# coding=utf-8
# --------------------------------------------------------------------------
# Copyright (c) Microsoft Corporation. All rights reserved.
# Licensed under the MIT License. See License.txt in the project root for
# license information.
#
# Code generated by Microsoft (R) AutoRest Code Generator.
# Changes may cause incorrect behavior and will be lost if the code is
# regenerated.
# --------------------------------------------------------------------------

from msrest.service_client import SDKClient
from msrest import Configuration, Serializer, Deserializer
from .version import VERSION
from msrest.pipeline import ClientRawResponse
from msrest.exceptions import HttpOperationError
from . import models


class SpeechServicesAPIv20Configuration(Configuration):
    """Configuration for SpeechServicesAPIv20
    Note that all parameters used to create this instance are saved as instance
    attributes.

    :param credentials: Subscription credentials which uniquely identify
     client subscription.
    :type credentials: None
    :param str base_url: Service URL
    """

    def __init__(
            self, credentials, base_url=None):

        if credentials is None:
            raise ValueError("Parameter 'credentials' must not be None.")
        if not base_url:
            base_url = 'https://westus.cris.ai'

        super(SpeechServicesAPIv20Configuration, self).__init__(base_url)

        self.add_user_agent('azure-cognitiveservices-speechservices/{}'.format(VERSION))

        self.credentials = credentials


class SpeechServicesAPIv20(SDKClient):
    """Speech Services API v2.0.

    :ivar config: Configuration for client.
    :vartype config: SpeechServicesAPIv20Configuration

    :param credentials: Subscription credentials which uniquely identify
     client subscription.
    :type credentials: None
    :param str base_url: Service URL
    """

    def __init__(
            self, credentials, base_url=None):

        self.config = SpeechServicesAPIv20Configuration(credentials, base_url)
        super(SpeechServicesAPIv20, self).__init__(self.config.credentials, self.config)

        client_models = {k: v for k, v in models.__dict__.items() if isinstance(v, type)}
        self.api_version = 'v2.0'
        self._serialize = Serializer(client_models)
        self._deserialize = Deserializer(client_models)


    def get_accuracy_tests(
            self, custom_headers=None, raw=False, **operation_config):
        """Gets the list of accuracy tests for the authenticated subscription.

        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :return: object or ClientRawResponse if raw=true
        :rtype: object or ~msrest.pipeline.ClientRawResponse
        :raises:
         :class:`HttpOperationError<msrest.exceptions.HttpOperationError>`
        """
        # Construct URL
        url = self.get_accuracy_tests.metadata['url']

        # Construct parameters
        query_parameters = {}

        # Construct headers
        header_parameters = {}
        header_parameters['Accept'] = 'application/json'
        if custom_headers:
            header_parameters.update(custom_headers)

        # Construct and send request
        request = self._client.get(url, query_parameters, header_parameters)
        response = self._client.send(request, stream=False, **operation_config)

        if response.status_code not in [200, 401, 403, 429]:
            raise HttpOperationError(self._deserialize, response)

        deserialized = None
        header_dict = {}

        if response.status_code == 200:
            deserialized = self._deserialize('[Test]', response)
            header_dict = {
                'X-RateLimit-Limit': 'int',
                'X-RateLimit-Remaining': 'int',
                'X-RateLimit-Reset': 'str',
                'Retry-After': 'int',
            }
        if response.status_code == 401:
            deserialized = self._deserialize('ErrorContent', response)
            header_dict = {
                'X-RateLimit-Limit': 'int',
                'X-RateLimit-Remaining': 'int',
                'X-RateLimit-Reset': 'str',
                'Retry-After': 'int',
            }
        if response.status_code == 403:
            deserialized = self._deserialize('ErrorContent', response)
            header_dict = {
                'X-RateLimit-Limit': 'int',
                'X-RateLimit-Remaining': 'int',
                'X-RateLimit-Reset': 'str',
                'Retry-After': 'int',
            }
        if response.status_code == 429:
            deserialized = self._deserialize('ErrorContent', response)
            header_dict = {
                'X-RateLimit-Limit': 'int',
                'X-RateLimit-Remaining': 'int',
                'X-RateLimit-Reset': 'str',
                'Retry-After': 'int',
            }

        if raw:
            client_raw_response = ClientRawResponse(deserialized, response)
            client_raw_response.add_headers(header_dict)
            return client_raw_response

        return deserialized
    get_accuracy_tests.metadata = {'url': '/api/speechtotext/v2.0/accuracytests'}

    def create_accuracy_test(
            self, test_definition, custom_headers=None, raw=False, **operation_config):
        """Creates a new accuracy test.

        :param test_definition: The details of the new accuracy test.
        :type test_definition:
         ~azure.cognitiveservices.speechservices.models.TestDefinition
        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :return: ErrorContent or ClientRawResponse if raw=true
        :rtype: ~azure.cognitiveservices.speechservices.models.ErrorContent or
         ~msrest.pipeline.ClientRawResponse
        :raises:
         :class:`HttpOperationError<msrest.exceptions.HttpOperationError>`
        """
        # Construct URL
        url = self.create_accuracy_test.metadata['url']

        # Construct parameters
        query_parameters = {}

        # Construct headers
        header_parameters = {}
        header_parameters['Accept'] = 'application/json'
        header_parameters['Content-Type'] = 'application/json; charset=utf-8'
        if custom_headers:
            header_parameters.update(custom_headers)

        # Construct body
        body_content = self._serialize.body(test_definition, 'TestDefinition')

        # Construct and send request
        request = self._client.post(url, query_parameters, header_parameters, body_content)
        response = self._client.send(request, stream=False, **operation_config)

        if response.status_code not in [401, 403, 415, 429]:
            raise HttpOperationError(self._deserialize, response)

        deserialized = None
        header_dict = {}

        if response.status_code == 401:
            deserialized = self._deserialize('ErrorContent', response)
            header_dict = {
                'X-RateLimit-Limit': 'int',
                'X-RateLimit-Remaining': 'int',
                'X-RateLimit-Reset': 'str',
                'Retry-After': 'int',
            }
        if response.status_code == 403:
            deserialized = self._deserialize('ErrorContent', response)
            header_dict = {
                'X-RateLimit-Limit': 'int',
                'X-RateLimit-Remaining': 'int',
                'X-RateLimit-Reset': 'str',
                'Retry-After': 'int',
            }
        if response.status_code == 415:
            deserialized = self._deserialize('ErrorContent', response)
            header_dict = {
                'X-RateLimit-Limit': 'int',
                'X-RateLimit-Remaining': 'int',
                'X-RateLimit-Reset': 'str',
                'Retry-After': 'int',
            }
        if response.status_code == 429:
            deserialized = self._deserialize('ErrorContent', response)
            header_dict = {
                'X-RateLimit-Limit': 'int',
                'X-RateLimit-Remaining': 'int',
                'X-RateLimit-Reset': 'str',
                'Retry-After': 'int',
            }

        if raw:
            client_raw_response = ClientRawResponse(deserialized, response)
            client_raw_response.add_headers(header_dict)
            return client_raw_response

        return deserialized
    create_accuracy_test.metadata = {'url': '/api/speechtotext/v2.0/accuracytests'}

    def get_accuracy_test(
            self, id, custom_headers=None, raw=False, **operation_config):
        """Gets the accuracy test identified by the given ID.

        :param id: The identifier of the accuracy test.
        :type id: str
        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :return: object or ClientRawResponse if raw=true
        :rtype: object or ~msrest.pipeline.ClientRawResponse
        :raises:
         :class:`HttpOperationError<msrest.exceptions.HttpOperationError>`
        """
        # Construct URL
        url = self.get_accuracy_test.metadata['url']
        path_format_arguments = {
            'id': self._serialize.url("id", id, 'str')
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}

        # Construct headers
        header_parameters = {}
        header_parameters['Accept'] = 'application/json'
        if custom_headers:
            header_parameters.update(custom_headers)

        # Construct and send request
        request = self._client.get(url, query_parameters, header_parameters)
        response = self._client.send(request, stream=False, **operation_config)

        if response.status_code not in [200, 401, 403, 404, 429]:
            raise HttpOperationError(self._deserialize, response)

        deserialized = None
        header_dict = {}

        if response.status_code == 200:
            deserialized = self._deserialize('Test', response)
            header_dict = {
                'Retry-After': 'int',
                'X-RateLimit-Limit': 'int',
                'X-RateLimit-Remaining': 'int',
                'X-RateLimit-Reset': 'str',
            }
        if response.status_code == 401:
            deserialized = self._deserialize('ErrorContent', response)
            header_dict = {
                'Retry-After': 'int',
                'X-RateLimit-Limit': 'int',
                'X-RateLimit-Remaining': 'int',
                'X-RateLimit-Reset': 'str',
            }
        if response.status_code == 403:
            deserialized = self._deserialize('ErrorContent', response)
            header_dict = {
                'Retry-After': 'int',
                'X-RateLimit-Limit': 'int',
                'X-RateLimit-Remaining': 'int',
                'X-RateLimit-Reset': 'str',
            }
        if response.status_code == 404:
            deserialized = self._deserialize('ErrorContent', response)
            header_dict = {
                'Retry-After': 'int',
                'X-RateLimit-Limit': 'int',
                'X-RateLimit-Remaining': 'int',
                'X-RateLimit-Reset': 'str',
            }
        if response.status_code == 429:
            deserialized = self._deserialize('ErrorContent', response)
            header_dict = {
                'Retry-After': 'int',
                'X-RateLimit-Limit': 'int',
                'X-RateLimit-Remaining': 'int',
                'X-RateLimit-Reset': 'str',
            }

        if raw:
            client_raw_response = ClientRawResponse(deserialized, response)
            client_raw_response.add_headers(header_dict)
            return client_raw_response

        return deserialized
    get_accuracy_test.metadata = {'url': '/api/speechtotext/v2.0/accuracytests/{id}'}

    def delete_accuracy_test(
            self, id, custom_headers=None, raw=False, **operation_config):
        """Deletes the accuracy test identified by the given ID.

        :param id: The identifier of the accuracy test.
        :type id: str
        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :return: ErrorContent or ClientRawResponse if raw=true
        :rtype: ~azure.cognitiveservices.speechservices.models.ErrorContent or
         ~msrest.pipeline.ClientRawResponse
        :raises:
         :class:`HttpOperationError<msrest.exceptions.HttpOperationError>`
        """
        # Construct URL
        url = self.delete_accuracy_test.metadata['url']
        path_format_arguments = {
            'id': self._serialize.url("id", id, 'str')
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}

        # Construct headers
        header_parameters = {}
        header_parameters['Accept'] = 'application/json'
        if custom_headers:
            header_parameters.update(custom_headers)

        # Construct and send request
        request = self._client.delete(url, query_parameters, header_parameters)
        response = self._client.send(request, stream=False, **operation_config)

        if response.status_code not in [204, 401, 403, 429]:
            raise HttpOperationError(self._deserialize, response)

        deserialized = None
        header_dict = {}

        if response.status_code == 401:
            deserialized = self._deserialize('ErrorContent', response)
            header_dict = {
                'X-RateLimit-Limit': 'int',
                'X-RateLimit-Remaining': 'int',
                'X-RateLimit-Reset': 'str',
                'Retry-After': 'int',
            }
        if response.status_code == 403:
            deserialized = self._deserialize('ErrorContent', response)
            header_dict = {
                'X-RateLimit-Limit': 'int',
                'X-RateLimit-Remaining': 'int',
                'X-RateLimit-Reset': 'str',
                'Retry-After': 'int',
            }
        if response.status_code == 429:
            deserialized = self._deserialize('ErrorContent', response)
            header_dict = {
                'X-RateLimit-Limit': 'int',
                'X-RateLimit-Remaining': 'int',
                'X-RateLimit-Reset': 'str',
                'Retry-After': 'int',
            }

        if raw:
            client_raw_response = ClientRawResponse(deserialized, response)
            client_raw_response.add_headers(header_dict)
            return client_raw_response

        return deserialized
    delete_accuracy_test.metadata = {'url': '/api/speechtotext/v2.0/accuracytests/{id}'}

    def update_accuracy_test(
            self, id, name, description=None, custom_headers=None, raw=False, **operation_config):
        """Updates the mutable details of the test identified by its id.

        :param id: The identifier of the accuracy test.
        :type id: str
        :param name: The name of the object
        :type name: str
        :param description: The description of the object
        :type description: str
        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :return: object or ClientRawResponse if raw=true
        :rtype: object or ~msrest.pipeline.ClientRawResponse
        :raises:
         :class:`HttpOperationError<msrest.exceptions.HttpOperationError>`
        """
        test_update = models.TestUpdate(name=name, description=description)

        # Construct URL
        url = self.update_accuracy_test.metadata['url']
        path_format_arguments = {
            'id': self._serialize.url("id", id, 'str')
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}

        # Construct headers
        header_parameters = {}
        header_parameters['Accept'] = 'application/json'
        header_parameters['Content-Type'] = 'application/json; charset=utf-8'
        if custom_headers:
            header_parameters.update(custom_headers)

        # Construct body
        body_content = self._serialize.body(test_update, 'TestUpdate')

        # Construct and send request
        request = self._client.patch(url, query_parameters, header_parameters, body_content)
        response = self._client.send(request, stream=False, **operation_config)

        if response.status_code not in [200, 400, 401, 403, 409, 415, 429]:
            raise HttpOperationError(self._deserialize, response)

        deserialized = None
        header_dict = {}

        if response.status_code == 200:
            deserialized = self._deserialize('Test', response)
            header_dict = {
                'X-RateLimit-Limit': 'int',
                'X-RateLimit-Remaining': 'int',
                'X-RateLimit-Reset': 'str',
                'Retry-After': 'int',
            }
        if response.status_code == 400:
            deserialized = self._deserialize('ErrorContent', response)
            header_dict = {
                'X-RateLimit-Limit': 'int',
                'X-RateLimit-Remaining': 'int',
                'X-RateLimit-Reset': 'str',
                'Retry-After': 'int',
            }
        if response.status_code == 401:
            deserialized = self._deserialize('ErrorContent', response)
            header_dict = {
                'X-RateLimit-Limit': 'int',
                'X-RateLimit-Remaining': 'int',
                'X-RateLimit-Reset': 'str',
                'Retry-After': 'int',
            }
        if response.status_code == 403:
            deserialized = self._deserialize('ErrorContent', response)
            header_dict = {
                'X-RateLimit-Limit': 'int',
                'X-RateLimit-Remaining': 'int',
                'X-RateLimit-Reset': 'str',
                'Retry-After': 'int',
            }
        if response.status_code == 409:
            deserialized = self._deserialize('ErrorContent', response)
            header_dict = {
                'X-RateLimit-Limit': 'int',
                'X-RateLimit-Remaining': 'int',
                'X-RateLimit-Reset': 'str',
                'Retry-After': 'int',
            }
        if response.status_code == 415:
            deserialized = self._deserialize('ErrorContent', response)
            header_dict = {
                'X-RateLimit-Limit': 'int',
                'X-RateLimit-Remaining': 'int',
                'X-RateLimit-Reset': 'str',
                'Retry-After': 'int',
            }
        if response.status_code == 429:
            deserialized = self._deserialize('ErrorContent', response)
            header_dict = {
                'X-RateLimit-Limit': 'int',
                'X-RateLimit-Remaining': 'int',
                'X-RateLimit-Reset': 'str',
                'Retry-After': 'int',
            }

        if raw:
            client_raw_response = ClientRawResponse(deserialized, response)
            client_raw_response.add_headers(header_dict)
            return client_raw_response

        return deserialized
    update_accuracy_test.metadata = {'url': '/api/speechtotext/v2.0/accuracytests/{id}'}

    def get_datasets(
            self, custom_headers=None, raw=False, **operation_config):
        """Gets a list of datasets for the authenticated subscription.

        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :return: object or ClientRawResponse if raw=true
        :rtype: object or ~msrest.pipeline.ClientRawResponse
        :raises:
         :class:`HttpOperationError<msrest.exceptions.HttpOperationError>`
        """
        # Construct URL
        url = self.get_datasets.metadata['url']

        # Construct parameters
        query_parameters = {}

        # Construct headers
        header_parameters = {}
        header_parameters['Accept'] = 'application/json'
        if custom_headers:
            header_parameters.update(custom_headers)

        # Construct and send request
        request = self._client.get(url, query_parameters, header_parameters)
        response = self._client.send(request, stream=False, **operation_config)

        if response.status_code not in [200, 401, 403, 429]:
            raise HttpOperationError(self._deserialize, response)

        deserialized = None
        header_dict = {}

        if response.status_code == 200:
            deserialized = self._deserialize('[Dataset]', response)
            header_dict = {
                'X-RateLimit-Limit': 'int',
                'X-RateLimit-Remaining': 'int',
                'X-RateLimit-Reset': 'str',
                'Retry-After': 'int',
            }
        if response.status_code == 401:
            deserialized = self._deserialize('ErrorContent', response)
            header_dict = {
                'X-RateLimit-Limit': 'int',
                'X-RateLimit-Remaining': 'int',
                'X-RateLimit-Reset': 'str',
                'Retry-After': 'int',
            }
        if response.status_code == 403:
            deserialized = self._deserialize('ErrorContent', response)
            header_dict = {
                'X-RateLimit-Limit': 'int',
                'X-RateLimit-Remaining': 'int',
                'X-RateLimit-Reset': 'str',
                'Retry-After': 'int',
            }
        if response.status_code == 429:
            deserialized = self._deserialize('ErrorContent', response)
            header_dict = {
                'X-RateLimit-Limit': 'int',
                'X-RateLimit-Remaining': 'int',
                'X-RateLimit-Reset': 'str',
                'Retry-After': 'int',
            }

        if raw:
            client_raw_response = ClientRawResponse(deserialized, response)
            client_raw_response.add_headers(header_dict)
            return client_raw_response

        return deserialized
    get_datasets.metadata = {'url': '/api/speechtotext/v2.0/datasets'}

    def get_dataset(
            self, id, custom_headers=None, raw=False, **operation_config):
        """Gets the dataset identified by the given ID.

        :param id: The identifier of the dataset.
        :type id: str
        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :return: object or ClientRawResponse if raw=true
        :rtype: object or ~msrest.pipeline.ClientRawResponse
        :raises:
         :class:`HttpOperationError<msrest.exceptions.HttpOperationError>`
        """
        # Construct URL
        url = self.get_dataset.metadata['url']
        path_format_arguments = {
            'id': self._serialize.url("id", id, 'str')
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}

        # Construct headers
        header_parameters = {}
        header_parameters['Accept'] = 'application/json'
        if custom_headers:
            header_parameters.update(custom_headers)

        # Construct and send request
        request = self._client.get(url, query_parameters, header_parameters)
        response = self._client.send(request, stream=False, **operation_config)

        if response.status_code not in [200, 401, 403, 404, 429]:
            raise HttpOperationError(self._deserialize, response)

        deserialized = None
        header_dict = {}

        if response.status_code == 200:
            deserialized = self._deserialize('Dataset', response)
            header_dict = {
                'Retry-After': 'int',
                'X-RateLimit-Limit': 'int',
                'X-RateLimit-Remaining': 'int',
                'X-RateLimit-Reset': 'str',
            }
        if response.status_code == 401:
            deserialized = self._deserialize('ErrorContent', response)
            header_dict = {
                'Retry-After': 'int',
                'X-RateLimit-Limit': 'int',
                'X-RateLimit-Remaining': 'int',
                'X-RateLimit-Reset': 'str',
            }
        if response.status_code == 403:
            deserialized = self._deserialize('ErrorContent', response)
            header_dict = {
                'Retry-After': 'int',
                'X-RateLimit-Limit': 'int',
                'X-RateLimit-Remaining': 'int',
                'X-RateLimit-Reset': 'str',
            }
        if response.status_code == 404:
            deserialized = self._deserialize('ErrorContent', response)
            header_dict = {
                'Retry-After': 'int',
                'X-RateLimit-Limit': 'int',
                'X-RateLimit-Remaining': 'int',
                'X-RateLimit-Reset': 'str',
            }
        if response.status_code == 429:
            deserialized = self._deserialize('ErrorContent', response)
            header_dict = {
                'Retry-After': 'int',
                'X-RateLimit-Limit': 'int',
                'X-RateLimit-Remaining': 'int',
                'X-RateLimit-Reset': 'str',
            }

        if raw:
            client_raw_response = ClientRawResponse(deserialized, response)
            client_raw_response.add_headers(header_dict)
            return client_raw_response

        return deserialized
    get_dataset.metadata = {'url': '/api/speechtotext/v2.0/datasets/{id}'}

    def delete_dataset(
            self, id, custom_headers=None, raw=False, **operation_config):
        """Deletes the specified dataset.

        :param id: The identifier of the dataset.
        :type id: str
        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :return: ErrorContent or ClientRawResponse if raw=true
        :rtype: ~azure.cognitiveservices.speechservices.models.ErrorContent or
         ~msrest.pipeline.ClientRawResponse
        :raises:
         :class:`HttpOperationError<msrest.exceptions.HttpOperationError>`
        """
        # Construct URL
        url = self.delete_dataset.metadata['url']
        path_format_arguments = {
            'id': self._serialize.url("id", id, 'str')
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}

        # Construct headers
        header_parameters = {}
        header_parameters['Accept'] = 'application/json'
        if custom_headers:
            header_parameters.update(custom_headers)

        # Construct and send request
        request = self._client.delete(url, query_parameters, header_parameters)
        response = self._client.send(request, stream=False, **operation_config)

        if response.status_code not in [204, 401, 403, 405, 429]:
            raise HttpOperationError(self._deserialize, response)

        deserialized = None
        header_dict = {}

        if response.status_code == 401:
            deserialized = self._deserialize('ErrorContent', response)
            header_dict = {
                'X-RateLimit-Limit': 'int',
                'X-RateLimit-Remaining': 'int',
                'X-RateLimit-Reset': 'str',
                'Retry-After': 'int',
            }
        if response.status_code == 403:
            deserialized = self._deserialize('ErrorContent', response)
            header_dict = {
                'X-RateLimit-Limit': 'int',
                'X-RateLimit-Remaining': 'int',
                'X-RateLimit-Reset': 'str',
                'Retry-After': 'int',
            }
        if response.status_code == 405:
            deserialized = self._deserialize('ErrorContent', response)
            header_dict = {
                'X-RateLimit-Limit': 'int',
                'X-RateLimit-Remaining': 'int',
                'X-RateLimit-Reset': 'str',
                'Retry-After': 'int',
            }
        if response.status_code == 429:
            deserialized = self._deserialize('ErrorContent', response)
            header_dict = {
                'X-RateLimit-Limit': 'int',
                'X-RateLimit-Remaining': 'int',
                'X-RateLimit-Reset': 'str',
                'Retry-After': 'int',
            }

        if raw:
            client_raw_response = ClientRawResponse(deserialized, response)
            client_raw_response.add_headers(header_dict)
            return client_raw_response

        return deserialized
    delete_dataset.metadata = {'url': '/api/speechtotext/v2.0/datasets/{id}'}

    def update_dataset(
            self, id, name, description=None, custom_headers=None, raw=False, **operation_config):
        """Updates the mutable details of the dataset identified by its ID.

        :param id: The identifier of the dataset.
        :type id: str
        :param name: The name of the object
        :type name: str
        :param description: The description of the object
        :type description: str
        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :return: object or ClientRawResponse if raw=true
        :rtype: object or ~msrest.pipeline.ClientRawResponse
        :raises:
         :class:`HttpOperationError<msrest.exceptions.HttpOperationError>`
        """
        dataset_update = models.DatasetUpdate(name=name, description=description)

        # Construct URL
        url = self.update_dataset.metadata['url']
        path_format_arguments = {
            'id': self._serialize.url("id", id, 'str')
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}

        # Construct headers
        header_parameters = {}
        header_parameters['Accept'] = 'application/json'
        header_parameters['Content-Type'] = 'application/json; charset=utf-8'
        if custom_headers:
            header_parameters.update(custom_headers)

        # Construct body
        body_content = self._serialize.body(dataset_update, 'DatasetUpdate')

        # Construct and send request
        request = self._client.patch(url, query_parameters, header_parameters, body_content)
        response = self._client.send(request, stream=False, **operation_config)

        if response.status_code not in [200, 400, 401, 403, 409, 415, 429]:
            raise HttpOperationError(self._deserialize, response)

        deserialized = None
        header_dict = {}

        if response.status_code == 200:
            deserialized = self._deserialize('Dataset', response)
            header_dict = {
                'X-RateLimit-Limit': 'int',
                'X-RateLimit-Remaining': 'int',
                'X-RateLimit-Reset': 'str',
                'Retry-After': 'int',
            }
        if response.status_code == 400:
            deserialized = self._deserialize('ErrorContent', response)
            header_dict = {
                'X-RateLimit-Limit': 'int',
                'X-RateLimit-Remaining': 'int',
                'X-RateLimit-Reset': 'str',
                'Retry-After': 'int',
            }
        if response.status_code == 401:
            deserialized = self._deserialize('ErrorContent', response)
            header_dict = {
                'X-RateLimit-Limit': 'int',
                'X-RateLimit-Remaining': 'int',
                'X-RateLimit-Reset': 'str',
                'Retry-After': 'int',
            }
        if response.status_code == 403:
            deserialized = self._deserialize('ErrorContent', response)
            header_dict = {
                'X-RateLimit-Limit': 'int',
                'X-RateLimit-Remaining': 'int',
                'X-RateLimit-Reset': 'str',
                'Retry-After': 'int',
            }
        if response.status_code == 409:
            deserialized = self._deserialize('ErrorContent', response)
            header_dict = {
                'X-RateLimit-Limit': 'int',
                'X-RateLimit-Remaining': 'int',
                'X-RateLimit-Reset': 'str',
                'Retry-After': 'int',
            }
        if response.status_code == 415:
            deserialized = self._deserialize('ErrorContent', response)
            header_dict = {
                'X-RateLimit-Limit': 'int',
                'X-RateLimit-Remaining': 'int',
                'X-RateLimit-Reset': 'str',
                'Retry-After': 'int',
            }
        if response.status_code == 429:
            deserialized = self._deserialize('ErrorContent', response)
            header_dict = {
                'X-RateLimit-Limit': 'int',
                'X-RateLimit-Remaining': 'int',
                'X-RateLimit-Reset': 'str',
                'Retry-After': 'int',
            }

        if raw:
            client_raw_response = ClientRawResponse(deserialized, response)
            client_raw_response.add_headers(header_dict)
            return client_raw_response

        return deserialized
    update_dataset.metadata = {'url': '/api/speechtotext/v2.0/datasets/{id}'}

    def get_supported_locales_for_datasets(
            self, custom_headers=None, raw=False, **operation_config):
        """Gets a list of supported locales for data imports.

        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :return: object or ClientRawResponse if raw=true
        :rtype: object or ~msrest.pipeline.ClientRawResponse
        :raises:
         :class:`HttpOperationError<msrest.exceptions.HttpOperationError>`
        """
        # Construct URL
        url = self.get_supported_locales_for_datasets.metadata['url']

        # Construct parameters
        query_parameters = {}

        # Construct headers
        header_parameters = {}
        header_parameters['Accept'] = 'application/json'
        if custom_headers:
            header_parameters.update(custom_headers)

        # Construct and send request
        request = self._client.get(url, query_parameters, header_parameters)
        response = self._client.send(request, stream=False, **operation_config)

        if response.status_code not in [200, 401, 403, 429]:
            raise HttpOperationError(self._deserialize, response)

        deserialized = None
        header_dict = {}

        if response.status_code == 200:
            deserialized = self._deserialize('GetSupportedLocalesForDatasetsOKResponse', response)
            header_dict = {
                'X-RateLimit-Limit': 'int',
                'X-RateLimit-Remaining': 'int',
                'X-RateLimit-Reset': 'str',
                'Retry-After': 'int',
            }
        if response.status_code == 401:
            deserialized = self._deserialize('ErrorContent', response)
            header_dict = {
                'X-RateLimit-Limit': 'int',
                'X-RateLimit-Remaining': 'int',
                'X-RateLimit-Reset': 'str',
                'Retry-After': 'int',
            }
        if response.status_code == 403:
            deserialized = self._deserialize('ErrorContent', response)
            header_dict = {
                'X-RateLimit-Limit': 'int',
                'X-RateLimit-Remaining': 'int',
                'X-RateLimit-Reset': 'str',
                'Retry-After': 'int',
            }
        if response.status_code == 429:
            deserialized = self._deserialize('ErrorContent', response)
            header_dict = {
                'X-RateLimit-Limit': 'int',
                'X-RateLimit-Remaining': 'int',
                'X-RateLimit-Reset': 'str',
                'Retry-After': 'int',
            }

        if raw:
            client_raw_response = ClientRawResponse(deserialized, response)
            client_raw_response.add_headers(header_dict)
            return client_raw_response

        return deserialized
    get_supported_locales_for_datasets.metadata = {'url': '/api/speechtotext/v2.0/datasets/locales'}

    def upload_dataset(
            self, name=None, description=None, locale=None, data_import_kind=None, properties=None, audiodata=None, transcriptions=None, languagedata=None, custom_headers=None, raw=False, **operation_config):
        """Uploads data and creates a new dataset.

        :param name: The name of this data import (always add this string for
         any import).
        :type name: str
        :param description: Optional description of this data import.
        :type description: str
        :param locale: The locale of this data import (always add this string
         for any import).
        :type locale: str
        :param data_import_kind: The kind of the data import (always add this
         string for any import). Possible values include: 'None', 'Language',
         'Acoustic', 'Pronunciation', 'CustomVoice', 'LanguageGeneration'
        :type data_import_kind: str
        :param properties: Optional properties of this data import (json
         serialized object with key/values, where all values must be strings)
        :type properties: str
        :param audiodata: A zip file containing the audio data (this and the
         audio archive file for acoustic data imports).
        :type audiodata: Generator
        :param transcriptions: A text file containing the transcriptions for
         the audio data (this and the transcriptions file for acoustic data
         imports).
        :type transcriptions: Generator
        :param languagedata: A text file containing the language or
         pronunciation data (only this file for language data imports).
        :type languagedata: Generator
        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :return: ErrorContent or ClientRawResponse if raw=true
        :rtype: ~azure.cognitiveservices.speechservices.models.ErrorContent or
         ~msrest.pipeline.ClientRawResponse
        :raises:
         :class:`HttpOperationError<msrest.exceptions.HttpOperationError>`
        """
        # Construct URL
        url = self.upload_dataset.metadata['url']

        # Construct parameters
        query_parameters = {}

        # Construct headers
        header_parameters = {}
        header_parameters['Accept'] = 'application/json'
        header_parameters['Content-Type'] = 'multipart/form-data'
        if custom_headers:
            header_parameters.update(custom_headers)

        # Construct form data
        form_data_content = {
            'name': name,
            'description': description,
            'locale': locale,
            'dataImportKind': data_import_kind,
            'properties': properties,
            'audiodata': audiodata,
            'transcriptions': transcriptions,
            'languagedata': languagedata,
        }

        # Construct and send request
        request = self._client.post(url, query_parameters, header_parameters, form_content=form_data_content)
        response = self._client.send(request, stream=False, **operation_config)

        if response.status_code not in [202, 400, 401, 403, 415, 429]:
            raise HttpOperationError(self._deserialize, response)

        deserialized = None
        header_dict = {}

        if response.status_code == 400:
            deserialized = self._deserialize('ErrorContent', response)
            header_dict = {
                'Location': 'str',
                'Operation-Location': 'str',
                'Retry-After': 'int',
                'X-RateLimit-Limit': 'int',
                'X-RateLimit-Remaining': 'int',
                'X-RateLimit-Reset': 'str',
            }
        if response.status_code == 401:
            deserialized = self._deserialize('ErrorContent', response)
            header_dict = {
                'Location': 'str',
                'Operation-Location': 'str',
                'Retry-After': 'int',
                'X-RateLimit-Limit': 'int',
                'X-RateLimit-Remaining': 'int',
                'X-RateLimit-Reset': 'str',
            }
        if response.status_code == 403:
            deserialized = self._deserialize('ErrorContent', response)
            header_dict = {
                'Location': 'str',
                'Operation-Location': 'str',
                'Retry-After': 'int',
                'X-RateLimit-Limit': 'int',
                'X-RateLimit-Remaining': 'int',
                'X-RateLimit-Reset': 'str',
            }
        if response.status_code == 415:
            deserialized = self._deserialize('ErrorContent', response)
            header_dict = {
                'Location': 'str',
                'Operation-Location': 'str',
                'Retry-After': 'int',
                'X-RateLimit-Limit': 'int',
                'X-RateLimit-Remaining': 'int',
                'X-RateLimit-Reset': 'str',
            }
        if response.status_code == 429:
            deserialized = self._deserialize('ErrorContent', response)
            header_dict = {
                'Location': 'str',
                'Operation-Location': 'str',
                'Retry-After': 'int',
                'X-RateLimit-Limit': 'int',
                'X-RateLimit-Remaining': 'int',
                'X-RateLimit-Reset': 'str',
            }

        if raw:
            client_raw_response = ClientRawResponse(deserialized, response)
            client_raw_response.add_headers(header_dict)
            return client_raw_response

        return deserialized
    upload_dataset.metadata = {'url': '/api/speechtotext/v2.0/datasets/upload'}

    def get_endpoints(
            self, custom_headers=None, raw=False, **operation_config):
        """Gets the list of endpoints for the authenticated subscription.

        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :return: object or ClientRawResponse if raw=true
        :rtype: object or ~msrest.pipeline.ClientRawResponse
        :raises:
         :class:`HttpOperationError<msrest.exceptions.HttpOperationError>`
        """
        # Construct URL
        url = self.get_endpoints.metadata['url']

        # Construct parameters
        query_parameters = {}

        # Construct headers
        header_parameters = {}
        header_parameters['Accept'] = 'application/json'
        if custom_headers:
            header_parameters.update(custom_headers)

        # Construct and send request
        request = self._client.get(url, query_parameters, header_parameters)
        response = self._client.send(request, stream=False, **operation_config)

        if response.status_code not in [200, 401, 403, 429]:
            raise HttpOperationError(self._deserialize, response)

        deserialized = None
        header_dict = {}

        if response.status_code == 200:
            deserialized = self._deserialize('[Endpoint]', response)
            header_dict = {
                'X-RateLimit-Limit': 'int',
                'X-RateLimit-Remaining': 'int',
                'X-RateLimit-Reset': 'str',
                'Retry-After': 'int',
            }
        if response.status_code == 401:
            deserialized = self._deserialize('ErrorContent', response)
            header_dict = {
                'X-RateLimit-Limit': 'int',
                'X-RateLimit-Remaining': 'int',
                'X-RateLimit-Reset': 'str',
                'Retry-After': 'int',
            }
        if response.status_code == 403:
            deserialized = self._deserialize('ErrorContent', response)
            header_dict = {
                'X-RateLimit-Limit': 'int',
                'X-RateLimit-Remaining': 'int',
                'X-RateLimit-Reset': 'str',
                'Retry-After': 'int',
            }
        if response.status_code == 429:
            deserialized = self._deserialize('ErrorContent', response)
            header_dict = {
                'X-RateLimit-Limit': 'int',
                'X-RateLimit-Remaining': 'int',
                'X-RateLimit-Reset': 'str',
                'Retry-After': 'int',
            }

        if raw:
            client_raw_response = ClientRawResponse(deserialized, response)
            client_raw_response.add_headers(header_dict)
            return client_raw_response

        return deserialized
    get_endpoints.metadata = {'url': '/api/speechtotext/v2.0/endpoints'}

    def create_endpoint(
            self, endpoint_definition, custom_headers=None, raw=False, **operation_config):
        """Creates a new endpoint.

        :param endpoint_definition: The details of the endpoint.
        :type endpoint_definition:
         ~azure.cognitiveservices.speechservices.models.SpeechEndpointDefinition
        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :return: ErrorContent or ClientRawResponse if raw=true
        :rtype: ~azure.cognitiveservices.speechservices.models.ErrorContent or
         ~msrest.pipeline.ClientRawResponse
        :raises:
         :class:`HttpOperationError<msrest.exceptions.HttpOperationError>`
        """
        # Construct URL
        url = self.create_endpoint.metadata['url']

        # Construct parameters
        query_parameters = {}

        # Construct headers
        header_parameters = {}
        header_parameters['Accept'] = 'application/json'
        header_parameters['Content-Type'] = 'application/json; charset=utf-8'
        if custom_headers:
            header_parameters.update(custom_headers)

        # Construct body
        body_content = self._serialize.body(endpoint_definition, 'SpeechEndpointDefinition')

        # Construct and send request
        request = self._client.post(url, query_parameters, header_parameters, body_content)
        response = self._client.send(request, stream=False, **operation_config)

        if response.status_code not in [202, 400, 401, 403, 415, 429, 503]:
            raise HttpOperationError(self._deserialize, response)

        deserialized = None
        header_dict = {}

        if response.status_code == 400:
            deserialized = self._deserialize('ErrorContent', response)
            header_dict = {
                'Location': 'str',
                'Operation-Location': 'str',
                'Retry-After': 'int',
                'X-RateLimit-Limit': 'int',
                'X-RateLimit-Remaining': 'int',
                'X-RateLimit-Reset': 'str',
            }
        if response.status_code == 401:
            deserialized = self._deserialize('ErrorContent', response)
            header_dict = {
                'Location': 'str',
                'Operation-Location': 'str',
                'Retry-After': 'int',
                'X-RateLimit-Limit': 'int',
                'X-RateLimit-Remaining': 'int',
                'X-RateLimit-Reset': 'str',
            }
        if response.status_code == 403:
            deserialized = self._deserialize('ErrorContent', response)
            header_dict = {
                'Location': 'str',
                'Operation-Location': 'str',
                'Retry-After': 'int',
                'X-RateLimit-Limit': 'int',
                'X-RateLimit-Remaining': 'int',
                'X-RateLimit-Reset': 'str',
            }
        if response.status_code == 415:
            deserialized = self._deserialize('ErrorContent', response)
            header_dict = {
                'Location': 'str',
                'Operation-Location': 'str',
                'Retry-After': 'int',
                'X-RateLimit-Limit': 'int',
                'X-RateLimit-Remaining': 'int',
                'X-RateLimit-Reset': 'str',
            }
        if response.status_code == 429:
            deserialized = self._deserialize('ErrorContent', response)
            header_dict = {
                'Location': 'str',
                'Operation-Location': 'str',
                'Retry-After': 'int',
                'X-RateLimit-Limit': 'int',
                'X-RateLimit-Remaining': 'int',
                'X-RateLimit-Reset': 'str',
            }
        if response.status_code == 503:
            deserialized = self._deserialize('ErrorContent', response)
            header_dict = {
                'Location': 'str',
                'Operation-Location': 'str',
                'Retry-After': 'int',
                'X-RateLimit-Limit': 'int',
                'X-RateLimit-Remaining': 'int',
                'X-RateLimit-Reset': 'str',
            }

        if raw:
            client_raw_response = ClientRawResponse(deserialized, response)
            client_raw_response.add_headers(header_dict)
            return client_raw_response

        return deserialized
    create_endpoint.metadata = {'url': '/api/speechtotext/v2.0/endpoints'}

    def get_endpoint(
            self, id, custom_headers=None, raw=False, **operation_config):
        """Gets the endpoint identified by the given ID.

        :param id: The identifier of the endpoint.
        :type id: str
        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :return: object or ClientRawResponse if raw=true
        :rtype: object or ~msrest.pipeline.ClientRawResponse
        :raises:
         :class:`HttpOperationError<msrest.exceptions.HttpOperationError>`
        """
        # Construct URL
        url = self.get_endpoint.metadata['url']
        path_format_arguments = {
            'id': self._serialize.url("id", id, 'str')
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}

        # Construct headers
        header_parameters = {}
        header_parameters['Accept'] = 'application/json'
        if custom_headers:
            header_parameters.update(custom_headers)

        # Construct and send request
        request = self._client.get(url, query_parameters, header_parameters)
        response = self._client.send(request, stream=False, **operation_config)

        if response.status_code not in [200, 401, 403, 404, 429]:
            raise HttpOperationError(self._deserialize, response)

        deserialized = None
        header_dict = {}

        if response.status_code == 200:
            deserialized = self._deserialize('Endpoint', response)
            header_dict = {
                'Retry-After': 'int',
                'X-RateLimit-Limit': 'int',
                'X-RateLimit-Remaining': 'int',
                'X-RateLimit-Reset': 'str',
            }
        if response.status_code == 401:
            deserialized = self._deserialize('ErrorContent', response)
            header_dict = {
                'Retry-After': 'int',
                'X-RateLimit-Limit': 'int',
                'X-RateLimit-Remaining': 'int',
                'X-RateLimit-Reset': 'str',
            }
        if response.status_code == 403:
            deserialized = self._deserialize('ErrorContent', response)
            header_dict = {
                'Retry-After': 'int',
                'X-RateLimit-Limit': 'int',
                'X-RateLimit-Remaining': 'int',
                'X-RateLimit-Reset': 'str',
            }
        if response.status_code == 404:
            deserialized = self._deserialize('ErrorContent', response)
            header_dict = {
                'Retry-After': 'int',
                'X-RateLimit-Limit': 'int',
                'X-RateLimit-Remaining': 'int',
                'X-RateLimit-Reset': 'str',
            }
        if response.status_code == 429:
            deserialized = self._deserialize('ErrorContent', response)
            header_dict = {
                'Retry-After': 'int',
                'X-RateLimit-Limit': 'int',
                'X-RateLimit-Remaining': 'int',
                'X-RateLimit-Reset': 'str',
            }

        if raw:
            client_raw_response = ClientRawResponse(deserialized, response)
            client_raw_response.add_headers(header_dict)
            return client_raw_response

        return deserialized
    get_endpoint.metadata = {'url': '/api/speechtotext/v2.0/endpoints/{id}'}

    def delete_endpoint(
            self, id, custom_headers=None, raw=False, **operation_config):
        """Deletes the endpoint identified by the given ID.

        :param id: The identifier of the endpoint.
        :type id: str
        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :return: ErrorContent or ClientRawResponse if raw=true
        :rtype: ~azure.cognitiveservices.speechservices.models.ErrorContent or
         ~msrest.pipeline.ClientRawResponse
        :raises:
         :class:`HttpOperationError<msrest.exceptions.HttpOperationError>`
        """
        # Construct URL
        url = self.delete_endpoint.metadata['url']
        path_format_arguments = {
            'id': self._serialize.url("id", id, 'str')
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}

        # Construct headers
        header_parameters = {}
        header_parameters['Accept'] = 'application/json'
        if custom_headers:
            header_parameters.update(custom_headers)

        # Construct and send request
        request = self._client.delete(url, query_parameters, header_parameters)
        response = self._client.send(request, stream=False, **operation_config)

        if response.status_code not in [204, 401, 403, 429]:
            raise HttpOperationError(self._deserialize, response)

        deserialized = None
        header_dict = {}

        if response.status_code == 401:
            deserialized = self._deserialize('ErrorContent', response)
            header_dict = {
                'X-RateLimit-Limit': 'int',
                'X-RateLimit-Remaining': 'int',
                'X-RateLimit-Reset': 'str',
                'Retry-After': 'int',
            }
        if response.status_code == 403:
            deserialized = self._deserialize('ErrorContent', response)
            header_dict = {
                'X-RateLimit-Limit': 'int',
                'X-RateLimit-Remaining': 'int',
                'X-RateLimit-Reset': 'str',
                'Retry-After': 'int',
            }
        if response.status_code == 429:
            deserialized = self._deserialize('ErrorContent', response)
            header_dict = {
                'X-RateLimit-Limit': 'int',
                'X-RateLimit-Remaining': 'int',
                'X-RateLimit-Reset': 'str',
                'Retry-After': 'int',
            }

        if raw:
            client_raw_response = ClientRawResponse(deserialized, response)
            client_raw_response.add_headers(header_dict)
            return client_raw_response

        return deserialized
    delete_endpoint.metadata = {'url': '/api/speechtotext/v2.0/endpoints/{id}'}

    def update_endpoint(
            self, id, name, description=None, custom_headers=None, raw=False, **operation_config):
        """Updates the metadata of the endpoint identified by the given ID.

        :param id: The identifier of the endpoint.
        :type id: str
        :param name: The name of the object
        :type name: str
        :param description: The description of the object
        :type description: str
        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :return: object or ClientRawResponse if raw=true
        :rtype: object or ~msrest.pipeline.ClientRawResponse
        :raises:
         :class:`HttpOperationError<msrest.exceptions.HttpOperationError>`
        """
        endpoint_update = models.EndpointUpdate(name=name, description=description)

        # Construct URL
        url = self.update_endpoint.metadata['url']
        path_format_arguments = {
            'id': self._serialize.url("id", id, 'str')
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}

        # Construct headers
        header_parameters = {}
        header_parameters['Accept'] = 'application/json'
        header_parameters['Content-Type'] = 'application/json; charset=utf-8'
        if custom_headers:
            header_parameters.update(custom_headers)

        # Construct body
        body_content = self._serialize.body(endpoint_update, 'EndpointUpdate')

        # Construct and send request
        request = self._client.patch(url, query_parameters, header_parameters, body_content)
        response = self._client.send(request, stream=False, **operation_config)

        if response.status_code not in [200, 400, 401, 403, 409, 415, 429]:
            raise HttpOperationError(self._deserialize, response)

        deserialized = None
        header_dict = {}

        if response.status_code == 200:
            deserialized = self._deserialize('Endpoint', response)
            header_dict = {
                'X-RateLimit-Limit': 'int',
                'X-RateLimit-Remaining': 'int',
                'X-RateLimit-Reset': 'str',
                'Retry-After': 'int',
            }
        if response.status_code == 400:
            deserialized = self._deserialize('ErrorContent', response)
            header_dict = {
                'X-RateLimit-Limit': 'int',
                'X-RateLimit-Remaining': 'int',
                'X-RateLimit-Reset': 'str',
                'Retry-After': 'int',
            }
        if response.status_code == 401:
            deserialized = self._deserialize('ErrorContent', response)
            header_dict = {
                'X-RateLimit-Limit': 'int',
                'X-RateLimit-Remaining': 'int',
                'X-RateLimit-Reset': 'str',
                'Retry-After': 'int',
            }
        if response.status_code == 403:
            deserialized = self._deserialize('ErrorContent', response)
            header_dict = {
                'X-RateLimit-Limit': 'int',
                'X-RateLimit-Remaining': 'int',
                'X-RateLimit-Reset': 'str',
                'Retry-After': 'int',
            }
        if response.status_code == 409:
            deserialized = self._deserialize('ErrorContent', response)
            header_dict = {
                'X-RateLimit-Limit': 'int',
                'X-RateLimit-Remaining': 'int',
                'X-RateLimit-Reset': 'str',
                'Retry-After': 'int',
            }
        if response.status_code == 415:
            deserialized = self._deserialize('ErrorContent', response)
            header_dict = {
                'X-RateLimit-Limit': 'int',
                'X-RateLimit-Remaining': 'int',
                'X-RateLimit-Reset': 'str',
                'Retry-After': 'int',
            }
        if response.status_code == 429:
            deserialized = self._deserialize('ErrorContent', response)
            header_dict = {
                'X-RateLimit-Limit': 'int',
                'X-RateLimit-Remaining': 'int',
                'X-RateLimit-Reset': 'str',
                'Retry-After': 'int',
            }

        if raw:
            client_raw_response = ClientRawResponse(deserialized, response)
            client_raw_response.add_headers(header_dict)
            return client_raw_response

        return deserialized
    update_endpoint.metadata = {'url': '/api/speechtotext/v2.0/endpoints/{id}'}

    def get_supported_locales_for_endpoints(
            self, custom_headers=None, raw=False, **operation_config):
        """Gets a list of supported locales for endpoint creations.

        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :return: object or ClientRawResponse if raw=true
        :rtype: object or ~msrest.pipeline.ClientRawResponse
        :raises:
         :class:`HttpOperationError<msrest.exceptions.HttpOperationError>`
        """
        # Construct URL
        url = self.get_supported_locales_for_endpoints.metadata['url']

        # Construct parameters
        query_parameters = {}

        # Construct headers
        header_parameters = {}
        header_parameters['Accept'] = 'application/json'
        if custom_headers:
            header_parameters.update(custom_headers)

        # Construct and send request
        request = self._client.get(url, query_parameters, header_parameters)
        response = self._client.send(request, stream=False, **operation_config)

        if response.status_code not in [200, 401, 403, 429]:
            raise HttpOperationError(self._deserialize, response)

        deserialized = None
        header_dict = {}

        if response.status_code == 200:
            deserialized = self._deserialize('[str]', response)
            header_dict = {
                'X-RateLimit-Limit': 'int',
                'X-RateLimit-Remaining': 'int',
                'X-RateLimit-Reset': 'str',
                'Retry-After': 'int',
            }
        if response.status_code == 401:
            deserialized = self._deserialize('ErrorContent', response)
            header_dict = {
                'X-RateLimit-Limit': 'int',
                'X-RateLimit-Remaining': 'int',
                'X-RateLimit-Reset': 'str',
                'Retry-After': 'int',
            }
        if response.status_code == 403:
            deserialized = self._deserialize('ErrorContent', response)
            header_dict = {
                'X-RateLimit-Limit': 'int',
                'X-RateLimit-Remaining': 'int',
                'X-RateLimit-Reset': 'str',
                'Retry-After': 'int',
            }
        if response.status_code == 429:
            deserialized = self._deserialize('ErrorContent', response)
            header_dict = {
                'X-RateLimit-Limit': 'int',
                'X-RateLimit-Remaining': 'int',
                'X-RateLimit-Reset': 'str',
                'Retry-After': 'int',
            }

        if raw:
            client_raw_response = ClientRawResponse(deserialized, response)
            client_raw_response.add_headers(header_dict)
            return client_raw_response

        return deserialized
    get_supported_locales_for_endpoints.metadata = {'url': '/api/speechtotext/v2.0/endpoints/locales'}

    def get_endpoint_data_exports(
            self, endpoint_id, custom_headers=None, raw=False, **operation_config):
        """Gets the list of endpoint data export tasks for the authenticated user.

        :param endpoint_id: The identifier of the endpoint.
        :type endpoint_id: str
        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :return: object or ClientRawResponse if raw=true
        :rtype: object or ~msrest.pipeline.ClientRawResponse
        :raises:
         :class:`HttpOperationError<msrest.exceptions.HttpOperationError>`
        """
        # Construct URL
        url = self.get_endpoint_data_exports.metadata['url']
        path_format_arguments = {
            'endpointId': self._serialize.url("endpoint_id", endpoint_id, 'str')
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}

        # Construct headers
        header_parameters = {}
        header_parameters['Accept'] = 'application/json'
        if custom_headers:
            header_parameters.update(custom_headers)

        # Construct and send request
        request = self._client.get(url, query_parameters, header_parameters)
        response = self._client.send(request, stream=False, **operation_config)

        if response.status_code not in [200, 401, 403, 404, 429]:
            raise HttpOperationError(self._deserialize, response)

        deserialized = None
        header_dict = {}

        if response.status_code == 200:
            deserialized = self._deserialize('[EndpointData]', response)
            header_dict = {
                'Retry-After': 'int',
                'X-RateLimit-Limit': 'int',
                'X-RateLimit-Remaining': 'int',
                'X-RateLimit-Reset': 'str',
            }
        if response.status_code == 401:
            deserialized = self._deserialize('ErrorContent', response)
            header_dict = {
                'Retry-After': 'int',
                'X-RateLimit-Limit': 'int',
                'X-RateLimit-Remaining': 'int',
                'X-RateLimit-Reset': 'str',
            }
        if response.status_code == 403:
            deserialized = self._deserialize('ErrorContent', response)
            header_dict = {
                'Retry-After': 'int',
                'X-RateLimit-Limit': 'int',
                'X-RateLimit-Remaining': 'int',
                'X-RateLimit-Reset': 'str',
            }
        if response.status_code == 404:
            deserialized = self._deserialize('ErrorContent', response)
            header_dict = {
                'Retry-After': 'int',
                'X-RateLimit-Limit': 'int',
                'X-RateLimit-Remaining': 'int',
                'X-RateLimit-Reset': 'str',
            }
        if response.status_code == 429:
            deserialized = self._deserialize('ErrorContent', response)
            header_dict = {
                'Retry-After': 'int',
                'X-RateLimit-Limit': 'int',
                'X-RateLimit-Remaining': 'int',
                'X-RateLimit-Reset': 'str',
            }

        if raw:
            client_raw_response = ClientRawResponse(deserialized, response)
            client_raw_response.add_headers(header_dict)
            return client_raw_response

        return deserialized
    get_endpoint_data_exports.metadata = {'url': '/api/speechtotext/v2.0/endpoints/{endpointId}/data'}

    def create_endpoint_data_export(
            self, endpoint_id, start_date, end_date, custom_headers=None, raw=False, **operation_config):
        """Create a new endpoint data export task.

        :param endpoint_id: The identifier of the endpoint.
        :type endpoint_id: str
        :param start_date: The start date of the demplyment data export
        :type start_date: datetime
        :param end_date: The end date of the demplyment data export
        :type end_date: datetime
        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :return: ErrorContent or ClientRawResponse if raw=true
        :rtype: ~azure.cognitiveservices.speechservices.models.ErrorContent or
         ~msrest.pipeline.ClientRawResponse
        :raises:
         :class:`HttpOperationError<msrest.exceptions.HttpOperationError>`
        """
        endpoint_data_definition = models.EndpointDataDefinition(start_date=start_date, end_date=end_date)

        # Construct URL
        url = self.create_endpoint_data_export.metadata['url']
        path_format_arguments = {
            'endpointId': self._serialize.url("endpoint_id", endpoint_id, 'str')
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}

        # Construct headers
        header_parameters = {}
        header_parameters['Accept'] = 'application/json'
        header_parameters['Content-Type'] = 'application/json; charset=utf-8'
        if custom_headers:
            header_parameters.update(custom_headers)

        # Construct body
        body_content = self._serialize.body(endpoint_data_definition, 'EndpointDataDefinition')

        # Construct and send request
        request = self._client.post(url, query_parameters, header_parameters, body_content)
        response = self._client.send(request, stream=False, **operation_config)

        if response.status_code not in [202, 400, 401, 403, 404, 429]:
            raise HttpOperationError(self._deserialize, response)

        deserialized = None
        header_dict = {}

        if response.status_code == 202:
            deserialized = self._deserialize('ErrorContent', response)
            header_dict = {
                'Location': 'str',
                'Operation-Location': 'str',
                'Retry-After': 'int',
                'X-RateLimit-Limit': 'int',
                'X-RateLimit-Remaining': 'int',
                'X-RateLimit-Reset': 'str',
            }
        if response.status_code == 400:
            deserialized = self._deserialize('ErrorContent', response)
            header_dict = {
                'Location': 'str',
                'Operation-Location': 'str',
                'Retry-After': 'int',
                'X-RateLimit-Limit': 'int',
                'X-RateLimit-Remaining': 'int',
                'X-RateLimit-Reset': 'str',
            }
        if response.status_code == 401:
            deserialized = self._deserialize('ErrorContent', response)
            header_dict = {
                'Location': 'str',
                'Operation-Location': 'str',
                'Retry-After': 'int',
                'X-RateLimit-Limit': 'int',
                'X-RateLimit-Remaining': 'int',
                'X-RateLimit-Reset': 'str',
            }
        if response.status_code == 403:
            deserialized = self._deserialize('ErrorContent', response)
            header_dict = {
                'Location': 'str',
                'Operation-Location': 'str',
                'Retry-After': 'int',
                'X-RateLimit-Limit': 'int',
                'X-RateLimit-Remaining': 'int',
                'X-RateLimit-Reset': 'str',
            }
        if response.status_code == 404:
            deserialized = self._deserialize('ErrorContent', response)
            header_dict = {
                'Location': 'str',
                'Operation-Location': 'str',
                'Retry-After': 'int',
                'X-RateLimit-Limit': 'int',
                'X-RateLimit-Remaining': 'int',
                'X-RateLimit-Reset': 'str',
            }
        if response.status_code == 429:
            deserialized = self._deserialize('ErrorContent', response)
            header_dict = {
                'Location': 'str',
                'Operation-Location': 'str',
                'Retry-After': 'int',
                'X-RateLimit-Limit': 'int',
                'X-RateLimit-Remaining': 'int',
                'X-RateLimit-Reset': 'str',
            }

        if raw:
            client_raw_response = ClientRawResponse(deserialized, response)
            client_raw_response.add_headers(header_dict)
            return client_raw_response

        return deserialized
    create_endpoint_data_export.metadata = {'url': '/api/speechtotext/v2.0/endpoints/{endpointId}/data'}

    def delete_endpoint_data(
            self, endpoint_id, custom_headers=None, raw=False, **operation_config):
        """Deletes the transcriptions and captured audio files associated with the
        endpoint identified by the given ID.

        Deletion will happen in the background and can take up to a day.

        :param endpoint_id: The identifier of the endpoint.
        :type endpoint_id: str
        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :return: ErrorContent or ClientRawResponse if raw=true
        :rtype: ~azure.cognitiveservices.speechservices.models.ErrorContent or
         ~msrest.pipeline.ClientRawResponse
        :raises:
         :class:`HttpOperationError<msrest.exceptions.HttpOperationError>`
        """
        # Construct URL
        url = self.delete_endpoint_data.metadata['url']
        path_format_arguments = {
            'endpointId': self._serialize.url("endpoint_id", endpoint_id, 'str')
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}

        # Construct headers
        header_parameters = {}
        header_parameters['Accept'] = 'application/json'
        if custom_headers:
            header_parameters.update(custom_headers)

        # Construct and send request
        request = self._client.delete(url, query_parameters, header_parameters)
        response = self._client.send(request, stream=False, **operation_config)

        if response.status_code not in [204, 401, 403, 429]:
            raise HttpOperationError(self._deserialize, response)

        deserialized = None
        header_dict = {}

        if response.status_code == 401:
            deserialized = self._deserialize('ErrorContent', response)
            header_dict = {
                'X-RateLimit-Limit': 'int',
                'X-RateLimit-Remaining': 'int',
                'X-RateLimit-Reset': 'str',
                'Retry-After': 'int',
            }
        if response.status_code == 403:
            deserialized = self._deserialize('ErrorContent', response)
            header_dict = {
                'X-RateLimit-Limit': 'int',
                'X-RateLimit-Remaining': 'int',
                'X-RateLimit-Reset': 'str',
                'Retry-After': 'int',
            }
        if response.status_code == 429:
            deserialized = self._deserialize('ErrorContent', response)
            header_dict = {
                'X-RateLimit-Limit': 'int',
                'X-RateLimit-Remaining': 'int',
                'X-RateLimit-Reset': 'str',
                'Retry-After': 'int',
            }

        if raw:
            client_raw_response = ClientRawResponse(deserialized, response)
            client_raw_response.add_headers(header_dict)
            return client_raw_response

        return deserialized
    delete_endpoint_data.metadata = {'url': '/api/speechtotext/v2.0/endpoints/{endpointId}/data'}

    def get_endpoint_data_export(
            self, endpoint_id, id, custom_headers=None, raw=False, **operation_config):
        """Gets the specified endpoint data export task for the authenticated
        user.

        :param endpoint_id: The identifier of the endpoint.
        :type endpoint_id: str
        :param id: The identifier of the data export.
        :type id: str
        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :return: object or ClientRawResponse if raw=true
        :rtype: object or ~msrest.pipeline.ClientRawResponse
        :raises:
         :class:`HttpOperationError<msrest.exceptions.HttpOperationError>`
        """
        # Construct URL
        url = self.get_endpoint_data_export.metadata['url']
        path_format_arguments = {
            'endpointId': self._serialize.url("endpoint_id", endpoint_id, 'str'),
            'id': self._serialize.url("id", id, 'str')
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}

        # Construct headers
        header_parameters = {}
        header_parameters['Accept'] = 'application/json'
        if custom_headers:
            header_parameters.update(custom_headers)

        # Construct and send request
        request = self._client.get(url, query_parameters, header_parameters)
        response = self._client.send(request, stream=False, **operation_config)

        if response.status_code not in [200, 401, 403, 404, 429]:
            raise HttpOperationError(self._deserialize, response)

        deserialized = None
        header_dict = {}

        if response.status_code == 200:
            deserialized = self._deserialize('EndpointData', response)
            header_dict = {
                'X-RateLimit-Limit': 'int',
                'X-RateLimit-Remaining': 'int',
                'X-RateLimit-Reset': 'str',
                'Retry-After': 'int',
            }
        if response.status_code == 401:
            deserialized = self._deserialize('ErrorContent', response)
            header_dict = {
                'X-RateLimit-Limit': 'int',
                'X-RateLimit-Remaining': 'int',
                'X-RateLimit-Reset': 'str',
                'Retry-After': 'int',
            }
        if response.status_code == 403:
            deserialized = self._deserialize('ErrorContent', response)
            header_dict = {
                'X-RateLimit-Limit': 'int',
                'X-RateLimit-Remaining': 'int',
                'X-RateLimit-Reset': 'str',
                'Retry-After': 'int',
            }
        if response.status_code == 404:
            deserialized = self._deserialize('ErrorContent', response)
            header_dict = {
                'X-RateLimit-Limit': 'int',
                'X-RateLimit-Remaining': 'int',
                'X-RateLimit-Reset': 'str',
                'Retry-After': 'int',
            }
        if response.status_code == 429:
            deserialized = self._deserialize('ErrorContent', response)
            header_dict = {
                'X-RateLimit-Limit': 'int',
                'X-RateLimit-Remaining': 'int',
                'X-RateLimit-Reset': 'str',
                'Retry-After': 'int',
            }

        if raw:
            client_raw_response = ClientRawResponse(deserialized, response)
            client_raw_response.add_headers(header_dict)
            return client_raw_response

        return deserialized
    get_endpoint_data_export.metadata = {'url': '/api/speechtotext/v2.0/endpoints/{endpointId}/data/{id}'}

    def delete_endpoint_data_export(
            self, endpoint_id, id, custom_headers=None, raw=False, **operation_config):
        """Deletes the endpoint data export task identified by the given ID.

        :param endpoint_id: The identifier of the endpoint.
        :type endpoint_id: str
        :param id: The identifier of the endpoint data export.
        :type id: str
        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :return: ErrorContent or ClientRawResponse if raw=true
        :rtype: ~azure.cognitiveservices.speechservices.models.ErrorContent or
         ~msrest.pipeline.ClientRawResponse
        :raises:
         :class:`HttpOperationError<msrest.exceptions.HttpOperationError>`
        """
        # Construct URL
        url = self.delete_endpoint_data_export.metadata['url']
        path_format_arguments = {
            'endpointId': self._serialize.url("endpoint_id", endpoint_id, 'str'),
            'id': self._serialize.url("id", id, 'str')
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}

        # Construct headers
        header_parameters = {}
        header_parameters['Accept'] = 'application/json'
        if custom_headers:
            header_parameters.update(custom_headers)

        # Construct and send request
        request = self._client.delete(url, query_parameters, header_parameters)
        response = self._client.send(request, stream=False, **operation_config)

        if response.status_code not in [204, 401, 403, 405, 429]:
            raise HttpOperationError(self._deserialize, response)

        deserialized = None
        header_dict = {}

        if response.status_code == 401:
            deserialized = self._deserialize('ErrorContent', response)
            header_dict = {
                'X-RateLimit-Limit': 'int',
                'X-RateLimit-Remaining': 'int',
                'X-RateLimit-Reset': 'str',
                'Retry-After': 'int',
            }
        if response.status_code == 403:
            deserialized = self._deserialize('ErrorContent', response)
            header_dict = {
                'X-RateLimit-Limit': 'int',
                'X-RateLimit-Remaining': 'int',
                'X-RateLimit-Reset': 'str',
                'Retry-After': 'int',
            }
        if response.status_code == 405:
            deserialized = self._deserialize('ErrorContent', response)
            header_dict = {
                'X-RateLimit-Limit': 'int',
                'X-RateLimit-Remaining': 'int',
                'X-RateLimit-Reset': 'str',
                'Retry-After': 'int',
            }
        if response.status_code == 429:
            deserialized = self._deserialize('ErrorContent', response)
            header_dict = {
                'X-RateLimit-Limit': 'int',
                'X-RateLimit-Remaining': 'int',
                'X-RateLimit-Reset': 'str',
                'Retry-After': 'int',
            }

        if raw:
            client_raw_response = ClientRawResponse(deserialized, response)
            client_raw_response.add_headers(header_dict)
            return client_raw_response

        return deserialized
    delete_endpoint_data_export.metadata = {'url': '/api/speechtotext/v2.0/endpoints/{endpointId}/data/{id}'}

    def get_models(
            self, custom_headers=None, raw=False, **operation_config):
        """Gets the list of models for the authenticated subscription.

        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :return: object or ClientRawResponse if raw=true
        :rtype: object or ~msrest.pipeline.ClientRawResponse
        :raises:
         :class:`HttpOperationError<msrest.exceptions.HttpOperationError>`
        """
        # Construct URL
        url = self.get_models.metadata['url']

        # Construct parameters
        query_parameters = {}

        # Construct headers
        header_parameters = {}
        header_parameters['Accept'] = 'application/json'
        if custom_headers:
            header_parameters.update(custom_headers)

        # Construct and send request
        request = self._client.get(url, query_parameters, header_parameters)
        response = self._client.send(request, stream=False, **operation_config)

        if response.status_code not in [200, 401, 403, 429]:
            raise HttpOperationError(self._deserialize, response)

        deserialized = None
        header_dict = {}

        if response.status_code == 200:
            deserialized = self._deserialize('[Model]', response)
            header_dict = {
                'X-RateLimit-Limit': 'int',
                'X-RateLimit-Remaining': 'int',
                'X-RateLimit-Reset': 'str',
                'Retry-After': 'int',
            }
        if response.status_code == 401:
            deserialized = self._deserialize('ErrorContent', response)
            header_dict = {
                'X-RateLimit-Limit': 'int',
                'X-RateLimit-Remaining': 'int',
                'X-RateLimit-Reset': 'str',
                'Retry-After': 'int',
            }
        if response.status_code == 403:
            deserialized = self._deserialize('ErrorContent', response)
            header_dict = {
                'X-RateLimit-Limit': 'int',
                'X-RateLimit-Remaining': 'int',
                'X-RateLimit-Reset': 'str',
                'Retry-After': 'int',
            }
        if response.status_code == 429:
            deserialized = self._deserialize('ErrorContent', response)
            header_dict = {
                'X-RateLimit-Limit': 'int',
                'X-RateLimit-Remaining': 'int',
                'X-RateLimit-Reset': 'str',
                'Retry-After': 'int',
            }

        if raw:
            client_raw_response = ClientRawResponse(deserialized, response)
            client_raw_response.add_headers(header_dict)
            return client_raw_response

        return deserialized
    get_models.metadata = {'url': '/api/speechtotext/v2.0/models'}

    def create_model(
            self, model_definition, custom_headers=None, raw=False, **operation_config):
        """Creates a new model.

        :param model_definition: The details of the new model.
        :type model_definition:
         ~azure.cognitiveservices.speechservices.models.SpeechModelDefinition
        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :return: ErrorContent or ClientRawResponse if raw=true
        :rtype: ~azure.cognitiveservices.speechservices.models.ErrorContent or
         ~msrest.pipeline.ClientRawResponse
        :raises:
         :class:`HttpOperationError<msrest.exceptions.HttpOperationError>`
        """
        # Construct URL
        url = self.create_model.metadata['url']

        # Construct parameters
        query_parameters = {}

        # Construct headers
        header_parameters = {}
        header_parameters['Accept'] = 'application/json'
        header_parameters['Content-Type'] = 'application/json; charset=utf-8'
        if custom_headers:
            header_parameters.update(custom_headers)

        # Construct body
        body_content = self._serialize.body(model_definition, 'SpeechModelDefinition')

        # Construct and send request
        request = self._client.post(url, query_parameters, header_parameters, body_content)
        response = self._client.send(request, stream=False, **operation_config)

        if response.status_code not in [202, 400, 401, 403, 415, 429]:
            raise HttpOperationError(self._deserialize, response)

        deserialized = None
        header_dict = {}

        if response.status_code == 400:
            deserialized = self._deserialize('ErrorContent', response)
            header_dict = {
                'Location': 'str',
                'Operation-Location': 'str',
                'Retry-After': 'int',
                'X-RateLimit-Limit': 'int',
                'X-RateLimit-Remaining': 'int',
                'X-RateLimit-Reset': 'str',
            }
        if response.status_code == 401:
            deserialized = self._deserialize('ErrorContent', response)
            header_dict = {
                'Location': 'str',
                'Operation-Location': 'str',
                'Retry-After': 'int',
                'X-RateLimit-Limit': 'int',
                'X-RateLimit-Remaining': 'int',
                'X-RateLimit-Reset': 'str',
            }
        if response.status_code == 403:
            deserialized = self._deserialize('ErrorContent', response)
            header_dict = {
                'Location': 'str',
                'Operation-Location': 'str',
                'Retry-After': 'int',
                'X-RateLimit-Limit': 'int',
                'X-RateLimit-Remaining': 'int',
                'X-RateLimit-Reset': 'str',
            }
        if response.status_code == 415:
            deserialized = self._deserialize('ErrorContent', response)
            header_dict = {
                'Location': 'str',
                'Operation-Location': 'str',
                'Retry-After': 'int',
                'X-RateLimit-Limit': 'int',
                'X-RateLimit-Remaining': 'int',
                'X-RateLimit-Reset': 'str',
            }
        if response.status_code == 429:
            deserialized = self._deserialize('ErrorContent', response)
            header_dict = {
                'Location': 'str',
                'Operation-Location': 'str',
                'Retry-After': 'int',
                'X-RateLimit-Limit': 'int',
                'X-RateLimit-Remaining': 'int',
                'X-RateLimit-Reset': 'str',
            }

        if raw:
            client_raw_response = ClientRawResponse(deserialized, response)
            client_raw_response.add_headers(header_dict)
            return client_raw_response

        return deserialized
    create_model.metadata = {'url': '/api/speechtotext/v2.0/models'}

    def get_model(
            self, id, custom_headers=None, raw=False, **operation_config):
        """Gets the model identified by the given ID.

        :param id: The identifier of the model.
        :type id: str
        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :return: object or ClientRawResponse if raw=true
        :rtype: object or ~msrest.pipeline.ClientRawResponse
        :raises:
         :class:`HttpOperationError<msrest.exceptions.HttpOperationError>`
        """
        # Construct URL
        url = self.get_model.metadata['url']
        path_format_arguments = {
            'id': self._serialize.url("id", id, 'str')
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}

        # Construct headers
        header_parameters = {}
        header_parameters['Accept'] = 'application/json'
        if custom_headers:
            header_parameters.update(custom_headers)

        # Construct and send request
        request = self._client.get(url, query_parameters, header_parameters)
        response = self._client.send(request, stream=False, **operation_config)

        if response.status_code not in [200, 401, 403, 404, 429]:
            raise HttpOperationError(self._deserialize, response)

        deserialized = None
        header_dict = {}

        if response.status_code == 200:
            deserialized = self._deserialize('Model', response)
            header_dict = {
                'Retry-After': 'int',
                'X-RateLimit-Limit': 'int',
                'X-RateLimit-Remaining': 'int',
                'X-RateLimit-Reset': 'str',
            }
        if response.status_code == 401:
            deserialized = self._deserialize('ErrorContent', response)
            header_dict = {
                'Retry-After': 'int',
                'X-RateLimit-Limit': 'int',
                'X-RateLimit-Remaining': 'int',
                'X-RateLimit-Reset': 'str',
            }
        if response.status_code == 403:
            deserialized = self._deserialize('ErrorContent', response)
            header_dict = {
                'Retry-After': 'int',
                'X-RateLimit-Limit': 'int',
                'X-RateLimit-Remaining': 'int',
                'X-RateLimit-Reset': 'str',
            }
        if response.status_code == 404:
            deserialized = self._deserialize('ErrorContent', response)
            header_dict = {
                'Retry-After': 'int',
                'X-RateLimit-Limit': 'int',
                'X-RateLimit-Remaining': 'int',
                'X-RateLimit-Reset': 'str',
            }
        if response.status_code == 429:
            deserialized = self._deserialize('ErrorContent', response)
            header_dict = {
                'Retry-After': 'int',
                'X-RateLimit-Limit': 'int',
                'X-RateLimit-Remaining': 'int',
                'X-RateLimit-Reset': 'str',
            }

        if raw:
            client_raw_response = ClientRawResponse(deserialized, response)
            client_raw_response.add_headers(header_dict)
            return client_raw_response

        return deserialized
    get_model.metadata = {'url': '/api/speechtotext/v2.0/models/{id}'}

    def delete_model(
            self, id, custom_headers=None, raw=False, **operation_config):
        """Deletes the model identified by the given ID.

        :param id: The identifier of the model.
        :type id: str
        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :return: ErrorContent or ClientRawResponse if raw=true
        :rtype: ~azure.cognitiveservices.speechservices.models.ErrorContent or
         ~msrest.pipeline.ClientRawResponse
        :raises:
         :class:`HttpOperationError<msrest.exceptions.HttpOperationError>`
        """
        # Construct URL
        url = self.delete_model.metadata['url']
        path_format_arguments = {
            'id': self._serialize.url("id", id, 'str')
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}

        # Construct headers
        header_parameters = {}
        header_parameters['Accept'] = 'application/json'
        if custom_headers:
            header_parameters.update(custom_headers)

        # Construct and send request
        request = self._client.delete(url, query_parameters, header_parameters)
        response = self._client.send(request, stream=False, **operation_config)

        if response.status_code not in [204, 401, 403, 405, 429]:
            raise HttpOperationError(self._deserialize, response)

        deserialized = None
        header_dict = {}

        if response.status_code == 401:
            deserialized = self._deserialize('ErrorContent', response)
            header_dict = {
                'X-RateLimit-Limit': 'int',
                'X-RateLimit-Remaining': 'int',
                'X-RateLimit-Reset': 'str',
                'Retry-After': 'int',
            }
        if response.status_code == 403:
            deserialized = self._deserialize('ErrorContent', response)
            header_dict = {
                'X-RateLimit-Limit': 'int',
                'X-RateLimit-Remaining': 'int',
                'X-RateLimit-Reset': 'str',
                'Retry-After': 'int',
            }
        if response.status_code == 405:
            deserialized = self._deserialize('ErrorContent', response)
            header_dict = {
                'X-RateLimit-Limit': 'int',
                'X-RateLimit-Remaining': 'int',
                'X-RateLimit-Reset': 'str',
                'Retry-After': 'int',
            }
        if response.status_code == 429:
            deserialized = self._deserialize('ErrorContent', response)
            header_dict = {
                'X-RateLimit-Limit': 'int',
                'X-RateLimit-Remaining': 'int',
                'X-RateLimit-Reset': 'str',
                'Retry-After': 'int',
            }

        if raw:
            client_raw_response = ClientRawResponse(deserialized, response)
            client_raw_response.add_headers(header_dict)
            return client_raw_response

        return deserialized
    delete_model.metadata = {'url': '/api/speechtotext/v2.0/models/{id}'}

    def update_model(
            self, id, name, description=None, custom_headers=None, raw=False, **operation_config):
        """Updates the metadata of the model identified by the given ID.

        :param id: The identifier of the model.
        :type id: str
        :param name: The name of the object
        :type name: str
        :param description: The description of the object
        :type description: str
        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :return: object or ClientRawResponse if raw=true
        :rtype: object or ~msrest.pipeline.ClientRawResponse
        :raises:
         :class:`HttpOperationError<msrest.exceptions.HttpOperationError>`
        """
        model_update = models.ModelUpdate(name=name, description=description)

        # Construct URL
        url = self.update_model.metadata['url']
        path_format_arguments = {
            'id': self._serialize.url("id", id, 'str')
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}

        # Construct headers
        header_parameters = {}
        header_parameters['Accept'] = 'application/json'
        header_parameters['Content-Type'] = 'application/json; charset=utf-8'
        if custom_headers:
            header_parameters.update(custom_headers)

        # Construct body
        body_content = self._serialize.body(model_update, 'ModelUpdate')

        # Construct and send request
        request = self._client.patch(url, query_parameters, header_parameters, body_content)
        response = self._client.send(request, stream=False, **operation_config)

        if response.status_code not in [200, 400, 401, 403, 409, 415, 429]:
            raise HttpOperationError(self._deserialize, response)

        deserialized = None
        header_dict = {}

        if response.status_code == 200:
            deserialized = self._deserialize('Model', response)
            header_dict = {
                'X-RateLimit-Limit': 'int',
                'X-RateLimit-Remaining': 'int',
                'X-RateLimit-Reset': 'str',
                'Retry-After': 'int',
            }
        if response.status_code == 400:
            deserialized = self._deserialize('ErrorContent', response)
            header_dict = {
                'X-RateLimit-Limit': 'int',
                'X-RateLimit-Remaining': 'int',
                'X-RateLimit-Reset': 'str',
                'Retry-After': 'int',
            }
        if response.status_code == 401:
            deserialized = self._deserialize('ErrorContent', response)
            header_dict = {
                'X-RateLimit-Limit': 'int',
                'X-RateLimit-Remaining': 'int',
                'X-RateLimit-Reset': 'str',
                'Retry-After': 'int',
            }
        if response.status_code == 403:
            deserialized = self._deserialize('ErrorContent', response)
            header_dict = {
                'X-RateLimit-Limit': 'int',
                'X-RateLimit-Remaining': 'int',
                'X-RateLimit-Reset': 'str',
                'Retry-After': 'int',
            }
        if response.status_code == 409:
            deserialized = self._deserialize('ErrorContent', response)
            header_dict = {
                'X-RateLimit-Limit': 'int',
                'X-RateLimit-Remaining': 'int',
                'X-RateLimit-Reset': 'str',
                'Retry-After': 'int',
            }
        if response.status_code == 415:
            deserialized = self._deserialize('ErrorContent', response)
            header_dict = {
                'X-RateLimit-Limit': 'int',
                'X-RateLimit-Remaining': 'int',
                'X-RateLimit-Reset': 'str',
                'Retry-After': 'int',
            }
        if response.status_code == 429:
            deserialized = self._deserialize('ErrorContent', response)
            header_dict = {
                'X-RateLimit-Limit': 'int',
                'X-RateLimit-Remaining': 'int',
                'X-RateLimit-Reset': 'str',
                'Retry-After': 'int',
            }

        if raw:
            client_raw_response = ClientRawResponse(deserialized, response)
            client_raw_response.add_headers(header_dict)
            return client_raw_response

        return deserialized
    update_model.metadata = {'url': '/api/speechtotext/v2.0/models/{id}'}

    def get_supported_locales_for_models(
            self, custom_headers=None, raw=False, **operation_config):
        """Gets a list of supported locales for model adaptation.

        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :return: object or ClientRawResponse if raw=true
        :rtype: object or ~msrest.pipeline.ClientRawResponse
        :raises:
         :class:`HttpOperationError<msrest.exceptions.HttpOperationError>`
        """
        # Construct URL
        url = self.get_supported_locales_for_models.metadata['url']

        # Construct parameters
        query_parameters = {}

        # Construct headers
        header_parameters = {}
        header_parameters['Accept'] = 'application/json'
        if custom_headers:
            header_parameters.update(custom_headers)

        # Construct and send request
        request = self._client.get(url, query_parameters, header_parameters)
        response = self._client.send(request, stream=False, **operation_config)

        if response.status_code not in [200, 401, 403, 429]:
            raise HttpOperationError(self._deserialize, response)

        deserialized = None
        header_dict = {}

        if response.status_code == 200:
            deserialized = self._deserialize('GetSupportedLocalesForModelsOKResponse', response)
            header_dict = {
                'X-RateLimit-Limit': 'int',
                'X-RateLimit-Remaining': 'int',
                'X-RateLimit-Reset': 'str',
                'Retry-After': 'int',
            }
        if response.status_code == 401:
            deserialized = self._deserialize('ErrorContent', response)
            header_dict = {
                'X-RateLimit-Limit': 'int',
                'X-RateLimit-Remaining': 'int',
                'X-RateLimit-Reset': 'str',
                'Retry-After': 'int',
            }
        if response.status_code == 403:
            deserialized = self._deserialize('ErrorContent', response)
            header_dict = {
                'X-RateLimit-Limit': 'int',
                'X-RateLimit-Remaining': 'int',
                'X-RateLimit-Reset': 'str',
                'Retry-After': 'int',
            }
        if response.status_code == 429:
            deserialized = self._deserialize('ErrorContent', response)
            header_dict = {
                'X-RateLimit-Limit': 'int',
                'X-RateLimit-Remaining': 'int',
                'X-RateLimit-Reset': 'str',
                'Retry-After': 'int',
            }

        if raw:
            client_raw_response = ClientRawResponse(deserialized, response)
            client_raw_response.add_headers(header_dict)
            return client_raw_response

        return deserialized
    get_supported_locales_for_models.metadata = {'url': '/api/speechtotext/v2.0/models/locales'}

    def get_transcriptions(
            self, custom_headers=None, raw=False, **operation_config):
        """Gets a list of transcriptions for the authenticated subscription.

        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :return: object or ClientRawResponse if raw=true
        :rtype: object or ~msrest.pipeline.ClientRawResponse
        :raises:
         :class:`HttpOperationError<msrest.exceptions.HttpOperationError>`
        """
        # Construct URL
        url = self.get_transcriptions.metadata['url']

        # Construct parameters
        query_parameters = {}

        # Construct headers
        header_parameters = {}
        header_parameters['Accept'] = 'application/json'
        if custom_headers:
            header_parameters.update(custom_headers)

        # Construct and send request
        request = self._client.get(url, query_parameters, header_parameters)
        response = self._client.send(request, stream=False, **operation_config)

        if response.status_code not in [200, 401, 403, 429]:
            raise HttpOperationError(self._deserialize, response)

        deserialized = None
        header_dict = {}

        if response.status_code == 200:
            deserialized = self._deserialize('[Transcription]', response)
            header_dict = {
                'X-RateLimit-Limit': 'int',
                'X-RateLimit-Remaining': 'int',
                'X-RateLimit-Reset': 'str',
                'Retry-After': 'int',
            }
        if response.status_code == 401:
            deserialized = self._deserialize('ErrorContent', response)
            header_dict = {
                'X-RateLimit-Limit': 'int',
                'X-RateLimit-Remaining': 'int',
                'X-RateLimit-Reset': 'str',
                'Retry-After': 'int',
            }
        if response.status_code == 403:
            deserialized = self._deserialize('ErrorContent', response)
            header_dict = {
                'X-RateLimit-Limit': 'int',
                'X-RateLimit-Remaining': 'int',
                'X-RateLimit-Reset': 'str',
                'Retry-After': 'int',
            }
        if response.status_code == 429:
            deserialized = self._deserialize('ErrorContent', response)
            header_dict = {
                'X-RateLimit-Limit': 'int',
                'X-RateLimit-Remaining': 'int',
                'X-RateLimit-Reset': 'str',
                'Retry-After': 'int',
            }

        if raw:
            client_raw_response = ClientRawResponse(deserialized, response)
            client_raw_response.add_headers(header_dict)
            return client_raw_response

        return deserialized
    get_transcriptions.metadata = {'url': '/api/speechtotext/v2.0/transcriptions'}

    def create_transcription(
            self, transcription, custom_headers=None, raw=False, **operation_config):
        """Creates a new transcription.

        :param transcription: The details of the new transcription.
        :type transcription:
         ~azure.cognitiveservices.speechservices.models.TranscriptionDefinition
        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :return: ErrorContent or ClientRawResponse if raw=true
        :rtype: ~azure.cognitiveservices.speechservices.models.ErrorContent or
         ~msrest.pipeline.ClientRawResponse
        :raises:
         :class:`HttpOperationError<msrest.exceptions.HttpOperationError>`
        """
        # Construct URL
        url = self.create_transcription.metadata['url']

        # Construct parameters
        query_parameters = {}

        # Construct headers
        header_parameters = {}
        header_parameters['Accept'] = 'application/json'
        header_parameters['Content-Type'] = 'application/json; charset=utf-8'
        if custom_headers:
            header_parameters.update(custom_headers)

        # Construct body
        body_content = self._serialize.body(transcription, 'TranscriptionDefinition')

        # Construct and send request
        request = self._client.post(url, query_parameters, header_parameters, body_content)
        response = self._client.send(request, stream=False, **operation_config)

        if response.status_code not in [202, 400, 401, 403, 415, 429, 503]:
            raise HttpOperationError(self._deserialize, response)

        deserialized = None
        header_dict = {}

        if response.status_code == 400:
            deserialized = self._deserialize('ErrorContent', response)
            header_dict = {
                'Location': 'str',
                'Operation-Location': 'str',
                'Retry-After': 'int',
                'X-RateLimit-Limit': 'int',
                'X-RateLimit-Remaining': 'int',
                'X-RateLimit-Reset': 'str',
            }
        if response.status_code == 401:
            deserialized = self._deserialize('ErrorContent', response)
            header_dict = {
                'Location': 'str',
                'Operation-Location': 'str',
                'Retry-After': 'int',
                'X-RateLimit-Limit': 'int',
                'X-RateLimit-Remaining': 'int',
                'X-RateLimit-Reset': 'str',
            }
        if response.status_code == 403:
            deserialized = self._deserialize('ErrorContent', response)
            header_dict = {
                'Location': 'str',
                'Operation-Location': 'str',
                'Retry-After': 'int',
                'X-RateLimit-Limit': 'int',
                'X-RateLimit-Remaining': 'int',
                'X-RateLimit-Reset': 'str',
            }
        if response.status_code == 415:
            deserialized = self._deserialize('ErrorContent', response)
            header_dict = {
                'Location': 'str',
                'Operation-Location': 'str',
                'Retry-After': 'int',
                'X-RateLimit-Limit': 'int',
                'X-RateLimit-Remaining': 'int',
                'X-RateLimit-Reset': 'str',
            }
        if response.status_code == 429:
            deserialized = self._deserialize('ErrorContent', response)
            header_dict = {
                'Location': 'str',
                'Operation-Location': 'str',
                'Retry-After': 'int',
                'X-RateLimit-Limit': 'int',
                'X-RateLimit-Remaining': 'int',
                'X-RateLimit-Reset': 'str',
            }
        if response.status_code == 503:
            deserialized = self._deserialize('ErrorContent', response)
            header_dict = {
                'Location': 'str',
                'Operation-Location': 'str',
                'Retry-After': 'int',
                'X-RateLimit-Limit': 'int',
                'X-RateLimit-Remaining': 'int',
                'X-RateLimit-Reset': 'str',
            }

        if raw:
            client_raw_response = ClientRawResponse(deserialized, response)
            client_raw_response.add_headers(header_dict)
            return client_raw_response

        return deserialized
    create_transcription.metadata = {'url': '/api/speechtotext/v2.0/transcriptions'}

    def get_transcription(
            self, id, custom_headers=None, raw=False, **operation_config):
        """Gets the transcription identified by the given ID.

        :param id: The identifier of the transcription.
        :type id: str
        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :return: object or ClientRawResponse if raw=true
        :rtype: object or ~msrest.pipeline.ClientRawResponse
        :raises:
         :class:`HttpOperationError<msrest.exceptions.HttpOperationError>`
        """
        # Construct URL
        url = self.get_transcription.metadata['url']
        path_format_arguments = {
            'id': self._serialize.url("id", id, 'str')
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}

        # Construct headers
        header_parameters = {}
        header_parameters['Accept'] = 'application/json'
        if custom_headers:
            header_parameters.update(custom_headers)

        # Construct and send request
        request = self._client.get(url, query_parameters, header_parameters)
        response = self._client.send(request, stream=False, **operation_config)

        if response.status_code not in [200, 401, 403, 404, 429]:
            raise HttpOperationError(self._deserialize, response)

        deserialized = None
        header_dict = {}

        if response.status_code == 200:
            deserialized = self._deserialize('Transcription', response)
            header_dict = {
                'Retry-After': 'int',
                'X-RateLimit-Limit': 'int',
                'X-RateLimit-Remaining': 'int',
                'X-RateLimit-Reset': 'str',
            }
        if response.status_code == 401:
            deserialized = self._deserialize('ErrorContent', response)
            header_dict = {
                'Retry-After': 'int',
                'X-RateLimit-Limit': 'int',
                'X-RateLimit-Remaining': 'int',
                'X-RateLimit-Reset': 'str',
            }
        if response.status_code == 403:
            deserialized = self._deserialize('ErrorContent', response)
            header_dict = {
                'Retry-After': 'int',
                'X-RateLimit-Limit': 'int',
                'X-RateLimit-Remaining': 'int',
                'X-RateLimit-Reset': 'str',
            }
        if response.status_code == 404:
            deserialized = self._deserialize('ErrorContent', response)
            header_dict = {
                'Retry-After': 'int',
                'X-RateLimit-Limit': 'int',
                'X-RateLimit-Remaining': 'int',
                'X-RateLimit-Reset': 'str',
            }
        if response.status_code == 429:
            deserialized = self._deserialize('ErrorContent', response)
            header_dict = {
                'Retry-After': 'int',
                'X-RateLimit-Limit': 'int',
                'X-RateLimit-Remaining': 'int',
                'X-RateLimit-Reset': 'str',
            }

        if raw:
            client_raw_response = ClientRawResponse(deserialized, response)
            client_raw_response.add_headers(header_dict)
            return client_raw_response

        return deserialized
    get_transcription.metadata = {'url': '/api/speechtotext/v2.0/transcriptions/{id}'}

    def delete_transcription(
            self, id, custom_headers=None, raw=False, **operation_config):
        """Deletes the specified transcription task.

        :param id: The identifier of the transcription.
        :type id: str
        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :return: ErrorContent or ClientRawResponse if raw=true
        :rtype: ~azure.cognitiveservices.speechservices.models.ErrorContent or
         ~msrest.pipeline.ClientRawResponse
        :raises:
         :class:`HttpOperationError<msrest.exceptions.HttpOperationError>`
        """
        # Construct URL
        url = self.delete_transcription.metadata['url']
        path_format_arguments = {
            'id': self._serialize.url("id", id, 'str')
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}

        # Construct headers
        header_parameters = {}
        header_parameters['Accept'] = 'application/json'
        if custom_headers:
            header_parameters.update(custom_headers)

        # Construct and send request
        request = self._client.delete(url, query_parameters, header_parameters)
        response = self._client.send(request, stream=False, **operation_config)

        if response.status_code not in [204, 401, 403, 405, 429]:
            raise HttpOperationError(self._deserialize, response)

        deserialized = None
        header_dict = {}

        if response.status_code == 204:
            deserialized = self._deserialize('ErrorContent', response)
            header_dict = {
                'X-RateLimit-Limit': 'int',
                'X-RateLimit-Remaining': 'int',
                'X-RateLimit-Reset': 'str',
                'Retry-After': 'int',
            }
        if response.status_code == 401:
            deserialized = self._deserialize('ErrorContent', response)
            header_dict = {
                'X-RateLimit-Limit': 'int',
                'X-RateLimit-Remaining': 'int',
                'X-RateLimit-Reset': 'str',
                'Retry-After': 'int',
            }
        if response.status_code == 403:
            deserialized = self._deserialize('ErrorContent', response)
            header_dict = {
                'X-RateLimit-Limit': 'int',
                'X-RateLimit-Remaining': 'int',
                'X-RateLimit-Reset': 'str',
                'Retry-After': 'int',
            }
        if response.status_code == 405:
            deserialized = self._deserialize('ErrorContent', response)
            header_dict = {
                'X-RateLimit-Limit': 'int',
                'X-RateLimit-Remaining': 'int',
                'X-RateLimit-Reset': 'str',
                'Retry-After': 'int',
            }
        if response.status_code == 429:
            deserialized = self._deserialize('ErrorContent', response)
            header_dict = {
                'X-RateLimit-Limit': 'int',
                'X-RateLimit-Remaining': 'int',
                'X-RateLimit-Reset': 'str',
                'Retry-After': 'int',
            }

        if raw:
            client_raw_response = ClientRawResponse(deserialized, response)
            client_raw_response.add_headers(header_dict)
            return client_raw_response

        return deserialized
    delete_transcription.metadata = {'url': '/api/speechtotext/v2.0/transcriptions/{id}'}

    def update_transcription(
            self, id, name, description=None, custom_headers=None, raw=False, **operation_config):
        """Updates the mutable details of the transcription identified by its ID.

        :param id: The identifier of the transcription.
        :type id: str
        :param name: The name of the object
        :type name: str
        :param description: The description of the object
        :type description: str
        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :return: object or ClientRawResponse if raw=true
        :rtype: object or ~msrest.pipeline.ClientRawResponse
        :raises:
         :class:`HttpOperationError<msrest.exceptions.HttpOperationError>`
        """
        transcription_update = models.TranscriptionUpdate(name=name, description=description)

        # Construct URL
        url = self.update_transcription.metadata['url']
        path_format_arguments = {
            'id': self._serialize.url("id", id, 'str')
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}

        # Construct headers
        header_parameters = {}
        header_parameters['Accept'] = 'application/json'
        header_parameters['Content-Type'] = 'application/json; charset=utf-8'
        if custom_headers:
            header_parameters.update(custom_headers)

        # Construct body
        body_content = self._serialize.body(transcription_update, 'TranscriptionUpdate')

        # Construct and send request
        request = self._client.patch(url, query_parameters, header_parameters, body_content)
        response = self._client.send(request, stream=False, **operation_config)

        if response.status_code not in [200, 400, 401, 403, 409, 415, 429]:
            raise HttpOperationError(self._deserialize, response)

        deserialized = None
        header_dict = {}

        if response.status_code == 200:
            deserialized = self._deserialize('Transcription', response)
            header_dict = {
                'X-RateLimit-Limit': 'int',
                'X-RateLimit-Remaining': 'int',
                'X-RateLimit-Reset': 'str',
                'Retry-After': 'int',
            }
        if response.status_code == 400:
            deserialized = self._deserialize('ErrorContent', response)
            header_dict = {
                'X-RateLimit-Limit': 'int',
                'X-RateLimit-Remaining': 'int',
                'X-RateLimit-Reset': 'str',
                'Retry-After': 'int',
            }
        if response.status_code == 401:
            deserialized = self._deserialize('ErrorContent', response)
            header_dict = {
                'X-RateLimit-Limit': 'int',
                'X-RateLimit-Remaining': 'int',
                'X-RateLimit-Reset': 'str',
                'Retry-After': 'int',
            }
        if response.status_code == 403:
            deserialized = self._deserialize('ErrorContent', response)
            header_dict = {
                'X-RateLimit-Limit': 'int',
                'X-RateLimit-Remaining': 'int',
                'X-RateLimit-Reset': 'str',
                'Retry-After': 'int',
            }
        if response.status_code == 409:
            deserialized = self._deserialize('ErrorContent', response)
            header_dict = {
                'X-RateLimit-Limit': 'int',
                'X-RateLimit-Remaining': 'int',
                'X-RateLimit-Reset': 'str',
                'Retry-After': 'int',
            }
        if response.status_code == 415:
            deserialized = self._deserialize('ErrorContent', response)
            header_dict = {
                'X-RateLimit-Limit': 'int',
                'X-RateLimit-Remaining': 'int',
                'X-RateLimit-Reset': 'str',
                'Retry-After': 'int',
            }
        if response.status_code == 429:
            deserialized = self._deserialize('ErrorContent', response)
            header_dict = {
                'X-RateLimit-Limit': 'int',
                'X-RateLimit-Remaining': 'int',
                'X-RateLimit-Reset': 'str',
                'Retry-After': 'int',
            }

        if raw:
            client_raw_response = ClientRawResponse(deserialized, response)
            client_raw_response.add_headers(header_dict)
            return client_raw_response

        return deserialized
    update_transcription.metadata = {'url': '/api/speechtotext/v2.0/transcriptions/{id}'}

    def get_supported_locales_for_transcriptions(
            self, custom_headers=None, raw=False, **operation_config):
        """Gets a list of supported locales for offline transcriptions.

        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :return: object or ClientRawResponse if raw=true
        :rtype: object or ~msrest.pipeline.ClientRawResponse
        :raises:
         :class:`HttpOperationError<msrest.exceptions.HttpOperationError>`
        """
        # Construct URL
        url = self.get_supported_locales_for_transcriptions.metadata['url']

        # Construct parameters
        query_parameters = {}

        # Construct headers
        header_parameters = {}
        header_parameters['Accept'] = 'application/json'
        if custom_headers:
            header_parameters.update(custom_headers)

        # Construct and send request
        request = self._client.get(url, query_parameters, header_parameters)
        response = self._client.send(request, stream=False, **operation_config)

        if response.status_code not in [200, 401, 403, 429]:
            raise HttpOperationError(self._deserialize, response)

        deserialized = None
        header_dict = {}

        if response.status_code == 200:
            deserialized = self._deserialize('[str]', response)
            header_dict = {
                'X-RateLimit-Limit': 'int',
                'X-RateLimit-Remaining': 'int',
                'X-RateLimit-Reset': 'str',
                'Retry-After': 'int',
            }
        if response.status_code == 401:
            deserialized = self._deserialize('ErrorContent', response)
            header_dict = {
                'X-RateLimit-Limit': 'int',
                'X-RateLimit-Remaining': 'int',
                'X-RateLimit-Reset': 'str',
                'Retry-After': 'int',
            }
        if response.status_code == 403:
            deserialized = self._deserialize('ErrorContent', response)
            header_dict = {
                'X-RateLimit-Limit': 'int',
                'X-RateLimit-Remaining': 'int',
                'X-RateLimit-Reset': 'str',
                'Retry-After': 'int',
            }
        if response.status_code == 429:
            deserialized = self._deserialize('ErrorContent', response)
            header_dict = {
                'X-RateLimit-Limit': 'int',
                'X-RateLimit-Remaining': 'int',
                'X-RateLimit-Reset': 'str',
                'Retry-After': 'int',
            }

        if raw:
            client_raw_response = ClientRawResponse(deserialized, response)
            client_raw_response.add_headers(header_dict)
            return client_raw_response

        return deserialized
    get_supported_locales_for_transcriptions.metadata = {'url': '/api/speechtotext/v2.0/transcriptions/locales'}

    def get_language_generation_endpoints(
            self, custom_headers=None, raw=False, **operation_config):
        """Gets all language generation endpoint of a subscription.

        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :return: object or ClientRawResponse if raw=true
        :rtype: object or ~msrest.pipeline.ClientRawResponse
        :raises:
         :class:`HttpOperationError<msrest.exceptions.HttpOperationError>`
        """
        # Construct URL
        url = self.get_language_generation_endpoints.metadata['url']

        # Construct parameters
        query_parameters = {}

        # Construct headers
        header_parameters = {}
        header_parameters['Accept'] = 'application/json'
        if custom_headers:
            header_parameters.update(custom_headers)

        # Construct and send request
        request = self._client.get(url, query_parameters, header_parameters)
        response = self._client.send(request, stream=False, **operation_config)

        if response.status_code not in [200, 401, 403, 429]:
            raise HttpOperationError(self._deserialize, response)

        deserialized = None
        header_dict = {}

        if response.status_code == 200:
            deserialized = self._deserialize('[Endpoint]', response)
            header_dict = {
                'X-RateLimit-Limit': 'int',
                'X-RateLimit-Remaining': 'int',
                'X-RateLimit-Reset': 'str',
                'Retry-After': 'int',
            }
        if response.status_code == 401:
            deserialized = self._deserialize('ErrorContent', response)
            header_dict = {
                'X-RateLimit-Limit': 'int',
                'X-RateLimit-Remaining': 'int',
                'X-RateLimit-Reset': 'str',
                'Retry-After': 'int',
            }
        if response.status_code == 403:
            deserialized = self._deserialize('ErrorContent', response)
            header_dict = {
                'X-RateLimit-Limit': 'int',
                'X-RateLimit-Remaining': 'int',
                'X-RateLimit-Reset': 'str',
                'Retry-After': 'int',
            }
        if response.status_code == 429:
            deserialized = self._deserialize('ErrorContent', response)
            header_dict = {
                'X-RateLimit-Limit': 'int',
                'X-RateLimit-Remaining': 'int',
                'X-RateLimit-Reset': 'str',
                'Retry-After': 'int',
            }

        if raw:
            client_raw_response = ClientRawResponse(deserialized, response)
            client_raw_response.add_headers(header_dict)
            return client_raw_response

        return deserialized
    get_language_generation_endpoints.metadata = {'url': '/api/languagegeneration/v2.0/Endpoints'}

    def create_language_generation_endpoint(
            self, endpoint_definition, custom_headers=None, raw=False, **operation_config):
        """Creates a new language generation endpoint.

        :param endpoint_definition:
        :type endpoint_definition:
         ~azure.cognitiveservices.speechservices.models.EndpointDefinition
        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :return: ErrorContent or ClientRawResponse if raw=true
        :rtype: ~azure.cognitiveservices.speechservices.models.ErrorContent or
         ~msrest.pipeline.ClientRawResponse
        :raises:
         :class:`HttpOperationError<msrest.exceptions.HttpOperationError>`
        """
        # Construct URL
        url = self.create_language_generation_endpoint.metadata['url']

        # Construct parameters
        query_parameters = {}

        # Construct headers
        header_parameters = {}
        header_parameters['Accept'] = 'application/json'
        header_parameters['Content-Type'] = 'application/json; charset=utf-8'
        if custom_headers:
            header_parameters.update(custom_headers)

        # Construct body
        body_content = self._serialize.body(endpoint_definition, 'EndpointDefinition')

        # Construct and send request
        request = self._client.post(url, query_parameters, header_parameters, body_content)
        response = self._client.send(request, stream=False, **operation_config)

        if response.status_code not in [202, 204, 400, 401, 403, 429]:
            raise HttpOperationError(self._deserialize, response)

        deserialized = None
        header_dict = {}

        if response.status_code == 400:
            deserialized = self._deserialize('ErrorContent', response)
            header_dict = {
                'Location': 'str',
                'Operation-Location': 'str',
                'Retry-After': 'int',
                'X-RateLimit-Limit': 'int',
                'X-RateLimit-Remaining': 'int',
                'X-RateLimit-Reset': 'str',
            }
        if response.status_code == 401:
            deserialized = self._deserialize('ErrorContent', response)
            header_dict = {
                'Location': 'str',
                'Operation-Location': 'str',
                'Retry-After': 'int',
                'X-RateLimit-Limit': 'int',
                'X-RateLimit-Remaining': 'int',
                'X-RateLimit-Reset': 'str',
            }
        if response.status_code == 403:
            deserialized = self._deserialize('ErrorContent', response)
            header_dict = {
                'Location': 'str',
                'Operation-Location': 'str',
                'Retry-After': 'int',
                'X-RateLimit-Limit': 'int',
                'X-RateLimit-Remaining': 'int',
                'X-RateLimit-Reset': 'str',
            }
        if response.status_code == 429:
            deserialized = self._deserialize('ErrorContent', response)
            header_dict = {
                'Location': 'str',
                'Operation-Location': 'str',
                'Retry-After': 'int',
                'X-RateLimit-Limit': 'int',
                'X-RateLimit-Remaining': 'int',
                'X-RateLimit-Reset': 'str',
            }

        if raw:
            client_raw_response = ClientRawResponse(deserialized, response)
            client_raw_response.add_headers(header_dict)
            return client_raw_response

        return deserialized
    create_language_generation_endpoint.metadata = {'url': '/api/languagegeneration/v2.0/Endpoints'}

    def get_language_generation_endpoint(
            self, id, custom_headers=None, raw=False, **operation_config):
        """Gets the specified deployed language generation endpoint.

        :param id:
        :type id: str
        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :return: object or ClientRawResponse if raw=true
        :rtype: object or ~msrest.pipeline.ClientRawResponse
        :raises:
         :class:`HttpOperationError<msrest.exceptions.HttpOperationError>`
        """
        # Construct URL
        url = self.get_language_generation_endpoint.metadata['url']
        path_format_arguments = {
            'id': self._serialize.url("id", id, 'str')
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}

        # Construct headers
        header_parameters = {}
        header_parameters['Accept'] = 'application/json'
        if custom_headers:
            header_parameters.update(custom_headers)

        # Construct and send request
        request = self._client.get(url, query_parameters, header_parameters)
        response = self._client.send(request, stream=False, **operation_config)

        if response.status_code not in [200, 401, 403, 429]:
            raise HttpOperationError(self._deserialize, response)

        deserialized = None
        header_dict = {}

        if response.status_code == 200:
            deserialized = self._deserialize('Endpoint', response)
            header_dict = {
                'Retry-After': 'int',
                'X-RateLimit-Limit': 'int',
                'X-RateLimit-Remaining': 'int',
                'X-RateLimit-Reset': 'str',
            }
        if response.status_code == 401:
            deserialized = self._deserialize('ErrorContent', response)
            header_dict = {
                'Retry-After': 'int',
                'X-RateLimit-Limit': 'int',
                'X-RateLimit-Remaining': 'int',
                'X-RateLimit-Reset': 'str',
            }
        if response.status_code == 403:
            deserialized = self._deserialize('ErrorContent', response)
            header_dict = {
                'Retry-After': 'int',
                'X-RateLimit-Limit': 'int',
                'X-RateLimit-Remaining': 'int',
                'X-RateLimit-Reset': 'str',
            }
        if response.status_code == 429:
            deserialized = self._deserialize('ErrorContent', response)
            header_dict = {
                'Retry-After': 'int',
                'X-RateLimit-Limit': 'int',
                'X-RateLimit-Remaining': 'int',
                'X-RateLimit-Reset': 'str',
            }

        if raw:
            client_raw_response = ClientRawResponse(deserialized, response)
            client_raw_response.add_headers(header_dict)
            return client_raw_response

        return deserialized
    get_language_generation_endpoint.metadata = {'url': '/api/languagegeneration/v2.0/Endpoints/{id}'}

    def delete_language_generation_endpoint(
            self, id, custom_headers=None, raw=False, **operation_config):
        """Deletes the language generation model endpoint with the given id.

        :param id: The identifier of the language generation model endpoint.
        :type id: str
        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :return: ErrorContent or ClientRawResponse if raw=true
        :rtype: ~azure.cognitiveservices.speechservices.models.ErrorContent or
         ~msrest.pipeline.ClientRawResponse
        :raises:
         :class:`HttpOperationError<msrest.exceptions.HttpOperationError>`
        """
        # Construct URL
        url = self.delete_language_generation_endpoint.metadata['url']
        path_format_arguments = {
            'id': self._serialize.url("id", id, 'str')
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}

        # Construct headers
        header_parameters = {}
        header_parameters['Accept'] = 'application/json'
        if custom_headers:
            header_parameters.update(custom_headers)

        # Construct and send request
        request = self._client.delete(url, query_parameters, header_parameters)
        response = self._client.send(request, stream=False, **operation_config)

        if response.status_code not in [204, 401, 403, 405, 429]:
            raise HttpOperationError(self._deserialize, response)

        deserialized = None
        header_dict = {}

        if response.status_code == 401:
            deserialized = self._deserialize('ErrorContent', response)
            header_dict = {
                'X-RateLimit-Limit': 'int',
                'X-RateLimit-Remaining': 'int',
                'X-RateLimit-Reset': 'str',
                'Retry-After': 'int',
            }
        if response.status_code == 403:
            deserialized = self._deserialize('ErrorContent', response)
            header_dict = {
                'X-RateLimit-Limit': 'int',
                'X-RateLimit-Remaining': 'int',
                'X-RateLimit-Reset': 'str',
                'Retry-After': 'int',
            }
        if response.status_code == 405:
            deserialized = self._deserialize('ErrorContent', response)
            header_dict = {
                'X-RateLimit-Limit': 'int',
                'X-RateLimit-Remaining': 'int',
                'X-RateLimit-Reset': 'str',
                'Retry-After': 'int',
            }
        if response.status_code == 429:
            deserialized = self._deserialize('ErrorContent', response)
            header_dict = {
                'X-RateLimit-Limit': 'int',
                'X-RateLimit-Remaining': 'int',
                'X-RateLimit-Reset': 'str',
                'Retry-After': 'int',
            }

        if raw:
            client_raw_response = ClientRawResponse(deserialized, response)
            client_raw_response.add_headers(header_dict)
            return client_raw_response

        return deserialized
    delete_language_generation_endpoint.metadata = {'url': '/api/languagegeneration/v2.0/Endpoints/{id}'}

    def update_language_generation_endpoint(
            self, id, name, description=None, custom_headers=None, raw=False, **operation_config):
        """Updates the mutable details of the language generation endpoint
        identified by its id.

        :param id: The identifier of the language generation model endpoint.
        :type id: str
        :param name: The name of the object
        :type name: str
        :param description: The description of the object
        :type description: str
        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :return: object or ClientRawResponse if raw=true
        :rtype: object or ~msrest.pipeline.ClientRawResponse
        :raises:
         :class:`HttpOperationError<msrest.exceptions.HttpOperationError>`
        """
        endpoint_update = models.EndpointUpdate(name=name, description=description)

        # Construct URL
        url = self.update_language_generation_endpoint.metadata['url']
        path_format_arguments = {
            'id': self._serialize.url("id", id, 'str')
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}

        # Construct headers
        header_parameters = {}
        header_parameters['Accept'] = 'application/json'
        header_parameters['Content-Type'] = 'application/json; charset=utf-8'
        if custom_headers:
            header_parameters.update(custom_headers)

        # Construct body
        body_content = self._serialize.body(endpoint_update, 'EndpointUpdate')

        # Construct and send request
        request = self._client.patch(url, query_parameters, header_parameters, body_content)
        response = self._client.send(request, stream=False, **operation_config)

        if response.status_code not in [200, 400, 401, 403, 409, 429]:
            raise HttpOperationError(self._deserialize, response)

        deserialized = None
        header_dict = {}

        if response.status_code == 200:
            deserialized = self._deserialize('Endpoint', response)
            header_dict = {
                'X-RateLimit-Limit': 'int',
                'X-RateLimit-Remaining': 'int',
                'X-RateLimit-Reset': 'str',
                'Retry-After': 'int',
            }
        if response.status_code == 400:
            deserialized = self._deserialize('ErrorContent', response)
            header_dict = {
                'X-RateLimit-Limit': 'int',
                'X-RateLimit-Remaining': 'int',
                'X-RateLimit-Reset': 'str',
                'Retry-After': 'int',
            }
        if response.status_code == 401:
            deserialized = self._deserialize('ErrorContent', response)
            header_dict = {
                'X-RateLimit-Limit': 'int',
                'X-RateLimit-Remaining': 'int',
                'X-RateLimit-Reset': 'str',
                'Retry-After': 'int',
            }
        if response.status_code == 403:
            deserialized = self._deserialize('ErrorContent', response)
            header_dict = {
                'X-RateLimit-Limit': 'int',
                'X-RateLimit-Remaining': 'int',
                'X-RateLimit-Reset': 'str',
                'Retry-After': 'int',
            }
        if response.status_code == 409:
            deserialized = self._deserialize('ErrorContent', response)
            header_dict = {
                'X-RateLimit-Limit': 'int',
                'X-RateLimit-Remaining': 'int',
                'X-RateLimit-Reset': 'str',
                'Retry-After': 'int',
            }
        if response.status_code == 429:
            deserialized = self._deserialize('ErrorContent', response)
            header_dict = {
                'X-RateLimit-Limit': 'int',
                'X-RateLimit-Remaining': 'int',
                'X-RateLimit-Reset': 'str',
                'Retry-After': 'int',
            }

        if raw:
            client_raw_response = ClientRawResponse(deserialized, response)
            client_raw_response.add_headers(header_dict)
            return client_raw_response

        return deserialized
    update_language_generation_endpoint.metadata = {'url': '/api/languagegeneration/v2.0/Endpoints/{id}'}

    def get_supported_locales_for_language_generation_endpoints(
            self, custom_headers=None, raw=False, **operation_config):
        """Gets a list of supported locales for language generation endpoint
        creation.

        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :return: object or ClientRawResponse if raw=true
        :rtype: object or ~msrest.pipeline.ClientRawResponse
        :raises:
         :class:`HttpOperationError<msrest.exceptions.HttpOperationError>`
        """
        # Construct URL
        url = self.get_supported_locales_for_language_generation_endpoints.metadata['url']

        # Construct parameters
        query_parameters = {}

        # Construct headers
        header_parameters = {}
        header_parameters['Accept'] = 'application/json'
        if custom_headers:
            header_parameters.update(custom_headers)

        # Construct and send request
        request = self._client.get(url, query_parameters, header_parameters)
        response = self._client.send(request, stream=False, **operation_config)

        if response.status_code not in [200, 401, 403, 429]:
            raise HttpOperationError(self._deserialize, response)

        deserialized = None
        header_dict = {}

        if response.status_code == 200:
            deserialized = self._deserialize('[str]', response)
            header_dict = {
                'X-RateLimit-Limit': 'int',
                'X-RateLimit-Remaining': 'int',
                'X-RateLimit-Reset': 'str',
                'Retry-After': 'int',
            }
        if response.status_code == 401:
            deserialized = self._deserialize('ErrorContent', response)
            header_dict = {
                'X-RateLimit-Limit': 'int',
                'X-RateLimit-Remaining': 'int',
                'X-RateLimit-Reset': 'str',
                'Retry-After': 'int',
            }
        if response.status_code == 403:
            deserialized = self._deserialize('ErrorContent', response)
            header_dict = {
                'X-RateLimit-Limit': 'int',
                'X-RateLimit-Remaining': 'int',
                'X-RateLimit-Reset': 'str',
                'Retry-After': 'int',
            }
        if response.status_code == 429:
            deserialized = self._deserialize('ErrorContent', response)
            header_dict = {
                'X-RateLimit-Limit': 'int',
                'X-RateLimit-Remaining': 'int',
                'X-RateLimit-Reset': 'str',
                'Retry-After': 'int',
            }

        if raw:
            client_raw_response = ClientRawResponse(deserialized, response)
            client_raw_response.add_headers(header_dict)
            return client_raw_response

        return deserialized
    get_supported_locales_for_language_generation_endpoints.metadata = {'url': '/api/languagegeneration/v2.0/Endpoints/locales'}

    def get_language_generation_models(
            self, custom_headers=None, raw=False, **operation_config):
        """Gets all language generation model of a subscription.

        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :return: object or ClientRawResponse if raw=true
        :rtype: object or ~msrest.pipeline.ClientRawResponse
        :raises:
         :class:`HttpOperationError<msrest.exceptions.HttpOperationError>`
        """
        # Construct URL
        url = self.get_language_generation_models.metadata['url']

        # Construct parameters
        query_parameters = {}

        # Construct headers
        header_parameters = {}
        header_parameters['Accept'] = 'application/json'
        if custom_headers:
            header_parameters.update(custom_headers)

        # Construct and send request
        request = self._client.get(url, query_parameters, header_parameters)
        response = self._client.send(request, stream=False, **operation_config)

        if response.status_code not in [200, 401, 403, 429]:
            raise HttpOperationError(self._deserialize, response)

        deserialized = None
        header_dict = {}

        if response.status_code == 200:
            deserialized = self._deserialize('[Model]', response)
            header_dict = {
                'X-RateLimit-Limit': 'int',
                'X-RateLimit-Remaining': 'int',
                'X-RateLimit-Reset': 'str',
                'Retry-After': 'int',
            }
        if response.status_code == 401:
            deserialized = self._deserialize('ErrorContent', response)
            header_dict = {
                'X-RateLimit-Limit': 'int',
                'X-RateLimit-Remaining': 'int',
                'X-RateLimit-Reset': 'str',
                'Retry-After': 'int',
            }
        if response.status_code == 403:
            deserialized = self._deserialize('ErrorContent', response)
            header_dict = {
                'X-RateLimit-Limit': 'int',
                'X-RateLimit-Remaining': 'int',
                'X-RateLimit-Reset': 'str',
                'Retry-After': 'int',
            }
        if response.status_code == 429:
            deserialized = self._deserialize('ErrorContent', response)
            header_dict = {
                'X-RateLimit-Limit': 'int',
                'X-RateLimit-Remaining': 'int',
                'X-RateLimit-Reset': 'str',
                'Retry-After': 'int',
            }

        if raw:
            client_raw_response = ClientRawResponse(deserialized, response)
            client_raw_response.add_headers(header_dict)
            return client_raw_response

        return deserialized
    get_language_generation_models.metadata = {'url': '/api/languagegeneration/v2.0/Models'}

    def create_language_generation_model(
            self, model_definition, custom_headers=None, raw=False, **operation_config):
        """Creates a new language generation model.

        :param model_definition:
        :type model_definition:
         ~azure.cognitiveservices.speechservices.models.ModelDefinition
        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :return: ErrorContent or ClientRawResponse if raw=true
        :rtype: ~azure.cognitiveservices.speechservices.models.ErrorContent or
         ~msrest.pipeline.ClientRawResponse
        :raises:
         :class:`HttpOperationError<msrest.exceptions.HttpOperationError>`
        """
        # Construct URL
        url = self.create_language_generation_model.metadata['url']

        # Construct parameters
        query_parameters = {}

        # Construct headers
        header_parameters = {}
        header_parameters['Accept'] = 'application/json'
        header_parameters['Content-Type'] = 'application/json; charset=utf-8'
        if custom_headers:
            header_parameters.update(custom_headers)

        # Construct body
        body_content = self._serialize.body(model_definition, 'ModelDefinition')

        # Construct and send request
        request = self._client.post(url, query_parameters, header_parameters, body_content)
        response = self._client.send(request, stream=False, **operation_config)

        if response.status_code not in [202, 204, 400, 401, 403, 429]:
            raise HttpOperationError(self._deserialize, response)

        deserialized = None
        header_dict = {}

        if response.status_code == 400:
            deserialized = self._deserialize('ErrorContent', response)
            header_dict = {
                'Location': 'str',
                'Operation-Location': 'str',
                'Retry-After': 'int',
                'X-RateLimit-Limit': 'int',
                'X-RateLimit-Remaining': 'int',
                'X-RateLimit-Reset': 'str',
            }
        if response.status_code == 401:
            deserialized = self._deserialize('ErrorContent', response)
            header_dict = {
                'Location': 'str',
                'Operation-Location': 'str',
                'Retry-After': 'int',
                'X-RateLimit-Limit': 'int',
                'X-RateLimit-Remaining': 'int',
                'X-RateLimit-Reset': 'str',
            }
        if response.status_code == 403:
            deserialized = self._deserialize('ErrorContent', response)
            header_dict = {
                'Location': 'str',
                'Operation-Location': 'str',
                'Retry-After': 'int',
                'X-RateLimit-Limit': 'int',
                'X-RateLimit-Remaining': 'int',
                'X-RateLimit-Reset': 'str',
            }
        if response.status_code == 429:
            deserialized = self._deserialize('ErrorContent', response)
            header_dict = {
                'Location': 'str',
                'Operation-Location': 'str',
                'Retry-After': 'int',
                'X-RateLimit-Limit': 'int',
                'X-RateLimit-Remaining': 'int',
                'X-RateLimit-Reset': 'str',
            }

        if raw:
            client_raw_response = ClientRawResponse(deserialized, response)
            client_raw_response.add_headers(header_dict)
            return client_raw_response

        return deserialized
    create_language_generation_model.metadata = {'url': '/api/languagegeneration/v2.0/Models'}

    def get_language_generation_model(
            self, id, custom_headers=None, raw=False, **operation_config):
        """Gets the specified language generation model.

        :param id:
        :type id: str
        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :return: object or ClientRawResponse if raw=true
        :rtype: object or ~msrest.pipeline.ClientRawResponse
        :raises:
         :class:`HttpOperationError<msrest.exceptions.HttpOperationError>`
        """
        # Construct URL
        url = self.get_language_generation_model.metadata['url']
        path_format_arguments = {
            'id': self._serialize.url("id", id, 'str')
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}

        # Construct headers
        header_parameters = {}
        header_parameters['Accept'] = 'application/json'
        if custom_headers:
            header_parameters.update(custom_headers)

        # Construct and send request
        request = self._client.get(url, query_parameters, header_parameters)
        response = self._client.send(request, stream=False, **operation_config)

        if response.status_code not in [200, 401, 403, 429]:
            raise HttpOperationError(self._deserialize, response)

        deserialized = None
        header_dict = {}

        if response.status_code == 200:
            deserialized = self._deserialize('Model', response)
            header_dict = {
                'Retry-After': 'int',
                'X-RateLimit-Limit': 'int',
                'X-RateLimit-Remaining': 'int',
                'X-RateLimit-Reset': 'str',
            }
        if response.status_code == 401:
            deserialized = self._deserialize('ErrorContent', response)
            header_dict = {
                'Retry-After': 'int',
                'X-RateLimit-Limit': 'int',
                'X-RateLimit-Remaining': 'int',
                'X-RateLimit-Reset': 'str',
            }
        if response.status_code == 403:
            deserialized = self._deserialize('ErrorContent', response)
            header_dict = {
                'Retry-After': 'int',
                'X-RateLimit-Limit': 'int',
                'X-RateLimit-Remaining': 'int',
                'X-RateLimit-Reset': 'str',
            }
        if response.status_code == 429:
            deserialized = self._deserialize('ErrorContent', response)
            header_dict = {
                'Retry-After': 'int',
                'X-RateLimit-Limit': 'int',
                'X-RateLimit-Remaining': 'int',
                'X-RateLimit-Reset': 'str',
            }

        if raw:
            client_raw_response = ClientRawResponse(deserialized, response)
            client_raw_response.add_headers(header_dict)
            return client_raw_response

        return deserialized
    get_language_generation_model.metadata = {'url': '/api/languagegeneration/v2.0/Models/{id}'}

    def delete_language_generation_model(
            self, id, custom_headers=None, raw=False, **operation_config):
        """Deletes the language generation model with the given id.

        :param id: The identifier of the language generation model.
        :type id: str
        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :return: ErrorContent or ClientRawResponse if raw=true
        :rtype: ~azure.cognitiveservices.speechservices.models.ErrorContent or
         ~msrest.pipeline.ClientRawResponse
        :raises:
         :class:`HttpOperationError<msrest.exceptions.HttpOperationError>`
        """
        # Construct URL
        url = self.delete_language_generation_model.metadata['url']
        path_format_arguments = {
            'id': self._serialize.url("id", id, 'str')
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}

        # Construct headers
        header_parameters = {}
        header_parameters['Accept'] = 'application/json'
        if custom_headers:
            header_parameters.update(custom_headers)

        # Construct and send request
        request = self._client.delete(url, query_parameters, header_parameters)
        response = self._client.send(request, stream=False, **operation_config)

        if response.status_code not in [204, 401, 403, 405, 429]:
            raise HttpOperationError(self._deserialize, response)

        deserialized = None
        header_dict = {}

        if response.status_code == 401:
            deserialized = self._deserialize('ErrorContent', response)
            header_dict = {
                'X-RateLimit-Limit': 'int',
                'X-RateLimit-Remaining': 'int',
                'X-RateLimit-Reset': 'str',
                'Retry-After': 'int',
            }
        if response.status_code == 403:
            deserialized = self._deserialize('ErrorContent', response)
            header_dict = {
                'X-RateLimit-Limit': 'int',
                'X-RateLimit-Remaining': 'int',
                'X-RateLimit-Reset': 'str',
                'Retry-After': 'int',
            }
        if response.status_code == 405:
            deserialized = self._deserialize('ErrorContent', response)
            header_dict = {
                'X-RateLimit-Limit': 'int',
                'X-RateLimit-Remaining': 'int',
                'X-RateLimit-Reset': 'str',
                'Retry-After': 'int',
            }
        if response.status_code == 429:
            deserialized = self._deserialize('ErrorContent', response)
            header_dict = {
                'X-RateLimit-Limit': 'int',
                'X-RateLimit-Remaining': 'int',
                'X-RateLimit-Reset': 'str',
                'Retry-After': 'int',
            }

        if raw:
            client_raw_response = ClientRawResponse(deserialized, response)
            client_raw_response.add_headers(header_dict)
            return client_raw_response

        return deserialized
    delete_language_generation_model.metadata = {'url': '/api/languagegeneration/v2.0/Models/{id}'}

    def update_language_generation_model(
            self, id, name, description=None, custom_headers=None, raw=False, **operation_config):
        """Updates the mutable details of the language generation model identified
        by its id.

        :param id: The route parameter identifies the language generation
         model to change.
        :type id: str
        :param name: The name of the object
        :type name: str
        :param description: The description of the object
        :type description: str
        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :return: object or ClientRawResponse if raw=true
        :rtype: object or ~msrest.pipeline.ClientRawResponse
        :raises:
         :class:`HttpOperationError<msrest.exceptions.HttpOperationError>`
        """
        model_update = models.ModelUpdate(name=name, description=description)

        # Construct URL
        url = self.update_language_generation_model.metadata['url']
        path_format_arguments = {
            'id': self._serialize.url("id", id, 'str')
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}

        # Construct headers
        header_parameters = {}
        header_parameters['Accept'] = 'application/json'
        header_parameters['Content-Type'] = 'application/json; charset=utf-8'
        if custom_headers:
            header_parameters.update(custom_headers)

        # Construct body
        body_content = self._serialize.body(model_update, 'ModelUpdate')

        # Construct and send request
        request = self._client.patch(url, query_parameters, header_parameters, body_content)
        response = self._client.send(request, stream=False, **operation_config)

        if response.status_code not in [200, 400, 401, 403, 409, 429]:
            raise HttpOperationError(self._deserialize, response)

        deserialized = None
        header_dict = {}

        if response.status_code == 200:
            deserialized = self._deserialize('Model', response)
            header_dict = {
                'X-RateLimit-Limit': 'int',
                'X-RateLimit-Remaining': 'int',
                'X-RateLimit-Reset': 'str',
                'Retry-After': 'int',
            }
        if response.status_code == 400:
            deserialized = self._deserialize('ErrorContent', response)
            header_dict = {
                'X-RateLimit-Limit': 'int',
                'X-RateLimit-Remaining': 'int',
                'X-RateLimit-Reset': 'str',
                'Retry-After': 'int',
            }
        if response.status_code == 401:
            deserialized = self._deserialize('ErrorContent', response)
            header_dict = {
                'X-RateLimit-Limit': 'int',
                'X-RateLimit-Remaining': 'int',
                'X-RateLimit-Reset': 'str',
                'Retry-After': 'int',
            }
        if response.status_code == 403:
            deserialized = self._deserialize('ErrorContent', response)
            header_dict = {
                'X-RateLimit-Limit': 'int',
                'X-RateLimit-Remaining': 'int',
                'X-RateLimit-Reset': 'str',
                'Retry-After': 'int',
            }
        if response.status_code == 409:
            deserialized = self._deserialize('ErrorContent', response)
            header_dict = {
                'X-RateLimit-Limit': 'int',
                'X-RateLimit-Remaining': 'int',
                'X-RateLimit-Reset': 'str',
                'Retry-After': 'int',
            }
        if response.status_code == 429:
            deserialized = self._deserialize('ErrorContent', response)
            header_dict = {
                'X-RateLimit-Limit': 'int',
                'X-RateLimit-Remaining': 'int',
                'X-RateLimit-Reset': 'str',
                'Retry-After': 'int',
            }

        if raw:
            client_raw_response = ClientRawResponse(deserialized, response)
            client_raw_response.add_headers(header_dict)
            return client_raw_response

        return deserialized
    update_language_generation_model.metadata = {'url': '/api/languagegeneration/v2.0/Models/{id}'}

    def get_supported_locales_for_language_generation_models(
            self, custom_headers=None, raw=False, **operation_config):
        """Gets a list of supported locales for language generation model
        creation.

        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :return: object or ClientRawResponse if raw=true
        :rtype: object or ~msrest.pipeline.ClientRawResponse
        :raises:
         :class:`HttpOperationError<msrest.exceptions.HttpOperationError>`
        """
        # Construct URL
        url = self.get_supported_locales_for_language_generation_models.metadata['url']

        # Construct parameters
        query_parameters = {}

        # Construct headers
        header_parameters = {}
        header_parameters['Accept'] = 'application/json'
        if custom_headers:
            header_parameters.update(custom_headers)

        # Construct and send request
        request = self._client.get(url, query_parameters, header_parameters)
        response = self._client.send(request, stream=False, **operation_config)

        if response.status_code not in [200, 401, 403, 429]:
            raise HttpOperationError(self._deserialize, response)

        deserialized = None
        header_dict = {}

        if response.status_code == 200:
            deserialized = self._deserialize('[str]', response)
            header_dict = {
                'X-RateLimit-Limit': 'int',
                'X-RateLimit-Remaining': 'int',
                'X-RateLimit-Reset': 'str',
                'Retry-After': 'int',
            }
        if response.status_code == 401:
            deserialized = self._deserialize('ErrorContent', response)
            header_dict = {
                'X-RateLimit-Limit': 'int',
                'X-RateLimit-Remaining': 'int',
                'X-RateLimit-Reset': 'str',
                'Retry-After': 'int',
            }
        if response.status_code == 403:
            deserialized = self._deserialize('ErrorContent', response)
            header_dict = {
                'X-RateLimit-Limit': 'int',
                'X-RateLimit-Remaining': 'int',
                'X-RateLimit-Reset': 'str',
                'Retry-After': 'int',
            }
        if response.status_code == 429:
            deserialized = self._deserialize('ErrorContent', response)
            header_dict = {
                'X-RateLimit-Limit': 'int',
                'X-RateLimit-Remaining': 'int',
                'X-RateLimit-Reset': 'str',
                'Retry-After': 'int',
            }

        if raw:
            client_raw_response = ClientRawResponse(deserialized, response)
            client_raw_response.add_headers(header_dict)
            return client_raw_response

        return deserialized
    get_supported_locales_for_language_generation_models.metadata = {'url': '/api/languagegeneration/v2.0/Models/locales'}

    def get_health_status(
            self, custom_headers=None, raw=False, **operation_config):
        """The action returns the health of the different components of the
        serivce.

        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :return: HealthStatusResponse or ClientRawResponse if raw=true
        :rtype:
         ~azure.cognitiveservices.speechservices.models.HealthStatusResponse or
         ~msrest.pipeline.ClientRawResponse
        :raises:
         :class:`HttpOperationError<msrest.exceptions.HttpOperationError>`
        """
        # Construct URL
        url = self.get_health_status.metadata['url']

        # Construct parameters
        query_parameters = {}

        # Construct headers
        header_parameters = {}
        header_parameters['Accept'] = 'application/json'
        if custom_headers:
            header_parameters.update(custom_headers)

        # Construct and send request
        request = self._client.get(url, query_parameters, header_parameters)
        response = self._client.send(request, stream=False, **operation_config)

        if response.status_code not in [200]:
            raise HttpOperationError(self._deserialize, response)

        deserialized = None
        header_dict = {}

        if response.status_code == 200:
            deserialized = self._deserialize('HealthStatusResponse', response)
            header_dict = {
                'X-RateLimit-Limit': 'int',
                'X-RateLimit-Remaining': 'int',
                'X-RateLimit-Reset': 'str',
            }

        if raw:
            client_raw_response = ClientRawResponse(deserialized, response)
            client_raw_response.add_headers(header_dict)
            return client_raw_response

        return deserialized
    get_health_status.metadata = {'url': '/api/common/v2.0/healthstatus'}

    def get_voice_datasets(
            self, custom_headers=None, raw=False, **operation_config):
        """Gets all voice datasets of a user.

        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :return: object or ClientRawResponse if raw=true
        :rtype: object or ~msrest.pipeline.ClientRawResponse
        :raises:
         :class:`HttpOperationError<msrest.exceptions.HttpOperationError>`
        """
        # Construct URL
        url = self.get_voice_datasets.metadata['url']

        # Construct parameters
        query_parameters = {}

        # Construct headers
        header_parameters = {}
        header_parameters['Accept'] = 'application/json'
        if custom_headers:
            header_parameters.update(custom_headers)

        # Construct and send request
        request = self._client.get(url, query_parameters, header_parameters)
        response = self._client.send(request, stream=False, **operation_config)

        if response.status_code not in [200, 401, 403, 429]:
            raise HttpOperationError(self._deserialize, response)

        deserialized = None
        header_dict = {}

        if response.status_code == 200:
            deserialized = self._deserialize('[Dataset]', response)
            header_dict = {
                'X-RateLimit-Limit': 'int',
                'X-RateLimit-Remaining': 'int',
                'X-RateLimit-Reset': 'str',
                'Retry-After': 'int',
            }
        if response.status_code == 401:
            deserialized = self._deserialize('ErrorContent', response)
            header_dict = {
                'X-RateLimit-Limit': 'int',
                'X-RateLimit-Remaining': 'int',
                'X-RateLimit-Reset': 'str',
                'Retry-After': 'int',
            }
        if response.status_code == 403:
            deserialized = self._deserialize('ErrorContent', response)
            header_dict = {
                'X-RateLimit-Limit': 'int',
                'X-RateLimit-Remaining': 'int',
                'X-RateLimit-Reset': 'str',
                'Retry-After': 'int',
            }
        if response.status_code == 429:
            deserialized = self._deserialize('ErrorContent', response)
            header_dict = {
                'X-RateLimit-Limit': 'int',
                'X-RateLimit-Remaining': 'int',
                'X-RateLimit-Reset': 'str',
                'Retry-After': 'int',
            }

        if raw:
            client_raw_response = ClientRawResponse(deserialized, response)
            client_raw_response.add_headers(header_dict)
            return client_raw_response

        return deserialized
    get_voice_datasets.metadata = {'url': '/api/texttospeech/v2.0/datasets'}

    def get_supported_locales_for_voice_datasets(
            self, custom_headers=None, raw=False, **operation_config):
        """Gets a list of supported locales for custom voice data imports.

        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :return: object or ClientRawResponse if raw=true
        :rtype: object or ~msrest.pipeline.ClientRawResponse
        :raises:
         :class:`HttpOperationError<msrest.exceptions.HttpOperationError>`
        """
        # Construct URL
        url = self.get_supported_locales_for_voice_datasets.metadata['url']

        # Construct parameters
        query_parameters = {}

        # Construct headers
        header_parameters = {}
        header_parameters['Accept'] = 'application/json'
        if custom_headers:
            header_parameters.update(custom_headers)

        # Construct and send request
        request = self._client.get(url, query_parameters, header_parameters)
        response = self._client.send(request, stream=False, **operation_config)

        if response.status_code not in [200, 401, 403, 429]:
            raise HttpOperationError(self._deserialize, response)

        deserialized = None
        header_dict = {}

        if response.status_code == 200:
            deserialized = self._deserialize('[str]', response)
            header_dict = {
                'X-RateLimit-Limit': 'int',
                'X-RateLimit-Remaining': 'int',
                'X-RateLimit-Reset': 'str',
                'Retry-After': 'int',
            }
        if response.status_code == 401:
            deserialized = self._deserialize('ErrorContent', response)
            header_dict = {
                'X-RateLimit-Limit': 'int',
                'X-RateLimit-Remaining': 'int',
                'X-RateLimit-Reset': 'str',
                'Retry-After': 'int',
            }
        if response.status_code == 403:
            deserialized = self._deserialize('ErrorContent', response)
            header_dict = {
                'X-RateLimit-Limit': 'int',
                'X-RateLimit-Remaining': 'int',
                'X-RateLimit-Reset': 'str',
                'Retry-After': 'int',
            }
        if response.status_code == 429:
            deserialized = self._deserialize('ErrorContent', response)
            header_dict = {
                'X-RateLimit-Limit': 'int',
                'X-RateLimit-Remaining': 'int',
                'X-RateLimit-Reset': 'str',
                'Retry-After': 'int',
            }

        if raw:
            client_raw_response = ClientRawResponse(deserialized, response)
            client_raw_response.add_headers(header_dict)
            return client_raw_response

        return deserialized
    get_supported_locales_for_voice_datasets.metadata = {'url': '/api/texttospeech/v2.0/datasets/locales'}

    def upload_voice_dataset(
            self, name=None, description=None, locale=None, data_import_kind=None, properties=None, audiodata=None, transcriptions=None, custom_headers=None, raw=False, **operation_config):
        """Uploads data and creates a new voice data object.

        :param name: The name of this data import (always add this string for
         any import).
        :type name: str
        :param description: Optional description of this data import.
        :type description: str
        :param locale: The locale of this data import (always add this string
         for any import).
        :type locale: str
        :param data_import_kind: The kind of the data import (always add this
         string for any import). Possible values include: 'None', 'Language',
         'Acoustic', 'Pronunciation', 'CustomVoice', 'LanguageGeneration'
        :type data_import_kind: str
        :param properties: Optional properties of this data import (json
         serialized object with key/values, where all values must be strings)
        :type properties: str
        :param audiodata: A zip file containing the audio data.
        :type audiodata: Generator
        :param transcriptions: The transcriptions text file of the audio data.
        :type transcriptions: Generator
        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :return: ErrorContent or ClientRawResponse if raw=true
        :rtype: ~azure.cognitiveservices.speechservices.models.ErrorContent or
         ~msrest.pipeline.ClientRawResponse
        :raises:
         :class:`HttpOperationError<msrest.exceptions.HttpOperationError>`
        """
        # Construct URL
        url = self.upload_voice_dataset.metadata['url']

        # Construct parameters
        query_parameters = {}

        # Construct headers
        header_parameters = {}
        header_parameters['Accept'] = 'application/json'
        header_parameters['Content-Type'] = 'multipart/form-data'
        if custom_headers:
            header_parameters.update(custom_headers)

        # Construct form data
        form_data_content = {
            'name': name,
            'description': description,
            'locale': locale,
            'dataImportKind': data_import_kind,
            'properties': properties,
            'audiodata': audiodata,
            'transcriptions': transcriptions,
        }

        # Construct and send request
        request = self._client.post(url, query_parameters, header_parameters, form_content=form_data_content)
        response = self._client.send(request, stream=False, **operation_config)

        if response.status_code not in [202, 400, 401, 403, 415, 429]:
            raise HttpOperationError(self._deserialize, response)

        deserialized = None
        header_dict = {}

        if response.status_code == 400:
            deserialized = self._deserialize('ErrorContent', response)
            header_dict = {
                'Location': 'str',
                'Operation-Location': 'str',
                'Retry-After': 'int',
                'X-RateLimit-Limit': 'int',
                'X-RateLimit-Remaining': 'int',
                'X-RateLimit-Reset': 'str',
            }
        if response.status_code == 401:
            deserialized = self._deserialize('ErrorContent', response)
            header_dict = {
                'Location': 'str',
                'Operation-Location': 'str',
                'Retry-After': 'int',
                'X-RateLimit-Limit': 'int',
                'X-RateLimit-Remaining': 'int',
                'X-RateLimit-Reset': 'str',
            }
        if response.status_code == 403:
            deserialized = self._deserialize('ErrorContent', response)
            header_dict = {
                'Location': 'str',
                'Operation-Location': 'str',
                'Retry-After': 'int',
                'X-RateLimit-Limit': 'int',
                'X-RateLimit-Remaining': 'int',
                'X-RateLimit-Reset': 'str',
            }
        if response.status_code == 415:
            deserialized = self._deserialize('ErrorContent', response)
            header_dict = {
                'Location': 'str',
                'Operation-Location': 'str',
                'Retry-After': 'int',
                'X-RateLimit-Limit': 'int',
                'X-RateLimit-Remaining': 'int',
                'X-RateLimit-Reset': 'str',
            }
        if response.status_code == 429:
            deserialized = self._deserialize('ErrorContent', response)
            header_dict = {
                'Location': 'str',
                'Operation-Location': 'str',
                'Retry-After': 'int',
                'X-RateLimit-Limit': 'int',
                'X-RateLimit-Remaining': 'int',
                'X-RateLimit-Reset': 'str',
            }

        if raw:
            client_raw_response = ClientRawResponse(deserialized, response)
            client_raw_response.add_headers(header_dict)
            return client_raw_response

        return deserialized
    upload_voice_dataset.metadata = {'url': '/api/texttospeech/v2.0/datasets/upload'}

    def delete_voice_dataset(
            self, id, custom_headers=None, raw=False, **operation_config):
        """Deletes the voice dataset with the given id.

        :param id: The identifier of the voice dataset
        :type id: str
        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :return: ErrorContent or ClientRawResponse if raw=true
        :rtype: ~azure.cognitiveservices.speechservices.models.ErrorContent or
         ~msrest.pipeline.ClientRawResponse
        :raises:
         :class:`HttpOperationError<msrest.exceptions.HttpOperationError>`
        """
        # Construct URL
        url = self.delete_voice_dataset.metadata['url']
        path_format_arguments = {
            'id': self._serialize.url("id", id, 'str')
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}

        # Construct headers
        header_parameters = {}
        header_parameters['Accept'] = 'application/json'
        if custom_headers:
            header_parameters.update(custom_headers)

        # Construct and send request
        request = self._client.delete(url, query_parameters, header_parameters)
        response = self._client.send(request, stream=False, **operation_config)

        if response.status_code not in [204, 401, 403, 405, 429]:
            raise HttpOperationError(self._deserialize, response)

        deserialized = None
        header_dict = {}

        if response.status_code == 401:
            deserialized = self._deserialize('ErrorContent', response)
            header_dict = {
                'X-RateLimit-Limit': 'int',
                'X-RateLimit-Remaining': 'int',
                'X-RateLimit-Reset': 'str',
                'Retry-After': 'int',
            }
        if response.status_code == 403:
            deserialized = self._deserialize('ErrorContent', response)
            header_dict = {
                'X-RateLimit-Limit': 'int',
                'X-RateLimit-Remaining': 'int',
                'X-RateLimit-Reset': 'str',
                'Retry-After': 'int',
            }
        if response.status_code == 405:
            deserialized = self._deserialize('ErrorContent', response)
            header_dict = {
                'X-RateLimit-Limit': 'int',
                'X-RateLimit-Remaining': 'int',
                'X-RateLimit-Reset': 'str',
                'Retry-After': 'int',
            }
        if response.status_code == 429:
            deserialized = self._deserialize('ErrorContent', response)
            header_dict = {
                'X-RateLimit-Limit': 'int',
                'X-RateLimit-Remaining': 'int',
                'X-RateLimit-Reset': 'str',
                'Retry-After': 'int',
            }

        if raw:
            client_raw_response = ClientRawResponse(deserialized, response)
            client_raw_response.add_headers(header_dict)
            return client_raw_response

        return deserialized
    delete_voice_dataset.metadata = {'url': '/api/texttospeech/v2.0/datasets/{id}'}

    def update_voice_dataset(
            self, id, name, description=None, custom_headers=None, raw=False, **operation_config):
        """Updates the mutable details of the voice dataset identified by its ID.

        :param id: The identifier of the voice dataset.
        :type id: str
        :param name: The name of the object
        :type name: str
        :param description: The description of the object
        :type description: str
        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :return: object or ClientRawResponse if raw=true
        :rtype: object or ~msrest.pipeline.ClientRawResponse
        :raises:
         :class:`HttpOperationError<msrest.exceptions.HttpOperationError>`
        """
        dataset_update = models.DatasetUpdate(name=name, description=description)

        # Construct URL
        url = self.update_voice_dataset.metadata['url']
        path_format_arguments = {
            'id': self._serialize.url("id", id, 'str')
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}

        # Construct headers
        header_parameters = {}
        header_parameters['Accept'] = 'application/json'
        header_parameters['Content-Type'] = 'application/json; charset=utf-8'
        if custom_headers:
            header_parameters.update(custom_headers)

        # Construct body
        body_content = self._serialize.body(dataset_update, 'DatasetUpdate')

        # Construct and send request
        request = self._client.patch(url, query_parameters, header_parameters, body_content)
        response = self._client.send(request, stream=False, **operation_config)

        if response.status_code not in [200, 400, 401, 403, 409, 415, 429]:
            raise HttpOperationError(self._deserialize, response)

        deserialized = None
        header_dict = {}

        if response.status_code == 200:
            deserialized = self._deserialize('Dataset', response)
            header_dict = {
                'X-RateLimit-Limit': 'int',
                'X-RateLimit-Remaining': 'int',
                'X-RateLimit-Reset': 'str',
                'Retry-After': 'int',
            }
        if response.status_code == 400:
            deserialized = self._deserialize('ErrorContent', response)
            header_dict = {
                'X-RateLimit-Limit': 'int',
                'X-RateLimit-Remaining': 'int',
                'X-RateLimit-Reset': 'str',
                'Retry-After': 'int',
            }
        if response.status_code == 401:
            deserialized = self._deserialize('ErrorContent', response)
            header_dict = {
                'X-RateLimit-Limit': 'int',
                'X-RateLimit-Remaining': 'int',
                'X-RateLimit-Reset': 'str',
                'Retry-After': 'int',
            }
        if response.status_code == 403:
            deserialized = self._deserialize('ErrorContent', response)
            header_dict = {
                'X-RateLimit-Limit': 'int',
                'X-RateLimit-Remaining': 'int',
                'X-RateLimit-Reset': 'str',
                'Retry-After': 'int',
            }
        if response.status_code == 409:
            deserialized = self._deserialize('ErrorContent', response)
            header_dict = {
                'X-RateLimit-Limit': 'int',
                'X-RateLimit-Remaining': 'int',
                'X-RateLimit-Reset': 'str',
                'Retry-After': 'int',
            }
        if response.status_code == 415:
            deserialized = self._deserialize('ErrorContent', response)
            header_dict = {
                'X-RateLimit-Limit': 'int',
                'X-RateLimit-Remaining': 'int',
                'X-RateLimit-Reset': 'str',
                'Retry-After': 'int',
            }
        if response.status_code == 429:
            deserialized = self._deserialize('ErrorContent', response)
            header_dict = {
                'X-RateLimit-Limit': 'int',
                'X-RateLimit-Remaining': 'int',
                'X-RateLimit-Reset': 'str',
                'Retry-After': 'int',
            }

        if raw:
            client_raw_response = ClientRawResponse(deserialized, response)
            client_raw_response.add_headers(header_dict)
            return client_raw_response

        return deserialized
    update_voice_dataset.metadata = {'url': '/api/texttospeech/v2.0/datasets/{id}'}

    def get_voice_deployments(
            self, custom_headers=None, raw=False, **operation_config):
        """Gets a list of voice endpoint details.

        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :return: object or ClientRawResponse if raw=true
        :rtype: object or ~msrest.pipeline.ClientRawResponse
        :raises:
         :class:`HttpOperationError<msrest.exceptions.HttpOperationError>`
        """
        # Construct URL
        url = self.get_voice_deployments.metadata['url']

        # Construct parameters
        query_parameters = {}

        # Construct headers
        header_parameters = {}
        header_parameters['Accept'] = 'application/json'
        if custom_headers:
            header_parameters.update(custom_headers)

        # Construct and send request
        request = self._client.get(url, query_parameters, header_parameters)
        response = self._client.send(request, stream=False, **operation_config)

        if response.status_code not in [200, 401, 403, 429]:
            raise HttpOperationError(self._deserialize, response)

        deserialized = None
        header_dict = {}

        if response.status_code == 200:
            deserialized = self._deserialize('[Endpoint]', response)
            header_dict = {
                'X-RateLimit-Limit': 'int',
                'X-RateLimit-Remaining': 'int',
                'X-RateLimit-Reset': 'str',
                'Retry-After': 'int',
            }
        if response.status_code == 401:
            deserialized = self._deserialize('ErrorContent', response)
            header_dict = {
                'X-RateLimit-Limit': 'int',
                'X-RateLimit-Remaining': 'int',
                'X-RateLimit-Reset': 'str',
                'Retry-After': 'int',
            }
        if response.status_code == 403:
            deserialized = self._deserialize('ErrorContent', response)
            header_dict = {
                'X-RateLimit-Limit': 'int',
                'X-RateLimit-Remaining': 'int',
                'X-RateLimit-Reset': 'str',
                'Retry-After': 'int',
            }
        if response.status_code == 429:
            deserialized = self._deserialize('ErrorContent', response)
            header_dict = {
                'X-RateLimit-Limit': 'int',
                'X-RateLimit-Remaining': 'int',
                'X-RateLimit-Reset': 'str',
                'Retry-After': 'int',
            }

        if raw:
            client_raw_response = ClientRawResponse(deserialized, response)
            client_raw_response.add_headers(header_dict)
            return client_raw_response

        return deserialized
    get_voice_deployments.metadata = {'url': '/api/texttospeech/v2.0/endpoints'}

    def create_voice_deployment(
            self, endpoint, custom_headers=None, raw=False, **operation_config):
        """Creates a new voice endpoint object.

        :param endpoint:
        :type endpoint:
         ~azure.cognitiveservices.speechservices.models.EndpointDefinition
        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :return: ErrorContent or ClientRawResponse if raw=true
        :rtype: ~azure.cognitiveservices.speechservices.models.ErrorContent or
         ~msrest.pipeline.ClientRawResponse
        :raises:
         :class:`HttpOperationError<msrest.exceptions.HttpOperationError>`
        """
        # Construct URL
        url = self.create_voice_deployment.metadata['url']

        # Construct parameters
        query_parameters = {}

        # Construct headers
        header_parameters = {}
        header_parameters['Accept'] = 'application/json'
        header_parameters['Content-Type'] = 'application/json; charset=utf-8'
        if custom_headers:
            header_parameters.update(custom_headers)

        # Construct body
        body_content = self._serialize.body(endpoint, 'EndpointDefinition')

        # Construct and send request
        request = self._client.post(url, query_parameters, header_parameters, body_content)
        response = self._client.send(request, stream=False, **operation_config)

        if response.status_code not in [202, 400, 401, 403, 429]:
            raise HttpOperationError(self._deserialize, response)

        deserialized = None
        header_dict = {}

        if response.status_code == 400:
            deserialized = self._deserialize('ErrorContent', response)
            header_dict = {
                'Location': 'str',
                'Operation-Location': 'str',
                'Retry-After': 'int',
                'X-RateLimit-Limit': 'int',
                'X-RateLimit-Remaining': 'int',
                'X-RateLimit-Reset': 'str',
            }
        if response.status_code == 401:
            deserialized = self._deserialize('ErrorContent', response)
            header_dict = {
                'Location': 'str',
                'Operation-Location': 'str',
                'Retry-After': 'int',
                'X-RateLimit-Limit': 'int',
                'X-RateLimit-Remaining': 'int',
                'X-RateLimit-Reset': 'str',
            }
        if response.status_code == 403:
            deserialized = self._deserialize('ErrorContent', response)
            header_dict = {
                'Location': 'str',
                'Operation-Location': 'str',
                'Retry-After': 'int',
                'X-RateLimit-Limit': 'int',
                'X-RateLimit-Remaining': 'int',
                'X-RateLimit-Reset': 'str',
            }
        if response.status_code == 429:
            deserialized = self._deserialize('ErrorContent', response)
            header_dict = {
                'Location': 'str',
                'Operation-Location': 'str',
                'Retry-After': 'int',
                'X-RateLimit-Limit': 'int',
                'X-RateLimit-Remaining': 'int',
                'X-RateLimit-Reset': 'str',
            }

        if raw:
            client_raw_response = ClientRawResponse(deserialized, response)
            client_raw_response.add_headers(header_dict)
            return client_raw_response

        return deserialized
    create_voice_deployment.metadata = {'url': '/api/texttospeech/v2.0/endpoints'}

    def get_voice_deployment(
            self, id, custom_headers=None, raw=False, **operation_config):
        """Gets the details of a Custom Voice endpoint.

        :param id:
        :type id: str
        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :return: object or ClientRawResponse if raw=true
        :rtype: object or ~msrest.pipeline.ClientRawResponse
        :raises:
         :class:`HttpOperationError<msrest.exceptions.HttpOperationError>`
        """
        # Construct URL
        url = self.get_voice_deployment.metadata['url']
        path_format_arguments = {
            'id': self._serialize.url("id", id, 'str')
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}

        # Construct headers
        header_parameters = {}
        header_parameters['Accept'] = 'application/json'
        if custom_headers:
            header_parameters.update(custom_headers)

        # Construct and send request
        request = self._client.get(url, query_parameters, header_parameters)
        response = self._client.send(request, stream=False, **operation_config)

        if response.status_code not in [200, 401, 403, 429]:
            raise HttpOperationError(self._deserialize, response)

        deserialized = None
        header_dict = {}

        if response.status_code == 200:
            deserialized = self._deserialize('Endpoint', response)
            header_dict = {
                'Retry-After': 'int',
                'X-RateLimit-Limit': 'int',
                'X-RateLimit-Remaining': 'int',
                'X-RateLimit-Reset': 'str',
            }
        if response.status_code == 401:
            deserialized = self._deserialize('ErrorContent', response)
            header_dict = {
                'Retry-After': 'int',
                'X-RateLimit-Limit': 'int',
                'X-RateLimit-Remaining': 'int',
                'X-RateLimit-Reset': 'str',
            }
        if response.status_code == 403:
            deserialized = self._deserialize('ErrorContent', response)
            header_dict = {
                'Retry-After': 'int',
                'X-RateLimit-Limit': 'int',
                'X-RateLimit-Remaining': 'int',
                'X-RateLimit-Reset': 'str',
            }
        if response.status_code == 429:
            deserialized = self._deserialize('ErrorContent', response)
            header_dict = {
                'Retry-After': 'int',
                'X-RateLimit-Limit': 'int',
                'X-RateLimit-Remaining': 'int',
                'X-RateLimit-Reset': 'str',
            }

        if raw:
            client_raw_response = ClientRawResponse(deserialized, response)
            client_raw_response.add_headers(header_dict)
            return client_raw_response

        return deserialized
    get_voice_deployment.metadata = {'url': '/api/texttospeech/v2.0/endpoints/{id}'}

    def delete_deployment(
            self, id, custom_headers=None, raw=False, **operation_config):
        """Delete the specified voice endpoint.

        :param id: The id of voice endpoint.
        :type id: str
        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :return: ErrorContent or ClientRawResponse if raw=true
        :rtype: ~azure.cognitiveservices.speechservices.models.ErrorContent or
         ~msrest.pipeline.ClientRawResponse
        :raises:
         :class:`HttpOperationError<msrest.exceptions.HttpOperationError>`
        """
        # Construct URL
        url = self.delete_deployment.metadata['url']
        path_format_arguments = {
            'id': self._serialize.url("id", id, 'str')
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}

        # Construct headers
        header_parameters = {}
        header_parameters['Accept'] = 'application/json'
        if custom_headers:
            header_parameters.update(custom_headers)

        # Construct and send request
        request = self._client.delete(url, query_parameters, header_parameters)
        response = self._client.send(request, stream=False, **operation_config)

        if response.status_code not in [204, 401, 403, 405, 429]:
            raise HttpOperationError(self._deserialize, response)

        deserialized = None
        header_dict = {}

        if response.status_code == 401:
            deserialized = self._deserialize('ErrorContent', response)
            header_dict = {
                'X-RateLimit-Limit': 'int',
                'X-RateLimit-Remaining': 'int',
                'X-RateLimit-Reset': 'str',
                'Retry-After': 'int',
            }
        if response.status_code == 403:
            deserialized = self._deserialize('ErrorContent', response)
            header_dict = {
                'X-RateLimit-Limit': 'int',
                'X-RateLimit-Remaining': 'int',
                'X-RateLimit-Reset': 'str',
                'Retry-After': 'int',
            }
        if response.status_code == 405:
            deserialized = self._deserialize('ErrorContent', response)
            header_dict = {
                'X-RateLimit-Limit': 'int',
                'X-RateLimit-Remaining': 'int',
                'X-RateLimit-Reset': 'str',
                'Retry-After': 'int',
            }
        if response.status_code == 429:
            deserialized = self._deserialize('ErrorContent', response)
            header_dict = {
                'X-RateLimit-Limit': 'int',
                'X-RateLimit-Remaining': 'int',
                'X-RateLimit-Reset': 'str',
                'Retry-After': 'int',
            }

        if raw:
            client_raw_response = ClientRawResponse(deserialized, response)
            client_raw_response.add_headers(header_dict)
            return client_raw_response

        return deserialized
    delete_deployment.metadata = {'url': '/api/texttospeech/v2.0/endpoints/{id}'}

    def update_voice_endpoint(
            self, id, name, description=None, custom_headers=None, raw=False, **operation_config):
        """Updates the name and description of the endpoint identified by the
        given ID.

        :param id: The identifier of the endpoint.
        :type id: str
        :param name: The name of the object
        :type name: str
        :param description: The description of the object
        :type description: str
        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :return: object or ClientRawResponse if raw=true
        :rtype: object or ~msrest.pipeline.ClientRawResponse
        :raises:
         :class:`HttpOperationError<msrest.exceptions.HttpOperationError>`
        """
        endpoint_update = models.EndpointUpdate(name=name, description=description)

        # Construct URL
        url = self.update_voice_endpoint.metadata['url']
        path_format_arguments = {
            'id': self._serialize.url("id", id, 'str')
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}

        # Construct headers
        header_parameters = {}
        header_parameters['Accept'] = 'application/json'
        header_parameters['Content-Type'] = 'application/json; charset=utf-8'
        if custom_headers:
            header_parameters.update(custom_headers)

        # Construct body
        body_content = self._serialize.body(endpoint_update, 'EndpointUpdate')

        # Construct and send request
        request = self._client.patch(url, query_parameters, header_parameters, body_content)
        response = self._client.send(request, stream=False, **operation_config)

        if response.status_code not in [200, 400, 401, 403, 409, 415, 429]:
            raise HttpOperationError(self._deserialize, response)

        deserialized = None
        header_dict = {}

        if response.status_code == 200:
            deserialized = self._deserialize('Endpoint', response)
            header_dict = {
                'X-RateLimit-Limit': 'int',
                'X-RateLimit-Remaining': 'int',
                'X-RateLimit-Reset': 'str',
                'Retry-After': 'int',
            }
        if response.status_code == 400:
            deserialized = self._deserialize('ErrorContent', response)
            header_dict = {
                'X-RateLimit-Limit': 'int',
                'X-RateLimit-Remaining': 'int',
                'X-RateLimit-Reset': 'str',
                'Retry-After': 'int',
            }
        if response.status_code == 401:
            deserialized = self._deserialize('ErrorContent', response)
            header_dict = {
                'X-RateLimit-Limit': 'int',
                'X-RateLimit-Remaining': 'int',
                'X-RateLimit-Reset': 'str',
                'Retry-After': 'int',
            }
        if response.status_code == 403:
            deserialized = self._deserialize('ErrorContent', response)
            header_dict = {
                'X-RateLimit-Limit': 'int',
                'X-RateLimit-Remaining': 'int',
                'X-RateLimit-Reset': 'str',
                'Retry-After': 'int',
            }
        if response.status_code == 409:
            deserialized = self._deserialize('ErrorContent', response)
            header_dict = {
                'X-RateLimit-Limit': 'int',
                'X-RateLimit-Remaining': 'int',
                'X-RateLimit-Reset': 'str',
                'Retry-After': 'int',
            }
        if response.status_code == 415:
            deserialized = self._deserialize('ErrorContent', response)
            header_dict = {
                'X-RateLimit-Limit': 'int',
                'X-RateLimit-Remaining': 'int',
                'X-RateLimit-Reset': 'str',
                'Retry-After': 'int',
            }
        if response.status_code == 429:
            deserialized = self._deserialize('ErrorContent', response)
            header_dict = {
                'X-RateLimit-Limit': 'int',
                'X-RateLimit-Remaining': 'int',
                'X-RateLimit-Reset': 'str',
                'Retry-After': 'int',
            }

        if raw:
            client_raw_response = ClientRawResponse(deserialized, response)
            client_raw_response.add_headers(header_dict)
            return client_raw_response

        return deserialized
    update_voice_endpoint.metadata = {'url': '/api/texttospeech/v2.0/endpoints/{id}'}

    def get_supported_locales_for_voice_endpoints(
            self, custom_headers=None, raw=False, **operation_config):
        """Gets a list of supported locales for custom voice Endpoints.

        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :return: object or ClientRawResponse if raw=true
        :rtype: object or ~msrest.pipeline.ClientRawResponse
        :raises:
         :class:`HttpOperationError<msrest.exceptions.HttpOperationError>`
        """
        # Construct URL
        url = self.get_supported_locales_for_voice_endpoints.metadata['url']

        # Construct parameters
        query_parameters = {}

        # Construct headers
        header_parameters = {}
        header_parameters['Accept'] = 'application/json'
        if custom_headers:
            header_parameters.update(custom_headers)

        # Construct and send request
        request = self._client.get(url, query_parameters, header_parameters)
        response = self._client.send(request, stream=False, **operation_config)

        if response.status_code not in [200, 401, 403, 429]:
            raise HttpOperationError(self._deserialize, response)

        deserialized = None
        header_dict = {}

        if response.status_code == 200:
            deserialized = self._deserialize('[str]', response)
            header_dict = {
                'X-RateLimit-Limit': 'int',
                'X-RateLimit-Remaining': 'int',
                'X-RateLimit-Reset': 'str',
                'Retry-After': 'int',
            }
        if response.status_code == 401:
            deserialized = self._deserialize('ErrorContent', response)
            header_dict = {
                'X-RateLimit-Limit': 'int',
                'X-RateLimit-Remaining': 'int',
                'X-RateLimit-Reset': 'str',
                'Retry-After': 'int',
            }
        if response.status_code == 403:
            deserialized = self._deserialize('ErrorContent', response)
            header_dict = {
                'X-RateLimit-Limit': 'int',
                'X-RateLimit-Remaining': 'int',
                'X-RateLimit-Reset': 'str',
                'Retry-After': 'int',
            }
        if response.status_code == 429:
            deserialized = self._deserialize('ErrorContent', response)
            header_dict = {
                'X-RateLimit-Limit': 'int',
                'X-RateLimit-Remaining': 'int',
                'X-RateLimit-Reset': 'str',
                'Retry-After': 'int',
            }

        if raw:
            client_raw_response = ClientRawResponse(deserialized, response)
            client_raw_response.add_headers(header_dict)
            return client_raw_response

        return deserialized
    get_supported_locales_for_voice_endpoints.metadata = {'url': '/api/texttospeech/v2.0/endpoints/locales'}

    def get_voice_models(
            self, custom_headers=None, raw=False, **operation_config):
        """Gets a list of voice model details.

        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :return: object or ClientRawResponse if raw=true
        :rtype: object or ~msrest.pipeline.ClientRawResponse
        :raises:
         :class:`HttpOperationError<msrest.exceptions.HttpOperationError>`
        """
        # Construct URL
        url = self.get_voice_models.metadata['url']

        # Construct parameters
        query_parameters = {}

        # Construct headers
        header_parameters = {}
        header_parameters['Accept'] = 'application/json'
        if custom_headers:
            header_parameters.update(custom_headers)

        # Construct and send request
        request = self._client.get(url, query_parameters, header_parameters)
        response = self._client.send(request, stream=False, **operation_config)

        if response.status_code not in [200, 401, 403, 429]:
            raise HttpOperationError(self._deserialize, response)

        deserialized = None
        header_dict = {}

        if response.status_code == 200:
            deserialized = self._deserialize('[Model]', response)
            header_dict = {
                'X-RateLimit-Limit': 'int',
                'X-RateLimit-Remaining': 'int',
                'X-RateLimit-Reset': 'str',
                'Retry-After': 'int',
            }
        if response.status_code == 401:
            deserialized = self._deserialize('ErrorContent', response)
            header_dict = {
                'X-RateLimit-Limit': 'int',
                'X-RateLimit-Remaining': 'int',
                'X-RateLimit-Reset': 'str',
                'Retry-After': 'int',
            }
        if response.status_code == 403:
            deserialized = self._deserialize('ErrorContent', response)
            header_dict = {
                'X-RateLimit-Limit': 'int',
                'X-RateLimit-Remaining': 'int',
                'X-RateLimit-Reset': 'str',
                'Retry-After': 'int',
            }
        if response.status_code == 429:
            deserialized = self._deserialize('ErrorContent', response)
            header_dict = {
                'X-RateLimit-Limit': 'int',
                'X-RateLimit-Remaining': 'int',
                'X-RateLimit-Reset': 'str',
                'Retry-After': 'int',
            }

        if raw:
            client_raw_response = ClientRawResponse(deserialized, response)
            client_raw_response.add_headers(header_dict)
            return client_raw_response

        return deserialized
    get_voice_models.metadata = {'url': '/api/texttospeech/v2.0/models'}

    def create_voice_model(
            self, model_definition, custom_headers=None, raw=False, **operation_config):
        """Creates a new voice model object.

        :param model_definition:
        :type model_definition:
         ~azure.cognitiveservices.speechservices.models.ModelDefinition
        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :return: ErrorContent or ClientRawResponse if raw=true
        :rtype: ~azure.cognitiveservices.speechservices.models.ErrorContent or
         ~msrest.pipeline.ClientRawResponse
        :raises:
         :class:`HttpOperationError<msrest.exceptions.HttpOperationError>`
        """
        # Construct URL
        url = self.create_voice_model.metadata['url']

        # Construct parameters
        query_parameters = {}

        # Construct headers
        header_parameters = {}
        header_parameters['Accept'] = 'application/json'
        header_parameters['Content-Type'] = 'application/json; charset=utf-8'
        if custom_headers:
            header_parameters.update(custom_headers)

        # Construct body
        body_content = self._serialize.body(model_definition, 'ModelDefinition')

        # Construct and send request
        request = self._client.post(url, query_parameters, header_parameters, body_content)
        response = self._client.send(request, stream=False, **operation_config)

        if response.status_code not in [202, 400, 401, 403, 429]:
            raise HttpOperationError(self._deserialize, response)

        deserialized = None
        header_dict = {}

        if response.status_code == 400:
            deserialized = self._deserialize('ErrorContent', response)
            header_dict = {
                'Location': 'str',
                'Operation-Location': 'str',
                'Retry-After': 'int',
                'X-RateLimit-Limit': 'int',
                'X-RateLimit-Remaining': 'int',
                'X-RateLimit-Reset': 'str',
            }
        if response.status_code == 401:
            deserialized = self._deserialize('ErrorContent', response)
            header_dict = {
                'Location': 'str',
                'Operation-Location': 'str',
                'Retry-After': 'int',
                'X-RateLimit-Limit': 'int',
                'X-RateLimit-Remaining': 'int',
                'X-RateLimit-Reset': 'str',
            }
        if response.status_code == 403:
            deserialized = self._deserialize('ErrorContent', response)
            header_dict = {
                'Location': 'str',
                'Operation-Location': 'str',
                'Retry-After': 'int',
                'X-RateLimit-Limit': 'int',
                'X-RateLimit-Remaining': 'int',
                'X-RateLimit-Reset': 'str',
            }
        if response.status_code == 429:
            deserialized = self._deserialize('ErrorContent', response)
            header_dict = {
                'Location': 'str',
                'Operation-Location': 'str',
                'Retry-After': 'int',
                'X-RateLimit-Limit': 'int',
                'X-RateLimit-Remaining': 'int',
                'X-RateLimit-Reset': 'str',
            }

        if raw:
            client_raw_response = ClientRawResponse(deserialized, response)
            client_raw_response.add_headers(header_dict)
            return client_raw_response

        return deserialized
    create_voice_model.metadata = {'url': '/api/texttospeech/v2.0/models'}

    def get_voice_model(
            self, id, custom_headers=None, raw=False, **operation_config):
        """Gets specified voice model details.

        :param id:
        :type id: str
        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :return: object or ClientRawResponse if raw=true
        :rtype: object or ~msrest.pipeline.ClientRawResponse
        :raises:
         :class:`HttpOperationError<msrest.exceptions.HttpOperationError>`
        """
        # Construct URL
        url = self.get_voice_model.metadata['url']
        path_format_arguments = {
            'id': self._serialize.url("id", id, 'str')
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}

        # Construct headers
        header_parameters = {}
        header_parameters['Accept'] = 'application/json'
        if custom_headers:
            header_parameters.update(custom_headers)

        # Construct and send request
        request = self._client.get(url, query_parameters, header_parameters)
        response = self._client.send(request, stream=False, **operation_config)

        if response.status_code not in [200, 401, 403, 429]:
            raise HttpOperationError(self._deserialize, response)

        deserialized = None
        header_dict = {}

        if response.status_code == 200:
            deserialized = self._deserialize('Model', response)
            header_dict = {
                'Retry-After': 'int',
                'X-RateLimit-Limit': 'int',
                'X-RateLimit-Remaining': 'int',
                'X-RateLimit-Reset': 'str',
            }
        if response.status_code == 401:
            deserialized = self._deserialize('ErrorContent', response)
            header_dict = {
                'Retry-After': 'int',
                'X-RateLimit-Limit': 'int',
                'X-RateLimit-Remaining': 'int',
                'X-RateLimit-Reset': 'str',
            }
        if response.status_code == 403:
            deserialized = self._deserialize('ErrorContent', response)
            header_dict = {
                'Retry-After': 'int',
                'X-RateLimit-Limit': 'int',
                'X-RateLimit-Remaining': 'int',
                'X-RateLimit-Reset': 'str',
            }
        if response.status_code == 429:
            deserialized = self._deserialize('ErrorContent', response)
            header_dict = {
                'Retry-After': 'int',
                'X-RateLimit-Limit': 'int',
                'X-RateLimit-Remaining': 'int',
                'X-RateLimit-Reset': 'str',
            }

        if raw:
            client_raw_response = ClientRawResponse(deserialized, response)
            client_raw_response.add_headers(header_dict)
            return client_raw_response

        return deserialized
    get_voice_model.metadata = {'url': '/api/texttospeech/v2.0/models/{id}'}

    def delete_voice_model(
            self, id, custom_headers=None, raw=False, **operation_config):
        """Deletes the voice model with the given id.

        :param id: The identifier of the voice model
        :type id: str
        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :return: ErrorContent or ClientRawResponse if raw=true
        :rtype: ~azure.cognitiveservices.speechservices.models.ErrorContent or
         ~msrest.pipeline.ClientRawResponse
        :raises:
         :class:`HttpOperationError<msrest.exceptions.HttpOperationError>`
        """
        # Construct URL
        url = self.delete_voice_model.metadata['url']
        path_format_arguments = {
            'id': self._serialize.url("id", id, 'str')
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}

        # Construct headers
        header_parameters = {}
        header_parameters['Accept'] = 'application/json'
        if custom_headers:
            header_parameters.update(custom_headers)

        # Construct and send request
        request = self._client.delete(url, query_parameters, header_parameters)
        response = self._client.send(request, stream=False, **operation_config)

        if response.status_code not in [204, 401, 403, 405, 429]:
            raise HttpOperationError(self._deserialize, response)

        deserialized = None
        header_dict = {}

        if response.status_code == 401:
            deserialized = self._deserialize('ErrorContent', response)
            header_dict = {
                'X-RateLimit-Limit': 'int',
                'X-RateLimit-Remaining': 'int',
                'X-RateLimit-Reset': 'str',
                'Retry-After': 'int',
            }
        if response.status_code == 403:
            deserialized = self._deserialize('ErrorContent', response)
            header_dict = {
                'X-RateLimit-Limit': 'int',
                'X-RateLimit-Remaining': 'int',
                'X-RateLimit-Reset': 'str',
                'Retry-After': 'int',
            }
        if response.status_code == 405:
            deserialized = self._deserialize('ErrorContent', response)
            header_dict = {
                'X-RateLimit-Limit': 'int',
                'X-RateLimit-Remaining': 'int',
                'X-RateLimit-Reset': 'str',
                'Retry-After': 'int',
            }
        if response.status_code == 429:
            deserialized = self._deserialize('ErrorContent', response)
            header_dict = {
                'X-RateLimit-Limit': 'int',
                'X-RateLimit-Remaining': 'int',
                'X-RateLimit-Reset': 'str',
                'Retry-After': 'int',
            }

        if raw:
            client_raw_response = ClientRawResponse(deserialized, response)
            client_raw_response.add_headers(header_dict)
            return client_raw_response

        return deserialized
    delete_voice_model.metadata = {'url': '/api/texttospeech/v2.0/models/{id}'}

    def update_voice_model(
            self, id, name, description=None, custom_headers=None, raw=False, **operation_config):
        """Updates the metadata of the voice model identified by the given ID.

        :param id: The identifier of the voice model.
        :type id: str
        :param name: The name of the object
        :type name: str
        :param description: The description of the object
        :type description: str
        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :return: object or ClientRawResponse if raw=true
        :rtype: object or ~msrest.pipeline.ClientRawResponse
        :raises:
         :class:`HttpOperationError<msrest.exceptions.HttpOperationError>`
        """
        model_update = models.ModelUpdate(name=name, description=description)

        # Construct URL
        url = self.update_voice_model.metadata['url']
        path_format_arguments = {
            'id': self._serialize.url("id", id, 'str')
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}

        # Construct headers
        header_parameters = {}
        header_parameters['Accept'] = 'application/json'
        header_parameters['Content-Type'] = 'application/json; charset=utf-8'
        if custom_headers:
            header_parameters.update(custom_headers)

        # Construct body
        body_content = self._serialize.body(model_update, 'ModelUpdate')

        # Construct and send request
        request = self._client.patch(url, query_parameters, header_parameters, body_content)
        response = self._client.send(request, stream=False, **operation_config)

        if response.status_code not in [200, 400, 401, 403, 409, 415, 429]:
            raise HttpOperationError(self._deserialize, response)

        deserialized = None
        header_dict = {}

        if response.status_code == 200:
            deserialized = self._deserialize('Model', response)
            header_dict = {
                'X-RateLimit-Limit': 'int',
                'X-RateLimit-Remaining': 'int',
                'X-RateLimit-Reset': 'str',
                'Retry-After': 'int',
            }
        if response.status_code == 400:
            deserialized = self._deserialize('ErrorContent', response)
            header_dict = {
                'X-RateLimit-Limit': 'int',
                'X-RateLimit-Remaining': 'int',
                'X-RateLimit-Reset': 'str',
                'Retry-After': 'int',
            }
        if response.status_code == 401:
            deserialized = self._deserialize('ErrorContent', response)
            header_dict = {
                'X-RateLimit-Limit': 'int',
                'X-RateLimit-Remaining': 'int',
                'X-RateLimit-Reset': 'str',
                'Retry-After': 'int',
            }
        if response.status_code == 403:
            deserialized = self._deserialize('ErrorContent', response)
            header_dict = {
                'X-RateLimit-Limit': 'int',
                'X-RateLimit-Remaining': 'int',
                'X-RateLimit-Reset': 'str',
                'Retry-After': 'int',
            }
        if response.status_code == 409:
            deserialized = self._deserialize('ErrorContent', response)
            header_dict = {
                'X-RateLimit-Limit': 'int',
                'X-RateLimit-Remaining': 'int',
                'X-RateLimit-Reset': 'str',
                'Retry-After': 'int',
            }
        if response.status_code == 415:
            deserialized = self._deserialize('ErrorContent', response)
            header_dict = {
                'X-RateLimit-Limit': 'int',
                'X-RateLimit-Remaining': 'int',
                'X-RateLimit-Reset': 'str',
                'Retry-After': 'int',
            }
        if response.status_code == 429:
            deserialized = self._deserialize('ErrorContent', response)
            header_dict = {
                'X-RateLimit-Limit': 'int',
                'X-RateLimit-Remaining': 'int',
                'X-RateLimit-Reset': 'str',
                'Retry-After': 'int',
            }

        if raw:
            client_raw_response = ClientRawResponse(deserialized, response)
            client_raw_response.add_headers(header_dict)
            return client_raw_response

        return deserialized
    update_voice_model.metadata = {'url': '/api/texttospeech/v2.0/models/{id}'}

    def get_supported_locales_for_voice_models(
            self, custom_headers=None, raw=False, **operation_config):
        """Gets a list of supported locales for custom voice Models.

        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :return: object or ClientRawResponse if raw=true
        :rtype: object or ~msrest.pipeline.ClientRawResponse
        :raises:
         :class:`HttpOperationError<msrest.exceptions.HttpOperationError>`
        """
        # Construct URL
        url = self.get_supported_locales_for_voice_models.metadata['url']

        # Construct parameters
        query_parameters = {}

        # Construct headers
        header_parameters = {}
        header_parameters['Accept'] = 'application/json'
        if custom_headers:
            header_parameters.update(custom_headers)

        # Construct and send request
        request = self._client.get(url, query_parameters, header_parameters)
        response = self._client.send(request, stream=False, **operation_config)

        if response.status_code not in [200, 401, 403, 429]:
            raise HttpOperationError(self._deserialize, response)

        deserialized = None
        header_dict = {}

        if response.status_code == 200:
            deserialized = self._deserialize('[str]', response)
            header_dict = {
                'X-RateLimit-Limit': 'int',
                'X-RateLimit-Remaining': 'int',
                'X-RateLimit-Reset': 'str',
                'Retry-After': 'int',
            }
        if response.status_code == 401:
            deserialized = self._deserialize('ErrorContent', response)
            header_dict = {
                'X-RateLimit-Limit': 'int',
                'X-RateLimit-Remaining': 'int',
                'X-RateLimit-Reset': 'str',
                'Retry-After': 'int',
            }
        if response.status_code == 403:
            deserialized = self._deserialize('ErrorContent', response)
            header_dict = {
                'X-RateLimit-Limit': 'int',
                'X-RateLimit-Remaining': 'int',
                'X-RateLimit-Reset': 'str',
                'Retry-After': 'int',
            }
        if response.status_code == 429:
            deserialized = self._deserialize('ErrorContent', response)
            header_dict = {
                'X-RateLimit-Limit': 'int',
                'X-RateLimit-Remaining': 'int',
                'X-RateLimit-Reset': 'str',
                'Retry-After': 'int',
            }

        if raw:
            client_raw_response = ClientRawResponse(deserialized, response)
            client_raw_response.add_headers(header_dict)
            return client_raw_response

        return deserialized
    get_supported_locales_for_voice_models.metadata = {'url': '/api/texttospeech/v2.0/models/locales'}

    def get_voice_test(
            self, id, custom_headers=None, raw=False, **operation_config):
        """Gets detail of the specified voice test.

        :param id: The identifier of the voice test.
        :type id: str
        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :return: object or ClientRawResponse if raw=true
        :rtype: object or ~msrest.pipeline.ClientRawResponse
        :raises:
         :class:`HttpOperationError<msrest.exceptions.HttpOperationError>`
        """
        # Construct URL
        url = self.get_voice_test.metadata['url']
        path_format_arguments = {
            'id': self._serialize.url("id", id, 'str')
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}

        # Construct headers
        header_parameters = {}
        header_parameters['Accept'] = 'application/json'
        if custom_headers:
            header_parameters.update(custom_headers)

        # Construct and send request
        request = self._client.get(url, query_parameters, header_parameters)
        response = self._client.send(request, stream=False, **operation_config)

        if response.status_code not in [200, 401, 403, 429]:
            raise HttpOperationError(self._deserialize, response)

        deserialized = None
        header_dict = {}

        if response.status_code == 200:
            deserialized = self._deserialize('VoiceTest', response)
            header_dict = {
                'Retry-After': 'int',
                'X-RateLimit-Limit': 'int',
                'X-RateLimit-Remaining': 'int',
                'X-RateLimit-Reset': 'str',
            }
        if response.status_code == 401:
            deserialized = self._deserialize('ErrorContent', response)
            header_dict = {
                'Retry-After': 'int',
                'X-RateLimit-Limit': 'int',
                'X-RateLimit-Remaining': 'int',
                'X-RateLimit-Reset': 'str',
            }
        if response.status_code == 403:
            deserialized = self._deserialize('ErrorContent', response)
            header_dict = {
                'Retry-After': 'int',
                'X-RateLimit-Limit': 'int',
                'X-RateLimit-Remaining': 'int',
                'X-RateLimit-Reset': 'str',
            }
        if response.status_code == 429:
            deserialized = self._deserialize('ErrorContent', response)
            header_dict = {
                'Retry-After': 'int',
                'X-RateLimit-Limit': 'int',
                'X-RateLimit-Remaining': 'int',
                'X-RateLimit-Reset': 'str',
            }

        if raw:
            client_raw_response = ClientRawResponse(deserialized, response)
            client_raw_response.add_headers(header_dict)
            return client_raw_response

        return deserialized
    get_voice_test.metadata = {'url': '/api/texttospeech/v2.0/tests/{id}'}

    def delete_voice_test(
            self, id, custom_headers=None, raw=False, **operation_config):
        """Deletes the specified voice test.

        :param id: The identifier of the voice test.
        :type id: str
        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :return: ErrorContent or ClientRawResponse if raw=true
        :rtype: ~azure.cognitiveservices.speechservices.models.ErrorContent or
         ~msrest.pipeline.ClientRawResponse
        :raises:
         :class:`HttpOperationError<msrest.exceptions.HttpOperationError>`
        """
        # Construct URL
        url = self.delete_voice_test.metadata['url']
        path_format_arguments = {
            'id': self._serialize.url("id", id, 'str')
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}

        # Construct headers
        header_parameters = {}
        header_parameters['Accept'] = 'application/json'
        if custom_headers:
            header_parameters.update(custom_headers)

        # Construct and send request
        request = self._client.delete(url, query_parameters, header_parameters)
        response = self._client.send(request, stream=False, **operation_config)

        if response.status_code not in [204, 400, 401, 403, 405, 429]:
            raise HttpOperationError(self._deserialize, response)

        deserialized = None
        header_dict = {}

        if response.status_code == 400:
            deserialized = self._deserialize('ErrorContent', response)
            header_dict = {
                'X-RateLimit-Limit': 'int',
                'X-RateLimit-Remaining': 'int',
                'X-RateLimit-Reset': 'str',
                'Retry-After': 'int',
            }
        if response.status_code == 401:
            deserialized = self._deserialize('ErrorContent', response)
            header_dict = {
                'X-RateLimit-Limit': 'int',
                'X-RateLimit-Remaining': 'int',
                'X-RateLimit-Reset': 'str',
                'Retry-After': 'int',
            }
        if response.status_code == 403:
            deserialized = self._deserialize('ErrorContent', response)
            header_dict = {
                'X-RateLimit-Limit': 'int',
                'X-RateLimit-Remaining': 'int',
                'X-RateLimit-Reset': 'str',
                'Retry-After': 'int',
            }
        if response.status_code == 405:
            deserialized = self._deserialize('ErrorContent', response)
            header_dict = {
                'X-RateLimit-Limit': 'int',
                'X-RateLimit-Remaining': 'int',
                'X-RateLimit-Reset': 'str',
                'Retry-After': 'int',
            }
        if response.status_code == 429:
            deserialized = self._deserialize('ErrorContent', response)
            header_dict = {
                'X-RateLimit-Limit': 'int',
                'X-RateLimit-Remaining': 'int',
                'X-RateLimit-Reset': 'str',
                'Retry-After': 'int',
            }

        if raw:
            client_raw_response = ClientRawResponse(deserialized, response)
            client_raw_response.add_headers(header_dict)
            return client_raw_response

        return deserialized
    delete_voice_test.metadata = {'url': '/api/texttospeech/v2.0/tests/{id}'}

    def create_voice_test(
            self, voice_test_definition, custom_headers=None, raw=False, **operation_config):
        """Creates a new voice test.

        :param voice_test_definition:
        :type voice_test_definition:
         ~azure.cognitiveservices.speechservices.models.VoiceTestDefinition
        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :return: ErrorContent or ClientRawResponse if raw=true
        :rtype: ~azure.cognitiveservices.speechservices.models.ErrorContent or
         ~msrest.pipeline.ClientRawResponse
        :raises:
         :class:`HttpOperationError<msrest.exceptions.HttpOperationError>`
        """
        # Construct URL
        url = self.create_voice_test.metadata['url']

        # Construct parameters
        query_parameters = {}

        # Construct headers
        header_parameters = {}
        header_parameters['Accept'] = 'application/json'
        header_parameters['Content-Type'] = 'application/json; charset=utf-8'
        if custom_headers:
            header_parameters.update(custom_headers)

        # Construct body
        body_content = self._serialize.body(voice_test_definition, 'VoiceTestDefinition')

        # Construct and send request
        request = self._client.post(url, query_parameters, header_parameters, body_content)
        response = self._client.send(request, stream=False, **operation_config)

        if response.status_code not in [202, 400, 401, 403, 429]:
            raise HttpOperationError(self._deserialize, response)

        deserialized = None
        header_dict = {}

        if response.status_code == 400:
            deserialized = self._deserialize('ErrorContent', response)
            header_dict = {
                'Location': 'str',
                'Operation-Location': 'str',
                'Retry-After': 'int',
                'X-RateLimit-Limit': 'int',
                'X-RateLimit-Remaining': 'int',
                'X-RateLimit-Reset': 'str',
            }
        if response.status_code == 401:
            deserialized = self._deserialize('ErrorContent', response)
            header_dict = {
                'Location': 'str',
                'Operation-Location': 'str',
                'Retry-After': 'int',
                'X-RateLimit-Limit': 'int',
                'X-RateLimit-Remaining': 'int',
                'X-RateLimit-Reset': 'str',
            }
        if response.status_code == 403:
            deserialized = self._deserialize('ErrorContent', response)
            header_dict = {
                'Location': 'str',
                'Operation-Location': 'str',
                'Retry-After': 'int',
                'X-RateLimit-Limit': 'int',
                'X-RateLimit-Remaining': 'int',
                'X-RateLimit-Reset': 'str',
            }
        if response.status_code == 429:
            deserialized = self._deserialize('ErrorContent', response)
            header_dict = {
                'Location': 'str',
                'Operation-Location': 'str',
                'Retry-After': 'int',
                'X-RateLimit-Limit': 'int',
                'X-RateLimit-Remaining': 'int',
                'X-RateLimit-Reset': 'str',
            }

        if raw:
            client_raw_response = ClientRawResponse(deserialized, response)
            client_raw_response.add_headers(header_dict)
            return client_raw_response

        return deserialized
    create_voice_test.metadata = {'url': '/api/texttospeech/v2.0/tests'}
