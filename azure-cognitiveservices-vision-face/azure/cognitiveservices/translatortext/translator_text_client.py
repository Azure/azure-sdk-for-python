# coding=utf-8
# --------------------------------------------------------------------------
# Copyright (c) Microsoft Corporation. All rights reserved.
# Licensed under the MIT License. See License.txt in the project root for
# license information.
#
# Code generated by Microsoft (R) AutoRest Code Generator.
# Changes may cause incorrect behavior and will be lost if the code is
# regenerated.
# --------------------------------------------------------------------------

from msrest.service_client import SDKClient
from msrest import Configuration, Serializer, Deserializer
from .version import VERSION
from msrest.pipeline import ClientRawResponse
from msrest.exceptions import HttpOperationError
from .operations.break_sentence_operations import BreakSentenceOperations
from .operations.detect_operations import DetectOperations
from .operations.dictionary_operations import DictionaryOperations
from .operations.dictionary_examples_operations import DictionaryExamplesOperations
from .operations.translate_operations import TranslateOperations
from .operations.transliterate_operations import TransliterateOperations
from . import models


class TranslatorTextClientConfiguration(Configuration):
    """Configuration for TranslatorTextClient
    Note that all parameters used to create this instance are saved as instance
    attributes.

    :param credentials: Subscription credentials which uniquely identify
     client subscription.
    :type credentials: None
    :param str base_url: Service URL
    """

    def __init__(
            self, credentials, base_url=None):

        if credentials is None:
            raise ValueError("Parameter 'credentials' must not be None.")
        if not base_url:
            base_url = 'https://api.cognitive.microsofttranslator.com/TranslatorText/v3.0'

        super(TranslatorTextClientConfiguration, self).__init__(base_url)

        self.add_user_agent('azure-cognitiveservices-translatortext/{}'.format(VERSION))

        self.credentials = credentials


class TranslatorTextClient(SDKClient):
    """# Introduction
    The Microsoft Translator Text API provides a JSON-based Web API. It provides:
      * Translation between any supported languages to any other supported language.
      * Translation to multiple languages in one request.
      * Transliteration to convert text from one script to another script of the same language.
      * Language detection, translation, and transliteration in one request.
      * Dictionary to lookup alternative translations of a term, to find back-translations and examples showing terms used in context.
      * Rich language detection.
    # Base URLs
    The Translator Text API is available in the following clouds:
    | Description | Region    | Base URL                                |
    | -------     | --------  | -------                                 |
    | Azure       | Global    | api.cognitive.microsofttranslator.com   |
    | Azure       | Europe    | api-eur.cognitive.microsofttranslator.com |
    # Authentication
    Subscribe to the Translator Text API, part of Azure Cognitive Services, and use your subscription key from the Azure portal to authenticate. You can follow the steps in https://docs.microsoft.com/en-us/azure/cognitive-services/translator/translator-text-how-to-signup.
    The simplest way is to pass your Azure secret key to the Translator service using the http request header `Ocp-Apim-Subscription-Key`.
    If you prefer using a short-lived authentication, you may use your secret key to obtain an authorization token from the token service. In that case you pass the authorization token to the Translator service using the `Authorization` request header. To obtain an authorization token, make a `POST` request to the following URL:
    | Environment | Authentication service URL                                |
    | ----------  | ----------                                                |
    | Azure       | `https://api.cognitive.microsoft.com/sts/v1.0/issueToken` |
    Here are example requests to obtain a token with a lifetime of 10 minutes, given a secret key:
    ```python
    // Pass secret key using header
    curl --header 'Ocp-Apim-Subscription-Key: &lt;your-key&gt;' --data "" 'https://api.cognitive.microsoft.com/sts/v1.0/issueToken'
    // Pass secret key using query string parameter
    curl --data "" 'https://api.cognitive.microsoft.com/sts/v1.0/issueToken?Subscription-Key=&lt;your-key&gt;'
    ```
    A successful request returns the encoded access token as plain text in the response body. The valid token is passed to the Translator service as a bearer token in the Authorization.
    ```
    Authorization: Bearer &lt;Base64-access_token&gt;
    ```
    An authentication token is valid for 10 minutes. The token should be re-used when making multiple calls to the Translator APIs. If you make requests to the Translator API over an extended period of time,  you  must request a new access token at regular intervals beforethe token expires, for instance every 9 minutes.
    To summarize, a client request to the Translator API will include one authorization header taken from the following table:
    | Headers       | Description  |
    | ----------    | ----------   |
    | Ocp-Apim-Subscription-key    | Use with Cognitive Services subscription if you are passing your secret key.                               The value is the Azure secret key for your subscription to Translator Text API.                         |
    | Authorization                | Use with Cognitive Services subscription if you are passing an authentication token. The value is the Bearer token: `Bearer &lt;token&gt;`.       |
    # Errors
    A standard error response is a JSON object with name/value pair named `error`. The value is also a JSON object with properties:
      * `code`: A server-defined error code.
      * `message`: A string giving a human-readable representation of the error.
    For example, a customer with a free trial subscription receives the following error once the free quota is exhausted:
    ```json
    {
      "error": {
      "code":403000,
      "message":"The subscription has exceeded its free quota."
      }
    }
    ```

    :ivar config: Configuration for client.
    :vartype config: TranslatorTextClientConfiguration

    :ivar break_sentence: BreakSentence operations
    :vartype break_sentence: azure.cognitiveservices.translatortext.operations.BreakSentenceOperations
    :ivar detect: Detect operations
    :vartype detect: azure.cognitiveservices.translatortext.operations.DetectOperations
    :ivar dictionary: Dictionary operations
    :vartype dictionary: azure.cognitiveservices.translatortext.operations.DictionaryOperations
    :ivar dictionary_examples: DictionaryExamples operations
    :vartype dictionary_examples: azure.cognitiveservices.translatortext.operations.DictionaryExamplesOperations
    :ivar translate: Translate operations
    :vartype translate: azure.cognitiveservices.translatortext.operations.TranslateOperations
    :ivar transliterate: Transliterate operations
    :vartype transliterate: azure.cognitiveservices.translatortext.operations.TransliterateOperations

    :param credentials: Subscription credentials which uniquely identify
     client subscription.
    :type credentials: None
    :param str base_url: Service URL
    """

    def __init__(
            self, credentials, base_url=None):

        self.config = TranslatorTextClientConfiguration(credentials, base_url)
        super(TranslatorTextClient, self).__init__(self.config.credentials, self.config)

        client_models = {k: v for k, v in models.__dict__.items() if isinstance(v, type)}
        self.api_version = '3.0'
        self._serialize = Serializer(client_models)
        self._deserialize = Deserializer(client_models)

        self.break_sentence = BreakSentenceOperations(
            self._client, self.config, self._serialize, self._deserialize)
        self.detect = DetectOperations(
            self._client, self.config, self._serialize, self._deserialize)
        self.dictionary = DictionaryOperations(
            self._client, self.config, self._serialize, self._deserialize)
        self.dictionary_examples = DictionaryExamplesOperations(
            self._client, self.config, self._serialize, self._deserialize)
        self.translate = TranslateOperations(
            self._client, self.config, self._serialize, self._deserialize)
        self.transliterate = TransliterateOperations(
            self._client, self.config, self._serialize, self._deserialize)

    def languages_text_translation_v3(
            self, api_version, scope=None, accept_language=None, x_client_trace_id=None, custom_headers=None, raw=False, **operation_config):
        """Gets the set of languages currently supported by other operations of
        the Translator Text API.
        **Authentication is not required to get language resources.**
        # Response Body
        A client uses the `scope` query parameter to define which groups of
        languages it is interested in.
        * `scope=translation` provides languages supported to translate text
        from one language to another language.
        * `scope=transliteration` provides capabilities for converting text in
        one language from one script to another script.
        * `scope=dictionary` provides language pairs for which `Dictionary`
        operations return data.
        A client may retrieve several groups simultaneously by specifying a
        comma-separated list of names. For example,
        `scope=translation,transliteration,dictionary` would return supported
        languages for all groups.
        A successful response is a JSON object with one property for each
        requested group.
        The value for each property is as follows.
        * `translation` property
        The value of the `translation` property is a dictionary of (key, value)
        pairs. Each key is a BCP 47 language tag. A key identifies a language
        for which text can be translated to or translated from. The value
        associated with the key is a JSON object with properties that describe
        the language
        * `name-` Display name of the language in the locale requested via
        `Accept-Language` header.
        * `nativeName-` Display name of the language in the locale native for
        this language.
        * `dir-` Directionality, which is `rtl` for right-to-left languages or
        `ltr` for left-to-right languages.
        ```json
        {
        "translation": {
        ...
        "fr": {
        "name": "French",
        "nativeName": "Français",
        "dir": "ltr"
        },
        ...
        }
        }
        ```
        * `transliteration` property
        The value of the `transliteration` property is a dictionary of (key,
        value) pairs. Each key is a BCP 47 language tag. A key identifies a
        language for which text can be converted from one script to another
        script. The value associated with the key is a JSON object with
        properties that describe the language and its supported scripts
        * `name-` Display name of the language in the locale requested via
        `Accept-Language` header.
        * `nativeName-` Display name of the language in the locale native for
        this language.
        * `scripts-` List of scripts to convert from. Each element of the
        `scripts` list has properties-
        * `code-` Code identifying the script.
        * `name-` Display name of the script in the locale requested via
        `Accept-Language` header.
        * `nativeName-` Display name of the language in the locale native for
        the language.
        * `dir-` Directionality, which is `rtl` for right-to-left languages or
        `ltr` for left-to-right languages.
        * `toScripts-` List of scripts available to convert text to. Each
        element of the `toScripts` list has properties `code`, `name`,
        `nativeName`, and `dir` as described earlier.
        ```json
        {
        "transliteration": {
        ...
        "ja": {
        "name": "Japanese",
        "nativeName": "日本語",
        "scripts": [
        {
        "code": "Jpan",
        "name": "Japanese",
        "nativeName": "日本語",
        "dir": "ltr",
        "toScripts": [
        {
        "code": "Latn",
        "name": "Latin",
        "nativeName": "ラテン語",
        "dir": "ltr"
        }
        ]
        },
        {
        "code": "Latn",
        "name": "Latin",
        "nativeName": "ラテン語",
        "dir": "ltr",
        "toScripts": [
        {
        "code": "Jpan",
        "name": "Japanese",
        "nativeName": "日本語",
        "dir": "ltr"
        }
        ]
        }
        ]
        },
        ...
        }
        }
        ```
        * `dictionary` property
        The value of the `dictionary` property is a dictionary of (key, value)
        pairs. Each key is a BCP 47 language tag. The key identifies a language
        for which alternative translations and back-translations are available.
        The value is a JSON object that describes the source language and the
        target languages with available translations.
        * `name-` Display name of the source language in the locale requested
        via `Accept-Language` header.
        * `nativeName-` Display name of the language in the locale native for
        this language.
        * `dir-` Directionality, which is `rtl` for right-to-left languages or
        `ltr` for left-to-right languages.
        * `translations-` List of languages with alterative translations and
        examples for the query expressed in the source language. Each element
        of the `translations` list has properties
        * `name-` Display name of the target language in the locale requested
        via `Accept-Language` header.
        * `nativeName-` Display name of the target language in the locale
        native for the target language.
        * `dir-` Directionality, which is `rtl` for right-to-left languages or
        `ltr` for left-to-right languages.
        * `code-` Language code identifying the target language.
        ```json
        "es": {
        "name": "Spanish",
        "nativeName": "Español",
        "dir": "ltr",
        "translations": [
        {
        "name": "English",
        "nativeName": "English",
        "dir": "ltr",
        "code": "en"
        }
        ]
        },
        ```
        The structure of the response object will not change without a change
        in the version of the API. For the same version of the API, the list of
        available languages may change over time because Microsoft Translator
        continually extends the list of languages supported by its services.
        The list of supported languages will not change frequently. To save
        network bandwidth and improve responsiveness, a client application
        should consider caching language resources and the corresponding entity
        tag (`ETag`). Then, the client application can periodically (for
        example, once every 24 hours) query the service to fetch the latest set
        of supported languages. Passing the current `ETag` value in an
        `If-None-Match` header field will allow the service to optimize the
        response. If the resource has not been modified, the service will
        return status code 304 and an empty response body.
        # Response Header
        ETag - Current value of the entity tag for the requested groups of
        supported languages. To make subsequent requests more efficient, the
        client may send the `ETag` value in an `If-None-Match` header field.
        X-RequestId - Value generated by the service to identify the request.
        It is used for troubleshooting purposes.
        .

        :param api_version: Version of the API requested by the client. Value
         must be **3.0**.
        :type api_version: str
        :param scope: A comma-separated list of names defining the group of
         languages to return. Allowed group names are- `translation`,
         `transliteration` and `dictionary`. If no scope is given, then all
         groups are returned, which is equivalent to passing
         `scope=translation,transliteration,dictionary`. To decide which set of
         supported languages is appropriate for your scenario, see the
         description of the response object.
        :type scope: str
        :param accept_language: The language to use for user interface
         strings. Some of the fields in the response are names of languages or
         names of regions. Use this parameter to define the language in which
         these names are returned. The language is specified by providing a
         well-formed BCP 47 language tag. For instance, use the value `fr` to
         request names in French or use the value `zh-Hant` to request names in
         Chinese Traditional. Names are provided in the English language when a
         target language is not specified or when localization is not
         available.
        :type accept_language: str
        :param x_client_trace_id: A client-generated GUID to uniquely identify
         the request. Note that you can omit this header if you include the
         trace ID in the query string using a query parameter named
         ClientTraceId.
        :type x_client_trace_id: str
        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :return: object or ClientRawResponse if raw=true
        :rtype: object or ~msrest.pipeline.ClientRawResponse
        :raises:
         :class:`HttpOperationError<msrest.exceptions.HttpOperationError>`
        """
        # Construct URL
        url = self.languages_text_translation_v3.metadata['url']

        # Construct parameters
        query_parameters = {}
        query_parameters['api-version'] = self._serialize.query("api_version", api_version, 'str')
        if scope is not None:
            query_parameters['scope'] = self._serialize.query("scope", scope, 'str')

        # Construct headers
        header_parameters = {}
        header_parameters['Accept'] = 'application/json'
        if custom_headers:
            header_parameters.update(custom_headers)
        if accept_language is not None:
            header_parameters['Accept-Language'] = self._serialize.header("accept_language", accept_language, 'str')
        if x_client_trace_id is not None:
            header_parameters['X-ClientTraceId'] = self._serialize.header("x_client_trace_id", x_client_trace_id, 'str')

        # Construct and send request
        request = self._client.get(url, query_parameters, header_parameters)
        response = self._client.send(request, stream=False, **operation_config)

        if response.status_code not in [200, 304, 400, 429, 500, 503]:
            raise HttpOperationError(self._deserialize, response)

        deserialized = None

        if response.status_code == 200:
            deserialized = self._deserialize('LanguageExampleSuccess', response)
        if response.status_code == 400:
            deserialized = self._deserialize('ErrorMessage', response)
        if response.status_code == 429:
            deserialized = self._deserialize('ErrorMessage', response)
        if response.status_code == 500:
            deserialized = self._deserialize('ErrorMessage', response)
        if response.status_code == 503:
            deserialized = self._deserialize('ErrorMessage', response)

        if raw:
            client_raw_response = ClientRawResponse(deserialized, response)
            return client_raw_response

        return deserialized
    languages_text_translation_v3.metadata = {'url': '/Languages'}
