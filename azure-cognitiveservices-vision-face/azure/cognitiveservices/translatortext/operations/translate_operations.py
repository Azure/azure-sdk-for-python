# coding=utf-8
# --------------------------------------------------------------------------
# Copyright (c) Microsoft Corporation. All rights reserved.
# Licensed under the MIT License. See License.txt in the project root for
# license information.
#
# Code generated by Microsoft (R) AutoRest Code Generator.
# Changes may cause incorrect behavior and will be lost if the code is
# regenerated.
# --------------------------------------------------------------------------

from msrest.pipeline import ClientRawResponse
from msrest.exceptions import HttpOperationError

from .. import models


class TranslateOperations(object):
    """TranslateOperations operations.

    :param client: Client for service requests.
    :param config: Configuration of service client.
    :param serializer: An object model serializer.
    :param deserializer: An object model deserializer.
    """

    models = models

    def __init__(self, client, config, serializer, deserializer):

        self._client = client
        self._serialize = serializer
        self._deserialize = deserializer

        self.config = config

    def translate_post_json(
            self, api_version, to, text, from_parameter=None, text_type=None, category=None, profanity_action=None, profanity_marker=None, include_alignment=None, include_sentence_length=None, suggested_from=None, from_script=None, to_script=None, ocp_apim_subscription_key=None, x_client_trace_id=None, custom_headers=None, raw=False, **operation_config):
        """Translates text into one or more languages.
        .

        :param api_version: Version of the API requested by the client. Value
         must be **3.0**.
        :type api_version: str
        :param to: Specifies the language of the output text. The target
         language must be one of the supported languages included in the
         `translation` scope. For example, use `to=de` to translate to German.
         It's possible to translate to multiple languages simultaneously by
         repeating the `to` parameter in the query string. For example, use
         `to=de&to=it` to translate to German and Italian in the same request.
        :type to: list[str]
        :param text: # Request body
         The body of the request is a JSON array. Each array element is a JSON
         object with a string property named `Text`, which represents the
         string to translate.
         The following limitations apply:
         * The array can have at most 25 elements.
         * The entire text included in the request cannot exceed 5,000
         characters including spaces.
         # Response body
         A successful response is a JSON array with one result for each string
         in the input array. A result object includes the following properties-
         * `detectedLanguage`- An object describing the detected language
         through the following properties.
         * `language`- A string representing the code of the detected language.
         * `score`- A float value indicating the confidence in the result. The
         score is between zero and one and a low score indicates a low
         confidence.
         The `detectedLanguage` property is only present in the result object
         when language auto-detection is requested.
         * `translations`- An array of translation results. The size of the
         array matches the number of target languages specified in the `to`
         query parameter. Each element in the array includes.
         * `to` A string representing the language code of the target language.
         * `text`- A string giving the translated text.
         * `transliteration`- An object giving the translated text in the
         script specified by the `toScript` parameter.
         * `script`- A string specifying the target script.
         * `text`- A string giving the translated text in the target script.
         The `transliteration` object is not included if transliteration does
         not take place.
         *`alignment`- An object with a single string property named `proj`,
         which maps input text to translated text. The alignment information is
         only provided when the request parameter `includeAlignment` is `true`.
         Alignment is returned as a string value of the following format-
         `[[SourceTextStartIndex]-[SourceTextEndIndex]–[TgtTextStartIndex]-[TgtTextEndIndex]]`.
         The colon separates start and end index, the dash separates the
         languages, and space separates the words. One word may align with
         zero, one, or multiple words in the other language, and the aligned
         words may be non-contiguous. When no alignment information is
         available, the alignment element will be empty. See Obtain alignment
         information for an example and restrictions.
         * `sentLen`- An object returning sentence boundaries in the input and
         output texts.
         * `srcSentLen`- An integer array representing the lengths of the
         sentences in the input text. The length of the array is the number of
         sentences, and the values are the length of each sentence.
         * `transSentLen`- An integer array representing the lengths of the
         sentences in the translated text. The length of the array is the
         number of sentences, and the values are the length of each sentence.
         Sentence boundaries are only included when the request parameter
         `includeSentenceLength` is `true`.
         * `sourceText`- An object with a single string property named `text`,
         which gives the input text in the default script of the source
         language. `sourceText` property is present only when the input is
         expressed in a script that's not the usual script for the language.
         For example, if the input were Arabic written in Latin script, then
         `sourceText.text` would be the same Arabic text converted into Arab
         script.
         Example of JSON responses are provided in the examples section.
        :type text:
         list[~azure.cognitiveservices.translatortext.models.TranslateTextInput]
        :param from_parameter: Specifies the language of the input text. Find
         which languages are available to translate from by looking up
         supported languages using the `translation` scope. If the `from`
         parameter is not specified, automatic language detection is applied to
         determine the source language.
        :type from_parameter: str
        :param text_type: Defines whether the text being translated is plain
         text or HTML text. Any HTML needs to be a well-formed, complete HTML
         element. Possible values are `plain` (default) or `html`
        :type text_type: str
        :param category: A string specifying the category (domain) of the
         translation. This parameter retrieves translations from a customized
         system built with Custom Translator. Default value is `general`.
        :type category: str
        :param profanity_action: Specifies how profanities should be treated
         in translations. Possible values are: `NoAction` (default), `Marked`
         or `Deleted`.
         ### Handling Profanity
         Normally the Translator service will retain profanity that is present
         in the source in the translation. The degree of profanity and the
         context that makes words profane differ between cultures, and as a
         result the degree of profanity in the target language may be amplified
         or reduced.
         If you want to avoid getting profanity in the translation, regardless
         of the presence of profanity in the source text, you can use the
         profanity filtering option. The option allows you to choose whether
         you want to see profanity deleted, whether you want to mark
         profanities with appropriate tags (giving you the option to add your
         own post-processing), or you want no action taken. The accepted values
         of `ProfanityAction` are `Deleted`, `Marked` and `NoAction` (default).
         | ProfanityAction | Action
         |
         | ----------      | ----------
         |
         | `NoAction`      | This is the default behavior. Profanity will pass
         from source to target.  |
         |                 | Example Source (Japanese)- 彼はジャッカスです。
         |
         |                 | Example Translation (English)- He is a jackass.
         |
         |                 |
         |
         | `Deleted`       | Profane words will be removed from the output
         without replacement.        |
         |                 | Example Source (Japanese)- 彼はジャッカスです。
         |
         |                 | Example Translation (English)- He is a.
         |
         | `Marked`        | Profane words are replaced by a marker in the
         output. The marker depends on the `ProfanityMarker` parameter.
         |                 | For `ProfanityMarker=Asterisk`, profane words are
         replaced with `***`     |
         |                 | Example Source (Japanese)- 彼はジャッカスです。
         |
         |                 | Example Translation (English)- He is a ***.
         |
         |                 | For `ProfanityMarker=Tag`, profane words are
         surrounded by XML tags <profanity> and </profanity>
         |                 | Example Source (Japanese)- 彼はジャッカスです。
         |
         |                 | Example Translation (English)- He is a
         <profanity>jackass</profanity>.
        :type profanity_action: str
        :param profanity_marker: Specifies how profanities should be marked in
         translations. Possible values are- `Asterisk` (default) or `Tag`.
        :type profanity_marker: str
        :param include_alignment: Specifies whether to include alignment
         projection from source text to translated text. Possible values are-
         `true` or `false` (default).
        :type include_alignment: str
        :param include_sentence_length: Specifies whether to include sentence
         boundaries for the input text and the translated text. Possible values
         are- `true` or `false` (default).
        :type include_sentence_length: str
        :param suggested_from: Specifies a fallback language if the language
         of the input text can't be identified. Language auto-detection is
         applied when the `from` parameter is omitted. If detection fails, the
         `suggestedFrom` language will be assumed.
        :type suggested_from: str
        :param from_script: Specifies the script of the input text.
        :type from_script: str
        :param to_script: Specifies the script of the translated text.
        :type to_script: list[str]
        :param ocp_apim_subscription_key: This is used to pass a key for auth.
         If you are passing a token for auth then use the previous header auth
         option. **ONE OF THESE METHODS MUST BE USED.**
        :type ocp_apim_subscription_key: str
        :param x_client_trace_id: A client-generated GUID to uniquely identify
         the request. Note that you can omit this header if you include the
         trace ID in the query string using a query parameter named
         ClientTraceId.
        :type x_client_trace_id: str
        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :return: object or ClientRawResponse if raw=true
        :rtype: object or ~msrest.pipeline.ClientRawResponse
        :raises:
         :class:`HttpOperationError<msrest.exceptions.HttpOperationError>`
        """
        # Construct URL
        url = self.translate_post_json.metadata['url']

        # Construct parameters
        query_parameters = {}
        query_parameters['api-version'] = self._serialize.query("api_version", api_version, 'str')
        if from_parameter is not None:
            query_parameters['from'] = self._serialize.query("from_parameter", from_parameter, 'str')
        query_parameters['to'] = self._serialize.query("to", to, '[str]', div=',')
        if text_type is not None:
            query_parameters['textType'] = self._serialize.query("text_type", text_type, 'str')
        if category is not None:
            query_parameters['category'] = self._serialize.query("category", category, 'str')
        if profanity_action is not None:
            query_parameters['profanityAction'] = self._serialize.query("profanity_action", profanity_action, 'str')
        if profanity_marker is not None:
            query_parameters['profanityMarker'] = self._serialize.query("profanity_marker", profanity_marker, 'str')
        if include_alignment is not None:
            query_parameters['includeAlignment'] = self._serialize.query("include_alignment", include_alignment, 'str')
        if include_sentence_length is not None:
            query_parameters['includeSentenceLength'] = self._serialize.query("include_sentence_length", include_sentence_length, 'str')
        if suggested_from is not None:
            query_parameters['suggestedFrom'] = self._serialize.query("suggested_from", suggested_from, 'str')
        if from_script is not None:
            query_parameters['fromScript'] = self._serialize.query("from_script", from_script, 'str')
        if to_script is not None:
            query_parameters['toScript'] = self._serialize.query("to_script", to_script, '[str]', div=',')

        # Construct headers
        header_parameters = {}
        header_parameters['Accept'] = 'application/json'
        header_parameters['Content-Type'] = 'application/json; charset=utf-8'
        if custom_headers:
            header_parameters.update(custom_headers)
        if ocp_apim_subscription_key is not None:
            header_parameters['Ocp-Apim-Subscription-Key'] = self._serialize.header("ocp_apim_subscription_key", ocp_apim_subscription_key, 'str')
        if x_client_trace_id is not None:
            header_parameters['X-ClientTraceId'] = self._serialize.header("x_client_trace_id", x_client_trace_id, 'str')

        # Construct body
        body_content = self._serialize.body(text, '[TranslateTextInput]')

        # Construct and send request
        request = self._client.post(url, query_parameters, header_parameters, body_content)
        response = self._client.send(request, stream=False, **operation_config)

        if response.status_code not in [200, 400, 401, 403, 429, 500, 503]:
            raise HttpOperationError(self._deserialize, response)

        deserialized = None

        if response.status_code == 200:
            deserialized = self._deserialize('[TranslateSuccessItem]', response)
        if response.status_code == 400:
            deserialized = self._deserialize('ErrorMessage', response)
        if response.status_code == 401:
            deserialized = self._deserialize('ErrorMessage', response)
        if response.status_code == 403:
            deserialized = self._deserialize('ErrorMessage', response)
        if response.status_code == 429:
            deserialized = self._deserialize('ErrorMessage', response)
        if response.status_code == 500:
            deserialized = self._deserialize('ErrorMessage', response)
        if response.status_code == 503:
            deserialized = self._deserialize('ErrorMessage', response)

        if raw:
            client_raw_response = ClientRawResponse(deserialized, response)
            return client_raw_response

        return deserialized
    translate_post_json.metadata = {'url': '/translate'}
