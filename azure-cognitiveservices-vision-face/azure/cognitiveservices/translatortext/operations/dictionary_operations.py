# coding=utf-8
# --------------------------------------------------------------------------
# Copyright (c) Microsoft Corporation. All rights reserved.
# Licensed under the MIT License. See License.txt in the project root for
# license information.
#
# Code generated by Microsoft (R) AutoRest Code Generator.
# Changes may cause incorrect behavior and will be lost if the code is
# regenerated.
# --------------------------------------------------------------------------

from msrest.pipeline import ClientRawResponse
from msrest.exceptions import HttpOperationError

from .. import models


class DictionaryOperations(object):
    """DictionaryOperations operations.

    :param client: Client for service requests.
    :param config: Configuration of service client.
    :param serializer: An object model serializer.
    :param deserializer: An object model deserializer.
    """

    models = models

    def __init__(self, client, config, serializer, deserializer):

        self._client = client
        self._serialize = serializer
        self._deserialize = deserializer

        self.config = config

    def lookup_post(
            self, api_version, from_parameter, to, text, ocp_apim_subscription_key=None, x_client_trace_id=None, custom_headers=None, raw=False, **operation_config):
        """Provides alternative translations for a word and a small number of
        idiomatic phrases. Each translation has a `part-of-speech` and a list
        of `back-translations`. The back-translations enable a user to
        understand the translation in context. The Dictionary Example operation
        allows further drill down to see example uses of each translation pair.
        .

        :param api_version: Version of the API requested by the client. Value
         must be **3.0**.
        :type api_version: str
        :param from_parameter: Specifies the language of the input text. The
         source language must be one of the supported languages included in the
         `dictionary` scope.
        :type from_parameter: str
        :param to: Specifies the language of the output text. The target
         language must be one of the supported languages included in the
         `dictionary` scope of the Languages resource.
        :type to: str
        :param text: # Request Body
         The body of the request is a JSON array. Each array element is a JSON
         object with a string property named `Text`, which represents the term
         to lookup.
         The following limitations apply:
         * The array can have at most 10 elements.
         * The text value of an array element cannot exceed 100 characters
         including spaces.
         # Response Body
         A successful response is a JSON array with one result for each string
         in the input array. A result object includes the following properties:
         * `normalizedSource`- A string giving the normalized form of the
         source term. For example, if the request is "JOHN", the normalized
         form will be "john". The content of this field becomes the input to
         lookup examples.
         * `displaySource`- A string giving the source term in a form best
         suited for end-user display. For example, if the input is "JOHN", the
         display form will reflect the usual spelling of the name- "John".
         * `translations`- A list of translations for the source term. Each
         element of the list is an object with the following properties:
         * `normalizedTarget`- A string giving the normalized form of this term
         in the target language. This value should be used as input to lookup
         examples.
         * `displayTarget`- A string giving the term in the target language and
         in a form best suited for end-user display. Generally, this will only
         differ from the `normalizedTarget` in terms of capitalization. For
         example, a proper noun like "Juan" will have `normalizedTarget =
         "juan"` and `displayTarget = "Juan"`.
         * `posTag`- A string associating this term with a part-of-speech tag.
         | Tag name  | Description       |
         | --------- | ----------------  |
         | ADJ       | Adjectives        |
         | ADV       | Adverbs           |
         | CONJ      | Conjuctions       |
         | DET       | Determiners       |
         | MODAL     | Verbs             |
         | NOUN      | Nouns             |
         | PREP      | Prepositions      |
         | PRON      | Pronouns          |
         | VERB      | Verbs             |
         | OTHER     | Other             |
         As an implementation note, these tags were determined by
         part-of-speech tagging the English side, and then taking the most
         frequent tag for each source/target pair. So if people frequently
         translate a Spanish word to a different part-of-speech tag in English,
         tags may end up being wrong (with respect to the Spanish word).
         * `confidence`- A value between 0.0 and 1.0 which represents the
         "confidence" (or perhaps more accurately, "probability in the training
         data") of that translation pair. The sum of confidence scores for one
         source word may or may not sum to 1.0.
         * `prefixWord-` A string giving the the word to display as a prefix of
         the translation. Currently, this is the gendered determiner of nouns,
         in languages that have gendered determiners. For example, the prefix
         of the Spanish word "mosca" is "la", since "mosca" is a feminine noun
         in Spanish. This is only dependent on the translation, and not on the
         source. If there is no prefix, it will be the empty string.
         * `backTranslations-` A list of "back translations" of the target. For
         example, source words that the target can translate to. The list is
         guaranteed to contain the source word that was requested (e.g., if the
         source word being looked up is "fly", then it is guaranteed that "fly"
         will be in the `backTranslations` list). However, it is not guaranteed
         to be in the first position, and often will not be. Each element of
         the `backTranslations` list is an object described by the following
         properties-
         * `normalizedText-` A string giving the normalized form of the source
         term that is a back-translation of the target. This value should be
         used as input to lookup examples.
         * `displayText-` A string giving the source term that is a
         back-translation of the target in a form best suited for end-user
         display.
         * `numExamples-` An integer representing the number of examples that
         are available for this translation pair. Actual examples must be
         retrieved with a separate call to lookup examples. The number is
         mostly intended to facilitate display in a UX. For example, a user
         interface may add a hyperlink to the back-translation if the number of
         examples is greater than zero and show the back-translation as plain
         text if there are no examples. Note that the actual number of examples
         returned by a call to lookup examples may be less than `numExamples`,
         because additional filtering may be applied on the fly to remove "bad"
         examples.
         * `frequencyCount-` An integer representing the frequency of this
         translation pair in the data. The main purpose of this field is to
         provide a user interface with a means to sort back-translations so the
         most frequent terms are first.
         Note - If the term being looked up does not exist in the dictionary,
         the response is 200 (OK) but the `translations` list is an empty list.
         # Response Header
         X-RequestId - Value generated by the service to identify the request.
         It is used for troubleshooting purposes.
        :type text:
         list[~azure.cognitiveservices.translatortext.models.DictionaryLookupTextInput]
        :param ocp_apim_subscription_key: This is used to pass a key for auth.
         If you are passing a token for auth then use the previous header auth
         option. **ONE OF THESE METHODS MUST BE USED.**
        :type ocp_apim_subscription_key: str
        :param x_client_trace_id: A client-generated GUID to uniquely identify
         the request. Note that you can omit this header if you include the
         trace ID in the query string using a query parameter named
         ClientTraceId.
        :type x_client_trace_id: str
        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :return: object or ClientRawResponse if raw=true
        :rtype: object or ~msrest.pipeline.ClientRawResponse
        :raises:
         :class:`HttpOperationError<msrest.exceptions.HttpOperationError>`
        """
        # Construct URL
        url = self.lookup_post.metadata['url']

        # Construct parameters
        query_parameters = {}
        query_parameters['api-version'] = self._serialize.query("api_version", api_version, 'str')
        query_parameters['from'] = self._serialize.query("from_parameter", from_parameter, 'str')
        query_parameters['to'] = self._serialize.query("to", to, 'str')

        # Construct headers
        header_parameters = {}
        header_parameters['Accept'] = 'application/json'
        header_parameters['Content-Type'] = 'application/json; charset=utf-8'
        if custom_headers:
            header_parameters.update(custom_headers)
        if ocp_apim_subscription_key is not None:
            header_parameters['Ocp-Apim-Subscription-Key'] = self._serialize.header("ocp_apim_subscription_key", ocp_apim_subscription_key, 'str')
        if x_client_trace_id is not None:
            header_parameters['X-ClientTraceId'] = self._serialize.header("x_client_trace_id", x_client_trace_id, 'str')

        # Construct body
        body_content = self._serialize.body(text, '[DictionaryLookupTextInput]')

        # Construct and send request
        request = self._client.post(url, query_parameters, header_parameters, body_content)
        response = self._client.send(request, stream=False, **operation_config)

        if response.status_code not in [200, 400, 401, 403, 429, 500, 503]:
            raise HttpOperationError(self._deserialize, response)

        deserialized = None

        if response.status_code == 200:
            deserialized = self._deserialize('[DictionaryLookupSuccessItem]', response)
        if response.status_code == 400:
            deserialized = self._deserialize('ErrorMessage', response)
        if response.status_code == 401:
            deserialized = self._deserialize('ErrorMessage', response)
        if response.status_code == 403:
            deserialized = self._deserialize('ErrorMessage', response)
        if response.status_code == 429:
            deserialized = self._deserialize('ErrorMessage', response)
        if response.status_code == 500:
            deserialized = self._deserialize('ErrorMessage', response)
        if response.status_code == 503:
            deserialized = self._deserialize('ErrorMessage', response)

        if raw:
            client_raw_response = ClientRawResponse(deserialized, response)
            return client_raw_response

        return deserialized
    lookup_post.metadata = {'url': '/Dictionary/Lookup'}
