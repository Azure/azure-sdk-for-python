# coding=utf-8
# --------------------------------------------------------------------------
# Copyright (c) Microsoft Corporation. All rights reserved.
# Licensed under the MIT License. See License.txt in the project root for license information.
# Code generated by Microsoft (R) AutoRest Code Generator.
# Changes may cause incorrect behavior and will be lost if the code is regenerated.
# --------------------------------------------------------------------------
from typing import Any, Callable, Dict, Generic, List, Optional, TypeVar, Union
import warnings

from azure.core.exceptions import ClientAuthenticationError, HttpResponseError, ResourceExistsError, ResourceNotFoundError, map_error
from azure.core.pipeline import PipelineResponse
from azure.core.pipeline.transport import AsyncHttpResponse, HttpRequest

from ... import models as _models

T = TypeVar('T')
ClsType = Optional[Callable[[PipelineResponse[HttpRequest, AsyncHttpResponse], T, Dict[str, Any]], Any]]

class SnapshotOperations:
    """SnapshotOperations async operations.

    You should not instantiate this class directly. Instead, you should create a Client instance that
    instantiates it for you and attaches it as an attribute.

    :ivar models: Alias to model classes used in this operation group.
    :type models: ~azure.cognitiveservices.vision.face.models
    :param client: Client for service requests.
    :param config: Configuration of service client.
    :param serializer: An object model serializer.
    :param deserializer: An object model deserializer.
    """

    models = _models

    def __init__(self, client, config, serializer, deserializer) -> None:
        self._client = client
        self._serialize = serializer
        self._deserialize = deserializer
        self._config = config

    async def take(
        self,
        type: Union[str, "_models.SnapshotObjectType"],
        object_id: str,
        apply_scope: List[str],
        user_data: Optional[str] = None,
        **kwargs
    ) -> None:
        """Submit an operation to take a snapshot of face list, large face list, person group or large
        person group, with user-specified snapshot type, source object id, apply scope and an optional
        user data.:code:`<br />`
        The snapshot interfaces are for users to backup and restore their face data from one face
        subscription to another, inside same region or across regions. The workflow contains two
        phases, user first calls Snapshot - Take to create a copy of the source object and store it as
        a snapshot, then calls Snapshot - Apply to paste the snapshot to target subscription. The
        snapshots are stored in a centralized location (per Azure instance), so that they can be
        applied cross accounts and regions.:code:`<br />`
        Taking snapshot is an asynchronous operation. An operation id can be obtained from the
        "Operation-Location" field in response header, to be used in OperationStatus - Get for tracking
        the progress of creating the snapshot. The snapshot id will be included in the
        "resourceLocation" field in OperationStatus - Get response when the operation status is
        "succeeded".:code:`<br />`
        Snapshot taking time depends on the number of person and face entries in the source object. It
        could be in seconds, or up to several hours for 1,000,000 persons with multiple
        faces.:code:`<br />`
        Snapshots will be automatically expired and cleaned in 48 hours after it is created by Snapshot
        - Take. User can delete the snapshot using Snapshot - Delete by themselves any time before
        expiration.:code:`<br />`
        Taking snapshot for a certain object will not block any other operations against the object.
        All read-only operations (Get/List and Identify/FindSimilar/Verify) can be conducted as usual.
        For all writable operations, including Add/Update/Delete the source object or its persons/faces
        and Train, they are not blocked but not recommended because writable updates may not be
        reflected on the snapshot during its taking. After snapshot taking is completed, all readable
        and writable operations can work as normal. Snapshot will also include the training results of
        the source object, which means target subscription the snapshot applied to does not need re-
        train the target object before calling Identify/FindSimilar.:code:`<br />`


        * Free-tier subscription quota: 100 take operations per month.
        * S0-tier subscription quota: 100 take operations per day.

        :param type: User specified type for the source object to take snapshot from. Currently
         FaceList, PersonGroup, LargeFaceList and LargePersonGroup are supported.
        :type type: str or ~azure.cognitiveservices.vision.face.models.SnapshotObjectType
        :param object_id: User specified source object id to take snapshot from.
        :type object_id: str
        :param apply_scope: User specified array of target Face subscription ids for the snapshot. For
         each snapshot, only subscriptions included in the applyScope of Snapshot - Take can apply it.
        :type apply_scope: list[str]
        :param user_data: User specified data about the snapshot for any purpose. Length should not
         exceed 16KB.
        :type user_data: str
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: None, or the result of cls(response)
        :rtype: None
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType[None]
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}))

        _body = _models.TakeSnapshotRequest(type=type, object_id=object_id, apply_scope=apply_scope, user_data=user_data)
        content_type = kwargs.pop("content_type", "application/json")
        accept = "application/json"

        # Construct URL
        url = self.take.metadata['url']  # type: ignore
        path_format_arguments = {
            'Endpoint': self._serialize.url("self._config.endpoint", self._config.endpoint, 'str', skip_quote=True),
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]
        header_parameters['Content-Type'] = self._serialize.header("content_type", content_type, 'str')
        header_parameters['Accept'] = self._serialize.header("accept", accept, 'str')

        body_content_kwargs = {}  # type: Dict[str, Any]
        body_content = self._serialize.body(_body, 'TakeSnapshotRequest')
        body_content_kwargs['content'] = body_content
        request = self._client.post(url, query_parameters, header_parameters, **body_content_kwargs)
        pipeline_response = await self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [202]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize.failsafe_deserialize(_models.APIError, response)
            raise HttpResponseError(response=response, model=error)

        response_headers = {}
        response_headers['Operation-Location']=self._deserialize('str', response.headers.get('Operation-Location'))

        if cls:
            return cls(pipeline_response, None, response_headers)

    take.metadata = {'url': '/snapshots'}  # type: ignore

    async def list(
        self,
        type: Optional[Union[str, "_models.SnapshotObjectType"]] = None,
        apply_scope: Optional[List[str]] = None,
        **kwargs
    ) -> List["_models.Snapshot"]:
        """List all accessible snapshots with related information, including snapshots that were taken by
        the user, or snapshots to be applied to the user (subscription id was included in the
        applyScope in Snapshot - Take).

        :param type: User specified object type as a search filter.
        :type type: str or ~azure.cognitiveservices.vision.face.models.SnapshotObjectType
        :param apply_scope: User specified snapshot apply scopes as a search filter. ApplyScope is an
         array of the target Azure subscription ids for the snapshot, specified by the user who created
         the snapshot by Snapshot - Take.
        :type apply_scope: list[str]
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: list of Snapshot, or the result of cls(response)
        :rtype: list[~azure.cognitiveservices.vision.face.models.Snapshot]
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType[List["_models.Snapshot"]]
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}))
        accept = "application/json"

        # Construct URL
        url = self.list.metadata['url']  # type: ignore
        path_format_arguments = {
            'Endpoint': self._serialize.url("self._config.endpoint", self._config.endpoint, 'str', skip_quote=True),
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]
        if type is not None:
            query_parameters['type'] = self._serialize.query("type", type, 'str')
        if apply_scope is not None:
            query_parameters['applyScope'] = self._serialize.query("apply_scope", apply_scope, '[str]', div=',')

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]
        header_parameters['Accept'] = self._serialize.header("accept", accept, 'str')

        request = self._client.get(url, query_parameters, header_parameters)
        pipeline_response = await self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize.failsafe_deserialize(_models.APIError, response)
            raise HttpResponseError(response=response, model=error)

        deserialized = self._deserialize('[Snapshot]', pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized
    list.metadata = {'url': '/snapshots'}  # type: ignore

    async def get(
        self,
        snapshot_id: str,
        **kwargs
    ) -> "_models.Snapshot":
        """Retrieve information about a snapshot. Snapshot is only accessible to the source subscription
        who took it, and target subscriptions included in the applyScope in Snapshot - Take.

        :param snapshot_id: Id referencing a particular snapshot.
        :type snapshot_id: str
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: Snapshot, or the result of cls(response)
        :rtype: ~azure.cognitiveservices.vision.face.models.Snapshot
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType["_models.Snapshot"]
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}))
        accept = "application/json"

        # Construct URL
        url = self.get.metadata['url']  # type: ignore
        path_format_arguments = {
            'Endpoint': self._serialize.url("self._config.endpoint", self._config.endpoint, 'str', skip_quote=True),
            'snapshotId': self._serialize.url("snapshot_id", snapshot_id, 'str'),
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]
        header_parameters['Accept'] = self._serialize.header("accept", accept, 'str')

        request = self._client.get(url, query_parameters, header_parameters)
        pipeline_response = await self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize.failsafe_deserialize(_models.APIError, response)
            raise HttpResponseError(response=response, model=error)

        deserialized = self._deserialize('Snapshot', pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized
    get.metadata = {'url': '/snapshots/{snapshotId}'}  # type: ignore

    async def update(
        self,
        snapshot_id: str,
        apply_scope: Optional[List[str]] = None,
        user_data: Optional[str] = None,
        **kwargs
    ) -> None:
        """Update the information of a snapshot. Only the source subscription who took the snapshot can
        update the snapshot.

        :param snapshot_id: Id referencing a particular snapshot.
        :type snapshot_id: str
        :param apply_scope: Array of the target Face subscription ids for the snapshot, specified by
         the user who created the snapshot when calling Snapshot - Take. For each snapshot, only
         subscriptions included in the applyScope of Snapshot - Take can apply it.
        :type apply_scope: list[str]
        :param user_data: User specified data about the snapshot for any purpose. Length should not
         exceed 16KB.
        :type user_data: str
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: None, or the result of cls(response)
        :rtype: None
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType[None]
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}))

        _body = _models.UpdateSnapshotRequest(apply_scope=apply_scope, user_data=user_data)
        content_type = kwargs.pop("content_type", "application/json")
        accept = "application/json"

        # Construct URL
        url = self.update.metadata['url']  # type: ignore
        path_format_arguments = {
            'Endpoint': self._serialize.url("self._config.endpoint", self._config.endpoint, 'str', skip_quote=True),
            'snapshotId': self._serialize.url("snapshot_id", snapshot_id, 'str'),
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]
        header_parameters['Content-Type'] = self._serialize.header("content_type", content_type, 'str')
        header_parameters['Accept'] = self._serialize.header("accept", accept, 'str')

        body_content_kwargs = {}  # type: Dict[str, Any]
        body_content = self._serialize.body(_body, 'UpdateSnapshotRequest')
        body_content_kwargs['content'] = body_content
        request = self._client.patch(url, query_parameters, header_parameters, **body_content_kwargs)
        pipeline_response = await self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize.failsafe_deserialize(_models.APIError, response)
            raise HttpResponseError(response=response, model=error)

        if cls:
            return cls(pipeline_response, None, {})

    update.metadata = {'url': '/snapshots/{snapshotId}'}  # type: ignore

    async def delete(
        self,
        snapshot_id: str,
        **kwargs
    ) -> None:
        """Delete an existing snapshot according to the snapshotId. All object data and information in the
        snapshot will also be deleted. Only the source subscription who took the snapshot can delete
        the snapshot. If the user does not delete a snapshot with this API, the snapshot will still be
        automatically deleted in 48 hours after creation.

        :param snapshot_id: Id referencing a particular snapshot.
        :type snapshot_id: str
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: None, or the result of cls(response)
        :rtype: None
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType[None]
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}))
        accept = "application/json"

        # Construct URL
        url = self.delete.metadata['url']  # type: ignore
        path_format_arguments = {
            'Endpoint': self._serialize.url("self._config.endpoint", self._config.endpoint, 'str', skip_quote=True),
            'snapshotId': self._serialize.url("snapshot_id", snapshot_id, 'str'),
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]
        header_parameters['Accept'] = self._serialize.header("accept", accept, 'str')

        request = self._client.delete(url, query_parameters, header_parameters)
        pipeline_response = await self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize.failsafe_deserialize(_models.APIError, response)
            raise HttpResponseError(response=response, model=error)

        if cls:
            return cls(pipeline_response, None, {})

    delete.metadata = {'url': '/snapshots/{snapshotId}'}  # type: ignore

    async def apply(
        self,
        snapshot_id: str,
        object_id: str,
        **kwargs
    ) -> None:
        """Submit an operation to apply a snapshot to current subscription. For each snapshot, only
        subscriptions included in the applyScope of Snapshot - Take can apply it.:code:`<br />`
        The snapshot interfaces are for users to backup and restore their face data from one face
        subscription to another, inside same region or across regions. The workflow contains two
        phases, user first calls Snapshot - Take to create a copy of the source object and store it as
        a snapshot, then calls Snapshot - Apply to paste the snapshot to target subscription. The
        snapshots are stored in a centralized location (per Azure instance), so that they can be
        applied cross accounts and regions.:code:`<br />`
        Applying snapshot is an asynchronous operation. An operation id can be obtained from the
        "Operation-Location" field in response header, to be used in OperationStatus - Get for tracking
        the progress of applying the snapshot. The target object id will be included in the
        "resourceLocation" field in OperationStatus - Get response when the operation status is
        "succeeded".:code:`<br />`
        Snapshot applying time depends on the number of person and face entries in the snapshot object.
        It could be in seconds, or up to 1 hour for 1,000,000 persons with multiple faces.:code:`<br
        />`
        Snapshots will be automatically expired and cleaned in 48 hours after it is created by Snapshot
        - Take. So the target subscription is required to apply the snapshot in 48 hours since its
        creation.:code:`<br />`
        Applying a snapshot will not block any other operations against the target object, however it
        is not recommended because the correctness cannot be guaranteed during snapshot applying. After
        snapshot applying is completed, all operations towards the target object can work as normal.
        Snapshot also includes the training results of the source object, which means target
        subscription the snapshot applied to does not need re-train the target object before calling
        Identify/FindSimilar.:code:`<br />`
        One snapshot can be applied multiple times in parallel, while currently only CreateNew apply
        mode is supported, which means the apply operation will fail if target subscription already
        contains an object of same type and using the same objectId. Users can specify the "objectId"
        in request body to avoid such conflicts.:code:`<br />`


        * Free-tier subscription quota: 100 apply operations per month.
        * S0-tier subscription quota: 100 apply operations per day.

        :param snapshot_id: Id referencing a particular snapshot.
        :type snapshot_id: str
        :param object_id: User specified target object id to be created from the snapshot.
        :type object_id: str
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: None, or the result of cls(response)
        :rtype: None
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType[None]
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}))

        _body = _models.ApplySnapshotRequest(object_id=object_id)
        content_type = kwargs.pop("content_type", "application/json")
        accept = "application/json"

        # Construct URL
        url = self.apply.metadata['url']  # type: ignore
        path_format_arguments = {
            'Endpoint': self._serialize.url("self._config.endpoint", self._config.endpoint, 'str', skip_quote=True),
            'snapshotId': self._serialize.url("snapshot_id", snapshot_id, 'str'),
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]
        header_parameters['Content-Type'] = self._serialize.header("content_type", content_type, 'str')
        header_parameters['Accept'] = self._serialize.header("accept", accept, 'str')

        body_content_kwargs = {}  # type: Dict[str, Any]
        body_content = self._serialize.body(_body, 'ApplySnapshotRequest')
        body_content_kwargs['content'] = body_content
        request = self._client.post(url, query_parameters, header_parameters, **body_content_kwargs)
        pipeline_response = await self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [202]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize.failsafe_deserialize(_models.APIError, response)
            raise HttpResponseError(response=response, model=error)

        response_headers = {}
        response_headers['Operation-Location']=self._deserialize('str', response.headers.get('Operation-Location'))

        if cls:
            return cls(pipeline_response, None, response_headers)

    apply.metadata = {'url': '/snapshots/{snapshotId}/apply'}  # type: ignore

    async def get_operation_status(
        self,
        operation_id: str,
        **kwargs
    ) -> "_models.OperationStatus":
        """Retrieve the status of a take/apply snapshot operation.

        :param operation_id: Id referencing a particular take/apply snapshot operation.
        :type operation_id: str
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: OperationStatus, or the result of cls(response)
        :rtype: ~azure.cognitiveservices.vision.face.models.OperationStatus
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType["_models.OperationStatus"]
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}))
        accept = "application/json"

        # Construct URL
        url = self.get_operation_status.metadata['url']  # type: ignore
        path_format_arguments = {
            'Endpoint': self._serialize.url("self._config.endpoint", self._config.endpoint, 'str', skip_quote=True),
            'operationId': self._serialize.url("operation_id", operation_id, 'str'),
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]
        header_parameters['Accept'] = self._serialize.header("accept", accept, 'str')

        request = self._client.get(url, query_parameters, header_parameters)
        pipeline_response = await self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize.failsafe_deserialize(_models.APIError, response)
            raise HttpResponseError(response=response, model=error)

        deserialized = self._deserialize('OperationStatus', pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized
    get_operation_status.metadata = {'url': '/operations/{operationId}'}  # type: ignore
