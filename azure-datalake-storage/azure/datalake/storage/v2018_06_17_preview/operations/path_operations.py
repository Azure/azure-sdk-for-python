# coding=utf-8
# --------------------------------------------------------------------------
# Copyright (c) Microsoft Corporation. All rights reserved.
# Licensed under the MIT License. See License.txt in the project root for
# license information.
#
# Code generated by Microsoft (R) AutoRest Code Generator.
# Changes may cause incorrect behavior and will be lost if the code is
# regenerated.
# --------------------------------------------------------------------------

import uuid
from msrest.pipeline import ClientRawResponse

from .. import models


class PathOperations(object):
    """PathOperations operations.

    :param client: Client for service requests.
    :param config: Configuration of service client.
    :param serializer: An object model serializer.
    :param deserializer: An object model deserializer.
    :ivar resource: The value must be "filesystem" for all filesystem operations. Constant value: "filesystem".
    """

    models = models

    def __init__(self, client, config, serializer, deserializer):

        self._client = client
        self._serialize = serializer
        self._deserialize = deserializer
        self.resource = "filesystem"

        self.config = config

    def list(
            self, recursive, filesystem, directory=None, continuation=None, max_results=None, x_ms_client_request_id=None, timeout=None, x_ms_date=None, custom_headers=None, raw=False, **operation_config):
        """List Paths.

        List filesystem paths and their properties.

        :param recursive: If "true", all paths are listed; otherwise, only
         paths at the root of the filesystem are listed.  If "directory" is
         specified, the list will only include paths that share the same root.
        :type recursive: bool
        :param filesystem: The filesystem identifier.  The value must start
         and end with a letter or number and must contain only letters,
         numbers, and the dash (-) character.  Consecutive dashes are not
         permitted.  All letters must be lowercase.  The value must have
         between 3 and 63 characters.
        :type filesystem: str
        :param directory: Filters results to paths within the specified
         directory. An error occurs if the directory does not exist.
        :type directory: str
        :param continuation: The number of paths returned with each invocation
         is limited. If the number of paths to be returned exceeds this limit,
         a continuation token is returned in the response header
         x-ms-continuation. When a continuation token is  returned in the
         response, it must be specified in a subsequent invocation of the list
         operation to continue listing the paths.
        :type continuation: str
        :param max_results: An optional value that specifies the maximum
         number of items to return. If omitted or greater than 5,000, the
         response will include up to 5,000 items.
        :type max_results: int
        :param x_ms_client_request_id: A UUID recorded in the analytics logs
         for troubleshooting and correlation.
        :type x_ms_client_request_id: str
        :param timeout: An optional operation timeout value in seconds. The
         period begins when the request is received by the service. If the
         timeout value elapses before the operation completes, the operation
         fails.
        :type timeout: int
        :param x_ms_date: Specifies the Coordinated Universal Time (UTC) for
         the request.  This is required when using shared key authorization.
        :type x_ms_date: str
        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :return: An iterator like instance of Path
        :rtype:
         ~azure.mgmt.media.models.PathPaged[~azure.mgmt.media.models.Path]
        :raises:
         :class:`DataLakeStorageErrorException<azure.mgmt.media.models.DataLakeStorageErrorException>`
        """
        def internal_paging(next_link=None, raw=False):

            if not next_link:
                # Construct URL
                url = self.list.metadata['url']
                path_format_arguments = {
                    'accountName': self._serialize.url("self.config.account_name", self.config.account_name, 'str', skip_quote=True),
                    'dnsSuffix': self._serialize.url("self.config.dns_suffix", self.config.dns_suffix, 'str', skip_quote=True),
                    'filesystem': self._serialize.url("filesystem", filesystem, 'str')
                }
                url = self._client.format_url(url, **path_format_arguments)

                # Construct parameters
                query_parameters = {}
                if directory is not None:
                    query_parameters['directory'] = self._serialize.query("directory", directory, 'str')
                query_parameters['recursive'] = self._serialize.query("recursive", recursive, 'bool')
                if continuation is not None:
                    query_parameters['continuation'] = self._serialize.query("continuation", continuation, 'str')
                if max_results is not None:
                    query_parameters['maxResults'] = self._serialize.query("max_results", max_results, 'int', minimum=1)
                query_parameters['resource'] = self._serialize.query("self.resource", self.resource, 'str')
                if timeout is not None:
                    query_parameters['timeout'] = self._serialize.query("timeout", timeout, 'int', minimum=1)

            else:
                url = next_link
                query_parameters = {}

            # Construct headers
            header_parameters = {}
            header_parameters['Content-Type'] = 'application/json; charset=utf-8'
            if self.config.generate_client_request_id:
                header_parameters['x-ms-client-request-id'] = str(uuid.uuid1())
            if custom_headers:
                header_parameters.update(custom_headers)
            if x_ms_client_request_id is not None:
                header_parameters['x-ms-client-request-id'] = self._serialize.header("x_ms_client_request_id", x_ms_client_request_id, 'str', pattern=r'^[{(]?[0-9a-f]{8}[-]?([0-9a-f]{4}[-]?){3}[0-9a-f]{12}[)}]?$')
            if x_ms_date is not None:
                header_parameters['x-ms-date'] = self._serialize.header("x_ms_date", x_ms_date, 'str')
            if self.config.x_ms_version is not None:
                header_parameters['x-ms-version'] = self._serialize.header("self.config.x_ms_version", self.config.x_ms_version, 'str')
            if self.config.accept_language is not None:
                header_parameters['accept-language'] = self._serialize.header("self.config.accept_language", self.config.accept_language, 'str')

            # Construct and send request
            request = self._client.get(url, query_parameters)
            response = self._client.send(
                request, header_parameters, stream=False, **operation_config)

            if response.status_code not in [200]:
                raise models.DataLakeStorageErrorException(self._deserialize, response)

            return response

        # Deserialize response
        deserialized = models.PathPaged(internal_paging, self._deserialize.dependencies)

        if raw:
            header_dict = {}
            client_raw_response = models.PathPaged(internal_paging, self._deserialize.dependencies, header_dict)
            return client_raw_response

        return deserialized
    list.metadata = {'url': '/{filesystem}'}

    def create(
            self, filesystem, path, resource=None, continuation=None, mode=None, cache_control=None, content_encoding=None, content_language=None, content_disposition=None, x_ms_cache_control=None, x_ms_content_type=None, x_ms_content_encoding=None, x_ms_content_language=None, x_ms_content_disposition=None, x_ms_rename_source=None, x_ms_lease_id=None, x_ms_proposed_lease_id=None, x_ms_source_lease_id=None, x_ms_properties=None, x_ms_permissions=None, if_match=None, if_none_match=None, if_modified_since=None, if_unmodified_since=None, x_ms_source_if_match=None, x_ms_source_if_none_match=None, x_ms_source_if_modified_since=None, x_ms_source_if_unmodified_since=None, x_ms_client_request_id=None, timeout=None, x_ms_date=None, custom_headers=None, raw=False, **operation_config):
        """Create File | Create Directory | Rename File | Rename Directory.

        Create or rename a file or directory.    By default, the destination is
        overwritten and if the destination already exists and has a lease the
        lease is broken.  This operation supports conditional HTTP requests.
        For more information, see [Specifying Conditional Headers for Blob
        Service
        Operations](https://docs.microsoft.com/en-us/rest/api/storageservices/specifying-conditional-headers-for-blob-service-operations).
        To fail if the destination already exists, use a conditional request
        with If-None-Match: "*".

        :param filesystem: The filesystem identifier.
        :type filesystem: str
        :param path: The file or directory path.
        :type path: str
        :param resource: Required only for Create File and Create Directory.
         The value must be "file" or "directory". Possible values include:
         'directory', 'file'
        :type resource: str or ~azure.mgmt.media.models.PathResourceType
        :param continuation: Optional.  When renaming a directory, the number
         of paths that are renamed with each invocation is limited.  If the
         number of paths to be renamed exceeds this limit, a continuation token
         is returned in this response header.  When a continuation token is
         returned in the response, it must be specified in a subsequent
         invocation of the rename operation to continue renaming the directory.
        :type continuation: str
        :param mode: Optional. Valid only when namespace is enabled. This
         parameter determines the behavior of the rename operation. The value
         must be "legacy" or "posix", and the default value will be "posix".
         Possible values include: 'legacy', 'posix'
        :type mode: str or ~azure.mgmt.media.models.PathRenameMode
        :param cache_control: Optional.  The service stores this value and
         includes it in the "Cache-Control" response header for "Read File"
         operations for "Read File" operations.
        :type cache_control: str
        :param content_encoding: Optional.  Specifies which content encodings
         have been applied to the file. This value is returned to the client
         when the "Read File" operation is performed.
        :type content_encoding: str
        :param content_language: Optional.  Specifies the natural language
         used by the intended audience for the file.
        :type content_language: str
        :param content_disposition: Optional.  The service stores this value
         and includes it in the "Content-Disposition" response header for "Read
         File" operations.
        :type content_disposition: str
        :param x_ms_cache_control: Optional.  The service stores this value
         and includes it in the "Cache-Control" response header for "Read File"
         operations.
        :type x_ms_cache_control: str
        :param x_ms_content_type: Optional.  The service stores this value and
         includes it in the "Content-Type" response header for "Read File"
         operations.
        :type x_ms_content_type: str
        :param x_ms_content_encoding: Optional.  The service stores this value
         and includes it in the "Content-Encoding" response header for "Read
         File" operations.
        :type x_ms_content_encoding: str
        :param x_ms_content_language: Optional.  The service stores this value
         and includes it in the "Content-Language" response header for "Read
         File" operations.
        :type x_ms_content_language: str
        :param x_ms_content_disposition: Optional.  The service stores this
         value and includes it in the "Content-Disposition" response header for
         "Read File" operations.
        :type x_ms_content_disposition: str
        :param x_ms_rename_source: An optional file or directory to be
         renamed.  The value must have the following format:
         "/{filesysystem}/{path}".  If "x-ms-properties" is specified, the
         properties will overwrite the existing properties; otherwise, the
         existing properties will be preserved.
        :type x_ms_rename_source: str
        :param x_ms_lease_id: Optional.  A lease ID for the path specified in
         the URI.  The path to be overwritten must have an active lease and the
         lease ID must match.
        :type x_ms_lease_id: str
        :param x_ms_proposed_lease_id: Optional for create operations.
         Required when "x-ms-lease-action" is used.  A lease will be acquired
         using the proposed ID when the resource is created.
        :type x_ms_proposed_lease_id: str
        :param x_ms_source_lease_id: Optional for rename operations.  A lease
         ID for the source path.  The source path must have an active lease and
         the lease ID must match.
        :type x_ms_source_lease_id: str
        :param x_ms_properties: Optional.  User-defined properties to be
         stored with the file or directory, in the format of a comma-separated
         list of name and value pairs "n1=v1, n2=v2, ...", where each value is
         base64 encoded.
        :type x_ms_properties: str
        :param x_ms_permissions: Optional and only valid if Hierarchical
         Namespace is enabled for the account. Sets POSIX access permissions
         for the file owner, the file owning group, and others. Each class may
         be granted read, write, or execute permission.  The sticky bit is also
         supported.  Both symbolic (rwxrw-rw-) and 4-digit octal notation (e.g.
         0766) are supported.
        :type x_ms_permissions: str
        :param if_match: Optional.  An ETag value. Specify this header to
         perform the operation only if the resource's ETag matches the value
         specified. The ETag must be specified in quotes.
        :type if_match: str
        :param if_none_match: Optional.  An ETag value or the special wildcard
         ("*") value. Specify this header to perform the operation only if the
         resource's ETag does not match the value specified. The ETag must be
         specified in quotes.
        :type if_none_match: str
        :param if_modified_since: Optional. A date and time value. Specify
         this header to perform the operation only if the resource has been
         modified since the specified date and time.
        :type if_modified_since: str
        :param if_unmodified_since: Optional. A date and time value. Specify
         this header to perform the operation only if the resource has not been
         modified since the specified date and time.
        :type if_unmodified_since: str
        :param x_ms_source_if_match: Optional.  An ETag value. Specify this
         header to perform the rename operation only if the source's ETag
         matches the value specified. The ETag must be specified in quotes.
        :type x_ms_source_if_match: str
        :param x_ms_source_if_none_match: Optional.  An ETag value or the
         special wildcard ("*") value. Specify this header to perform the
         rename operation only if the source's ETag does not match the value
         specified. The ETag must be specified in quotes.
        :type x_ms_source_if_none_match: str
        :param x_ms_source_if_modified_since: Optional. A date and time value.
         Specify this header to perform the rename operation only if the source
         has been modified since the specified date and time.
        :type x_ms_source_if_modified_since: str
        :param x_ms_source_if_unmodified_since: Optional. A date and time
         value. Specify this header to perform the rename operation only if the
         source has not been modified since the specified date and time.
        :type x_ms_source_if_unmodified_since: str
        :param x_ms_client_request_id: A UUID recorded in the analytics logs
         for troubleshooting and correlation.
        :type x_ms_client_request_id: str
        :param timeout: An optional operation timeout value in seconds. The
         period begins when the request is received by the service. If the
         timeout value elapses before the operation completes, the operation
         fails.
        :type timeout: int
        :param x_ms_date: Specifies the Coordinated Universal Time (UTC) for
         the request.  This is required when using shared key authorization.
        :type x_ms_date: str
        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :return: None or ClientRawResponse if raw=true
        :rtype: None or ~msrest.pipeline.ClientRawResponse
        :raises:
         :class:`DataLakeStorageErrorException<azure.mgmt.media.models.DataLakeStorageErrorException>`
        """
        # Construct URL
        url = self.create.metadata['url']
        path_format_arguments = {
            'accountName': self._serialize.url("self.config.account_name", self.config.account_name, 'str', skip_quote=True),
            'dnsSuffix': self._serialize.url("self.config.dns_suffix", self.config.dns_suffix, 'str', skip_quote=True),
            'filesystem': self._serialize.url("filesystem", filesystem, 'str', max_length=63, min_length=3, pattern=r'^[a-z0-9](?!.*--)[-a-z0-9]{1,61}[a-z0-9]$'),
            'path': self._serialize.url("path", path, 'str')
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}
        if resource is not None:
            query_parameters['resource'] = self._serialize.query("resource", resource, 'PathResourceType')
        if continuation is not None:
            query_parameters['continuation'] = self._serialize.query("continuation", continuation, 'str')
        if mode is not None:
            query_parameters['mode'] = self._serialize.query("mode", mode, 'PathRenameMode')
        if timeout is not None:
            query_parameters['timeout'] = self._serialize.query("timeout", timeout, 'int', minimum=1)

        # Construct headers
        header_parameters = {}
        header_parameters['Content-Type'] = 'application/json; charset=utf-8'
        if self.config.generate_client_request_id:
            header_parameters['x-ms-client-request-id'] = str(uuid.uuid1())
        if custom_headers:
            header_parameters.update(custom_headers)
        if cache_control is not None:
            header_parameters['Cache-Control'] = self._serialize.header("cache_control", cache_control, 'str')
        if content_encoding is not None:
            header_parameters['Content-Encoding'] = self._serialize.header("content_encoding", content_encoding, 'str')
        if content_language is not None:
            header_parameters['Content-Language'] = self._serialize.header("content_language", content_language, 'str')
        if content_disposition is not None:
            header_parameters['Content-Disposition'] = self._serialize.header("content_disposition", content_disposition, 'str')
        if x_ms_cache_control is not None:
            header_parameters['x-ms-cache-control'] = self._serialize.header("x_ms_cache_control", x_ms_cache_control, 'str')
        if x_ms_content_type is not None:
            header_parameters['x-ms-content-type'] = self._serialize.header("x_ms_content_type", x_ms_content_type, 'str')
        if x_ms_content_encoding is not None:
            header_parameters['x-ms-content-encoding'] = self._serialize.header("x_ms_content_encoding", x_ms_content_encoding, 'str')
        if x_ms_content_language is not None:
            header_parameters['x-ms-content-language'] = self._serialize.header("x_ms_content_language", x_ms_content_language, 'str')
        if x_ms_content_disposition is not None:
            header_parameters['x-ms-content-disposition'] = self._serialize.header("x_ms_content_disposition", x_ms_content_disposition, 'str')
        if x_ms_rename_source is not None:
            header_parameters['x-ms-rename-source'] = self._serialize.header("x_ms_rename_source", x_ms_rename_source, 'str')
        if x_ms_lease_id is not None:
            header_parameters['x-ms-lease-id'] = self._serialize.header("x_ms_lease_id", x_ms_lease_id, 'str', pattern=r'^[{(]?[0-9a-f]{8}[-]?([0-9a-f]{4}[-]?){3}[0-9a-f]{12}[)}]?$')
        if x_ms_proposed_lease_id is not None:
            header_parameters['x-ms-proposed-lease-id'] = self._serialize.header("x_ms_proposed_lease_id", x_ms_proposed_lease_id, 'str', pattern=r'^[{(]?[0-9a-f]{8}[-]?([0-9a-f]{4}[-]?){3}[0-9a-f]{12}[)}]?$')
        if x_ms_source_lease_id is not None:
            header_parameters['x-ms-source-lease-id'] = self._serialize.header("x_ms_source_lease_id", x_ms_source_lease_id, 'str', pattern=r'^[{(]?[0-9a-f]{8}[-]?([0-9a-f]{4}[-]?){3}[0-9a-f]{12}[)}]?$')
        if x_ms_properties is not None:
            header_parameters['x-ms-properties'] = self._serialize.header("x_ms_properties", x_ms_properties, 'str')
        if x_ms_permissions is not None:
            header_parameters['x-ms-permissions'] = self._serialize.header("x_ms_permissions", x_ms_permissions, 'str')
        if if_match is not None:
            header_parameters['If-Match'] = self._serialize.header("if_match", if_match, 'str')
        if if_none_match is not None:
            header_parameters['If-None-Match'] = self._serialize.header("if_none_match", if_none_match, 'str')
        if if_modified_since is not None:
            header_parameters['If-Modified-Since'] = self._serialize.header("if_modified_since", if_modified_since, 'str')
        if if_unmodified_since is not None:
            header_parameters['If-Unmodified-Since'] = self._serialize.header("if_unmodified_since", if_unmodified_since, 'str')
        if x_ms_source_if_match is not None:
            header_parameters['x-ms-source-if-match'] = self._serialize.header("x_ms_source_if_match", x_ms_source_if_match, 'str')
        if x_ms_source_if_none_match is not None:
            header_parameters['x-ms-source-if-none-match'] = self._serialize.header("x_ms_source_if_none_match", x_ms_source_if_none_match, 'str')
        if x_ms_source_if_modified_since is not None:
            header_parameters['x-ms-source-if-modified-since'] = self._serialize.header("x_ms_source_if_modified_since", x_ms_source_if_modified_since, 'str')
        if x_ms_source_if_unmodified_since is not None:
            header_parameters['x-ms-source-if-unmodified-since'] = self._serialize.header("x_ms_source_if_unmodified_since", x_ms_source_if_unmodified_since, 'str')
        if x_ms_client_request_id is not None:
            header_parameters['x-ms-client-request-id'] = self._serialize.header("x_ms_client_request_id", x_ms_client_request_id, 'str', pattern=r'^[{(]?[0-9a-f]{8}[-]?([0-9a-f]{4}[-]?){3}[0-9a-f]{12}[)}]?$')
        if x_ms_date is not None:
            header_parameters['x-ms-date'] = self._serialize.header("x_ms_date", x_ms_date, 'str')
        if self.config.x_ms_version is not None:
            header_parameters['x-ms-version'] = self._serialize.header("self.config.x_ms_version", self.config.x_ms_version, 'str')
        if self.config.accept_language is not None:
            header_parameters['accept-language'] = self._serialize.header("self.config.accept_language", self.config.accept_language, 'str')

        # Construct and send request
        request = self._client.put(url, query_parameters)
        response = self._client.send(request, header_parameters, stream=False, **operation_config)

        if response.status_code not in [201]:
            raise models.DataLakeStorageErrorException(self._deserialize, response)

        if raw:
            client_raw_response = ClientRawResponse(None, response)
            client_raw_response.add_headers({
                'Date': 'str',
                'ETag': 'str',
                'Last-Modified': 'str',
                'x-ms-request-id': 'str',
                'x-ms-version': 'str',
                'x-ms-continuation': 'str',
                'Content-Length': 'str',
            })
            return client_raw_response
    create.metadata = {'url': '/{filesystem}/{path}'}

    def update(
            self, action, filesystem, path, position=None, retain_uncommitted_data=None, content_length=None, x_ms_lease_action=None, x_ms_lease_id=None, x_ms_cache_control=None, x_ms_content_type=None, x_ms_content_disposition=None, x_ms_content_encoding=None, x_ms_content_language=None, x_ms_properties=None, x_ms_owner=None, x_ms_group=None, x_ms_permissions=None, x_ms_acl=None, if_match=None, if_none_match=None, if_modified_since=None, if_unmodified_since=None, request_body=None, x_ms_client_request_id=None, timeout=None, x_ms_date=None, custom_headers=None, raw=False, callback=None, **operation_config):
        """Append Data | Flush Data | Set Properties | Set Access Control.

        Uploads data to be appended to a file, flushes (writes) previously
        uploaded data to a file, sets properties for a file or directory, or
        sets access control for a file or directory. Data can only be appended
        to a file. This operation supports conditional HTTP requests. For more
        information, see [Specifying Conditional Headers for Blob Service
        Operations](https://docs.microsoft.com/en-us/rest/api/storageservices/specifying-conditional-headers-for-blob-service-operations).

        :param action: The action must be "append" to upload data to be
         appended to a file, "flush" to flush previously uploaded data to a
         file, "setProperties" to set the properties of a file or directory, or
         "setAccessControl" to set the owner, group, permissions, or access
         control list for a file or directory.  Note that Hierarchical
         Namespace must be enabled for the account in order to use access
         control.  Also note that the Access Control List (ACL) includes
         permissions for the owner, owning group, and others, so the
         x-ms-permissions and x-ms-acl request headers are mutually exclusive.
         Possible values include: 'append', 'flush', 'setProperties',
         'setAccessControl'
        :type action: str or ~azure.mgmt.media.models.PathUpdateAction
        :param filesystem: The filesystem identifier.
        :type filesystem: str
        :param path: The file or directory path.
        :type path: str
        :param position: This parameter allows the caller to upload data in
         parallel and control the order in which it is appended to the file.
         It is required when uploading data to be appended to the file and when
         flushing previously uploaded data to the file.  The value must be the
         position where the data is to be appended.  Uploaded data is not
         immediately flushed, or written, to the file.  To flush, the
         previously uploaded data must be contiguous, the position parameter
         must be specified and equal to the length of the file after all data
         has been written, and there must not be a request entity body included
         with the request.
        :type position: long
        :param retain_uncommitted_data: Valid only for flush operations.  If
         "true", uncommitted data is retained after the flush operation
         completes; otherwise, the uncommitted data is deleted after the flush
         operation.  The default is false.  Data at offsets less than the
         specified position are written to the file when flush succeeds, but
         this optional parameter allows data after the flush position to be
         retained for a future flush operation.
        :type retain_uncommitted_data: bool
        :param content_length: Required for "Append Data" and "Flush Data".
         Must be 0 for "Flush Data".  Must be the length of the request content
         in bytes for "Append Data".
        :type content_length: str
        :param x_ms_lease_action: Optional.  The lease action can be "renew"
         to renew an existing lease or "release" to release a lease. Possible
         values include: 'renew', 'release'
        :type x_ms_lease_action: str or
         ~azure.mgmt.media.models.PathUpdateLeaseAction
        :param x_ms_lease_id: The lease ID must be specified if there is an
         active lease.
        :type x_ms_lease_id: str
        :param x_ms_cache_control: Optional and only valid for flush and set
         properties operations.  The service stores this value and includes it
         in the "Cache-Control" response header for "Read File" operations.
        :type x_ms_cache_control: str
        :param x_ms_content_type: Optional and only valid for flush and set
         properties operations.  The service stores this value and includes it
         in the "Content-Type" response header for "Read File" operations.
        :type x_ms_content_type: str
        :param x_ms_content_disposition: Optional and only valid for flush and
         set properties operations.  The service stores this value and includes
         it in the "Content-Disposition" response header for "Read File"
         operations.
        :type x_ms_content_disposition: str
        :param x_ms_content_encoding: Optional and only valid for flush and
         set properties operations.  The service stores this value and includes
         it in the "Content-Encoding" response header for "Read File"
         operations.
        :type x_ms_content_encoding: str
        :param x_ms_content_language: Optional and only valid for flush and
         set properties operations.  The service stores this value and includes
         it in the "Content-Language" response header for "Read File"
         operations.
        :type x_ms_content_language: str
        :param x_ms_properties: Optional.  User-defined properties to be
         stored with the file or directory, in the format of a comma-separated
         list of name and value pairs "n1=v1, n2=v2, ...", where each value is
         base64 encoded.  Valid only for the setProperties operation.  If the
         file or directory exists, any properties not included in the list will
         be removed.  All properties are removed if the header is omitted.  To
         merge new and existing properties, first get all existing properties
         and the current E-Tag, then make a conditional request with the E-Tag
         and include values for all properties.
        :type x_ms_properties: str
        :param x_ms_owner: Optional and valid only for the setAccessControl
         operation. Sets the owner of the file or directory.
        :type x_ms_owner: str
        :param x_ms_group: Optional and valid only for the setAccessControl
         operation. Sets the owning group of the file or directory.
        :type x_ms_group: str
        :param x_ms_permissions: Optional and only valid if Hierarchical
         Namespace is enabled for the account. Sets POSIX access permissions
         for the file owner, the file owning group, and others. Each class may
         be granted read, write, or execute permission.  The sticky bit is also
         supported.  Both symbolic (rwxrw-rw-) and 4-digit octal notation (e.g.
         0766) are supported. Invalid in conjunction with x-ms-acl.
        :type x_ms_permissions: str
        :param x_ms_acl: Optional and valid only for the setAccessControl
         operation. Sets POSIX access control rights on files and directories.
         The value is a comma-separated list of access control entries that
         fully replaces the existing access control list (ACL).  Each access
         control entry (ACE) consists of a scope, a type, a user or group
         identifier, and permissions in the format
         "[scope:][type]:[id]:[permissions]". The scope must be "default" to
         indicate the ACE belongs to the default ACL for a directory; otherwise
         scope is implicit and the ACE belongs to the access ACL.  There are
         four ACE types: "user" grants rights to the owner or a named user,
         "group" grants rights to the owning group or a named group, "mask"
         restricts rights granted to named users and the members of groups, and
         "other" grants rights to all users not found in any of the other
         entries. The user or group identifier is omitted for entries of type
         "mask" and "other".  The user or group identifier is also omitted for
         the owner and owning group.  The permission field is a 3-character
         sequence where the first character is 'r' to grant read access, the
         second character is 'w' to grant write access, and the third character
         is 'x' to grant execute permission.  If access is not granted, the '-'
         character is used to denote that the permission is denied. For
         example, the following ACL grants read, write, and execute rights to
         the file owner and john.doe@contoso, the read right to the owning
         group, and nothing to everyone else:
         "user::rwx,user:john.doe@contoso:rwx,group::r--,other::---,mask=rwx".
         Invalid in conjunction with x-ms-permissions.
        :type x_ms_acl: str
        :param if_match: Optional for Flush Data and Set Properties, but
         invalid for Append Data.  An ETag value. Specify this header to
         perform the operation only if the resource's ETag matches the value
         specified. The ETag must be specified in quotes.
        :type if_match: str
        :param if_none_match: Optional for Flush Data and Set Properties, but
         invalid for Append Data.  An ETag value or the special wildcard ("*")
         value. Specify this header to perform the operation only if the
         resource's ETag does not match the value specified. The ETag must be
         specified in quotes.
        :type if_none_match: str
        :param if_modified_since: Optional for Flush Data and Set Properties,
         but invalid for Append Data. A date and time value. Specify this
         header to perform the operation only if the resource has been modified
         since the specified date and time.
        :type if_modified_since: str
        :param if_unmodified_since: Optional for Flush Data and Set
         Properties, but invalid for Append Data. A date and time value.
         Specify this header to perform the operation only if the resource has
         not been modified since the specified date and time.
        :type if_unmodified_since: str
        :param request_body: Valid only for append operations.  The data to be
         uploaded and appended to the file.
        :type request_body: Generator
        :param x_ms_client_request_id: A UUID recorded in the analytics logs
         for troubleshooting and correlation.
        :type x_ms_client_request_id: str
        :param timeout: An optional operation timeout value in seconds. The
         period begins when the request is received by the service. If the
         timeout value elapses before the operation completes, the operation
         fails.
        :type timeout: int
        :param x_ms_date: Specifies the Coordinated Universal Time (UTC) for
         the request.  This is required when using shared key authorization.
        :type x_ms_date: str
        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param callback: When specified, will be called with each chunk of
         data that is streamed. The callback should take two arguments, the
         bytes of the current chunk of data and the response object. If the
         data is uploading, response will be None.
        :type callback: Callable[Bytes, response=None]
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :return: None or ClientRawResponse if raw=true
        :rtype: None or ~msrest.pipeline.ClientRawResponse
        :raises:
         :class:`DataLakeStorageErrorException<azure.mgmt.media.models.DataLakeStorageErrorException>`
        """
        # Construct URL
        url = self.update.metadata['url']
        path_format_arguments = {
            'accountName': self._serialize.url("self.config.account_name", self.config.account_name, 'str', skip_quote=True),
            'dnsSuffix': self._serialize.url("self.config.dns_suffix", self.config.dns_suffix, 'str', skip_quote=True),
            'filesystem': self._serialize.url("filesystem", filesystem, 'str', max_length=63, min_length=3, pattern=r'^[a-z0-9](?!.*--)[-a-z0-9]{1,61}[a-z0-9]$'),
            'path': self._serialize.url("path", path, 'str')
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}
        query_parameters['action'] = self._serialize.query("action", action, 'PathUpdateAction')
        if position is not None:
            query_parameters['position'] = self._serialize.query("position", position, 'long')
        if retain_uncommitted_data is not None:
            query_parameters['retainUncommittedData'] = self._serialize.query("retain_uncommitted_data", retain_uncommitted_data, 'bool')
        if timeout is not None:
            query_parameters['timeout'] = self._serialize.query("timeout", timeout, 'int', minimum=1)

        # Construct headers
        header_parameters = {}
        header_parameters['Content-Type'] = 'application/octet-stream'
        if self.config.generate_client_request_id:
            header_parameters['x-ms-client-request-id'] = str(uuid.uuid1())
        if custom_headers:
            header_parameters.update(custom_headers)
        if content_length is not None:
            header_parameters['Content-Length'] = self._serialize.header("content_length", content_length, 'str')
        if x_ms_lease_action is not None:
            header_parameters['x-ms-lease-action'] = self._serialize.header("x_ms_lease_action", x_ms_lease_action, 'PathUpdateLeaseAction')
        if x_ms_lease_id is not None:
            header_parameters['x-ms-lease-id'] = self._serialize.header("x_ms_lease_id", x_ms_lease_id, 'str', pattern=r'^[{(]?[0-9a-f]{8}[-]?([0-9a-f]{4}[-]?){3}[0-9a-f]{12}[)}]?$')
        if x_ms_cache_control is not None:
            header_parameters['x-ms-cache-control'] = self._serialize.header("x_ms_cache_control", x_ms_cache_control, 'str')
        if x_ms_content_type is not None:
            header_parameters['x-ms-content-type'] = self._serialize.header("x_ms_content_type", x_ms_content_type, 'str')
        if x_ms_content_disposition is not None:
            header_parameters['x-ms-content-disposition'] = self._serialize.header("x_ms_content_disposition", x_ms_content_disposition, 'str')
        if x_ms_content_encoding is not None:
            header_parameters['x-ms-content-encoding'] = self._serialize.header("x_ms_content_encoding", x_ms_content_encoding, 'str')
        if x_ms_content_language is not None:
            header_parameters['x-ms-content-language'] = self._serialize.header("x_ms_content_language", x_ms_content_language, 'str')
        if x_ms_properties is not None:
            header_parameters['x-ms-properties'] = self._serialize.header("x_ms_properties", x_ms_properties, 'str')
        if x_ms_owner is not None:
            header_parameters['x-ms-owner'] = self._serialize.header("x_ms_owner", x_ms_owner, 'str')
        if x_ms_group is not None:
            header_parameters['x-ms-group'] = self._serialize.header("x_ms_group", x_ms_group, 'str')
        if x_ms_permissions is not None:
            header_parameters['x-ms-permissions'] = self._serialize.header("x_ms_permissions", x_ms_permissions, 'str')
        if x_ms_acl is not None:
            header_parameters['x-ms-acl'] = self._serialize.header("x_ms_acl", x_ms_acl, 'str')
        if if_match is not None:
            header_parameters['If-Match'] = self._serialize.header("if_match", if_match, 'str')
        if if_none_match is not None:
            header_parameters['If-None-Match'] = self._serialize.header("if_none_match", if_none_match, 'str')
        if if_modified_since is not None:
            header_parameters['If-Modified-Since'] = self._serialize.header("if_modified_since", if_modified_since, 'str')
        if if_unmodified_since is not None:
            header_parameters['If-Unmodified-Since'] = self._serialize.header("if_unmodified_since", if_unmodified_since, 'str')
        if x_ms_client_request_id is not None:
            header_parameters['x-ms-client-request-id'] = self._serialize.header("x_ms_client_request_id", x_ms_client_request_id, 'str', pattern=r'^[{(]?[0-9a-f]{8}[-]?([0-9a-f]{4}[-]?){3}[0-9a-f]{12}[)}]?$')
        if x_ms_date is not None:
            header_parameters['x-ms-date'] = self._serialize.header("x_ms_date", x_ms_date, 'str')
        if self.config.x_ms_version is not None:
            header_parameters['x-ms-version'] = self._serialize.header("self.config.x_ms_version", self.config.x_ms_version, 'str')
        if self.config.accept_language is not None:
            header_parameters['accept-language'] = self._serialize.header("self.config.accept_language", self.config.accept_language, 'str')

        # Construct body
        body_content = self._client.stream_upload(request_body, callback)

        # Construct and send request
        request = self._client.patch(url, query_parameters)
        response = self._client.send(
            request, header_parameters, body_content, stream=False, **operation_config)

        if response.status_code not in [200, 202]:
            raise models.DataLakeStorageErrorException(self._deserialize, response)

        if raw:
            client_raw_response = ClientRawResponse(None, response)
            client_raw_response.add_headers({
                'Date': 'str',
                'ETag': 'str',
                'Last-Modified': 'str',
                'Accept-Ranges': 'str',
                'Cache-Control': 'str',
                'Content-Disposition': 'str',
                'Content-Encoding': 'str',
                'Content-Language': 'str',
                'Content-Length': 'str',
                'Content-Range': 'str',
                'Content-Type': 'str',
                'x-ms-properties': 'str',
                'x-ms-request-id': 'str',
                'x-ms-version': 'str',
            })
            return client_raw_response
    update.metadata = {'url': '/{filesystem}/{path}'}

    def lease(
            self, x_ms_lease_action, filesystem, path, x_ms_lease_duration=None, x_ms_lease_break_period=None, x_ms_lease_id=None, x_ms_proposed_lease_id=None, if_match=None, if_none_match=None, if_modified_since=None, if_unmodified_since=None, x_ms_client_request_id=None, timeout=None, x_ms_date=None, custom_headers=None, raw=False, **operation_config):
        """Lease Path.

        Create and manage a lease to restrict write and delete access to the
        path. This operation supports conditional HTTP requests.  For more
        information, see [Specifying Conditional Headers for Blob Service
        Operations](https://docs.microsoft.com/en-us/rest/api/storageservices/specifying-conditional-headers-for-blob-service-operations).

        :param x_ms_lease_action: There are five lease actions: "acquire",
         "break", "change", "renew", and "release". Use "acquire" and specify
         the "x-ms-proposed-lease-id" and "x-ms-lease-duration" to acquire a
         new lease. Use "break" to break an existing lease. When a lease is
         broken, the lease break period is allowed to elapse, during which time
         no lease operation except break and release can be performed on the
         file. When a lease is successfully broken, the response indicates the
         interval in seconds until a new lease can be acquired. Use "change"
         and specify the current lease ID in "x-ms-lease-id" and the new lease
         ID in "x-ms-proposed-lease-id" to change the lease ID of an active
         lease. Use "renew" and specify the "x-ms-lease-id" to renew an
         existing lease. Use "release" and specify the "x-ms-lease-id" to
         release a lease. Possible values include: 'acquire', 'break',
         'change', 'renew', 'release'
        :type x_ms_lease_action: str or
         ~azure.mgmt.media.models.PathLeaseAction
        :param filesystem: The filesystem identifier.
        :type filesystem: str
        :param path: The file or directory path.
        :type path: str
        :param x_ms_lease_duration: The lease duration is required to acquire
         a lease, and specifies the duration of the lease in seconds.  The
         lease duration must be between 15 and 60 seconds or -1 for infinite
         lease.
        :type x_ms_lease_duration: int
        :param x_ms_lease_break_period: The lease break period duration is
         optional to break a lease, and  specifies the break period of the
         lease in seconds.  The lease break  duration must be between 0 and 60
         seconds.
        :type x_ms_lease_break_period: int
        :param x_ms_lease_id: Required when "x-ms-lease-action" is "renew",
         "change" or "release". For the renew and release actions, this must
         match the current lease ID.
        :type x_ms_lease_id: str
        :param x_ms_proposed_lease_id: Required when "x-ms-lease-action" is
         "acquire" or "change".  A lease will be acquired with this lease ID if
         the operation is successful.
        :type x_ms_proposed_lease_id: str
        :param if_match: Optional.  An ETag value. Specify this header to
         perform the operation only if the resource's ETag matches the value
         specified. The ETag must be specified in quotes.
        :type if_match: str
        :param if_none_match: Optional.  An ETag value or the special wildcard
         ("*") value. Specify this header to perform the operation only if the
         resource's ETag does not match the value specified. The ETag must be
         specified in quotes.
        :type if_none_match: str
        :param if_modified_since: Optional. A date and time value. Specify
         this header to perform the operation only if the resource has been
         modified since the specified date and time.
        :type if_modified_since: str
        :param if_unmodified_since: Optional. A date and time value. Specify
         this header to perform the operation only if the resource has not been
         modified since the specified date and time.
        :type if_unmodified_since: str
        :param x_ms_client_request_id: A UUID recorded in the analytics logs
         for troubleshooting and correlation.
        :type x_ms_client_request_id: str
        :param timeout: An optional operation timeout value in seconds. The
         period begins when the request is received by the service. If the
         timeout value elapses before the operation completes, the operation
         fails.
        :type timeout: int
        :param x_ms_date: Specifies the Coordinated Universal Time (UTC) for
         the request.  This is required when using shared key authorization.
        :type x_ms_date: str
        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :return: None or ClientRawResponse if raw=true
        :rtype: None or ~msrest.pipeline.ClientRawResponse
        :raises:
         :class:`DataLakeStorageErrorException<azure.mgmt.media.models.DataLakeStorageErrorException>`
        """
        # Construct URL
        url = self.lease.metadata['url']
        path_format_arguments = {
            'accountName': self._serialize.url("self.config.account_name", self.config.account_name, 'str', skip_quote=True),
            'dnsSuffix': self._serialize.url("self.config.dns_suffix", self.config.dns_suffix, 'str', skip_quote=True),
            'filesystem': self._serialize.url("filesystem", filesystem, 'str', max_length=63, min_length=3, pattern=r'^[a-z0-9](?!.*--)[-a-z0-9]{1,61}[a-z0-9]$'),
            'path': self._serialize.url("path", path, 'str')
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}
        if timeout is not None:
            query_parameters['timeout'] = self._serialize.query("timeout", timeout, 'int', minimum=1)

        # Construct headers
        header_parameters = {}
        header_parameters['Content-Type'] = 'application/json; charset=utf-8'
        if self.config.generate_client_request_id:
            header_parameters['x-ms-client-request-id'] = str(uuid.uuid1())
        if custom_headers:
            header_parameters.update(custom_headers)
        header_parameters['x-ms-lease-action'] = self._serialize.header("x_ms_lease_action", x_ms_lease_action, 'PathLeaseAction')
        if x_ms_lease_duration is not None:
            header_parameters['x-ms-lease-duration'] = self._serialize.header("x_ms_lease_duration", x_ms_lease_duration, 'int')
        if x_ms_lease_break_period is not None:
            header_parameters['x-ms-lease-break-period'] = self._serialize.header("x_ms_lease_break_period", x_ms_lease_break_period, 'int')
        if x_ms_lease_id is not None:
            header_parameters['x-ms-lease-id'] = self._serialize.header("x_ms_lease_id", x_ms_lease_id, 'str', pattern=r'^[{(]?[0-9a-f]{8}[-]?([0-9a-f]{4}[-]?){3}[0-9a-f]{12}[)}]?$')
        if x_ms_proposed_lease_id is not None:
            header_parameters['x-ms-proposed-lease-id'] = self._serialize.header("x_ms_proposed_lease_id", x_ms_proposed_lease_id, 'str', pattern=r'^[{(]?[0-9a-f]{8}[-]?([0-9a-f]{4}[-]?){3}[0-9a-f]{12}[)}]?$')
        if if_match is not None:
            header_parameters['If-Match'] = self._serialize.header("if_match", if_match, 'str')
        if if_none_match is not None:
            header_parameters['If-None-Match'] = self._serialize.header("if_none_match", if_none_match, 'str')
        if if_modified_since is not None:
            header_parameters['If-Modified-Since'] = self._serialize.header("if_modified_since", if_modified_since, 'str')
        if if_unmodified_since is not None:
            header_parameters['If-Unmodified-Since'] = self._serialize.header("if_unmodified_since", if_unmodified_since, 'str')
        if x_ms_client_request_id is not None:
            header_parameters['x-ms-client-request-id'] = self._serialize.header("x_ms_client_request_id", x_ms_client_request_id, 'str', pattern=r'^[{(]?[0-9a-f]{8}[-]?([0-9a-f]{4}[-]?){3}[0-9a-f]{12}[)}]?$')
        if x_ms_date is not None:
            header_parameters['x-ms-date'] = self._serialize.header("x_ms_date", x_ms_date, 'str')
        if self.config.x_ms_version is not None:
            header_parameters['x-ms-version'] = self._serialize.header("self.config.x_ms_version", self.config.x_ms_version, 'str')
        if self.config.accept_language is not None:
            header_parameters['accept-language'] = self._serialize.header("self.config.accept_language", self.config.accept_language, 'str')

        # Construct and send request
        request = self._client.post(url, query_parameters)
        response = self._client.send(request, header_parameters, stream=False, **operation_config)

        if response.status_code not in [200, 201, 202]:
            raise models.DataLakeStorageErrorException(self._deserialize, response)

        if raw:
            client_raw_response = ClientRawResponse(None, response)
            client_raw_response.add_headers({
                'Date': 'str',
                'ETag': 'str',
                'Last-Modified': 'str',
                'x-ms-request-id': 'str',
                'x-ms-version': 'str',
                'x-ms-lease-id': 'str',
                'x-ms-lease-time': 'str',
            })
            return client_raw_response
    lease.metadata = {'url': '/{filesystem}/{path}'}

    def read(
            self, filesystem, path, range=None, if_match=None, if_none_match=None, if_modified_since=None, if_unmodified_since=None, x_ms_client_request_id=None, timeout=None, x_ms_date=None, custom_headers=None, raw=False, callback=None, **operation_config):
        """Read File.

        Read the contents of a file.  For read operations, range requests are
        supported. This operation supports conditional HTTP requests.  For more
        information, see [Specifying Conditional Headers for Blob Service
        Operations](https://docs.microsoft.com/en-us/rest/api/storageservices/specifying-conditional-headers-for-blob-service-operations).

        :param filesystem: The filesystem identifier.
        :type filesystem: str
        :param path: The file or directory path.
        :type path: str
        :param range: The HTTP Range request header specifies one or more byte
         ranges of the resource to be retrieved.
        :type range: str
        :param if_match: Optional.  An ETag value. Specify this header to
         perform the operation only if the resource's ETag matches the value
         specified. The ETag must be specified in quotes.
        :type if_match: str
        :param if_none_match: Optional.  An ETag value or the special wildcard
         ("*") value. Specify this header to perform the operation only if the
         resource's ETag does not match the value specified. The ETag must be
         specified in quotes.
        :type if_none_match: str
        :param if_modified_since: Optional. A date and time value. Specify
         this header to perform the operation only if the resource has been
         modified since the specified date and time.
        :type if_modified_since: str
        :param if_unmodified_since: Optional. A date and time value. Specify
         this header to perform the operation only if the resource has not been
         modified since the specified date and time.
        :type if_unmodified_since: str
        :param x_ms_client_request_id: A UUID recorded in the analytics logs
         for troubleshooting and correlation.
        :type x_ms_client_request_id: str
        :param timeout: An optional operation timeout value in seconds. The
         period begins when the request is received by the service. If the
         timeout value elapses before the operation completes, the operation
         fails.
        :type timeout: int
        :param x_ms_date: Specifies the Coordinated Universal Time (UTC) for
         the request.  This is required when using shared key authorization.
        :type x_ms_date: str
        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param callback: When specified, will be called with each chunk of
         data that is streamed. The callback should take two arguments, the
         bytes of the current chunk of data and the response object. If the
         data is uploading, response will be None.
        :type callback: Callable[Bytes, response=None]
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :return: object or ClientRawResponse if raw=true
        :rtype: Generator or ~msrest.pipeline.ClientRawResponse
        :raises:
         :class:`DataLakeStorageErrorException<azure.mgmt.media.models.DataLakeStorageErrorException>`
        """
        # Construct URL
        url = self.read.metadata['url']
        path_format_arguments = {
            'accountName': self._serialize.url("self.config.account_name", self.config.account_name, 'str', skip_quote=True),
            'dnsSuffix': self._serialize.url("self.config.dns_suffix", self.config.dns_suffix, 'str', skip_quote=True),
            'filesystem': self._serialize.url("filesystem", filesystem, 'str', max_length=63, min_length=3, pattern=r'^[a-z0-9](?!.*--)[-a-z0-9]{1,61}[a-z0-9]$'),
            'path': self._serialize.url("path", path, 'str')
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}
        if timeout is not None:
            query_parameters['timeout'] = self._serialize.query("timeout", timeout, 'int', minimum=1)

        # Construct headers
        header_parameters = {}
        header_parameters['Content-Type'] = 'application/json; charset=utf-8'
        if self.config.generate_client_request_id:
            header_parameters['x-ms-client-request-id'] = str(uuid.uuid1())
        if custom_headers:
            header_parameters.update(custom_headers)
        if range is not None:
            header_parameters['Range'] = self._serialize.header("range", range, 'str')
        if if_match is not None:
            header_parameters['If-Match'] = self._serialize.header("if_match", if_match, 'str')
        if if_none_match is not None:
            header_parameters['If-None-Match'] = self._serialize.header("if_none_match", if_none_match, 'str')
        if if_modified_since is not None:
            header_parameters['If-Modified-Since'] = self._serialize.header("if_modified_since", if_modified_since, 'str')
        if if_unmodified_since is not None:
            header_parameters['If-Unmodified-Since'] = self._serialize.header("if_unmodified_since", if_unmodified_since, 'str')
        if x_ms_client_request_id is not None:
            header_parameters['x-ms-client-request-id'] = self._serialize.header("x_ms_client_request_id", x_ms_client_request_id, 'str', pattern=r'^[{(]?[0-9a-f]{8}[-]?([0-9a-f]{4}[-]?){3}[0-9a-f]{12}[)}]?$')
        if x_ms_date is not None:
            header_parameters['x-ms-date'] = self._serialize.header("x_ms_date", x_ms_date, 'str')
        if self.config.x_ms_version is not None:
            header_parameters['x-ms-version'] = self._serialize.header("self.config.x_ms_version", self.config.x_ms_version, 'str')
        if self.config.accept_language is not None:
            header_parameters['accept-language'] = self._serialize.header("self.config.accept_language", self.config.accept_language, 'str')

        # Construct and send request
        request = self._client.get(url, query_parameters)
        response = self._client.send(request, header_parameters, stream=True, **operation_config)

        if response.status_code not in [200, 206]:
            raise models.DataLakeStorageErrorException(self._deserialize, response)

        deserialized = None
        header_dict = {}

        if response.status_code == 200:
            deserialized = self._client.stream_download(response, callback)
            header_dict = {
                'Accept-Ranges': 'str',
                'Cache-Control': 'str',
                'Content-Disposition': 'str',
                'Content-Encoding': 'str',
                'Content-Language': 'str',
                'Content-Length': 'str',
                'Content-Range': 'str',
                'Content-Type': 'str',
                'Date': 'str',
                'ETag': 'str',
                'Last-Modified': 'str',
                'x-ms-request-id': 'str',
                'x-ms-version': 'str',
                'x-ms-resource-type': 'str',
                'x-ms-properties': 'str',
                'x-ms-lease-duration': 'str',
                'x-ms-lease-state': 'str',
                'x-ms-lease-status': 'str',
            }
        if response.status_code == 206:
            deserialized = self._client.stream_download(response, callback)
            header_dict = {
                'Accept-Ranges': 'str',
                'Cache-Control': 'str',
                'Content-Disposition': 'str',
                'Content-Encoding': 'str',
                'Content-Language': 'str',
                'Content-Length': 'str',
                'Content-Range': 'str',
                'Content-Type': 'str',
                'Date': 'str',
                'ETag': 'str',
                'Last-Modified': 'str',
                'x-ms-request-id': 'str',
                'x-ms-version': 'str',
                'x-ms-resource-type': 'str',
                'x-ms-properties': 'str',
                'x-ms-lease-duration': 'str',
                'x-ms-lease-state': 'str',
                'x-ms-lease-status': 'str',
            }

        if raw:
            client_raw_response = ClientRawResponse(deserialized, response)
            client_raw_response.add_headers(header_dict)
            return client_raw_response

        return deserialized
    read.metadata = {'url': '/{filesystem}/{path}'}

    def get_properties(
            self, filesystem, path, action=None, if_match=None, if_none_match=None, if_modified_since=None, if_unmodified_since=None, x_ms_client_request_id=None, timeout=None, x_ms_date=None, custom_headers=None, raw=False, **operation_config):
        """Get Properties | Get Access Control List.

        Get the properties for a file or directory, and optionally include the
        access control list.  This operation supports conditional HTTP
        requests.  For more information, see [Specifying Conditional Headers
        for Blob Service
        Operations](https://docs.microsoft.com/en-us/rest/api/storageservices/specifying-conditional-headers-for-blob-service-operations).

        :param filesystem: The filesystem identifier.
        :type filesystem: str
        :param path: The file or directory path.
        :type path: str
        :param action: Optional. If the value is "getAccessControl" the access
         control list is returned in the response headers (Hierarchical
         Namespace must be enabled for the account). Possible values include:
         'getAccessControl'
        :type action: str or ~azure.mgmt.media.models.PathGetPropertiesAction
        :param if_match: Optional.  An ETag value. Specify this header to
         perform the operation only if the resource's ETag matches the value
         specified. The ETag must be specified in quotes.
        :type if_match: str
        :param if_none_match: Optional.  An ETag value or the special wildcard
         ("*") value. Specify this header to perform the operation only if the
         resource's ETag does not match the value specified. The ETag must be
         specified in quotes.
        :type if_none_match: str
        :param if_modified_since: Optional. A date and time value. Specify
         this header to perform the operation only if the resource has been
         modified since the specified date and time.
        :type if_modified_since: str
        :param if_unmodified_since: Optional. A date and time value. Specify
         this header to perform the operation only if the resource has not been
         modified since the specified date and time.
        :type if_unmodified_since: str
        :param x_ms_client_request_id: A UUID recorded in the analytics logs
         for troubleshooting and correlation.
        :type x_ms_client_request_id: str
        :param timeout: An optional operation timeout value in seconds. The
         period begins when the request is received by the service. If the
         timeout value elapses before the operation completes, the operation
         fails.
        :type timeout: int
        :param x_ms_date: Specifies the Coordinated Universal Time (UTC) for
         the request.  This is required when using shared key authorization.
        :type x_ms_date: str
        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :return: None or ClientRawResponse if raw=true
        :rtype: None or ~msrest.pipeline.ClientRawResponse
        :raises:
         :class:`DataLakeStorageErrorException<azure.mgmt.media.models.DataLakeStorageErrorException>`
        """
        # Construct URL
        url = self.get_properties.metadata['url']
        path_format_arguments = {
            'accountName': self._serialize.url("self.config.account_name", self.config.account_name, 'str', skip_quote=True),
            'dnsSuffix': self._serialize.url("self.config.dns_suffix", self.config.dns_suffix, 'str', skip_quote=True),
            'filesystem': self._serialize.url("filesystem", filesystem, 'str', max_length=63, min_length=3, pattern=r'^[a-z0-9](?!.*--)[-a-z0-9]{1,61}[a-z0-9]$'),
            'path': self._serialize.url("path", path, 'str')
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}
        if action is not None:
            query_parameters['action'] = self._serialize.query("action", action, 'PathGetPropertiesAction')
        if timeout is not None:
            query_parameters['timeout'] = self._serialize.query("timeout", timeout, 'int', minimum=1)

        # Construct headers
        header_parameters = {}
        header_parameters['Content-Type'] = 'application/json; charset=utf-8'
        if self.config.generate_client_request_id:
            header_parameters['x-ms-client-request-id'] = str(uuid.uuid1())
        if custom_headers:
            header_parameters.update(custom_headers)
        if if_match is not None:
            header_parameters['If-Match'] = self._serialize.header("if_match", if_match, 'str')
        if if_none_match is not None:
            header_parameters['If-None-Match'] = self._serialize.header("if_none_match", if_none_match, 'str')
        if if_modified_since is not None:
            header_parameters['If-Modified-Since'] = self._serialize.header("if_modified_since", if_modified_since, 'str')
        if if_unmodified_since is not None:
            header_parameters['If-Unmodified-Since'] = self._serialize.header("if_unmodified_since", if_unmodified_since, 'str')
        if x_ms_client_request_id is not None:
            header_parameters['x-ms-client-request-id'] = self._serialize.header("x_ms_client_request_id", x_ms_client_request_id, 'str', pattern=r'^[{(]?[0-9a-f]{8}[-]?([0-9a-f]{4}[-]?){3}[0-9a-f]{12}[)}]?$')
        if x_ms_date is not None:
            header_parameters['x-ms-date'] = self._serialize.header("x_ms_date", x_ms_date, 'str')
        if self.config.x_ms_version is not None:
            header_parameters['x-ms-version'] = self._serialize.header("self.config.x_ms_version", self.config.x_ms_version, 'str')
        if self.config.accept_language is not None:
            header_parameters['accept-language'] = self._serialize.header("self.config.accept_language", self.config.accept_language, 'str')

        # Construct and send request
        request = self._client.head(url, query_parameters)
        response = self._client.send(request, header_parameters, stream=False, **operation_config)

        if response.status_code not in [200]:
            raise models.DataLakeStorageErrorException(self._deserialize, response)

        if raw:
            client_raw_response = ClientRawResponse(None, response)
            client_raw_response.add_headers({
                'Accept-Ranges': 'str',
                'Cache-Control': 'str',
                'Content-Disposition': 'str',
                'Content-Encoding': 'str',
                'Content-Language': 'str',
                'Content-Length': 'str',
                'Content-Range': 'str',
                'Content-Type': 'str',
                'Date': 'str',
                'ETag': 'str',
                'Last-Modified': 'str',
                'x-ms-request-id': 'str',
                'x-ms-version': 'str',
                'x-ms-resource-type': 'str',
                'x-ms-properties': 'str',
                'x-ms-owner': 'str',
                'x-ms-group': 'str',
                'x-ms-permissions': 'str',
                'x-ms-acl': 'str',
                'x-ms-lease-duration': 'str',
                'x-ms-lease-state': 'str',
                'x-ms-lease-status': 'str',
            })
            return client_raw_response
    get_properties.metadata = {'url': '/{filesystem}/{path}'}

    def delete(
            self, filesystem, path, recursive=None, continuation=None, x_ms_lease_id=None, if_match=None, if_none_match=None, if_modified_since=None, if_unmodified_since=None, x_ms_client_request_id=None, timeout=None, x_ms_date=None, custom_headers=None, raw=False, **operation_config):
        """Delete File | Delete Directory.

        Delete the file or directory. This operation supports conditional HTTP
        requests.  For more information, see [Specifying Conditional Headers
        for Blob Service
        Operations](https://docs.microsoft.com/en-us/rest/api/storageservices/specifying-conditional-headers-for-blob-service-operations).

        :param filesystem: The filesystem identifier.
        :type filesystem: str
        :param path: The file or directory path.
        :type path: str
        :param recursive: Required and valid only when the resource is a
         directory.  If "true", all paths beneath the directory will be
         deleted. If "false" and the directory is non-empty, an error occurs.
        :type recursive: bool
        :param continuation: Optional.  When deleting a directory, the number
         of paths that are deleted with each invocation is limited.  If the
         number of paths to be deleted exceeds this limit, a continuation token
         is returned in this response header.  When a continuation token is
         returned in the response, it must be specified in a subsequent
         invocation of the delete operation to continue deleting the directory.
        :type continuation: str
        :param x_ms_lease_id: The lease ID must be specified if there is an
         active lease.
        :type x_ms_lease_id: str
        :param if_match: Optional.  An ETag value. Specify this header to
         perform the operation only if the resource's ETag matches the value
         specified. The ETag must be specified in quotes.
        :type if_match: str
        :param if_none_match: Optional.  An ETag value or the special wildcard
         ("*") value. Specify this header to perform the operation only if the
         resource's ETag does not match the value specified. The ETag must be
         specified in quotes.
        :type if_none_match: str
        :param if_modified_since: Optional. A date and time value. Specify
         this header to perform the operation only if the resource has been
         modified since the specified date and time.
        :type if_modified_since: str
        :param if_unmodified_since: Optional. A date and time value. Specify
         this header to perform the operation only if the resource has not been
         modified since the specified date and time.
        :type if_unmodified_since: str
        :param x_ms_client_request_id: A UUID recorded in the analytics logs
         for troubleshooting and correlation.
        :type x_ms_client_request_id: str
        :param timeout: An optional operation timeout value in seconds. The
         period begins when the request is received by the service. If the
         timeout value elapses before the operation completes, the operation
         fails.
        :type timeout: int
        :param x_ms_date: Specifies the Coordinated Universal Time (UTC) for
         the request.  This is required when using shared key authorization.
        :type x_ms_date: str
        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :return: None or ClientRawResponse if raw=true
        :rtype: None or ~msrest.pipeline.ClientRawResponse
        :raises:
         :class:`DataLakeStorageErrorException<azure.mgmt.media.models.DataLakeStorageErrorException>`
        """
        # Construct URL
        url = self.delete.metadata['url']
        path_format_arguments = {
            'accountName': self._serialize.url("self.config.account_name", self.config.account_name, 'str', skip_quote=True),
            'dnsSuffix': self._serialize.url("self.config.dns_suffix", self.config.dns_suffix, 'str', skip_quote=True),
            'filesystem': self._serialize.url("filesystem", filesystem, 'str', max_length=63, min_length=3, pattern=r'^[a-z0-9](?!.*--)[-a-z0-9]{1,61}[a-z0-9]$'),
            'path': self._serialize.url("path", path, 'str')
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}
        if recursive is not None:
            query_parameters['recursive'] = self._serialize.query("recursive", recursive, 'bool')
        if continuation is not None:
            query_parameters['continuation'] = self._serialize.query("continuation", continuation, 'str')
        if timeout is not None:
            query_parameters['timeout'] = self._serialize.query("timeout", timeout, 'int', minimum=1)

        # Construct headers
        header_parameters = {}
        header_parameters['Content-Type'] = 'application/json; charset=utf-8'
        if self.config.generate_client_request_id:
            header_parameters['x-ms-client-request-id'] = str(uuid.uuid1())
        if custom_headers:
            header_parameters.update(custom_headers)
        if x_ms_lease_id is not None:
            header_parameters['x-ms-lease-id'] = self._serialize.header("x_ms_lease_id", x_ms_lease_id, 'str', pattern=r'^[{(]?[0-9a-f]{8}[-]?([0-9a-f]{4}[-]?){3}[0-9a-f]{12}[)}]?$')
        if if_match is not None:
            header_parameters['If-Match'] = self._serialize.header("if_match", if_match, 'str')
        if if_none_match is not None:
            header_parameters['If-None-Match'] = self._serialize.header("if_none_match", if_none_match, 'str')
        if if_modified_since is not None:
            header_parameters['If-Modified-Since'] = self._serialize.header("if_modified_since", if_modified_since, 'str')
        if if_unmodified_since is not None:
            header_parameters['If-Unmodified-Since'] = self._serialize.header("if_unmodified_since", if_unmodified_since, 'str')
        if x_ms_client_request_id is not None:
            header_parameters['x-ms-client-request-id'] = self._serialize.header("x_ms_client_request_id", x_ms_client_request_id, 'str', pattern=r'^[{(]?[0-9a-f]{8}[-]?([0-9a-f]{4}[-]?){3}[0-9a-f]{12}[)}]?$')
        if x_ms_date is not None:
            header_parameters['x-ms-date'] = self._serialize.header("x_ms_date", x_ms_date, 'str')
        if self.config.x_ms_version is not None:
            header_parameters['x-ms-version'] = self._serialize.header("self.config.x_ms_version", self.config.x_ms_version, 'str')
        if self.config.accept_language is not None:
            header_parameters['accept-language'] = self._serialize.header("self.config.accept_language", self.config.accept_language, 'str')

        # Construct and send request
        request = self._client.delete(url, query_parameters)
        response = self._client.send(request, header_parameters, stream=False, **operation_config)

        if response.status_code not in [200]:
            raise models.DataLakeStorageErrorException(self._deserialize, response)

        if raw:
            client_raw_response = ClientRawResponse(None, response)
            client_raw_response.add_headers({
                'Date': 'str',
                'x-ms-request-id': 'str',
                'x-ms-version': 'str',
                'x-ms-continuation': 'str',
            })
            return client_raw_response
    delete.metadata = {'url': '/{filesystem}/{path}'}
