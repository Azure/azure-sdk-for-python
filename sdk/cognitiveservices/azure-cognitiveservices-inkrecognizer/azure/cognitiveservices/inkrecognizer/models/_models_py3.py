# coding=utf-8
# --------------------------------------------------------------------------
# Copyright (c) Microsoft Corporation. All rights reserved.
# Licensed under the MIT License. See License.txt in the project root for
# license information.
#
# Code generated by Microsoft (R) AutoRest Code Generator.
# Changes may cause incorrect behavior and will be lost if the code is
# regenerated.
# --------------------------------------------------------------------------

from msrest.serialization import Model
from msrest.exceptions import HttpOperationError


class AlternatePatternItem(Model):
    """AlternatePatternItem.

    All required parameters must be populated in order to send to Azure.

    :param category: Required. Possible values include: 'inkDrawing',
     'inkBullet', 'inkWord', 'unknown'
    :type category: str or ~azure.cognitiveservices.inkrecognizer.models.Leaf
    :param points: Array of point objects that represent points that are
     relevant to the type of recognition unit. For example, for leaf node of
     inkDrawing category that represents a triangle, points would include the
     x,y coordinates of the vertices of the recognized triangle. The points
     represent the coordinates of points used to create the perfectly drawn
     shape that is closest to the original input. They may not exactly match.
    :type points:
     list[~azure.cognitiveservices.inkrecognizer.models.PointDetailsPattern]
    :param rotation_angle: The angular orientation of an object relative to
     the horizontal axis
    :type rotation_angle: float
    :param confidence: A number between 0 and 1 which indicates the confidence
     level in the result
    :type confidence: float
    :param recognized_string: Required. The recognized string from an inkWord
     or the name of a recognized shape in an inkDrawing object
    :type recognized_string: str
    """

    _validation = {
        'category': {'required': True},
        'recognized_string': {'required': True},
    }

    _attribute_map = {
        'category': {'key': 'category', 'type': 'str'},
        'points': {'key': 'points', 'type': '[PointDetailsPattern]'},
        'rotation_angle': {'key': 'rotationAngle', 'type': 'float'},
        'confidence': {'key': 'confidence', 'type': 'float'},
        'recognized_string': {'key': 'recognizedString', 'type': 'str'},
    }

    def __init__(self, *, category, recognized_string: str, points=None, rotation_angle: float=None, confidence: float=None, **kwargs) -> None:
        super(AlternatePatternItem, self).__init__(**kwargs)
        self.category = category
        self.points = points
        self.rotation_angle = rotation_angle
        self.confidence = confidence
        self.recognized_string = recognized_string


class AnalysisRequest(Model):
    """This shows the expected contents of a request.

    All required parameters must be populated in order to send to Azure.

    :param application_type: This describes the domain of the client
     application. Possible values include: 'drawing', 'writing', 'mixed'
    :type application_type: str or
     ~azure.cognitiveservices.inkrecognizer.models.Application
    :param input_device_kind: This identifies the kind of device used as the
     writing instrument. Possible values include: 'digitizer', 'pen',
     'lightPen', 'touchScreen', 'touchPad', 'whiteBoard', '3dDigitizer',
     'stereoPlotter', 'articulatedArm', 'armature'
    :type input_device_kind: str or
     ~azure.cognitiveservices.inkrecognizer.models.InputDevice
    :param unit: This is the physical unit of the ink strokes. It is up to the
     application developer to decide how to convert the device specific units
     to physical units before calling the service. The conversion factor can be
     different based on the type of the device used. Possible values include:
     'mm', 'cm', 'in'
    :type unit: str or ~azure.cognitiveservices.inkrecognizer.models.Unit
    :param unit_multiple:  This is a scaling factor to be applied to the point
     coordinates when interpreting them in the physical units specified.
    :type unit_multiple: float
    :param language: Required. The IETF BCP 47 language code (for ex. en-US,
     en-GB, hi-IN etc.) of the expected language for the handwritten content in
     the ink strokes. The response will include results from this language.
    :type language: str
    :param ink_point_value_attributes:
    :type ink_point_value_attributes:
     list[~azure.cognitiveservices.inkrecognizer.models.InkPointValueAttribute]
    :param strokes: Required. This is the array of strokes sent for
     recognition. Best results are produced when the order of strokes added in
     the array matches the order in which the user created them. Changing the
     stroke order may produce unexpected results.
    :type strokes: list[~azure.cognitiveservices.inkrecognizer.models.Stroke]
    """

    _validation = {
        'language': {'required': True},
        'strokes': {'required': True},
    }

    _attribute_map = {
        'application_type': {'key': 'applicationType', 'type': 'str'},
        'input_device_kind': {'key': 'inputDeviceKind', 'type': 'str'},
        'unit': {'key': 'unit', 'type': 'str'},
        'unit_multiple': {'key': 'unitMultiple', 'type': 'float'},
        'language': {'key': 'language', 'type': 'str'},
        'ink_point_value_attributes': {'key': 'inkPointValueAttributes', 'type': '[InkPointValueAttribute]'},
        'strokes': {'key': 'strokes', 'type': '[Stroke]'},
    }

    def __init__(self, *, language: str, strokes, application_type=None, input_device_kind=None, unit=None, unit_multiple: float=None, ink_point_value_attributes=None, **kwargs) -> None:
        super(AnalysisRequest, self).__init__(**kwargs)
        self.application_type = application_type
        self.input_device_kind = input_device_kind
        self.unit = unit
        self.unit_multiple = unit_multiple
        self.language = language
        self.ink_point_value_attributes = ink_point_value_attributes
        self.strokes = strokes


class AnalysisResponse(Model):
    """This shows the expected contents of a response from the service.

    All required parameters must be populated in order to send to Azure.

    :param unit: This is the physical unit of the ink strokes. It is up to the
     application developer to decide how to convert the device specific units
     to physical units before calling the service. The conversion factor can be
     different based on the type of the device used. Possible values include:
     'mm', 'cm', 'in'
    :type unit: str or ~azure.cognitiveservices.inkrecognizer.models.Unit
    :param unit_multiple:  This is a scaling factor to be applied to the point
     coordinates when interpreting them in the physical units specified.
    :type unit_multiple: float
    :param language: This is the language used for recognizing handwriting
     from the ink strokes in the request.
    :type language: str
    :param recognition_units: Required.
    :type recognition_units:
     list[~azure.cognitiveservices.inkrecognizer.models.RecognitionUnitItem]
    """

    _validation = {
        'recognition_units': {'required': True},
    }

    _attribute_map = {
        'unit': {'key': 'unit', 'type': 'str'},
        'unit_multiple': {'key': 'unitMultiple', 'type': 'float'},
        'language': {'key': 'language', 'type': 'str'},
        'recognition_units': {'key': 'recognitionUnits', 'type': '[RecognitionUnitItem]'},
    }

    def __init__(self, *, recognition_units, unit=None, unit_multiple: float=None, language: str=None, **kwargs) -> None:
        super(AnalysisResponse, self).__init__(**kwargs)
        self.unit = unit
        self.unit_multiple = unit_multiple
        self.language = language
        self.recognition_units = recognition_units


class DrawingAttributesPattern(Model):
    """The properties to use when rendering ink.

    :param width: The width of the stylus used to draw the stroke
    :type width: float
    :param color: This shows the components of the color in rgba format
    :type color:
     ~azure.cognitiveservices.inkrecognizer.models.DrawingAttributesPatternColor
    :param height: The height of the stylus used to draw the stroke
    :type height: float
    :param fit_to_curve:  This indicates whether Bezier smoothing is used to
     render the stroke
    :type fit_to_curve: bool
    :param raster_op: Possible values include: 'noOperation', 'copyPen',
     'maskPen'
    :type raster_op: str or
     ~azure.cognitiveservices.inkrecognizer.models.RasterOp
    :param ignore_pressure:  This indicates whether the thickness of a
     rendered Stroke changes according the amount of pressure applied.
    :type ignore_pressure: bool
    :param tip: This specifies the tip to be used to draw a stroke. Possible
     values include: 'ellipse', 'rectangle'
    :type tip: str or ~azure.cognitiveservices.inkrecognizer.models.Tip
    """

    _attribute_map = {
        'width': {'key': 'width', 'type': 'float'},
        'color': {'key': 'color', 'type': 'DrawingAttributesPatternColor'},
        'height': {'key': 'height', 'type': 'float'},
        'fit_to_curve': {'key': 'fitToCurve', 'type': 'bool'},
        'raster_op': {'key': 'rasterOp', 'type': 'str'},
        'ignore_pressure': {'key': 'ignorePressure', 'type': 'bool'},
        'tip': {'key': 'tip', 'type': 'str'},
    }

    def __init__(self, *, width: float=None, color=None, height: float=None, fit_to_curve: bool=None, raster_op=None, ignore_pressure: bool=None, tip=None, **kwargs) -> None:
        super(DrawingAttributesPattern, self).__init__(**kwargs)
        self.width = width
        self.color = color
        self.height = height
        self.fit_to_curve = fit_to_curve
        self.raster_op = raster_op
        self.ignore_pressure = ignore_pressure
        self.tip = tip


class DrawingAttributesPatternColor(Model):
    """This shows the components of the color in rgba format.

    :param r: The red component of the color
    :type r: float
    :param g: The green component of the color
    :type g: float
    :param b: The blue component of the color
    :type b: float
    :param a: The alpha component of the color
    :type a: float
    """

    _attribute_map = {
        'r': {'key': 'r', 'type': 'float'},
        'g': {'key': 'g', 'type': 'float'},
        'b': {'key': 'b', 'type': 'float'},
        'a': {'key': 'a', 'type': 'float'},
    }

    def __init__(self, *, r: float=None, g: float=None, b: float=None, a: float=None, **kwargs) -> None:
        super(DrawingAttributesPatternColor, self).__init__(**kwargs)
        self.r = r
        self.g = g
        self.b = b
        self.a = a


class ErrorModel(Model):
    """ErrorModel.

    All required parameters must be populated in order to send to Azure.

    :param code: Required. This represents the error code
    :type code: str
    :param message: Required. This represents the error message
    :type message: str
    :param target: This represents the target of the error message
    :type target: str
    :param details: This gives details of the reason(s) for the error
    :type details:
     list[~azure.cognitiveservices.inkrecognizer.models.ErrorModelDetailsItem]
    """

    _validation = {
        'code': {'required': True},
        'message': {'required': True},
    }

    _attribute_map = {
        'code': {'key': 'code', 'type': 'str'},
        'message': {'key': 'message', 'type': 'str'},
        'target': {'key': 'target', 'type': 'str'},
        'details': {'key': 'details', 'type': '[ErrorModelDetailsItem]'},
    }

    def __init__(self, *, code: str, message: str, target: str=None, details=None, **kwargs) -> None:
        super(ErrorModel, self).__init__(**kwargs)
        self.code = code
        self.message = message
        self.target = target
        self.details = details


class ErrorModelException(HttpOperationError):
    """Server responsed with exception of type: 'ErrorModel'.

    :param deserialize: A deserializer
    :param response: Server response to be deserialized.
    """

    def __init__(self, deserialize, response, *args):

        super(ErrorModelException, self).__init__(deserialize, response, 'ErrorModel', *args)


class ErrorModelDetailsItem(Model):
    """ErrorModelDetailsItem.

    :param code: This represents the error code
    :type code: str
    :param message: This represents the error message
    :type message: str
    :param target: This represents the target of the error message
    :type target: str
    """

    _attribute_map = {
        'code': {'key': 'code', 'type': 'str'},
        'message': {'key': 'message', 'type': 'str'},
        'target': {'key': 'target', 'type': 'str'},
    }

    def __init__(self, *, code: str=None, message: str=None, target: str=None, **kwargs) -> None:
        super(ErrorModelDetailsItem, self).__init__(**kwargs)
        self.code = code
        self.message = message
        self.target = target


class InkPoint(Model):
    """An object containing the properties of an point in the path of an ink
    stroke. The main properties are the x and y values. Other include tip
    pressure, x tilt etc. For the coordinate values, it is recommended to have
    a precision of 8 digits after the decimal to obtain most accurate
    recognition results. The origin (0,0) of the canvas is assumed to be at the
    top left corner of the canvas.

    All required parameters must be populated in order to send to Azure.

    :param x: Required. The x coordinate of the pen location on the writing
     surface.
    :type x: float
    :param y: Required. The y coordinate of the pen location on the writing
     surface.
    :type y: float
    :param z: The z coordinate of the pen location on the writing space. This
     may not be used for recognition.
    :type z: float
    :param tip_pressure: The force exerted against the tablet surface by the
     transducer, typically a stylus. This may not be used for recognition.
    :type tip_pressure: float
    :param barrel_pressure: The force exerted directly by the user on a
     transducer sensor, such as a pressure-sensitive button on the barrel of a
     stylus. This may not be used for recognition.
    :type barrel_pressure: float
    :param timestamp: The time relative to the absolute time the transducer
     last became active. This may not be used for recognition.
    :type timestamp: float
    :param x_tilt: The plane angle between the Y-Z plane and the plane
     containing the transducer axis and the Y axis. This may not be used for
     recognition.
    :type x_tilt: float
    :param y_tilt: The angle between the X-Z and transducer-X planes. A
     positive Y Tilt is toward the user. This may not be used for recognition.
    :type y_tilt: float
    :param width: The width of the tip of the writing instrument. This is used
     by touch screen devices to report the width of the finger contact on the
     writing surface. This may not be used for recognition.
    :type width: float
    :param height: The height of the tip of the writing instrument. This is
     used by touch screen devices to report the height of the finger contact on
     the writing surface. This may not be used for recognition.
    :type height: float
    :param tip_switch: A switch located on the tip of a stylus indicating
     contact of the stylus with a surface. This may not be used for
     recognition.
    :type tip_switch: bool
    :param inverted: A value that indicates that the currently sensed position
     originates from the end of a stylus opposite the tip switch. This may not
     be used for recognition.
    :type inverted: bool
    :param barrel_switch: A non-tip button located on the barrel of a stylus.
     Its function is typically mapped to a system secondary button. This may
     not be used for recognition.
    :type barrel_switch: bool
    :param eraser: The control is used for erasing objects. It is typically
     located opposite the writing end of a stylus. This may not be used for
     recognition.
    :type eraser: bool
    :param secondary_tip: A secondary switch used in conjunction with the tip
     switch to indicate pressure above a certain threshold applied with the
     stylus. This may not be used for recognition.
    :type secondary_tip: bool
    """

    _validation = {
        'x': {'required': True},
        'y': {'required': True},
    }

    _attribute_map = {
        'x': {'key': 'x', 'type': 'float'},
        'y': {'key': 'y', 'type': 'float'},
        'z': {'key': 'z', 'type': 'float'},
        'tip_pressure': {'key': 'tipPressure', 'type': 'float'},
        'barrel_pressure': {'key': 'barrelPressure', 'type': 'float'},
        'timestamp': {'key': 'timestamp', 'type': 'float'},
        'x_tilt': {'key': 'xTilt', 'type': 'float'},
        'y_tilt': {'key': 'yTilt', 'type': 'float'},
        'width': {'key': 'width', 'type': 'float'},
        'height': {'key': 'height', 'type': 'float'},
        'tip_switch': {'key': 'tipSwitch', 'type': 'bool'},
        'inverted': {'key': 'inverted', 'type': 'bool'},
        'barrel_switch': {'key': 'barrelSwitch', 'type': 'bool'},
        'eraser': {'key': 'eraser', 'type': 'bool'},
        'secondary_tip': {'key': 'secondaryTip', 'type': 'bool'},
    }

    def __init__(self, *, x: float, y: float, z: float=None, tip_pressure: float=None, barrel_pressure: float=None, timestamp: float=None, x_tilt: float=None, y_tilt: float=None, width: float=None, height: float=None, tip_switch: bool=None, inverted: bool=None, barrel_switch: bool=None, eraser: bool=None, secondary_tip: bool=None, **kwargs) -> None:
        super(InkPoint, self).__init__(**kwargs)
        self.x = x
        self.y = y
        self.z = z
        self.tip_pressure = tip_pressure
        self.barrel_pressure = barrel_pressure
        self.timestamp = timestamp
        self.x_tilt = x_tilt
        self.y_tilt = y_tilt
        self.width = width
        self.height = height
        self.tip_switch = tip_switch
        self.inverted = inverted
        self.barrel_switch = barrel_switch
        self.eraser = eraser
        self.secondary_tip = secondary_tip


class InkPointValueAttribute(Model):
    """A container for the attributes of a value contained in the ink point
    object.

    :param name: The name of the point attribute.
    :type name: str
    :param logical_minimum: The minimum value for the attribute
    :type logical_minimum: float
    :param logical_maximum: The maximum value for the attribute
    :type logical_maximum: float
    """

    _attribute_map = {
        'name': {'key': 'name', 'type': 'str'},
        'logical_minimum': {'key': 'logicalMinimum', 'type': 'float'},
        'logical_maximum': {'key': 'logicalMaximum', 'type': 'float'},
    }

    def __init__(self, *, name: str=None, logical_minimum: float=None, logical_maximum: float=None, **kwargs) -> None:
        super(InkPointValueAttribute, self).__init__(**kwargs)
        self.name = name
        self.logical_minimum = logical_minimum
        self.logical_maximum = logical_maximum


class PointDetailsPattern(Model):
    """This holds all the properties of one point.

    All required parameters must be populated in order to send to Azure.

    :param x: Required. This represents the x coordinate of the point
    :type x: float
    :param y: Required. This represents the y coordinate of the point
    :type y: float
    """

    _validation = {
        'x': {'required': True},
        'y': {'required': True},
    }

    _attribute_map = {
        'x': {'key': 'x', 'type': 'float'},
        'y': {'key': 'y', 'type': 'float'},
    }

    def __init__(self, *, x: float, y: float, **kwargs) -> None:
        super(PointDetailsPattern, self).__init__(**kwargs)
        self.x = x
        self.y = y


class RecognitionUnitItem(Model):
    """This identifies the recognized entity.

    All required parameters must be populated in order to send to Azure.

    :param id: Required. The identifier of the recognition unit. This id is
     used to indicate parent/child relationship between different recognition
     units.
    :type id: int
    :param category: Required. Possible values include: 'root',
     'writingRegion', 'paragraph', 'line', 'inkBullet', 'inkDrawing',
     'inkWord', 'unknown'
    :type category: str or
     ~azure.cognitiveservices.inkrecognizer.models.Category
    :param alternates:
    :type alternates:
     list[~azure.cognitiveservices.inkrecognizer.models.AlternatePatternItem]
    :param center: The coordinates (x,y) of the center of the recognition
     unit.
    :type center:
     ~azure.cognitiveservices.inkrecognizer.models.PointDetailsPattern
    :param points: Array of point objects that represent points that are
     relevant to the type of recognition unit. For example, for a leaf node of
     inkDrawing category that represents a triangle, points would include the
     x, y coordinates of the vertices of the recognized triangle. The points
     represent the coordinates used to create the perfectly drawn shape that is
     closest to the original input. They may not exactly match.
    :type points:
     list[~azure.cognitiveservices.inkrecognizer.models.PointDetailsPattern]
    :param child_ids: An array of integers representing the identifier of each
     child of the current recognition unit.
    :type child_ids: list[int]
    :param class_property: Required. Possible values include: 'container',
     'leaf'
    :type class_property: str or
     ~azure.cognitiveservices.inkrecognizer.models.enum
    :param parent_id: Required. The id of the parent node in the tree
     structure of the recognition results. parent = 0 indicates that there is
     no dedicated parent node for this unit.
    :type parent_id: int
    :param bounding_rectangle: The bounding rectangle of the recognition unit
     represented by the coordinates of the top left corner (topX,topY) along
     with width and height of the rectangle. Note that this rectangle is not
     rotated. So for  rotated objects such as slanted handwriting, it will
     cover the entire object. The unit will be matched to the one specified in
     the original request (mm by default.)
    :type bounding_rectangle:
     ~azure.cognitiveservices.inkrecognizer.models.RecognitionUnitItemBoundingRectangle
    :param rotated_bounding_rectangle: This is the rotated bounding rectangle
     that covers the entire recognized object along the angle of rotation of
     the object. Note that this is NOT the same as rotating the
     boundingRectangle by the rotation angle.
    :type rotated_bounding_rectangle:
     list[~azure.cognitiveservices.inkrecognizer.models.PointDetailsPattern]
    :param stroke_ids: Required. This is an array of integers representing the
     list of stroke Identifiers from the input request body that belong to this
     recognition unit.
    :type stroke_ids: list[int]
    :param recognized_text: The string contains the text that was recognized.
     It can be an empty string if the recognizer cannot determine the text.
    :type recognized_text: str
    :param confidence: A number between 0 and 1 which indicates the confidence
     level in the result.
    :type confidence: float
    :param rotation_angle: This is the angle at which the unit is rotated in
     degrees with respect to the positive X axis.
    :type rotation_angle: float
    :param recognized_object: Possible values include: 'drawing', 'square',
     'rectangle', 'circle', 'ellipse', 'triangle', 'isoscelesTriangle',
     'equilateralTriangle', 'rightTriangle', 'quadrilateral', 'diamond',
     'trapezoid', 'parallelogram', 'pentagon', 'hexagon', 'blockArrow',
     'heart', 'starSimple', 'starCrossed', 'cloud', 'line', 'curve', 'polyLine'
    :type recognized_object: str or
     ~azure.cognitiveservices.inkrecognizer.models.Shape
    """

    _validation = {
        'id': {'required': True},
        'category': {'required': True},
        'class_property': {'required': True},
        'parent_id': {'required': True},
        'stroke_ids': {'required': True},
    }

    _attribute_map = {
        'id': {'key': 'id', 'type': 'int'},
        'category': {'key': 'category', 'type': 'str'},
        'alternates': {'key': 'alternates', 'type': '[AlternatePatternItem]'},
        'center': {'key': 'center', 'type': 'PointDetailsPattern'},
        'points': {'key': 'points', 'type': '[PointDetailsPattern]'},
        'child_ids': {'key': 'childIds', 'type': '[int]'},
        'class_property': {'key': 'class', 'type': 'str'},
        'parent_id': {'key': 'parentId', 'type': 'int'},
        'bounding_rectangle': {'key': 'boundingRectangle', 'type': 'RecognitionUnitItemBoundingRectangle'},
        'rotated_bounding_rectangle': {'key': 'rotatedBoundingRectangle', 'type': '[PointDetailsPattern]'},
        'stroke_ids': {'key': 'strokeIds', 'type': '[int]'},
        'recognized_text': {'key': 'recognizedText', 'type': 'str'},
        'confidence': {'key': 'confidence', 'type': 'float'},
        'rotation_angle': {'key': 'rotationAngle', 'type': 'float'},
        'recognized_object': {'key': 'recognizedObject', 'type': 'str'},
    }

    def __init__(self, *, id: int, category, class_property, parent_id: int, stroke_ids, alternates=None, center=None, points=None, child_ids=None, bounding_rectangle=None, rotated_bounding_rectangle=None, recognized_text: str=None, confidence: float=None, rotation_angle: float=None, recognized_object=None, **kwargs) -> None:
        super(RecognitionUnitItem, self).__init__(**kwargs)
        self.id = id
        self.category = category
        self.alternates = alternates
        self.center = center
        self.points = points
        self.child_ids = child_ids
        self.class_property = class_property
        self.parent_id = parent_id
        self.bounding_rectangle = bounding_rectangle
        self.rotated_bounding_rectangle = rotated_bounding_rectangle
        self.stroke_ids = stroke_ids
        self.recognized_text = recognized_text
        self.confidence = confidence
        self.rotation_angle = rotation_angle
        self.recognized_object = recognized_object


class RecognitionUnitItemBoundingRectangle(Model):
    """The bounding rectangle of the recognition unit represented by the
    coordinates of the top left corner (topX,topY) along with width and height
    of the rectangle. Note that this rectangle is not rotated. So for  rotated
    objects such as slanted handwriting, it will cover the entire object. The
    unit will be matched to the one specified in the original request (mm by
    default.) .

    :param top_x: This is the top left x coordinate
    :type top_x: float
    :param top_y: This is the top left y coordinate
    :type top_y: float
    :param width: This is width of the bounding rectangle
    :type width: float
    :param height: The is the height of the bounding rectangle
    :type height: float
    """

    _attribute_map = {
        'top_x': {'key': 'topX', 'type': 'float'},
        'top_y': {'key': 'topY', 'type': 'float'},
        'width': {'key': 'width', 'type': 'float'},
        'height': {'key': 'height', 'type': 'float'},
    }

    def __init__(self, *, top_x: float=None, top_y: float=None, width: float=None, height: float=None, **kwargs) -> None:
        super(RecognitionUnitItemBoundingRectangle, self).__init__(**kwargs)
        self.top_x = top_x
        self.top_y = top_y
        self.width = width
        self.height = height


class Stroke(Model):
    """Stroke.

    All required parameters must be populated in order to send to Azure.

    :param id: Required. This is treated as a unique identifier for each
     stroke within a request. If the id is repeated within the same request,
     the service will return an error.
    :type id: int
    :param language: The IETF BCP 47 language code (for ex. en-US, en-GB,
     hi-IN etc.) of the expected language for the handwritten content in this
     stroke. The response will include results from this language.
    :type language: str
    :param points: Required.
    :type points: list[~azure.cognitiveservices.inkrecognizer.models.InkPoint]
    :param drawing_attributes:
    :type drawing_attributes:
     ~azure.cognitiveservices.inkrecognizer.models.DrawingAttributesPattern
    :param kind: This is an optional property which influences the decision
     about what the stroke kind is between inkWriting and inkDrawing. This
     property should be set ONLY if the type of user content is known ahead of
     time. Not setting this value implies the kind is not known ahead of time.
     Kind represents the type of content the stroke is a part of. Possible
     values include: 'inkDrawing', 'inkWriting'
    :type kind: str or ~azure.cognitiveservices.inkrecognizer.models.Kind
    """

    _validation = {
        'id': {'required': True},
        'points': {'required': True},
    }

    _attribute_map = {
        'id': {'key': 'id', 'type': 'int'},
        'language': {'key': 'language', 'type': 'str'},
        'points': {'key': 'points', 'type': '[InkPoint]'},
        'drawing_attributes': {'key': 'drawingAttributes', 'type': 'DrawingAttributesPattern'},
        'kind': {'key': 'kind', 'type': 'str'},
    }

    def __init__(self, *, id: int, points, language: str=None, drawing_attributes=None, kind=None, **kwargs) -> None:
        super(Stroke, self).__init__(**kwargs)
        self.id = id
        self.language = language
        self.points = points
        self.drawing_attributes = drawing_attributes
        self.kind = kind
