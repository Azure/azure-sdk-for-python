# coding=utf-8
# --------------------------------------------------------------------------
# Copyright (c) Microsoft Corporation. All rights reserved.
# Licensed under the MIT License. See License.txt in the project root for
# license information.
#
# Code generated by Microsoft (R) AutoRest Code Generator.
# Changes may cause incorrect behavior and will be lost if the code is
# regenerated.
# --------------------------------------------------------------------------

from msrest.pipeline import ClientRawResponse

from .. import models


class TimeSeriesGroupOperations(object):
    """TimeSeriesGroupOperations operations.

    :param client: Client for service requests.
    :param config: Configuration of service client.
    :param serializer: An object model serializer.
    :param deserializer: An object model deserializer.
    """

    models = models

    def __init__(self, client, config, serializer, deserializer):

        self._client = client
        self._serialize = serializer
        self._deserialize = deserializer

        self.config = config

    def get(
            self, time_series_group_id, custom_headers=None, raw=False, **operation_config):
        """Get meta information of the specified time series group.

        This operation fetches detailed information about the specified time
        series group.

        :param time_series_group_id: Unique id for time series group.
        :type time_series_group_id: str
        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :return: TimeSeriesGroup or ClientRawResponse if raw=true
        :rtype:
         ~azure.cognitiveservices.anomalydetector.models.TimeSeriesGroup or
         ~msrest.pipeline.ClientRawResponse
        :raises:
         :class:`APIErrorException<azure.cognitiveservices.anomalydetector.models.APIErrorException>`
        """
        # Construct URL
        url = self.get.metadata['url']
        path_format_arguments = {
            'Endpoint': self._serialize.url("self.config.endpoint", self.config.endpoint, 'str', skip_quote=True),
            'timeSeriesGroupId': self._serialize.url("time_series_group_id", time_series_group_id, 'str', max_length=64, pattern=r'^[a-z0-9-_]+$')
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}

        # Construct headers
        header_parameters = {}
        header_parameters['Accept'] = 'application/json'
        if custom_headers:
            header_parameters.update(custom_headers)

        # Construct and send request
        request = self._client.get(url, query_parameters, header_parameters)
        response = self._client.send(request, stream=False, **operation_config)

        if response.status_code not in [200]:
            raise models.APIErrorException(self._deserialize, response)

        deserialized = None

        if response.status_code == 200:
            deserialized = self._deserialize('TimeSeriesGroup', response)

        if raw:
            client_raw_response = ClientRawResponse(deserialized, response)
            return client_raw_response

        return deserialized
    get.metadata = {'url': '/timeseriesgroups/{timeSeriesGroupId}'}

    def create(
            self, time_series_group_id, body, custom_headers=None, raw=False, **operation_config):
        """Create a time series group.

        Create a time series group.

        :param time_series_group_id: Unique id for time series group.
        :type time_series_group_id: str
        :param body: GroupId and granularity are needed to create a time
         series group
        :type body:
         ~azure.cognitiveservices.anomalydetector.models.TimeSeriesGroupCreateRequest
        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :return: None or ClientRawResponse if raw=true
        :rtype: None or ~msrest.pipeline.ClientRawResponse
        :raises:
         :class:`APIErrorException<azure.cognitiveservices.anomalydetector.models.APIErrorException>`
        """
        # Construct URL
        url = self.create.metadata['url']
        path_format_arguments = {
            'Endpoint': self._serialize.url("self.config.endpoint", self.config.endpoint, 'str', skip_quote=True),
            'timeSeriesGroupId': self._serialize.url("time_series_group_id", time_series_group_id, 'str', max_length=64, pattern=r'^[a-z0-9-_]+$')
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}

        # Construct headers
        header_parameters = {}
        header_parameters['Content-Type'] = 'application/json; charset=utf-8'
        if custom_headers:
            header_parameters.update(custom_headers)

        # Construct body
        body_content = self._serialize.body(body, 'TimeSeriesGroupCreateRequest')

        # Construct and send request
        request = self._client.put(url, query_parameters, header_parameters, body_content)
        response = self._client.send(request, stream=False, **operation_config)

        if response.status_code not in [200]:
            raise models.APIErrorException(self._deserialize, response)

        if raw:
            client_raw_response = ClientRawResponse(None, response)
            return client_raw_response
    create.metadata = {'url': '/timeseriesgroups/{timeSeriesGroupId}'}

    def delete(
            self, time_series_group_id, custom_headers=None, raw=False, **operation_config):
        """Delete a time series group.

        Delete a time series group.

        :param time_series_group_id: Unique id for time series group.
        :type time_series_group_id: str
        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :return: None or ClientRawResponse if raw=true
        :rtype: None or ~msrest.pipeline.ClientRawResponse
        :raises:
         :class:`APIErrorException<azure.cognitiveservices.anomalydetector.models.APIErrorException>`
        """
        # Construct URL
        url = self.delete.metadata['url']
        path_format_arguments = {
            'Endpoint': self._serialize.url("self.config.endpoint", self.config.endpoint, 'str', skip_quote=True),
            'timeSeriesGroupId': self._serialize.url("time_series_group_id", time_series_group_id, 'str', max_length=64, pattern=r'^[a-z0-9-_]+$')
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}

        # Construct headers
        header_parameters = {}
        if custom_headers:
            header_parameters.update(custom_headers)

        # Construct and send request
        request = self._client.delete(url, query_parameters, header_parameters)
        response = self._client.send(request, stream=False, **operation_config)

        if response.status_code not in [200]:
            raise models.APIErrorException(self._deserialize, response)

        if raw:
            client_raw_response = ClientRawResponse(None, response)
            return client_raw_response
    delete.metadata = {'url': '/timeseriesgroups/{timeSeriesGroupId}'}

    def list(
            self, next=None, custom_headers=None, raw=False, **operation_config):
        """List time series groups.

        List time series groups page by page using the "next" field. It means
        that all time series groups have been returned when the "next" field is
        null.

        :param next: Use "next" as query parameter to get next page data.
        :type next: str
        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :return: TimeSeriesGroupList or ClientRawResponse if raw=true
        :rtype:
         ~azure.cognitiveservices.anomalydetector.models.TimeSeriesGroupList or
         ~msrest.pipeline.ClientRawResponse
        :raises:
         :class:`APIErrorException<azure.cognitiveservices.anomalydetector.models.APIErrorException>`
        """
        # Construct URL
        url = self.list.metadata['url']
        path_format_arguments = {
            'Endpoint': self._serialize.url("self.config.endpoint", self.config.endpoint, 'str', skip_quote=True)
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}
        if next is not None:
            query_parameters['next'] = self._serialize.query("next", next, 'str')

        # Construct headers
        header_parameters = {}
        header_parameters['Accept'] = 'application/json'
        if custom_headers:
            header_parameters.update(custom_headers)

        # Construct and send request
        request = self._client.get(url, query_parameters, header_parameters)
        response = self._client.send(request, stream=False, **operation_config)

        if response.status_code not in [200]:
            raise models.APIErrorException(self._deserialize, response)

        deserialized = None

        if response.status_code == 200:
            deserialized = self._deserialize('TimeSeriesGroupList', response)

        if raw:
            client_raw_response = ClientRawResponse(deserialized, response)
            return client_raw_response

        return deserialized
    list.metadata = {'url': '/timeseriesgroups'}

    def inconsistency_detect(
            self, time_series_group_id, timestamp, epsilon=None, custom_headers=None, raw=False, **operation_config):
        """Detect inconsistent time series from a group of similar time series.

        This operation helps detect the inconsistent series among a group
        series with similar trend.

        :param time_series_group_id: Unique id for time series group.
        :type time_series_group_id: str
        :param timestamp: Inconsistency detect timestamp.
        :type timestamp: datetime
        :param epsilon: Parameter to be tuned to get inconsistency.
        :type epsilon: float
        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :return: Inconsistency or ClientRawResponse if raw=true
        :rtype: ~azure.cognitiveservices.anomalydetector.models.Inconsistency
         or ~msrest.pipeline.ClientRawResponse
        :raises:
         :class:`APIErrorException<azure.cognitiveservices.anomalydetector.models.APIErrorException>`
        """
        body = models.InconsistencyDetectRequest(timestamp=timestamp, epsilon=epsilon)

        # Construct URL
        url = self.inconsistency_detect.metadata['url']
        path_format_arguments = {
            'Endpoint': self._serialize.url("self.config.endpoint", self.config.endpoint, 'str', skip_quote=True),
            'timeSeriesGroupId': self._serialize.url("time_series_group_id", time_series_group_id, 'str', max_length=64, pattern=r'^[a-z0-9-_]+$')
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}

        # Construct headers
        header_parameters = {}
        header_parameters['Accept'] = 'application/json'
        header_parameters['Content-Type'] = 'application/json; charset=utf-8'
        if custom_headers:
            header_parameters.update(custom_headers)

        # Construct body
        body_content = self._serialize.body(body, 'InconsistencyDetectRequest')

        # Construct and send request
        request = self._client.post(url, query_parameters, header_parameters, body_content)
        response = self._client.send(request, stream=False, **operation_config)

        if response.status_code not in [200]:
            raise models.APIErrorException(self._deserialize, response)

        deserialized = None

        if response.status_code == 200:
            deserialized = self._deserialize('Inconsistency', response)

        if raw:
            client_raw_response = ClientRawResponse(deserialized, response)
            return client_raw_response

        return deserialized
    inconsistency_detect.metadata = {'url': '/timeseriesgroups/{timeSeriesGroupId}/inconsistency/detect'}

    def inconsistency_query(
            self, time_series_group_id, begin, end, custom_headers=None, raw=False, **operation_config):
        """Query time series properties from a group of similar time series.

        This operation helps query properties of one group, for example the
        inconsistent series among a group series with similar trend.

        :param time_series_group_id: Unique id for time series group.
        :type time_series_group_id: str
        :param begin: Start time of the time series group.
        :type begin: datetime
        :param end: End time of the time series group.
        :type end: datetime
        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :return: list or ClientRawResponse if raw=true
        :rtype:
         list[~azure.cognitiveservices.anomalydetector.models.Inconsistency] or
         ~msrest.pipeline.ClientRawResponse
        :raises:
         :class:`APIErrorException<azure.cognitiveservices.anomalydetector.models.APIErrorException>`
        """
        body = models.InconsistencyQueryRequest(begin=begin, end=end)

        # Construct URL
        url = self.inconsistency_query.metadata['url']
        path_format_arguments = {
            'Endpoint': self._serialize.url("self.config.endpoint", self.config.endpoint, 'str', skip_quote=True),
            'timeSeriesGroupId': self._serialize.url("time_series_group_id", time_series_group_id, 'str', max_length=64, pattern=r'^[a-z0-9-_]+$')
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}

        # Construct headers
        header_parameters = {}
        header_parameters['Accept'] = 'application/json'
        header_parameters['Content-Type'] = 'application/json; charset=utf-8'
        if custom_headers:
            header_parameters.update(custom_headers)

        # Construct body
        body_content = self._serialize.body(body, 'InconsistencyQueryRequest')

        # Construct and send request
        request = self._client.post(url, query_parameters, header_parameters, body_content)
        response = self._client.send(request, stream=False, **operation_config)

        if response.status_code not in [200]:
            raise models.APIErrorException(self._deserialize, response)

        deserialized = None

        if response.status_code == 200:
            deserialized = self._deserialize('[Inconsistency]', response)

        if raw:
            client_raw_response = ClientRawResponse(deserialized, response)
            return client_raw_response

        return deserialized
    inconsistency_query.metadata = {'url': '/timeseriesgroups/{timeSeriesGroupId}/inconsistency/query'}

    def list_series(
            self, time_series_group_id, next=None, custom_headers=None, raw=False, **operation_config):
        """List TimeSeries that belongs to a TimeSeriesGroup.

        List TimeSeries that belongs to a TimeSeriesGroup. One TimeSeriesGroup
        could have multiple TimeSeries.

        :param time_series_group_id: Unique id for time series group.
        :type time_series_group_id: str
        :param next: Use "next" as query parameter to get next page data.
        :type next: str
        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :return: TimeSeriesList or ClientRawResponse if raw=true
        :rtype: ~azure.cognitiveservices.anomalydetector.models.TimeSeriesList
         or ~msrest.pipeline.ClientRawResponse
        :raises:
         :class:`APIErrorException<azure.cognitiveservices.anomalydetector.models.APIErrorException>`
        """
        # Construct URL
        url = self.list_series.metadata['url']
        path_format_arguments = {
            'Endpoint': self._serialize.url("self.config.endpoint", self.config.endpoint, 'str', skip_quote=True),
            'timeSeriesGroupId': self._serialize.url("time_series_group_id", time_series_group_id, 'str', max_length=64, pattern=r'^[a-z0-9-_]+$')
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}
        if next is not None:
            query_parameters['next'] = self._serialize.query("next", next, 'str')

        # Construct headers
        header_parameters = {}
        header_parameters['Accept'] = 'application/json'
        if custom_headers:
            header_parameters.update(custom_headers)

        # Construct and send request
        request = self._client.get(url, query_parameters, header_parameters)
        response = self._client.send(request, stream=False, **operation_config)

        if response.status_code not in [200]:
            raise models.APIErrorException(self._deserialize, response)

        deserialized = None

        if response.status_code == 200:
            deserialized = self._deserialize('TimeSeriesList', response)

        if raw:
            client_raw_response = ClientRawResponse(deserialized, response)
            return client_raw_response

        return deserialized
    list_series.metadata = {'url': '/timeseriesgroups/{timeSeriesGroupId}/timeseries'}

    def add_time_series(
            self, time_series_group_id, time_series_id, custom_headers=None, raw=False, **operation_config):
        """Add a TimeSeries to TimeSeriesGroup.

        Add a TimeSeries to TimeSeriesGroup.

        :param time_series_group_id: Unique id for time series group.
        :type time_series_group_id: str
        :param time_series_id: Unique id for time series.
        :type time_series_id: str
        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :return: None or ClientRawResponse if raw=true
        :rtype: None or ~msrest.pipeline.ClientRawResponse
        :raises:
         :class:`APIErrorException<azure.cognitiveservices.anomalydetector.models.APIErrorException>`
        """
        # Construct URL
        url = self.add_time_series.metadata['url']
        path_format_arguments = {
            'Endpoint': self._serialize.url("self.config.endpoint", self.config.endpoint, 'str', skip_quote=True),
            'timeSeriesGroupId': self._serialize.url("time_series_group_id", time_series_group_id, 'str', max_length=64, pattern=r'^[a-z0-9-_]+$'),
            'timeSeriesId': self._serialize.url("time_series_id", time_series_id, 'str', max_length=64, pattern=r'^[a-z0-9-_]+$')
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}

        # Construct headers
        header_parameters = {}
        if custom_headers:
            header_parameters.update(custom_headers)

        # Construct and send request
        request = self._client.put(url, query_parameters, header_parameters)
        response = self._client.send(request, stream=False, **operation_config)

        if response.status_code not in [200]:
            raise models.APIErrorException(self._deserialize, response)

        if raw:
            client_raw_response = ClientRawResponse(None, response)
            return client_raw_response
    add_time_series.metadata = {'url': '/timeseriesgroups/{timeSeriesGroupId}/timeseries/{timeSeriesId}'}

    def delete_time_series(
            self, time_series_group_id, time_series_id, custom_headers=None, raw=False, **operation_config):
        """Remove a TimeSeries from TimeSeriesGroup.

        Remove a TimeSeries from TimeSeriesGroup.

        :param time_series_group_id: Unique id for time series group.
        :type time_series_group_id: str
        :param time_series_id: Unique id for time series.
        :type time_series_id: str
        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :return: None or ClientRawResponse if raw=true
        :rtype: None or ~msrest.pipeline.ClientRawResponse
        :raises:
         :class:`APIErrorException<azure.cognitiveservices.anomalydetector.models.APIErrorException>`
        """
        # Construct URL
        url = self.delete_time_series.metadata['url']
        path_format_arguments = {
            'Endpoint': self._serialize.url("self.config.endpoint", self.config.endpoint, 'str', skip_quote=True),
            'timeSeriesGroupId': self._serialize.url("time_series_group_id", time_series_group_id, 'str', max_length=64, pattern=r'^[a-z0-9-_]+$'),
            'timeSeriesId': self._serialize.url("time_series_id", time_series_id, 'str', max_length=64, pattern=r'^[a-z0-9-_]+$')
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}

        # Construct headers
        header_parameters = {}
        if custom_headers:
            header_parameters.update(custom_headers)

        # Construct and send request
        request = self._client.delete(url, query_parameters, header_parameters)
        response = self._client.send(request, stream=False, **operation_config)

        if response.status_code not in [200]:
            raise models.APIErrorException(self._deserialize, response)

        if raw:
            client_raw_response = ClientRawResponse(None, response)
            return client_raw_response
    delete_time_series.metadata = {'url': '/timeseriesgroups/{timeSeriesGroupId}/timeseries/{timeSeriesId}'}
