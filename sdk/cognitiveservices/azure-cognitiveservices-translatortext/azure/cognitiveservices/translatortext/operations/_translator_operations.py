# coding=utf-8
# --------------------------------------------------------------------------
# Copyright (c) Microsoft Corporation. All rights reserved.
# Licensed under the MIT License. See License.txt in the project root for
# license information.
#
# Code generated by Microsoft (R) AutoRest Code Generator.
# Changes may cause incorrect behavior and will be lost if the code is
# regenerated.
# --------------------------------------------------------------------------

from msrest.pipeline import ClientRawResponse

from .. import models


class TranslatorOperations(object):
    """TranslatorOperations operations.

    You should not instantiate directly this class, but create a Client instance that will create it for you and attach it as attribute.

    :param client: Client for service requests.
    :param config: Configuration of service client.
    :param serializer: An object model serializer.
    :param deserializer: An object model deserializer.
    :ivar api_version: Version of the API requested by the client. Value must be **3.0**. Constant value: "3.0".
    """

    models = models

    def __init__(self, client, config, serializer, deserializer):

        self._client = client
        self._serialize = serializer
        self._deserialize = deserializer

        self.config = config
        self.api_version = "3.0"

    def break_sentence(
            self, text, language=None, script=None, x_client_trace_id=None, custom_headers=None, raw=False, **operation_config):
        """Identifies the position of sentence boundaries in a piece of text.
        .

        :param text: # Request Body
         The body of the request is a JSON array. Each array element is a JSON
         object with a string property named Text. Sentence boundaries are
         computed for the value of the Text property.
         The following limitations apply:
         * The array can have at most 100 elements.
         * The text value of an array element cannot exceed 10,000 characters
         including spaces.
         * The entire text included in the request cannot exceed 50,000
         characters including spaces.
         * If the `language` query parameter is specified, then all array
         elements must be in the same language. Otherwise, language
         auto-detection is applied to each array element independently.
         # Response Body
         A successful response is a JSON array with one result for each string
         in the input array. A result object includes the following properties:
         * `sentLen`- An array of integers representing the lengths of the
         sentences in the text element. The length of the array is the number
         of sentences, and the values are the length of each sentence.
         * `detectedLanguage`- An object describing the detected language
         through the following properties
         * `language`- Code of the detected language.
         * `score`- A float value indicating the confidence in the result. The
         score is between zero and one and a low score indicates a low
         confidence.
         * Note that the `detectedLanguage` property is only present in the
         result object when language auto-detection is requested.
         # Response Header
         X-RequestId - Value generated by the service to identify the request.
         It is used for troubleshooting purposes.
        :type text:
         list[~azure.cognitiveservices.translatortext.models.BreakSentenceTextInput]
        :param language: Language tag of the language of the input text. If
         not specified, Translator will apply automatic language detection.
        :type language: str
        :param script: Script identifier of the script used by the input text.
         If a script is not specified, the default script of the language will
         be assumed.
        :type script: str
        :param x_client_trace_id: A client-generated GUID to uniquely identify
         the request. Note that you can omit this header if you include the
         trace ID in the query string using a query parameter named
         ClientTraceId.
        :type x_client_trace_id: str
        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :return: list or ClientRawResponse if raw=true
        :rtype:
         list[~azure.cognitiveservices.translatortext.models.BreakSentenceResultItem]
         or ~msrest.pipeline.ClientRawResponse
        :raises:
         :class:`ErrorMessageException<azure.cognitiveservices.translatortext.models.ErrorMessageException>`
        """
        # Construct URL
        url = self.break_sentence.metadata['url']
        path_format_arguments = {
            'Endpoint': self._serialize.url("self.config.endpoint", self.config.endpoint, 'str', skip_quote=True)
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}
        query_parameters['api-version'] = self._serialize.query("self.api_version", self.api_version, 'str')
        if language is not None:
            query_parameters['Language'] = self._serialize.query("language", language, 'str')
        if script is not None:
            query_parameters['Script'] = self._serialize.query("script", script, 'str')

        # Construct headers
        header_parameters = {}
        header_parameters['Accept'] = 'application/json'
        header_parameters['Content-Type'] = 'application/json; charset=utf-8'
        if custom_headers:
            header_parameters.update(custom_headers)
        if x_client_trace_id is not None:
            header_parameters['X-ClientTraceId'] = self._serialize.header("x_client_trace_id", x_client_trace_id, 'str')

        # Construct body
        body_content = self._serialize.body(text, '[BreakSentenceTextInput]')

        # Construct and send request
        request = self._client.post(url, query_parameters, header_parameters, body_content)
        response = self._client.send(request, stream=False, **operation_config)

        if response.status_code not in [200]:
            raise models.ErrorMessageException(self._deserialize, response)

        deserialized = None
        if response.status_code == 200:
            deserialized = self._deserialize('[BreakSentenceResultItem]', response)

        if raw:
            client_raw_response = ClientRawResponse(deserialized, response)
            return client_raw_response

        return deserialized
    break_sentence.metadata = {'url': '/BreakSentence'}

    def detect(
            self, text, x_client_trace_id=None, custom_headers=None, raw=False, **operation_config):
        """Identifies the language of a string of text.
        .

        :param text: # Request Body
         The body of the request is a JSON array. Each array element is a JSON
         object with a string property named Text. Language detection is
         applied to the value of the Text property.
         The following limitations apply:
         * The array can have at most 100 elements.
         * The text value of an array element cannot exceed 10,000 characters
         including spaces.
         * The entire text included in the request cannot exceed 50,000
         characters including spaces.
         # Response Body
         A successful response is a JSON array with one result for each string
         in the input array. A result object includes the following properties:
         * language- Code of the detected language.
         * score- A float value indicating the confidence in the result. The
         score is between zero and one and a low score indicates a low
         confidence.
         * isTranslationSupported- A boolean value which is true if the
         detected language is one of the languages supported for text
         translation. Not all detected languages can be translated by the API.
         * isTransliterationSupported- A boolean value which is true if the
         detected language is one of the languages supported for
         transliteration.
         * alternatives- An array of other possible languages. Each element of
         the array is another object with the same properties listed above-
         language, score, isTranslationSupported and
         isTransliterationSupported.
         # Response Header
         X-RequestId - Value generated by the service to identify the request.
         It is used for troubleshooting purposes.
        :type text:
         list[~azure.cognitiveservices.translatortext.models.DetectTextInput]
        :param x_client_trace_id: A client-generated GUID to uniquely identify
         the request. Note that you can omit this header if you include the
         trace ID in the query string using a query parameter named
         ClientTraceId.
        :type x_client_trace_id: str
        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :return: list or ClientRawResponse if raw=true
        :rtype:
         list[~azure.cognitiveservices.translatortext.models.DetectResultItem]
         or ~msrest.pipeline.ClientRawResponse
        :raises:
         :class:`ErrorMessageException<azure.cognitiveservices.translatortext.models.ErrorMessageException>`
        """
        # Construct URL
        url = self.detect.metadata['url']
        path_format_arguments = {
            'Endpoint': self._serialize.url("self.config.endpoint", self.config.endpoint, 'str', skip_quote=True)
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}
        query_parameters['api-version'] = self._serialize.query("self.api_version", self.api_version, 'str')

        # Construct headers
        header_parameters = {}
        header_parameters['Accept'] = 'application/json'
        header_parameters['Content-Type'] = 'application/json; charset=utf-8'
        if custom_headers:
            header_parameters.update(custom_headers)
        if x_client_trace_id is not None:
            header_parameters['X-ClientTraceId'] = self._serialize.header("x_client_trace_id", x_client_trace_id, 'str')

        # Construct body
        body_content = self._serialize.body(text, '[DetectTextInput]')

        # Construct and send request
        request = self._client.post(url, query_parameters, header_parameters, body_content)
        response = self._client.send(request, stream=False, **operation_config)

        if response.status_code not in [200]:
            raise models.ErrorMessageException(self._deserialize, response)

        deserialized = None
        if response.status_code == 200:
            deserialized = self._deserialize('[DetectResultItem]', response)

        if raw:
            client_raw_response = ClientRawResponse(deserialized, response)
            return client_raw_response

        return deserialized
    detect.metadata = {'url': '/Detect'}

    def dictionary_lookup(
            self, from_parameter, to, text, x_client_trace_id=None, custom_headers=None, raw=False, **operation_config):
        """Provides alternative translations for a word and a small number of
        idiomatic phrases. Each translation has a `part-of-speech` and a list
        of `back-translations`. The back-translations enable a user to
        understand the translation in context. The Dictionary Example operation
        allows further drill down to see example uses of each translation pair.
        .

        :param from_parameter: Specifies the language of the input text. The
         source language must be one of the supported languages included in the
         `dictionary` scope.
        :type from_parameter: str
        :param to: Specifies the language of the output text. The target
         language must be one of the supported languages included in the
         `dictionary` scope of the Languages resource.
        :type to: str
        :param text: # Request Body
         The body of the request is a JSON array. Each array element is a JSON
         object with a string property named `Text`, which represents the term
         to lookup.
         The following limitations apply:
         * The array can have at most 10 elements.
         * The text value of an array element cannot exceed 100 characters
         including spaces.
         # Response Body
         A successful response is a JSON array with one result for each string
         in the input array. A result object includes the following properties:
         * `normalizedSource`- A string giving the normalized form of the
         source term. For example, if the request is "JOHN", the normalized
         form will be "john". The content of this field becomes the input to
         lookup examples.
         * `displaySource`- A string giving the source term in a form best
         suited for end-user display. For example, if the input is "JOHN", the
         display form will reflect the usual spelling of the name- "John".
         * `translations`- A list of translations for the source term. Each
         element of the list is an object with the following properties:
         * `normalizedTarget`- A string giving the normalized form of this term
         in the target language. This value should be used as input to lookup
         examples.
         * `displayTarget`- A string giving the term in the target language and
         in a form best suited for end-user display. Generally, this will only
         differ from the `normalizedTarget` in terms of capitalization. For
         example, a proper noun like "Juan" will have `normalizedTarget =
         "juan"` and `displayTarget = "Juan"`.
         * `posTag`- A string associating this term with a part-of-speech tag.
         | Tag name  | Description       |
         | --------- | ----------------  |
         | ADJ       | Adjectives        |
         | ADV       | Adverbs           |
         | CONJ      | Conjunctions       |
         | DET       | Determiners       |
         | MODAL     | Verbs             |
         | NOUN      | Nouns             |
         | PREP      | Prepositions      |
         | PRON      | Pronouns          |
         | VERB      | Verbs             |
         | OTHER     | Other             |
         As an implementation note, these tags were determined by
         part-of-speech tagging the English side, and then taking the most
         frequent tag for each source/target pair. So if people frequently
         translate a Spanish word to a different part-of-speech tag in English,
         tags may end up being wrong (with respect to the Spanish word).
         * `confidence`- A value between 0.0 and 1.0 which represents the
         "confidence" (or perhaps more accurately, "probability in the training
         data") of that translation pair. The sum of confidence scores for one
         source word may or may not sum to 1.0.
         * `prefixWord-` A string giving the word to display as a prefix of the
         translation. Currently, this is the gendered determiner of nouns, in
         languages that have gendered determiners. For example, the prefix of
         the Spanish word "mosca" is "la", since "mosca" is a feminine noun in
         Spanish. This is only dependent on the translation, and not on the
         source. If there is no prefix, it will be the empty string.
         * `backTranslations-` A list of "back translations" of the target. For
         example, source words that the target can translate to. The list is
         guaranteed to contain the source word that was requested (e.g., if the
         source word being looked up is "fly", then it is guaranteed that "fly"
         will be in the `backTranslations` list). However, it is not guaranteed
         to be in the first position, and often will not be. Each element of
         the `backTranslations` list is an object described by the following
         properties-
         * `normalizedText-` A string giving the normalized form of the source
         term that is a back-translation of the target. This value should be
         used as input to lookup examples.
         * `displayText-` A string giving the source term that is a
         back-translation of the target in a form best suited for end-user
         display.
         * `numExamples-` An integer representing the number of examples that
         are available for this translation pair. Actual examples must be
         retrieved with a separate call to lookup examples. The number is
         mostly intended to facilitate display in a UX. For example, a user
         interface may add a hyperlink to the back-translation if the number of
         examples is greater than zero and show the back-translation as plain
         text if there are no examples. Note that the actual number of examples
         returned by a call to lookup examples may be less than `numExamples`,
         because additional filtering may be applied on the fly to remove "bad"
         examples.
         * `frequencyCount-` An integer representing the frequency of this
         translation pair in the data. The main purpose of this field is to
         provide a user interface with a means to sort back-translations so the
         most frequent terms are first.
         Note - If the term being looked up does not exist in the dictionary,
         the response is 200 (OK) but the `translations` list is an empty list.
         # Response Header
         X-RequestId - Value generated by the service to identify the request.
         It is used for troubleshooting purposes.
        :type text:
         list[~azure.cognitiveservices.translatortext.models.DictionaryLookupTextInput]
        :param x_client_trace_id: A client-generated GUID to uniquely identify
         the request. Note that you can omit this header if you include the
         trace ID in the query string using a query parameter named
         ClientTraceId.
        :type x_client_trace_id: str
        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :return: list or ClientRawResponse if raw=true
        :rtype:
         list[~azure.cognitiveservices.translatortext.models.DictionaryLookupResultItem]
         or ~msrest.pipeline.ClientRawResponse
        :raises:
         :class:`ErrorMessageException<azure.cognitiveservices.translatortext.models.ErrorMessageException>`
        """
        # Construct URL
        url = self.dictionary_lookup.metadata['url']
        path_format_arguments = {
            'Endpoint': self._serialize.url("self.config.endpoint", self.config.endpoint, 'str', skip_quote=True)
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}
        query_parameters['api-version'] = self._serialize.query("self.api_version", self.api_version, 'str')
        query_parameters['from'] = self._serialize.query("from_parameter", from_parameter, 'str')
        query_parameters['to'] = self._serialize.query("to", to, 'str')

        # Construct headers
        header_parameters = {}
        header_parameters['Accept'] = 'application/json'
        header_parameters['Content-Type'] = 'application/json; charset=utf-8'
        if custom_headers:
            header_parameters.update(custom_headers)
        if x_client_trace_id is not None:
            header_parameters['X-ClientTraceId'] = self._serialize.header("x_client_trace_id", x_client_trace_id, 'str')

        # Construct body
        body_content = self._serialize.body(text, '[DictionaryLookupTextInput]')

        # Construct and send request
        request = self._client.post(url, query_parameters, header_parameters, body_content)
        response = self._client.send(request, stream=False, **operation_config)

        if response.status_code not in [200]:
            raise models.ErrorMessageException(self._deserialize, response)

        deserialized = None
        if response.status_code == 200:
            deserialized = self._deserialize('[DictionaryLookupResultItem]', response)

        if raw:
            client_raw_response = ClientRawResponse(deserialized, response)
            return client_raw_response

        return deserialized
    dictionary_lookup.metadata = {'url': '/Dictionary/Lookup'}

    def dictionary_examples(
            self, from_parameter, to, text, x_client_trace_id=None, custom_headers=None, raw=False, **operation_config):
        """Provides examples that show how terms in the dictionary are used in
        context. This operation is used in tandem with `Dictionary lookup`.
        .

        :param from_parameter: Specifies the language of the input text. The
         source language must be one of the supported languages included in the
         `dictionary` scope.
        :type from_parameter: str
        :param to: Specifies the language of the output text. The target
         language must be one of the supported languages included in the
         `dictionary` scope.
        :type to: str
        :param text: # Request body
         The body of the request is a JSON array. Each array element is a JSON
         object with the following properties:
         * `Text-` A string specifying the term to lookup. This should be the
         value of a `normalizedText` field from the back-translations of a
         previous Dictionary lookup request. It can also be the value of the
         `normalizedSource` field.
         * `Translation-` A string specifying the translated text previously
         returned by the Dictionary lookup operation. This should be the value
         from the `normalizedTarget` field in the `translations` list of the
         Dictionary lookup response. The service will return examples for the
         specific source-target word-pair.
         The following limitations apply:
         * The array can have at most 10 elements.
         * The text value of an array element cannot exceed 100 characters
         including spaces.
         # Response body
         A successful response is a JSON array with one result for each string
         in the input array. A result object includes the following properties:
         * `normalizedSource-` A string giving the normalized form of the
         source term. Generally, this should be identical to the value of the
         `Text` field at the matching list index in the body of the request.
         * `normalizedTarget-` A string giving the normalized form of the
         target term. Generally, this should be identical to the value of the
         `Translation` field at the matching list index in the body of the
         request.
         * `examples-` A list of examples for the (source term, target term)
         pair. Each element of the list is an object with the following
         properties:
         * `sourcePrefix-` The string to concatenate before the value of
         `sourceTerm` to form a complete example. Do not add a space character,
         since it is already there when it should be. This value may be an
         empty string.
         * `sourceTerm-` A string equal to the actual term looked up. The
         string is added with `sourcePrefix` and `sourceSuffix` to form the
         complete example. Its value is separated so it can be marked in a user
         interface, e.g., by bolding it.
         * `sourceSuffix-` The string to concatenate after the value of
         `sourceTerm` to form a complete example. Do not add a space character,
         since it is already there when it should be. This value may be an
         empty string.
         * `targetPrefix-` A string similar to `sourcePrefix` but for the
         target.
         * `targetTerm-` A string similar to `sourceTerm` but for the target.
         * `targetSuffix-` A string similar to `sourceSuffix` but for the
         target.
         # Response Header
         X-RequestId - Value generated by the service to identify the request.
         It is used for troubleshooting purposes.
         NOTE - If there are no examples in the dictionary, the response is 200
         (OK) but the `examples` list is an empty list.
        :type text:
         list[~azure.cognitiveservices.translatortext.models.DictionaryExampleTextInput]
        :param x_client_trace_id: A client-generated GUID to uniquely identify
         the request. Note that you can omit this header if you include the
         trace ID in the query string using a query parameter named
         ClientTraceId.
        :type x_client_trace_id: str
        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :return: list or ClientRawResponse if raw=true
        :rtype:
         list[~azure.cognitiveservices.translatortext.models.DictionaryExampleResultItem]
         or ~msrest.pipeline.ClientRawResponse
        :raises:
         :class:`ErrorMessageException<azure.cognitiveservices.translatortext.models.ErrorMessageException>`
        """
        # Construct URL
        url = self.dictionary_examples.metadata['url']
        path_format_arguments = {
            'Endpoint': self._serialize.url("self.config.endpoint", self.config.endpoint, 'str', skip_quote=True)
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}
        query_parameters['api-version'] = self._serialize.query("self.api_version", self.api_version, 'str')
        query_parameters['from'] = self._serialize.query("from_parameter", from_parameter, 'str')
        query_parameters['to'] = self._serialize.query("to", to, 'str')

        # Construct headers
        header_parameters = {}
        header_parameters['Accept'] = 'application/json'
        header_parameters['Content-Type'] = 'application/json; charset=utf-8'
        if custom_headers:
            header_parameters.update(custom_headers)
        if x_client_trace_id is not None:
            header_parameters['X-ClientTraceId'] = self._serialize.header("x_client_trace_id", x_client_trace_id, 'str')

        # Construct body
        body_content = self._serialize.body(text, '[DictionaryExampleTextInput]')

        # Construct and send request
        request = self._client.post(url, query_parameters, header_parameters, body_content)
        response = self._client.send(request, stream=False, **operation_config)

        if response.status_code not in [200]:
            raise models.ErrorMessageException(self._deserialize, response)

        deserialized = None
        if response.status_code == 200:
            deserialized = self._deserialize('[DictionaryExampleResultItem]', response)

        if raw:
            client_raw_response = ClientRawResponse(deserialized, response)
            return client_raw_response

        return deserialized
    dictionary_examples.metadata = {'url': '/Dictionary/Examples'}

    def languages(
            self, scope=None, accept_language=None, x_client_trace_id=None, custom_headers=None, raw=False, **operation_config):
        """Gets the set of languages currently supported by other operations of
        the Translator Text API.
        **Authentication is not required to get language resources.**
        # Response Body
        A client uses the `scope` query parameter to define which groups of
        languages it is interested in.
        * `scope=translation` provides languages supported to translate text
        from one language to another language.
        * `scope=transliteration` provides capabilities for converting text in
        one language from one script to another script.
        * `scope=dictionary` provides language pairs for which `Dictionary`
        operations return data.
        A client may retrieve several groups simultaneously by specifying a
        comma-separated list of names. For example,
        `scope=translation,transliteration,dictionary` would return supported
        languages for all groups.
        A successful response is a JSON object with one property for each
        requested group.
        The value for each property is as follows.
        * `translation` property
        The value of the `translation` property is a dictionary of (key, value)
        pairs. Each key is a BCP 47 language tag. A key identifies a language
        for which text can be translated to or translated from. The value
        associated with the key is a JSON object with properties that describe
        the language
        * `name-` Display name of the language in the locale requested via
        `Accept-Language` header.
        * `nativeName-` Display name of the language in the locale native for
        this language.
        * `dir-` Directionality, which is `rtl` for right-to-left languages or
        `ltr` for left-to-right languages.
        ```json
        {
        "translation": {
        ...
        "fr": {
        "name": "French",
        "nativeName": "Français",
        "dir": "ltr"
        },
        ...
        }
        }
        ```
        * `transliteration` property
        The value of the `transliteration` property is a dictionary of (key,
        value) pairs. Each key is a BCP 47 language tag. A key identifies a
        language for which text can be converted from one script to another
        script. The value associated with the key is a JSON object with
        properties that describe the language and its supported scripts
        * `name-` Display name of the language in the locale requested via
        `Accept-Language` header.
        * `nativeName-` Display name of the language in the locale native for
        this language.
        * `scripts-` List of scripts to convert from. Each element of the
        `scripts` list has properties-
        * `code-` Code identifying the script.
        * `name-` Display name of the script in the locale requested via
        `Accept-Language` header.
        * `nativeName-` Display name of the language in the locale native for
        the language.
        * `dir-` Directionality, which is `rtl` for right-to-left languages or
        `ltr` for left-to-right languages.
        * `toScripts-` List of scripts available to convert text to. Each
        element of the `toScripts` list has properties `code`, `name`,
        `nativeName`, and `dir` as described earlier.
        ```json
        {
        "transliteration": {
        ...
        "ja": {
        "name": "Japanese",
        "nativeName": "日本語",
        "scripts": [
        {
        "code": "Jpan",
        "name": "Japanese",
        "nativeName": "日本語",
        "dir": "ltr",
        "toScripts": [
        {
        "code": "Latn",
        "name": "Latin",
        "nativeName": "ラテン語",
        "dir": "ltr"
        }
        ]
        },
        {
        "code": "Latn",
        "name": "Latin",
        "nativeName": "ラテン語",
        "dir": "ltr",
        "toScripts": [
        {
        "code": "Jpan",
        "name": "Japanese",
        "nativeName": "日本語",
        "dir": "ltr"
        }
        ]
        }
        ]
        },
        ...
        }
        }
        ```
        * `dictionary` property
        The value of the `dictionary` property is a dictionary of (key, value)
        pairs. Each key is a BCP 47 language tag. The key identifies a language
        for which alternative translations and back-translations are available.
        The value is a JSON object that describes the source language and the
        target languages with available translations.
        * `name-` Display name of the source language in the locale requested
        via `Accept-Language` header.
        * `nativeName-` Display name of the language in the locale native for
        this language.
        * `dir-` Directionality, which is `rtl` for right-to-left languages or
        `ltr` for left-to-right languages.
        * `translations-` List of languages with alterative translations and
        examples for the query expressed in the source language. Each element
        of the `translations` list has properties
        * `name-` Display name of the target language in the locale requested
        via `Accept-Language` header.
        * `nativeName-` Display name of the target language in the locale
        native for the target language.
        * `dir-` Directionality, which is `rtl` for right-to-left languages or
        `ltr` for left-to-right languages.
        * `code-` Language code identifying the target language.
        ```json
        "es": {
        "name": "Spanish",
        "nativeName": "Español",
        "dir": "ltr",
        "translations": [
        {
        "name": "English",
        "nativeName": "English",
        "dir": "ltr",
        "code": "en"
        }
        ]
        },
        ```
        The structure of the response object will not change without a change
        in the version of the API. For the same version of the API, the list of
        available languages may change over time because Microsoft Translator
        continually extends the list of languages supported by its services.
        The list of supported languages will not change frequently. To save
        network bandwidth and improve responsiveness, a client application
        should consider caching language resources and the corresponding entity
        tag (`ETag`). Then, the client application can periodically (for
        example, once every 24 hours) query the service to fetch the latest set
        of supported languages. Passing the current `ETag` value in an
        `If-None-Match` header field will allow the service to optimize the
        response. If the resource has not been modified, the service will
        return status code 304 and an empty response body.
        # Response Header
        ETag - Current value of the entity tag for the requested groups of
        supported languages. To make subsequent requests more efficient, the
        client may send the `ETag` value in an `If-None-Match` header field.
        X-RequestId - Value generated by the service to identify the request.
        It is used for troubleshooting purposes.
        .

        :param scope: A comma-separated list of names defining the group of
         languages to return. Allowed group names are- `translation`,
         `transliteration` and `dictionary`. If no scope is given, then all
         groups are returned, which is equivalent to passing
         `scope=translation,transliteration,dictionary`. To decide which set of
         supported languages is appropriate for your scenario, see the
         description of the response object.
        :type scope: list[str]
        :param accept_language: The language to use for user interface
         strings. Some of the fields in the response are names of languages or
         names of regions. Use this parameter to define the language in which
         these names are returned. The language is specified by providing a
         well-formed BCP 47 language tag. For instance, use the value `fr` to
         request names in French or use the value `zh-Hant` to request names in
         Chinese Traditional. Names are provided in the English language when a
         target language is not specified or when localization is not
         available.
        :type accept_language: str
        :param x_client_trace_id: A client-generated GUID to uniquely identify
         the request. Note that you can omit this header if you include the
         trace ID in the query string using a query parameter named
         ClientTraceId.
        :type x_client_trace_id: str
        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :return: LanguagesResult or ClientRawResponse if raw=true
        :rtype: ~azure.cognitiveservices.translatortext.models.LanguagesResult
         or ~msrest.pipeline.ClientRawResponse
        :raises:
         :class:`ErrorMessageException<azure.cognitiveservices.translatortext.models.ErrorMessageException>`
        """
        # Construct URL
        url = self.languages.metadata['url']
        path_format_arguments = {
            'Endpoint': self._serialize.url("self.config.endpoint", self.config.endpoint, 'str', skip_quote=True)
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}
        query_parameters['api-version'] = self._serialize.query("self.api_version", self.api_version, 'str')
        if scope is not None:
            query_parameters['scope'] = self._serialize.query("scope", scope, '[str]', div=',', max_items=3, min_items=0)

        # Construct headers
        header_parameters = {}
        header_parameters['Accept'] = 'application/json'
        if custom_headers:
            header_parameters.update(custom_headers)
        if accept_language is not None:
            header_parameters['Accept-Language'] = self._serialize.header("accept_language", accept_language, 'str')
        if x_client_trace_id is not None:
            header_parameters['X-ClientTraceId'] = self._serialize.header("x_client_trace_id", x_client_trace_id, 'str')

        # Construct and send request
        request = self._client.get(url, query_parameters, header_parameters)
        response = self._client.send(request, stream=False, **operation_config)

        if response.status_code not in [200]:
            raise models.ErrorMessageException(self._deserialize, response)

        deserialized = None
        if response.status_code == 200:
            deserialized = self._deserialize('LanguagesResult', response)

        if raw:
            client_raw_response = ClientRawResponse(deserialized, response)
            return client_raw_response

        return deserialized
    languages.metadata = {'url': '/Languages'}

    def translate(
            self, to, text, from_parameter=None, text_type=None, category=None, profanity_action=None, profanity_marker=None, include_alignment=None, include_sentence_length=None, suggested_from=None, from_script=None, to_script=None, x_client_trace_id=None, custom_headers=None, raw=False, **operation_config):
        """Translates text into one or more languages.
        .

        :param to: Specifies the language of the output text. Find which
         languages are available to translate to by using the languages method.
         For example, use `to=de` to translate to German.
         It's possible to translate to multiple languages simultaneously by
         repeating the `to` parameter in the query string. For example, use
         `to=de&to=it` to translate to German and Italian in the same request.
        :type to: list[str]
        :param text: # Request body
         The body of the request is a JSON array. Each array element is a JSON
         object with a string property named `Text`, which represents the
         string to translate.
         The following limitations apply:
         * The array can have at most 25 elements.
         * The entire text included in the request cannot exceed 5,000
         characters including spaces.
         # Response body
         A successful response is a JSON array with one result for each string
         in the input array. A result object includes the following properties-
         * `detectedLanguage`- An object describing the detected language
         through the following properties.
         * `language`- A string representing the code of the detected language.
         * `score`- A float value indicating the confidence in the result. The
         score is between zero and one and a low score indicates a low
         confidence.
         The `detectedLanguage` property is only present in the result object
         when language auto-detection is requested.
         * `translations`- An array of translation results. The size of the
         array matches the number of target languages specified in the `to`
         query parameter. Each element in the array includes.
         * `to` A string representing the language code of the target language.
         * `text`- A string giving the translated text.
         * `transliteration`- An object giving the translated text in the
         script specified by the `toScript` parameter.
         * `script`- A string specifying the target script.
         * `text`- A string giving the translated text in the target script.
         The `transliteration` object is not included if transliteration does
         not take place.
         *`alignment`- An object with a single string property named `proj`,
         which maps input text to translated text. The alignment information is
         only provided when the request parameter `includeAlignment` is `true`.
         Alignment is returned as a string value of the following format-
         `[[SourceTextStartIndex]-[SourceTextEndIndex]–[TgtTextStartIndex]-[TgtTextEndIndex]]`.
         The colon separates start and end index, the dash separates the
         languages, and space separates the words. One word may align with
         zero, one, or multiple words in the other language, and the aligned
         words may be non-contiguous. When no alignment information is
         available, the alignment element will be empty. See Obtain alignment
         information for an example and restrictions.
         * `sentLen`- An object returning sentence boundaries in the input and
         output texts.
         * `srcSentLen`- An integer array representing the lengths of the
         sentences in the input text. The length of the array is the number of
         sentences, and the values are the length of each sentence.
         * `transSentLen`- An integer array representing the lengths of the
         sentences in the translated text. The length of the array is the
         number of sentences, and the values are the length of each sentence.
         Sentence boundaries are only included when the request parameter
         `includeSentenceLength` is `true`.
         * `sourceText`- An object with a single string property named `text`,
         which gives the input text in the default script of the source
         language. `sourceText` property is present only when the input is
         expressed in a script that's not the usual script for the language.
         For example, if the input were Arabic written in Latin script, then
         `sourceText.text` would be the same Arabic text converted into Arab
         script.
         Example of JSON responses are provided in the examples section.
        :type text:
         list[~azure.cognitiveservices.translatortext.models.TranslateTextInput]
        :param from_parameter: Specifies the language of the input text. Find
         which languages are available to translate from by using the languages
         method. If the `from` parameter is not specified, automatic language
         detection is applied to determine the source language.
        :type from_parameter: str
        :param text_type: Defines whether the text being translated is plain
         text or HTML text. Any HTML needs to be a well-formed, complete HTML
         element. Possible values are `plain` (default) or `html`
         . Possible values include: 'plain', 'html'
        :type text_type: str
        :param category: A string specifying the category (domain) of the
         translation. This parameter retrieves translations from a customized
         system built with Custom Translator. Default value is `general`.
        :type category: str
        :param profanity_action: Specifies how profanities should be treated
         in translations. Possible values are: `NoAction` (default), `Marked`
         or `Deleted`.
         ### Handling Profanity
         Normally the Translator service will retain profanity that is present
         in the source in the translation. The degree of profanity and the
         context that makes words profane differ between cultures, and as a
         result the degree of profanity in the target language may be amplified
         or reduced.
         If you want to avoid getting profanity in the translation, regardless
         of the presence of profanity in the source text, you can use the
         profanity filtering option. The option allows you to choose whether
         you want to see profanity deleted, whether you want to mark
         profanities with appropriate tags (giving you the option to add your
         own post-processing), or you want no action taken. The accepted values
         of `ProfanityAction` are `Deleted`, `Marked` and `NoAction` (default).
         | ProfanityAction | Action
         |
         | ----------      | ----------
         |
         | `NoAction`      | This is the default behavior. Profanity will pass
         from source to target.  |
         |                 | Example Source (Japanese)- 彼はジャッカスです。
         |
         |                 | Example Translation (English)- He is a jackass.
         |
         |                 |
         |
         | `Deleted`       | Profane words will be removed from the output
         without replacement.        |
         |                 | Example Source (Japanese)- 彼はジャッカスです。
         |
         |                 | Example Translation (English)- He is a.
         |
         | `Marked`        | Profane words are replaced by a marker in the
         output. The marker depends on the `ProfanityMarker` parameter.
         |                 | For `ProfanityMarker=Asterisk`, profane words are
         replaced with `***`     |
         |                 | Example Source (Japanese)- 彼はジャッカスです。
         |
         |                 | Example Translation (English)- He is a ***.
         |
         |                 | For `ProfanityMarker=Tag`, profane words are
         surrounded by XML tags <profanity> and </profanity>
         |                 | Example Source (Japanese)- 彼はジャッカスです。
         |
         |                 | Example Translation (English)- He is a
         <profanity>jackass</profanity>.
         . Possible values include: 'NoAction', 'Marked', 'Deleted'
        :type profanity_action: str
        :param profanity_marker: Specifies how profanities should be marked in
         translations. Possible values are- `Asterisk` (default) or `Tag`.
        :type profanity_marker: str
        :param include_alignment: Specifies whether to include alignment
         projection from source text to translated text. Possible values are-
         `true` or `false` (default).
        :type include_alignment: bool
        :param include_sentence_length: Specifies whether to include sentence
         boundaries for the input text and the translated text. Possible values
         are- `true` or `false` (default).
        :type include_sentence_length: bool
        :param suggested_from: Specifies a fallback language if the language
         of the input text can't be identified. Language auto-detection is
         applied when the `from` parameter is omitted. If detection fails, the
         `suggestedFrom` language will be assumed.
        :type suggested_from: str
        :param from_script: Specifies the script of the input text. Supported
         scripts are available from the languages method
        :type from_script: str
        :param to_script: Specifies the script of the translated text.
         Supported scripts are available from the languages method
        :type to_script: list[str]
        :param x_client_trace_id: A client-generated GUID to uniquely identify
         the request. Note that you can omit this header if you include the
         trace ID in the query string using a query parameter named
         ClientTraceId.
        :type x_client_trace_id: str
        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :return: list or ClientRawResponse if raw=true
        :rtype:
         list[~azure.cognitiveservices.translatortext.models.TranslateResultAllItem]
         or ~msrest.pipeline.ClientRawResponse
        :raises:
         :class:`ErrorMessageException<azure.cognitiveservices.translatortext.models.ErrorMessageException>`
        """
        # Construct URL
        url = self.translate.metadata['url']
        path_format_arguments = {
            'Endpoint': self._serialize.url("self.config.endpoint", self.config.endpoint, 'str', skip_quote=True)
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}
        query_parameters['api-version'] = self._serialize.query("self.api_version", self.api_version, 'str')
        if from_parameter is not None:
            query_parameters['from'] = self._serialize.query("from_parameter", from_parameter, 'str')
        query_parameters['to'] = self._serialize.query("to", to, '[str]', div=',')
        if text_type is not None:
            query_parameters['textType'] = self._serialize.query("text_type", text_type, 'str')
        if category is not None:
            query_parameters['category'] = self._serialize.query("category", category, 'str')
        if profanity_action is not None:
            query_parameters['profanityAction'] = self._serialize.query("profanity_action", profanity_action, 'str')
        if profanity_marker is not None:
            query_parameters['profanityMarker'] = self._serialize.query("profanity_marker", profanity_marker, 'str')
        if include_alignment is not None:
            query_parameters['includeAlignment'] = self._serialize.query("include_alignment", include_alignment, 'bool')
        if include_sentence_length is not None:
            query_parameters['includeSentenceLength'] = self._serialize.query("include_sentence_length", include_sentence_length, 'bool')
        if suggested_from is not None:
            query_parameters['suggestedFrom'] = self._serialize.query("suggested_from", suggested_from, 'str')
        if from_script is not None:
            query_parameters['fromScript'] = self._serialize.query("from_script", from_script, 'str')
        if to_script is not None:
            query_parameters['toScript'] = self._serialize.query("to_script", to_script, '[str]', div=',')

        # Construct headers
        header_parameters = {}
        header_parameters['Accept'] = 'application/json'
        header_parameters['Content-Type'] = 'application/json; charset=utf-8'
        if custom_headers:
            header_parameters.update(custom_headers)
        if x_client_trace_id is not None:
            header_parameters['X-ClientTraceId'] = self._serialize.header("x_client_trace_id", x_client_trace_id, 'str')

        # Construct body
        body_content = self._serialize.body(text, '[TranslateTextInput]')

        # Construct and send request
        request = self._client.post(url, query_parameters, header_parameters, body_content)
        response = self._client.send(request, stream=False, **operation_config)

        if response.status_code not in [200]:
            raise models.ErrorMessageException(self._deserialize, response)

        deserialized = None
        if response.status_code == 200:
            deserialized = self._deserialize('[TranslateResultAllItem]', response)

        if raw:
            client_raw_response = ClientRawResponse(deserialized, response)
            return client_raw_response

        return deserialized
    translate.metadata = {'url': '/translate'}

    def transliterate(
            self, language, from_script, to_script, texts, x_client_trace_id=None, custom_headers=None, raw=False, **operation_config):
        """Converts the text of a language in one script into another type of
        script. Example-
        Japanese script "こんにちは"
        Same word in Latin script "konnichiha"
        .

        :param language: Specifies the language of the text to convert from
         one script to another. Possible languages are listed in the
         `transliteration` scope obtained by querying the service for its
         supported languages.
        :type language: str
        :param from_script: Specifies the script used by the input text.
         Lookup supported languages using the `transliteration` scope, to find
         input scripts available for the selected language.
        :type from_script: str
        :param to_script: Specifies the output script. Lookup supported
         languages using the `transliteration` scope, to find output scripts
         available for the selected combination of input language and input
         script.
        :type to_script: str
        :param texts: # Request body
         The body of the request is a JSON array. Each array element is a JSON
         object with a string property named `Text`, which represents the
         string to convert.
         The following limitations apply:
         * The array can have at most 10 elements.
         * The text value of an array element cannot exceed 1,000 characters
         including spaces.
         * The entire text included in the request cannot exceed 5,000
         characters including spaces.
         # Response body
         A successful response is a JSON array with one result for each element
         in the input array. A result object includes the following properties:
         * `text`- A string which is the result of converting the input string
         to the output script.
         * `script`- A string specifying the script used in the output.
        :type texts:
         list[~azure.cognitiveservices.translatortext.models.TransliterateTextInput]
        :param x_client_trace_id: A client-generated GUID to uniquely identify
         the request. Note that you can omit this header if you include the
         trace ID in the query string using a query parameter named
         ClientTraceId.
        :type x_client_trace_id: str
        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :return: list or ClientRawResponse if raw=true
        :rtype:
         list[~azure.cognitiveservices.translatortext.models.TransliterateResultItem]
         or ~msrest.pipeline.ClientRawResponse
        :raises:
         :class:`ErrorMessageException<azure.cognitiveservices.translatortext.models.ErrorMessageException>`
        """
        # Construct URL
        url = self.transliterate.metadata['url']
        path_format_arguments = {
            'Endpoint': self._serialize.url("self.config.endpoint", self.config.endpoint, 'str', skip_quote=True)
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}
        query_parameters['api-version'] = self._serialize.query("self.api_version", self.api_version, 'str')
        query_parameters['language'] = self._serialize.query("language", language, 'str')
        query_parameters['fromScript'] = self._serialize.query("from_script", from_script, 'str')
        query_parameters['toScript'] = self._serialize.query("to_script", to_script, 'str')

        # Construct headers
        header_parameters = {}
        header_parameters['Accept'] = 'application/json'
        header_parameters['Content-Type'] = 'application/json; charset=utf-8'
        if custom_headers:
            header_parameters.update(custom_headers)
        if x_client_trace_id is not None:
            header_parameters['X-ClientTraceId'] = self._serialize.header("x_client_trace_id", x_client_trace_id, 'str')

        # Construct body
        body_content = self._serialize.body(texts, '[TransliterateTextInput]')

        # Construct and send request
        request = self._client.post(url, query_parameters, header_parameters, body_content)
        response = self._client.send(request, stream=False, **operation_config)

        if response.status_code not in [200]:
            raise models.ErrorMessageException(self._deserialize, response)

        deserialized = None
        if response.status_code == 200:
            deserialized = self._deserialize('[TransliterateResultItem]', response)

        if raw:
            client_raw_response = ClientRawResponse(deserialized, response)
            return client_raw_response

        return deserialized
    transliterate.metadata = {'url': '/transliterate'}
