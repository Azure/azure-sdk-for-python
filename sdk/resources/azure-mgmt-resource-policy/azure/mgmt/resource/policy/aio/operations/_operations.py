# pylint: disable=too-many-lines
# coding=utf-8
# --------------------------------------------------------------------------
# Copyright (c) Microsoft Corporation. All rights reserved.
# Licensed under the MIT License. See License.txt in the project root for license information.
# Code generated by Microsoft (R) Python Code Generator.
# Changes may cause incorrect behavior and will be lost if the code is regenerated.
# --------------------------------------------------------------------------
from collections.abc import MutableMapping
from io import IOBase
import json
from typing import Any, Callable, IO, Optional, TypeVar, Union, overload
import urllib.parse

from azure.core import AsyncPipelineClient
from azure.core.async_paging import AsyncItemPaged, AsyncList
from azure.core.exceptions import (
    ClientAuthenticationError,
    HttpResponseError,
    ResourceExistsError,
    ResourceNotFoundError,
    ResourceNotModifiedError,
    StreamClosedError,
    StreamConsumedError,
    map_error,
)
from azure.core.pipeline import PipelineResponse
from azure.core.rest import AsyncHttpResponse, HttpRequest
from azure.core.tracing.decorator import distributed_trace
from azure.core.tracing.decorator_async import distributed_trace_async
from azure.core.utils import case_insensitive_dict
from azure.mgmt.core.exceptions import ARMErrorFormat

from ... import models as _models
from ..._utils.model_base import SdkJSONEncoder, _deserialize, _failsafe_deserialize
from ..._utils.serialization import Deserializer, Serializer
from ...operations._operations import (
    build_policy_assignments_create_request,
    build_policy_assignments_delete_request,
    build_policy_assignments_get_request,
    build_policy_assignments_list_for_management_group_request,
    build_policy_assignments_list_for_resource_group_request,
    build_policy_assignments_list_for_resource_request,
    build_policy_assignments_list_request,
    build_policy_assignments_update_request,
    build_policy_definition_versions_create_or_update_at_management_group_request,
    build_policy_definition_versions_create_or_update_request,
    build_policy_definition_versions_delete_at_management_group_request,
    build_policy_definition_versions_delete_request,
    build_policy_definition_versions_get_at_management_group_request,
    build_policy_definition_versions_get_built_in_request,
    build_policy_definition_versions_get_request,
    build_policy_definition_versions_list_all_at_management_group_request,
    build_policy_definition_versions_list_all_builtins_request,
    build_policy_definition_versions_list_all_request,
    build_policy_definition_versions_list_built_in_request,
    build_policy_definition_versions_list_by_management_group_request,
    build_policy_definition_versions_list_request,
    build_policy_definitions_create_or_update_at_management_group_request,
    build_policy_definitions_create_or_update_request,
    build_policy_definitions_delete_at_management_group_request,
    build_policy_definitions_delete_request,
    build_policy_definitions_get_at_management_group_request,
    build_policy_definitions_get_built_in_request,
    build_policy_definitions_get_request,
    build_policy_definitions_list_built_in_request,
    build_policy_definitions_list_by_management_group_request,
    build_policy_definitions_list_request,
    build_policy_set_definition_versions_create_or_update_at_management_group_request,
    build_policy_set_definition_versions_create_or_update_request,
    build_policy_set_definition_versions_delete_at_management_group_request,
    build_policy_set_definition_versions_delete_request,
    build_policy_set_definition_versions_get_at_management_group_request,
    build_policy_set_definition_versions_get_built_in_request,
    build_policy_set_definition_versions_get_request,
    build_policy_set_definition_versions_list_all_at_management_group_request,
    build_policy_set_definition_versions_list_all_builtins_request,
    build_policy_set_definition_versions_list_all_request,
    build_policy_set_definition_versions_list_built_in_request,
    build_policy_set_definition_versions_list_by_management_group_request,
    build_policy_set_definition_versions_list_request,
    build_policy_set_definitions_create_or_update_at_management_group_request,
    build_policy_set_definitions_create_or_update_request,
    build_policy_set_definitions_delete_at_management_group_request,
    build_policy_set_definitions_delete_request,
    build_policy_set_definitions_get_at_management_group_request,
    build_policy_set_definitions_get_built_in_request,
    build_policy_set_definitions_get_request,
    build_policy_set_definitions_list_built_in_request,
    build_policy_set_definitions_list_by_management_group_request,
    build_policy_set_definitions_list_request,
    build_policy_tokens_acquire_at_management_group_request,
    build_policy_tokens_acquire_request,
)
from .._configuration import PolicyClientConfiguration

JSON = MutableMapping[str, Any]
T = TypeVar("T")
ClsType = Optional[Callable[[PipelineResponse[HttpRequest, AsyncHttpResponse], T, dict[str, Any]], Any]]
List = list


class PolicyAssignmentsOperations:
    """
    .. warning::
        **DO NOT** instantiate this class directly.

        Instead, you should access the following operations through
        :class:`~azure.mgmt.resource.policy.aio.PolicyClient`'s
        :attr:`policy_assignments` attribute.
    """

    def __init__(self, *args, **kwargs) -> None:
        input_args = list(args)
        self._client: AsyncPipelineClient = input_args.pop(0) if input_args else kwargs.pop("client")
        self._config: PolicyClientConfiguration = input_args.pop(0) if input_args else kwargs.pop("config")
        self._serialize: Serializer = input_args.pop(0) if input_args else kwargs.pop("serializer")
        self._deserialize: Deserializer = input_args.pop(0) if input_args else kwargs.pop("deserializer")

    @distributed_trace_async
    async def get(
        self, scope: str, policy_assignment_name: str, *, expand: Optional[str] = None, **kwargs: Any
    ) -> _models.PolicyAssignment:
        """This operation retrieves a single policy assignment, given its name and the scope it was
        created at.

        :param scope: The fully qualified Azure Resource manager identifier of the resource. Required.
        :type scope: str
        :param policy_assignment_name: The name of the policy assignment to get. Required.
        :type policy_assignment_name: str
        :keyword expand: Comma-separated list of additional properties to be included in the response.
         Supported values are 'LatestDefinitionVersion, EffectiveDefinitionVersion'. Default value is
         None.
        :paramtype expand: str
        :return: PolicyAssignment. The PolicyAssignment is compatible with MutableMapping
        :rtype: ~azure.mgmt.resource.policy.models.PolicyAssignment
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[_models.PolicyAssignment] = kwargs.pop("cls", None)

        _request = build_policy_assignments_get_request(
            scope=scope,
            policy_assignment_name=policy_assignment_name,
            expand=expand,
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.base_url", self._config.base_url, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = kwargs.pop("stream", False)
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                try:
                    await response.read()  # Load the body in memory and close the socket
                except (StreamConsumedError, StreamClosedError):
                    pass
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = _failsafe_deserialize(
                _models.ErrorResponse,
                response,
            )
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        if _stream:
            deserialized = response.iter_bytes()
        else:
            deserialized = _deserialize(_models.PolicyAssignment, response.json())

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore

    @overload
    async def create(
        self,
        scope: str,
        policy_assignment_name: str,
        parameters: _models.PolicyAssignment,
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> _models.PolicyAssignment:
        """This operation creates or updates a policy assignment with the given scope and name. Policy
        assignments apply to all resources contained within their scope. For example, when you assign a
        policy at resource group scope, that policy applies to all resources in the group.

        :param scope: The fully qualified Azure Resource manager identifier of the resource. Required.
        :type scope: str
        :param policy_assignment_name: The name of the policy assignment to get. Required.
        :type policy_assignment_name: str
        :param parameters: Parameters for the policy assignment. Required.
        :type parameters: ~azure.mgmt.resource.policy.models.PolicyAssignment
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: PolicyAssignment. The PolicyAssignment is compatible with MutableMapping
        :rtype: ~azure.mgmt.resource.policy.models.PolicyAssignment
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @overload
    async def create(
        self,
        scope: str,
        policy_assignment_name: str,
        parameters: JSON,
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> _models.PolicyAssignment:
        """This operation creates or updates a policy assignment with the given scope and name. Policy
        assignments apply to all resources contained within their scope. For example, when you assign a
        policy at resource group scope, that policy applies to all resources in the group.

        :param scope: The fully qualified Azure Resource manager identifier of the resource. Required.
        :type scope: str
        :param policy_assignment_name: The name of the policy assignment to get. Required.
        :type policy_assignment_name: str
        :param parameters: Parameters for the policy assignment. Required.
        :type parameters: JSON
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: PolicyAssignment. The PolicyAssignment is compatible with MutableMapping
        :rtype: ~azure.mgmt.resource.policy.models.PolicyAssignment
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @overload
    async def create(
        self,
        scope: str,
        policy_assignment_name: str,
        parameters: IO[bytes],
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> _models.PolicyAssignment:
        """This operation creates or updates a policy assignment with the given scope and name. Policy
        assignments apply to all resources contained within their scope. For example, when you assign a
        policy at resource group scope, that policy applies to all resources in the group.

        :param scope: The fully qualified Azure Resource manager identifier of the resource. Required.
        :type scope: str
        :param policy_assignment_name: The name of the policy assignment to get. Required.
        :type policy_assignment_name: str
        :param parameters: Parameters for the policy assignment. Required.
        :type parameters: IO[bytes]
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: PolicyAssignment. The PolicyAssignment is compatible with MutableMapping
        :rtype: ~azure.mgmt.resource.policy.models.PolicyAssignment
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @distributed_trace_async
    async def create(
        self,
        scope: str,
        policy_assignment_name: str,
        parameters: Union[_models.PolicyAssignment, JSON, IO[bytes]],
        **kwargs: Any
    ) -> _models.PolicyAssignment:
        """This operation creates or updates a policy assignment with the given scope and name. Policy
        assignments apply to all resources contained within their scope. For example, when you assign a
        policy at resource group scope, that policy applies to all resources in the group.

        :param scope: The fully qualified Azure Resource manager identifier of the resource. Required.
        :type scope: str
        :param policy_assignment_name: The name of the policy assignment to get. Required.
        :type policy_assignment_name: str
        :param parameters: Parameters for the policy assignment. Is one of the following types:
         PolicyAssignment, JSON, IO[bytes] Required.
        :type parameters: ~azure.mgmt.resource.policy.models.PolicyAssignment or JSON or IO[bytes]
        :return: PolicyAssignment. The PolicyAssignment is compatible with MutableMapping
        :rtype: ~azure.mgmt.resource.policy.models.PolicyAssignment
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[_models.PolicyAssignment] = kwargs.pop("cls", None)

        content_type = content_type or "application/json"
        _content = None
        if isinstance(parameters, (IOBase, bytes)):
            _content = parameters
        else:
            _content = json.dumps(parameters, cls=SdkJSONEncoder, exclude_readonly=True)  # type: ignore

        _request = build_policy_assignments_create_request(
            scope=scope,
            policy_assignment_name=policy_assignment_name,
            content_type=content_type,
            api_version=self._config.api_version,
            content=_content,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.base_url", self._config.base_url, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = kwargs.pop("stream", False)
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [201]:
            if _stream:
                try:
                    await response.read()  # Load the body in memory and close the socket
                except (StreamConsumedError, StreamClosedError):
                    pass
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = _failsafe_deserialize(
                _models.ErrorResponse,
                response,
            )
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        if _stream:
            deserialized = response.iter_bytes()
        else:
            deserialized = _deserialize(_models.PolicyAssignment, response.json())

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore

    @overload
    async def update(
        self,
        scope: str,
        policy_assignment_name: str,
        parameters: _models.PolicyAssignmentUpdate,
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> _models.PolicyAssignment:
        """This operation updates a policy assignment with the given scope and name. Policy assignments
        apply to all resources contained within their scope. For example, when you assign a policy at
        resource group scope, that policy applies to all resources in the group.

        :param scope: The fully qualified Azure Resource manager identifier of the resource. Required.
        :type scope: str
        :param policy_assignment_name: The name of the policy assignment to get. Required.
        :type policy_assignment_name: str
        :param parameters: Parameters for policy assignment patch request. Required.
        :type parameters: ~azure.mgmt.resource.policy.models.PolicyAssignmentUpdate
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: PolicyAssignment. The PolicyAssignment is compatible with MutableMapping
        :rtype: ~azure.mgmt.resource.policy.models.PolicyAssignment
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @overload
    async def update(
        self,
        scope: str,
        policy_assignment_name: str,
        parameters: JSON,
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> _models.PolicyAssignment:
        """This operation updates a policy assignment with the given scope and name. Policy assignments
        apply to all resources contained within their scope. For example, when you assign a policy at
        resource group scope, that policy applies to all resources in the group.

        :param scope: The fully qualified Azure Resource manager identifier of the resource. Required.
        :type scope: str
        :param policy_assignment_name: The name of the policy assignment to get. Required.
        :type policy_assignment_name: str
        :param parameters: Parameters for policy assignment patch request. Required.
        :type parameters: JSON
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: PolicyAssignment. The PolicyAssignment is compatible with MutableMapping
        :rtype: ~azure.mgmt.resource.policy.models.PolicyAssignment
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @overload
    async def update(
        self,
        scope: str,
        policy_assignment_name: str,
        parameters: IO[bytes],
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> _models.PolicyAssignment:
        """This operation updates a policy assignment with the given scope and name. Policy assignments
        apply to all resources contained within their scope. For example, when you assign a policy at
        resource group scope, that policy applies to all resources in the group.

        :param scope: The fully qualified Azure Resource manager identifier of the resource. Required.
        :type scope: str
        :param policy_assignment_name: The name of the policy assignment to get. Required.
        :type policy_assignment_name: str
        :param parameters: Parameters for policy assignment patch request. Required.
        :type parameters: IO[bytes]
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: PolicyAssignment. The PolicyAssignment is compatible with MutableMapping
        :rtype: ~azure.mgmt.resource.policy.models.PolicyAssignment
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @distributed_trace_async
    async def update(
        self,
        scope: str,
        policy_assignment_name: str,
        parameters: Union[_models.PolicyAssignmentUpdate, JSON, IO[bytes]],
        **kwargs: Any
    ) -> _models.PolicyAssignment:
        """This operation updates a policy assignment with the given scope and name. Policy assignments
        apply to all resources contained within their scope. For example, when you assign a policy at
        resource group scope, that policy applies to all resources in the group.

        :param scope: The fully qualified Azure Resource manager identifier of the resource. Required.
        :type scope: str
        :param policy_assignment_name: The name of the policy assignment to get. Required.
        :type policy_assignment_name: str
        :param parameters: Parameters for policy assignment patch request. Is one of the following
         types: PolicyAssignmentUpdate, JSON, IO[bytes] Required.
        :type parameters: ~azure.mgmt.resource.policy.models.PolicyAssignmentUpdate or JSON or
         IO[bytes]
        :return: PolicyAssignment. The PolicyAssignment is compatible with MutableMapping
        :rtype: ~azure.mgmt.resource.policy.models.PolicyAssignment
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[_models.PolicyAssignment] = kwargs.pop("cls", None)

        content_type = content_type or "application/json"
        _content = None
        if isinstance(parameters, (IOBase, bytes)):
            _content = parameters
        else:
            _content = json.dumps(parameters, cls=SdkJSONEncoder, exclude_readonly=True)  # type: ignore

        _request = build_policy_assignments_update_request(
            scope=scope,
            policy_assignment_name=policy_assignment_name,
            content_type=content_type,
            api_version=self._config.api_version,
            content=_content,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.base_url", self._config.base_url, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = kwargs.pop("stream", False)
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                try:
                    await response.read()  # Load the body in memory and close the socket
                except (StreamConsumedError, StreamClosedError):
                    pass
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = _failsafe_deserialize(
                _models.ErrorResponse,
                response,
            )
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        if _stream:
            deserialized = response.iter_bytes()
        else:
            deserialized = _deserialize(_models.PolicyAssignment, response.json())

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore

    @distributed_trace_async
    async def delete(
        self, scope: str, policy_assignment_name: str, **kwargs: Any
    ) -> Optional[_models.PolicyAssignment]:
        """This operation deletes a policy assignment, given its name and the scope it was created in. The
        scope of a policy assignment is the part of its ID preceding
        '/providers/Microsoft.Authorization/policyAssignments/{policyAssignmentName}'.

        :param scope: The fully qualified Azure Resource manager identifier of the resource. Required.
        :type scope: str
        :param policy_assignment_name: The name of the policy assignment to get. Required.
        :type policy_assignment_name: str
        :return: PolicyAssignment or None. The PolicyAssignment is compatible with MutableMapping
        :rtype: ~azure.mgmt.resource.policy.models.PolicyAssignment or None
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[Optional[_models.PolicyAssignment]] = kwargs.pop("cls", None)

        _request = build_policy_assignments_delete_request(
            scope=scope,
            policy_assignment_name=policy_assignment_name,
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.base_url", self._config.base_url, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = kwargs.pop("stream", False)
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200, 204]:
            if _stream:
                try:
                    await response.read()  # Load the body in memory and close the socket
                except (StreamConsumedError, StreamClosedError):
                    pass
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = _failsafe_deserialize(
                _models.ErrorResponse,
                response,
            )
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        deserialized = None
        if response.status_code == 200:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.PolicyAssignment, response.json())

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore

    @distributed_trace
    def list_for_resource_group(
        self,
        resource_group_name: str,
        *,
        filter: Optional[str] = None,
        expand: Optional[str] = None,
        top: Optional[int] = None,
        **kwargs: Any
    ) -> AsyncItemPaged["_models.PolicyAssignment"]:
        """This operation retrieves the list of all policy assignments associated with the given resource
        group in the given subscription that match the optional given $filter. Valid values for $filter
        are: 'atScope()', 'atExactScope()' or 'policyDefinitionId eq '{value}''. If $filter is not
        provided, the unfiltered list includes all policy assignments associated with the resource
        group, including those that apply directly or apply from containing scopes, as well as any
        applied to resources contained within the resource group. If $filter=atScope() is provided, the
        returned list includes all policy assignments that apply to the resource group, which is
        everything in the unfiltered list except those applied to resources contained within the
        resource group. If $filter=atExactScope() is provided, the returned list only includes all
        policy assignments that at the resource group. If $filter=policyDefinitionId eq '{value}' is
        provided, the returned list includes all policy assignments of the policy definition whose id
        is {value} that apply to the resource group.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :keyword filter: The filter to apply on the operation. Valid values for $filter are:
         'atScope()', 'atExactScope()' or 'policyDefinitionId eq '{value}''. If $filter is not provided,
         no filtering is performed. If $filter=atScope() is provided, the returned list only includes
         all policy assignments that apply to the scope, which is everything in the unfiltered list
         except those applied to sub scopes contained within the given scope. If $filter=atExactScope()
         is provided, the returned list only includes all policy assignments that at the given scope. If
         $filter=policyDefinitionId eq '{value}' is provided, the returned list includes all policy
         assignments of the policy definition whose id is {value}. Default value is None.
        :paramtype filter: str
        :keyword expand: Comma-separated list of additional properties to be included in the response.
         Supported values are 'LatestDefinitionVersion, EffectiveDefinitionVersion'. Default value is
         None.
        :paramtype expand: str
        :keyword top: Maximum number of records to return. When the $top filter is not provided, it
         will return 500 records. Default value is None.
        :paramtype top: int
        :return: An iterator like instance of PolicyAssignment
        :rtype:
         ~azure.core.async_paging.AsyncItemPaged[~azure.mgmt.resource.policy.models.PolicyAssignment]
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[List[_models.PolicyAssignment]] = kwargs.pop("cls", None)

        error_map: MutableMapping = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        def prepare_request(next_link=None):
            if not next_link:

                _request = build_policy_assignments_list_for_resource_group_request(
                    resource_group_name=resource_group_name,
                    subscription_id=self._config.subscription_id,
                    filter=filter,
                    expand=expand,
                    top=top,
                    api_version=self._config.api_version,
                    headers=_headers,
                    params=_params,
                )
                path_format_arguments = {
                    "endpoint": self._serialize.url(
                        "self._config.base_url", self._config.base_url, "str", skip_quote=True
                    ),
                }
                _request.url = self._client.format_url(_request.url, **path_format_arguments)

            else:
                # make call to next link with the client's api-version
                _parsed_next_link = urllib.parse.urlparse(next_link)
                _next_request_params = case_insensitive_dict(
                    {
                        key: [urllib.parse.quote(v) for v in value]
                        for key, value in urllib.parse.parse_qs(_parsed_next_link.query).items()
                    }
                )
                _next_request_params["api-version"] = self._config.api_version
                _request = HttpRequest(
                    "GET", urllib.parse.urljoin(next_link, _parsed_next_link.path), params=_next_request_params
                )
                path_format_arguments = {
                    "endpoint": self._serialize.url(
                        "self._config.base_url", self._config.base_url, "str", skip_quote=True
                    ),
                }
                _request.url = self._client.format_url(_request.url, **path_format_arguments)

            return _request

        async def extract_data(pipeline_response):
            deserialized = pipeline_response.http_response.json()
            list_of_elem = _deserialize(List[_models.PolicyAssignment], deserialized.get("value", []))
            if cls:
                list_of_elem = cls(list_of_elem)  # type: ignore
            return deserialized.get("nextLink") or None, AsyncList(list_of_elem)

        async def get_next(next_link=None):
            _request = prepare_request(next_link)

            _stream = False
            pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
                _request, stream=_stream, **kwargs
            )
            response = pipeline_response.http_response

            if response.status_code not in [200]:
                map_error(status_code=response.status_code, response=response, error_map=error_map)
                error = _failsafe_deserialize(
                    _models.ErrorResponse,
                    response,
                )
                raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

            return pipeline_response

        return AsyncItemPaged(get_next, extract_data)

    @distributed_trace
    def list_for_management_group(
        self,
        management_group_id: str,
        *,
        filter: Optional[str] = None,
        expand: Optional[str] = None,
        top: Optional[int] = None,
        **kwargs: Any
    ) -> AsyncItemPaged["_models.PolicyAssignment"]:
        """Retrieves all policy assignments that apply to a management group.

        This operation retrieves the list of all policy assignments applicable to the management group
        that match the given $filter. Valid values for $filter are: 'atScope()', 'atExactScope()' or
        'policyDefinitionId eq '{value}''. If $filter=atScope() is provided, the returned list includes
        all policy assignments that are assigned to the management group or the management group's
        ancestors. If $filter=atExactScope() is provided, the returned list only includes all policy
        assignments that at the management group. If $filter=policyDefinitionId eq '{value}' is
        provided, the returned list includes all policy assignments of the policy definition whose id
        is {value} that apply to the management group.

        :param management_group_id: The management group ID. Required.
        :type management_group_id: str
        :keyword filter: The filter to apply on the operation. Valid values for $filter are:
         'atScope()', 'atExactScope()' or 'policyDefinitionId eq '{value}''. If $filter is not provided,
         no filtering is performed. If $filter=atScope() is provided, the returned list only includes
         all policy assignments that apply to the scope, which is everything in the unfiltered list
         except those applied to sub scopes contained within the given scope. If $filter=atExactScope()
         is provided, the returned list only includes all policy assignments that at the given scope. If
         $filter=policyDefinitionId eq '{value}' is provided, the returned list includes all policy
         assignments of the policy definition whose id is {value}. Default value is None.
        :paramtype filter: str
        :keyword expand: Comma-separated list of additional properties to be included in the response.
         Supported values are 'LatestDefinitionVersion, EffectiveDefinitionVersion'. Default value is
         None.
        :paramtype expand: str
        :keyword top: Maximum number of records to return. When the $top filter is not provided, it
         will return 500 records. Default value is None.
        :paramtype top: int
        :return: An iterator like instance of PolicyAssignment
        :rtype:
         ~azure.core.async_paging.AsyncItemPaged[~azure.mgmt.resource.policy.models.PolicyAssignment]
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[List[_models.PolicyAssignment]] = kwargs.pop("cls", None)

        error_map: MutableMapping = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        def prepare_request(next_link=None):
            if not next_link:

                _request = build_policy_assignments_list_for_management_group_request(
                    management_group_id=management_group_id,
                    filter=filter,
                    expand=expand,
                    top=top,
                    api_version=self._config.api_version,
                    headers=_headers,
                    params=_params,
                )
                path_format_arguments = {
                    "endpoint": self._serialize.url(
                        "self._config.base_url", self._config.base_url, "str", skip_quote=True
                    ),
                }
                _request.url = self._client.format_url(_request.url, **path_format_arguments)

            else:
                # make call to next link with the client's api-version
                _parsed_next_link = urllib.parse.urlparse(next_link)
                _next_request_params = case_insensitive_dict(
                    {
                        key: [urllib.parse.quote(v) for v in value]
                        for key, value in urllib.parse.parse_qs(_parsed_next_link.query).items()
                    }
                )
                _next_request_params["api-version"] = self._config.api_version
                _request = HttpRequest(
                    "GET", urllib.parse.urljoin(next_link, _parsed_next_link.path), params=_next_request_params
                )
                path_format_arguments = {
                    "endpoint": self._serialize.url(
                        "self._config.base_url", self._config.base_url, "str", skip_quote=True
                    ),
                }
                _request.url = self._client.format_url(_request.url, **path_format_arguments)

            return _request

        async def extract_data(pipeline_response):
            deserialized = pipeline_response.http_response.json()
            list_of_elem = _deserialize(List[_models.PolicyAssignment], deserialized.get("value", []))
            if cls:
                list_of_elem = cls(list_of_elem)  # type: ignore
            return deserialized.get("nextLink") or None, AsyncList(list_of_elem)

        async def get_next(next_link=None):
            _request = prepare_request(next_link)

            _stream = False
            pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
                _request, stream=_stream, **kwargs
            )
            response = pipeline_response.http_response

            if response.status_code not in [200]:
                map_error(status_code=response.status_code, response=response, error_map=error_map)
                error = _failsafe_deserialize(
                    _models.ErrorResponse,
                    response,
                )
                raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

            return pipeline_response

        return AsyncItemPaged(get_next, extract_data)

    @distributed_trace
    def list(
        self, *, filter: Optional[str] = None, expand: Optional[str] = None, top: Optional[int] = None, **kwargs: Any
    ) -> AsyncItemPaged["_models.PolicyAssignment"]:
        """Retrieves all policy assignments that apply to a subscription.

        This operation retrieves the list of all policy assignments associated with the given
        subscription that match the optional given $filter. Valid values for $filter are: 'atScope()',
        'atExactScope()' or 'policyDefinitionId eq '{value}''. If $filter is not provided, the
        unfiltered list includes all policy assignments associated with the subscription, including
        those that apply directly or from management groups that contain the given subscription, as
        well as any applied to objects contained within the subscription. If $filter=atScope() is
        provided, the returned list includes all policy assignments that apply to the subscription,
        which is everything in the unfiltered list except those applied to objects contained within the
        subscription. If $filter=atExactScope() is provided, the returned list only includes all policy
        assignments that at the subscription. If $filter=policyDefinitionId eq '{value}' is provided,
        the returned list includes all policy assignments of the policy definition whose id is {value}.

        :keyword filter: The filter to apply on the operation. Valid values for $filter are:
         'atScope()', 'atExactScope()' or 'policyDefinitionId eq '{value}''. If $filter is not provided,
         no filtering is performed. If $filter=atScope() is provided, the returned list only includes
         all policy assignments that apply to the scope, which is everything in the unfiltered list
         except those applied to sub scopes contained within the given scope. If $filter=atExactScope()
         is provided, the returned list only includes all policy assignments that at the given scope. If
         $filter=policyDefinitionId eq '{value}' is provided, the returned list includes all policy
         assignments of the policy definition whose id is {value}. Default value is None.
        :paramtype filter: str
        :keyword expand: Comma-separated list of additional properties to be included in the response.
         Supported values are 'LatestDefinitionVersion, EffectiveDefinitionVersion'. Default value is
         None.
        :paramtype expand: str
        :keyword top: Maximum number of records to return. When the $top filter is not provided, it
         will return 500 records. Default value is None.
        :paramtype top: int
        :return: An iterator like instance of PolicyAssignment
        :rtype:
         ~azure.core.async_paging.AsyncItemPaged[~azure.mgmt.resource.policy.models.PolicyAssignment]
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[List[_models.PolicyAssignment]] = kwargs.pop("cls", None)

        error_map: MutableMapping = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        def prepare_request(next_link=None):
            if not next_link:

                _request = build_policy_assignments_list_request(
                    subscription_id=self._config.subscription_id,
                    filter=filter,
                    expand=expand,
                    top=top,
                    api_version=self._config.api_version,
                    headers=_headers,
                    params=_params,
                )
                path_format_arguments = {
                    "endpoint": self._serialize.url(
                        "self._config.base_url", self._config.base_url, "str", skip_quote=True
                    ),
                }
                _request.url = self._client.format_url(_request.url, **path_format_arguments)

            else:
                # make call to next link with the client's api-version
                _parsed_next_link = urllib.parse.urlparse(next_link)
                _next_request_params = case_insensitive_dict(
                    {
                        key: [urllib.parse.quote(v) for v in value]
                        for key, value in urllib.parse.parse_qs(_parsed_next_link.query).items()
                    }
                )
                _next_request_params["api-version"] = self._config.api_version
                _request = HttpRequest(
                    "GET", urllib.parse.urljoin(next_link, _parsed_next_link.path), params=_next_request_params
                )
                path_format_arguments = {
                    "endpoint": self._serialize.url(
                        "self._config.base_url", self._config.base_url, "str", skip_quote=True
                    ),
                }
                _request.url = self._client.format_url(_request.url, **path_format_arguments)

            return _request

        async def extract_data(pipeline_response):
            deserialized = pipeline_response.http_response.json()
            list_of_elem = _deserialize(List[_models.PolicyAssignment], deserialized.get("value", []))
            if cls:
                list_of_elem = cls(list_of_elem)  # type: ignore
            return deserialized.get("nextLink") or None, AsyncList(list_of_elem)

        async def get_next(next_link=None):
            _request = prepare_request(next_link)

            _stream = False
            pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
                _request, stream=_stream, **kwargs
            )
            response = pipeline_response.http_response

            if response.status_code not in [200]:
                map_error(status_code=response.status_code, response=response, error_map=error_map)
                error = _failsafe_deserialize(
                    _models.ErrorResponse,
                    response,
                )
                raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

            return pipeline_response

        return AsyncItemPaged(get_next, extract_data)

    @distributed_trace
    def list_for_resource(
        self,
        resource_group_name: str,
        resource_provider_namespace: str,
        parent_resource_path: str,
        resource_type: str,
        resource_name: str,
        *,
        filter: Optional[str] = None,
        expand: Optional[str] = None,
        top: Optional[int] = None,
        **kwargs: Any
    ) -> AsyncItemPaged["_models.PolicyAssignment"]:
        """Retrieves all policy assignments that apply to a resource.

        This operation retrieves the list of all policy assignments associated with the specified
        resource in the given resource group and subscription that match the optional given $filter.
        Valid values for $filter are: 'atScope()', 'atExactScope()' or 'policyDefinitionId eq
        '{value}''. If $filter is not provided, the unfiltered list includes all policy assignments
        associated with the resource, including those that apply directly or from all containing
        scopes, as well as any applied to resources contained within the resource. If $filter=atScope()
        is provided, the returned list includes all policy assignments that apply to the resource,
        which is everything in the unfiltered list except those applied to resources contained within
        the resource. If $filter=atExactScope() is provided, the returned list only includes all policy
        assignments that at the resource level. If $filter=policyDefinitionId eq '{value}' is provided,
        the returned list includes all policy assignments of the policy definition whose id is {value}
        that apply to the resource. Three parameters plus the resource name are used to identify a
        specific resource. If the resource is not part of a parent resource (the more common case), the
        parent resource path should not be provided (or provided as ''). For example a web app could be
        specified as ({resourceProviderNamespace} == 'Microsoft.Web', {parentResourcePath} == '',
        {resourceType} == 'sites', {resourceName} == 'MyWebApp'). If the resource is part of a parent
        resource, then all parameters should be provided. For example a virtual machine DNS name could
        be specified as ({resourceProviderNamespace} == 'Microsoft.Compute', {parentResourcePath} ==
        'virtualMachines/MyVirtualMachine', {resourceType} == 'domainNames', {resourceName} ==
        'MyComputerName'). A convenient alternative to providing the namespace and type name separately
        is to provide both in the {resourceType} parameter, format: ({resourceProviderNamespace} == '',
        {parentResourcePath} == '', {resourceType} == 'Microsoft.Web/sites', {resourceName} ==
        'MyWebApp').

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param resource_provider_namespace: The namespace of the resource provider. For example, the
         namespace of a virtual machine is Microsoft.Compute (from Microsoft.Compute/virtualMachines).
         Required.
        :type resource_provider_namespace: str
        :param parent_resource_path: The parent resource path. Use empty string if there is none.
         Required.
        :type parent_resource_path: str
        :param resource_type: The resource type name. For example the type name of a web app is 'sites'
         (from Microsoft.Web/sites). Required.
        :type resource_type: str
        :param resource_name: The name of the resource. Required.
        :type resource_name: str
        :keyword filter: The filter to apply on the operation. Valid values for $filter are:
         'atScope()', 'atExactScope()' or 'policyDefinitionId eq '{value}''. If $filter is not provided,
         no filtering is performed. If $filter=atScope() is provided, the returned list only includes
         all policy assignments that apply to the scope, which is everything in the unfiltered list
         except those applied to sub scopes contained within the given scope. If $filter=atExactScope()
         is provided, the returned list only includes all policy assignments that at the given scope. If
         $filter=policyDefinitionId eq '{value}' is provided, the returned list includes all policy
         assignments of the policy definition whose id is {value}. Default value is None.
        :paramtype filter: str
        :keyword expand: Comma-separated list of additional properties to be included in the response.
         Supported values are 'LatestDefinitionVersion, EffectiveDefinitionVersion'. Default value is
         None.
        :paramtype expand: str
        :keyword top: Maximum number of records to return. When the $top filter is not provided, it
         will return 500 records. Default value is None.
        :paramtype top: int
        :return: An iterator like instance of PolicyAssignment
        :rtype:
         ~azure.core.async_paging.AsyncItemPaged[~azure.mgmt.resource.policy.models.PolicyAssignment]
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[List[_models.PolicyAssignment]] = kwargs.pop("cls", None)

        error_map: MutableMapping = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        def prepare_request(next_link=None):
            if not next_link:

                _request = build_policy_assignments_list_for_resource_request(
                    resource_group_name=resource_group_name,
                    resource_provider_namespace=resource_provider_namespace,
                    parent_resource_path=parent_resource_path,
                    resource_type=resource_type,
                    resource_name=resource_name,
                    subscription_id=self._config.subscription_id,
                    filter=filter,
                    expand=expand,
                    top=top,
                    api_version=self._config.api_version,
                    headers=_headers,
                    params=_params,
                )
                path_format_arguments = {
                    "endpoint": self._serialize.url(
                        "self._config.base_url", self._config.base_url, "str", skip_quote=True
                    ),
                }
                _request.url = self._client.format_url(_request.url, **path_format_arguments)

            else:
                # make call to next link with the client's api-version
                _parsed_next_link = urllib.parse.urlparse(next_link)
                _next_request_params = case_insensitive_dict(
                    {
                        key: [urllib.parse.quote(v) for v in value]
                        for key, value in urllib.parse.parse_qs(_parsed_next_link.query).items()
                    }
                )
                _next_request_params["api-version"] = self._config.api_version
                _request = HttpRequest(
                    "GET", urllib.parse.urljoin(next_link, _parsed_next_link.path), params=_next_request_params
                )
                path_format_arguments = {
                    "endpoint": self._serialize.url(
                        "self._config.base_url", self._config.base_url, "str", skip_quote=True
                    ),
                }
                _request.url = self._client.format_url(_request.url, **path_format_arguments)

            return _request

        async def extract_data(pipeline_response):
            deserialized = pipeline_response.http_response.json()
            list_of_elem = _deserialize(List[_models.PolicyAssignment], deserialized.get("value", []))
            if cls:
                list_of_elem = cls(list_of_elem)  # type: ignore
            return deserialized.get("nextLink") or None, AsyncList(list_of_elem)

        async def get_next(next_link=None):
            _request = prepare_request(next_link)

            _stream = False
            pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
                _request, stream=_stream, **kwargs
            )
            response = pipeline_response.http_response

            if response.status_code not in [200]:
                map_error(status_code=response.status_code, response=response, error_map=error_map)
                error = _failsafe_deserialize(
                    _models.ErrorResponse,
                    response,
                )
                raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

            return pipeline_response

        return AsyncItemPaged(get_next, extract_data)


class PolicyDefinitionsOperations:
    """
    .. warning::
        **DO NOT** instantiate this class directly.

        Instead, you should access the following operations through
        :class:`~azure.mgmt.resource.policy.aio.PolicyClient`'s
        :attr:`policy_definitions` attribute.
    """

    def __init__(self, *args, **kwargs) -> None:
        input_args = list(args)
        self._client: AsyncPipelineClient = input_args.pop(0) if input_args else kwargs.pop("client")
        self._config: PolicyClientConfiguration = input_args.pop(0) if input_args else kwargs.pop("config")
        self._serialize: Serializer = input_args.pop(0) if input_args else kwargs.pop("serializer")
        self._deserialize: Deserializer = input_args.pop(0) if input_args else kwargs.pop("deserializer")

    @distributed_trace_async
    async def get(self, policy_definition_name: str, **kwargs: Any) -> _models.PolicyDefinition:
        """This operation retrieves the policy definition in the given subscription with the given name.

        :param policy_definition_name: The name of the policy definition to get. Required.
        :type policy_definition_name: str
        :return: PolicyDefinition. The PolicyDefinition is compatible with MutableMapping
        :rtype: ~azure.mgmt.resource.policy.models.PolicyDefinition
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[_models.PolicyDefinition] = kwargs.pop("cls", None)

        _request = build_policy_definitions_get_request(
            policy_definition_name=policy_definition_name,
            subscription_id=self._config.subscription_id,
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.base_url", self._config.base_url, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = kwargs.pop("stream", False)
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                try:
                    await response.read()  # Load the body in memory and close the socket
                except (StreamConsumedError, StreamClosedError):
                    pass
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = _failsafe_deserialize(
                _models.ErrorResponse,
                response,
            )
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        if _stream:
            deserialized = response.iter_bytes()
        else:
            deserialized = _deserialize(_models.PolicyDefinition, response.json())

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore

    @overload
    async def create_or_update(
        self,
        policy_definition_name: str,
        parameters: _models.PolicyDefinition,
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> _models.PolicyDefinition:
        """This operation creates or updates a policy definition in the given subscription with the given
        name.

        :param policy_definition_name: The name of the policy definition to get. Required.
        :type policy_definition_name: str
        :param parameters: The policy definition properties. Required.
        :type parameters: ~azure.mgmt.resource.policy.models.PolicyDefinition
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: PolicyDefinition. The PolicyDefinition is compatible with MutableMapping
        :rtype: ~azure.mgmt.resource.policy.models.PolicyDefinition
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @overload
    async def create_or_update(
        self, policy_definition_name: str, parameters: JSON, *, content_type: str = "application/json", **kwargs: Any
    ) -> _models.PolicyDefinition:
        """This operation creates or updates a policy definition in the given subscription with the given
        name.

        :param policy_definition_name: The name of the policy definition to get. Required.
        :type policy_definition_name: str
        :param parameters: The policy definition properties. Required.
        :type parameters: JSON
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: PolicyDefinition. The PolicyDefinition is compatible with MutableMapping
        :rtype: ~azure.mgmt.resource.policy.models.PolicyDefinition
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @overload
    async def create_or_update(
        self,
        policy_definition_name: str,
        parameters: IO[bytes],
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> _models.PolicyDefinition:
        """This operation creates or updates a policy definition in the given subscription with the given
        name.

        :param policy_definition_name: The name of the policy definition to get. Required.
        :type policy_definition_name: str
        :param parameters: The policy definition properties. Required.
        :type parameters: IO[bytes]
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: PolicyDefinition. The PolicyDefinition is compatible with MutableMapping
        :rtype: ~azure.mgmt.resource.policy.models.PolicyDefinition
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @distributed_trace_async
    async def create_or_update(
        self, policy_definition_name: str, parameters: Union[_models.PolicyDefinition, JSON, IO[bytes]], **kwargs: Any
    ) -> _models.PolicyDefinition:
        """This operation creates or updates a policy definition in the given subscription with the given
        name.

        :param policy_definition_name: The name of the policy definition to get. Required.
        :type policy_definition_name: str
        :param parameters: The policy definition properties. Is one of the following types:
         PolicyDefinition, JSON, IO[bytes] Required.
        :type parameters: ~azure.mgmt.resource.policy.models.PolicyDefinition or JSON or IO[bytes]
        :return: PolicyDefinition. The PolicyDefinition is compatible with MutableMapping
        :rtype: ~azure.mgmt.resource.policy.models.PolicyDefinition
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[_models.PolicyDefinition] = kwargs.pop("cls", None)

        content_type = content_type or "application/json"
        _content = None
        if isinstance(parameters, (IOBase, bytes)):
            _content = parameters
        else:
            _content = json.dumps(parameters, cls=SdkJSONEncoder, exclude_readonly=True)  # type: ignore

        _request = build_policy_definitions_create_or_update_request(
            policy_definition_name=policy_definition_name,
            subscription_id=self._config.subscription_id,
            content_type=content_type,
            api_version=self._config.api_version,
            content=_content,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.base_url", self._config.base_url, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = kwargs.pop("stream", False)
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [201]:
            if _stream:
                try:
                    await response.read()  # Load the body in memory and close the socket
                except (StreamConsumedError, StreamClosedError):
                    pass
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = _failsafe_deserialize(
                _models.ErrorResponse,
                response,
            )
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        if _stream:
            deserialized = response.iter_bytes()
        else:
            deserialized = _deserialize(_models.PolicyDefinition, response.json())

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore

    @distributed_trace_async
    async def delete(self, policy_definition_name: str, **kwargs: Any) -> None:
        """This operation deletes the policy definition in the given subscription with the given name.

        :param policy_definition_name: The name of the policy definition to get. Required.
        :type policy_definition_name: str
        :return: None
        :rtype: None
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[None] = kwargs.pop("cls", None)

        _request = build_policy_definitions_delete_request(
            policy_definition_name=policy_definition_name,
            subscription_id=self._config.subscription_id,
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.base_url", self._config.base_url, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = False
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200, 204]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = _failsafe_deserialize(
                _models.ErrorResponse,
                response,
            )
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        if cls:
            return cls(pipeline_response, None, {})  # type: ignore

    @distributed_trace
    def list(
        self, *, filter: Optional[str] = None, top: Optional[int] = None, **kwargs: Any
    ) -> AsyncItemPaged["_models.PolicyDefinition"]:
        """This operation retrieves a list of all the policy definitions in a given subscription that
        match the optional given $filter. Valid values for $filter are: 'atExactScope()', 'policyType
        -eq {value}' or 'category eq '{value}''. If $filter is not provided, the unfiltered list
        includes all policy definitions associated with the subscription, including those that apply
        directly or from management groups that contain the given subscription. If
        $filter=atExactScope() is provided, the returned list only includes all policy definitions that
        at the given subscription. If $filter='policyType -eq {value}' is provided, the returned list
        only includes all policy definitions whose type match the {value}. Possible policyType values
        are NotSpecified, BuiltIn, Custom, and Static. If $filter='category -eq {value}' is provided,
        the returned list only includes all policy definitions whose category match the {value}.

        :keyword filter: The filter to apply on the operation. Valid values for $filter are:
         'atExactScope()', 'policyType -eq {value}' or 'category eq '{value}''. If $filter is not
         provided, no filtering is performed. If $filter=atExactScope() is provided, the returned list
         only includes all policy definitions that at the given scope. If $filter='policyType -eq
         {value}' is provided, the returned list only includes all policy definitions whose type match
         the {value}. Possible policyType values are NotSpecified, BuiltIn, Custom, and Static. If
         $filter='category -eq {value}' is provided, the returned list only includes all policy
         definitions whose category match the {value}. Default value is None.
        :paramtype filter: str
        :keyword top: Maximum number of records to return. When the $top filter is not provided, it
         will return 500 records. Default value is None.
        :paramtype top: int
        :return: An iterator like instance of PolicyDefinition
        :rtype:
         ~azure.core.async_paging.AsyncItemPaged[~azure.mgmt.resource.policy.models.PolicyDefinition]
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[List[_models.PolicyDefinition]] = kwargs.pop("cls", None)

        error_map: MutableMapping = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        def prepare_request(next_link=None):
            if not next_link:

                _request = build_policy_definitions_list_request(
                    subscription_id=self._config.subscription_id,
                    filter=filter,
                    top=top,
                    api_version=self._config.api_version,
                    headers=_headers,
                    params=_params,
                )
                path_format_arguments = {
                    "endpoint": self._serialize.url(
                        "self._config.base_url", self._config.base_url, "str", skip_quote=True
                    ),
                }
                _request.url = self._client.format_url(_request.url, **path_format_arguments)

            else:
                # make call to next link with the client's api-version
                _parsed_next_link = urllib.parse.urlparse(next_link)
                _next_request_params = case_insensitive_dict(
                    {
                        key: [urllib.parse.quote(v) for v in value]
                        for key, value in urllib.parse.parse_qs(_parsed_next_link.query).items()
                    }
                )
                _next_request_params["api-version"] = self._config.api_version
                _request = HttpRequest(
                    "GET", urllib.parse.urljoin(next_link, _parsed_next_link.path), params=_next_request_params
                )
                path_format_arguments = {
                    "endpoint": self._serialize.url(
                        "self._config.base_url", self._config.base_url, "str", skip_quote=True
                    ),
                }
                _request.url = self._client.format_url(_request.url, **path_format_arguments)

            return _request

        async def extract_data(pipeline_response):
            deserialized = pipeline_response.http_response.json()
            list_of_elem = _deserialize(List[_models.PolicyDefinition], deserialized.get("value", []))
            if cls:
                list_of_elem = cls(list_of_elem)  # type: ignore
            return deserialized.get("nextLink") or None, AsyncList(list_of_elem)

        async def get_next(next_link=None):
            _request = prepare_request(next_link)

            _stream = False
            pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
                _request, stream=_stream, **kwargs
            )
            response = pipeline_response.http_response

            if response.status_code not in [200]:
                map_error(status_code=response.status_code, response=response, error_map=error_map)
                error = _failsafe_deserialize(
                    _models.ErrorResponse,
                    response,
                )
                raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

            return pipeline_response

        return AsyncItemPaged(get_next, extract_data)

    @distributed_trace_async
    async def get_built_in(self, policy_definition_name: str, **kwargs: Any) -> _models.PolicyDefinition:
        """This operation retrieves the built-in policy definition with the given name.

        :param policy_definition_name: The name of the built-in policy definition to get. Required.
        :type policy_definition_name: str
        :return: PolicyDefinition. The PolicyDefinition is compatible with MutableMapping
        :rtype: ~azure.mgmt.resource.policy.models.PolicyDefinition
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[_models.PolicyDefinition] = kwargs.pop("cls", None)

        _request = build_policy_definitions_get_built_in_request(
            policy_definition_name=policy_definition_name,
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.base_url", self._config.base_url, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = kwargs.pop("stream", False)
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                try:
                    await response.read()  # Load the body in memory and close the socket
                except (StreamConsumedError, StreamClosedError):
                    pass
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = _failsafe_deserialize(
                _models.ErrorResponse,
                response,
            )
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        if _stream:
            deserialized = response.iter_bytes()
        else:
            deserialized = _deserialize(_models.PolicyDefinition, response.json())

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore

    @distributed_trace
    def list_built_in(
        self, *, filter: Optional[str] = None, top: Optional[int] = None, **kwargs: Any
    ) -> AsyncItemPaged["_models.PolicyDefinition"]:
        """This operation retrieves a list of all the built-in policy definitions that match the optional
        given $filter. If $filter='policyType -eq {value}' is provided, the returned list only includes
        all built-in policy definitions whose type match the {value}. Possible policyType values are
        NotSpecified, BuiltIn, Custom, and Static. If $filter='category -eq {value}' is provided, the
        returned list only includes all built-in policy definitions whose category match the {value}.

        :keyword filter: The filter to apply on the operation. Valid values for $filter are:
         'atExactScope()', 'policyType -eq {value}' or 'category eq '{value}''. If $filter is not
         provided, no filtering is performed. If $filter=atExactScope() is provided, the returned list
         only includes all policy definitions that at the given scope. If $filter='policyType -eq
         {value}' is provided, the returned list only includes all policy definitions whose type match
         the {value}. Possible policyType values are NotSpecified, BuiltIn, Custom, and Static. If
         $filter='category -eq {value}' is provided, the returned list only includes all policy
         definitions whose category match the {value}. Default value is None.
        :paramtype filter: str
        :keyword top: Maximum number of records to return. When the $top filter is not provided, it
         will return 500 records. Default value is None.
        :paramtype top: int
        :return: An iterator like instance of PolicyDefinition
        :rtype:
         ~azure.core.async_paging.AsyncItemPaged[~azure.mgmt.resource.policy.models.PolicyDefinition]
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[List[_models.PolicyDefinition]] = kwargs.pop("cls", None)

        error_map: MutableMapping = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        def prepare_request(next_link=None):
            if not next_link:

                _request = build_policy_definitions_list_built_in_request(
                    filter=filter,
                    top=top,
                    api_version=self._config.api_version,
                    headers=_headers,
                    params=_params,
                )
                path_format_arguments = {
                    "endpoint": self._serialize.url(
                        "self._config.base_url", self._config.base_url, "str", skip_quote=True
                    ),
                }
                _request.url = self._client.format_url(_request.url, **path_format_arguments)

            else:
                # make call to next link with the client's api-version
                _parsed_next_link = urllib.parse.urlparse(next_link)
                _next_request_params = case_insensitive_dict(
                    {
                        key: [urllib.parse.quote(v) for v in value]
                        for key, value in urllib.parse.parse_qs(_parsed_next_link.query).items()
                    }
                )
                _next_request_params["api-version"] = self._config.api_version
                _request = HttpRequest(
                    "GET", urllib.parse.urljoin(next_link, _parsed_next_link.path), params=_next_request_params
                )
                path_format_arguments = {
                    "endpoint": self._serialize.url(
                        "self._config.base_url", self._config.base_url, "str", skip_quote=True
                    ),
                }
                _request.url = self._client.format_url(_request.url, **path_format_arguments)

            return _request

        async def extract_data(pipeline_response):
            deserialized = pipeline_response.http_response.json()
            list_of_elem = _deserialize(List[_models.PolicyDefinition], deserialized.get("value", []))
            if cls:
                list_of_elem = cls(list_of_elem)  # type: ignore
            return deserialized.get("nextLink") or None, AsyncList(list_of_elem)

        async def get_next(next_link=None):
            _request = prepare_request(next_link)

            _stream = False
            pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
                _request, stream=_stream, **kwargs
            )
            response = pipeline_response.http_response

            if response.status_code not in [200]:
                map_error(status_code=response.status_code, response=response, error_map=error_map)
                error = _failsafe_deserialize(
                    _models.ErrorResponse,
                    response,
                )
                raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

            return pipeline_response

        return AsyncItemPaged(get_next, extract_data)

    @distributed_trace_async
    async def get_at_management_group(
        self, management_group_id: str, policy_definition_name: str, **kwargs: Any
    ) -> _models.PolicyDefinition:
        """This operation retrieves the policy definition in the given management group with the given
        name.

        :param management_group_id: The ID of the management group. Required.
        :type management_group_id: str
        :param policy_definition_name: The name of the policy definition to get. Required.
        :type policy_definition_name: str
        :return: PolicyDefinition. The PolicyDefinition is compatible with MutableMapping
        :rtype: ~azure.mgmt.resource.policy.models.PolicyDefinition
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[_models.PolicyDefinition] = kwargs.pop("cls", None)

        _request = build_policy_definitions_get_at_management_group_request(
            management_group_id=management_group_id,
            policy_definition_name=policy_definition_name,
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.base_url", self._config.base_url, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = kwargs.pop("stream", False)
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                try:
                    await response.read()  # Load the body in memory and close the socket
                except (StreamConsumedError, StreamClosedError):
                    pass
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = _failsafe_deserialize(
                _models.ErrorResponse,
                response,
            )
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        if _stream:
            deserialized = response.iter_bytes()
        else:
            deserialized = _deserialize(_models.PolicyDefinition, response.json())

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore

    @overload
    async def create_or_update_at_management_group(
        self,
        management_group_id: str,
        policy_definition_name: str,
        parameters: _models.PolicyDefinition,
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> _models.PolicyDefinition:
        """This operation creates or updates a policy definition in the given management group with the
        given name.

        :param management_group_id: The ID of the management group. Required.
        :type management_group_id: str
        :param policy_definition_name: The name of the policy definition to get. Required.
        :type policy_definition_name: str
        :param parameters: The policy definition properties. Required.
        :type parameters: ~azure.mgmt.resource.policy.models.PolicyDefinition
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: PolicyDefinition. The PolicyDefinition is compatible with MutableMapping
        :rtype: ~azure.mgmt.resource.policy.models.PolicyDefinition
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @overload
    async def create_or_update_at_management_group(
        self,
        management_group_id: str,
        policy_definition_name: str,
        parameters: JSON,
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> _models.PolicyDefinition:
        """This operation creates or updates a policy definition in the given management group with the
        given name.

        :param management_group_id: The ID of the management group. Required.
        :type management_group_id: str
        :param policy_definition_name: The name of the policy definition to get. Required.
        :type policy_definition_name: str
        :param parameters: The policy definition properties. Required.
        :type parameters: JSON
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: PolicyDefinition. The PolicyDefinition is compatible with MutableMapping
        :rtype: ~azure.mgmt.resource.policy.models.PolicyDefinition
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @overload
    async def create_or_update_at_management_group(
        self,
        management_group_id: str,
        policy_definition_name: str,
        parameters: IO[bytes],
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> _models.PolicyDefinition:
        """This operation creates or updates a policy definition in the given management group with the
        given name.

        :param management_group_id: The ID of the management group. Required.
        :type management_group_id: str
        :param policy_definition_name: The name of the policy definition to get. Required.
        :type policy_definition_name: str
        :param parameters: The policy definition properties. Required.
        :type parameters: IO[bytes]
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: PolicyDefinition. The PolicyDefinition is compatible with MutableMapping
        :rtype: ~azure.mgmt.resource.policy.models.PolicyDefinition
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @distributed_trace_async
    async def create_or_update_at_management_group(
        self,
        management_group_id: str,
        policy_definition_name: str,
        parameters: Union[_models.PolicyDefinition, JSON, IO[bytes]],
        **kwargs: Any
    ) -> _models.PolicyDefinition:
        """This operation creates or updates a policy definition in the given management group with the
        given name.

        :param management_group_id: The ID of the management group. Required.
        :type management_group_id: str
        :param policy_definition_name: The name of the policy definition to get. Required.
        :type policy_definition_name: str
        :param parameters: The policy definition properties. Is one of the following types:
         PolicyDefinition, JSON, IO[bytes] Required.
        :type parameters: ~azure.mgmt.resource.policy.models.PolicyDefinition or JSON or IO[bytes]
        :return: PolicyDefinition. The PolicyDefinition is compatible with MutableMapping
        :rtype: ~azure.mgmt.resource.policy.models.PolicyDefinition
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[_models.PolicyDefinition] = kwargs.pop("cls", None)

        content_type = content_type or "application/json"
        _content = None
        if isinstance(parameters, (IOBase, bytes)):
            _content = parameters
        else:
            _content = json.dumps(parameters, cls=SdkJSONEncoder, exclude_readonly=True)  # type: ignore

        _request = build_policy_definitions_create_or_update_at_management_group_request(
            management_group_id=management_group_id,
            policy_definition_name=policy_definition_name,
            content_type=content_type,
            api_version=self._config.api_version,
            content=_content,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.base_url", self._config.base_url, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = kwargs.pop("stream", False)
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [201]:
            if _stream:
                try:
                    await response.read()  # Load the body in memory and close the socket
                except (StreamConsumedError, StreamClosedError):
                    pass
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = _failsafe_deserialize(
                _models.ErrorResponse,
                response,
            )
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        if _stream:
            deserialized = response.iter_bytes()
        else:
            deserialized = _deserialize(_models.PolicyDefinition, response.json())

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore

    @distributed_trace_async
    async def delete_at_management_group(
        self, management_group_id: str, policy_definition_name: str, **kwargs: Any
    ) -> None:
        """This operation deletes the policy definition in the given management group with the given name.

        :param management_group_id: The ID of the management group. Required.
        :type management_group_id: str
        :param policy_definition_name: The name of the policy definition to get. Required.
        :type policy_definition_name: str
        :return: None
        :rtype: None
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[None] = kwargs.pop("cls", None)

        _request = build_policy_definitions_delete_at_management_group_request(
            management_group_id=management_group_id,
            policy_definition_name=policy_definition_name,
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.base_url", self._config.base_url, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = False
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200, 204]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = _failsafe_deserialize(
                _models.ErrorResponse,
                response,
            )
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        if cls:
            return cls(pipeline_response, None, {})  # type: ignore

    @distributed_trace
    def list_by_management_group(
        self, management_group_id: str, *, filter: Optional[str] = None, top: Optional[int] = None, **kwargs: Any
    ) -> AsyncItemPaged["_models.PolicyDefinition"]:
        """This operation retrieves a list of all the policy definitions in a given management group that
        match the optional given $filter. Valid values for $filter are: 'atExactScope()', 'policyType
        -eq {value}' or 'category eq '{value}''. If $filter is not provided, the unfiltered list
        includes all policy definitions associated with the management group, including those that
        apply directly or from management groups that contain the given management group. If
        $filter=atExactScope() is provided, the returned list only includes all policy definitions that
        at the given management group. If $filter='policyType -eq {value}' is provided, the returned
        list only includes all policy definitions whose type match the {value}. Possible policyType
        values are NotSpecified, BuiltIn, Custom, and Static. If $filter='category -eq {value}' is
        provided, the returned list only includes all policy definitions whose category match the
        {value}.

        :param management_group_id: The ID of the management group. Required.
        :type management_group_id: str
        :keyword filter: The filter to apply on the operation. Valid values for $filter are:
         'atExactScope()', 'policyType -eq {value}' or 'category eq '{value}''. If $filter is not
         provided, no filtering is performed. If $filter=atExactScope() is provided, the returned list
         only includes all policy definitions that at the given scope. If $filter='policyType -eq
         {value}' is provided, the returned list only includes all policy definitions whose type match
         the {value}. Possible policyType values are NotSpecified, BuiltIn, Custom, and Static. If
         $filter='category -eq {value}' is provided, the returned list only includes all policy
         definitions whose category match the {value}. Default value is None.
        :paramtype filter: str
        :keyword top: Maximum number of records to return. When the $top filter is not provided, it
         will return 500 records. Default value is None.
        :paramtype top: int
        :return: An iterator like instance of PolicyDefinition
        :rtype:
         ~azure.core.async_paging.AsyncItemPaged[~azure.mgmt.resource.policy.models.PolicyDefinition]
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[List[_models.PolicyDefinition]] = kwargs.pop("cls", None)

        error_map: MutableMapping = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        def prepare_request(next_link=None):
            if not next_link:

                _request = build_policy_definitions_list_by_management_group_request(
                    management_group_id=management_group_id,
                    filter=filter,
                    top=top,
                    api_version=self._config.api_version,
                    headers=_headers,
                    params=_params,
                )
                path_format_arguments = {
                    "endpoint": self._serialize.url(
                        "self._config.base_url", self._config.base_url, "str", skip_quote=True
                    ),
                }
                _request.url = self._client.format_url(_request.url, **path_format_arguments)

            else:
                # make call to next link with the client's api-version
                _parsed_next_link = urllib.parse.urlparse(next_link)
                _next_request_params = case_insensitive_dict(
                    {
                        key: [urllib.parse.quote(v) for v in value]
                        for key, value in urllib.parse.parse_qs(_parsed_next_link.query).items()
                    }
                )
                _next_request_params["api-version"] = self._config.api_version
                _request = HttpRequest(
                    "GET", urllib.parse.urljoin(next_link, _parsed_next_link.path), params=_next_request_params
                )
                path_format_arguments = {
                    "endpoint": self._serialize.url(
                        "self._config.base_url", self._config.base_url, "str", skip_quote=True
                    ),
                }
                _request.url = self._client.format_url(_request.url, **path_format_arguments)

            return _request

        async def extract_data(pipeline_response):
            deserialized = pipeline_response.http_response.json()
            list_of_elem = _deserialize(List[_models.PolicyDefinition], deserialized.get("value", []))
            if cls:
                list_of_elem = cls(list_of_elem)  # type: ignore
            return deserialized.get("nextLink") or None, AsyncList(list_of_elem)

        async def get_next(next_link=None):
            _request = prepare_request(next_link)

            _stream = False
            pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
                _request, stream=_stream, **kwargs
            )
            response = pipeline_response.http_response

            if response.status_code not in [200]:
                map_error(status_code=response.status_code, response=response, error_map=error_map)
                error = _failsafe_deserialize(
                    _models.ErrorResponse,
                    response,
                )
                raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

            return pipeline_response

        return AsyncItemPaged(get_next, extract_data)


class PolicyDefinitionVersionsOperations:
    """
    .. warning::
        **DO NOT** instantiate this class directly.

        Instead, you should access the following operations through
        :class:`~azure.mgmt.resource.policy.aio.PolicyClient`'s
        :attr:`policy_definition_versions` attribute.
    """

    def __init__(self, *args, **kwargs) -> None:
        input_args = list(args)
        self._client: AsyncPipelineClient = input_args.pop(0) if input_args else kwargs.pop("client")
        self._config: PolicyClientConfiguration = input_args.pop(0) if input_args else kwargs.pop("config")
        self._serialize: Serializer = input_args.pop(0) if input_args else kwargs.pop("serializer")
        self._deserialize: Deserializer = input_args.pop(0) if input_args else kwargs.pop("deserializer")

    @distributed_trace_async
    async def get(
        self, policy_definition_name: str, policy_definition_version: str, **kwargs: Any
    ) -> _models.PolicyDefinitionVersion:
        """This operation retrieves the policy definition version in the given subscription with the given
        name.

        :param policy_definition_name: The name of the policy definition. Required.
        :type policy_definition_name: str
        :param policy_definition_version: The policy definition version.  The format is x.y.z where x
         is the major version number, y is the minor version number, and z is the patch number.
         Required.
        :type policy_definition_version: str
        :return: PolicyDefinitionVersion. The PolicyDefinitionVersion is compatible with MutableMapping
        :rtype: ~azure.mgmt.resource.policy.models.PolicyDefinitionVersion
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[_models.PolicyDefinitionVersion] = kwargs.pop("cls", None)

        _request = build_policy_definition_versions_get_request(
            policy_definition_name=policy_definition_name,
            policy_definition_version=policy_definition_version,
            subscription_id=self._config.subscription_id,
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.base_url", self._config.base_url, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = kwargs.pop("stream", False)
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                try:
                    await response.read()  # Load the body in memory and close the socket
                except (StreamConsumedError, StreamClosedError):
                    pass
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = _failsafe_deserialize(
                _models.ErrorResponse,
                response,
            )
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        if _stream:
            deserialized = response.iter_bytes()
        else:
            deserialized = _deserialize(_models.PolicyDefinitionVersion, response.json())

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore

    @overload
    async def create_or_update(
        self,
        policy_definition_name: str,
        policy_definition_version: str,
        parameters: _models.PolicyDefinitionVersion,
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> _models.PolicyDefinitionVersion:
        """This operation creates or updates a policy definition in the given subscription with the given
        name.

        :param policy_definition_name: The name of the policy definition. Required.
        :type policy_definition_name: str
        :param policy_definition_version: The policy definition version.  The format is x.y.z where x
         is the major version number, y is the minor version number, and z is the patch number.
         Required.
        :type policy_definition_version: str
        :param parameters: The policy definition properties. Required.
        :type parameters: ~azure.mgmt.resource.policy.models.PolicyDefinitionVersion
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: PolicyDefinitionVersion. The PolicyDefinitionVersion is compatible with MutableMapping
        :rtype: ~azure.mgmt.resource.policy.models.PolicyDefinitionVersion
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @overload
    async def create_or_update(
        self,
        policy_definition_name: str,
        policy_definition_version: str,
        parameters: JSON,
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> _models.PolicyDefinitionVersion:
        """This operation creates or updates a policy definition in the given subscription with the given
        name.

        :param policy_definition_name: The name of the policy definition. Required.
        :type policy_definition_name: str
        :param policy_definition_version: The policy definition version.  The format is x.y.z where x
         is the major version number, y is the minor version number, and z is the patch number.
         Required.
        :type policy_definition_version: str
        :param parameters: The policy definition properties. Required.
        :type parameters: JSON
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: PolicyDefinitionVersion. The PolicyDefinitionVersion is compatible with MutableMapping
        :rtype: ~azure.mgmt.resource.policy.models.PolicyDefinitionVersion
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @overload
    async def create_or_update(
        self,
        policy_definition_name: str,
        policy_definition_version: str,
        parameters: IO[bytes],
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> _models.PolicyDefinitionVersion:
        """This operation creates or updates a policy definition in the given subscription with the given
        name.

        :param policy_definition_name: The name of the policy definition. Required.
        :type policy_definition_name: str
        :param policy_definition_version: The policy definition version.  The format is x.y.z where x
         is the major version number, y is the minor version number, and z is the patch number.
         Required.
        :type policy_definition_version: str
        :param parameters: The policy definition properties. Required.
        :type parameters: IO[bytes]
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: PolicyDefinitionVersion. The PolicyDefinitionVersion is compatible with MutableMapping
        :rtype: ~azure.mgmt.resource.policy.models.PolicyDefinitionVersion
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @distributed_trace_async
    async def create_or_update(
        self,
        policy_definition_name: str,
        policy_definition_version: str,
        parameters: Union[_models.PolicyDefinitionVersion, JSON, IO[bytes]],
        **kwargs: Any
    ) -> _models.PolicyDefinitionVersion:
        """This operation creates or updates a policy definition in the given subscription with the given
        name.

        :param policy_definition_name: The name of the policy definition. Required.
        :type policy_definition_name: str
        :param policy_definition_version: The policy definition version.  The format is x.y.z where x
         is the major version number, y is the minor version number, and z is the patch number.
         Required.
        :type policy_definition_version: str
        :param parameters: The policy definition properties. Is one of the following types:
         PolicyDefinitionVersion, JSON, IO[bytes] Required.
        :type parameters: ~azure.mgmt.resource.policy.models.PolicyDefinitionVersion or JSON or
         IO[bytes]
        :return: PolicyDefinitionVersion. The PolicyDefinitionVersion is compatible with MutableMapping
        :rtype: ~azure.mgmt.resource.policy.models.PolicyDefinitionVersion
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[_models.PolicyDefinitionVersion] = kwargs.pop("cls", None)

        content_type = content_type or "application/json"
        _content = None
        if isinstance(parameters, (IOBase, bytes)):
            _content = parameters
        else:
            _content = json.dumps(parameters, cls=SdkJSONEncoder, exclude_readonly=True)  # type: ignore

        _request = build_policy_definition_versions_create_or_update_request(
            policy_definition_name=policy_definition_name,
            policy_definition_version=policy_definition_version,
            subscription_id=self._config.subscription_id,
            content_type=content_type,
            api_version=self._config.api_version,
            content=_content,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.base_url", self._config.base_url, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = kwargs.pop("stream", False)
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200, 201]:
            if _stream:
                try:
                    await response.read()  # Load the body in memory and close the socket
                except (StreamConsumedError, StreamClosedError):
                    pass
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = _failsafe_deserialize(
                _models.ErrorResponse,
                response,
            )
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        if _stream:
            deserialized = response.iter_bytes()
        else:
            deserialized = _deserialize(_models.PolicyDefinitionVersion, response.json())

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore

    @distributed_trace_async
    async def delete(self, policy_definition_name: str, policy_definition_version: str, **kwargs: Any) -> None:
        """This operation deletes the policy definition version in the given subscription with the given
        name.

        :param policy_definition_name: The name of the policy definition. Required.
        :type policy_definition_name: str
        :param policy_definition_version: The policy definition version.  The format is x.y.z where x
         is the major version number, y is the minor version number, and z is the patch number.
         Required.
        :type policy_definition_version: str
        :return: None
        :rtype: None
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[None] = kwargs.pop("cls", None)

        _request = build_policy_definition_versions_delete_request(
            policy_definition_name=policy_definition_name,
            policy_definition_version=policy_definition_version,
            subscription_id=self._config.subscription_id,
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.base_url", self._config.base_url, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = False
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200, 204]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = _failsafe_deserialize(
                _models.ErrorResponse,
                response,
            )
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        if cls:
            return cls(pipeline_response, None, {})  # type: ignore

    @distributed_trace
    def list(
        self, policy_definition_name: str, *, top: Optional[int] = None, **kwargs: Any
    ) -> AsyncItemPaged["_models.PolicyDefinitionVersion"]:
        """This operation retrieves a list of all the policy definition versions for the given policy
        definition.

        :param policy_definition_name: The name of the policy definition. Required.
        :type policy_definition_name: str
        :keyword top: Maximum number of records to return. When the $top filter is not provided, it
         will return 500 records. Default value is None.
        :paramtype top: int
        :return: An iterator like instance of PolicyDefinitionVersion
        :rtype:
         ~azure.core.async_paging.AsyncItemPaged[~azure.mgmt.resource.policy.models.PolicyDefinitionVersion]
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[List[_models.PolicyDefinitionVersion]] = kwargs.pop("cls", None)

        error_map: MutableMapping = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        def prepare_request(next_link=None):
            if not next_link:

                _request = build_policy_definition_versions_list_request(
                    policy_definition_name=policy_definition_name,
                    subscription_id=self._config.subscription_id,
                    top=top,
                    api_version=self._config.api_version,
                    headers=_headers,
                    params=_params,
                )
                path_format_arguments = {
                    "endpoint": self._serialize.url(
                        "self._config.base_url", self._config.base_url, "str", skip_quote=True
                    ),
                }
                _request.url = self._client.format_url(_request.url, **path_format_arguments)

            else:
                # make call to next link with the client's api-version
                _parsed_next_link = urllib.parse.urlparse(next_link)
                _next_request_params = case_insensitive_dict(
                    {
                        key: [urllib.parse.quote(v) for v in value]
                        for key, value in urllib.parse.parse_qs(_parsed_next_link.query).items()
                    }
                )
                _next_request_params["api-version"] = self._config.api_version
                _request = HttpRequest(
                    "GET", urllib.parse.urljoin(next_link, _parsed_next_link.path), params=_next_request_params
                )
                path_format_arguments = {
                    "endpoint": self._serialize.url(
                        "self._config.base_url", self._config.base_url, "str", skip_quote=True
                    ),
                }
                _request.url = self._client.format_url(_request.url, **path_format_arguments)

            return _request

        async def extract_data(pipeline_response):
            deserialized = pipeline_response.http_response.json()
            list_of_elem = _deserialize(List[_models.PolicyDefinitionVersion], deserialized.get("value", []))
            if cls:
                list_of_elem = cls(list_of_elem)  # type: ignore
            return deserialized.get("nextLink") or None, AsyncList(list_of_elem)

        async def get_next(next_link=None):
            _request = prepare_request(next_link)

            _stream = False
            pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
                _request, stream=_stream, **kwargs
            )
            response = pipeline_response.http_response

            if response.status_code not in [200]:
                map_error(status_code=response.status_code, response=response, error_map=error_map)
                error = _failsafe_deserialize(
                    _models.ErrorResponse,
                    response,
                )
                raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

            return pipeline_response

        return AsyncItemPaged(get_next, extract_data)

    @distributed_trace_async
    async def get_built_in(
        self, policy_definition_name: str, policy_definition_version: str, **kwargs: Any
    ) -> _models.PolicyDefinitionVersion:
        """This operation retrieves the built-in policy definition version with the given name.

        :param policy_definition_name: The name of the policy definition. Required.
        :type policy_definition_name: str
        :param policy_definition_version: The policy definition version.  The format is x.y.z where x
         is the major version number, y is the minor version number, and z is the patch number.
         Required.
        :type policy_definition_version: str
        :return: PolicyDefinitionVersion. The PolicyDefinitionVersion is compatible with MutableMapping
        :rtype: ~azure.mgmt.resource.policy.models.PolicyDefinitionVersion
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[_models.PolicyDefinitionVersion] = kwargs.pop("cls", None)

        _request = build_policy_definition_versions_get_built_in_request(
            policy_definition_name=policy_definition_name,
            policy_definition_version=policy_definition_version,
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.base_url", self._config.base_url, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = kwargs.pop("stream", False)
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                try:
                    await response.read()  # Load the body in memory and close the socket
                except (StreamConsumedError, StreamClosedError):
                    pass
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = _failsafe_deserialize(
                _models.ErrorResponse,
                response,
            )
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        if _stream:
            deserialized = response.iter_bytes()
        else:
            deserialized = _deserialize(_models.PolicyDefinitionVersion, response.json())

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore

    @distributed_trace
    def list_built_in(
        self, policy_definition_name: str, *, top: Optional[int] = None, **kwargs: Any
    ) -> AsyncItemPaged["_models.PolicyDefinitionVersion"]:
        """This operation retrieves a list of all the built-in policy definition versions for the given
        policy definition.

        :param policy_definition_name: The name of the policy definition. Required.
        :type policy_definition_name: str
        :keyword top: Maximum number of records to return. When the $top filter is not provided, it
         will return 500 records. Default value is None.
        :paramtype top: int
        :return: An iterator like instance of PolicyDefinitionVersion
        :rtype:
         ~azure.core.async_paging.AsyncItemPaged[~azure.mgmt.resource.policy.models.PolicyDefinitionVersion]
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[List[_models.PolicyDefinitionVersion]] = kwargs.pop("cls", None)

        error_map: MutableMapping = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        def prepare_request(next_link=None):
            if not next_link:

                _request = build_policy_definition_versions_list_built_in_request(
                    policy_definition_name=policy_definition_name,
                    top=top,
                    api_version=self._config.api_version,
                    headers=_headers,
                    params=_params,
                )
                path_format_arguments = {
                    "endpoint": self._serialize.url(
                        "self._config.base_url", self._config.base_url, "str", skip_quote=True
                    ),
                }
                _request.url = self._client.format_url(_request.url, **path_format_arguments)

            else:
                # make call to next link with the client's api-version
                _parsed_next_link = urllib.parse.urlparse(next_link)
                _next_request_params = case_insensitive_dict(
                    {
                        key: [urllib.parse.quote(v) for v in value]
                        for key, value in urllib.parse.parse_qs(_parsed_next_link.query).items()
                    }
                )
                _next_request_params["api-version"] = self._config.api_version
                _request = HttpRequest(
                    "GET", urllib.parse.urljoin(next_link, _parsed_next_link.path), params=_next_request_params
                )
                path_format_arguments = {
                    "endpoint": self._serialize.url(
                        "self._config.base_url", self._config.base_url, "str", skip_quote=True
                    ),
                }
                _request.url = self._client.format_url(_request.url, **path_format_arguments)

            return _request

        async def extract_data(pipeline_response):
            deserialized = pipeline_response.http_response.json()
            list_of_elem = _deserialize(List[_models.PolicyDefinitionVersion], deserialized.get("value", []))
            if cls:
                list_of_elem = cls(list_of_elem)  # type: ignore
            return deserialized.get("nextLink") or None, AsyncList(list_of_elem)

        async def get_next(next_link=None):
            _request = prepare_request(next_link)

            _stream = False
            pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
                _request, stream=_stream, **kwargs
            )
            response = pipeline_response.http_response

            if response.status_code not in [200]:
                map_error(status_code=response.status_code, response=response, error_map=error_map)
                error = _failsafe_deserialize(
                    _models.ErrorResponse,
                    response,
                )
                raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

            return pipeline_response

        return AsyncItemPaged(get_next, extract_data)

    @distributed_trace_async
    async def get_at_management_group(
        self, management_group_name: str, policy_definition_name: str, policy_definition_version: str, **kwargs: Any
    ) -> _models.PolicyDefinitionVersion:
        """This operation retrieves the policy definition version in the given management group with the
        given name.

        :param management_group_name: The name of the management group. The name is case insensitive.
         Required.
        :type management_group_name: str
        :param policy_definition_name: The name of the policy definition. Required.
        :type policy_definition_name: str
        :param policy_definition_version: The policy definition version.  The format is x.y.z where x
         is the major version number, y is the minor version number, and z is the patch number.
         Required.
        :type policy_definition_version: str
        :return: PolicyDefinitionVersion. The PolicyDefinitionVersion is compatible with MutableMapping
        :rtype: ~azure.mgmt.resource.policy.models.PolicyDefinitionVersion
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[_models.PolicyDefinitionVersion] = kwargs.pop("cls", None)

        _request = build_policy_definition_versions_get_at_management_group_request(
            management_group_name=management_group_name,
            policy_definition_name=policy_definition_name,
            policy_definition_version=policy_definition_version,
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.base_url", self._config.base_url, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = kwargs.pop("stream", False)
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                try:
                    await response.read()  # Load the body in memory and close the socket
                except (StreamConsumedError, StreamClosedError):
                    pass
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = _failsafe_deserialize(
                _models.ErrorResponse,
                response,
            )
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        if _stream:
            deserialized = response.iter_bytes()
        else:
            deserialized = _deserialize(_models.PolicyDefinitionVersion, response.json())

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore

    @overload
    async def create_or_update_at_management_group(
        self,
        management_group_name: str,
        policy_definition_name: str,
        policy_definition_version: str,
        parameters: _models.PolicyDefinitionVersion,
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> _models.PolicyDefinitionVersion:
        """This operation creates or updates a policy definition version in the given management group
        with the given name.

        :param management_group_name: The name of the management group. The name is case insensitive.
         Required.
        :type management_group_name: str
        :param policy_definition_name: The name of the policy definition. Required.
        :type policy_definition_name: str
        :param policy_definition_version: The policy definition version.  The format is x.y.z where x
         is the major version number, y is the minor version number, and z is the patch number.
         Required.
        :type policy_definition_version: str
        :param parameters: The policy definition properties. Required.
        :type parameters: ~azure.mgmt.resource.policy.models.PolicyDefinitionVersion
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: PolicyDefinitionVersion. The PolicyDefinitionVersion is compatible with MutableMapping
        :rtype: ~azure.mgmt.resource.policy.models.PolicyDefinitionVersion
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @overload
    async def create_or_update_at_management_group(
        self,
        management_group_name: str,
        policy_definition_name: str,
        policy_definition_version: str,
        parameters: JSON,
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> _models.PolicyDefinitionVersion:
        """This operation creates or updates a policy definition version in the given management group
        with the given name.

        :param management_group_name: The name of the management group. The name is case insensitive.
         Required.
        :type management_group_name: str
        :param policy_definition_name: The name of the policy definition. Required.
        :type policy_definition_name: str
        :param policy_definition_version: The policy definition version.  The format is x.y.z where x
         is the major version number, y is the minor version number, and z is the patch number.
         Required.
        :type policy_definition_version: str
        :param parameters: The policy definition properties. Required.
        :type parameters: JSON
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: PolicyDefinitionVersion. The PolicyDefinitionVersion is compatible with MutableMapping
        :rtype: ~azure.mgmt.resource.policy.models.PolicyDefinitionVersion
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @overload
    async def create_or_update_at_management_group(
        self,
        management_group_name: str,
        policy_definition_name: str,
        policy_definition_version: str,
        parameters: IO[bytes],
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> _models.PolicyDefinitionVersion:
        """This operation creates or updates a policy definition version in the given management group
        with the given name.

        :param management_group_name: The name of the management group. The name is case insensitive.
         Required.
        :type management_group_name: str
        :param policy_definition_name: The name of the policy definition. Required.
        :type policy_definition_name: str
        :param policy_definition_version: The policy definition version.  The format is x.y.z where x
         is the major version number, y is the minor version number, and z is the patch number.
         Required.
        :type policy_definition_version: str
        :param parameters: The policy definition properties. Required.
        :type parameters: IO[bytes]
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: PolicyDefinitionVersion. The PolicyDefinitionVersion is compatible with MutableMapping
        :rtype: ~azure.mgmt.resource.policy.models.PolicyDefinitionVersion
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @distributed_trace_async
    async def create_or_update_at_management_group(
        self,
        management_group_name: str,
        policy_definition_name: str,
        policy_definition_version: str,
        parameters: Union[_models.PolicyDefinitionVersion, JSON, IO[bytes]],
        **kwargs: Any
    ) -> _models.PolicyDefinitionVersion:
        """This operation creates or updates a policy definition version in the given management group
        with the given name.

        :param management_group_name: The name of the management group. The name is case insensitive.
         Required.
        :type management_group_name: str
        :param policy_definition_name: The name of the policy definition. Required.
        :type policy_definition_name: str
        :param policy_definition_version: The policy definition version.  The format is x.y.z where x
         is the major version number, y is the minor version number, and z is the patch number.
         Required.
        :type policy_definition_version: str
        :param parameters: The policy definition properties. Is one of the following types:
         PolicyDefinitionVersion, JSON, IO[bytes] Required.
        :type parameters: ~azure.mgmt.resource.policy.models.PolicyDefinitionVersion or JSON or
         IO[bytes]
        :return: PolicyDefinitionVersion. The PolicyDefinitionVersion is compatible with MutableMapping
        :rtype: ~azure.mgmt.resource.policy.models.PolicyDefinitionVersion
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[_models.PolicyDefinitionVersion] = kwargs.pop("cls", None)

        content_type = content_type or "application/json"
        _content = None
        if isinstance(parameters, (IOBase, bytes)):
            _content = parameters
        else:
            _content = json.dumps(parameters, cls=SdkJSONEncoder, exclude_readonly=True)  # type: ignore

        _request = build_policy_definition_versions_create_or_update_at_management_group_request(
            management_group_name=management_group_name,
            policy_definition_name=policy_definition_name,
            policy_definition_version=policy_definition_version,
            content_type=content_type,
            api_version=self._config.api_version,
            content=_content,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.base_url", self._config.base_url, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = kwargs.pop("stream", False)
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200, 201]:
            if _stream:
                try:
                    await response.read()  # Load the body in memory and close the socket
                except (StreamConsumedError, StreamClosedError):
                    pass
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = _failsafe_deserialize(
                _models.ErrorResponse,
                response,
            )
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        if _stream:
            deserialized = response.iter_bytes()
        else:
            deserialized = _deserialize(_models.PolicyDefinitionVersion, response.json())

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore

    @distributed_trace_async
    async def delete_at_management_group(
        self, management_group_name: str, policy_definition_name: str, policy_definition_version: str, **kwargs: Any
    ) -> None:
        """This operation deletes the policy definition in the given management group with the given name.

        :param management_group_name: The name of the management group. The name is case insensitive.
         Required.
        :type management_group_name: str
        :param policy_definition_name: The name of the policy definition. Required.
        :type policy_definition_name: str
        :param policy_definition_version: The policy definition version.  The format is x.y.z where x
         is the major version number, y is the minor version number, and z is the patch number.
         Required.
        :type policy_definition_version: str
        :return: None
        :rtype: None
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[None] = kwargs.pop("cls", None)

        _request = build_policy_definition_versions_delete_at_management_group_request(
            management_group_name=management_group_name,
            policy_definition_name=policy_definition_name,
            policy_definition_version=policy_definition_version,
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.base_url", self._config.base_url, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = False
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200, 204]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = _failsafe_deserialize(
                _models.ErrorResponse,
                response,
            )
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        if cls:
            return cls(pipeline_response, None, {})  # type: ignore

    @distributed_trace
    def list_by_management_group(
        self, management_group_name: str, policy_definition_name: str, *, top: Optional[int] = None, **kwargs: Any
    ) -> AsyncItemPaged["_models.PolicyDefinitionVersion"]:
        """This operation retrieves a list of all the policy definition versions for the given policy
        definition in the given management group.

        :param management_group_name: The name of the management group. The name is case insensitive.
         Required.
        :type management_group_name: str
        :param policy_definition_name: The name of the policy definition. Required.
        :type policy_definition_name: str
        :keyword top: Maximum number of records to return. When the $top filter is not provided, it
         will return 500 records. Default value is None.
        :paramtype top: int
        :return: An iterator like instance of PolicyDefinitionVersion
        :rtype:
         ~azure.core.async_paging.AsyncItemPaged[~azure.mgmt.resource.policy.models.PolicyDefinitionVersion]
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[List[_models.PolicyDefinitionVersion]] = kwargs.pop("cls", None)

        error_map: MutableMapping = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        def prepare_request(next_link=None):
            if not next_link:

                _request = build_policy_definition_versions_list_by_management_group_request(
                    management_group_name=management_group_name,
                    policy_definition_name=policy_definition_name,
                    top=top,
                    api_version=self._config.api_version,
                    headers=_headers,
                    params=_params,
                )
                path_format_arguments = {
                    "endpoint": self._serialize.url(
                        "self._config.base_url", self._config.base_url, "str", skip_quote=True
                    ),
                }
                _request.url = self._client.format_url(_request.url, **path_format_arguments)

            else:
                # make call to next link with the client's api-version
                _parsed_next_link = urllib.parse.urlparse(next_link)
                _next_request_params = case_insensitive_dict(
                    {
                        key: [urllib.parse.quote(v) for v in value]
                        for key, value in urllib.parse.parse_qs(_parsed_next_link.query).items()
                    }
                )
                _next_request_params["api-version"] = self._config.api_version
                _request = HttpRequest(
                    "GET", urllib.parse.urljoin(next_link, _parsed_next_link.path), params=_next_request_params
                )
                path_format_arguments = {
                    "endpoint": self._serialize.url(
                        "self._config.base_url", self._config.base_url, "str", skip_quote=True
                    ),
                }
                _request.url = self._client.format_url(_request.url, **path_format_arguments)

            return _request

        async def extract_data(pipeline_response):
            deserialized = pipeline_response.http_response.json()
            list_of_elem = _deserialize(List[_models.PolicyDefinitionVersion], deserialized.get("value", []))
            if cls:
                list_of_elem = cls(list_of_elem)  # type: ignore
            return deserialized.get("nextLink") or None, AsyncList(list_of_elem)

        async def get_next(next_link=None):
            _request = prepare_request(next_link)

            _stream = False
            pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
                _request, stream=_stream, **kwargs
            )
            response = pipeline_response.http_response

            if response.status_code not in [200]:
                map_error(status_code=response.status_code, response=response, error_map=error_map)
                error = _failsafe_deserialize(
                    _models.ErrorResponse,
                    response,
                )
                raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

            return pipeline_response

        return AsyncItemPaged(get_next, extract_data)

    @distributed_trace_async
    async def list_all_builtins(self, **kwargs: Any) -> _models.PolicyDefinitionVersionListResult:
        """Lists all built-in policy definition versions.

        This operation lists all the built-in policy definition versions for all built-in policy
        definitions.

        :return: PolicyDefinitionVersionListResult. The PolicyDefinitionVersionListResult is compatible
         with MutableMapping
        :rtype: ~azure.mgmt.resource.policy.models.PolicyDefinitionVersionListResult
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[_models.PolicyDefinitionVersionListResult] = kwargs.pop("cls", None)

        _request = build_policy_definition_versions_list_all_builtins_request(
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.base_url", self._config.base_url, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = kwargs.pop("stream", False)
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                try:
                    await response.read()  # Load the body in memory and close the socket
                except (StreamConsumedError, StreamClosedError):
                    pass
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = _failsafe_deserialize(
                _models.ErrorResponse,
                response,
            )
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        if _stream:
            deserialized = response.iter_bytes()
        else:
            deserialized = _deserialize(_models.PolicyDefinitionVersionListResult, response.json())

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore

    @distributed_trace_async
    async def list_all_at_management_group(
        self, management_group_name: str, **kwargs: Any
    ) -> _models.PolicyDefinitionVersionListResult:
        """Lists all policy definition versions at management group scope.

        This operation lists all the policy definition versions for all policy definitions at the
        management group scope.

        :param management_group_name: The name of the management group. The name is case insensitive.
         Required.
        :type management_group_name: str
        :return: PolicyDefinitionVersionListResult. The PolicyDefinitionVersionListResult is compatible
         with MutableMapping
        :rtype: ~azure.mgmt.resource.policy.models.PolicyDefinitionVersionListResult
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[_models.PolicyDefinitionVersionListResult] = kwargs.pop("cls", None)

        _request = build_policy_definition_versions_list_all_at_management_group_request(
            management_group_name=management_group_name,
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.base_url", self._config.base_url, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = kwargs.pop("stream", False)
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                try:
                    await response.read()  # Load the body in memory and close the socket
                except (StreamConsumedError, StreamClosedError):
                    pass
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = _failsafe_deserialize(
                _models.ErrorResponse,
                response,
            )
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        if _stream:
            deserialized = response.iter_bytes()
        else:
            deserialized = _deserialize(_models.PolicyDefinitionVersionListResult, response.json())

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore

    @distributed_trace_async
    async def list_all(self, **kwargs: Any) -> _models.PolicyDefinitionVersionListResult:
        """Lists all policy definition versions within a subscription.

        This operation lists all the policy definition versions for all policy definitions within a
        subscription.

        :return: PolicyDefinitionVersionListResult. The PolicyDefinitionVersionListResult is compatible
         with MutableMapping
        :rtype: ~azure.mgmt.resource.policy.models.PolicyDefinitionVersionListResult
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[_models.PolicyDefinitionVersionListResult] = kwargs.pop("cls", None)

        _request = build_policy_definition_versions_list_all_request(
            subscription_id=self._config.subscription_id,
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.base_url", self._config.base_url, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = kwargs.pop("stream", False)
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                try:
                    await response.read()  # Load the body in memory and close the socket
                except (StreamConsumedError, StreamClosedError):
                    pass
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = _failsafe_deserialize(
                _models.ErrorResponse,
                response,
            )
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        if _stream:
            deserialized = response.iter_bytes()
        else:
            deserialized = _deserialize(_models.PolicyDefinitionVersionListResult, response.json())

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore


class PolicySetDefinitionsOperations:
    """
    .. warning::
        **DO NOT** instantiate this class directly.

        Instead, you should access the following operations through
        :class:`~azure.mgmt.resource.policy.aio.PolicyClient`'s
        :attr:`policy_set_definitions` attribute.
    """

    def __init__(self, *args, **kwargs) -> None:
        input_args = list(args)
        self._client: AsyncPipelineClient = input_args.pop(0) if input_args else kwargs.pop("client")
        self._config: PolicyClientConfiguration = input_args.pop(0) if input_args else kwargs.pop("config")
        self._serialize: Serializer = input_args.pop(0) if input_args else kwargs.pop("serializer")
        self._deserialize: Deserializer = input_args.pop(0) if input_args else kwargs.pop("deserializer")

    @distributed_trace_async
    async def get(
        self, policy_set_definition_name: str, *, expand: Optional[str] = None, **kwargs: Any
    ) -> _models.PolicySetDefinition:
        """This operation retrieves the policy set definition in the given subscription with the given
        name.

        :param policy_set_definition_name: The name of the policy set definition to get. Required.
        :type policy_set_definition_name: str
        :keyword expand: Comma-separated list of additional properties to be included in the response.
         Supported values are 'LatestDefinitionVersion, EffectiveDefinitionVersion'. Default value is
         None.
        :paramtype expand: str
        :return: PolicySetDefinition. The PolicySetDefinition is compatible with MutableMapping
        :rtype: ~azure.mgmt.resource.policy.models.PolicySetDefinition
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[_models.PolicySetDefinition] = kwargs.pop("cls", None)

        _request = build_policy_set_definitions_get_request(
            policy_set_definition_name=policy_set_definition_name,
            subscription_id=self._config.subscription_id,
            expand=expand,
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.base_url", self._config.base_url, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = kwargs.pop("stream", False)
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                try:
                    await response.read()  # Load the body in memory and close the socket
                except (StreamConsumedError, StreamClosedError):
                    pass
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = _failsafe_deserialize(
                _models.ErrorResponse,
                response,
            )
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        if _stream:
            deserialized = response.iter_bytes()
        else:
            deserialized = _deserialize(_models.PolicySetDefinition, response.json())

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore

    @overload
    async def create_or_update(
        self,
        policy_set_definition_name: str,
        parameters: _models.PolicySetDefinition,
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> _models.PolicySetDefinition:
        """This operation creates or updates a policy set definition in the given subscription with the
        given name.

        :param policy_set_definition_name: The name of the policy set definition to get. Required.
        :type policy_set_definition_name: str
        :param parameters: The policy set definition properties. Required.
        :type parameters: ~azure.mgmt.resource.policy.models.PolicySetDefinition
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: PolicySetDefinition. The PolicySetDefinition is compatible with MutableMapping
        :rtype: ~azure.mgmt.resource.policy.models.PolicySetDefinition
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @overload
    async def create_or_update(
        self,
        policy_set_definition_name: str,
        parameters: JSON,
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> _models.PolicySetDefinition:
        """This operation creates or updates a policy set definition in the given subscription with the
        given name.

        :param policy_set_definition_name: The name of the policy set definition to get. Required.
        :type policy_set_definition_name: str
        :param parameters: The policy set definition properties. Required.
        :type parameters: JSON
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: PolicySetDefinition. The PolicySetDefinition is compatible with MutableMapping
        :rtype: ~azure.mgmt.resource.policy.models.PolicySetDefinition
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @overload
    async def create_or_update(
        self,
        policy_set_definition_name: str,
        parameters: IO[bytes],
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> _models.PolicySetDefinition:
        """This operation creates or updates a policy set definition in the given subscription with the
        given name.

        :param policy_set_definition_name: The name of the policy set definition to get. Required.
        :type policy_set_definition_name: str
        :param parameters: The policy set definition properties. Required.
        :type parameters: IO[bytes]
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: PolicySetDefinition. The PolicySetDefinition is compatible with MutableMapping
        :rtype: ~azure.mgmt.resource.policy.models.PolicySetDefinition
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @distributed_trace_async
    async def create_or_update(
        self,
        policy_set_definition_name: str,
        parameters: Union[_models.PolicySetDefinition, JSON, IO[bytes]],
        **kwargs: Any
    ) -> _models.PolicySetDefinition:
        """This operation creates or updates a policy set definition in the given subscription with the
        given name.

        :param policy_set_definition_name: The name of the policy set definition to get. Required.
        :type policy_set_definition_name: str
        :param parameters: The policy set definition properties. Is one of the following types:
         PolicySetDefinition, JSON, IO[bytes] Required.
        :type parameters: ~azure.mgmt.resource.policy.models.PolicySetDefinition or JSON or IO[bytes]
        :return: PolicySetDefinition. The PolicySetDefinition is compatible with MutableMapping
        :rtype: ~azure.mgmt.resource.policy.models.PolicySetDefinition
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[_models.PolicySetDefinition] = kwargs.pop("cls", None)

        content_type = content_type or "application/json"
        _content = None
        if isinstance(parameters, (IOBase, bytes)):
            _content = parameters
        else:
            _content = json.dumps(parameters, cls=SdkJSONEncoder, exclude_readonly=True)  # type: ignore

        _request = build_policy_set_definitions_create_or_update_request(
            policy_set_definition_name=policy_set_definition_name,
            subscription_id=self._config.subscription_id,
            content_type=content_type,
            api_version=self._config.api_version,
            content=_content,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.base_url", self._config.base_url, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = kwargs.pop("stream", False)
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200, 201]:
            if _stream:
                try:
                    await response.read()  # Load the body in memory and close the socket
                except (StreamConsumedError, StreamClosedError):
                    pass
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = _failsafe_deserialize(
                _models.ErrorResponse,
                response,
            )
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        if _stream:
            deserialized = response.iter_bytes()
        else:
            deserialized = _deserialize(_models.PolicySetDefinition, response.json())

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore

    @distributed_trace_async
    async def delete(self, policy_set_definition_name: str, **kwargs: Any) -> None:
        """This operation deletes the policy set definition in the given subscription with the given name.

        :param policy_set_definition_name: The name of the policy set definition to get. Required.
        :type policy_set_definition_name: str
        :return: None
        :rtype: None
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[None] = kwargs.pop("cls", None)

        _request = build_policy_set_definitions_delete_request(
            policy_set_definition_name=policy_set_definition_name,
            subscription_id=self._config.subscription_id,
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.base_url", self._config.base_url, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = False
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200, 204]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = _failsafe_deserialize(
                _models.ErrorResponse,
                response,
            )
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        if cls:
            return cls(pipeline_response, None, {})  # type: ignore

    @distributed_trace
    def list(
        self, *, filter: Optional[str] = None, expand: Optional[str] = None, top: Optional[int] = None, **kwargs: Any
    ) -> AsyncItemPaged["_models.PolicySetDefinition"]:
        """This operation retrieves a list of all the policy set definitions in a given subscription that
        match the optional given $filter. Valid values for $filter are: 'atExactScope()', 'policyType
        -eq {value}' or 'category eq '{value}''. If $filter is not provided, the unfiltered list
        includes all policy set definitions associated with the subscription, including those that
        apply directly or from management groups that contain the given subscription. If
        $filter=atExactScope() is provided, the returned list only includes all policy set definitions
        that at the given subscription. If $filter='policyType -eq {value}' is provided, the returned
        list only includes all policy set definitions whose type match the {value}. Possible policyType
        values are NotSpecified, BuiltIn and Custom. If $filter='category -eq {value}' is provided, the
        returned list only includes all policy set definitions whose category match the {value}.

        :keyword filter: The filter to apply on the operation. Valid values for $filter are:
         'atExactScope()', 'policyType -eq {value}' or 'category eq '{value}''. If $filter is not
         provided, no filtering is performed. If $filter=atExactScope() is provided, the returned list
         only includes all policy set definitions that at the given scope. If $filter='policyType -eq
         {value}' is provided, the returned list only includes all policy set definitions whose type
         match the {value}. Possible policyType values are NotSpecified, BuiltIn, Custom, and Static. If
         $filter='category -eq {value}' is provided, the returned list only includes all policy set
         definitions whose category match the {value}. Default value is None.
        :paramtype filter: str
        :keyword expand: Comma-separated list of additional properties to be included in the response.
         Supported values are 'LatestDefinitionVersion, EffectiveDefinitionVersion'. Default value is
         None.
        :paramtype expand: str
        :keyword top: Maximum number of records to return. When the $top filter is not provided, it
         will return 500 records. Default value is None.
        :paramtype top: int
        :return: An iterator like instance of PolicySetDefinition
        :rtype:
         ~azure.core.async_paging.AsyncItemPaged[~azure.mgmt.resource.policy.models.PolicySetDefinition]
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[List[_models.PolicySetDefinition]] = kwargs.pop("cls", None)

        error_map: MutableMapping = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        def prepare_request(next_link=None):
            if not next_link:

                _request = build_policy_set_definitions_list_request(
                    subscription_id=self._config.subscription_id,
                    filter=filter,
                    expand=expand,
                    top=top,
                    api_version=self._config.api_version,
                    headers=_headers,
                    params=_params,
                )
                path_format_arguments = {
                    "endpoint": self._serialize.url(
                        "self._config.base_url", self._config.base_url, "str", skip_quote=True
                    ),
                }
                _request.url = self._client.format_url(_request.url, **path_format_arguments)

            else:
                # make call to next link with the client's api-version
                _parsed_next_link = urllib.parse.urlparse(next_link)
                _next_request_params = case_insensitive_dict(
                    {
                        key: [urllib.parse.quote(v) for v in value]
                        for key, value in urllib.parse.parse_qs(_parsed_next_link.query).items()
                    }
                )
                _next_request_params["api-version"] = self._config.api_version
                _request = HttpRequest(
                    "GET", urllib.parse.urljoin(next_link, _parsed_next_link.path), params=_next_request_params
                )
                path_format_arguments = {
                    "endpoint": self._serialize.url(
                        "self._config.base_url", self._config.base_url, "str", skip_quote=True
                    ),
                }
                _request.url = self._client.format_url(_request.url, **path_format_arguments)

            return _request

        async def extract_data(pipeline_response):
            deserialized = pipeline_response.http_response.json()
            list_of_elem = _deserialize(List[_models.PolicySetDefinition], deserialized.get("value", []))
            if cls:
                list_of_elem = cls(list_of_elem)  # type: ignore
            return deserialized.get("nextLink") or None, AsyncList(list_of_elem)

        async def get_next(next_link=None):
            _request = prepare_request(next_link)

            _stream = False
            pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
                _request, stream=_stream, **kwargs
            )
            response = pipeline_response.http_response

            if response.status_code not in [200]:
                map_error(status_code=response.status_code, response=response, error_map=error_map)
                error = _failsafe_deserialize(
                    _models.ErrorResponse,
                    response,
                )
                raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

            return pipeline_response

        return AsyncItemPaged(get_next, extract_data)

    @distributed_trace_async
    async def get_built_in(
        self, policy_set_definition_name: str, *, expand: Optional[str] = None, **kwargs: Any
    ) -> _models.PolicySetDefinition:
        """This operation retrieves the built-in policy set definition with the given name.

        :param policy_set_definition_name: The name of the policy set definition to get. Required.
        :type policy_set_definition_name: str
        :keyword expand: Comma-separated list of additional properties to be included in the response.
         Supported values are 'LatestDefinitionVersion, EffectiveDefinitionVersion'. Default value is
         None.
        :paramtype expand: str
        :return: PolicySetDefinition. The PolicySetDefinition is compatible with MutableMapping
        :rtype: ~azure.mgmt.resource.policy.models.PolicySetDefinition
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[_models.PolicySetDefinition] = kwargs.pop("cls", None)

        _request = build_policy_set_definitions_get_built_in_request(
            policy_set_definition_name=policy_set_definition_name,
            expand=expand,
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.base_url", self._config.base_url, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = kwargs.pop("stream", False)
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                try:
                    await response.read()  # Load the body in memory and close the socket
                except (StreamConsumedError, StreamClosedError):
                    pass
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = _failsafe_deserialize(
                _models.ErrorResponse,
                response,
            )
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        if _stream:
            deserialized = response.iter_bytes()
        else:
            deserialized = _deserialize(_models.PolicySetDefinition, response.json())

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore

    @distributed_trace
    def list_built_in(
        self, *, filter: Optional[str] = None, expand: Optional[str] = None, top: Optional[int] = None, **kwargs: Any
    ) -> AsyncItemPaged["_models.PolicySetDefinition"]:
        """This operation retrieves a list of all the built-in policy set definitions that match the
        optional given $filter. If $filter='category -eq {value}' is provided, the returned list only
        includes all built-in policy set definitions whose category match the {value}.

        :keyword filter: The filter to apply on the operation. Valid values for $filter are:
         'atExactScope()', 'policyType -eq {value}' or 'category eq '{value}''. If $filter is not
         provided, no filtering is performed. If $filter=atExactScope() is provided, the returned list
         only includes all policy set definitions that at the given scope. If $filter='policyType -eq
         {value}' is provided, the returned list only includes all policy set definitions whose type
         match the {value}. Possible policyType values are NotSpecified, BuiltIn, Custom, and Static. If
         $filter='category -eq {value}' is provided, the returned list only includes all policy set
         definitions whose category match the {value}. Default value is None.
        :paramtype filter: str
        :keyword expand: Comma-separated list of additional properties to be included in the response.
         Supported values are 'LatestDefinitionVersion, EffectiveDefinitionVersion'. Default value is
         None.
        :paramtype expand: str
        :keyword top: Maximum number of records to return. When the $top filter is not provided, it
         will return 500 records. Default value is None.
        :paramtype top: int
        :return: An iterator like instance of PolicySetDefinition
        :rtype:
         ~azure.core.async_paging.AsyncItemPaged[~azure.mgmt.resource.policy.models.PolicySetDefinition]
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[List[_models.PolicySetDefinition]] = kwargs.pop("cls", None)

        error_map: MutableMapping = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        def prepare_request(next_link=None):
            if not next_link:

                _request = build_policy_set_definitions_list_built_in_request(
                    filter=filter,
                    expand=expand,
                    top=top,
                    api_version=self._config.api_version,
                    headers=_headers,
                    params=_params,
                )
                path_format_arguments = {
                    "endpoint": self._serialize.url(
                        "self._config.base_url", self._config.base_url, "str", skip_quote=True
                    ),
                }
                _request.url = self._client.format_url(_request.url, **path_format_arguments)

            else:
                # make call to next link with the client's api-version
                _parsed_next_link = urllib.parse.urlparse(next_link)
                _next_request_params = case_insensitive_dict(
                    {
                        key: [urllib.parse.quote(v) for v in value]
                        for key, value in urllib.parse.parse_qs(_parsed_next_link.query).items()
                    }
                )
                _next_request_params["api-version"] = self._config.api_version
                _request = HttpRequest(
                    "GET", urllib.parse.urljoin(next_link, _parsed_next_link.path), params=_next_request_params
                )
                path_format_arguments = {
                    "endpoint": self._serialize.url(
                        "self._config.base_url", self._config.base_url, "str", skip_quote=True
                    ),
                }
                _request.url = self._client.format_url(_request.url, **path_format_arguments)

            return _request

        async def extract_data(pipeline_response):
            deserialized = pipeline_response.http_response.json()
            list_of_elem = _deserialize(List[_models.PolicySetDefinition], deserialized.get("value", []))
            if cls:
                list_of_elem = cls(list_of_elem)  # type: ignore
            return deserialized.get("nextLink") or None, AsyncList(list_of_elem)

        async def get_next(next_link=None):
            _request = prepare_request(next_link)

            _stream = False
            pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
                _request, stream=_stream, **kwargs
            )
            response = pipeline_response.http_response

            if response.status_code not in [200]:
                map_error(status_code=response.status_code, response=response, error_map=error_map)
                error = _failsafe_deserialize(
                    _models.ErrorResponse,
                    response,
                )
                raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

            return pipeline_response

        return AsyncItemPaged(get_next, extract_data)

    @distributed_trace_async
    async def get_at_management_group(
        self, management_group_id: str, policy_set_definition_name: str, *, expand: Optional[str] = None, **kwargs: Any
    ) -> _models.PolicySetDefinition:
        """This operation retrieves the policy set definition in the given management group with the given
        name.

        :param management_group_id: The ID of the management group. Required.
        :type management_group_id: str
        :param policy_set_definition_name: The name of the policy set definition to get. Required.
        :type policy_set_definition_name: str
        :keyword expand: Comma-separated list of additional properties to be included in the response.
         Supported values are 'LatestDefinitionVersion, EffectiveDefinitionVersion'. Default value is
         None.
        :paramtype expand: str
        :return: PolicySetDefinition. The PolicySetDefinition is compatible with MutableMapping
        :rtype: ~azure.mgmt.resource.policy.models.PolicySetDefinition
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[_models.PolicySetDefinition] = kwargs.pop("cls", None)

        _request = build_policy_set_definitions_get_at_management_group_request(
            management_group_id=management_group_id,
            policy_set_definition_name=policy_set_definition_name,
            expand=expand,
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.base_url", self._config.base_url, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = kwargs.pop("stream", False)
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                try:
                    await response.read()  # Load the body in memory and close the socket
                except (StreamConsumedError, StreamClosedError):
                    pass
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = _failsafe_deserialize(
                _models.ErrorResponse,
                response,
            )
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        if _stream:
            deserialized = response.iter_bytes()
        else:
            deserialized = _deserialize(_models.PolicySetDefinition, response.json())

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore

    @overload
    async def create_or_update_at_management_group(
        self,
        management_group_id: str,
        policy_set_definition_name: str,
        parameters: _models.PolicySetDefinition,
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> _models.PolicySetDefinition:
        """This operation creates or updates a policy set definition in the given management group with
        the given name.

        :param management_group_id: The ID of the management group. Required.
        :type management_group_id: str
        :param policy_set_definition_name: The name of the policy set definition to get. Required.
        :type policy_set_definition_name: str
        :param parameters: The policy set definition properties. Required.
        :type parameters: ~azure.mgmt.resource.policy.models.PolicySetDefinition
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: PolicySetDefinition. The PolicySetDefinition is compatible with MutableMapping
        :rtype: ~azure.mgmt.resource.policy.models.PolicySetDefinition
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @overload
    async def create_or_update_at_management_group(
        self,
        management_group_id: str,
        policy_set_definition_name: str,
        parameters: JSON,
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> _models.PolicySetDefinition:
        """This operation creates or updates a policy set definition in the given management group with
        the given name.

        :param management_group_id: The ID of the management group. Required.
        :type management_group_id: str
        :param policy_set_definition_name: The name of the policy set definition to get. Required.
        :type policy_set_definition_name: str
        :param parameters: The policy set definition properties. Required.
        :type parameters: JSON
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: PolicySetDefinition. The PolicySetDefinition is compatible with MutableMapping
        :rtype: ~azure.mgmt.resource.policy.models.PolicySetDefinition
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @overload
    async def create_or_update_at_management_group(
        self,
        management_group_id: str,
        policy_set_definition_name: str,
        parameters: IO[bytes],
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> _models.PolicySetDefinition:
        """This operation creates or updates a policy set definition in the given management group with
        the given name.

        :param management_group_id: The ID of the management group. Required.
        :type management_group_id: str
        :param policy_set_definition_name: The name of the policy set definition to get. Required.
        :type policy_set_definition_name: str
        :param parameters: The policy set definition properties. Required.
        :type parameters: IO[bytes]
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: PolicySetDefinition. The PolicySetDefinition is compatible with MutableMapping
        :rtype: ~azure.mgmt.resource.policy.models.PolicySetDefinition
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @distributed_trace_async
    async def create_or_update_at_management_group(
        self,
        management_group_id: str,
        policy_set_definition_name: str,
        parameters: Union[_models.PolicySetDefinition, JSON, IO[bytes]],
        **kwargs: Any
    ) -> _models.PolicySetDefinition:
        """This operation creates or updates a policy set definition in the given management group with
        the given name.

        :param management_group_id: The ID of the management group. Required.
        :type management_group_id: str
        :param policy_set_definition_name: The name of the policy set definition to get. Required.
        :type policy_set_definition_name: str
        :param parameters: The policy set definition properties. Is one of the following types:
         PolicySetDefinition, JSON, IO[bytes] Required.
        :type parameters: ~azure.mgmt.resource.policy.models.PolicySetDefinition or JSON or IO[bytes]
        :return: PolicySetDefinition. The PolicySetDefinition is compatible with MutableMapping
        :rtype: ~azure.mgmt.resource.policy.models.PolicySetDefinition
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[_models.PolicySetDefinition] = kwargs.pop("cls", None)

        content_type = content_type or "application/json"
        _content = None
        if isinstance(parameters, (IOBase, bytes)):
            _content = parameters
        else:
            _content = json.dumps(parameters, cls=SdkJSONEncoder, exclude_readonly=True)  # type: ignore

        _request = build_policy_set_definitions_create_or_update_at_management_group_request(
            management_group_id=management_group_id,
            policy_set_definition_name=policy_set_definition_name,
            content_type=content_type,
            api_version=self._config.api_version,
            content=_content,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.base_url", self._config.base_url, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = kwargs.pop("stream", False)
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200, 201]:
            if _stream:
                try:
                    await response.read()  # Load the body in memory and close the socket
                except (StreamConsumedError, StreamClosedError):
                    pass
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = _failsafe_deserialize(
                _models.ErrorResponse,
                response,
            )
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        if _stream:
            deserialized = response.iter_bytes()
        else:
            deserialized = _deserialize(_models.PolicySetDefinition, response.json())

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore

    @distributed_trace_async
    async def delete_at_management_group(
        self, management_group_id: str, policy_set_definition_name: str, **kwargs: Any
    ) -> None:
        """This operation deletes the policy set definition in the given management group with the given
        name.

        :param management_group_id: The ID of the management group. Required.
        :type management_group_id: str
        :param policy_set_definition_name: The name of the policy set definition to get. Required.
        :type policy_set_definition_name: str
        :return: None
        :rtype: None
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[None] = kwargs.pop("cls", None)

        _request = build_policy_set_definitions_delete_at_management_group_request(
            management_group_id=management_group_id,
            policy_set_definition_name=policy_set_definition_name,
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.base_url", self._config.base_url, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = False
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200, 204]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = _failsafe_deserialize(
                _models.ErrorResponse,
                response,
            )
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        if cls:
            return cls(pipeline_response, None, {})  # type: ignore

    @distributed_trace
    def list_by_management_group(
        self,
        management_group_id: str,
        *,
        filter: Optional[str] = None,
        expand: Optional[str] = None,
        top: Optional[int] = None,
        **kwargs: Any
    ) -> AsyncItemPaged["_models.PolicySetDefinition"]:
        """This operation retrieves a list of all the policy set definitions in a given management group
        that match the optional given $filter. Valid values for $filter are: 'atExactScope()',
        'policyType -eq {value}' or 'category eq '{value}''. If $filter is not provided, the unfiltered
        list includes all policy set definitions associated with the management group, including those
        that apply directly or from management groups that contain the given management group. If
        $filter=atExactScope() is provided, the returned list only includes all policy set definitions
        that at the given management group. If $filter='policyType -eq {value}' is provided, the
        returned list only includes all policy set definitions whose type match the {value}. Possible
        policyType values are NotSpecified, BuiltIn and Custom. If $filter='category -eq {value}' is
        provided, the returned list only includes all policy set definitions whose category match the
        {value}.

        :param management_group_id: The ID of the management group. Required.
        :type management_group_id: str
        :keyword filter: The filter to apply on the operation. Valid values for $filter are:
         'atExactScope()', 'policyType -eq {value}' or 'category eq '{value}''. If $filter is not
         provided, no filtering is performed. If $filter=atExactScope() is provided, the returned list
         only includes all policy set definitions that at the given scope. If $filter='policyType -eq
         {value}' is provided, the returned list only includes all policy set definitions whose type
         match the {value}. Possible policyType values are NotSpecified, BuiltIn, Custom, and Static. If
         $filter='category -eq {value}' is provided, the returned list only includes all policy set
         definitions whose category match the {value}. Default value is None.
        :paramtype filter: str
        :keyword expand: Comma-separated list of additional properties to be included in the response.
         Supported values are 'LatestDefinitionVersion, EffectiveDefinitionVersion'. Default value is
         None.
        :paramtype expand: str
        :keyword top: Maximum number of records to return. When the $top filter is not provided, it
         will return 500 records. Default value is None.
        :paramtype top: int
        :return: An iterator like instance of PolicySetDefinition
        :rtype:
         ~azure.core.async_paging.AsyncItemPaged[~azure.mgmt.resource.policy.models.PolicySetDefinition]
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[List[_models.PolicySetDefinition]] = kwargs.pop("cls", None)

        error_map: MutableMapping = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        def prepare_request(next_link=None):
            if not next_link:

                _request = build_policy_set_definitions_list_by_management_group_request(
                    management_group_id=management_group_id,
                    filter=filter,
                    expand=expand,
                    top=top,
                    api_version=self._config.api_version,
                    headers=_headers,
                    params=_params,
                )
                path_format_arguments = {
                    "endpoint": self._serialize.url(
                        "self._config.base_url", self._config.base_url, "str", skip_quote=True
                    ),
                }
                _request.url = self._client.format_url(_request.url, **path_format_arguments)

            else:
                # make call to next link with the client's api-version
                _parsed_next_link = urllib.parse.urlparse(next_link)
                _next_request_params = case_insensitive_dict(
                    {
                        key: [urllib.parse.quote(v) for v in value]
                        for key, value in urllib.parse.parse_qs(_parsed_next_link.query).items()
                    }
                )
                _next_request_params["api-version"] = self._config.api_version
                _request = HttpRequest(
                    "GET", urllib.parse.urljoin(next_link, _parsed_next_link.path), params=_next_request_params
                )
                path_format_arguments = {
                    "endpoint": self._serialize.url(
                        "self._config.base_url", self._config.base_url, "str", skip_quote=True
                    ),
                }
                _request.url = self._client.format_url(_request.url, **path_format_arguments)

            return _request

        async def extract_data(pipeline_response):
            deserialized = pipeline_response.http_response.json()
            list_of_elem = _deserialize(List[_models.PolicySetDefinition], deserialized.get("value", []))
            if cls:
                list_of_elem = cls(list_of_elem)  # type: ignore
            return deserialized.get("nextLink") or None, AsyncList(list_of_elem)

        async def get_next(next_link=None):
            _request = prepare_request(next_link)

            _stream = False
            pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
                _request, stream=_stream, **kwargs
            )
            response = pipeline_response.http_response

            if response.status_code not in [200]:
                map_error(status_code=response.status_code, response=response, error_map=error_map)
                error = _failsafe_deserialize(
                    _models.ErrorResponse,
                    response,
                )
                raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

            return pipeline_response

        return AsyncItemPaged(get_next, extract_data)


class PolicySetDefinitionVersionsOperations:
    """
    .. warning::
        **DO NOT** instantiate this class directly.

        Instead, you should access the following operations through
        :class:`~azure.mgmt.resource.policy.aio.PolicyClient`'s
        :attr:`policy_set_definition_versions` attribute.
    """

    def __init__(self, *args, **kwargs) -> None:
        input_args = list(args)
        self._client: AsyncPipelineClient = input_args.pop(0) if input_args else kwargs.pop("client")
        self._config: PolicyClientConfiguration = input_args.pop(0) if input_args else kwargs.pop("config")
        self._serialize: Serializer = input_args.pop(0) if input_args else kwargs.pop("serializer")
        self._deserialize: Deserializer = input_args.pop(0) if input_args else kwargs.pop("deserializer")

    @distributed_trace_async
    async def get(
        self,
        policy_set_definition_name: str,
        policy_definition_version: str,
        *,
        expand: Optional[str] = None,
        **kwargs: Any
    ) -> _models.PolicySetDefinitionVersion:
        """This operation retrieves the policy set definition version in the given subscription with the
        given name and version.

        :param policy_set_definition_name: The name of the policy set definition. Required.
        :type policy_set_definition_name: str
        :param policy_definition_version: The policy set definition version.  The format is x.y.z where
         x is the major version number, y is the minor version number, and z is the patch number.
         Required.
        :type policy_definition_version: str
        :keyword expand: Comma-separated list of additional properties to be included in the response.
         Supported values are 'LatestDefinitionVersion, EffectiveDefinitionVersion'. Default value is
         None.
        :paramtype expand: str
        :return: PolicySetDefinitionVersion. The PolicySetDefinitionVersion is compatible with
         MutableMapping
        :rtype: ~azure.mgmt.resource.policy.models.PolicySetDefinitionVersion
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[_models.PolicySetDefinitionVersion] = kwargs.pop("cls", None)

        _request = build_policy_set_definition_versions_get_request(
            policy_set_definition_name=policy_set_definition_name,
            policy_definition_version=policy_definition_version,
            subscription_id=self._config.subscription_id,
            expand=expand,
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.base_url", self._config.base_url, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = kwargs.pop("stream", False)
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                try:
                    await response.read()  # Load the body in memory and close the socket
                except (StreamConsumedError, StreamClosedError):
                    pass
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = _failsafe_deserialize(
                _models.ErrorResponse,
                response,
            )
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        if _stream:
            deserialized = response.iter_bytes()
        else:
            deserialized = _deserialize(_models.PolicySetDefinitionVersion, response.json())

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore

    @overload
    async def create_or_update(
        self,
        policy_set_definition_name: str,
        policy_definition_version: str,
        parameters: _models.PolicySetDefinitionVersion,
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> _models.PolicySetDefinitionVersion:
        """This operation creates or updates a policy set definition version in the given subscription
        with the given name and version.

        :param policy_set_definition_name: The name of the policy set definition. Required.
        :type policy_set_definition_name: str
        :param policy_definition_version: The policy set definition version.  The format is x.y.z where
         x is the major version number, y is the minor version number, and z is the patch number.
         Required.
        :type policy_definition_version: str
        :param parameters: The policy set definition properties. Required.
        :type parameters: ~azure.mgmt.resource.policy.models.PolicySetDefinitionVersion
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: PolicySetDefinitionVersion. The PolicySetDefinitionVersion is compatible with
         MutableMapping
        :rtype: ~azure.mgmt.resource.policy.models.PolicySetDefinitionVersion
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @overload
    async def create_or_update(
        self,
        policy_set_definition_name: str,
        policy_definition_version: str,
        parameters: JSON,
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> _models.PolicySetDefinitionVersion:
        """This operation creates or updates a policy set definition version in the given subscription
        with the given name and version.

        :param policy_set_definition_name: The name of the policy set definition. Required.
        :type policy_set_definition_name: str
        :param policy_definition_version: The policy set definition version.  The format is x.y.z where
         x is the major version number, y is the minor version number, and z is the patch number.
         Required.
        :type policy_definition_version: str
        :param parameters: The policy set definition properties. Required.
        :type parameters: JSON
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: PolicySetDefinitionVersion. The PolicySetDefinitionVersion is compatible with
         MutableMapping
        :rtype: ~azure.mgmt.resource.policy.models.PolicySetDefinitionVersion
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @overload
    async def create_or_update(
        self,
        policy_set_definition_name: str,
        policy_definition_version: str,
        parameters: IO[bytes],
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> _models.PolicySetDefinitionVersion:
        """This operation creates or updates a policy set definition version in the given subscription
        with the given name and version.

        :param policy_set_definition_name: The name of the policy set definition. Required.
        :type policy_set_definition_name: str
        :param policy_definition_version: The policy set definition version.  The format is x.y.z where
         x is the major version number, y is the minor version number, and z is the patch number.
         Required.
        :type policy_definition_version: str
        :param parameters: The policy set definition properties. Required.
        :type parameters: IO[bytes]
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: PolicySetDefinitionVersion. The PolicySetDefinitionVersion is compatible with
         MutableMapping
        :rtype: ~azure.mgmt.resource.policy.models.PolicySetDefinitionVersion
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @distributed_trace_async
    async def create_or_update(
        self,
        policy_set_definition_name: str,
        policy_definition_version: str,
        parameters: Union[_models.PolicySetDefinitionVersion, JSON, IO[bytes]],
        **kwargs: Any
    ) -> _models.PolicySetDefinitionVersion:
        """This operation creates or updates a policy set definition version in the given subscription
        with the given name and version.

        :param policy_set_definition_name: The name of the policy set definition. Required.
        :type policy_set_definition_name: str
        :param policy_definition_version: The policy set definition version.  The format is x.y.z where
         x is the major version number, y is the minor version number, and z is the patch number.
         Required.
        :type policy_definition_version: str
        :param parameters: The policy set definition properties. Is one of the following types:
         PolicySetDefinitionVersion, JSON, IO[bytes] Required.
        :type parameters: ~azure.mgmt.resource.policy.models.PolicySetDefinitionVersion or JSON or
         IO[bytes]
        :return: PolicySetDefinitionVersion. The PolicySetDefinitionVersion is compatible with
         MutableMapping
        :rtype: ~azure.mgmt.resource.policy.models.PolicySetDefinitionVersion
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[_models.PolicySetDefinitionVersion] = kwargs.pop("cls", None)

        content_type = content_type or "application/json"
        _content = None
        if isinstance(parameters, (IOBase, bytes)):
            _content = parameters
        else:
            _content = json.dumps(parameters, cls=SdkJSONEncoder, exclude_readonly=True)  # type: ignore

        _request = build_policy_set_definition_versions_create_or_update_request(
            policy_set_definition_name=policy_set_definition_name,
            policy_definition_version=policy_definition_version,
            subscription_id=self._config.subscription_id,
            content_type=content_type,
            api_version=self._config.api_version,
            content=_content,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.base_url", self._config.base_url, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = kwargs.pop("stream", False)
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200, 201]:
            if _stream:
                try:
                    await response.read()  # Load the body in memory and close the socket
                except (StreamConsumedError, StreamClosedError):
                    pass
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = _failsafe_deserialize(
                _models.ErrorResponse,
                response,
            )
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        if _stream:
            deserialized = response.iter_bytes()
        else:
            deserialized = _deserialize(_models.PolicySetDefinitionVersion, response.json())

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore

    @distributed_trace_async
    async def delete(self, policy_set_definition_name: str, policy_definition_version: str, **kwargs: Any) -> None:
        """This operation deletes the policy set definition version in the given subscription with the
        given name and version.

        :param policy_set_definition_name: The name of the policy set definition. Required.
        :type policy_set_definition_name: str
        :param policy_definition_version: The policy set definition version.  The format is x.y.z where
         x is the major version number, y is the minor version number, and z is the patch number.
         Required.
        :type policy_definition_version: str
        :return: None
        :rtype: None
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[None] = kwargs.pop("cls", None)

        _request = build_policy_set_definition_versions_delete_request(
            policy_set_definition_name=policy_set_definition_name,
            policy_definition_version=policy_definition_version,
            subscription_id=self._config.subscription_id,
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.base_url", self._config.base_url, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = False
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200, 204]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = _failsafe_deserialize(
                _models.ErrorResponse,
                response,
            )
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        if cls:
            return cls(pipeline_response, None, {})  # type: ignore

    @distributed_trace
    def list(
        self, policy_set_definition_name: str, *, expand: Optional[str] = None, top: Optional[int] = None, **kwargs: Any
    ) -> AsyncItemPaged["_models.PolicySetDefinitionVersion"]:
        """This operation retrieves a list of all the policy set definition versions for the given policy
        set definition.

        :param policy_set_definition_name: The name of the policy set definition. Required.
        :type policy_set_definition_name: str
        :keyword expand: Comma-separated list of additional properties to be included in the response.
         Supported values are 'LatestDefinitionVersion, EffectiveDefinitionVersion'. Default value is
         None.
        :paramtype expand: str
        :keyword top: Maximum number of records to return. When the $top filter is not provided, it
         will return 500 records. Default value is None.
        :paramtype top: int
        :return: An iterator like instance of PolicySetDefinitionVersion
        :rtype:
         ~azure.core.async_paging.AsyncItemPaged[~azure.mgmt.resource.policy.models.PolicySetDefinitionVersion]
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[List[_models.PolicySetDefinitionVersion]] = kwargs.pop("cls", None)

        error_map: MutableMapping = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        def prepare_request(next_link=None):
            if not next_link:

                _request = build_policy_set_definition_versions_list_request(
                    policy_set_definition_name=policy_set_definition_name,
                    subscription_id=self._config.subscription_id,
                    expand=expand,
                    top=top,
                    api_version=self._config.api_version,
                    headers=_headers,
                    params=_params,
                )
                path_format_arguments = {
                    "endpoint": self._serialize.url(
                        "self._config.base_url", self._config.base_url, "str", skip_quote=True
                    ),
                }
                _request.url = self._client.format_url(_request.url, **path_format_arguments)

            else:
                # make call to next link with the client's api-version
                _parsed_next_link = urllib.parse.urlparse(next_link)
                _next_request_params = case_insensitive_dict(
                    {
                        key: [urllib.parse.quote(v) for v in value]
                        for key, value in urllib.parse.parse_qs(_parsed_next_link.query).items()
                    }
                )
                _next_request_params["api-version"] = self._config.api_version
                _request = HttpRequest(
                    "GET", urllib.parse.urljoin(next_link, _parsed_next_link.path), params=_next_request_params
                )
                path_format_arguments = {
                    "endpoint": self._serialize.url(
                        "self._config.base_url", self._config.base_url, "str", skip_quote=True
                    ),
                }
                _request.url = self._client.format_url(_request.url, **path_format_arguments)

            return _request

        async def extract_data(pipeline_response):
            deserialized = pipeline_response.http_response.json()
            list_of_elem = _deserialize(List[_models.PolicySetDefinitionVersion], deserialized.get("value", []))
            if cls:
                list_of_elem = cls(list_of_elem)  # type: ignore
            return deserialized.get("nextLink") or None, AsyncList(list_of_elem)

        async def get_next(next_link=None):
            _request = prepare_request(next_link)

            _stream = False
            pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
                _request, stream=_stream, **kwargs
            )
            response = pipeline_response.http_response

            if response.status_code not in [200]:
                map_error(status_code=response.status_code, response=response, error_map=error_map)
                error = _failsafe_deserialize(
                    _models.ErrorResponse,
                    response,
                )
                raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

            return pipeline_response

        return AsyncItemPaged(get_next, extract_data)

    @distributed_trace_async
    async def get_built_in(
        self,
        policy_set_definition_name: str,
        policy_definition_version: str,
        *,
        expand: Optional[str] = None,
        **kwargs: Any
    ) -> _models.PolicySetDefinitionVersion:
        """This operation retrieves the built-in policy set definition version with the given name and
        version.

        :param policy_set_definition_name: The name of the policy set definition. Required.
        :type policy_set_definition_name: str
        :param policy_definition_version: The policy set definition version.  The format is x.y.z where
         x is the major version number, y is the minor version number, and z is the patch number.
         Required.
        :type policy_definition_version: str
        :keyword expand: Comma-separated list of additional properties to be included in the response.
         Supported values are 'LatestDefinitionVersion, EffectiveDefinitionVersion'. Default value is
         None.
        :paramtype expand: str
        :return: PolicySetDefinitionVersion. The PolicySetDefinitionVersion is compatible with
         MutableMapping
        :rtype: ~azure.mgmt.resource.policy.models.PolicySetDefinitionVersion
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[_models.PolicySetDefinitionVersion] = kwargs.pop("cls", None)

        _request = build_policy_set_definition_versions_get_built_in_request(
            policy_set_definition_name=policy_set_definition_name,
            policy_definition_version=policy_definition_version,
            expand=expand,
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.base_url", self._config.base_url, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = kwargs.pop("stream", False)
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                try:
                    await response.read()  # Load the body in memory and close the socket
                except (StreamConsumedError, StreamClosedError):
                    pass
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = _failsafe_deserialize(
                _models.ErrorResponse,
                response,
            )
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        if _stream:
            deserialized = response.iter_bytes()
        else:
            deserialized = _deserialize(_models.PolicySetDefinitionVersion, response.json())

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore

    @distributed_trace
    def list_built_in(
        self, policy_set_definition_name: str, *, expand: Optional[str] = None, top: Optional[int] = None, **kwargs: Any
    ) -> AsyncItemPaged["_models.PolicySetDefinitionVersion"]:
        """This operation retrieves a list of all the built-in policy set definition versions for the
        given built-in policy set definition.

        :param policy_set_definition_name: The name of the policy set definition. Required.
        :type policy_set_definition_name: str
        :keyword expand: Comma-separated list of additional properties to be included in the response.
         Supported values are 'LatestDefinitionVersion, EffectiveDefinitionVersion'. Default value is
         None.
        :paramtype expand: str
        :keyword top: Maximum number of records to return. When the $top filter is not provided, it
         will return 500 records. Default value is None.
        :paramtype top: int
        :return: An iterator like instance of PolicySetDefinitionVersion
        :rtype:
         ~azure.core.async_paging.AsyncItemPaged[~azure.mgmt.resource.policy.models.PolicySetDefinitionVersion]
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[List[_models.PolicySetDefinitionVersion]] = kwargs.pop("cls", None)

        error_map: MutableMapping = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        def prepare_request(next_link=None):
            if not next_link:

                _request = build_policy_set_definition_versions_list_built_in_request(
                    policy_set_definition_name=policy_set_definition_name,
                    expand=expand,
                    top=top,
                    api_version=self._config.api_version,
                    headers=_headers,
                    params=_params,
                )
                path_format_arguments = {
                    "endpoint": self._serialize.url(
                        "self._config.base_url", self._config.base_url, "str", skip_quote=True
                    ),
                }
                _request.url = self._client.format_url(_request.url, **path_format_arguments)

            else:
                # make call to next link with the client's api-version
                _parsed_next_link = urllib.parse.urlparse(next_link)
                _next_request_params = case_insensitive_dict(
                    {
                        key: [urllib.parse.quote(v) for v in value]
                        for key, value in urllib.parse.parse_qs(_parsed_next_link.query).items()
                    }
                )
                _next_request_params["api-version"] = self._config.api_version
                _request = HttpRequest(
                    "GET", urllib.parse.urljoin(next_link, _parsed_next_link.path), params=_next_request_params
                )
                path_format_arguments = {
                    "endpoint": self._serialize.url(
                        "self._config.base_url", self._config.base_url, "str", skip_quote=True
                    ),
                }
                _request.url = self._client.format_url(_request.url, **path_format_arguments)

            return _request

        async def extract_data(pipeline_response):
            deserialized = pipeline_response.http_response.json()
            list_of_elem = _deserialize(List[_models.PolicySetDefinitionVersion], deserialized.get("value", []))
            if cls:
                list_of_elem = cls(list_of_elem)  # type: ignore
            return deserialized.get("nextLink") or None, AsyncList(list_of_elem)

        async def get_next(next_link=None):
            _request = prepare_request(next_link)

            _stream = False
            pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
                _request, stream=_stream, **kwargs
            )
            response = pipeline_response.http_response

            if response.status_code not in [200]:
                map_error(status_code=response.status_code, response=response, error_map=error_map)
                error = _failsafe_deserialize(
                    _models.ErrorResponse,
                    response,
                )
                raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

            return pipeline_response

        return AsyncItemPaged(get_next, extract_data)

    @distributed_trace_async
    async def get_at_management_group(
        self,
        management_group_name: str,
        policy_set_definition_name: str,
        policy_definition_version: str,
        *,
        expand: Optional[str] = None,
        **kwargs: Any
    ) -> _models.PolicySetDefinitionVersion:
        """This operation retrieves the policy set definition version in the given management group with
        the given name and version.

        :param management_group_name: The name of the management group. The name is case insensitive.
         Required.
        :type management_group_name: str
        :param policy_set_definition_name: The name of the policy set definition. Required.
        :type policy_set_definition_name: str
        :param policy_definition_version: The policy set definition version.  The format is x.y.z where
         x is the major version number, y is the minor version number, and z is the patch number.
         Required.
        :type policy_definition_version: str
        :keyword expand: Comma-separated list of additional properties to be included in the response.
         Supported values are 'LatestDefinitionVersion, EffectiveDefinitionVersion'. Default value is
         None.
        :paramtype expand: str
        :return: PolicySetDefinitionVersion. The PolicySetDefinitionVersion is compatible with
         MutableMapping
        :rtype: ~azure.mgmt.resource.policy.models.PolicySetDefinitionVersion
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[_models.PolicySetDefinitionVersion] = kwargs.pop("cls", None)

        _request = build_policy_set_definition_versions_get_at_management_group_request(
            management_group_name=management_group_name,
            policy_set_definition_name=policy_set_definition_name,
            policy_definition_version=policy_definition_version,
            expand=expand,
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.base_url", self._config.base_url, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = kwargs.pop("stream", False)
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                try:
                    await response.read()  # Load the body in memory and close the socket
                except (StreamConsumedError, StreamClosedError):
                    pass
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = _failsafe_deserialize(
                _models.ErrorResponse,
                response,
            )
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        if _stream:
            deserialized = response.iter_bytes()
        else:
            deserialized = _deserialize(_models.PolicySetDefinitionVersion, response.json())

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore

    @overload
    async def create_or_update_at_management_group(
        self,
        management_group_name: str,
        policy_set_definition_name: str,
        policy_definition_version: str,
        parameters: _models.PolicySetDefinitionVersion,
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> _models.PolicySetDefinitionVersion:
        """This operation creates or updates a policy set definition version in the given management group
        with the given name and version.

        :param management_group_name: The name of the management group. The name is case insensitive.
         Required.
        :type management_group_name: str
        :param policy_set_definition_name: The name of the policy set definition. Required.
        :type policy_set_definition_name: str
        :param policy_definition_version: The policy set definition version.  The format is x.y.z where
         x is the major version number, y is the minor version number, and z is the patch number.
         Required.
        :type policy_definition_version: str
        :param parameters: The policy set definition version properties. Required.
        :type parameters: ~azure.mgmt.resource.policy.models.PolicySetDefinitionVersion
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: PolicySetDefinitionVersion. The PolicySetDefinitionVersion is compatible with
         MutableMapping
        :rtype: ~azure.mgmt.resource.policy.models.PolicySetDefinitionVersion
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @overload
    async def create_or_update_at_management_group(
        self,
        management_group_name: str,
        policy_set_definition_name: str,
        policy_definition_version: str,
        parameters: JSON,
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> _models.PolicySetDefinitionVersion:
        """This operation creates or updates a policy set definition version in the given management group
        with the given name and version.

        :param management_group_name: The name of the management group. The name is case insensitive.
         Required.
        :type management_group_name: str
        :param policy_set_definition_name: The name of the policy set definition. Required.
        :type policy_set_definition_name: str
        :param policy_definition_version: The policy set definition version.  The format is x.y.z where
         x is the major version number, y is the minor version number, and z is the patch number.
         Required.
        :type policy_definition_version: str
        :param parameters: The policy set definition version properties. Required.
        :type parameters: JSON
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: PolicySetDefinitionVersion. The PolicySetDefinitionVersion is compatible with
         MutableMapping
        :rtype: ~azure.mgmt.resource.policy.models.PolicySetDefinitionVersion
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @overload
    async def create_or_update_at_management_group(
        self,
        management_group_name: str,
        policy_set_definition_name: str,
        policy_definition_version: str,
        parameters: IO[bytes],
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> _models.PolicySetDefinitionVersion:
        """This operation creates or updates a policy set definition version in the given management group
        with the given name and version.

        :param management_group_name: The name of the management group. The name is case insensitive.
         Required.
        :type management_group_name: str
        :param policy_set_definition_name: The name of the policy set definition. Required.
        :type policy_set_definition_name: str
        :param policy_definition_version: The policy set definition version.  The format is x.y.z where
         x is the major version number, y is the minor version number, and z is the patch number.
         Required.
        :type policy_definition_version: str
        :param parameters: The policy set definition version properties. Required.
        :type parameters: IO[bytes]
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: PolicySetDefinitionVersion. The PolicySetDefinitionVersion is compatible with
         MutableMapping
        :rtype: ~azure.mgmt.resource.policy.models.PolicySetDefinitionVersion
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @distributed_trace_async
    async def create_or_update_at_management_group(
        self,
        management_group_name: str,
        policy_set_definition_name: str,
        policy_definition_version: str,
        parameters: Union[_models.PolicySetDefinitionVersion, JSON, IO[bytes]],
        **kwargs: Any
    ) -> _models.PolicySetDefinitionVersion:
        """This operation creates or updates a policy set definition version in the given management group
        with the given name and version.

        :param management_group_name: The name of the management group. The name is case insensitive.
         Required.
        :type management_group_name: str
        :param policy_set_definition_name: The name of the policy set definition. Required.
        :type policy_set_definition_name: str
        :param policy_definition_version: The policy set definition version.  The format is x.y.z where
         x is the major version number, y is the minor version number, and z is the patch number.
         Required.
        :type policy_definition_version: str
        :param parameters: The policy set definition version properties. Is one of the following types:
         PolicySetDefinitionVersion, JSON, IO[bytes] Required.
        :type parameters: ~azure.mgmt.resource.policy.models.PolicySetDefinitionVersion or JSON or
         IO[bytes]
        :return: PolicySetDefinitionVersion. The PolicySetDefinitionVersion is compatible with
         MutableMapping
        :rtype: ~azure.mgmt.resource.policy.models.PolicySetDefinitionVersion
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[_models.PolicySetDefinitionVersion] = kwargs.pop("cls", None)

        content_type = content_type or "application/json"
        _content = None
        if isinstance(parameters, (IOBase, bytes)):
            _content = parameters
        else:
            _content = json.dumps(parameters, cls=SdkJSONEncoder, exclude_readonly=True)  # type: ignore

        _request = build_policy_set_definition_versions_create_or_update_at_management_group_request(
            management_group_name=management_group_name,
            policy_set_definition_name=policy_set_definition_name,
            policy_definition_version=policy_definition_version,
            content_type=content_type,
            api_version=self._config.api_version,
            content=_content,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.base_url", self._config.base_url, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = kwargs.pop("stream", False)
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200, 201]:
            if _stream:
                try:
                    await response.read()  # Load the body in memory and close the socket
                except (StreamConsumedError, StreamClosedError):
                    pass
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = _failsafe_deserialize(
                _models.ErrorResponse,
                response,
            )
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        if _stream:
            deserialized = response.iter_bytes()
        else:
            deserialized = _deserialize(_models.PolicySetDefinitionVersion, response.json())

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore

    @distributed_trace_async
    async def delete_at_management_group(
        self, management_group_name: str, policy_set_definition_name: str, policy_definition_version: str, **kwargs: Any
    ) -> None:
        """This operation deletes the policy set definition version in the given management group with the
        given name and version.

        :param management_group_name: The name of the management group. The name is case insensitive.
         Required.
        :type management_group_name: str
        :param policy_set_definition_name: The name of the policy set definition. Required.
        :type policy_set_definition_name: str
        :param policy_definition_version: The policy set definition version.  The format is x.y.z where
         x is the major version number, y is the minor version number, and z is the patch number.
         Required.
        :type policy_definition_version: str
        :return: None
        :rtype: None
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[None] = kwargs.pop("cls", None)

        _request = build_policy_set_definition_versions_delete_at_management_group_request(
            management_group_name=management_group_name,
            policy_set_definition_name=policy_set_definition_name,
            policy_definition_version=policy_definition_version,
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.base_url", self._config.base_url, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = False
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200, 204]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = _failsafe_deserialize(
                _models.ErrorResponse,
                response,
            )
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        if cls:
            return cls(pipeline_response, None, {})  # type: ignore

    @distributed_trace
    def list_by_management_group(
        self,
        management_group_name: str,
        policy_set_definition_name: str,
        *,
        expand: Optional[str] = None,
        top: Optional[int] = None,
        **kwargs: Any
    ) -> AsyncItemPaged["_models.PolicySetDefinitionVersion"]:
        """This operation retrieves a list of all the policy set definition versions for the given policy
        set definition in a given management group.

        :param management_group_name: The name of the management group. The name is case insensitive.
         Required.
        :type management_group_name: str
        :param policy_set_definition_name: The name of the policy set definition. Required.
        :type policy_set_definition_name: str
        :keyword expand: Comma-separated list of additional properties to be included in the response.
         Supported values are 'LatestDefinitionVersion, EffectiveDefinitionVersion'. Default value is
         None.
        :paramtype expand: str
        :keyword top: Maximum number of records to return. When the $top filter is not provided, it
         will return 500 records. Default value is None.
        :paramtype top: int
        :return: An iterator like instance of PolicySetDefinitionVersion
        :rtype:
         ~azure.core.async_paging.AsyncItemPaged[~azure.mgmt.resource.policy.models.PolicySetDefinitionVersion]
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[List[_models.PolicySetDefinitionVersion]] = kwargs.pop("cls", None)

        error_map: MutableMapping = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        def prepare_request(next_link=None):
            if not next_link:

                _request = build_policy_set_definition_versions_list_by_management_group_request(
                    management_group_name=management_group_name,
                    policy_set_definition_name=policy_set_definition_name,
                    expand=expand,
                    top=top,
                    api_version=self._config.api_version,
                    headers=_headers,
                    params=_params,
                )
                path_format_arguments = {
                    "endpoint": self._serialize.url(
                        "self._config.base_url", self._config.base_url, "str", skip_quote=True
                    ),
                }
                _request.url = self._client.format_url(_request.url, **path_format_arguments)

            else:
                # make call to next link with the client's api-version
                _parsed_next_link = urllib.parse.urlparse(next_link)
                _next_request_params = case_insensitive_dict(
                    {
                        key: [urllib.parse.quote(v) for v in value]
                        for key, value in urllib.parse.parse_qs(_parsed_next_link.query).items()
                    }
                )
                _next_request_params["api-version"] = self._config.api_version
                _request = HttpRequest(
                    "GET", urllib.parse.urljoin(next_link, _parsed_next_link.path), params=_next_request_params
                )
                path_format_arguments = {
                    "endpoint": self._serialize.url(
                        "self._config.base_url", self._config.base_url, "str", skip_quote=True
                    ),
                }
                _request.url = self._client.format_url(_request.url, **path_format_arguments)

            return _request

        async def extract_data(pipeline_response):
            deserialized = pipeline_response.http_response.json()
            list_of_elem = _deserialize(List[_models.PolicySetDefinitionVersion], deserialized.get("value", []))
            if cls:
                list_of_elem = cls(list_of_elem)  # type: ignore
            return deserialized.get("nextLink") or None, AsyncList(list_of_elem)

        async def get_next(next_link=None):
            _request = prepare_request(next_link)

            _stream = False
            pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
                _request, stream=_stream, **kwargs
            )
            response = pipeline_response.http_response

            if response.status_code not in [200]:
                map_error(status_code=response.status_code, response=response, error_map=error_map)
                error = _failsafe_deserialize(
                    _models.ErrorResponse,
                    response,
                )
                raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

            return pipeline_response

        return AsyncItemPaged(get_next, extract_data)

    @distributed_trace_async
    async def list_all_builtins(self, **kwargs: Any) -> _models.PolicySetDefinitionVersionListResult:
        """Lists all built-in policy set definition versions.

        This operation lists all the built-in policy set definition versions for all built-in policy
        set definitions.

        :return: PolicySetDefinitionVersionListResult. The PolicySetDefinitionVersionListResult is
         compatible with MutableMapping
        :rtype: ~azure.mgmt.resource.policy.models.PolicySetDefinitionVersionListResult
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[_models.PolicySetDefinitionVersionListResult] = kwargs.pop("cls", None)

        _request = build_policy_set_definition_versions_list_all_builtins_request(
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.base_url", self._config.base_url, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = kwargs.pop("stream", False)
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                try:
                    await response.read()  # Load the body in memory and close the socket
                except (StreamConsumedError, StreamClosedError):
                    pass
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = _failsafe_deserialize(
                _models.ErrorResponse,
                response,
            )
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        if _stream:
            deserialized = response.iter_bytes()
        else:
            deserialized = _deserialize(_models.PolicySetDefinitionVersionListResult, response.json())

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore

    @distributed_trace_async
    async def list_all_at_management_group(
        self, management_group_name: str, **kwargs: Any
    ) -> _models.PolicySetDefinitionVersionListResult:
        """Lists all policy set definition versions at management group scope.

        This operation lists all the policy set definition versions for all policy set definitions at
        the management group scope.

        :param management_group_name: The name of the management group. The name is case insensitive.
         Required.
        :type management_group_name: str
        :return: PolicySetDefinitionVersionListResult. The PolicySetDefinitionVersionListResult is
         compatible with MutableMapping
        :rtype: ~azure.mgmt.resource.policy.models.PolicySetDefinitionVersionListResult
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[_models.PolicySetDefinitionVersionListResult] = kwargs.pop("cls", None)

        _request = build_policy_set_definition_versions_list_all_at_management_group_request(
            management_group_name=management_group_name,
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.base_url", self._config.base_url, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = kwargs.pop("stream", False)
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                try:
                    await response.read()  # Load the body in memory and close the socket
                except (StreamConsumedError, StreamClosedError):
                    pass
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = _failsafe_deserialize(
                _models.ErrorResponse,
                response,
            )
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        if _stream:
            deserialized = response.iter_bytes()
        else:
            deserialized = _deserialize(_models.PolicySetDefinitionVersionListResult, response.json())

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore

    @distributed_trace_async
    async def list_all(self, **kwargs: Any) -> _models.PolicySetDefinitionVersionListResult:
        """Lists all policy set definition versions within a subscription.

        This operation lists all the policy set definition versions for all policy set definitions
        within a subscription.

        :return: PolicySetDefinitionVersionListResult. The PolicySetDefinitionVersionListResult is
         compatible with MutableMapping
        :rtype: ~azure.mgmt.resource.policy.models.PolicySetDefinitionVersionListResult
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[_models.PolicySetDefinitionVersionListResult] = kwargs.pop("cls", None)

        _request = build_policy_set_definition_versions_list_all_request(
            subscription_id=self._config.subscription_id,
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.base_url", self._config.base_url, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = kwargs.pop("stream", False)
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                try:
                    await response.read()  # Load the body in memory and close the socket
                except (StreamConsumedError, StreamClosedError):
                    pass
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = _failsafe_deserialize(
                _models.ErrorResponse,
                response,
            )
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        if _stream:
            deserialized = response.iter_bytes()
        else:
            deserialized = _deserialize(_models.PolicySetDefinitionVersionListResult, response.json())

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore


class PolicyTokensOperations:
    """
    .. warning::
        **DO NOT** instantiate this class directly.

        Instead, you should access the following operations through
        :class:`~azure.mgmt.resource.policy.aio.PolicyClient`'s
        :attr:`policy_tokens` attribute.
    """

    def __init__(self, *args, **kwargs) -> None:
        input_args = list(args)
        self._client: AsyncPipelineClient = input_args.pop(0) if input_args else kwargs.pop("client")
        self._config: PolicyClientConfiguration = input_args.pop(0) if input_args else kwargs.pop("config")
        self._serialize: Serializer = input_args.pop(0) if input_args else kwargs.pop("serializer")
        self._deserialize: Deserializer = input_args.pop(0) if input_args else kwargs.pop("deserializer")

    @overload
    async def acquire(
        self, parameters: _models.PolicyTokenRequest, *, content_type: str = "application/json", **kwargs: Any
    ) -> _models.PolicyTokenResponse:
        """Acquires a policy token.

        This operation acquires a policy token in the given subscription for the given request body.

        :param parameters: The request body. Required.
        :type parameters: ~azure.mgmt.resource.policy.models.PolicyTokenRequest
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: PolicyTokenResponse. The PolicyTokenResponse is compatible with MutableMapping
        :rtype: ~azure.mgmt.resource.policy.models.PolicyTokenResponse
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @overload
    async def acquire(
        self, parameters: JSON, *, content_type: str = "application/json", **kwargs: Any
    ) -> _models.PolicyTokenResponse:
        """Acquires a policy token.

        This operation acquires a policy token in the given subscription for the given request body.

        :param parameters: The request body. Required.
        :type parameters: JSON
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: PolicyTokenResponse. The PolicyTokenResponse is compatible with MutableMapping
        :rtype: ~azure.mgmt.resource.policy.models.PolicyTokenResponse
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @overload
    async def acquire(
        self, parameters: IO[bytes], *, content_type: str = "application/json", **kwargs: Any
    ) -> _models.PolicyTokenResponse:
        """Acquires a policy token.

        This operation acquires a policy token in the given subscription for the given request body.

        :param parameters: The request body. Required.
        :type parameters: IO[bytes]
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: PolicyTokenResponse. The PolicyTokenResponse is compatible with MutableMapping
        :rtype: ~azure.mgmt.resource.policy.models.PolicyTokenResponse
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @distributed_trace_async
    async def acquire(
        self, parameters: Union[_models.PolicyTokenRequest, JSON, IO[bytes]], **kwargs: Any
    ) -> _models.PolicyTokenResponse:
        """Acquires a policy token.

        This operation acquires a policy token in the given subscription for the given request body.

        :param parameters: The request body. Is one of the following types: PolicyTokenRequest, JSON,
         IO[bytes] Required.
        :type parameters: ~azure.mgmt.resource.policy.models.PolicyTokenRequest or JSON or IO[bytes]
        :return: PolicyTokenResponse. The PolicyTokenResponse is compatible with MutableMapping
        :rtype: ~azure.mgmt.resource.policy.models.PolicyTokenResponse
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[_models.PolicyTokenResponse] = kwargs.pop("cls", None)

        content_type = content_type or "application/json"
        _content = None
        if isinstance(parameters, (IOBase, bytes)):
            _content = parameters
        else:
            _content = json.dumps(parameters, cls=SdkJSONEncoder, exclude_readonly=True)  # type: ignore

        _request = build_policy_tokens_acquire_request(
            subscription_id=self._config.subscription_id,
            content_type=content_type,
            api_version=self._config.api_version,
            content=_content,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.base_url", self._config.base_url, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = kwargs.pop("stream", False)
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                try:
                    await response.read()  # Load the body in memory and close the socket
                except (StreamConsumedError, StreamClosedError):
                    pass
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = _failsafe_deserialize(
                _models.ErrorResponse,
                response,
            )
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        if _stream:
            deserialized = response.iter_bytes()
        else:
            deserialized = _deserialize(_models.PolicyTokenResponse, response.json())

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore

    @overload
    async def acquire_at_management_group(
        self,
        management_group_name: str,
        parameters: _models.PolicyTokenRequest,
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> _models.PolicyTokenResponse:
        """Acquires a policy token at management group level.

        This operation acquires a policy token in the given management group for the given request
        body.

        :param management_group_name: The name of the management group. The name is case insensitive.
         Required.
        :type management_group_name: str
        :param parameters: The policy token properties. Required.
        :type parameters: ~azure.mgmt.resource.policy.models.PolicyTokenRequest
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: PolicyTokenResponse. The PolicyTokenResponse is compatible with MutableMapping
        :rtype: ~azure.mgmt.resource.policy.models.PolicyTokenResponse
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @overload
    async def acquire_at_management_group(
        self, management_group_name: str, parameters: JSON, *, content_type: str = "application/json", **kwargs: Any
    ) -> _models.PolicyTokenResponse:
        """Acquires a policy token at management group level.

        This operation acquires a policy token in the given management group for the given request
        body.

        :param management_group_name: The name of the management group. The name is case insensitive.
         Required.
        :type management_group_name: str
        :param parameters: The policy token properties. Required.
        :type parameters: JSON
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: PolicyTokenResponse. The PolicyTokenResponse is compatible with MutableMapping
        :rtype: ~azure.mgmt.resource.policy.models.PolicyTokenResponse
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @overload
    async def acquire_at_management_group(
        self,
        management_group_name: str,
        parameters: IO[bytes],
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> _models.PolicyTokenResponse:
        """Acquires a policy token at management group level.

        This operation acquires a policy token in the given management group for the given request
        body.

        :param management_group_name: The name of the management group. The name is case insensitive.
         Required.
        :type management_group_name: str
        :param parameters: The policy token properties. Required.
        :type parameters: IO[bytes]
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: PolicyTokenResponse. The PolicyTokenResponse is compatible with MutableMapping
        :rtype: ~azure.mgmt.resource.policy.models.PolicyTokenResponse
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @distributed_trace_async
    async def acquire_at_management_group(
        self, management_group_name: str, parameters: Union[_models.PolicyTokenRequest, JSON, IO[bytes]], **kwargs: Any
    ) -> _models.PolicyTokenResponse:
        """Acquires a policy token at management group level.

        This operation acquires a policy token in the given management group for the given request
        body.

        :param management_group_name: The name of the management group. The name is case insensitive.
         Required.
        :type management_group_name: str
        :param parameters: The policy token properties. Is one of the following types:
         PolicyTokenRequest, JSON, IO[bytes] Required.
        :type parameters: ~azure.mgmt.resource.policy.models.PolicyTokenRequest or JSON or IO[bytes]
        :return: PolicyTokenResponse. The PolicyTokenResponse is compatible with MutableMapping
        :rtype: ~azure.mgmt.resource.policy.models.PolicyTokenResponse
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[_models.PolicyTokenResponse] = kwargs.pop("cls", None)

        content_type = content_type or "application/json"
        _content = None
        if isinstance(parameters, (IOBase, bytes)):
            _content = parameters
        else:
            _content = json.dumps(parameters, cls=SdkJSONEncoder, exclude_readonly=True)  # type: ignore

        _request = build_policy_tokens_acquire_at_management_group_request(
            management_group_name=management_group_name,
            content_type=content_type,
            api_version=self._config.api_version,
            content=_content,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.base_url", self._config.base_url, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = kwargs.pop("stream", False)
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                try:
                    await response.read()  # Load the body in memory and close the socket
                except (StreamConsumedError, StreamClosedError):
                    pass
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = _failsafe_deserialize(
                _models.ErrorResponse,
                response,
            )
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        if _stream:
            deserialized = response.iter_bytes()
        else:
            deserialized = _deserialize(_models.PolicyTokenResponse, response.json())

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore
