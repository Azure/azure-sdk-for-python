# pylint: disable=too-many-lines,too-many-statements
# coding=utf-8
# --------------------------------------------------------------------------
# Copyright (c) Microsoft Corporation. All rights reserved.
# Licensed under the MIT License. See License.txt in the project root for license information.
# Code generated by Microsoft (R) Python Code Generator.
# Changes may cause incorrect behavior and will be lost if the code is regenerated.
# --------------------------------------------------------------------------
from io import IOBase
import json
import sys
from typing import Any, Callable, Dict, IO, Iterator, List, Optional, Type, TypeVar, Union, cast, overload

from azure.core.exceptions import (
    ClientAuthenticationError,
    HttpResponseError,
    ResourceExistsError,
    ResourceNotFoundError,
    ResourceNotModifiedError,
    StreamClosedError,
    StreamConsumedError,
    map_error,
)
from azure.core.pipeline import PipelineResponse
from azure.core.polling import LROPoller, NoPolling, PollingMethod
from azure.core.polling.base_polling import LROBasePolling
from azure.core.rest import HttpRequest, HttpResponse
from azure.core.tracing.decorator import distributed_trace
from azure.core.utils import case_insensitive_dict

from .. import _model_base, models as _models
from .._model_base import SdkJSONEncoder, _deserialize
from .._serialization import Serializer
from .._vendor import (
    FaceClientMixinABC,
    FaceServiceClientMixinABC,
    FaceSessionClientMixinABC,
    prepare_multipart_form_data,
)

if sys.version_info >= (3, 9):
    from collections.abc import MutableMapping
else:
    from typing import MutableMapping  # type: ignore  # pylint: disable=ungrouped-imports
JSON = MutableMapping[str, Any]  # pylint: disable=unsubscriptable-object
_Unset: Any = object()
T = TypeVar("T")
ClsType = Optional[Callable[[PipelineResponse[HttpRequest, HttpResponse], T, Dict[str, Any]], Any]]

_SERIALIZER = Serializer()
_SERIALIZER.client_side_validation = False


def build_face_lists_create_request(face_list_id: str, **kwargs: Any) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})

    content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/facelists/{faceListId}"
    path_format_arguments = {
        "faceListId": _SERIALIZER.url("face_list_id", face_list_id, "str"),
    }

    _url: str = _url.format(**path_format_arguments)  # type: ignore

    # Construct headers
    if content_type is not None:
        _headers["Content-Type"] = _SERIALIZER.header("content_type", content_type, "str")
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="PUT", url=_url, headers=_headers, **kwargs)


def build_face_lists_delete_request(face_list_id: str, **kwargs: Any) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})

    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/facelists/{faceListId}"
    path_format_arguments = {
        "faceListId": _SERIALIZER.url("face_list_id", face_list_id, "str"),
    }

    _url: str = _url.format(**path_format_arguments)  # type: ignore

    # Construct headers
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="DELETE", url=_url, headers=_headers, **kwargs)


def build_face_lists_get_request(
    face_list_id: str, *, return_recognition_model: Optional[bool] = None, **kwargs: Any
) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/facelists/{faceListId}"
    path_format_arguments = {
        "faceListId": _SERIALIZER.url("face_list_id", face_list_id, "str"),
    }

    _url: str = _url.format(**path_format_arguments)  # type: ignore

    # Construct parameters
    if return_recognition_model is not None:
        _params["returnRecognitionModel"] = _SERIALIZER.query(
            "return_recognition_model", return_recognition_model, "bool"
        )

    # Construct headers
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="GET", url=_url, params=_params, headers=_headers, **kwargs)


def build_face_lists_update_request(face_list_id: str, **kwargs: Any) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})

    content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/facelists/{faceListId}"
    path_format_arguments = {
        "faceListId": _SERIALIZER.url("face_list_id", face_list_id, "str"),
    }

    _url: str = _url.format(**path_format_arguments)  # type: ignore

    # Construct headers
    if content_type is not None:
        _headers["Content-Type"] = _SERIALIZER.header("content_type", content_type, "str")
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="PATCH", url=_url, headers=_headers, **kwargs)


def build_face_lists_get_face_lists_request(
    *, return_recognition_model: Optional[bool] = None, **kwargs: Any
) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/facelists"

    # Construct parameters
    if return_recognition_model is not None:
        _params["returnRecognitionModel"] = _SERIALIZER.query(
            "return_recognition_model", return_recognition_model, "bool"
        )

    # Construct headers
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="GET", url=_url, params=_params, headers=_headers, **kwargs)


def build_face_lists_add_face_from_url_request(  # pylint: disable=name-too-long
    face_list_id: str,
    *,
    target_face: Optional[List[int]] = None,
    detection_model: Optional[Union[str, _models.FaceDetectionModel]] = None,
    user_data: Optional[str] = None,
    **kwargs: Any,
) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/facelists/{faceListId}/persistedfaces"
    path_format_arguments = {
        "faceListId": _SERIALIZER.url("face_list_id", face_list_id, "str"),
    }

    _url: str = _url.format(**path_format_arguments)  # type: ignore

    # Construct parameters
    if target_face is not None:
        _params["targetFace"] = _SERIALIZER.query("target_face", target_face, "[int]", div=",")
    if detection_model is not None:
        _params["detectionModel"] = _SERIALIZER.query("detection_model", detection_model, "str")
    if user_data is not None:
        _params["userData"] = _SERIALIZER.query("user_data", user_data, "str")

    # Construct headers
    if content_type is not None:
        _headers["Content-Type"] = _SERIALIZER.header("content_type", content_type, "str")
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="POST", url=_url, params=_params, headers=_headers, **kwargs)


def build_face_lists_add_face_request(
    face_list_id: str,
    *,
    target_face: Optional[List[int]] = None,
    detection_model: Optional[Union[str, _models.FaceDetectionModel]] = None,
    user_data: Optional[str] = None,
    **kwargs: Any,
) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    content_type: str = kwargs.pop("content_type")
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/facelists/{faceListId}/persistedfaces"
    path_format_arguments = {
        "faceListId": _SERIALIZER.url("face_list_id", face_list_id, "str"),
    }

    _url: str = _url.format(**path_format_arguments)  # type: ignore

    # Construct parameters
    if target_face is not None:
        _params["targetFace"] = _SERIALIZER.query("target_face", target_face, "[int]", div=",")
    if detection_model is not None:
        _params["detectionModel"] = _SERIALIZER.query("detection_model", detection_model, "str")
    if user_data is not None:
        _params["userData"] = _SERIALIZER.query("user_data", user_data, "str")

    # Construct headers
    _headers["content-type"] = _SERIALIZER.header("content_type", content_type, "str")
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="POST", url=_url, params=_params, headers=_headers, **kwargs)


def build_face_lists_delete_face_request(face_list_id: str, persisted_face_id: str, **kwargs: Any) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})

    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/facelists/{faceListId}/persistedfaces/{persistedFaceId}"
    path_format_arguments = {
        "faceListId": _SERIALIZER.url("face_list_id", face_list_id, "str"),
        "persistedFaceId": _SERIALIZER.url("persisted_face_id", persisted_face_id, "str"),
    }

    _url: str = _url.format(**path_format_arguments)  # type: ignore

    # Construct headers
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="DELETE", url=_url, headers=_headers, **kwargs)


def build_large_face_lists_create_request(large_face_list_id: str, **kwargs: Any) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})

    content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/largefacelists/{largeFaceListId}"
    path_format_arguments = {
        "largeFaceListId": _SERIALIZER.url("large_face_list_id", large_face_list_id, "str"),
    }

    _url: str = _url.format(**path_format_arguments)  # type: ignore

    # Construct headers
    if content_type is not None:
        _headers["Content-Type"] = _SERIALIZER.header("content_type", content_type, "str")
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="PUT", url=_url, headers=_headers, **kwargs)


def build_large_face_lists_delete_request(large_face_list_id: str, **kwargs: Any) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})

    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/largefacelists/{largeFaceListId}"
    path_format_arguments = {
        "largeFaceListId": _SERIALIZER.url("large_face_list_id", large_face_list_id, "str"),
    }

    _url: str = _url.format(**path_format_arguments)  # type: ignore

    # Construct headers
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="DELETE", url=_url, headers=_headers, **kwargs)


def build_large_face_lists_get_request(
    large_face_list_id: str, *, return_recognition_model: Optional[bool] = None, **kwargs: Any
) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/largefacelists/{largeFaceListId}"
    path_format_arguments = {
        "largeFaceListId": _SERIALIZER.url("large_face_list_id", large_face_list_id, "str"),
    }

    _url: str = _url.format(**path_format_arguments)  # type: ignore

    # Construct parameters
    if return_recognition_model is not None:
        _params["returnRecognitionModel"] = _SERIALIZER.query(
            "return_recognition_model", return_recognition_model, "bool"
        )

    # Construct headers
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="GET", url=_url, params=_params, headers=_headers, **kwargs)


def build_large_face_lists_update_request(large_face_list_id: str, **kwargs: Any) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})

    content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/largefacelists/{largeFaceListId}"
    path_format_arguments = {
        "largeFaceListId": _SERIALIZER.url("large_face_list_id", large_face_list_id, "str"),
    }

    _url: str = _url.format(**path_format_arguments)  # type: ignore

    # Construct headers
    if content_type is not None:
        _headers["Content-Type"] = _SERIALIZER.header("content_type", content_type, "str")
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="PATCH", url=_url, headers=_headers, **kwargs)


def build_large_face_lists_get_large_face_lists_request(  # pylint: disable=name-too-long
    *,
    start: Optional[str] = None,
    top: Optional[int] = None,
    return_recognition_model: Optional[bool] = None,
    **kwargs: Any,
) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/largefacelists"

    # Construct parameters
    if start is not None:
        _params["start"] = _SERIALIZER.query("start", start, "str")
    if top is not None:
        _params["top"] = _SERIALIZER.query("top", top, "int")
    if return_recognition_model is not None:
        _params["returnRecognitionModel"] = _SERIALIZER.query(
            "return_recognition_model", return_recognition_model, "bool"
        )

    # Construct headers
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="GET", url=_url, params=_params, headers=_headers, **kwargs)


def build_large_face_lists_get_training_status_request(  # pylint: disable=name-too-long
    large_face_list_id: str, **kwargs: Any
) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})

    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/largefacelists/{largeFaceListId}/training"
    path_format_arguments = {
        "largeFaceListId": _SERIALIZER.url("large_face_list_id", large_face_list_id, "str"),
    }

    _url: str = _url.format(**path_format_arguments)  # type: ignore

    # Construct headers
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="GET", url=_url, headers=_headers, **kwargs)


def build_large_face_lists_train_request(large_face_list_id: str, **kwargs: Any) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})

    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/largefacelists/{largeFaceListId}/train"
    path_format_arguments = {
        "largeFaceListId": _SERIALIZER.url("large_face_list_id", large_face_list_id, "str"),
    }

    _url: str = _url.format(**path_format_arguments)  # type: ignore

    # Construct headers
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="POST", url=_url, headers=_headers, **kwargs)


def build_large_face_lists_add_face_from_url_request(  # pylint: disable=name-too-long
    large_face_list_id: str,
    *,
    target_face: Optional[List[int]] = None,
    detection_model: Optional[Union[str, _models.FaceDetectionModel]] = None,
    user_data: Optional[str] = None,
    **kwargs: Any,
) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/largefacelists/{largeFaceListId}/persistedfaces"
    path_format_arguments = {
        "largeFaceListId": _SERIALIZER.url("large_face_list_id", large_face_list_id, "str"),
    }

    _url: str = _url.format(**path_format_arguments)  # type: ignore

    # Construct parameters
    if target_face is not None:
        _params["targetFace"] = _SERIALIZER.query("target_face", target_face, "[int]", div=",")
    if detection_model is not None:
        _params["detectionModel"] = _SERIALIZER.query("detection_model", detection_model, "str")
    if user_data is not None:
        _params["userData"] = _SERIALIZER.query("user_data", user_data, "str")

    # Construct headers
    if content_type is not None:
        _headers["Content-Type"] = _SERIALIZER.header("content_type", content_type, "str")
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="POST", url=_url, params=_params, headers=_headers, **kwargs)


def build_large_face_lists_add_face_request(
    large_face_list_id: str,
    *,
    target_face: Optional[List[int]] = None,
    detection_model: Optional[Union[str, _models.FaceDetectionModel]] = None,
    user_data: Optional[str] = None,
    **kwargs: Any,
) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    content_type: str = kwargs.pop("content_type")
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/largefacelists/{largeFaceListId}/persistedfaces"
    path_format_arguments = {
        "largeFaceListId": _SERIALIZER.url("large_face_list_id", large_face_list_id, "str"),
    }

    _url: str = _url.format(**path_format_arguments)  # type: ignore

    # Construct parameters
    if target_face is not None:
        _params["targetFace"] = _SERIALIZER.query("target_face", target_face, "[int]", div=",")
    if detection_model is not None:
        _params["detectionModel"] = _SERIALIZER.query("detection_model", detection_model, "str")
    if user_data is not None:
        _params["userData"] = _SERIALIZER.query("user_data", user_data, "str")

    # Construct headers
    _headers["content-type"] = _SERIALIZER.header("content_type", content_type, "str")
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="POST", url=_url, params=_params, headers=_headers, **kwargs)


def build_large_face_lists_delete_face_request(  # pylint: disable=name-too-long
    large_face_list_id: str, persisted_face_id: str, **kwargs: Any
) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})

    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/largefacelists/{largeFaceListId}/persistedfaces/{persistedFaceId}"
    path_format_arguments = {
        "largeFaceListId": _SERIALIZER.url("large_face_list_id", large_face_list_id, "str"),
        "persistedFaceId": _SERIALIZER.url("persisted_face_id", persisted_face_id, "str"),
    }

    _url: str = _url.format(**path_format_arguments)  # type: ignore

    # Construct headers
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="DELETE", url=_url, headers=_headers, **kwargs)


def build_large_face_lists_get_face_request(
    large_face_list_id: str, persisted_face_id: str, **kwargs: Any
) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})

    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/largefacelists/{largeFaceListId}/persistedfaces/{persistedFaceId}"
    path_format_arguments = {
        "largeFaceListId": _SERIALIZER.url("large_face_list_id", large_face_list_id, "str"),
        "persistedFaceId": _SERIALIZER.url("persisted_face_id", persisted_face_id, "str"),
    }

    _url: str = _url.format(**path_format_arguments)  # type: ignore

    # Construct headers
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="GET", url=_url, headers=_headers, **kwargs)


def build_large_face_lists_update_face_request(  # pylint: disable=name-too-long
    large_face_list_id: str, persisted_face_id: str, **kwargs: Any
) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})

    content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/largefacelists/{largeFaceListId}/persistedfaces/{persistedFaceId}"
    path_format_arguments = {
        "largeFaceListId": _SERIALIZER.url("large_face_list_id", large_face_list_id, "str"),
        "persistedFaceId": _SERIALIZER.url("persisted_face_id", persisted_face_id, "str"),
    }

    _url: str = _url.format(**path_format_arguments)  # type: ignore

    # Construct headers
    if content_type is not None:
        _headers["Content-Type"] = _SERIALIZER.header("content_type", content_type, "str")
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="PATCH", url=_url, headers=_headers, **kwargs)


def build_large_face_lists_get_faces_request(
    large_face_list_id: str, *, start: Optional[str] = None, top: Optional[int] = None, **kwargs: Any
) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/largefacelists/{largeFaceListId}/persistedfaces"
    path_format_arguments = {
        "largeFaceListId": _SERIALIZER.url("large_face_list_id", large_face_list_id, "str"),
    }

    _url: str = _url.format(**path_format_arguments)  # type: ignore

    # Construct parameters
    if start is not None:
        _params["start"] = _SERIALIZER.query("start", start, "str")
    if top is not None:
        _params["top"] = _SERIALIZER.query("top", top, "int")

    # Construct headers
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="GET", url=_url, params=_params, headers=_headers, **kwargs)


def build_person_groups_create_request(person_group_id: str, **kwargs: Any) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})

    content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/persongroups/{personGroupId}"
    path_format_arguments = {
        "personGroupId": _SERIALIZER.url("person_group_id", person_group_id, "str"),
    }

    _url: str = _url.format(**path_format_arguments)  # type: ignore

    # Construct headers
    if content_type is not None:
        _headers["Content-Type"] = _SERIALIZER.header("content_type", content_type, "str")
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="PUT", url=_url, headers=_headers, **kwargs)


def build_person_groups_delete_request(person_group_id: str, **kwargs: Any) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})

    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/persongroups/{personGroupId}"
    path_format_arguments = {
        "personGroupId": _SERIALIZER.url("person_group_id", person_group_id, "str"),
    }

    _url: str = _url.format(**path_format_arguments)  # type: ignore

    # Construct headers
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="DELETE", url=_url, headers=_headers, **kwargs)


def build_person_groups_get_request(
    person_group_id: str, *, return_recognition_model: Optional[bool] = None, **kwargs: Any
) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/persongroups/{personGroupId}"
    path_format_arguments = {
        "personGroupId": _SERIALIZER.url("person_group_id", person_group_id, "str"),
    }

    _url: str = _url.format(**path_format_arguments)  # type: ignore

    # Construct parameters
    if return_recognition_model is not None:
        _params["returnRecognitionModel"] = _SERIALIZER.query(
            "return_recognition_model", return_recognition_model, "bool"
        )

    # Construct headers
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="GET", url=_url, params=_params, headers=_headers, **kwargs)


def build_person_groups_update_request(person_group_id: str, **kwargs: Any) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})

    content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/persongroups/{personGroupId}"
    path_format_arguments = {
        "personGroupId": _SERIALIZER.url("person_group_id", person_group_id, "str"),
    }

    _url: str = _url.format(**path_format_arguments)  # type: ignore

    # Construct headers
    if content_type is not None:
        _headers["Content-Type"] = _SERIALIZER.header("content_type", content_type, "str")
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="PATCH", url=_url, headers=_headers, **kwargs)


def build_person_groups_get_person_groups_request(  # pylint: disable=name-too-long
    *,
    start: Optional[str] = None,
    top: Optional[int] = None,
    return_recognition_model: Optional[bool] = None,
    **kwargs: Any,
) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/persongroups"

    # Construct parameters
    if start is not None:
        _params["start"] = _SERIALIZER.query("start", start, "str")
    if top is not None:
        _params["top"] = _SERIALIZER.query("top", top, "int")
    if return_recognition_model is not None:
        _params["returnRecognitionModel"] = _SERIALIZER.query(
            "return_recognition_model", return_recognition_model, "bool"
        )

    # Construct headers
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="GET", url=_url, params=_params, headers=_headers, **kwargs)


def build_person_groups_get_training_status_request(  # pylint: disable=name-too-long
    person_group_id: str, **kwargs: Any
) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})

    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/persongroups/{personGroupId}/training"
    path_format_arguments = {
        "personGroupId": _SERIALIZER.url("person_group_id", person_group_id, "str"),
    }

    _url: str = _url.format(**path_format_arguments)  # type: ignore

    # Construct headers
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="GET", url=_url, headers=_headers, **kwargs)


def build_person_groups_train_request(person_group_id: str, **kwargs: Any) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})

    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/persongroups/{personGroupId}/train"
    path_format_arguments = {
        "personGroupId": _SERIALIZER.url("person_group_id", person_group_id, "str"),
    }

    _url: str = _url.format(**path_format_arguments)  # type: ignore

    # Construct headers
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="POST", url=_url, headers=_headers, **kwargs)


def build_person_groups_create_person_request(  # pylint: disable=name-too-long
    person_group_id: str, **kwargs: Any
) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})

    content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/persongroups/{personGroupId}/persons"
    path_format_arguments = {
        "personGroupId": _SERIALIZER.url("person_group_id", person_group_id, "str"),
    }

    _url: str = _url.format(**path_format_arguments)  # type: ignore

    # Construct headers
    if content_type is not None:
        _headers["Content-Type"] = _SERIALIZER.header("content_type", content_type, "str")
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="POST", url=_url, headers=_headers, **kwargs)


def build_person_groups_delete_person_request(  # pylint: disable=name-too-long
    person_group_id: str, person_id: str, **kwargs: Any
) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})

    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/persongroups/{personGroupId}/persons/{personId}"
    path_format_arguments = {
        "personGroupId": _SERIALIZER.url("person_group_id", person_group_id, "str"),
        "personId": _SERIALIZER.url("person_id", person_id, "str"),
    }

    _url: str = _url.format(**path_format_arguments)  # type: ignore

    # Construct headers
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="DELETE", url=_url, headers=_headers, **kwargs)


def build_person_groups_get_person_request(person_group_id: str, person_id: str, **kwargs: Any) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})

    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/persongroups/{personGroupId}/persons/{personId}"
    path_format_arguments = {
        "personGroupId": _SERIALIZER.url("person_group_id", person_group_id, "str"),
        "personId": _SERIALIZER.url("person_id", person_id, "str"),
    }

    _url: str = _url.format(**path_format_arguments)  # type: ignore

    # Construct headers
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="GET", url=_url, headers=_headers, **kwargs)


def build_person_groups_update_person_request(  # pylint: disable=name-too-long
    person_group_id: str, person_id: str, **kwargs: Any
) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})

    content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/persongroups/{personGroupId}/persons/{personId}"
    path_format_arguments = {
        "personGroupId": _SERIALIZER.url("person_group_id", person_group_id, "str"),
        "personId": _SERIALIZER.url("person_id", person_id, "str"),
    }

    _url: str = _url.format(**path_format_arguments)  # type: ignore

    # Construct headers
    if content_type is not None:
        _headers["Content-Type"] = _SERIALIZER.header("content_type", content_type, "str")
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="PATCH", url=_url, headers=_headers, **kwargs)


def build_person_groups_get_persons_request(
    person_group_id: str, *, start: Optional[str] = None, top: Optional[int] = None, **kwargs: Any
) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/persongroups/{personGroupId}/persons"
    path_format_arguments = {
        "personGroupId": _SERIALIZER.url("person_group_id", person_group_id, "str"),
    }

    _url: str = _url.format(**path_format_arguments)  # type: ignore

    # Construct parameters
    if start is not None:
        _params["start"] = _SERIALIZER.query("start", start, "str")
    if top is not None:
        _params["top"] = _SERIALIZER.query("top", top, "int")

    # Construct headers
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="GET", url=_url, params=_params, headers=_headers, **kwargs)


def build_person_groups_add_face_from_url_request(  # pylint: disable=name-too-long
    person_group_id: str,
    person_id: str,
    *,
    target_face: Optional[List[int]] = None,
    detection_model: Optional[Union[str, _models.FaceDetectionModel]] = None,
    user_data: Optional[str] = None,
    **kwargs: Any,
) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/persongroups/{personGroupId}/persons/{personId}/persistedfaces"
    path_format_arguments = {
        "personGroupId": _SERIALIZER.url("person_group_id", person_group_id, "str"),
        "personId": _SERIALIZER.url("person_id", person_id, "str"),
    }

    _url: str = _url.format(**path_format_arguments)  # type: ignore

    # Construct parameters
    if target_face is not None:
        _params["targetFace"] = _SERIALIZER.query("target_face", target_face, "[int]", div=",")
    if detection_model is not None:
        _params["detectionModel"] = _SERIALIZER.query("detection_model", detection_model, "str")
    if user_data is not None:
        _params["userData"] = _SERIALIZER.query("user_data", user_data, "str")

    # Construct headers
    if content_type is not None:
        _headers["Content-Type"] = _SERIALIZER.header("content_type", content_type, "str")
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="POST", url=_url, params=_params, headers=_headers, **kwargs)


def build_person_groups_add_face_request(
    person_group_id: str,
    person_id: str,
    *,
    target_face: Optional[List[int]] = None,
    detection_model: Optional[Union[str, _models.FaceDetectionModel]] = None,
    user_data: Optional[str] = None,
    **kwargs: Any,
) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    content_type: str = kwargs.pop("content_type")
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/persongroups/{personGroupId}/persons/{personId}/persistedfaces"
    path_format_arguments = {
        "personGroupId": _SERIALIZER.url("person_group_id", person_group_id, "str"),
        "personId": _SERIALIZER.url("person_id", person_id, "str"),
    }

    _url: str = _url.format(**path_format_arguments)  # type: ignore

    # Construct parameters
    if target_face is not None:
        _params["targetFace"] = _SERIALIZER.query("target_face", target_face, "[int]", div=",")
    if detection_model is not None:
        _params["detectionModel"] = _SERIALIZER.query("detection_model", detection_model, "str")
    if user_data is not None:
        _params["userData"] = _SERIALIZER.query("user_data", user_data, "str")

    # Construct headers
    _headers["content-type"] = _SERIALIZER.header("content_type", content_type, "str")
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="POST", url=_url, params=_params, headers=_headers, **kwargs)


def build_person_groups_delete_face_request(
    person_group_id: str, person_id: str, persisted_face_id: str, **kwargs: Any
) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})

    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/persongroups/{personGroupId}/persons/{personId}/persistedfaces/{persistedFaceId}"
    path_format_arguments = {
        "personGroupId": _SERIALIZER.url("person_group_id", person_group_id, "str"),
        "personId": _SERIALIZER.url("person_id", person_id, "str"),
        "persistedFaceId": _SERIALIZER.url("persisted_face_id", persisted_face_id, "str"),
    }

    _url: str = _url.format(**path_format_arguments)  # type: ignore

    # Construct headers
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="DELETE", url=_url, headers=_headers, **kwargs)


def build_person_groups_get_face_request(
    person_group_id: str, person_id: str, persisted_face_id: str, **kwargs: Any
) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})

    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/persongroups/{personGroupId}/persons/{personId}/persistedfaces/{persistedFaceId}"
    path_format_arguments = {
        "personGroupId": _SERIALIZER.url("person_group_id", person_group_id, "str"),
        "personId": _SERIALIZER.url("person_id", person_id, "str"),
        "persistedFaceId": _SERIALIZER.url("persisted_face_id", persisted_face_id, "str"),
    }

    _url: str = _url.format(**path_format_arguments)  # type: ignore

    # Construct headers
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="GET", url=_url, headers=_headers, **kwargs)


def build_person_groups_update_face_request(
    person_group_id: str, person_id: str, persisted_face_id: str, **kwargs: Any
) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})

    content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/persongroups/{personGroupId}/persons/{personId}/persistedfaces/{persistedFaceId}"
    path_format_arguments = {
        "personGroupId": _SERIALIZER.url("person_group_id", person_group_id, "str"),
        "personId": _SERIALIZER.url("person_id", person_id, "str"),
        "persistedFaceId": _SERIALIZER.url("persisted_face_id", persisted_face_id, "str"),
    }

    _url: str = _url.format(**path_format_arguments)  # type: ignore

    # Construct headers
    if content_type is not None:
        _headers["Content-Type"] = _SERIALIZER.header("content_type", content_type, "str")
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="PATCH", url=_url, headers=_headers, **kwargs)


def build_large_person_groups_create_request(large_person_group_id: str, **kwargs: Any) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})

    content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/largepersongroups/{largePersonGroupId}"
    path_format_arguments = {
        "largePersonGroupId": _SERIALIZER.url("large_person_group_id", large_person_group_id, "str"),
    }

    _url: str = _url.format(**path_format_arguments)  # type: ignore

    # Construct headers
    if content_type is not None:
        _headers["Content-Type"] = _SERIALIZER.header("content_type", content_type, "str")
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="PUT", url=_url, headers=_headers, **kwargs)


def build_large_person_groups_delete_request(large_person_group_id: str, **kwargs: Any) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})

    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/largepersongroups/{largePersonGroupId}"
    path_format_arguments = {
        "largePersonGroupId": _SERIALIZER.url("large_person_group_id", large_person_group_id, "str"),
    }

    _url: str = _url.format(**path_format_arguments)  # type: ignore

    # Construct headers
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="DELETE", url=_url, headers=_headers, **kwargs)


def build_large_person_groups_get_request(
    large_person_group_id: str, *, return_recognition_model: Optional[bool] = None, **kwargs: Any
) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/largepersongroups/{largePersonGroupId}"
    path_format_arguments = {
        "largePersonGroupId": _SERIALIZER.url("large_person_group_id", large_person_group_id, "str"),
    }

    _url: str = _url.format(**path_format_arguments)  # type: ignore

    # Construct parameters
    if return_recognition_model is not None:
        _params["returnRecognitionModel"] = _SERIALIZER.query(
            "return_recognition_model", return_recognition_model, "bool"
        )

    # Construct headers
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="GET", url=_url, params=_params, headers=_headers, **kwargs)


def build_large_person_groups_update_request(large_person_group_id: str, **kwargs: Any) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})

    content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/largepersongroups/{largePersonGroupId}"
    path_format_arguments = {
        "largePersonGroupId": _SERIALIZER.url("large_person_group_id", large_person_group_id, "str"),
    }

    _url: str = _url.format(**path_format_arguments)  # type: ignore

    # Construct headers
    if content_type is not None:
        _headers["Content-Type"] = _SERIALIZER.header("content_type", content_type, "str")
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="PATCH", url=_url, headers=_headers, **kwargs)


def build_large_person_groups_get_large_person_groups_request(  # pylint: disable=name-too-long
    *,
    start: Optional[str] = None,
    top: Optional[int] = None,
    return_recognition_model: Optional[bool] = None,
    **kwargs: Any,
) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/largepersongroups"

    # Construct parameters
    if start is not None:
        _params["start"] = _SERIALIZER.query("start", start, "str")
    if top is not None:
        _params["top"] = _SERIALIZER.query("top", top, "int")
    if return_recognition_model is not None:
        _params["returnRecognitionModel"] = _SERIALIZER.query(
            "return_recognition_model", return_recognition_model, "bool"
        )

    # Construct headers
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="GET", url=_url, params=_params, headers=_headers, **kwargs)


def build_large_person_groups_get_training_status_request(  # pylint: disable=name-too-long
    large_person_group_id: str, **kwargs: Any
) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})

    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/largepersongroups/{largePersonGroupId}/training"
    path_format_arguments = {
        "largePersonGroupId": _SERIALIZER.url("large_person_group_id", large_person_group_id, "str"),
    }

    _url: str = _url.format(**path_format_arguments)  # type: ignore

    # Construct headers
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="GET", url=_url, headers=_headers, **kwargs)


def build_large_person_groups_train_request(large_person_group_id: str, **kwargs: Any) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})

    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/largepersongroups/{largePersonGroupId}/train"
    path_format_arguments = {
        "largePersonGroupId": _SERIALIZER.url("large_person_group_id", large_person_group_id, "str"),
    }

    _url: str = _url.format(**path_format_arguments)  # type: ignore

    # Construct headers
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="POST", url=_url, headers=_headers, **kwargs)


def build_large_person_groups_create_person_request(  # pylint: disable=name-too-long
    large_person_group_id: str, **kwargs: Any
) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})

    content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/largepersongroups/{largePersonGroupId}/persons"
    path_format_arguments = {
        "largePersonGroupId": _SERIALIZER.url("large_person_group_id", large_person_group_id, "str"),
    }

    _url: str = _url.format(**path_format_arguments)  # type: ignore

    # Construct headers
    if content_type is not None:
        _headers["Content-Type"] = _SERIALIZER.header("content_type", content_type, "str")
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="POST", url=_url, headers=_headers, **kwargs)


def build_large_person_groups_delete_person_request(  # pylint: disable=name-too-long
    large_person_group_id: str, person_id: str, **kwargs: Any
) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})

    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/largepersongroups/{largePersonGroupId}/persons/{personId}"
    path_format_arguments = {
        "largePersonGroupId": _SERIALIZER.url("large_person_group_id", large_person_group_id, "str"),
        "personId": _SERIALIZER.url("person_id", person_id, "str"),
    }

    _url: str = _url.format(**path_format_arguments)  # type: ignore

    # Construct headers
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="DELETE", url=_url, headers=_headers, **kwargs)


def build_large_person_groups_get_person_request(  # pylint: disable=name-too-long
    large_person_group_id: str, person_id: str, **kwargs: Any
) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})

    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/largepersongroups/{largePersonGroupId}/persons/{personId}"
    path_format_arguments = {
        "largePersonGroupId": _SERIALIZER.url("large_person_group_id", large_person_group_id, "str"),
        "personId": _SERIALIZER.url("person_id", person_id, "str"),
    }

    _url: str = _url.format(**path_format_arguments)  # type: ignore

    # Construct headers
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="GET", url=_url, headers=_headers, **kwargs)


def build_large_person_groups_update_person_request(  # pylint: disable=name-too-long
    large_person_group_id: str, person_id: str, **kwargs: Any
) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})

    content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/largepersongroups/{largePersonGroupId}/persons/{personId}"
    path_format_arguments = {
        "largePersonGroupId": _SERIALIZER.url("large_person_group_id", large_person_group_id, "str"),
        "personId": _SERIALIZER.url("person_id", person_id, "str"),
    }

    _url: str = _url.format(**path_format_arguments)  # type: ignore

    # Construct headers
    if content_type is not None:
        _headers["Content-Type"] = _SERIALIZER.header("content_type", content_type, "str")
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="PATCH", url=_url, headers=_headers, **kwargs)


def build_large_person_groups_get_persons_request(  # pylint: disable=name-too-long
    large_person_group_id: str, *, start: Optional[str] = None, top: Optional[int] = None, **kwargs: Any
) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/largepersongroups/{largePersonGroupId}/persons"
    path_format_arguments = {
        "largePersonGroupId": _SERIALIZER.url("large_person_group_id", large_person_group_id, "str"),
    }

    _url: str = _url.format(**path_format_arguments)  # type: ignore

    # Construct parameters
    if start is not None:
        _params["start"] = _SERIALIZER.query("start", start, "str")
    if top is not None:
        _params["top"] = _SERIALIZER.query("top", top, "int")

    # Construct headers
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="GET", url=_url, params=_params, headers=_headers, **kwargs)


def build_large_person_groups_add_face_from_url_request(  # pylint: disable=name-too-long
    large_person_group_id: str,
    person_id: str,
    *,
    target_face: Optional[List[int]] = None,
    detection_model: Optional[Union[str, _models.FaceDetectionModel]] = None,
    user_data: Optional[str] = None,
    **kwargs: Any,
) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/largepersongroups/{largePersonGroupId}/persons/{personId}/persistedfaces"
    path_format_arguments = {
        "largePersonGroupId": _SERIALIZER.url("large_person_group_id", large_person_group_id, "str"),
        "personId": _SERIALIZER.url("person_id", person_id, "str"),
    }

    _url: str = _url.format(**path_format_arguments)  # type: ignore

    # Construct parameters
    if target_face is not None:
        _params["targetFace"] = _SERIALIZER.query("target_face", target_face, "[int]", div=",")
    if detection_model is not None:
        _params["detectionModel"] = _SERIALIZER.query("detection_model", detection_model, "str")
    if user_data is not None:
        _params["userData"] = _SERIALIZER.query("user_data", user_data, "str")

    # Construct headers
    if content_type is not None:
        _headers["Content-Type"] = _SERIALIZER.header("content_type", content_type, "str")
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="POST", url=_url, params=_params, headers=_headers, **kwargs)


def build_large_person_groups_add_face_request(  # pylint: disable=name-too-long
    large_person_group_id: str,
    person_id: str,
    *,
    target_face: Optional[List[int]] = None,
    detection_model: Optional[Union[str, _models.FaceDetectionModel]] = None,
    user_data: Optional[str] = None,
    **kwargs: Any,
) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    content_type: str = kwargs.pop("content_type")
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/largepersongroups/{largePersonGroupId}/persons/{personId}/persistedfaces"
    path_format_arguments = {
        "largePersonGroupId": _SERIALIZER.url("large_person_group_id", large_person_group_id, "str"),
        "personId": _SERIALIZER.url("person_id", person_id, "str"),
    }

    _url: str = _url.format(**path_format_arguments)  # type: ignore

    # Construct parameters
    if target_face is not None:
        _params["targetFace"] = _SERIALIZER.query("target_face", target_face, "[int]", div=",")
    if detection_model is not None:
        _params["detectionModel"] = _SERIALIZER.query("detection_model", detection_model, "str")
    if user_data is not None:
        _params["userData"] = _SERIALIZER.query("user_data", user_data, "str")

    # Construct headers
    _headers["content-type"] = _SERIALIZER.header("content_type", content_type, "str")
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="POST", url=_url, params=_params, headers=_headers, **kwargs)


def build_large_person_groups_delete_face_request(  # pylint: disable=name-too-long
    large_person_group_id: str, person_id: str, persisted_face_id: str, **kwargs: Any
) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})

    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/largepersongroups/{largePersonGroupId}/persons/{personId}/persistedfaces/{persistedFaceId}"
    path_format_arguments = {
        "largePersonGroupId": _SERIALIZER.url("large_person_group_id", large_person_group_id, "str"),
        "personId": _SERIALIZER.url("person_id", person_id, "str"),
        "persistedFaceId": _SERIALIZER.url("persisted_face_id", persisted_face_id, "str"),
    }

    _url: str = _url.format(**path_format_arguments)  # type: ignore

    # Construct headers
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="DELETE", url=_url, headers=_headers, **kwargs)


def build_large_person_groups_get_face_request(  # pylint: disable=name-too-long
    large_person_group_id: str, person_id: str, persisted_face_id: str, **kwargs: Any
) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})

    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/largepersongroups/{largePersonGroupId}/persons/{personId}/persistedfaces/{persistedFaceId}"
    path_format_arguments = {
        "largePersonGroupId": _SERIALIZER.url("large_person_group_id", large_person_group_id, "str"),
        "personId": _SERIALIZER.url("person_id", person_id, "str"),
        "persistedFaceId": _SERIALIZER.url("persisted_face_id", persisted_face_id, "str"),
    }

    _url: str = _url.format(**path_format_arguments)  # type: ignore

    # Construct headers
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="GET", url=_url, headers=_headers, **kwargs)


def build_large_person_groups_update_face_request(  # pylint: disable=name-too-long
    large_person_group_id: str, person_id: str, persisted_face_id: str, **kwargs: Any
) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})

    content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/largepersongroups/{largePersonGroupId}/persons/{personId}/persistedfaces/{persistedFaceId}"
    path_format_arguments = {
        "largePersonGroupId": _SERIALIZER.url("large_person_group_id", large_person_group_id, "str"),
        "personId": _SERIALIZER.url("person_id", person_id, "str"),
        "persistedFaceId": _SERIALIZER.url("persisted_face_id", persisted_face_id, "str"),
    }

    _url: str = _url.format(**path_format_arguments)  # type: ignore

    # Construct headers
    if content_type is not None:
        _headers["Content-Type"] = _SERIALIZER.header("content_type", content_type, "str")
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="PATCH", url=_url, headers=_headers, **kwargs)


def build_face_detect_from_url_request(
    *,
    detection_model: Optional[Union[str, _models.FaceDetectionModel]] = None,
    recognition_model: Optional[Union[str, _models.FaceRecognitionModel]] = None,
    return_face_id: Optional[bool] = None,
    return_face_attributes: Optional[List[Union[str, _models.FaceAttributeType]]] = None,
    return_face_landmarks: Optional[bool] = None,
    return_recognition_model: Optional[bool] = None,
    face_id_time_to_live: Optional[int] = None,
    **kwargs: Any,
) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("content-type", None))
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/detect"

    # Construct parameters
    if detection_model is not None:
        _params["detectionModel"] = _SERIALIZER.query("detection_model", detection_model, "str")
    if recognition_model is not None:
        _params["recognitionModel"] = _SERIALIZER.query("recognition_model", recognition_model, "str")
    if return_face_id is not None:
        _params["returnFaceId"] = _SERIALIZER.query("return_face_id", return_face_id, "bool")
    if return_face_attributes is not None:
        _params["returnFaceAttributes"] = _SERIALIZER.query(
            "return_face_attributes", return_face_attributes, "[str]", div=","
        )
    if return_face_landmarks is not None:
        _params["returnFaceLandmarks"] = _SERIALIZER.query("return_face_landmarks", return_face_landmarks, "bool")
    if return_recognition_model is not None:
        _params["returnRecognitionModel"] = _SERIALIZER.query(
            "return_recognition_model", return_recognition_model, "bool"
        )
    if face_id_time_to_live is not None:
        _params["faceIdTimeToLive"] = _SERIALIZER.query("face_id_time_to_live", face_id_time_to_live, "int")

    # Construct headers
    if content_type is not None:
        _headers["content-type"] = _SERIALIZER.header("content_type", content_type, "str")
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="POST", url=_url, params=_params, headers=_headers, **kwargs)


def build_face_detect_request(
    *,
    detection_model: Optional[Union[str, _models.FaceDetectionModel]] = None,
    recognition_model: Optional[Union[str, _models.FaceRecognitionModel]] = None,
    return_face_id: Optional[bool] = None,
    return_face_attributes: Optional[List[Union[str, _models.FaceAttributeType]]] = None,
    return_face_landmarks: Optional[bool] = None,
    return_recognition_model: Optional[bool] = None,
    face_id_time_to_live: Optional[int] = None,
    **kwargs: Any,
) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    content_type: str = kwargs.pop("content_type")
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/detect"

    # Construct parameters
    if detection_model is not None:
        _params["detectionModel"] = _SERIALIZER.query("detection_model", detection_model, "str")
    if recognition_model is not None:
        _params["recognitionModel"] = _SERIALIZER.query("recognition_model", recognition_model, "str")
    if return_face_id is not None:
        _params["returnFaceId"] = _SERIALIZER.query("return_face_id", return_face_id, "bool")
    if return_face_attributes is not None:
        _params["returnFaceAttributes"] = _SERIALIZER.query(
            "return_face_attributes", return_face_attributes, "[str]", div=","
        )
    if return_face_landmarks is not None:
        _params["returnFaceLandmarks"] = _SERIALIZER.query("return_face_landmarks", return_face_landmarks, "bool")
    if return_recognition_model is not None:
        _params["returnRecognitionModel"] = _SERIALIZER.query(
            "return_recognition_model", return_recognition_model, "bool"
        )
    if face_id_time_to_live is not None:
        _params["faceIdTimeToLive"] = _SERIALIZER.query("face_id_time_to_live", face_id_time_to_live, "int")

    # Construct headers
    _headers["content-type"] = _SERIALIZER.header("content_type", content_type, "str")
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="POST", url=_url, params=_params, headers=_headers, **kwargs)


def build_face_find_similar_request(**kwargs: Any) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})

    content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/findsimilars"

    # Construct headers
    if content_type is not None:
        _headers["Content-Type"] = _SERIALIZER.header("content_type", content_type, "str")
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="POST", url=_url, headers=_headers, **kwargs)


def build_face_verify_face_to_face_request(**kwargs: Any) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})

    content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/verify"

    # Construct headers
    if content_type is not None:
        _headers["Content-Type"] = _SERIALIZER.header("content_type", content_type, "str")
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="POST", url=_url, headers=_headers, **kwargs)


def build_face_group_request(**kwargs: Any) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})

    content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/group"

    # Construct headers
    if content_type is not None:
        _headers["Content-Type"] = _SERIALIZER.header("content_type", content_type, "str")
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="POST", url=_url, headers=_headers, **kwargs)


def build_face_session_create_liveness_session_request(**kwargs: Any) -> HttpRequest:  # pylint: disable=name-too-long
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})

    content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/detectLiveness/singleModal/sessions"

    # Construct headers
    if content_type is not None:
        _headers["Content-Type"] = _SERIALIZER.header("content_type", content_type, "str")
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="POST", url=_url, headers=_headers, **kwargs)


def build_face_session_delete_liveness_session_request(  # pylint: disable=name-too-long
    session_id: str, **kwargs: Any
) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})

    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/detectLiveness/singleModal/sessions/{sessionId}"
    path_format_arguments = {
        "sessionId": _SERIALIZER.url("session_id", session_id, "str"),
    }

    _url: str = _url.format(**path_format_arguments)  # type: ignore

    # Construct headers
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="DELETE", url=_url, headers=_headers, **kwargs)


def build_face_session_get_liveness_session_result_request(  # pylint: disable=name-too-long
    session_id: str, **kwargs: Any
) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})

    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/detectLiveness/singleModal/sessions/{sessionId}"
    path_format_arguments = {
        "sessionId": _SERIALIZER.url("session_id", session_id, "str"),
    }

    _url: str = _url.format(**path_format_arguments)  # type: ignore

    # Construct headers
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="GET", url=_url, headers=_headers, **kwargs)


def build_face_session_get_liveness_sessions_request(  # pylint: disable=name-too-long
    *, start: Optional[str] = None, top: Optional[int] = None, **kwargs: Any
) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/detectLiveness/singleModal/sessions"

    # Construct parameters
    if start is not None:
        _params["start"] = _SERIALIZER.query("start", start, "str")
    if top is not None:
        _params["top"] = _SERIALIZER.query("top", top, "int")

    # Construct headers
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="GET", url=_url, params=_params, headers=_headers, **kwargs)


def build_face_session_get_liveness_session_audit_entries_request(  # pylint: disable=name-too-long
    session_id: str, *, start: Optional[str] = None, top: Optional[int] = None, **kwargs: Any
) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/detectLiveness/singleModal/sessions/{sessionId}/audit"
    path_format_arguments = {
        "sessionId": _SERIALIZER.url("session_id", session_id, "str"),
    }

    _url: str = _url.format(**path_format_arguments)  # type: ignore

    # Construct parameters
    if start is not None:
        _params["start"] = _SERIALIZER.query("start", start, "str")
    if top is not None:
        _params["top"] = _SERIALIZER.query("top", top, "int")

    # Construct headers
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="GET", url=_url, params=_params, headers=_headers, **kwargs)


def build_face_session_create_liveness_with_verify_session_request(  # pylint: disable=name-too-long
    **kwargs: Any,
) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})

    content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/detectLivenessWithVerify/singleModal/sessions"

    # Construct headers
    if content_type is not None:
        _headers["Content-Type"] = _SERIALIZER.header("content_type", content_type, "str")
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="POST", url=_url, headers=_headers, **kwargs)


def build_face_session_create_liveness_with_verify_session_with_verify_image_request(  # pylint: disable=name-too-long
    **kwargs: Any,
) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})

    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/detectLivenessWithVerify/singleModal/sessions"

    # Construct headers
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="POST", url=_url, headers=_headers, **kwargs)


def build_face_session_delete_liveness_with_verify_session_request(  # pylint: disable=name-too-long
    session_id: str, **kwargs: Any
) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})

    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/detectLivenessWithVerify/singleModal/sessions/{sessionId}"
    path_format_arguments = {
        "sessionId": _SERIALIZER.url("session_id", session_id, "str"),
    }

    _url: str = _url.format(**path_format_arguments)  # type: ignore

    # Construct headers
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="DELETE", url=_url, headers=_headers, **kwargs)


def build_face_session_get_liveness_with_verify_session_result_request(  # pylint: disable=name-too-long
    session_id: str, **kwargs: Any
) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})

    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/detectLivenessWithVerify/singleModal/sessions/{sessionId}"
    path_format_arguments = {
        "sessionId": _SERIALIZER.url("session_id", session_id, "str"),
    }

    _url: str = _url.format(**path_format_arguments)  # type: ignore

    # Construct headers
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="GET", url=_url, headers=_headers, **kwargs)


def build_face_session_get_liveness_with_verify_sessions_request(  # pylint: disable=name-too-long
    *, start: Optional[str] = None, top: Optional[int] = None, **kwargs: Any
) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/detectLivenessWithVerify/singleModal/sessions"

    # Construct parameters
    if start is not None:
        _params["start"] = _SERIALIZER.query("start", start, "str")
    if top is not None:
        _params["top"] = _SERIALIZER.query("top", top, "int")

    # Construct headers
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="GET", url=_url, params=_params, headers=_headers, **kwargs)


def build_face_session_get_liveness_with_verify_session_audit_entries_request(  # pylint: disable=name-too-long
    session_id: str, *, start: Optional[str] = None, top: Optional[int] = None, **kwargs: Any
) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/detectLivenessWithVerify/singleModal/sessions/{sessionId}/audit"
    path_format_arguments = {
        "sessionId": _SERIALIZER.url("session_id", session_id, "str"),
    }

    _url: str = _url.format(**path_format_arguments)  # type: ignore

    # Construct parameters
    if start is not None:
        _params["start"] = _SERIALIZER.query("start", start, "str")
    if top is not None:
        _params["top"] = _SERIALIZER.query("top", top, "int")

    # Construct headers
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="GET", url=_url, params=_params, headers=_headers, **kwargs)


class FaceListsOperations:
    """
    .. warning::
        **DO NOT** instantiate this class directly.

        Instead, you should access the following operations through
        :class:`~azure.ai.vision.face.FaceServiceClient`'s
        :attr:`face_lists` attribute.
    """

    def __init__(self, *args, **kwargs):
        input_args = list(args)
        self._client = input_args.pop(0) if input_args else kwargs.pop("client")
        self._config = input_args.pop(0) if input_args else kwargs.pop("config")
        self._serialize = input_args.pop(0) if input_args else kwargs.pop("serializer")
        self._deserialize = input_args.pop(0) if input_args else kwargs.pop("deserializer")

    @overload
    def create(  # pylint: disable=inconsistent-return-statements
        self, face_list_id: str, body: JSON, *, content_type: str = "application/json", **kwargs: Any
    ) -> None:
        """Create an empty Face List with user-specified faceListId, name, an optional userData and
        recognitionModel.

        Up to 64 Face Lists are allowed in one subscription.

        Face List is a list of faces, up to 1,000 faces, and used by "Find Similar From Face List".

        After creation, user should use "Add Face List Face" to import the faces. No image will be
        stored. Only the extracted face feature(s) will be stored on server until "Delete Face List" is
        called.

        "Find Similar" is used for scenario like finding celebrity-like faces, similar face filtering,
        or as a light way face identification. But if the actual use is to identify person, please use
        Person Group / Large Person Group and "Identify".

        Please consider Large Face List when the face number is large. It can support up to 1,000,000
        faces.

        :param face_list_id: Valid character is letter in lower case or digit or '-' or '_', maximum
         length is 64. Required.
        :type face_list_id: str
        :param body: Required.
        :type body: JSON
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: None
        :rtype: None
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                body = {
                    "name": "str",
                    "recognitionModel": "str",
                    "userData": "str"
                }
        """

    @overload
    def create(  # pylint: disable=inconsistent-return-statements
        self,
        face_list_id: str,
        *,
        name: str,
        content_type: str = "application/json",
        user_data: Optional[str] = None,
        recognition_model: Optional[Union[str, _models.FaceRecognitionModel]] = None,
        **kwargs: Any,
    ) -> None:
        """Create an empty Face List with user-specified faceListId, name, an optional userData and
        recognitionModel.

        Up to 64 Face Lists are allowed in one subscription.

        Face List is a list of faces, up to 1,000 faces, and used by "Find Similar From Face List".

        After creation, user should use "Add Face List Face" to import the faces. No image will be
        stored. Only the extracted face feature(s) will be stored on server until "Delete Face List" is
        called.

        "Find Similar" is used for scenario like finding celebrity-like faces, similar face filtering,
        or as a light way face identification. But if the actual use is to identify person, please use
        Person Group / Large Person Group and "Identify".

        Please consider Large Face List when the face number is large. It can support up to 1,000,000
        faces.

        :param face_list_id: Valid character is letter in lower case or digit or '-' or '_', maximum
         length is 64. Required.
        :type face_list_id: str
        :keyword name: User defined name, maximum length is 128. Required.
        :paramtype name: str
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :keyword user_data: Optional user defined data. Length should not exceed 16K. Default value is
         None.
        :paramtype user_data: str
        :keyword recognition_model: The 'recognitionModel' associated with this face list. Supported
         'recognitionModel' values include 'recognition_01', 'recognition_02, 'recognition_03', and
         'recognition_04'. The default value is 'recognition_01'. 'recognition_04' is recommended since
         its accuracy is improved on faces wearing masks compared with 'recognition_03', and its overall
         accuracy is improved compared with 'recognition_01' and 'recognition_02'. Known values are:
         "recognition_01", "recognition_02", "recognition_03", and "recognition_04". Default value is
         None.
        :paramtype recognition_model: str or ~azure.ai.vision.face.models.FaceRecognitionModel
        :return: None
        :rtype: None
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @overload
    def create(  # pylint: disable=inconsistent-return-statements
        self, face_list_id: str, body: IO[bytes], *, content_type: str = "application/json", **kwargs: Any
    ) -> None:
        """Create an empty Face List with user-specified faceListId, name, an optional userData and
        recognitionModel.

        Up to 64 Face Lists are allowed in one subscription.

        Face List is a list of faces, up to 1,000 faces, and used by "Find Similar From Face List".

        After creation, user should use "Add Face List Face" to import the faces. No image will be
        stored. Only the extracted face feature(s) will be stored on server until "Delete Face List" is
        called.

        "Find Similar" is used for scenario like finding celebrity-like faces, similar face filtering,
        or as a light way face identification. But if the actual use is to identify person, please use
        Person Group / Large Person Group and "Identify".

        Please consider Large Face List when the face number is large. It can support up to 1,000,000
        faces.

        :param face_list_id: Valid character is letter in lower case or digit or '-' or '_', maximum
         length is 64. Required.
        :type face_list_id: str
        :param body: Required.
        :type body: IO[bytes]
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: None
        :rtype: None
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @distributed_trace
    def create(  # pylint: disable=inconsistent-return-statements
        self,
        face_list_id: str,
        body: Union[JSON, IO[bytes]] = _Unset,
        *,
        name: str = _Unset,
        user_data: Optional[str] = None,
        recognition_model: Optional[Union[str, _models.FaceRecognitionModel]] = None,
        **kwargs: Any,
    ) -> None:
        """Create an empty Face List with user-specified faceListId, name, an optional userData and
        recognitionModel.

        Up to 64 Face Lists are allowed in one subscription.

        Face List is a list of faces, up to 1,000 faces, and used by "Find Similar From Face List".

        After creation, user should use "Add Face List Face" to import the faces. No image will be
        stored. Only the extracted face feature(s) will be stored on server until "Delete Face List" is
        called.

        "Find Similar" is used for scenario like finding celebrity-like faces, similar face filtering,
        or as a light way face identification. But if the actual use is to identify person, please use
        Person Group / Large Person Group and "Identify".

        Please consider Large Face List when the face number is large. It can support up to 1,000,000
        faces.

        :param face_list_id: Valid character is letter in lower case or digit or '-' or '_', maximum
         length is 64. Required.
        :type face_list_id: str
        :param body: Is either a JSON type or a IO[bytes] type. Required.
        :type body: JSON or IO[bytes]
        :keyword name: User defined name, maximum length is 128. Required.
        :paramtype name: str
        :keyword user_data: Optional user defined data. Length should not exceed 16K. Default value is
         None.
        :paramtype user_data: str
        :keyword recognition_model: The 'recognitionModel' associated with this face list. Supported
         'recognitionModel' values include 'recognition_01', 'recognition_02, 'recognition_03', and
         'recognition_04'. The default value is 'recognition_01'. 'recognition_04' is recommended since
         its accuracy is improved on faces wearing masks compared with 'recognition_03', and its overall
         accuracy is improved compared with 'recognition_01' and 'recognition_02'. Known values are:
         "recognition_01", "recognition_02", "recognition_03", and "recognition_04". Default value is
         None.
        :paramtype recognition_model: str or ~azure.ai.vision.face.models.FaceRecognitionModel
        :return: None
        :rtype: None
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                body = {
                    "name": "str",
                    "recognitionModel": "str",
                    "userData": "str"
                }
        """
        error_map: MutableMapping[int, Type[HttpResponseError]] = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[None] = kwargs.pop("cls", None)

        if body is _Unset:
            if name is _Unset:
                raise TypeError("missing required argument: name")
            body = {"name": name, "recognitionModel": recognition_model, "userData": user_data}
            body = {k: v for k, v in body.items() if v is not None}
        content_type = content_type or "application/json"
        _content = None
        if isinstance(body, (IOBase, bytes)):
            _content = body
        else:
            _content = json.dumps(body, cls=SdkJSONEncoder, exclude_readonly=True)  # type: ignore

        _request = build_face_lists_create_request(
            face_list_id=face_list_id,
            content_type=content_type,
            content=_content,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, "str", skip_quote=True),
            "apiVersion": self._serialize.url("self._config.api_version", self._config.api_version, "str"),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = False
        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = _deserialize(_models.FaceErrorResponse, response.json())
            raise HttpResponseError(response=response, model=error)

        if cls:
            return cls(pipeline_response, None, {})  # type: ignore

    @distributed_trace
    def delete(self, face_list_id: str, **kwargs: Any) -> None:  # pylint: disable=inconsistent-return-statements
        """Delete a specified Face List.

        :param face_list_id: Valid character is letter in lower case or digit or '-' or '_', maximum
         length is 64. Required.
        :type face_list_id: str
        :return: None
        :rtype: None
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping[int, Type[HttpResponseError]] = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[None] = kwargs.pop("cls", None)

        _request = build_face_lists_delete_request(
            face_list_id=face_list_id,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, "str", skip_quote=True),
            "apiVersion": self._serialize.url("self._config.api_version", self._config.api_version, "str"),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = False
        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = _deserialize(_models.FaceErrorResponse, response.json())
            raise HttpResponseError(response=response, model=error)

        if cls:
            return cls(pipeline_response, None, {})  # type: ignore

    @distributed_trace
    def get(
        self, face_list_id: str, *, return_recognition_model: Optional[bool] = None, **kwargs: Any
    ) -> _models.FaceList:
        """Retrieve a Face List's faceListId, name, userData, recognitionModel and faces in the Face List.

        :param face_list_id: Valid character is letter in lower case or digit or '-' or '_', maximum
         length is 64. Required.
        :type face_list_id: str
        :keyword return_recognition_model: Return 'recognitionModel' or not. The default value is
         false. Default value is None.
        :paramtype return_recognition_model: bool
        :return: FaceList. The FaceList is compatible with MutableMapping
        :rtype: ~azure.ai.vision.face.models.FaceList
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "faceListId": "str",
                    "name": "str",
                    "persistedFaces": [
                        {
                            "persistedFaceId": "str",
                            "userData": "str"
                        }
                    ],
                    "recognitionModel": "str",
                    "userData": "str"
                }
        """
        error_map: MutableMapping[int, Type[HttpResponseError]] = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[_models.FaceList] = kwargs.pop("cls", None)

        _request = build_face_lists_get_request(
            face_list_id=face_list_id,
            return_recognition_model=return_recognition_model,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, "str", skip_quote=True),
            "apiVersion": self._serialize.url("self._config.api_version", self._config.api_version, "str"),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = kwargs.pop("stream", False)
        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                try:
                    response.read()  # Load the body in memory and close the socket
                except (StreamConsumedError, StreamClosedError):
                    pass
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = _deserialize(_models.FaceErrorResponse, response.json())
            raise HttpResponseError(response=response, model=error)

        if _stream:
            deserialized = response.iter_bytes()
        else:
            deserialized = _deserialize(_models.FaceList, response.json())

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore

    @overload
    def update(  # pylint: disable=inconsistent-return-statements
        self, face_list_id: str, body: JSON, *, content_type: str = "application/json", **kwargs: Any
    ) -> None:
        """Update information of a Face List, including name and userData.

        :param face_list_id: Valid character is letter in lower case or digit or '-' or '_', maximum
         length is 64. Required.
        :type face_list_id: str
        :param body: Required.
        :type body: JSON
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: None
        :rtype: None
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                body = {
                    "name": "str",
                    "userData": "str"
                }
        """

    @overload
    def update(  # pylint: disable=inconsistent-return-statements
        self,
        face_list_id: str,
        *,
        content_type: str = "application/json",
        name: Optional[str] = None,
        user_data: Optional[str] = None,
        **kwargs: Any,
    ) -> None:
        """Update information of a Face List, including name and userData.

        :param face_list_id: Valid character is letter in lower case or digit or '-' or '_', maximum
         length is 64. Required.
        :type face_list_id: str
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :keyword name: User defined name, maximum length is 128. Default value is None.
        :paramtype name: str
        :keyword user_data: Optional user defined data. Length should not exceed 16K. Default value is
         None.
        :paramtype user_data: str
        :return: None
        :rtype: None
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @overload
    def update(  # pylint: disable=inconsistent-return-statements
        self, face_list_id: str, body: IO[bytes], *, content_type: str = "application/json", **kwargs: Any
    ) -> None:
        """Update information of a Face List, including name and userData.

        :param face_list_id: Valid character is letter in lower case or digit or '-' or '_', maximum
         length is 64. Required.
        :type face_list_id: str
        :param body: Required.
        :type body: IO[bytes]
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: None
        :rtype: None
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @distributed_trace
    def update(  # pylint: disable=inconsistent-return-statements
        self,
        face_list_id: str,
        body: Union[JSON, IO[bytes]] = _Unset,
        *,
        name: Optional[str] = None,
        user_data: Optional[str] = None,
        **kwargs: Any,
    ) -> None:
        """Update information of a Face List, including name and userData.

        :param face_list_id: Valid character is letter in lower case or digit or '-' or '_', maximum
         length is 64. Required.
        :type face_list_id: str
        :param body: Is either a JSON type or a IO[bytes] type. Required.
        :type body: JSON or IO[bytes]
        :keyword name: User defined name, maximum length is 128. Default value is None.
        :paramtype name: str
        :keyword user_data: Optional user defined data. Length should not exceed 16K. Default value is
         None.
        :paramtype user_data: str
        :return: None
        :rtype: None
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                body = {
                    "name": "str",
                    "userData": "str"
                }
        """
        error_map: MutableMapping[int, Type[HttpResponseError]] = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[None] = kwargs.pop("cls", None)

        if body is _Unset:
            body = {"name": name, "userData": user_data}
            body = {k: v for k, v in body.items() if v is not None}
        content_type = content_type or "application/json"
        _content = None
        if isinstance(body, (IOBase, bytes)):
            _content = body
        else:
            _content = json.dumps(body, cls=SdkJSONEncoder, exclude_readonly=True)  # type: ignore

        _request = build_face_lists_update_request(
            face_list_id=face_list_id,
            content_type=content_type,
            content=_content,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, "str", skip_quote=True),
            "apiVersion": self._serialize.url("self._config.api_version", self._config.api_version, "str"),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = False
        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = _deserialize(_models.FaceErrorResponse, response.json())
            raise HttpResponseError(response=response, model=error)

        if cls:
            return cls(pipeline_response, None, {})  # type: ignore

    @distributed_trace
    def get_face_lists(
        self, *, return_recognition_model: Optional[bool] = None, **kwargs: Any
    ) -> List[_models.FaceListItem]:
        """List Face Lists' faceListId, name, userData and recognitionModel.

        To get face information inside Face List use "Get Face List".

        :keyword return_recognition_model: Return 'recognitionModel' or not. The default value is
         false. Default value is None.
        :paramtype return_recognition_model: bool
        :return: list of FaceListItem
        :rtype: list[~azure.ai.vision.face.models.FaceListItem]
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == [
                    {
                        "faceListId": "str",
                        "name": "str",
                        "recognitionModel": "str",
                        "userData": "str"
                    }
                ]
        """
        error_map: MutableMapping[int, Type[HttpResponseError]] = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[List[_models.FaceListItem]] = kwargs.pop("cls", None)

        _request = build_face_lists_get_face_lists_request(
            return_recognition_model=return_recognition_model,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, "str", skip_quote=True),
            "apiVersion": self._serialize.url("self._config.api_version", self._config.api_version, "str"),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = kwargs.pop("stream", False)
        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                try:
                    response.read()  # Load the body in memory and close the socket
                except (StreamConsumedError, StreamClosedError):
                    pass
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = _deserialize(_models.FaceErrorResponse, response.json())
            raise HttpResponseError(response=response, model=error)

        if _stream:
            deserialized = response.iter_bytes()
        else:
            deserialized = _deserialize(List[_models.FaceListItem], response.json())

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore

    @overload
    def add_face_from_url(
        self,
        face_list_id: str,
        body: JSON,
        *,
        target_face: Optional[List[int]] = None,
        detection_model: Optional[Union[str, _models.FaceDetectionModel]] = None,
        user_data: Optional[str] = None,
        content_type: str = "application/json",
        **kwargs: Any,
    ) -> _models.AddFaceResult:
        """Add a face to a specified Face List, up to 1,000 faces.

        To deal with an image containing multiple faces, input face can be specified as an image with a
        targetFace rectangle. It returns a persistedFaceId representing the added face. No image will
        be stored. Only the extracted face feature(s) will be stored on server until "Delete Face List
        Face" or "Delete Face List" is called.

        Note that persistedFaceId is different from faceId generated by "Detect".
        >
        *


        * Higher face image quality means better recognition precision. Please consider high-quality
        faces: frontal, clear, and face size is 200x200 pixels (100 pixels between eyes) or bigger.
        * Each person entry can hold up to 248 faces.
        * JPEG, PNG, GIF (the first frame), and BMP format are supported. The allowed image file size
        is from 1KB to 6MB.
        * "targetFace" rectangle should contain one face. Zero or multiple faces will be regarded as an
        error. If the provided "targetFace" rectangle is not returned from "Detect", there's no
        guarantee to detect and add the face successfully.
        * Out of detectable face size (36x36 - 4096x4096 pixels), large head-pose, or large occlusions
        will cause failures.
        * The minimum detectable face size is 36x36 pixels in an image no larger than 1920x1080 pixels.
        Images with dimensions higher than 1920x1080 pixels will need a proportionally larger minimum
        face size.
        * Different 'detectionModel' values can be provided. To use and compare different detection
        models, please refer to
        https://learn.microsoft.com/azure/ai-services/computer-vision/how-to/specify-detection-model.

        :param face_list_id: Valid character is letter in lower case or digit or '-' or '_', maximum
         length is 64. Required.
        :type face_list_id: str
        :param body: Required.
        :type body: JSON
        :keyword target_face: A face rectangle to specify the target face to be added to a person, in
         the format of 'targetFace=left,top,width,height'. Default value is None.
        :paramtype target_face: list[int]
        :keyword detection_model: The 'detectionModel' associated with the detected faceIds. Supported
         'detectionModel' values include 'detection_01', 'detection_02' and 'detection_03'. The default
         value is 'detection_01'. Known values are: "detection_01", "detection_02", and "detection_03".
         Default value is None.
        :paramtype detection_model: str or ~azure.ai.vision.face.models.FaceDetectionModel
        :keyword user_data: User-provided data attached to the face. The size limit is 1K. Default
         value is None.
        :paramtype user_data: str
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: AddFaceResult. The AddFaceResult is compatible with MutableMapping
        :rtype: ~azure.ai.vision.face.models.AddFaceResult
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                body = {
                    "url": "str"
                }

                # response body for status code(s): 200
                response == {
                    "persistedFaceId": "str"
                }
        """

    @overload
    def add_face_from_url(
        self,
        face_list_id: str,
        *,
        url: str,
        target_face: Optional[List[int]] = None,
        detection_model: Optional[Union[str, _models.FaceDetectionModel]] = None,
        user_data: Optional[str] = None,
        content_type: str = "application/json",
        **kwargs: Any,
    ) -> _models.AddFaceResult:
        """Add a face to a specified Face List, up to 1,000 faces.

        To deal with an image containing multiple faces, input face can be specified as an image with a
        targetFace rectangle. It returns a persistedFaceId representing the added face. No image will
        be stored. Only the extracted face feature(s) will be stored on server until "Delete Face List
        Face" or "Delete Face List" is called.

        Note that persistedFaceId is different from faceId generated by "Detect".
        >
        *


        * Higher face image quality means better recognition precision. Please consider high-quality
        faces: frontal, clear, and face size is 200x200 pixels (100 pixels between eyes) or bigger.
        * Each person entry can hold up to 248 faces.
        * JPEG, PNG, GIF (the first frame), and BMP format are supported. The allowed image file size
        is from 1KB to 6MB.
        * "targetFace" rectangle should contain one face. Zero or multiple faces will be regarded as an
        error. If the provided "targetFace" rectangle is not returned from "Detect", there's no
        guarantee to detect and add the face successfully.
        * Out of detectable face size (36x36 - 4096x4096 pixels), large head-pose, or large occlusions
        will cause failures.
        * The minimum detectable face size is 36x36 pixels in an image no larger than 1920x1080 pixels.
        Images with dimensions higher than 1920x1080 pixels will need a proportionally larger minimum
        face size.
        * Different 'detectionModel' values can be provided. To use and compare different detection
        models, please refer to
        https://learn.microsoft.com/azure/ai-services/computer-vision/how-to/specify-detection-model.

        :param face_list_id: Valid character is letter in lower case or digit or '-' or '_', maximum
         length is 64. Required.
        :type face_list_id: str
        :keyword url: URL of input image. Required.
        :paramtype url: str
        :keyword target_face: A face rectangle to specify the target face to be added to a person, in
         the format of 'targetFace=left,top,width,height'. Default value is None.
        :paramtype target_face: list[int]
        :keyword detection_model: The 'detectionModel' associated with the detected faceIds. Supported
         'detectionModel' values include 'detection_01', 'detection_02' and 'detection_03'. The default
         value is 'detection_01'. Known values are: "detection_01", "detection_02", and "detection_03".
         Default value is None.
        :paramtype detection_model: str or ~azure.ai.vision.face.models.FaceDetectionModel
        :keyword user_data: User-provided data attached to the face. The size limit is 1K. Default
         value is None.
        :paramtype user_data: str
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: AddFaceResult. The AddFaceResult is compatible with MutableMapping
        :rtype: ~azure.ai.vision.face.models.AddFaceResult
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "persistedFaceId": "str"
                }
        """

    @overload
    def add_face_from_url(
        self,
        face_list_id: str,
        body: IO[bytes],
        *,
        target_face: Optional[List[int]] = None,
        detection_model: Optional[Union[str, _models.FaceDetectionModel]] = None,
        user_data: Optional[str] = None,
        content_type: str = "application/json",
        **kwargs: Any,
    ) -> _models.AddFaceResult:
        """Add a face to a specified Face List, up to 1,000 faces.

        To deal with an image containing multiple faces, input face can be specified as an image with a
        targetFace rectangle. It returns a persistedFaceId representing the added face. No image will
        be stored. Only the extracted face feature(s) will be stored on server until "Delete Face List
        Face" or "Delete Face List" is called.

        Note that persistedFaceId is different from faceId generated by "Detect".
        >
        *


        * Higher face image quality means better recognition precision. Please consider high-quality
        faces: frontal, clear, and face size is 200x200 pixels (100 pixels between eyes) or bigger.
        * Each person entry can hold up to 248 faces.
        * JPEG, PNG, GIF (the first frame), and BMP format are supported. The allowed image file size
        is from 1KB to 6MB.
        * "targetFace" rectangle should contain one face. Zero or multiple faces will be regarded as an
        error. If the provided "targetFace" rectangle is not returned from "Detect", there's no
        guarantee to detect and add the face successfully.
        * Out of detectable face size (36x36 - 4096x4096 pixels), large head-pose, or large occlusions
        will cause failures.
        * The minimum detectable face size is 36x36 pixels in an image no larger than 1920x1080 pixels.
        Images with dimensions higher than 1920x1080 pixels will need a proportionally larger minimum
        face size.
        * Different 'detectionModel' values can be provided. To use and compare different detection
        models, please refer to
        https://learn.microsoft.com/azure/ai-services/computer-vision/how-to/specify-detection-model.

        :param face_list_id: Valid character is letter in lower case or digit or '-' or '_', maximum
         length is 64. Required.
        :type face_list_id: str
        :param body: Required.
        :type body: IO[bytes]
        :keyword target_face: A face rectangle to specify the target face to be added to a person, in
         the format of 'targetFace=left,top,width,height'. Default value is None.
        :paramtype target_face: list[int]
        :keyword detection_model: The 'detectionModel' associated with the detected faceIds. Supported
         'detectionModel' values include 'detection_01', 'detection_02' and 'detection_03'. The default
         value is 'detection_01'. Known values are: "detection_01", "detection_02", and "detection_03".
         Default value is None.
        :paramtype detection_model: str or ~azure.ai.vision.face.models.FaceDetectionModel
        :keyword user_data: User-provided data attached to the face. The size limit is 1K. Default
         value is None.
        :paramtype user_data: str
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: AddFaceResult. The AddFaceResult is compatible with MutableMapping
        :rtype: ~azure.ai.vision.face.models.AddFaceResult
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "persistedFaceId": "str"
                }
        """

    @distributed_trace
    def add_face_from_url(
        self,
        face_list_id: str,
        body: Union[JSON, IO[bytes]] = _Unset,
        *,
        url: str = _Unset,
        target_face: Optional[List[int]] = None,
        detection_model: Optional[Union[str, _models.FaceDetectionModel]] = None,
        user_data: Optional[str] = None,
        **kwargs: Any,
    ) -> _models.AddFaceResult:
        """Add a face to a specified Face List, up to 1,000 faces.

        To deal with an image containing multiple faces, input face can be specified as an image with a
        targetFace rectangle. It returns a persistedFaceId representing the added face. No image will
        be stored. Only the extracted face feature(s) will be stored on server until "Delete Face List
        Face" or "Delete Face List" is called.

        Note that persistedFaceId is different from faceId generated by "Detect".
        >
        *


        * Higher face image quality means better recognition precision. Please consider high-quality
        faces: frontal, clear, and face size is 200x200 pixels (100 pixels between eyes) or bigger.
        * Each person entry can hold up to 248 faces.
        * JPEG, PNG, GIF (the first frame), and BMP format are supported. The allowed image file size
        is from 1KB to 6MB.
        * "targetFace" rectangle should contain one face. Zero or multiple faces will be regarded as an
        error. If the provided "targetFace" rectangle is not returned from "Detect", there's no
        guarantee to detect and add the face successfully.
        * Out of detectable face size (36x36 - 4096x4096 pixels), large head-pose, or large occlusions
        will cause failures.
        * The minimum detectable face size is 36x36 pixels in an image no larger than 1920x1080 pixels.
        Images with dimensions higher than 1920x1080 pixels will need a proportionally larger minimum
        face size.
        * Different 'detectionModel' values can be provided. To use and compare different detection
        models, please refer to
        https://learn.microsoft.com/azure/ai-services/computer-vision/how-to/specify-detection-model.

        :param face_list_id: Valid character is letter in lower case or digit or '-' or '_', maximum
         length is 64. Required.
        :type face_list_id: str
        :param body: Is either a JSON type or a IO[bytes] type. Required.
        :type body: JSON or IO[bytes]
        :keyword url: URL of input image. Required.
        :paramtype url: str
        :keyword target_face: A face rectangle to specify the target face to be added to a person, in
         the format of 'targetFace=left,top,width,height'. Default value is None.
        :paramtype target_face: list[int]
        :keyword detection_model: The 'detectionModel' associated with the detected faceIds. Supported
         'detectionModel' values include 'detection_01', 'detection_02' and 'detection_03'. The default
         value is 'detection_01'. Known values are: "detection_01", "detection_02", and "detection_03".
         Default value is None.
        :paramtype detection_model: str or ~azure.ai.vision.face.models.FaceDetectionModel
        :keyword user_data: User-provided data attached to the face. The size limit is 1K. Default
         value is None.
        :paramtype user_data: str
        :return: AddFaceResult. The AddFaceResult is compatible with MutableMapping
        :rtype: ~azure.ai.vision.face.models.AddFaceResult
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                body = {
                    "url": "str"
                }

                # response body for status code(s): 200
                response == {
                    "persistedFaceId": "str"
                }
        """
        error_map: MutableMapping[int, Type[HttpResponseError]] = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[_models.AddFaceResult] = kwargs.pop("cls", None)

        if body is _Unset:
            if url is _Unset:
                raise TypeError("missing required argument: url")
            body = {"url": url}
            body = {k: v for k, v in body.items() if v is not None}
        content_type = content_type or "application/json"
        _content = None
        if isinstance(body, (IOBase, bytes)):
            _content = body
        else:
            _content = json.dumps(body, cls=SdkJSONEncoder, exclude_readonly=True)  # type: ignore

        _request = build_face_lists_add_face_from_url_request(
            face_list_id=face_list_id,
            target_face=target_face,
            detection_model=detection_model,
            user_data=user_data,
            content_type=content_type,
            content=_content,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, "str", skip_quote=True),
            "apiVersion": self._serialize.url("self._config.api_version", self._config.api_version, "str"),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = kwargs.pop("stream", False)
        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                try:
                    response.read()  # Load the body in memory and close the socket
                except (StreamConsumedError, StreamClosedError):
                    pass
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = _deserialize(_models.FaceErrorResponse, response.json())
            raise HttpResponseError(response=response, model=error)

        if _stream:
            deserialized = response.iter_bytes()
        else:
            deserialized = _deserialize(_models.AddFaceResult, response.json())

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore

    @distributed_trace
    def add_face(
        self,
        face_list_id: str,
        image_content: bytes,
        *,
        target_face: Optional[List[int]] = None,
        detection_model: Optional[Union[str, _models.FaceDetectionModel]] = None,
        user_data: Optional[str] = None,
        **kwargs: Any,
    ) -> _models.AddFaceResult:
        """Add a face to a specified Face List, up to 1,000 faces.

        To deal with an image containing multiple faces, input face can be specified as an image with a
        targetFace rectangle. It returns a persistedFaceId representing the added face. No image will
        be stored. Only the extracted face feature(s) will be stored on server until "Delete Face List
        Face" or "Delete Face List" is called.

        Note that persistedFaceId is different from faceId generated by "Detect".
        >
        *


        * Higher face image quality means better recognition precision. Please consider high-quality
        faces: frontal, clear, and face size is 200x200 pixels (100 pixels between eyes) or bigger.
        * Each person entry can hold up to 248 faces.
        * JPEG, PNG, GIF (the first frame), and BMP format are supported. The allowed image file size
        is from 1KB to 6MB.
        * "targetFace" rectangle should contain one face. Zero or multiple faces will be regarded as an
        error. If the provided "targetFace" rectangle is not returned from "Detect", there's no
        guarantee to detect and add the face successfully.
        * Out of detectable face size (36x36 - 4096x4096 pixels), large head-pose, or large occlusions
        will cause failures.
        * The minimum detectable face size is 36x36 pixels in an image no larger than 1920x1080 pixels.
        Images with dimensions higher than 1920x1080 pixels will need a proportionally larger minimum
        face size.
        * Different 'detectionModel' values can be provided. To use and compare different detection
        models, please refer to
        https://learn.microsoft.com/azure/ai-services/computer-vision/how-to/specify-detection-model.

        :param face_list_id: Valid character is letter in lower case or digit or '-' or '_', maximum
         length is 64. Required.
        :type face_list_id: str
        :param image_content: The image to be analyzed. Required.
        :type image_content: bytes
        :keyword target_face: A face rectangle to specify the target face to be added to a person, in
         the format of 'targetFace=left,top,width,height'. Default value is None.
        :paramtype target_face: list[int]
        :keyword detection_model: The 'detectionModel' associated with the detected faceIds. Supported
         'detectionModel' values include 'detection_01', 'detection_02' and 'detection_03'. The default
         value is 'detection_01'. Known values are: "detection_01", "detection_02", and "detection_03".
         Default value is None.
        :paramtype detection_model: str or ~azure.ai.vision.face.models.FaceDetectionModel
        :keyword user_data: User-provided data attached to the face. The size limit is 1K. Default
         value is None.
        :paramtype user_data: str
        :return: AddFaceResult. The AddFaceResult is compatible with MutableMapping
        :rtype: ~azure.ai.vision.face.models.AddFaceResult
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "persistedFaceId": "str"
                }
        """
        error_map: MutableMapping[int, Type[HttpResponseError]] = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: str = kwargs.pop("content_type", _headers.pop("content-type", "application/octet-stream"))
        cls: ClsType[_models.AddFaceResult] = kwargs.pop("cls", None)

        _content = image_content

        _request = build_face_lists_add_face_request(
            face_list_id=face_list_id,
            target_face=target_face,
            detection_model=detection_model,
            user_data=user_data,
            content_type=content_type,
            content=_content,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, "str", skip_quote=True),
            "apiVersion": self._serialize.url("self._config.api_version", self._config.api_version, "str"),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = kwargs.pop("stream", False)
        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                try:
                    response.read()  # Load the body in memory and close the socket
                except (StreamConsumedError, StreamClosedError):
                    pass
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = _deserialize(_models.FaceErrorResponse, response.json())
            raise HttpResponseError(response=response, model=error)

        if _stream:
            deserialized = response.iter_bytes()
        else:
            deserialized = _deserialize(_models.AddFaceResult, response.json())

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore

    @distributed_trace
    def delete_face(  # pylint: disable=inconsistent-return-statements
        self, face_list_id: str, persisted_face_id: str, **kwargs: Any
    ) -> None:
        """Delete a face from a Face List by specified faceListId and persistedFaceId.

        Adding/deleting faces to/from a same Face List are processed sequentially and to/from different
        Face Lists are in parallel.

        :param face_list_id: Valid character is letter in lower case or digit or '-' or '_', maximum
         length is 64. Required.
        :type face_list_id: str
        :param persisted_face_id: Face ID of the face. Required.
        :type persisted_face_id: str
        :return: None
        :rtype: None
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping[int, Type[HttpResponseError]] = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[None] = kwargs.pop("cls", None)

        _request = build_face_lists_delete_face_request(
            face_list_id=face_list_id,
            persisted_face_id=persisted_face_id,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, "str", skip_quote=True),
            "apiVersion": self._serialize.url("self._config.api_version", self._config.api_version, "str"),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = False
        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = _deserialize(_models.FaceErrorResponse, response.json())
            raise HttpResponseError(response=response, model=error)

        if cls:
            return cls(pipeline_response, None, {})  # type: ignore


class LargeFaceListsOperations:
    """
    .. warning::
        **DO NOT** instantiate this class directly.

        Instead, you should access the following operations through
        :class:`~azure.ai.vision.face.FaceServiceClient`'s
        :attr:`large_face_lists` attribute.
    """

    def __init__(self, *args, **kwargs):
        input_args = list(args)
        self._client = input_args.pop(0) if input_args else kwargs.pop("client")
        self._config = input_args.pop(0) if input_args else kwargs.pop("config")
        self._serialize = input_args.pop(0) if input_args else kwargs.pop("serializer")
        self._deserialize = input_args.pop(0) if input_args else kwargs.pop("deserializer")

    @overload
    def create(  # pylint: disable=inconsistent-return-statements
        self, large_face_list_id: str, body: JSON, *, content_type: str = "application/json", **kwargs: Any
    ) -> None:
        """Create an empty Large Face List with user-specified largeFaceListId, name, an optional userData
        and recognitionModel.

        Large Face List is a list of faces, up to 1,000,000 faces, and used by "Find Similar From Large
        Face List".

        After creation, user should use Add Large Face List Face to import the faces and Train Large
        Face List to make it ready for "Find Similar". No image will be stored. Only the extracted face
        feature(s) will be stored on server until Delete Large Face List is called.

        "Find Similar" is used for scenario like finding celebrity-like faces, similar face filtering,
        or as a light way face identification. But if the actual use is to identify person, please use
        Person Group / Large Person Group and "Identify".

        ..

           [!NOTE]

           *


           * Free-tier subscription quota: 64 Large Face Lists.
           * S0-tier subscription quota: 1,000,000 Large Face Lists.

        :param large_face_list_id: Valid character is letter in lower case or digit or '-' or '_',
         maximum length is 64. Required.
        :type large_face_list_id: str
        :param body: Required.
        :type body: JSON
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: None
        :rtype: None
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                body = {
                    "name": "str",
                    "recognitionModel": "str",
                    "userData": "str"
                }
        """

    @overload
    def create(  # pylint: disable=inconsistent-return-statements
        self,
        large_face_list_id: str,
        *,
        name: str,
        content_type: str = "application/json",
        user_data: Optional[str] = None,
        recognition_model: Optional[Union[str, _models.FaceRecognitionModel]] = None,
        **kwargs: Any,
    ) -> None:
        """Create an empty Large Face List with user-specified largeFaceListId, name, an optional userData
        and recognitionModel.

        Large Face List is a list of faces, up to 1,000,000 faces, and used by "Find Similar From Large
        Face List".

        After creation, user should use Add Large Face List Face to import the faces and Train Large
        Face List to make it ready for "Find Similar". No image will be stored. Only the extracted face
        feature(s) will be stored on server until Delete Large Face List is called.

        "Find Similar" is used for scenario like finding celebrity-like faces, similar face filtering,
        or as a light way face identification. But if the actual use is to identify person, please use
        Person Group / Large Person Group and "Identify".

        ..

           [!NOTE]

           *


           * Free-tier subscription quota: 64 Large Face Lists.
           * S0-tier subscription quota: 1,000,000 Large Face Lists.

        :param large_face_list_id: Valid character is letter in lower case or digit or '-' or '_',
         maximum length is 64. Required.
        :type large_face_list_id: str
        :keyword name: User defined name, maximum length is 128. Required.
        :paramtype name: str
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :keyword user_data: Optional user defined data. Length should not exceed 16K. Default value is
         None.
        :paramtype user_data: str
        :keyword recognition_model: The 'recognitionModel' associated with this face list. Supported
         'recognitionModel' values include 'recognition_01', 'recognition_02, 'recognition_03', and
         'recognition_04'. The default value is 'recognition_01'. 'recognition_04' is recommended since
         its accuracy is improved on faces wearing masks compared with 'recognition_03', and its overall
         accuracy is improved compared with 'recognition_01' and 'recognition_02'. Known values are:
         "recognition_01", "recognition_02", "recognition_03", and "recognition_04". Default value is
         None.
        :paramtype recognition_model: str or ~azure.ai.vision.face.models.FaceRecognitionModel
        :return: None
        :rtype: None
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @overload
    def create(  # pylint: disable=inconsistent-return-statements
        self, large_face_list_id: str, body: IO[bytes], *, content_type: str = "application/json", **kwargs: Any
    ) -> None:
        """Create an empty Large Face List with user-specified largeFaceListId, name, an optional userData
        and recognitionModel.

        Large Face List is a list of faces, up to 1,000,000 faces, and used by "Find Similar From Large
        Face List".

        After creation, user should use Add Large Face List Face to import the faces and Train Large
        Face List to make it ready for "Find Similar". No image will be stored. Only the extracted face
        feature(s) will be stored on server until Delete Large Face List is called.

        "Find Similar" is used for scenario like finding celebrity-like faces, similar face filtering,
        or as a light way face identification. But if the actual use is to identify person, please use
        Person Group / Large Person Group and "Identify".

        ..

           [!NOTE]

           *


           * Free-tier subscription quota: 64 Large Face Lists.
           * S0-tier subscription quota: 1,000,000 Large Face Lists.

        :param large_face_list_id: Valid character is letter in lower case or digit or '-' or '_',
         maximum length is 64. Required.
        :type large_face_list_id: str
        :param body: Required.
        :type body: IO[bytes]
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: None
        :rtype: None
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @distributed_trace
    def create(  # pylint: disable=inconsistent-return-statements
        self,
        large_face_list_id: str,
        body: Union[JSON, IO[bytes]] = _Unset,
        *,
        name: str = _Unset,
        user_data: Optional[str] = None,
        recognition_model: Optional[Union[str, _models.FaceRecognitionModel]] = None,
        **kwargs: Any,
    ) -> None:
        """Create an empty Large Face List with user-specified largeFaceListId, name, an optional userData
        and recognitionModel.

        Large Face List is a list of faces, up to 1,000,000 faces, and used by "Find Similar From Large
        Face List".

        After creation, user should use Add Large Face List Face to import the faces and Train Large
        Face List to make it ready for "Find Similar". No image will be stored. Only the extracted face
        feature(s) will be stored on server until Delete Large Face List is called.

        "Find Similar" is used for scenario like finding celebrity-like faces, similar face filtering,
        or as a light way face identification. But if the actual use is to identify person, please use
        Person Group / Large Person Group and "Identify".

        ..

           [!NOTE]

           *


           * Free-tier subscription quota: 64 Large Face Lists.
           * S0-tier subscription quota: 1,000,000 Large Face Lists.

        :param large_face_list_id: Valid character is letter in lower case or digit or '-' or '_',
         maximum length is 64. Required.
        :type large_face_list_id: str
        :param body: Is either a JSON type or a IO[bytes] type. Required.
        :type body: JSON or IO[bytes]
        :keyword name: User defined name, maximum length is 128. Required.
        :paramtype name: str
        :keyword user_data: Optional user defined data. Length should not exceed 16K. Default value is
         None.
        :paramtype user_data: str
        :keyword recognition_model: The 'recognitionModel' associated with this face list. Supported
         'recognitionModel' values include 'recognition_01', 'recognition_02, 'recognition_03', and
         'recognition_04'. The default value is 'recognition_01'. 'recognition_04' is recommended since
         its accuracy is improved on faces wearing masks compared with 'recognition_03', and its overall
         accuracy is improved compared with 'recognition_01' and 'recognition_02'. Known values are:
         "recognition_01", "recognition_02", "recognition_03", and "recognition_04". Default value is
         None.
        :paramtype recognition_model: str or ~azure.ai.vision.face.models.FaceRecognitionModel
        :return: None
        :rtype: None
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                body = {
                    "name": "str",
                    "recognitionModel": "str",
                    "userData": "str"
                }
        """
        error_map: MutableMapping[int, Type[HttpResponseError]] = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[None] = kwargs.pop("cls", None)

        if body is _Unset:
            if name is _Unset:
                raise TypeError("missing required argument: name")
            body = {"name": name, "recognitionModel": recognition_model, "userData": user_data}
            body = {k: v for k, v in body.items() if v is not None}
        content_type = content_type or "application/json"
        _content = None
        if isinstance(body, (IOBase, bytes)):
            _content = body
        else:
            _content = json.dumps(body, cls=SdkJSONEncoder, exclude_readonly=True)  # type: ignore

        _request = build_large_face_lists_create_request(
            large_face_list_id=large_face_list_id,
            content_type=content_type,
            content=_content,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, "str", skip_quote=True),
            "apiVersion": self._serialize.url("self._config.api_version", self._config.api_version, "str"),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = False
        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = _deserialize(_models.FaceErrorResponse, response.json())
            raise HttpResponseError(response=response, model=error)

        if cls:
            return cls(pipeline_response, None, {})  # type: ignore

    @distributed_trace
    def delete(self, large_face_list_id: str, **kwargs: Any) -> None:  # pylint: disable=inconsistent-return-statements
        """Delete a face from a Large Face List by specified largeFaceListId and persistedFaceId.

        Adding/deleting faces to/from a same Large Face List are processed sequentially and to/from
        different Large Face Lists are in parallel.

        :param large_face_list_id: Valid character is letter in lower case or digit or '-' or '_',
         maximum length is 64. Required.
        :type large_face_list_id: str
        :return: None
        :rtype: None
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping[int, Type[HttpResponseError]] = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[None] = kwargs.pop("cls", None)

        _request = build_large_face_lists_delete_request(
            large_face_list_id=large_face_list_id,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, "str", skip_quote=True),
            "apiVersion": self._serialize.url("self._config.api_version", self._config.api_version, "str"),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = False
        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = _deserialize(_models.FaceErrorResponse, response.json())
            raise HttpResponseError(response=response, model=error)

        if cls:
            return cls(pipeline_response, None, {})  # type: ignore

    @distributed_trace
    def get(
        self, large_face_list_id: str, *, return_recognition_model: Optional[bool] = None, **kwargs: Any
    ) -> _models.LargeFaceList:
        """Retrieve a Large Face List's largeFaceListId, name, userData and recognitionModel.

        :param large_face_list_id: Valid character is letter in lower case or digit or '-' or '_',
         maximum length is 64. Required.
        :type large_face_list_id: str
        :keyword return_recognition_model: Return 'recognitionModel' or not. The default value is
         false. Default value is None.
        :paramtype return_recognition_model: bool
        :return: LargeFaceList. The LargeFaceList is compatible with MutableMapping
        :rtype: ~azure.ai.vision.face.models.LargeFaceList
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "largeFaceListId": "str",
                    "name": "str",
                    "recognitionModel": "str",
                    "userData": "str"
                }
        """
        error_map: MutableMapping[int, Type[HttpResponseError]] = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[_models.LargeFaceList] = kwargs.pop("cls", None)

        _request = build_large_face_lists_get_request(
            large_face_list_id=large_face_list_id,
            return_recognition_model=return_recognition_model,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, "str", skip_quote=True),
            "apiVersion": self._serialize.url("self._config.api_version", self._config.api_version, "str"),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = kwargs.pop("stream", False)
        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                try:
                    response.read()  # Load the body in memory and close the socket
                except (StreamConsumedError, StreamClosedError):
                    pass
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = _deserialize(_models.FaceErrorResponse, response.json())
            raise HttpResponseError(response=response, model=error)

        if _stream:
            deserialized = response.iter_bytes()
        else:
            deserialized = _deserialize(_models.LargeFaceList, response.json())

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore

    @overload
    def update(  # pylint: disable=inconsistent-return-statements
        self, large_face_list_id: str, body: JSON, *, content_type: str = "application/json", **kwargs: Any
    ) -> None:
        """Update information of a Large Face List, including name and userData.

        :param large_face_list_id: Valid character is letter in lower case or digit or '-' or '_',
         maximum length is 64. Required.
        :type large_face_list_id: str
        :param body: Required.
        :type body: JSON
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: None
        :rtype: None
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                body = {
                    "name": "str",
                    "userData": "str"
                }
        """

    @overload
    def update(  # pylint: disable=inconsistent-return-statements
        self,
        large_face_list_id: str,
        *,
        content_type: str = "application/json",
        name: Optional[str] = None,
        user_data: Optional[str] = None,
        **kwargs: Any,
    ) -> None:
        """Update information of a Large Face List, including name and userData.

        :param large_face_list_id: Valid character is letter in lower case or digit or '-' or '_',
         maximum length is 64. Required.
        :type large_face_list_id: str
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :keyword name: User defined name, maximum length is 128. Default value is None.
        :paramtype name: str
        :keyword user_data: Optional user defined data. Length should not exceed 16K. Default value is
         None.
        :paramtype user_data: str
        :return: None
        :rtype: None
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @overload
    def update(  # pylint: disable=inconsistent-return-statements
        self, large_face_list_id: str, body: IO[bytes], *, content_type: str = "application/json", **kwargs: Any
    ) -> None:
        """Update information of a Large Face List, including name and userData.

        :param large_face_list_id: Valid character is letter in lower case or digit or '-' or '_',
         maximum length is 64. Required.
        :type large_face_list_id: str
        :param body: Required.
        :type body: IO[bytes]
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: None
        :rtype: None
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @distributed_trace
    def update(  # pylint: disable=inconsistent-return-statements
        self,
        large_face_list_id: str,
        body: Union[JSON, IO[bytes]] = _Unset,
        *,
        name: Optional[str] = None,
        user_data: Optional[str] = None,
        **kwargs: Any,
    ) -> None:
        """Update information of a Large Face List, including name and userData.

        :param large_face_list_id: Valid character is letter in lower case or digit or '-' or '_',
         maximum length is 64. Required.
        :type large_face_list_id: str
        :param body: Is either a JSON type or a IO[bytes] type. Required.
        :type body: JSON or IO[bytes]
        :keyword name: User defined name, maximum length is 128. Default value is None.
        :paramtype name: str
        :keyword user_data: Optional user defined data. Length should not exceed 16K. Default value is
         None.
        :paramtype user_data: str
        :return: None
        :rtype: None
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                body = {
                    "name": "str",
                    "userData": "str"
                }
        """
        error_map: MutableMapping[int, Type[HttpResponseError]] = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[None] = kwargs.pop("cls", None)

        if body is _Unset:
            body = {"name": name, "userData": user_data}
            body = {k: v for k, v in body.items() if v is not None}
        content_type = content_type or "application/json"
        _content = None
        if isinstance(body, (IOBase, bytes)):
            _content = body
        else:
            _content = json.dumps(body, cls=SdkJSONEncoder, exclude_readonly=True)  # type: ignore

        _request = build_large_face_lists_update_request(
            large_face_list_id=large_face_list_id,
            content_type=content_type,
            content=_content,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, "str", skip_quote=True),
            "apiVersion": self._serialize.url("self._config.api_version", self._config.api_version, "str"),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = False
        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = _deserialize(_models.FaceErrorResponse, response.json())
            raise HttpResponseError(response=response, model=error)

        if cls:
            return cls(pipeline_response, None, {})  # type: ignore

    @distributed_trace
    def get_large_face_lists(
        self,
        *,
        start: Optional[str] = None,
        top: Optional[int] = None,
        return_recognition_model: Optional[bool] = None,
        **kwargs: Any,
    ) -> List[_models.LargeFaceList]:
        """List Large Face Lists' information of largeFaceListId, name, userData and recognitionModel.

        To get face information inside largeFaceList use "Get Large Face List Face".

        Large Face Lists are stored in alphabetical order of largeFaceListId.
        >
        *


        * "start" parameter (string, optional) specifies an ID value from which returned entries will
        have larger IDs based on string comparison. Setting "start" to an empty value indicates that
        entries should be returned starting from the first item.
        * "top" parameter (int, optional) determines the maximum number of entries to be returned, with
        a limit of up to 1000 entries per call. To retrieve additional entries beyond this limit,
        specify "start" with the personId of the last entry returned in the current call.

        ..

           [!TIP]


           * For example, there are total 5 items with their IDs: "itemId1", ..., "itemId5".

             * "start=&top=" will return all 5 items.
             * "start=&top=2" will return "itemId1", "itemId2".
             * "start=itemId2&top=3" will return "itemId3", "itemId4", "itemId5".

        :keyword start: List resources greater than the "start". It contains no more than 64
         characters. Default is empty. Default value is None.
        :paramtype start: str
        :keyword top: The number of items to list, ranging in [1, 1000]. Default is 1000. Default value
         is None.
        :paramtype top: int
        :keyword return_recognition_model: Return 'recognitionModel' or not. The default value is
         false. Default value is None.
        :paramtype return_recognition_model: bool
        :return: list of LargeFaceList
        :rtype: list[~azure.ai.vision.face.models.LargeFaceList]
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == [
                    {
                        "largeFaceListId": "str",
                        "name": "str",
                        "recognitionModel": "str",
                        "userData": "str"
                    }
                ]
        """
        error_map: MutableMapping[int, Type[HttpResponseError]] = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[List[_models.LargeFaceList]] = kwargs.pop("cls", None)

        _request = build_large_face_lists_get_large_face_lists_request(
            start=start,
            top=top,
            return_recognition_model=return_recognition_model,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, "str", skip_quote=True),
            "apiVersion": self._serialize.url("self._config.api_version", self._config.api_version, "str"),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = kwargs.pop("stream", False)
        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                try:
                    response.read()  # Load the body in memory and close the socket
                except (StreamConsumedError, StreamClosedError):
                    pass
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = _deserialize(_models.FaceErrorResponse, response.json())
            raise HttpResponseError(response=response, model=error)

        if _stream:
            deserialized = response.iter_bytes()
        else:
            deserialized = _deserialize(List[_models.LargeFaceList], response.json())

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore

    @distributed_trace
    def get_training_status(self, large_face_list_id: str, **kwargs: Any) -> _models.TrainingResult:
        """To check the Large Face List training status completed or still ongoing. Large Face List
        training is an asynchronous operation triggered by "Train Large Face List".

        Training time depends on the number of face entries in a Large Face List. It could be in
        seconds, or up to half an hour for 1,000,000 faces.

        :param large_face_list_id: Valid character is letter in lower case or digit or '-' or '_',
         maximum length is 64. Required.
        :type large_face_list_id: str
        :return: TrainingResult. The TrainingResult is compatible with MutableMapping
        :rtype: ~azure.ai.vision.face.models.TrainingResult
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "createdDateTime": "2020-02-20 00:00:00",
                    "lastActionDateTime": "2020-02-20 00:00:00",
                    "lastSuccessfulTrainingDateTime": "2020-02-20 00:00:00",
                    "status": "str",
                    "message": "str"
                }
        """
        error_map: MutableMapping[int, Type[HttpResponseError]] = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[_models.TrainingResult] = kwargs.pop("cls", None)

        _request = build_large_face_lists_get_training_status_request(
            large_face_list_id=large_face_list_id,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, "str", skip_quote=True),
            "apiVersion": self._serialize.url("self._config.api_version", self._config.api_version, "str"),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = kwargs.pop("stream", False)
        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                try:
                    response.read()  # Load the body in memory and close the socket
                except (StreamConsumedError, StreamClosedError):
                    pass
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = _deserialize(_models.FaceErrorResponse, response.json())
            raise HttpResponseError(response=response, model=error)

        if _stream:
            deserialized = response.iter_bytes()
        else:
            deserialized = _deserialize(_models.TrainingResult, response.json())

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore

    def _train_initial(self, large_face_list_id: str, **kwargs: Any) -> Iterator[bytes]:
        error_map: MutableMapping[int, Type[HttpResponseError]] = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[Iterator[bytes]] = kwargs.pop("cls", None)

        _request = build_large_face_lists_train_request(
            large_face_list_id=large_face_list_id,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, "str", skip_quote=True),
            "apiVersion": self._serialize.url("self._config.api_version", self._config.api_version, "str"),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = True
        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [202]:
            try:
                response.read()  # Load the body in memory and close the socket
            except (StreamConsumedError, StreamClosedError):
                pass
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = _deserialize(_models.FaceErrorResponse, response.json())
            raise HttpResponseError(response=response, model=error)

        response_headers = {}
        response_headers["operation-Location"] = self._deserialize("str", response.headers.get("operation-Location"))

        deserialized = response.iter_bytes()

        if cls:
            return cls(pipeline_response, deserialized, response_headers)  # type: ignore

        return deserialized  # type: ignore

    @distributed_trace
    def begin_train(self, large_face_list_id: str, **kwargs: Any) -> LROPoller[None]:
        """Submit a Large Face List training task.

        Training is a crucial step that only a trained Large Face List can be used by "Find Similar
        From Large Face List".

        The training task is an asynchronous task. Training time depends on the number of face entries
        in a Large Face List. It could be in seconds, or up to half an hour for 1,000,000 faces. To
        check training completion, please use "Get Large Face List Training Status".

        :param large_face_list_id: Valid character is letter in lower case or digit or '-' or '_',
         maximum length is 64. Required.
        :type large_face_list_id: str
        :return: An instance of LROPoller that returns None
        :rtype: ~azure.core.polling.LROPoller[None]
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[None] = kwargs.pop("cls", None)
        polling: Union[bool, PollingMethod] = kwargs.pop("polling", True)
        lro_delay = kwargs.pop("polling_interval", self._config.polling_interval)
        cont_token: Optional[str] = kwargs.pop("continuation_token", None)
        if cont_token is None:
            raw_result = self._train_initial(
                large_face_list_id=large_face_list_id, cls=lambda x, y, z: x, headers=_headers, params=_params, **kwargs
            )
            raw_result.http_response.read()  # type: ignore
        kwargs.pop("error_map", None)

        def get_long_running_output(pipeline_response):  # pylint: disable=inconsistent-return-statements
            if cls:
                return cls(pipeline_response, None, {})  # type: ignore

        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, "str", skip_quote=True),
            "apiVersion": self._serialize.url("self._config.api_version", self._config.api_version, "str"),
        }

        if polling is True:
            polling_method: PollingMethod = cast(
                PollingMethod, LROBasePolling(lro_delay, path_format_arguments=path_format_arguments, **kwargs)
            )
        elif polling is False:
            polling_method = cast(PollingMethod, NoPolling())
        else:
            polling_method = polling
        if cont_token:
            return LROPoller[None].from_continuation_token(
                polling_method=polling_method,
                continuation_token=cont_token,
                client=self._client,
                deserialization_callback=get_long_running_output,
            )
        return LROPoller[None](self._client, raw_result, get_long_running_output, polling_method)  # type: ignore

    @overload
    def add_face_from_url(
        self,
        large_face_list_id: str,
        body: JSON,
        *,
        target_face: Optional[List[int]] = None,
        detection_model: Optional[Union[str, _models.FaceDetectionModel]] = None,
        user_data: Optional[str] = None,
        content_type: str = "application/json",
        **kwargs: Any,
    ) -> _models.AddFaceResult:
        """Add a face to a specified Large Face List, up to 1,000,000 faces.

        To deal with an image containing multiple faces, input face can be specified as an image with a
        targetFace rectangle. It returns a persistedFaceId representing the added face. No image will
        be stored. Only the extracted face feature(s) will be stored on server until "Delete Large Face
        List Face" or "Delete Large Face List" is called.

        Note that persistedFaceId is different from faceId generated by "Detect".
        >
        *


        * Higher face image quality means better recognition precision. Please consider high-quality
        faces: frontal, clear, and face size is 200x200 pixels (100 pixels between eyes) or bigger.
        * Each person entry can hold up to 248 faces.
        * JPEG, PNG, GIF (the first frame), and BMP format are supported. The allowed image file size
        is from 1KB to 6MB.
        * "targetFace" rectangle should contain one face. Zero or multiple faces will be regarded as an
        error. If the provided "targetFace" rectangle is not returned from "Detect", there's no
        guarantee to detect and add the face successfully.
        * Out of detectable face size (36x36 - 4096x4096 pixels), large head-pose, or large occlusions
        will cause failures.
        * The minimum detectable face size is 36x36 pixels in an image no larger than 1920x1080 pixels.
        Images with dimensions higher than 1920x1080 pixels will need a proportionally larger minimum
        face size.
        * Different 'detectionModel' values can be provided. To use and compare different detection
        models, please refer to
        https://learn.microsoft.com/azure/ai-services/computer-vision/how-to/specify-detection-model

        ..

           [!NOTE]

           *


           * Free-tier subscription quota: 1,000 faces per Large Face List.
           * S0-tier subscription quota: 1,000,000 faces per Large Face List.

        :param large_face_list_id: Valid character is letter in lower case or digit or '-' or '_',
         maximum length is 64. Required.
        :type large_face_list_id: str
        :param body: Required.
        :type body: JSON
        :keyword target_face: A face rectangle to specify the target face to be added to a person, in
         the format of 'targetFace=left,top,width,height'. Default value is None.
        :paramtype target_face: list[int]
        :keyword detection_model: The 'detectionModel' associated with the detected faceIds. Supported
         'detectionModel' values include 'detection_01', 'detection_02' and 'detection_03'. The default
         value is 'detection_01'. Known values are: "detection_01", "detection_02", and "detection_03".
         Default value is None.
        :paramtype detection_model: str or ~azure.ai.vision.face.models.FaceDetectionModel
        :keyword user_data: User-provided data attached to the face. The size limit is 1K. Default
         value is None.
        :paramtype user_data: str
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: AddFaceResult. The AddFaceResult is compatible with MutableMapping
        :rtype: ~azure.ai.vision.face.models.AddFaceResult
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                body = {
                    "url": "str"
                }

                # response body for status code(s): 200
                response == {
                    "persistedFaceId": "str"
                }
        """

    @overload
    def add_face_from_url(
        self,
        large_face_list_id: str,
        *,
        url: str,
        target_face: Optional[List[int]] = None,
        detection_model: Optional[Union[str, _models.FaceDetectionModel]] = None,
        user_data: Optional[str] = None,
        content_type: str = "application/json",
        **kwargs: Any,
    ) -> _models.AddFaceResult:
        """Add a face to a specified Large Face List, up to 1,000,000 faces.

        To deal with an image containing multiple faces, input face can be specified as an image with a
        targetFace rectangle. It returns a persistedFaceId representing the added face. No image will
        be stored. Only the extracted face feature(s) will be stored on server until "Delete Large Face
        List Face" or "Delete Large Face List" is called.

        Note that persistedFaceId is different from faceId generated by "Detect".
        >
        *


        * Higher face image quality means better recognition precision. Please consider high-quality
        faces: frontal, clear, and face size is 200x200 pixels (100 pixels between eyes) or bigger.
        * Each person entry can hold up to 248 faces.
        * JPEG, PNG, GIF (the first frame), and BMP format are supported. The allowed image file size
        is from 1KB to 6MB.
        * "targetFace" rectangle should contain one face. Zero or multiple faces will be regarded as an
        error. If the provided "targetFace" rectangle is not returned from "Detect", there's no
        guarantee to detect and add the face successfully.
        * Out of detectable face size (36x36 - 4096x4096 pixels), large head-pose, or large occlusions
        will cause failures.
        * The minimum detectable face size is 36x36 pixels in an image no larger than 1920x1080 pixels.
        Images with dimensions higher than 1920x1080 pixels will need a proportionally larger minimum
        face size.
        * Different 'detectionModel' values can be provided. To use and compare different detection
        models, please refer to
        https://learn.microsoft.com/azure/ai-services/computer-vision/how-to/specify-detection-model

        ..

           [!NOTE]

           *


           * Free-tier subscription quota: 1,000 faces per Large Face List.
           * S0-tier subscription quota: 1,000,000 faces per Large Face List.

        :param large_face_list_id: Valid character is letter in lower case or digit or '-' or '_',
         maximum length is 64. Required.
        :type large_face_list_id: str
        :keyword url: URL of input image. Required.
        :paramtype url: str
        :keyword target_face: A face rectangle to specify the target face to be added to a person, in
         the format of 'targetFace=left,top,width,height'. Default value is None.
        :paramtype target_face: list[int]
        :keyword detection_model: The 'detectionModel' associated with the detected faceIds. Supported
         'detectionModel' values include 'detection_01', 'detection_02' and 'detection_03'. The default
         value is 'detection_01'. Known values are: "detection_01", "detection_02", and "detection_03".
         Default value is None.
        :paramtype detection_model: str or ~azure.ai.vision.face.models.FaceDetectionModel
        :keyword user_data: User-provided data attached to the face. The size limit is 1K. Default
         value is None.
        :paramtype user_data: str
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: AddFaceResult. The AddFaceResult is compatible with MutableMapping
        :rtype: ~azure.ai.vision.face.models.AddFaceResult
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "persistedFaceId": "str"
                }
        """

    @overload
    def add_face_from_url(
        self,
        large_face_list_id: str,
        body: IO[bytes],
        *,
        target_face: Optional[List[int]] = None,
        detection_model: Optional[Union[str, _models.FaceDetectionModel]] = None,
        user_data: Optional[str] = None,
        content_type: str = "application/json",
        **kwargs: Any,
    ) -> _models.AddFaceResult:
        """Add a face to a specified Large Face List, up to 1,000,000 faces.

        To deal with an image containing multiple faces, input face can be specified as an image with a
        targetFace rectangle. It returns a persistedFaceId representing the added face. No image will
        be stored. Only the extracted face feature(s) will be stored on server until "Delete Large Face
        List Face" or "Delete Large Face List" is called.

        Note that persistedFaceId is different from faceId generated by "Detect".
        >
        *


        * Higher face image quality means better recognition precision. Please consider high-quality
        faces: frontal, clear, and face size is 200x200 pixels (100 pixels between eyes) or bigger.
        * Each person entry can hold up to 248 faces.
        * JPEG, PNG, GIF (the first frame), and BMP format are supported. The allowed image file size
        is from 1KB to 6MB.
        * "targetFace" rectangle should contain one face. Zero or multiple faces will be regarded as an
        error. If the provided "targetFace" rectangle is not returned from "Detect", there's no
        guarantee to detect and add the face successfully.
        * Out of detectable face size (36x36 - 4096x4096 pixels), large head-pose, or large occlusions
        will cause failures.
        * The minimum detectable face size is 36x36 pixels in an image no larger than 1920x1080 pixels.
        Images with dimensions higher than 1920x1080 pixels will need a proportionally larger minimum
        face size.
        * Different 'detectionModel' values can be provided. To use and compare different detection
        models, please refer to
        https://learn.microsoft.com/azure/ai-services/computer-vision/how-to/specify-detection-model

        ..

           [!NOTE]

           *


           * Free-tier subscription quota: 1,000 faces per Large Face List.
           * S0-tier subscription quota: 1,000,000 faces per Large Face List.

        :param large_face_list_id: Valid character is letter in lower case or digit or '-' or '_',
         maximum length is 64. Required.
        :type large_face_list_id: str
        :param body: Required.
        :type body: IO[bytes]
        :keyword target_face: A face rectangle to specify the target face to be added to a person, in
         the format of 'targetFace=left,top,width,height'. Default value is None.
        :paramtype target_face: list[int]
        :keyword detection_model: The 'detectionModel' associated with the detected faceIds. Supported
         'detectionModel' values include 'detection_01', 'detection_02' and 'detection_03'. The default
         value is 'detection_01'. Known values are: "detection_01", "detection_02", and "detection_03".
         Default value is None.
        :paramtype detection_model: str or ~azure.ai.vision.face.models.FaceDetectionModel
        :keyword user_data: User-provided data attached to the face. The size limit is 1K. Default
         value is None.
        :paramtype user_data: str
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: AddFaceResult. The AddFaceResult is compatible with MutableMapping
        :rtype: ~azure.ai.vision.face.models.AddFaceResult
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "persistedFaceId": "str"
                }
        """

    @distributed_trace
    def add_face_from_url(
        self,
        large_face_list_id: str,
        body: Union[JSON, IO[bytes]] = _Unset,
        *,
        url: str = _Unset,
        target_face: Optional[List[int]] = None,
        detection_model: Optional[Union[str, _models.FaceDetectionModel]] = None,
        user_data: Optional[str] = None,
        **kwargs: Any,
    ) -> _models.AddFaceResult:
        """Add a face to a specified Large Face List, up to 1,000,000 faces.

        To deal with an image containing multiple faces, input face can be specified as an image with a
        targetFace rectangle. It returns a persistedFaceId representing the added face. No image will
        be stored. Only the extracted face feature(s) will be stored on server until "Delete Large Face
        List Face" or "Delete Large Face List" is called.

        Note that persistedFaceId is different from faceId generated by "Detect".
        >
        *


        * Higher face image quality means better recognition precision. Please consider high-quality
        faces: frontal, clear, and face size is 200x200 pixels (100 pixels between eyes) or bigger.
        * Each person entry can hold up to 248 faces.
        * JPEG, PNG, GIF (the first frame), and BMP format are supported. The allowed image file size
        is from 1KB to 6MB.
        * "targetFace" rectangle should contain one face. Zero or multiple faces will be regarded as an
        error. If the provided "targetFace" rectangle is not returned from "Detect", there's no
        guarantee to detect and add the face successfully.
        * Out of detectable face size (36x36 - 4096x4096 pixels), large head-pose, or large occlusions
        will cause failures.
        * The minimum detectable face size is 36x36 pixels in an image no larger than 1920x1080 pixels.
        Images with dimensions higher than 1920x1080 pixels will need a proportionally larger minimum
        face size.
        * Different 'detectionModel' values can be provided. To use and compare different detection
        models, please refer to
        https://learn.microsoft.com/azure/ai-services/computer-vision/how-to/specify-detection-model

        ..

           [!NOTE]

           *


           * Free-tier subscription quota: 1,000 faces per Large Face List.
           * S0-tier subscription quota: 1,000,000 faces per Large Face List.

        :param large_face_list_id: Valid character is letter in lower case or digit or '-' or '_',
         maximum length is 64. Required.
        :type large_face_list_id: str
        :param body: Is either a JSON type or a IO[bytes] type. Required.
        :type body: JSON or IO[bytes]
        :keyword url: URL of input image. Required.
        :paramtype url: str
        :keyword target_face: A face rectangle to specify the target face to be added to a person, in
         the format of 'targetFace=left,top,width,height'. Default value is None.
        :paramtype target_face: list[int]
        :keyword detection_model: The 'detectionModel' associated with the detected faceIds. Supported
         'detectionModel' values include 'detection_01', 'detection_02' and 'detection_03'. The default
         value is 'detection_01'. Known values are: "detection_01", "detection_02", and "detection_03".
         Default value is None.
        :paramtype detection_model: str or ~azure.ai.vision.face.models.FaceDetectionModel
        :keyword user_data: User-provided data attached to the face. The size limit is 1K. Default
         value is None.
        :paramtype user_data: str
        :return: AddFaceResult. The AddFaceResult is compatible with MutableMapping
        :rtype: ~azure.ai.vision.face.models.AddFaceResult
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                body = {
                    "url": "str"
                }

                # response body for status code(s): 200
                response == {
                    "persistedFaceId": "str"
                }
        """
        error_map: MutableMapping[int, Type[HttpResponseError]] = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[_models.AddFaceResult] = kwargs.pop("cls", None)

        if body is _Unset:
            if url is _Unset:
                raise TypeError("missing required argument: url")
            body = {"url": url}
            body = {k: v for k, v in body.items() if v is not None}
        content_type = content_type or "application/json"
        _content = None
        if isinstance(body, (IOBase, bytes)):
            _content = body
        else:
            _content = json.dumps(body, cls=SdkJSONEncoder, exclude_readonly=True)  # type: ignore

        _request = build_large_face_lists_add_face_from_url_request(
            large_face_list_id=large_face_list_id,
            target_face=target_face,
            detection_model=detection_model,
            user_data=user_data,
            content_type=content_type,
            content=_content,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, "str", skip_quote=True),
            "apiVersion": self._serialize.url("self._config.api_version", self._config.api_version, "str"),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = kwargs.pop("stream", False)
        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                try:
                    response.read()  # Load the body in memory and close the socket
                except (StreamConsumedError, StreamClosedError):
                    pass
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = _deserialize(_models.FaceErrorResponse, response.json())
            raise HttpResponseError(response=response, model=error)

        if _stream:
            deserialized = response.iter_bytes()
        else:
            deserialized = _deserialize(_models.AddFaceResult, response.json())

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore

    @distributed_trace
    def add_face(
        self,
        large_face_list_id: str,
        image_content: bytes,
        *,
        target_face: Optional[List[int]] = None,
        detection_model: Optional[Union[str, _models.FaceDetectionModel]] = None,
        user_data: Optional[str] = None,
        **kwargs: Any,
    ) -> _models.AddFaceResult:
        """Add a face to a specified Large Face List, up to 1,000,000 faces.

        To deal with an image containing multiple faces, input face can be specified as an image with a
        targetFace rectangle. It returns a persistedFaceId representing the added face. No image will
        be stored. Only the extracted face feature(s) will be stored on server until "Delete Large Face
        List Face" or "Delete Large Face List" is called.

        Note that persistedFaceId is different from faceId generated by "Detect".
        >
        *


        * Higher face image quality means better recognition precision. Please consider high-quality
        faces: frontal, clear, and face size is 200x200 pixels (100 pixels between eyes) or bigger.
        * Each person entry can hold up to 248 faces.
        * JPEG, PNG, GIF (the first frame), and BMP format are supported. The allowed image file size
        is from 1KB to 6MB.
        * "targetFace" rectangle should contain one face. Zero or multiple faces will be regarded as an
        error. If the provided "targetFace" rectangle is not returned from "Detect", there's no
        guarantee to detect and add the face successfully.
        * Out of detectable face size (36x36 - 4096x4096 pixels), large head-pose, or large occlusions
        will cause failures.
        * The minimum detectable face size is 36x36 pixels in an image no larger than 1920x1080 pixels.
        Images with dimensions higher than 1920x1080 pixels will need a proportionally larger minimum
        face size.
        * Different 'detectionModel' values can be provided. To use and compare different detection
        models, please refer to
        https://learn.microsoft.com/azure/ai-services/computer-vision/how-to/specify-detection-model

        ..

           [!NOTE]

           *


           * Free-tier subscription quota: 1,000 faces per Large Face List.
           * S0-tier subscription quota: 1,000,000 faces per Large Face List.

        :param large_face_list_id: Valid character is letter in lower case or digit or '-' or '_',
         maximum length is 64. Required.
        :type large_face_list_id: str
        :param image_content: The image to be analyzed. Required.
        :type image_content: bytes
        :keyword target_face: A face rectangle to specify the target face to be added to a person, in
         the format of 'targetFace=left,top,width,height'. Default value is None.
        :paramtype target_face: list[int]
        :keyword detection_model: The 'detectionModel' associated with the detected faceIds. Supported
         'detectionModel' values include 'detection_01', 'detection_02' and 'detection_03'. The default
         value is 'detection_01'. Known values are: "detection_01", "detection_02", and "detection_03".
         Default value is None.
        :paramtype detection_model: str or ~azure.ai.vision.face.models.FaceDetectionModel
        :keyword user_data: User-provided data attached to the face. The size limit is 1K. Default
         value is None.
        :paramtype user_data: str
        :return: AddFaceResult. The AddFaceResult is compatible with MutableMapping
        :rtype: ~azure.ai.vision.face.models.AddFaceResult
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "persistedFaceId": "str"
                }
        """
        error_map: MutableMapping[int, Type[HttpResponseError]] = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: str = kwargs.pop("content_type", _headers.pop("content-type", "application/octet-stream"))
        cls: ClsType[_models.AddFaceResult] = kwargs.pop("cls", None)

        _content = image_content

        _request = build_large_face_lists_add_face_request(
            large_face_list_id=large_face_list_id,
            target_face=target_face,
            detection_model=detection_model,
            user_data=user_data,
            content_type=content_type,
            content=_content,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, "str", skip_quote=True),
            "apiVersion": self._serialize.url("self._config.api_version", self._config.api_version, "str"),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = kwargs.pop("stream", False)
        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                try:
                    response.read()  # Load the body in memory and close the socket
                except (StreamConsumedError, StreamClosedError):
                    pass
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = _deserialize(_models.FaceErrorResponse, response.json())
            raise HttpResponseError(response=response, model=error)

        if _stream:
            deserialized = response.iter_bytes()
        else:
            deserialized = _deserialize(_models.AddFaceResult, response.json())

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore

    @distributed_trace
    def delete_face(  # pylint: disable=inconsistent-return-statements
        self, large_face_list_id: str, persisted_face_id: str, **kwargs: Any
    ) -> None:
        """Delete a face from a Large Face List by specified largeFaceListId and persistedFaceId.

        :param large_face_list_id: Valid character is letter in lower case or digit or '-' or '_',
         maximum length is 64. Required.
        :type large_face_list_id: str
        :param persisted_face_id: Face ID of the face. Required.
        :type persisted_face_id: str
        :return: None
        :rtype: None
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping[int, Type[HttpResponseError]] = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[None] = kwargs.pop("cls", None)

        _request = build_large_face_lists_delete_face_request(
            large_face_list_id=large_face_list_id,
            persisted_face_id=persisted_face_id,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, "str", skip_quote=True),
            "apiVersion": self._serialize.url("self._config.api_version", self._config.api_version, "str"),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = False
        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = _deserialize(_models.FaceErrorResponse, response.json())
            raise HttpResponseError(response=response, model=error)

        if cls:
            return cls(pipeline_response, None, {})  # type: ignore

    @distributed_trace
    def get_face(self, large_face_list_id: str, persisted_face_id: str, **kwargs: Any) -> _models.LargeFaceListFace:
        """Retrieve persisted face in Large Face List by largeFaceListId and persistedFaceId.

        :param large_face_list_id: Valid character is letter in lower case or digit or '-' or '_',
         maximum length is 64. Required.
        :type large_face_list_id: str
        :param persisted_face_id: Face ID of the face. Required.
        :type persisted_face_id: str
        :return: LargeFaceListFace. The LargeFaceListFace is compatible with MutableMapping
        :rtype: ~azure.ai.vision.face.models.LargeFaceListFace
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "persistedFaceId": "str",
                    "userData": "str"
                }
        """
        error_map: MutableMapping[int, Type[HttpResponseError]] = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[_models.LargeFaceListFace] = kwargs.pop("cls", None)

        _request = build_large_face_lists_get_face_request(
            large_face_list_id=large_face_list_id,
            persisted_face_id=persisted_face_id,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, "str", skip_quote=True),
            "apiVersion": self._serialize.url("self._config.api_version", self._config.api_version, "str"),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = kwargs.pop("stream", False)
        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                try:
                    response.read()  # Load the body in memory and close the socket
                except (StreamConsumedError, StreamClosedError):
                    pass
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = _deserialize(_models.FaceErrorResponse, response.json())
            raise HttpResponseError(response=response, model=error)

        if _stream:
            deserialized = response.iter_bytes()
        else:
            deserialized = _deserialize(_models.LargeFaceListFace, response.json())

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore

    @overload
    def update_face(  # pylint: disable=inconsistent-return-statements
        self,
        large_face_list_id: str,
        persisted_face_id: str,
        body: JSON,
        *,
        content_type: str = "application/json",
        **kwargs: Any,
    ) -> None:
        """Update a specified face's userData field in a Large Face List by its persistedFaceId.

        :param large_face_list_id: Valid character is letter in lower case or digit or '-' or '_',
         maximum length is 64. Required.
        :type large_face_list_id: str
        :param persisted_face_id: Face ID of the face. Required.
        :type persisted_face_id: str
        :param body: Required.
        :type body: JSON
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: None
        :rtype: None
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                body = {
                    "userData": "str"
                }
        """

    @overload
    def update_face(  # pylint: disable=inconsistent-return-statements
        self,
        large_face_list_id: str,
        persisted_face_id: str,
        *,
        content_type: str = "application/json",
        user_data: Optional[str] = None,
        **kwargs: Any,
    ) -> None:
        """Update a specified face's userData field in a Large Face List by its persistedFaceId.

        :param large_face_list_id: Valid character is letter in lower case or digit or '-' or '_',
         maximum length is 64. Required.
        :type large_face_list_id: str
        :param persisted_face_id: Face ID of the face. Required.
        :type persisted_face_id: str
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :keyword user_data: User-provided data attached to the face. The length limit is 1K. Default
         value is None.
        :paramtype user_data: str
        :return: None
        :rtype: None
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @overload
    def update_face(  # pylint: disable=inconsistent-return-statements
        self,
        large_face_list_id: str,
        persisted_face_id: str,
        body: IO[bytes],
        *,
        content_type: str = "application/json",
        **kwargs: Any,
    ) -> None:
        """Update a specified face's userData field in a Large Face List by its persistedFaceId.

        :param large_face_list_id: Valid character is letter in lower case or digit or '-' or '_',
         maximum length is 64. Required.
        :type large_face_list_id: str
        :param persisted_face_id: Face ID of the face. Required.
        :type persisted_face_id: str
        :param body: Required.
        :type body: IO[bytes]
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: None
        :rtype: None
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @distributed_trace
    def update_face(  # pylint: disable=inconsistent-return-statements
        self,
        large_face_list_id: str,
        persisted_face_id: str,
        body: Union[JSON, IO[bytes]] = _Unset,
        *,
        user_data: Optional[str] = None,
        **kwargs: Any,
    ) -> None:
        """Update a specified face's userData field in a Large Face List by its persistedFaceId.

        :param large_face_list_id: Valid character is letter in lower case or digit or '-' or '_',
         maximum length is 64. Required.
        :type large_face_list_id: str
        :param persisted_face_id: Face ID of the face. Required.
        :type persisted_face_id: str
        :param body: Is either a JSON type or a IO[bytes] type. Required.
        :type body: JSON or IO[bytes]
        :keyword user_data: User-provided data attached to the face. The length limit is 1K. Default
         value is None.
        :paramtype user_data: str
        :return: None
        :rtype: None
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                body = {
                    "userData": "str"
                }
        """
        error_map: MutableMapping[int, Type[HttpResponseError]] = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[None] = kwargs.pop("cls", None)

        if body is _Unset:
            body = {"userData": user_data}
            body = {k: v for k, v in body.items() if v is not None}
        content_type = content_type or "application/json"
        _content = None
        if isinstance(body, (IOBase, bytes)):
            _content = body
        else:
            _content = json.dumps(body, cls=SdkJSONEncoder, exclude_readonly=True)  # type: ignore

        _request = build_large_face_lists_update_face_request(
            large_face_list_id=large_face_list_id,
            persisted_face_id=persisted_face_id,
            content_type=content_type,
            content=_content,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, "str", skip_quote=True),
            "apiVersion": self._serialize.url("self._config.api_version", self._config.api_version, "str"),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = False
        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = _deserialize(_models.FaceErrorResponse, response.json())
            raise HttpResponseError(response=response, model=error)

        if cls:
            return cls(pipeline_response, None, {})  # type: ignore

    @distributed_trace
    def get_faces(
        self, large_face_list_id: str, *, start: Optional[str] = None, top: Optional[int] = None, **kwargs: Any
    ) -> List[_models.LargeFaceListFace]:
        """List faces' persistedFaceId and userData in a specified Large Face List.

        Faces are stored in alphabetical order of persistedFaceId created in "Add Large Face List
        Face".
        >
        *


        * "start" parameter (string, optional) specifies an ID value from which returned entries will
        have larger IDs based on string comparison. Setting "start" to an empty value indicates that
        entries should be returned starting from the first item.
        * "top" parameter (int, optional) determines the maximum number of entries to be returned, with
        a limit of up to 1000 entries per call. To retrieve additional entries beyond this limit,
        specify "start" with the personId of the last entry returned in the current call.

        ..

           [!TIP]


           * For example, there are total 5 items with their IDs: "itemId1", ..., "itemId5".

             * "start=&top=" will return all 5 items.
             * "start=&top=2" will return "itemId1", "itemId2".
             * "start=itemId2&top=3" will return "itemId3", "itemId4", "itemId5".

        :param large_face_list_id: Valid character is letter in lower case or digit or '-' or '_',
         maximum length is 64. Required.
        :type large_face_list_id: str
        :keyword start: List resources greater than the "start". It contains no more than 64
         characters. Default is empty. Default value is None.
        :paramtype start: str
        :keyword top: The number of items to list, ranging in [1, 1000]. Default is 1000. Default value
         is None.
        :paramtype top: int
        :return: list of LargeFaceListFace
        :rtype: list[~azure.ai.vision.face.models.LargeFaceListFace]
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == [
                    {
                        "persistedFaceId": "str",
                        "userData": "str"
                    }
                ]
        """
        error_map: MutableMapping[int, Type[HttpResponseError]] = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[List[_models.LargeFaceListFace]] = kwargs.pop("cls", None)

        _request = build_large_face_lists_get_faces_request(
            large_face_list_id=large_face_list_id,
            start=start,
            top=top,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, "str", skip_quote=True),
            "apiVersion": self._serialize.url("self._config.api_version", self._config.api_version, "str"),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = kwargs.pop("stream", False)
        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                try:
                    response.read()  # Load the body in memory and close the socket
                except (StreamConsumedError, StreamClosedError):
                    pass
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = _deserialize(_models.FaceErrorResponse, response.json())
            raise HttpResponseError(response=response, model=error)

        if _stream:
            deserialized = response.iter_bytes()
        else:
            deserialized = _deserialize(List[_models.LargeFaceListFace], response.json())

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore


class PersonGroupsOperations:
    """
    .. warning::
        **DO NOT** instantiate this class directly.

        Instead, you should access the following operations through
        :class:`~azure.ai.vision.face.FaceServiceClient`'s
        :attr:`person_groups` attribute.
    """

    def __init__(self, *args, **kwargs):
        input_args = list(args)
        self._client = input_args.pop(0) if input_args else kwargs.pop("client")
        self._config = input_args.pop(0) if input_args else kwargs.pop("config")
        self._serialize = input_args.pop(0) if input_args else kwargs.pop("serializer")
        self._deserialize = input_args.pop(0) if input_args else kwargs.pop("deserializer")

    @overload
    def create(  # pylint: disable=inconsistent-return-statements
        self, person_group_id: str, body: JSON, *, content_type: str = "application/json", **kwargs: Any
    ) -> None:
        """Create a new Person Group with specified personGroupId, name, user-provided userData and
        recognitionModel.

        A Person Group is a container holding the uploaded person data, including face recognition
        features.

        After creation, use "Create Person Group Person" to add persons into the group, and then call
        "Train Person Group" to get this group ready for "Identify From Person Group".

        No image will be stored. Only the person's extracted face feature(s) and userData will be
        stored on server until "Delete Person Group Person" or "Delete Person Group" is called.

        'recognitionModel' should be specified to associate with this Person Group. The default value
        for 'recognitionModel' is 'recognition_01', if the latest model needed, please explicitly
        specify the model you need in this parameter. New faces that are added to an existing Person
        Group will use the recognition model that's already associated with the collection. Existing
        face feature(s) in a Person Group can't be updated to features extracted by another version of
        recognition model.

        ..

           [!NOTE]

           *


           * Free-tier subscription quota: 1,000 Person Groups. Each holds up to 1,000 persons.
           * S0-tier subscription quota: 1,000,000 Person Groups. Each holds up to 10,000 persons.
           * to handle larger scale face identification problem, please consider using Large Person
        Group.

        :param person_group_id: ID of the container. Required.
        :type person_group_id: str
        :param body: Required.
        :type body: JSON
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: None
        :rtype: None
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                body = {
                    "name": "str",
                    "recognitionModel": "str",
                    "userData": "str"
                }
        """

    @overload
    def create(  # pylint: disable=inconsistent-return-statements
        self,
        person_group_id: str,
        *,
        name: str,
        content_type: str = "application/json",
        user_data: Optional[str] = None,
        recognition_model: Optional[Union[str, _models.FaceRecognitionModel]] = None,
        **kwargs: Any,
    ) -> None:
        """Create a new Person Group with specified personGroupId, name, user-provided userData and
        recognitionModel.

        A Person Group is a container holding the uploaded person data, including face recognition
        features.

        After creation, use "Create Person Group Person" to add persons into the group, and then call
        "Train Person Group" to get this group ready for "Identify From Person Group".

        No image will be stored. Only the person's extracted face feature(s) and userData will be
        stored on server until "Delete Person Group Person" or "Delete Person Group" is called.

        'recognitionModel' should be specified to associate with this Person Group. The default value
        for 'recognitionModel' is 'recognition_01', if the latest model needed, please explicitly
        specify the model you need in this parameter. New faces that are added to an existing Person
        Group will use the recognition model that's already associated with the collection. Existing
        face feature(s) in a Person Group can't be updated to features extracted by another version of
        recognition model.

        ..

           [!NOTE]

           *


           * Free-tier subscription quota: 1,000 Person Groups. Each holds up to 1,000 persons.
           * S0-tier subscription quota: 1,000,000 Person Groups. Each holds up to 10,000 persons.
           * to handle larger scale face identification problem, please consider using Large Person
        Group.

        :param person_group_id: ID of the container. Required.
        :type person_group_id: str
        :keyword name: User defined name, maximum length is 128. Required.
        :paramtype name: str
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :keyword user_data: Optional user defined data. Length should not exceed 16K. Default value is
         None.
        :paramtype user_data: str
        :keyword recognition_model: The 'recognitionModel' associated with this face list. Supported
         'recognitionModel' values include 'recognition_01', 'recognition_02, 'recognition_03', and
         'recognition_04'. The default value is 'recognition_01'. 'recognition_04' is recommended since
         its accuracy is improved on faces wearing masks compared with 'recognition_03', and its overall
         accuracy is improved compared with 'recognition_01' and 'recognition_02'. Known values are:
         "recognition_01", "recognition_02", "recognition_03", and "recognition_04". Default value is
         None.
        :paramtype recognition_model: str or ~azure.ai.vision.face.models.FaceRecognitionModel
        :return: None
        :rtype: None
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @overload
    def create(  # pylint: disable=inconsistent-return-statements
        self, person_group_id: str, body: IO[bytes], *, content_type: str = "application/json", **kwargs: Any
    ) -> None:
        """Create a new Person Group with specified personGroupId, name, user-provided userData and
        recognitionModel.

        A Person Group is a container holding the uploaded person data, including face recognition
        features.

        After creation, use "Create Person Group Person" to add persons into the group, and then call
        "Train Person Group" to get this group ready for "Identify From Person Group".

        No image will be stored. Only the person's extracted face feature(s) and userData will be
        stored on server until "Delete Person Group Person" or "Delete Person Group" is called.

        'recognitionModel' should be specified to associate with this Person Group. The default value
        for 'recognitionModel' is 'recognition_01', if the latest model needed, please explicitly
        specify the model you need in this parameter. New faces that are added to an existing Person
        Group will use the recognition model that's already associated with the collection. Existing
        face feature(s) in a Person Group can't be updated to features extracted by another version of
        recognition model.

        ..

           [!NOTE]

           *


           * Free-tier subscription quota: 1,000 Person Groups. Each holds up to 1,000 persons.
           * S0-tier subscription quota: 1,000,000 Person Groups. Each holds up to 10,000 persons.
           * to handle larger scale face identification problem, please consider using Large Person
        Group.

        :param person_group_id: ID of the container. Required.
        :type person_group_id: str
        :param body: Required.
        :type body: IO[bytes]
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: None
        :rtype: None
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @distributed_trace
    def create(  # pylint: disable=inconsistent-return-statements
        self,
        person_group_id: str,
        body: Union[JSON, IO[bytes]] = _Unset,
        *,
        name: str = _Unset,
        user_data: Optional[str] = None,
        recognition_model: Optional[Union[str, _models.FaceRecognitionModel]] = None,
        **kwargs: Any,
    ) -> None:
        """Create a new Person Group with specified personGroupId, name, user-provided userData and
        recognitionModel.

        A Person Group is a container holding the uploaded person data, including face recognition
        features.

        After creation, use "Create Person Group Person" to add persons into the group, and then call
        "Train Person Group" to get this group ready for "Identify From Person Group".

        No image will be stored. Only the person's extracted face feature(s) and userData will be
        stored on server until "Delete Person Group Person" or "Delete Person Group" is called.

        'recognitionModel' should be specified to associate with this Person Group. The default value
        for 'recognitionModel' is 'recognition_01', if the latest model needed, please explicitly
        specify the model you need in this parameter. New faces that are added to an existing Person
        Group will use the recognition model that's already associated with the collection. Existing
        face feature(s) in a Person Group can't be updated to features extracted by another version of
        recognition model.

        ..

           [!NOTE]

           *


           * Free-tier subscription quota: 1,000 Person Groups. Each holds up to 1,000 persons.
           * S0-tier subscription quota: 1,000,000 Person Groups. Each holds up to 10,000 persons.
           * to handle larger scale face identification problem, please consider using Large Person
        Group.

        :param person_group_id: ID of the container. Required.
        :type person_group_id: str
        :param body: Is either a JSON type or a IO[bytes] type. Required.
        :type body: JSON or IO[bytes]
        :keyword name: User defined name, maximum length is 128. Required.
        :paramtype name: str
        :keyword user_data: Optional user defined data. Length should not exceed 16K. Default value is
         None.
        :paramtype user_data: str
        :keyword recognition_model: The 'recognitionModel' associated with this face list. Supported
         'recognitionModel' values include 'recognition_01', 'recognition_02, 'recognition_03', and
         'recognition_04'. The default value is 'recognition_01'. 'recognition_04' is recommended since
         its accuracy is improved on faces wearing masks compared with 'recognition_03', and its overall
         accuracy is improved compared with 'recognition_01' and 'recognition_02'. Known values are:
         "recognition_01", "recognition_02", "recognition_03", and "recognition_04". Default value is
         None.
        :paramtype recognition_model: str or ~azure.ai.vision.face.models.FaceRecognitionModel
        :return: None
        :rtype: None
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                body = {
                    "name": "str",
                    "recognitionModel": "str",
                    "userData": "str"
                }
        """
        error_map: MutableMapping[int, Type[HttpResponseError]] = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[None] = kwargs.pop("cls", None)

        if body is _Unset:
            if name is _Unset:
                raise TypeError("missing required argument: name")
            body = {"name": name, "recognitionModel": recognition_model, "userData": user_data}
            body = {k: v for k, v in body.items() if v is not None}
        content_type = content_type or "application/json"
        _content = None
        if isinstance(body, (IOBase, bytes)):
            _content = body
        else:
            _content = json.dumps(body, cls=SdkJSONEncoder, exclude_readonly=True)  # type: ignore

        _request = build_person_groups_create_request(
            person_group_id=person_group_id,
            content_type=content_type,
            content=_content,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, "str", skip_quote=True),
            "apiVersion": self._serialize.url("self._config.api_version", self._config.api_version, "str"),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = False
        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = _deserialize(_models.FaceErrorResponse, response.json())
            raise HttpResponseError(response=response, model=error)

        if cls:
            return cls(pipeline_response, None, {})  # type: ignore

    @distributed_trace
    def delete(self, person_group_id: str, **kwargs: Any) -> None:  # pylint: disable=inconsistent-return-statements
        """Delete an existing Person Group with specified personGroupId. Persisted data in this Person
        Group will be deleted.

        :param person_group_id: ID of the container. Required.
        :type person_group_id: str
        :return: None
        :rtype: None
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping[int, Type[HttpResponseError]] = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[None] = kwargs.pop("cls", None)

        _request = build_person_groups_delete_request(
            person_group_id=person_group_id,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, "str", skip_quote=True),
            "apiVersion": self._serialize.url("self._config.api_version", self._config.api_version, "str"),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = False
        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = _deserialize(_models.FaceErrorResponse, response.json())
            raise HttpResponseError(response=response, model=error)

        if cls:
            return cls(pipeline_response, None, {})  # type: ignore

    @distributed_trace
    def get(
        self, person_group_id: str, *, return_recognition_model: Optional[bool] = None, **kwargs: Any
    ) -> _models.PersonGroup:
        """Retrieve Person Group name, userData and recognitionModel. To get person information under this
        personGroup, use "Get Person Group Persons".

        :param person_group_id: ID of the container. Required.
        :type person_group_id: str
        :keyword return_recognition_model: Return 'recognitionModel' or not. The default value is
         false. Default value is None.
        :paramtype return_recognition_model: bool
        :return: PersonGroup. The PersonGroup is compatible with MutableMapping
        :rtype: ~azure.ai.vision.face.models.PersonGroup
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "name": "str",
                    "personGroupId": "str",
                    "recognitionModel": "str",
                    "userData": "str"
                }
        """
        error_map: MutableMapping[int, Type[HttpResponseError]] = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[_models.PersonGroup] = kwargs.pop("cls", None)

        _request = build_person_groups_get_request(
            person_group_id=person_group_id,
            return_recognition_model=return_recognition_model,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, "str", skip_quote=True),
            "apiVersion": self._serialize.url("self._config.api_version", self._config.api_version, "str"),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = kwargs.pop("stream", False)
        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                try:
                    response.read()  # Load the body in memory and close the socket
                except (StreamConsumedError, StreamClosedError):
                    pass
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = _deserialize(_models.FaceErrorResponse, response.json())
            raise HttpResponseError(response=response, model=error)

        if _stream:
            deserialized = response.iter_bytes()
        else:
            deserialized = _deserialize(_models.PersonGroup, response.json())

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore

    @overload
    def update(  # pylint: disable=inconsistent-return-statements
        self, person_group_id: str, body: JSON, *, content_type: str = "application/json", **kwargs: Any
    ) -> None:
        """Update an existing Person Group's name and userData. The properties keep unchanged if they are
        not in request body.

        :param person_group_id: ID of the container. Required.
        :type person_group_id: str
        :param body: Required.
        :type body: JSON
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: None
        :rtype: None
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                body = {
                    "name": "str",
                    "userData": "str"
                }
        """

    @overload
    def update(  # pylint: disable=inconsistent-return-statements
        self,
        person_group_id: str,
        *,
        content_type: str = "application/json",
        name: Optional[str] = None,
        user_data: Optional[str] = None,
        **kwargs: Any,
    ) -> None:
        """Update an existing Person Group's name and userData. The properties keep unchanged if they are
        not in request body.

        :param person_group_id: ID of the container. Required.
        :type person_group_id: str
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :keyword name: User defined name, maximum length is 128. Default value is None.
        :paramtype name: str
        :keyword user_data: Optional user defined data. Length should not exceed 16K. Default value is
         None.
        :paramtype user_data: str
        :return: None
        :rtype: None
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @overload
    def update(  # pylint: disable=inconsistent-return-statements
        self, person_group_id: str, body: IO[bytes], *, content_type: str = "application/json", **kwargs: Any
    ) -> None:
        """Update an existing Person Group's name and userData. The properties keep unchanged if they are
        not in request body.

        :param person_group_id: ID of the container. Required.
        :type person_group_id: str
        :param body: Required.
        :type body: IO[bytes]
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: None
        :rtype: None
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @distributed_trace
    def update(  # pylint: disable=inconsistent-return-statements
        self,
        person_group_id: str,
        body: Union[JSON, IO[bytes]] = _Unset,
        *,
        name: Optional[str] = None,
        user_data: Optional[str] = None,
        **kwargs: Any,
    ) -> None:
        """Update an existing Person Group's name and userData. The properties keep unchanged if they are
        not in request body.

        :param person_group_id: ID of the container. Required.
        :type person_group_id: str
        :param body: Is either a JSON type or a IO[bytes] type. Required.
        :type body: JSON or IO[bytes]
        :keyword name: User defined name, maximum length is 128. Default value is None.
        :paramtype name: str
        :keyword user_data: Optional user defined data. Length should not exceed 16K. Default value is
         None.
        :paramtype user_data: str
        :return: None
        :rtype: None
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                body = {
                    "name": "str",
                    "userData": "str"
                }
        """
        error_map: MutableMapping[int, Type[HttpResponseError]] = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[None] = kwargs.pop("cls", None)

        if body is _Unset:
            body = {"name": name, "userData": user_data}
            body = {k: v for k, v in body.items() if v is not None}
        content_type = content_type or "application/json"
        _content = None
        if isinstance(body, (IOBase, bytes)):
            _content = body
        else:
            _content = json.dumps(body, cls=SdkJSONEncoder, exclude_readonly=True)  # type: ignore

        _request = build_person_groups_update_request(
            person_group_id=person_group_id,
            content_type=content_type,
            content=_content,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, "str", skip_quote=True),
            "apiVersion": self._serialize.url("self._config.api_version", self._config.api_version, "str"),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = False
        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = _deserialize(_models.FaceErrorResponse, response.json())
            raise HttpResponseError(response=response, model=error)

        if cls:
            return cls(pipeline_response, None, {})  # type: ignore

    @distributed_trace
    def get_person_groups(
        self,
        *,
        start: Optional[str] = None,
        top: Optional[int] = None,
        return_recognition_model: Optional[bool] = None,
        **kwargs: Any,
    ) -> List[_models.PersonGroup]:
        """List Person Groups' personGroupId, name, userData and recognitionModel.

        Person Groups are stored in alphabetical order of personGroupId.
        >
        *


        * "start" parameter (string, optional) specifies an ID value from which returned entries will
        have larger IDs based on string comparison. Setting "start" to an empty value indicates that
        entries should be returned starting from the first item.
        * "top" parameter (int, optional) determines the maximum number of entries to be returned, with
        a limit of up to 1000 entries per call. To retrieve additional entries beyond this limit,
        specify "start" with the personId of the last entry returned in the current call.

        ..

           [!TIP]


           * For example, there are total 5 items with their IDs: "itemId1", ..., "itemId5".

             * "start=&top=" will return all 5 items.
             * "start=&top=2" will return "itemId1", "itemId2".
             * "start=itemId2&top=3" will return "itemId3", "itemId4", "itemId5".

        :keyword start: List resources greater than the "start". It contains no more than 64
         characters. Default is empty. Default value is None.
        :paramtype start: str
        :keyword top: The number of items to list, ranging in [1, 1000]. Default is 1000. Default value
         is None.
        :paramtype top: int
        :keyword return_recognition_model: Return 'recognitionModel' or not. The default value is
         false. Default value is None.
        :paramtype return_recognition_model: bool
        :return: list of PersonGroup
        :rtype: list[~azure.ai.vision.face.models.PersonGroup]
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == [
                    {
                        "name": "str",
                        "personGroupId": "str",
                        "recognitionModel": "str",
                        "userData": "str"
                    }
                ]
        """
        error_map: MutableMapping[int, Type[HttpResponseError]] = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[List[_models.PersonGroup]] = kwargs.pop("cls", None)

        _request = build_person_groups_get_person_groups_request(
            start=start,
            top=top,
            return_recognition_model=return_recognition_model,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, "str", skip_quote=True),
            "apiVersion": self._serialize.url("self._config.api_version", self._config.api_version, "str"),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = kwargs.pop("stream", False)
        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                try:
                    response.read()  # Load the body in memory and close the socket
                except (StreamConsumedError, StreamClosedError):
                    pass
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = _deserialize(_models.FaceErrorResponse, response.json())
            raise HttpResponseError(response=response, model=error)

        if _stream:
            deserialized = response.iter_bytes()
        else:
            deserialized = _deserialize(List[_models.PersonGroup], response.json())

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore

    @distributed_trace
    def get_training_status(self, person_group_id: str, **kwargs: Any) -> _models.TrainingResult:
        """To check Person Group training status completed or still ongoing. Person Group training is an
        asynchronous operation triggered by "Train Person Group" API.

        :param person_group_id: ID of the container. Required.
        :type person_group_id: str
        :return: TrainingResult. The TrainingResult is compatible with MutableMapping
        :rtype: ~azure.ai.vision.face.models.TrainingResult
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "createdDateTime": "2020-02-20 00:00:00",
                    "lastActionDateTime": "2020-02-20 00:00:00",
                    "lastSuccessfulTrainingDateTime": "2020-02-20 00:00:00",
                    "status": "str",
                    "message": "str"
                }
        """
        error_map: MutableMapping[int, Type[HttpResponseError]] = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[_models.TrainingResult] = kwargs.pop("cls", None)

        _request = build_person_groups_get_training_status_request(
            person_group_id=person_group_id,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, "str", skip_quote=True),
            "apiVersion": self._serialize.url("self._config.api_version", self._config.api_version, "str"),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = kwargs.pop("stream", False)
        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                try:
                    response.read()  # Load the body in memory and close the socket
                except (StreamConsumedError, StreamClosedError):
                    pass
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = _deserialize(_models.FaceErrorResponse, response.json())
            raise HttpResponseError(response=response, model=error)

        if _stream:
            deserialized = response.iter_bytes()
        else:
            deserialized = _deserialize(_models.TrainingResult, response.json())

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore

    def _train_initial(self, person_group_id: str, **kwargs: Any) -> Iterator[bytes]:
        error_map: MutableMapping[int, Type[HttpResponseError]] = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[Iterator[bytes]] = kwargs.pop("cls", None)

        _request = build_person_groups_train_request(
            person_group_id=person_group_id,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, "str", skip_quote=True),
            "apiVersion": self._serialize.url("self._config.api_version", self._config.api_version, "str"),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = True
        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [202]:
            try:
                response.read()  # Load the body in memory and close the socket
            except (StreamConsumedError, StreamClosedError):
                pass
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = _deserialize(_models.FaceErrorResponse, response.json())
            raise HttpResponseError(response=response, model=error)

        response_headers = {}
        response_headers["operation-Location"] = self._deserialize("str", response.headers.get("operation-Location"))

        deserialized = response.iter_bytes()

        if cls:
            return cls(pipeline_response, deserialized, response_headers)  # type: ignore

        return deserialized  # type: ignore

    @distributed_trace
    def begin_train(self, person_group_id: str, **kwargs: Any) -> LROPoller[None]:
        """Submit a Person Group training task. Training is a crucial step that only a trained Person
        Group can be used by "Identify From Person Group".

        The training task is an asynchronous task. Training time depends on the number of person
        entries, and their faces in a Person Group. It could be several seconds to minutes. To check
        training status, please use "Get Person Group Training Status".

        :param person_group_id: ID of the container. Required.
        :type person_group_id: str
        :return: An instance of LROPoller that returns None
        :rtype: ~azure.core.polling.LROPoller[None]
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[None] = kwargs.pop("cls", None)
        polling: Union[bool, PollingMethod] = kwargs.pop("polling", True)
        lro_delay = kwargs.pop("polling_interval", self._config.polling_interval)
        cont_token: Optional[str] = kwargs.pop("continuation_token", None)
        if cont_token is None:
            raw_result = self._train_initial(
                person_group_id=person_group_id, cls=lambda x, y, z: x, headers=_headers, params=_params, **kwargs
            )
            raw_result.http_response.read()  # type: ignore
        kwargs.pop("error_map", None)

        def get_long_running_output(pipeline_response):  # pylint: disable=inconsistent-return-statements
            if cls:
                return cls(pipeline_response, None, {})  # type: ignore

        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, "str", skip_quote=True),
            "apiVersion": self._serialize.url("self._config.api_version", self._config.api_version, "str"),
        }

        if polling is True:
            polling_method: PollingMethod = cast(
                PollingMethod, LROBasePolling(lro_delay, path_format_arguments=path_format_arguments, **kwargs)
            )
        elif polling is False:
            polling_method = cast(PollingMethod, NoPolling())
        else:
            polling_method = polling
        if cont_token:
            return LROPoller[None].from_continuation_token(
                polling_method=polling_method,
                continuation_token=cont_token,
                client=self._client,
                deserialization_callback=get_long_running_output,
            )
        return LROPoller[None](self._client, raw_result, get_long_running_output, polling_method)  # type: ignore

    @overload
    def create_person(
        self, person_group_id: str, body: JSON, *, content_type: str = "application/json", **kwargs: Any
    ) -> _models.CreatePersonResult:
        """Create a new person in a specified Person Group. To add face to this person, please call "Add
        Person Group Person Face".

        ..

           [!NOTE]

           *


           * Free-tier subscription quota:

             * 1,000 persons in all Person Groups.

           * S0-tier subscription quota:

             * 10,000 persons per Person Group.
             * 1,000,000 Person Groups.
             * 100,000,000 persons in all Person Groups.

        :param person_group_id: ID of the container. Required.
        :type person_group_id: str
        :param body: Required.
        :type body: JSON
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: CreatePersonResult. The CreatePersonResult is compatible with MutableMapping
        :rtype: ~azure.ai.vision.face.models.CreatePersonResult
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                body = {
                    "name": "str",
                    "userData": "str"
                }

                # response body for status code(s): 200
                response == {
                    "personId": "str"
                }
        """

    @overload
    def create_person(
        self,
        person_group_id: str,
        *,
        name: str,
        content_type: str = "application/json",
        user_data: Optional[str] = None,
        **kwargs: Any,
    ) -> _models.CreatePersonResult:
        """Create a new person in a specified Person Group. To add face to this person, please call "Add
        Person Group Person Face".

        ..

           [!NOTE]

           *


           * Free-tier subscription quota:

             * 1,000 persons in all Person Groups.

           * S0-tier subscription quota:

             * 10,000 persons per Person Group.
             * 1,000,000 Person Groups.
             * 100,000,000 persons in all Person Groups.

        :param person_group_id: ID of the container. Required.
        :type person_group_id: str
        :keyword name: User defined name, maximum length is 128. Required.
        :paramtype name: str
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :keyword user_data: Optional user defined data. Length should not exceed 16K. Default value is
         None.
        :paramtype user_data: str
        :return: CreatePersonResult. The CreatePersonResult is compatible with MutableMapping
        :rtype: ~azure.ai.vision.face.models.CreatePersonResult
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "personId": "str"
                }
        """

    @overload
    def create_person(
        self, person_group_id: str, body: IO[bytes], *, content_type: str = "application/json", **kwargs: Any
    ) -> _models.CreatePersonResult:
        """Create a new person in a specified Person Group. To add face to this person, please call "Add
        Person Group Person Face".

        ..

           [!NOTE]

           *


           * Free-tier subscription quota:

             * 1,000 persons in all Person Groups.

           * S0-tier subscription quota:

             * 10,000 persons per Person Group.
             * 1,000,000 Person Groups.
             * 100,000,000 persons in all Person Groups.

        :param person_group_id: ID of the container. Required.
        :type person_group_id: str
        :param body: Required.
        :type body: IO[bytes]
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: CreatePersonResult. The CreatePersonResult is compatible with MutableMapping
        :rtype: ~azure.ai.vision.face.models.CreatePersonResult
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "personId": "str"
                }
        """

    @distributed_trace
    def create_person(
        self,
        person_group_id: str,
        body: Union[JSON, IO[bytes]] = _Unset,
        *,
        name: str = _Unset,
        user_data: Optional[str] = None,
        **kwargs: Any,
    ) -> _models.CreatePersonResult:
        """Create a new person in a specified Person Group. To add face to this person, please call "Add
        Person Group Person Face".

        ..

           [!NOTE]

           *


           * Free-tier subscription quota:

             * 1,000 persons in all Person Groups.

           * S0-tier subscription quota:

             * 10,000 persons per Person Group.
             * 1,000,000 Person Groups.
             * 100,000,000 persons in all Person Groups.

        :param person_group_id: ID of the container. Required.
        :type person_group_id: str
        :param body: Is either a JSON type or a IO[bytes] type. Required.
        :type body: JSON or IO[bytes]
        :keyword name: User defined name, maximum length is 128. Required.
        :paramtype name: str
        :keyword user_data: Optional user defined data. Length should not exceed 16K. Default value is
         None.
        :paramtype user_data: str
        :return: CreatePersonResult. The CreatePersonResult is compatible with MutableMapping
        :rtype: ~azure.ai.vision.face.models.CreatePersonResult
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                body = {
                    "name": "str",
                    "userData": "str"
                }

                # response body for status code(s): 200
                response == {
                    "personId": "str"
                }
        """
        error_map: MutableMapping[int, Type[HttpResponseError]] = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[_models.CreatePersonResult] = kwargs.pop("cls", None)

        if body is _Unset:
            if name is _Unset:
                raise TypeError("missing required argument: name")
            body = {"name": name, "userData": user_data}
            body = {k: v for k, v in body.items() if v is not None}
        content_type = content_type or "application/json"
        _content = None
        if isinstance(body, (IOBase, bytes)):
            _content = body
        else:
            _content = json.dumps(body, cls=SdkJSONEncoder, exclude_readonly=True)  # type: ignore

        _request = build_person_groups_create_person_request(
            person_group_id=person_group_id,
            content_type=content_type,
            content=_content,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, "str", skip_quote=True),
            "apiVersion": self._serialize.url("self._config.api_version", self._config.api_version, "str"),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = kwargs.pop("stream", False)
        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                try:
                    response.read()  # Load the body in memory and close the socket
                except (StreamConsumedError, StreamClosedError):
                    pass
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = _deserialize(_models.FaceErrorResponse, response.json())
            raise HttpResponseError(response=response, model=error)

        if _stream:
            deserialized = response.iter_bytes()
        else:
            deserialized = _deserialize(_models.CreatePersonResult, response.json())

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore

    @distributed_trace
    def delete_person(  # pylint: disable=inconsistent-return-statements
        self, person_group_id: str, person_id: str, **kwargs: Any
    ) -> None:
        """Delete an existing person from a Person Group. The persistedFaceId, userData, person name and
        face feature(s) in the person entry will all be deleted.

        :param person_group_id: ID of the container. Required.
        :type person_group_id: str
        :param person_id: ID of the person. Required.
        :type person_id: str
        :return: None
        :rtype: None
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping[int, Type[HttpResponseError]] = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[None] = kwargs.pop("cls", None)

        _request = build_person_groups_delete_person_request(
            person_group_id=person_group_id,
            person_id=person_id,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, "str", skip_quote=True),
            "apiVersion": self._serialize.url("self._config.api_version", self._config.api_version, "str"),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = False
        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = _deserialize(_models.FaceErrorResponse, response.json())
            raise HttpResponseError(response=response, model=error)

        if cls:
            return cls(pipeline_response, None, {})  # type: ignore

    @distributed_trace
    def get_person(self, person_group_id: str, person_id: str, **kwargs: Any) -> _models.PersonGroupPerson:
        """Retrieve a person's name and userData, and the persisted faceIds representing the registered
        person face feature(s).

        :param person_group_id: ID of the container. Required.
        :type person_group_id: str
        :param person_id: ID of the person. Required.
        :type person_id: str
        :return: PersonGroupPerson. The PersonGroupPerson is compatible with MutableMapping
        :rtype: ~azure.ai.vision.face.models.PersonGroupPerson
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "name": "str",
                    "personId": "str",
                    "persistedFaceIds": [
                        "str"
                    ],
                    "userData": "str"
                }
        """
        error_map: MutableMapping[int, Type[HttpResponseError]] = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[_models.PersonGroupPerson] = kwargs.pop("cls", None)

        _request = build_person_groups_get_person_request(
            person_group_id=person_group_id,
            person_id=person_id,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, "str", skip_quote=True),
            "apiVersion": self._serialize.url("self._config.api_version", self._config.api_version, "str"),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = kwargs.pop("stream", False)
        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                try:
                    response.read()  # Load the body in memory and close the socket
                except (StreamConsumedError, StreamClosedError):
                    pass
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = _deserialize(_models.FaceErrorResponse, response.json())
            raise HttpResponseError(response=response, model=error)

        if _stream:
            deserialized = response.iter_bytes()
        else:
            deserialized = _deserialize(_models.PersonGroupPerson, response.json())

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore

    @overload
    def update_person(  # pylint: disable=inconsistent-return-statements
        self, person_group_id: str, person_id: str, body: JSON, *, content_type: str = "application/json", **kwargs: Any
    ) -> None:
        """Update name or userData of a person.

        :param person_group_id: ID of the container. Required.
        :type person_group_id: str
        :param person_id: ID of the person. Required.
        :type person_id: str
        :param body: Required.
        :type body: JSON
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: None
        :rtype: None
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                body = {
                    "name": "str",
                    "userData": "str"
                }
        """

    @overload
    def update_person(  # pylint: disable=inconsistent-return-statements
        self,
        person_group_id: str,
        person_id: str,
        *,
        content_type: str = "application/json",
        name: Optional[str] = None,
        user_data: Optional[str] = None,
        **kwargs: Any,
    ) -> None:
        """Update name or userData of a person.

        :param person_group_id: ID of the container. Required.
        :type person_group_id: str
        :param person_id: ID of the person. Required.
        :type person_id: str
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :keyword name: User defined name, maximum length is 128. Default value is None.
        :paramtype name: str
        :keyword user_data: Optional user defined data. Length should not exceed 16K. Default value is
         None.
        :paramtype user_data: str
        :return: None
        :rtype: None
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @overload
    def update_person(  # pylint: disable=inconsistent-return-statements
        self,
        person_group_id: str,
        person_id: str,
        body: IO[bytes],
        *,
        content_type: str = "application/json",
        **kwargs: Any,
    ) -> None:
        """Update name or userData of a person.

        :param person_group_id: ID of the container. Required.
        :type person_group_id: str
        :param person_id: ID of the person. Required.
        :type person_id: str
        :param body: Required.
        :type body: IO[bytes]
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: None
        :rtype: None
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @distributed_trace
    def update_person(  # pylint: disable=inconsistent-return-statements
        self,
        person_group_id: str,
        person_id: str,
        body: Union[JSON, IO[bytes]] = _Unset,
        *,
        name: Optional[str] = None,
        user_data: Optional[str] = None,
        **kwargs: Any,
    ) -> None:
        """Update name or userData of a person.

        :param person_group_id: ID of the container. Required.
        :type person_group_id: str
        :param person_id: ID of the person. Required.
        :type person_id: str
        :param body: Is either a JSON type or a IO[bytes] type. Required.
        :type body: JSON or IO[bytes]
        :keyword name: User defined name, maximum length is 128. Default value is None.
        :paramtype name: str
        :keyword user_data: Optional user defined data. Length should not exceed 16K. Default value is
         None.
        :paramtype user_data: str
        :return: None
        :rtype: None
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                body = {
                    "name": "str",
                    "userData": "str"
                }
        """
        error_map: MutableMapping[int, Type[HttpResponseError]] = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[None] = kwargs.pop("cls", None)

        if body is _Unset:
            body = {"name": name, "userData": user_data}
            body = {k: v for k, v in body.items() if v is not None}
        content_type = content_type or "application/json"
        _content = None
        if isinstance(body, (IOBase, bytes)):
            _content = body
        else:
            _content = json.dumps(body, cls=SdkJSONEncoder, exclude_readonly=True)  # type: ignore

        _request = build_person_groups_update_person_request(
            person_group_id=person_group_id,
            person_id=person_id,
            content_type=content_type,
            content=_content,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, "str", skip_quote=True),
            "apiVersion": self._serialize.url("self._config.api_version", self._config.api_version, "str"),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = False
        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = _deserialize(_models.FaceErrorResponse, response.json())
            raise HttpResponseError(response=response, model=error)

        if cls:
            return cls(pipeline_response, None, {})  # type: ignore

    @distributed_trace
    def get_persons(
        self, person_group_id: str, *, start: Optional[str] = None, top: Optional[int] = None, **kwargs: Any
    ) -> List[_models.PersonGroupPerson]:
        """List all persons' information in the specified Person Group, including personId, name, userData
        and persistedFaceIds of registered person faces.

        Persons are stored in alphabetical order of personId created in "Create Person Group Person".
        >
        *


        * "start" parameter (string, optional) specifies an ID value from which returned entries will
        have larger IDs based on string comparison. Setting "start" to an empty value indicates that
        entries should be returned starting from the first item.
        * "top" parameter (int, optional) determines the maximum number of entries to be returned, with
        a limit of up to 1000 entries per call. To retrieve additional entries beyond this limit,
        specify "start" with the personId of the last entry returned in the current call.

        ..

           [!TIP]


           * For example, there are total 5 items with their IDs: "itemId1", ..., "itemId5".

             * "start=&top=" will return all 5 items.
             * "start=&top=2" will return "itemId1", "itemId2".
             * "start=itemId2&top=3" will return "itemId3", "itemId4", "itemId5".

        :param person_group_id: ID of the container. Required.
        :type person_group_id: str
        :keyword start: List resources greater than the "start". It contains no more than 64
         characters. Default is empty. Default value is None.
        :paramtype start: str
        :keyword top: The number of items to list, ranging in [1, 1000]. Default is 1000. Default value
         is None.
        :paramtype top: int
        :return: list of PersonGroupPerson
        :rtype: list[~azure.ai.vision.face.models.PersonGroupPerson]
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == [
                    {
                        "name": "str",
                        "personId": "str",
                        "persistedFaceIds": [
                            "str"
                        ],
                        "userData": "str"
                    }
                ]
        """
        error_map: MutableMapping[int, Type[HttpResponseError]] = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[List[_models.PersonGroupPerson]] = kwargs.pop("cls", None)

        _request = build_person_groups_get_persons_request(
            person_group_id=person_group_id,
            start=start,
            top=top,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, "str", skip_quote=True),
            "apiVersion": self._serialize.url("self._config.api_version", self._config.api_version, "str"),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = kwargs.pop("stream", False)
        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                try:
                    response.read()  # Load the body in memory and close the socket
                except (StreamConsumedError, StreamClosedError):
                    pass
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = _deserialize(_models.FaceErrorResponse, response.json())
            raise HttpResponseError(response=response, model=error)

        if _stream:
            deserialized = response.iter_bytes()
        else:
            deserialized = _deserialize(List[_models.PersonGroupPerson], response.json())

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore

    @overload
    def add_face_from_url(
        self,
        person_group_id: str,
        person_id: str,
        body: JSON,
        *,
        target_face: Optional[List[int]] = None,
        detection_model: Optional[Union[str, _models.FaceDetectionModel]] = None,
        user_data: Optional[str] = None,
        content_type: str = "application/json",
        **kwargs: Any,
    ) -> _models.AddFaceResult:
        """Add a face to a person into a Person Group for face identification or verification.

        To deal with an image containing multiple faces, input face can be specified as an image with a
        targetFace rectangle. It returns a persistedFaceId representing the added face. No image will
        be stored. Only the extracted face feature(s) will be stored on server until "Delete Person
        Group Person Face", "Delete Person Group Person" or "Delete Person Group" is called.

        Note that persistedFaceId is different from faceId generated by "Detect".
        >
        *


        * Higher face image quality means better recognition precision. Please consider high-quality
        faces: frontal, clear, and face size is 200x200 pixels (100 pixels between eyes) or bigger.
        * Each person entry can hold up to 248 faces.
        * JPEG, PNG, GIF (the first frame), and BMP format are supported. The allowed image file size
        is from 1KB to 6MB.
        * "targetFace" rectangle should contain one face. Zero or multiple faces will be regarded as an
        error. If the provided "targetFace" rectangle is not returned from "Detect", there's no
        guarantee to detect and add the face successfully.
        * Out of detectable face size (36x36 - 4096x4096 pixels), large head-pose, or large occlusions
        will cause failures.
        * The minimum detectable face size is 36x36 pixels in an image no larger than 1920x1080 pixels.
        Images with dimensions higher than 1920x1080 pixels will need a proportionally larger minimum
        face size.
        * Different 'detectionModel' values can be provided. To use and compare different detection
        models, please refer to
        https://learn.microsoft.com/azure/ai-services/computer-vision/how-to/specify-detection-model.

        :param person_group_id: ID of the container. Required.
        :type person_group_id: str
        :param person_id: ID of the person. Required.
        :type person_id: str
        :param body: Required.
        :type body: JSON
        :keyword target_face: A face rectangle to specify the target face to be added to a person, in
         the format of 'targetFace=left,top,width,height'. Default value is None.
        :paramtype target_face: list[int]
        :keyword detection_model: The 'detectionModel' associated with the detected faceIds. Supported
         'detectionModel' values include 'detection_01', 'detection_02' and 'detection_03'. The default
         value is 'detection_01'. Known values are: "detection_01", "detection_02", and "detection_03".
         Default value is None.
        :paramtype detection_model: str or ~azure.ai.vision.face.models.FaceDetectionModel
        :keyword user_data: User-provided data attached to the face. The size limit is 1K. Default
         value is None.
        :paramtype user_data: str
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: AddFaceResult. The AddFaceResult is compatible with MutableMapping
        :rtype: ~azure.ai.vision.face.models.AddFaceResult
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                body = {
                    "url": "str"
                }

                # response body for status code(s): 200
                response == {
                    "persistedFaceId": "str"
                }
        """

    @overload
    def add_face_from_url(
        self,
        person_group_id: str,
        person_id: str,
        *,
        url: str,
        target_face: Optional[List[int]] = None,
        detection_model: Optional[Union[str, _models.FaceDetectionModel]] = None,
        user_data: Optional[str] = None,
        content_type: str = "application/json",
        **kwargs: Any,
    ) -> _models.AddFaceResult:
        """Add a face to a person into a Person Group for face identification or verification.

        To deal with an image containing multiple faces, input face can be specified as an image with a
        targetFace rectangle. It returns a persistedFaceId representing the added face. No image will
        be stored. Only the extracted face feature(s) will be stored on server until "Delete Person
        Group Person Face", "Delete Person Group Person" or "Delete Person Group" is called.

        Note that persistedFaceId is different from faceId generated by "Detect".
        >
        *


        * Higher face image quality means better recognition precision. Please consider high-quality
        faces: frontal, clear, and face size is 200x200 pixels (100 pixels between eyes) or bigger.
        * Each person entry can hold up to 248 faces.
        * JPEG, PNG, GIF (the first frame), and BMP format are supported. The allowed image file size
        is from 1KB to 6MB.
        * "targetFace" rectangle should contain one face. Zero or multiple faces will be regarded as an
        error. If the provided "targetFace" rectangle is not returned from "Detect", there's no
        guarantee to detect and add the face successfully.
        * Out of detectable face size (36x36 - 4096x4096 pixels), large head-pose, or large occlusions
        will cause failures.
        * The minimum detectable face size is 36x36 pixels in an image no larger than 1920x1080 pixels.
        Images with dimensions higher than 1920x1080 pixels will need a proportionally larger minimum
        face size.
        * Different 'detectionModel' values can be provided. To use and compare different detection
        models, please refer to
        https://learn.microsoft.com/azure/ai-services/computer-vision/how-to/specify-detection-model.

        :param person_group_id: ID of the container. Required.
        :type person_group_id: str
        :param person_id: ID of the person. Required.
        :type person_id: str
        :keyword url: URL of input image. Required.
        :paramtype url: str
        :keyword target_face: A face rectangle to specify the target face to be added to a person, in
         the format of 'targetFace=left,top,width,height'. Default value is None.
        :paramtype target_face: list[int]
        :keyword detection_model: The 'detectionModel' associated with the detected faceIds. Supported
         'detectionModel' values include 'detection_01', 'detection_02' and 'detection_03'. The default
         value is 'detection_01'. Known values are: "detection_01", "detection_02", and "detection_03".
         Default value is None.
        :paramtype detection_model: str or ~azure.ai.vision.face.models.FaceDetectionModel
        :keyword user_data: User-provided data attached to the face. The size limit is 1K. Default
         value is None.
        :paramtype user_data: str
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: AddFaceResult. The AddFaceResult is compatible with MutableMapping
        :rtype: ~azure.ai.vision.face.models.AddFaceResult
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "persistedFaceId": "str"
                }
        """

    @overload
    def add_face_from_url(
        self,
        person_group_id: str,
        person_id: str,
        body: IO[bytes],
        *,
        target_face: Optional[List[int]] = None,
        detection_model: Optional[Union[str, _models.FaceDetectionModel]] = None,
        user_data: Optional[str] = None,
        content_type: str = "application/json",
        **kwargs: Any,
    ) -> _models.AddFaceResult:
        """Add a face to a person into a Person Group for face identification or verification.

        To deal with an image containing multiple faces, input face can be specified as an image with a
        targetFace rectangle. It returns a persistedFaceId representing the added face. No image will
        be stored. Only the extracted face feature(s) will be stored on server until "Delete Person
        Group Person Face", "Delete Person Group Person" or "Delete Person Group" is called.

        Note that persistedFaceId is different from faceId generated by "Detect".
        >
        *


        * Higher face image quality means better recognition precision. Please consider high-quality
        faces: frontal, clear, and face size is 200x200 pixels (100 pixels between eyes) or bigger.
        * Each person entry can hold up to 248 faces.
        * JPEG, PNG, GIF (the first frame), and BMP format are supported. The allowed image file size
        is from 1KB to 6MB.
        * "targetFace" rectangle should contain one face. Zero or multiple faces will be regarded as an
        error. If the provided "targetFace" rectangle is not returned from "Detect", there's no
        guarantee to detect and add the face successfully.
        * Out of detectable face size (36x36 - 4096x4096 pixels), large head-pose, or large occlusions
        will cause failures.
        * The minimum detectable face size is 36x36 pixels in an image no larger than 1920x1080 pixels.
        Images with dimensions higher than 1920x1080 pixels will need a proportionally larger minimum
        face size.
        * Different 'detectionModel' values can be provided. To use and compare different detection
        models, please refer to
        https://learn.microsoft.com/azure/ai-services/computer-vision/how-to/specify-detection-model.

        :param person_group_id: ID of the container. Required.
        :type person_group_id: str
        :param person_id: ID of the person. Required.
        :type person_id: str
        :param body: Required.
        :type body: IO[bytes]
        :keyword target_face: A face rectangle to specify the target face to be added to a person, in
         the format of 'targetFace=left,top,width,height'. Default value is None.
        :paramtype target_face: list[int]
        :keyword detection_model: The 'detectionModel' associated with the detected faceIds. Supported
         'detectionModel' values include 'detection_01', 'detection_02' and 'detection_03'. The default
         value is 'detection_01'. Known values are: "detection_01", "detection_02", and "detection_03".
         Default value is None.
        :paramtype detection_model: str or ~azure.ai.vision.face.models.FaceDetectionModel
        :keyword user_data: User-provided data attached to the face. The size limit is 1K. Default
         value is None.
        :paramtype user_data: str
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: AddFaceResult. The AddFaceResult is compatible with MutableMapping
        :rtype: ~azure.ai.vision.face.models.AddFaceResult
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "persistedFaceId": "str"
                }
        """

    @distributed_trace
    def add_face_from_url(
        self,
        person_group_id: str,
        person_id: str,
        body: Union[JSON, IO[bytes]] = _Unset,
        *,
        url: str = _Unset,
        target_face: Optional[List[int]] = None,
        detection_model: Optional[Union[str, _models.FaceDetectionModel]] = None,
        user_data: Optional[str] = None,
        **kwargs: Any,
    ) -> _models.AddFaceResult:
        """Add a face to a person into a Person Group for face identification or verification.

        To deal with an image containing multiple faces, input face can be specified as an image with a
        targetFace rectangle. It returns a persistedFaceId representing the added face. No image will
        be stored. Only the extracted face feature(s) will be stored on server until "Delete Person
        Group Person Face", "Delete Person Group Person" or "Delete Person Group" is called.

        Note that persistedFaceId is different from faceId generated by "Detect".
        >
        *


        * Higher face image quality means better recognition precision. Please consider high-quality
        faces: frontal, clear, and face size is 200x200 pixels (100 pixels between eyes) or bigger.
        * Each person entry can hold up to 248 faces.
        * JPEG, PNG, GIF (the first frame), and BMP format are supported. The allowed image file size
        is from 1KB to 6MB.
        * "targetFace" rectangle should contain one face. Zero or multiple faces will be regarded as an
        error. If the provided "targetFace" rectangle is not returned from "Detect", there's no
        guarantee to detect and add the face successfully.
        * Out of detectable face size (36x36 - 4096x4096 pixels), large head-pose, or large occlusions
        will cause failures.
        * The minimum detectable face size is 36x36 pixels in an image no larger than 1920x1080 pixels.
        Images with dimensions higher than 1920x1080 pixels will need a proportionally larger minimum
        face size.
        * Different 'detectionModel' values can be provided. To use and compare different detection
        models, please refer to
        https://learn.microsoft.com/azure/ai-services/computer-vision/how-to/specify-detection-model.

        :param person_group_id: ID of the container. Required.
        :type person_group_id: str
        :param person_id: ID of the person. Required.
        :type person_id: str
        :param body: Is either a JSON type or a IO[bytes] type. Required.
        :type body: JSON or IO[bytes]
        :keyword url: URL of input image. Required.
        :paramtype url: str
        :keyword target_face: A face rectangle to specify the target face to be added to a person, in
         the format of 'targetFace=left,top,width,height'. Default value is None.
        :paramtype target_face: list[int]
        :keyword detection_model: The 'detectionModel' associated with the detected faceIds. Supported
         'detectionModel' values include 'detection_01', 'detection_02' and 'detection_03'. The default
         value is 'detection_01'. Known values are: "detection_01", "detection_02", and "detection_03".
         Default value is None.
        :paramtype detection_model: str or ~azure.ai.vision.face.models.FaceDetectionModel
        :keyword user_data: User-provided data attached to the face. The size limit is 1K. Default
         value is None.
        :paramtype user_data: str
        :return: AddFaceResult. The AddFaceResult is compatible with MutableMapping
        :rtype: ~azure.ai.vision.face.models.AddFaceResult
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                body = {
                    "url": "str"
                }

                # response body for status code(s): 200
                response == {
                    "persistedFaceId": "str"
                }
        """
        error_map: MutableMapping[int, Type[HttpResponseError]] = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[_models.AddFaceResult] = kwargs.pop("cls", None)

        if body is _Unset:
            if url is _Unset:
                raise TypeError("missing required argument: url")
            body = {"url": url}
            body = {k: v for k, v in body.items() if v is not None}
        content_type = content_type or "application/json"
        _content = None
        if isinstance(body, (IOBase, bytes)):
            _content = body
        else:
            _content = json.dumps(body, cls=SdkJSONEncoder, exclude_readonly=True)  # type: ignore

        _request = build_person_groups_add_face_from_url_request(
            person_group_id=person_group_id,
            person_id=person_id,
            target_face=target_face,
            detection_model=detection_model,
            user_data=user_data,
            content_type=content_type,
            content=_content,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, "str", skip_quote=True),
            "apiVersion": self._serialize.url("self._config.api_version", self._config.api_version, "str"),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = kwargs.pop("stream", False)
        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                try:
                    response.read()  # Load the body in memory and close the socket
                except (StreamConsumedError, StreamClosedError):
                    pass
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = _deserialize(_models.FaceErrorResponse, response.json())
            raise HttpResponseError(response=response, model=error)

        if _stream:
            deserialized = response.iter_bytes()
        else:
            deserialized = _deserialize(_models.AddFaceResult, response.json())

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore

    @distributed_trace
    def add_face(
        self,
        person_group_id: str,
        person_id: str,
        image_content: bytes,
        *,
        target_face: Optional[List[int]] = None,
        detection_model: Optional[Union[str, _models.FaceDetectionModel]] = None,
        user_data: Optional[str] = None,
        **kwargs: Any,
    ) -> _models.AddFaceResult:
        """Add a face to a person into a Person Group for face identification or verification.

        To deal with an image containing multiple faces, input face can be specified as an image with a
        targetFace rectangle. It returns a persistedFaceId representing the added face. No image will
        be stored. Only the extracted face feature(s) will be stored on server until "Delete Person
        Group Person Face", "Delete Person Group Person" or "Delete Person Group" is called.

        Note that persistedFaceId is different from faceId generated by "Detect".
        >
        *


        * Higher face image quality means better recognition precision. Please consider high-quality
        faces: frontal, clear, and face size is 200x200 pixels (100 pixels between eyes) or bigger.
        * Each person entry can hold up to 248 faces.
        * JPEG, PNG, GIF (the first frame), and BMP format are supported. The allowed image file size
        is from 1KB to 6MB.
        * "targetFace" rectangle should contain one face. Zero or multiple faces will be regarded as an
        error. If the provided "targetFace" rectangle is not returned from "Detect", there's no
        guarantee to detect and add the face successfully.
        * Out of detectable face size (36x36 - 4096x4096 pixels), large head-pose, or large occlusions
        will cause failures.
        * The minimum detectable face size is 36x36 pixels in an image no larger than 1920x1080 pixels.
        Images with dimensions higher than 1920x1080 pixels will need a proportionally larger minimum
        face size.
        * Different 'detectionModel' values can be provided. To use and compare different detection
        models, please refer to
        https://learn.microsoft.com/azure/ai-services/computer-vision/how-to/specify-detection-model.

        :param person_group_id: ID of the container. Required.
        :type person_group_id: str
        :param person_id: ID of the person. Required.
        :type person_id: str
        :param image_content: The image to be analyzed. Required.
        :type image_content: bytes
        :keyword target_face: A face rectangle to specify the target face to be added to a person, in
         the format of 'targetFace=left,top,width,height'. Default value is None.
        :paramtype target_face: list[int]
        :keyword detection_model: The 'detectionModel' associated with the detected faceIds. Supported
         'detectionModel' values include 'detection_01', 'detection_02' and 'detection_03'. The default
         value is 'detection_01'. Known values are: "detection_01", "detection_02", and "detection_03".
         Default value is None.
        :paramtype detection_model: str or ~azure.ai.vision.face.models.FaceDetectionModel
        :keyword user_data: User-provided data attached to the face. The size limit is 1K. Default
         value is None.
        :paramtype user_data: str
        :return: AddFaceResult. The AddFaceResult is compatible with MutableMapping
        :rtype: ~azure.ai.vision.face.models.AddFaceResult
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "persistedFaceId": "str"
                }
        """
        error_map: MutableMapping[int, Type[HttpResponseError]] = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: str = kwargs.pop("content_type", _headers.pop("content-type", "application/octet-stream"))
        cls: ClsType[_models.AddFaceResult] = kwargs.pop("cls", None)

        _content = image_content

        _request = build_person_groups_add_face_request(
            person_group_id=person_group_id,
            person_id=person_id,
            target_face=target_face,
            detection_model=detection_model,
            user_data=user_data,
            content_type=content_type,
            content=_content,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, "str", skip_quote=True),
            "apiVersion": self._serialize.url("self._config.api_version", self._config.api_version, "str"),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = kwargs.pop("stream", False)
        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                try:
                    response.read()  # Load the body in memory and close the socket
                except (StreamConsumedError, StreamClosedError):
                    pass
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = _deserialize(_models.FaceErrorResponse, response.json())
            raise HttpResponseError(response=response, model=error)

        if _stream:
            deserialized = response.iter_bytes()
        else:
            deserialized = _deserialize(_models.AddFaceResult, response.json())

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore

    @distributed_trace
    def delete_face(  # pylint: disable=inconsistent-return-statements
        self, person_group_id: str, person_id: str, persisted_face_id: str, **kwargs: Any
    ) -> None:
        """Delete a face from a person in a Person Group by specified personGroupId, personId and
        persistedFaceId.

        Adding/deleting faces to/from a same person will be processed sequentially. Adding/deleting
        faces to/from different persons are processed in parallel.

        :param person_group_id: ID of the container. Required.
        :type person_group_id: str
        :param person_id: ID of the person. Required.
        :type person_id: str
        :param persisted_face_id: Face ID of the face. Required.
        :type persisted_face_id: str
        :return: None
        :rtype: None
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping[int, Type[HttpResponseError]] = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[None] = kwargs.pop("cls", None)

        _request = build_person_groups_delete_face_request(
            person_group_id=person_group_id,
            person_id=person_id,
            persisted_face_id=persisted_face_id,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, "str", skip_quote=True),
            "apiVersion": self._serialize.url("self._config.api_version", self._config.api_version, "str"),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = False
        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = _deserialize(_models.FaceErrorResponse, response.json())
            raise HttpResponseError(response=response, model=error)

        if cls:
            return cls(pipeline_response, None, {})  # type: ignore

    @distributed_trace
    def get_face(
        self, person_group_id: str, person_id: str, persisted_face_id: str, **kwargs: Any
    ) -> _models.PersonGroupPersonFace:
        """Retrieve person face information. The persisted person face is specified by its personGroupId,
        personId and persistedFaceId.

        :param person_group_id: ID of the container. Required.
        :type person_group_id: str
        :param person_id: ID of the person. Required.
        :type person_id: str
        :param persisted_face_id: Face ID of the face. Required.
        :type persisted_face_id: str
        :return: PersonGroupPersonFace. The PersonGroupPersonFace is compatible with MutableMapping
        :rtype: ~azure.ai.vision.face.models.PersonGroupPersonFace
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "persistedFaceId": "str",
                    "userData": "str"
                }
        """
        error_map: MutableMapping[int, Type[HttpResponseError]] = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[_models.PersonGroupPersonFace] = kwargs.pop("cls", None)

        _request = build_person_groups_get_face_request(
            person_group_id=person_group_id,
            person_id=person_id,
            persisted_face_id=persisted_face_id,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, "str", skip_quote=True),
            "apiVersion": self._serialize.url("self._config.api_version", self._config.api_version, "str"),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = kwargs.pop("stream", False)
        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                try:
                    response.read()  # Load the body in memory and close the socket
                except (StreamConsumedError, StreamClosedError):
                    pass
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = _deserialize(_models.FaceErrorResponse, response.json())
            raise HttpResponseError(response=response, model=error)

        if _stream:
            deserialized = response.iter_bytes()
        else:
            deserialized = _deserialize(_models.PersonGroupPersonFace, response.json())

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore

    @overload
    def update_face(  # pylint: disable=inconsistent-return-statements
        self,
        person_group_id: str,
        person_id: str,
        persisted_face_id: str,
        body: JSON,
        *,
        content_type: str = "application/json",
        **kwargs: Any,
    ) -> None:
        """Update a person persisted face's userData field.

        :param person_group_id: ID of the container. Required.
        :type person_group_id: str
        :param person_id: ID of the person. Required.
        :type person_id: str
        :param persisted_face_id: Face ID of the face. Required.
        :type persisted_face_id: str
        :param body: Required.
        :type body: JSON
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: None
        :rtype: None
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                body = {
                    "userData": "str"
                }
        """

    @overload
    def update_face(  # pylint: disable=inconsistent-return-statements
        self,
        person_group_id: str,
        person_id: str,
        persisted_face_id: str,
        *,
        content_type: str = "application/json",
        user_data: Optional[str] = None,
        **kwargs: Any,
    ) -> None:
        """Update a person persisted face's userData field.

        :param person_group_id: ID of the container. Required.
        :type person_group_id: str
        :param person_id: ID of the person. Required.
        :type person_id: str
        :param persisted_face_id: Face ID of the face. Required.
        :type persisted_face_id: str
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :keyword user_data: User-provided data attached to the face. The length limit is 1K. Default
         value is None.
        :paramtype user_data: str
        :return: None
        :rtype: None
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @overload
    def update_face(  # pylint: disable=inconsistent-return-statements
        self,
        person_group_id: str,
        person_id: str,
        persisted_face_id: str,
        body: IO[bytes],
        *,
        content_type: str = "application/json",
        **kwargs: Any,
    ) -> None:
        """Update a person persisted face's userData field.

        :param person_group_id: ID of the container. Required.
        :type person_group_id: str
        :param person_id: ID of the person. Required.
        :type person_id: str
        :param persisted_face_id: Face ID of the face. Required.
        :type persisted_face_id: str
        :param body: Required.
        :type body: IO[bytes]
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: None
        :rtype: None
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @distributed_trace
    def update_face(  # pylint: disable=inconsistent-return-statements
        self,
        person_group_id: str,
        person_id: str,
        persisted_face_id: str,
        body: Union[JSON, IO[bytes]] = _Unset,
        *,
        user_data: Optional[str] = None,
        **kwargs: Any,
    ) -> None:
        """Update a person persisted face's userData field.

        :param person_group_id: ID of the container. Required.
        :type person_group_id: str
        :param person_id: ID of the person. Required.
        :type person_id: str
        :param persisted_face_id: Face ID of the face. Required.
        :type persisted_face_id: str
        :param body: Is either a JSON type or a IO[bytes] type. Required.
        :type body: JSON or IO[bytes]
        :keyword user_data: User-provided data attached to the face. The length limit is 1K. Default
         value is None.
        :paramtype user_data: str
        :return: None
        :rtype: None
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                body = {
                    "userData": "str"
                }
        """
        error_map: MutableMapping[int, Type[HttpResponseError]] = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[None] = kwargs.pop("cls", None)

        if body is _Unset:
            body = {"userData": user_data}
            body = {k: v for k, v in body.items() if v is not None}
        content_type = content_type or "application/json"
        _content = None
        if isinstance(body, (IOBase, bytes)):
            _content = body
        else:
            _content = json.dumps(body, cls=SdkJSONEncoder, exclude_readonly=True)  # type: ignore

        _request = build_person_groups_update_face_request(
            person_group_id=person_group_id,
            person_id=person_id,
            persisted_face_id=persisted_face_id,
            content_type=content_type,
            content=_content,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, "str", skip_quote=True),
            "apiVersion": self._serialize.url("self._config.api_version", self._config.api_version, "str"),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = False
        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = _deserialize(_models.FaceErrorResponse, response.json())
            raise HttpResponseError(response=response, model=error)

        if cls:
            return cls(pipeline_response, None, {})  # type: ignore


class LargePersonGroupsOperations:
    """
    .. warning::
        **DO NOT** instantiate this class directly.

        Instead, you should access the following operations through
        :class:`~azure.ai.vision.face.FaceServiceClient`'s
        :attr:`large_person_groups` attribute.
    """

    def __init__(self, *args, **kwargs):
        input_args = list(args)
        self._client = input_args.pop(0) if input_args else kwargs.pop("client")
        self._config = input_args.pop(0) if input_args else kwargs.pop("config")
        self._serialize = input_args.pop(0) if input_args else kwargs.pop("serializer")
        self._deserialize = input_args.pop(0) if input_args else kwargs.pop("deserializer")

    @overload
    def create(  # pylint: disable=inconsistent-return-statements
        self, large_person_group_id: str, body: JSON, *, content_type: str = "application/json", **kwargs: Any
    ) -> None:
        """Create a new Large Person Group with user-specified largePersonGroupId, name, an optional
        userData and recognitionModel.

        A Large Person Group is a container holding the uploaded person data, including the face
        recognition features. It can hold up to 1,000,000 entities.

        After creation, use "Create Large Person Group Person" to add person into the group, and call
        "Train Large Person Group" to get this group ready for "Identify From Large Person Group".

        No image will be stored. Only the person's extracted face feature(s) and userData will be
        stored on server until "Delete Large Person Group Person" or "Delete Large Person Group" is
        called.

        'recognitionModel' should be specified to associate with this Large Person Group. The default
        value for 'recognitionModel' is 'recognition_01', if the latest model needed, please explicitly
        specify the model you need in this parameter. New faces that are added to an existing Large
        Person Group will use the recognition model that's already associated with the collection.
        Existing face feature(s) in a Large Person Group can't be updated to features extracted by
        another version of recognition model.

        ..

           [!NOTE]

           *


           * Free-tier subscription quota: 1,000 Large Person Groups.
           * S0-tier subscription quota: 1,000,000 Large Person Groups.

        :param large_person_group_id: ID of the container. Required.
        :type large_person_group_id: str
        :param body: Required.
        :type body: JSON
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: None
        :rtype: None
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                body = {
                    "name": "str",
                    "recognitionModel": "str",
                    "userData": "str"
                }
        """

    @overload
    def create(  # pylint: disable=inconsistent-return-statements
        self,
        large_person_group_id: str,
        *,
        name: str,
        content_type: str = "application/json",
        user_data: Optional[str] = None,
        recognition_model: Optional[Union[str, _models.FaceRecognitionModel]] = None,
        **kwargs: Any,
    ) -> None:
        """Create a new Large Person Group with user-specified largePersonGroupId, name, an optional
        userData and recognitionModel.

        A Large Person Group is a container holding the uploaded person data, including the face
        recognition features. It can hold up to 1,000,000 entities.

        After creation, use "Create Large Person Group Person" to add person into the group, and call
        "Train Large Person Group" to get this group ready for "Identify From Large Person Group".

        No image will be stored. Only the person's extracted face feature(s) and userData will be
        stored on server until "Delete Large Person Group Person" or "Delete Large Person Group" is
        called.

        'recognitionModel' should be specified to associate with this Large Person Group. The default
        value for 'recognitionModel' is 'recognition_01', if the latest model needed, please explicitly
        specify the model you need in this parameter. New faces that are added to an existing Large
        Person Group will use the recognition model that's already associated with the collection.
        Existing face feature(s) in a Large Person Group can't be updated to features extracted by
        another version of recognition model.

        ..

           [!NOTE]

           *


           * Free-tier subscription quota: 1,000 Large Person Groups.
           * S0-tier subscription quota: 1,000,000 Large Person Groups.

        :param large_person_group_id: ID of the container. Required.
        :type large_person_group_id: str
        :keyword name: User defined name, maximum length is 128. Required.
        :paramtype name: str
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :keyword user_data: Optional user defined data. Length should not exceed 16K. Default value is
         None.
        :paramtype user_data: str
        :keyword recognition_model: The 'recognitionModel' associated with this face list. Supported
         'recognitionModel' values include 'recognition_01', 'recognition_02, 'recognition_03', and
         'recognition_04'. The default value is 'recognition_01'. 'recognition_04' is recommended since
         its accuracy is improved on faces wearing masks compared with 'recognition_03', and its overall
         accuracy is improved compared with 'recognition_01' and 'recognition_02'. Known values are:
         "recognition_01", "recognition_02", "recognition_03", and "recognition_04". Default value is
         None.
        :paramtype recognition_model: str or ~azure.ai.vision.face.models.FaceRecognitionModel
        :return: None
        :rtype: None
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @overload
    def create(  # pylint: disable=inconsistent-return-statements
        self, large_person_group_id: str, body: IO[bytes], *, content_type: str = "application/json", **kwargs: Any
    ) -> None:
        """Create a new Large Person Group with user-specified largePersonGroupId, name, an optional
        userData and recognitionModel.

        A Large Person Group is a container holding the uploaded person data, including the face
        recognition features. It can hold up to 1,000,000 entities.

        After creation, use "Create Large Person Group Person" to add person into the group, and call
        "Train Large Person Group" to get this group ready for "Identify From Large Person Group".

        No image will be stored. Only the person's extracted face feature(s) and userData will be
        stored on server until "Delete Large Person Group Person" or "Delete Large Person Group" is
        called.

        'recognitionModel' should be specified to associate with this Large Person Group. The default
        value for 'recognitionModel' is 'recognition_01', if the latest model needed, please explicitly
        specify the model you need in this parameter. New faces that are added to an existing Large
        Person Group will use the recognition model that's already associated with the collection.
        Existing face feature(s) in a Large Person Group can't be updated to features extracted by
        another version of recognition model.

        ..

           [!NOTE]

           *


           * Free-tier subscription quota: 1,000 Large Person Groups.
           * S0-tier subscription quota: 1,000,000 Large Person Groups.

        :param large_person_group_id: ID of the container. Required.
        :type large_person_group_id: str
        :param body: Required.
        :type body: IO[bytes]
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: None
        :rtype: None
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @distributed_trace
    def create(  # pylint: disable=inconsistent-return-statements
        self,
        large_person_group_id: str,
        body: Union[JSON, IO[bytes]] = _Unset,
        *,
        name: str = _Unset,
        user_data: Optional[str] = None,
        recognition_model: Optional[Union[str, _models.FaceRecognitionModel]] = None,
        **kwargs: Any,
    ) -> None:
        """Create a new Large Person Group with user-specified largePersonGroupId, name, an optional
        userData and recognitionModel.

        A Large Person Group is a container holding the uploaded person data, including the face
        recognition features. It can hold up to 1,000,000 entities.

        After creation, use "Create Large Person Group Person" to add person into the group, and call
        "Train Large Person Group" to get this group ready for "Identify From Large Person Group".

        No image will be stored. Only the person's extracted face feature(s) and userData will be
        stored on server until "Delete Large Person Group Person" or "Delete Large Person Group" is
        called.

        'recognitionModel' should be specified to associate with this Large Person Group. The default
        value for 'recognitionModel' is 'recognition_01', if the latest model needed, please explicitly
        specify the model you need in this parameter. New faces that are added to an existing Large
        Person Group will use the recognition model that's already associated with the collection.
        Existing face feature(s) in a Large Person Group can't be updated to features extracted by
        another version of recognition model.

        ..

           [!NOTE]

           *


           * Free-tier subscription quota: 1,000 Large Person Groups.
           * S0-tier subscription quota: 1,000,000 Large Person Groups.

        :param large_person_group_id: ID of the container. Required.
        :type large_person_group_id: str
        :param body: Is either a JSON type or a IO[bytes] type. Required.
        :type body: JSON or IO[bytes]
        :keyword name: User defined name, maximum length is 128. Required.
        :paramtype name: str
        :keyword user_data: Optional user defined data. Length should not exceed 16K. Default value is
         None.
        :paramtype user_data: str
        :keyword recognition_model: The 'recognitionModel' associated with this face list. Supported
         'recognitionModel' values include 'recognition_01', 'recognition_02, 'recognition_03', and
         'recognition_04'. The default value is 'recognition_01'. 'recognition_04' is recommended since
         its accuracy is improved on faces wearing masks compared with 'recognition_03', and its overall
         accuracy is improved compared with 'recognition_01' and 'recognition_02'. Known values are:
         "recognition_01", "recognition_02", "recognition_03", and "recognition_04". Default value is
         None.
        :paramtype recognition_model: str or ~azure.ai.vision.face.models.FaceRecognitionModel
        :return: None
        :rtype: None
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                body = {
                    "name": "str",
                    "recognitionModel": "str",
                    "userData": "str"
                }
        """
        error_map: MutableMapping[int, Type[HttpResponseError]] = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[None] = kwargs.pop("cls", None)

        if body is _Unset:
            if name is _Unset:
                raise TypeError("missing required argument: name")
            body = {"name": name, "recognitionModel": recognition_model, "userData": user_data}
            body = {k: v for k, v in body.items() if v is not None}
        content_type = content_type or "application/json"
        _content = None
        if isinstance(body, (IOBase, bytes)):
            _content = body
        else:
            _content = json.dumps(body, cls=SdkJSONEncoder, exclude_readonly=True)  # type: ignore

        _request = build_large_person_groups_create_request(
            large_person_group_id=large_person_group_id,
            content_type=content_type,
            content=_content,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, "str", skip_quote=True),
            "apiVersion": self._serialize.url("self._config.api_version", self._config.api_version, "str"),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = False
        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = _deserialize(_models.FaceErrorResponse, response.json())
            raise HttpResponseError(response=response, model=error)

        if cls:
            return cls(pipeline_response, None, {})  # type: ignore

    @distributed_trace
    def delete(  # pylint: disable=inconsistent-return-statements
        self, large_person_group_id: str, **kwargs: Any
    ) -> None:
        """Delete an existing Large Person Group with specified personGroupId. Persisted data in this
        Large Person Group will be deleted.

        :param large_person_group_id: ID of the container. Required.
        :type large_person_group_id: str
        :return: None
        :rtype: None
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping[int, Type[HttpResponseError]] = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[None] = kwargs.pop("cls", None)

        _request = build_large_person_groups_delete_request(
            large_person_group_id=large_person_group_id,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, "str", skip_quote=True),
            "apiVersion": self._serialize.url("self._config.api_version", self._config.api_version, "str"),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = False
        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = _deserialize(_models.FaceErrorResponse, response.json())
            raise HttpResponseError(response=response, model=error)

        if cls:
            return cls(pipeline_response, None, {})  # type: ignore

    @distributed_trace
    def get(
        self, large_person_group_id: str, *, return_recognition_model: Optional[bool] = None, **kwargs: Any
    ) -> _models.LargePersonGroup:
        """Retrieve the information of a Large Person Group, including its name, userData and
        recognitionModel. This API returns Large Person Group information only, use "Get Large Person
        Group Persons" instead to retrieve person information under the Large Person Group.

        :param large_person_group_id: ID of the container. Required.
        :type large_person_group_id: str
        :keyword return_recognition_model: Return 'recognitionModel' or not. The default value is
         false. Default value is None.
        :paramtype return_recognition_model: bool
        :return: LargePersonGroup. The LargePersonGroup is compatible with MutableMapping
        :rtype: ~azure.ai.vision.face.models.LargePersonGroup
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "largePersonGroupId": "str",
                    "name": "str",
                    "recognitionModel": "str",
                    "userData": "str"
                }
        """
        error_map: MutableMapping[int, Type[HttpResponseError]] = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[_models.LargePersonGroup] = kwargs.pop("cls", None)

        _request = build_large_person_groups_get_request(
            large_person_group_id=large_person_group_id,
            return_recognition_model=return_recognition_model,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, "str", skip_quote=True),
            "apiVersion": self._serialize.url("self._config.api_version", self._config.api_version, "str"),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = kwargs.pop("stream", False)
        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                try:
                    response.read()  # Load the body in memory and close the socket
                except (StreamConsumedError, StreamClosedError):
                    pass
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = _deserialize(_models.FaceErrorResponse, response.json())
            raise HttpResponseError(response=response, model=error)

        if _stream:
            deserialized = response.iter_bytes()
        else:
            deserialized = _deserialize(_models.LargePersonGroup, response.json())

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore

    @overload
    def update(  # pylint: disable=inconsistent-return-statements
        self, large_person_group_id: str, body: JSON, *, content_type: str = "application/json", **kwargs: Any
    ) -> None:
        """Update an existing Large Person Group's name and userData. The properties keep unchanged if
        they are not in request body.

        :param large_person_group_id: ID of the container. Required.
        :type large_person_group_id: str
        :param body: Required.
        :type body: JSON
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: None
        :rtype: None
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                body = {
                    "name": "str",
                    "userData": "str"
                }
        """

    @overload
    def update(  # pylint: disable=inconsistent-return-statements
        self,
        large_person_group_id: str,
        *,
        content_type: str = "application/json",
        name: Optional[str] = None,
        user_data: Optional[str] = None,
        **kwargs: Any,
    ) -> None:
        """Update an existing Large Person Group's name and userData. The properties keep unchanged if
        they are not in request body.

        :param large_person_group_id: ID of the container. Required.
        :type large_person_group_id: str
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :keyword name: User defined name, maximum length is 128. Default value is None.
        :paramtype name: str
        :keyword user_data: Optional user defined data. Length should not exceed 16K. Default value is
         None.
        :paramtype user_data: str
        :return: None
        :rtype: None
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @overload
    def update(  # pylint: disable=inconsistent-return-statements
        self, large_person_group_id: str, body: IO[bytes], *, content_type: str = "application/json", **kwargs: Any
    ) -> None:
        """Update an existing Large Person Group's name and userData. The properties keep unchanged if
        they are not in request body.

        :param large_person_group_id: ID of the container. Required.
        :type large_person_group_id: str
        :param body: Required.
        :type body: IO[bytes]
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: None
        :rtype: None
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @distributed_trace
    def update(  # pylint: disable=inconsistent-return-statements
        self,
        large_person_group_id: str,
        body: Union[JSON, IO[bytes]] = _Unset,
        *,
        name: Optional[str] = None,
        user_data: Optional[str] = None,
        **kwargs: Any,
    ) -> None:
        """Update an existing Large Person Group's name and userData. The properties keep unchanged if
        they are not in request body.

        :param large_person_group_id: ID of the container. Required.
        :type large_person_group_id: str
        :param body: Is either a JSON type or a IO[bytes] type. Required.
        :type body: JSON or IO[bytes]
        :keyword name: User defined name, maximum length is 128. Default value is None.
        :paramtype name: str
        :keyword user_data: Optional user defined data. Length should not exceed 16K. Default value is
         None.
        :paramtype user_data: str
        :return: None
        :rtype: None
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                body = {
                    "name": "str",
                    "userData": "str"
                }
        """
        error_map: MutableMapping[int, Type[HttpResponseError]] = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[None] = kwargs.pop("cls", None)

        if body is _Unset:
            body = {"name": name, "userData": user_data}
            body = {k: v for k, v in body.items() if v is not None}
        content_type = content_type or "application/json"
        _content = None
        if isinstance(body, (IOBase, bytes)):
            _content = body
        else:
            _content = json.dumps(body, cls=SdkJSONEncoder, exclude_readonly=True)  # type: ignore

        _request = build_large_person_groups_update_request(
            large_person_group_id=large_person_group_id,
            content_type=content_type,
            content=_content,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, "str", skip_quote=True),
            "apiVersion": self._serialize.url("self._config.api_version", self._config.api_version, "str"),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = False
        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = _deserialize(_models.FaceErrorResponse, response.json())
            raise HttpResponseError(response=response, model=error)

        if cls:
            return cls(pipeline_response, None, {})  # type: ignore

    @distributed_trace
    def get_large_person_groups(
        self,
        *,
        start: Optional[str] = None,
        top: Optional[int] = None,
        return_recognition_model: Optional[bool] = None,
        **kwargs: Any,
    ) -> List[_models.LargePersonGroup]:
        """List all existing Large Person Groups' largePersonGroupId, name, userData and recognitionModel.

        Large Person Groups are stored in alphabetical order of largePersonGroupId.
        >
        *


        * "start" parameter (string, optional) specifies an ID value from which returned entries will
        have larger IDs based on string comparison. Setting "start" to an empty value indicates that
        entries should be returned starting from the first item.
        * "top" parameter (int, optional) determines the maximum number of entries to be returned, with
        a limit of up to 1000 entries per call. To retrieve additional entries beyond this limit,
        specify "start" with the personId of the last entry returned in the current call.

        ..

           [!TIP]


           * For example, there are total 5 items with their IDs: "itemId1", ..., "itemId5".

             * "start=&top=" will return all 5 items.
             * "start=&top=2" will return "itemId1", "itemId2".
             * "start=itemId2&top=3" will return "itemId3", "itemId4", "itemId5".

        :keyword start: List resources greater than the "start". It contains no more than 64
         characters. Default is empty. Default value is None.
        :paramtype start: str
        :keyword top: The number of items to list, ranging in [1, 1000]. Default is 1000. Default value
         is None.
        :paramtype top: int
        :keyword return_recognition_model: Return 'recognitionModel' or not. The default value is
         false. Default value is None.
        :paramtype return_recognition_model: bool
        :return: list of LargePersonGroup
        :rtype: list[~azure.ai.vision.face.models.LargePersonGroup]
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == [
                    {
                        "largePersonGroupId": "str",
                        "name": "str",
                        "recognitionModel": "str",
                        "userData": "str"
                    }
                ]
        """
        error_map: MutableMapping[int, Type[HttpResponseError]] = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[List[_models.LargePersonGroup]] = kwargs.pop("cls", None)

        _request = build_large_person_groups_get_large_person_groups_request(
            start=start,
            top=top,
            return_recognition_model=return_recognition_model,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, "str", skip_quote=True),
            "apiVersion": self._serialize.url("self._config.api_version", self._config.api_version, "str"),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = kwargs.pop("stream", False)
        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                try:
                    response.read()  # Load the body in memory and close the socket
                except (StreamConsumedError, StreamClosedError):
                    pass
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = _deserialize(_models.FaceErrorResponse, response.json())
            raise HttpResponseError(response=response, model=error)

        if _stream:
            deserialized = response.iter_bytes()
        else:
            deserialized = _deserialize(List[_models.LargePersonGroup], response.json())

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore

    @distributed_trace
    def get_training_status(self, large_person_group_id: str, **kwargs: Any) -> _models.TrainingResult:
        """To check Large Person Group training status completed or still ongoing. Large Person Group
        training is an asynchronous operation triggered by "Train Large Person Group" API.

        Training time depends on the number of person entries, and their faces in a Large Person Group.
        It could be in seconds, or up to half an hour for 1,000,000 persons.

        :param large_person_group_id: ID of the container. Required.
        :type large_person_group_id: str
        :return: TrainingResult. The TrainingResult is compatible with MutableMapping
        :rtype: ~azure.ai.vision.face.models.TrainingResult
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "createdDateTime": "2020-02-20 00:00:00",
                    "lastActionDateTime": "2020-02-20 00:00:00",
                    "lastSuccessfulTrainingDateTime": "2020-02-20 00:00:00",
                    "status": "str",
                    "message": "str"
                }
        """
        error_map: MutableMapping[int, Type[HttpResponseError]] = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[_models.TrainingResult] = kwargs.pop("cls", None)

        _request = build_large_person_groups_get_training_status_request(
            large_person_group_id=large_person_group_id,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, "str", skip_quote=True),
            "apiVersion": self._serialize.url("self._config.api_version", self._config.api_version, "str"),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = kwargs.pop("stream", False)
        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                try:
                    response.read()  # Load the body in memory and close the socket
                except (StreamConsumedError, StreamClosedError):
                    pass
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = _deserialize(_models.FaceErrorResponse, response.json())
            raise HttpResponseError(response=response, model=error)

        if _stream:
            deserialized = response.iter_bytes()
        else:
            deserialized = _deserialize(_models.TrainingResult, response.json())

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore

    def _train_initial(self, large_person_group_id: str, **kwargs: Any) -> Iterator[bytes]:
        error_map: MutableMapping[int, Type[HttpResponseError]] = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[Iterator[bytes]] = kwargs.pop("cls", None)

        _request = build_large_person_groups_train_request(
            large_person_group_id=large_person_group_id,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, "str", skip_quote=True),
            "apiVersion": self._serialize.url("self._config.api_version", self._config.api_version, "str"),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = True
        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [202]:
            try:
                response.read()  # Load the body in memory and close the socket
            except (StreamConsumedError, StreamClosedError):
                pass
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = _deserialize(_models.FaceErrorResponse, response.json())
            raise HttpResponseError(response=response, model=error)

        response_headers = {}
        response_headers["operation-Location"] = self._deserialize("str", response.headers.get("operation-Location"))

        deserialized = response.iter_bytes()

        if cls:
            return cls(pipeline_response, deserialized, response_headers)  # type: ignore

        return deserialized  # type: ignore

    @distributed_trace
    def begin_train(self, large_person_group_id: str, **kwargs: Any) -> LROPoller[None]:
        """Submit a Large Person Group training task. Training is a crucial step that only a trained Large
        Person Group can be used by "Identify From Large Person Group".

        The training task is an asynchronous task. Training time depends on the number of person
        entries, and their faces in a Large Person Group. It could be in several seconds, or up to half
        a hour for 1,000,000 persons. To check training status, please use "Get Large Person Group
        Training Status".

        :param large_person_group_id: ID of the container. Required.
        :type large_person_group_id: str
        :return: An instance of LROPoller that returns None
        :rtype: ~azure.core.polling.LROPoller[None]
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[None] = kwargs.pop("cls", None)
        polling: Union[bool, PollingMethod] = kwargs.pop("polling", True)
        lro_delay = kwargs.pop("polling_interval", self._config.polling_interval)
        cont_token: Optional[str] = kwargs.pop("continuation_token", None)
        if cont_token is None:
            raw_result = self._train_initial(
                large_person_group_id=large_person_group_id,
                cls=lambda x, y, z: x,
                headers=_headers,
                params=_params,
                **kwargs,
            )
            raw_result.http_response.read()  # type: ignore
        kwargs.pop("error_map", None)

        def get_long_running_output(pipeline_response):  # pylint: disable=inconsistent-return-statements
            if cls:
                return cls(pipeline_response, None, {})  # type: ignore

        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, "str", skip_quote=True),
            "apiVersion": self._serialize.url("self._config.api_version", self._config.api_version, "str"),
        }

        if polling is True:
            polling_method: PollingMethod = cast(
                PollingMethod, LROBasePolling(lro_delay, path_format_arguments=path_format_arguments, **kwargs)
            )
        elif polling is False:
            polling_method = cast(PollingMethod, NoPolling())
        else:
            polling_method = polling
        if cont_token:
            return LROPoller[None].from_continuation_token(
                polling_method=polling_method,
                continuation_token=cont_token,
                client=self._client,
                deserialization_callback=get_long_running_output,
            )
        return LROPoller[None](self._client, raw_result, get_long_running_output, polling_method)  # type: ignore

    @overload
    def create_person(
        self, large_person_group_id: str, body: JSON, *, content_type: str = "application/json", **kwargs: Any
    ) -> _models.CreatePersonResult:
        """Create a new person in a specified Large Person Group. To add face to this person, please call
        "Add Large Person Group Person Face".

        ..

           [!NOTE]

           *


           * Free-tier subscription quota:

             * 1,000 persons in all Large Person Groups.

           * S0-tier subscription quota:

             * 1,000,000 persons per Large Person Group.
             * 1,000,000 Large Person Groups.
             * 1,000,000,000 persons in all Large Person Groups.

        :param large_person_group_id: ID of the container. Required.
        :type large_person_group_id: str
        :param body: Required.
        :type body: JSON
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: CreatePersonResult. The CreatePersonResult is compatible with MutableMapping
        :rtype: ~azure.ai.vision.face.models.CreatePersonResult
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                body = {
                    "name": "str",
                    "userData": "str"
                }

                # response body for status code(s): 200
                response == {
                    "personId": "str"
                }
        """

    @overload
    def create_person(
        self,
        large_person_group_id: str,
        *,
        name: str,
        content_type: str = "application/json",
        user_data: Optional[str] = None,
        **kwargs: Any,
    ) -> _models.CreatePersonResult:
        """Create a new person in a specified Large Person Group. To add face to this person, please call
        "Add Large Person Group Person Face".

        ..

           [!NOTE]

           *


           * Free-tier subscription quota:

             * 1,000 persons in all Large Person Groups.

           * S0-tier subscription quota:

             * 1,000,000 persons per Large Person Group.
             * 1,000,000 Large Person Groups.
             * 1,000,000,000 persons in all Large Person Groups.

        :param large_person_group_id: ID of the container. Required.
        :type large_person_group_id: str
        :keyword name: User defined name, maximum length is 128. Required.
        :paramtype name: str
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :keyword user_data: Optional user defined data. Length should not exceed 16K. Default value is
         None.
        :paramtype user_data: str
        :return: CreatePersonResult. The CreatePersonResult is compatible with MutableMapping
        :rtype: ~azure.ai.vision.face.models.CreatePersonResult
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "personId": "str"
                }
        """

    @overload
    def create_person(
        self, large_person_group_id: str, body: IO[bytes], *, content_type: str = "application/json", **kwargs: Any
    ) -> _models.CreatePersonResult:
        """Create a new person in a specified Large Person Group. To add face to this person, please call
        "Add Large Person Group Person Face".

        ..

           [!NOTE]

           *


           * Free-tier subscription quota:

             * 1,000 persons in all Large Person Groups.

           * S0-tier subscription quota:

             * 1,000,000 persons per Large Person Group.
             * 1,000,000 Large Person Groups.
             * 1,000,000,000 persons in all Large Person Groups.

        :param large_person_group_id: ID of the container. Required.
        :type large_person_group_id: str
        :param body: Required.
        :type body: IO[bytes]
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: CreatePersonResult. The CreatePersonResult is compatible with MutableMapping
        :rtype: ~azure.ai.vision.face.models.CreatePersonResult
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "personId": "str"
                }
        """

    @distributed_trace
    def create_person(
        self,
        large_person_group_id: str,
        body: Union[JSON, IO[bytes]] = _Unset,
        *,
        name: str = _Unset,
        user_data: Optional[str] = None,
        **kwargs: Any,
    ) -> _models.CreatePersonResult:
        """Create a new person in a specified Large Person Group. To add face to this person, please call
        "Add Large Person Group Person Face".

        ..

           [!NOTE]

           *


           * Free-tier subscription quota:

             * 1,000 persons in all Large Person Groups.

           * S0-tier subscription quota:

             * 1,000,000 persons per Large Person Group.
             * 1,000,000 Large Person Groups.
             * 1,000,000,000 persons in all Large Person Groups.

        :param large_person_group_id: ID of the container. Required.
        :type large_person_group_id: str
        :param body: Is either a JSON type or a IO[bytes] type. Required.
        :type body: JSON or IO[bytes]
        :keyword name: User defined name, maximum length is 128. Required.
        :paramtype name: str
        :keyword user_data: Optional user defined data. Length should not exceed 16K. Default value is
         None.
        :paramtype user_data: str
        :return: CreatePersonResult. The CreatePersonResult is compatible with MutableMapping
        :rtype: ~azure.ai.vision.face.models.CreatePersonResult
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                body = {
                    "name": "str",
                    "userData": "str"
                }

                # response body for status code(s): 200
                response == {
                    "personId": "str"
                }
        """
        error_map: MutableMapping[int, Type[HttpResponseError]] = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[_models.CreatePersonResult] = kwargs.pop("cls", None)

        if body is _Unset:
            if name is _Unset:
                raise TypeError("missing required argument: name")
            body = {"name": name, "userData": user_data}
            body = {k: v for k, v in body.items() if v is not None}
        content_type = content_type or "application/json"
        _content = None
        if isinstance(body, (IOBase, bytes)):
            _content = body
        else:
            _content = json.dumps(body, cls=SdkJSONEncoder, exclude_readonly=True)  # type: ignore

        _request = build_large_person_groups_create_person_request(
            large_person_group_id=large_person_group_id,
            content_type=content_type,
            content=_content,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, "str", skip_quote=True),
            "apiVersion": self._serialize.url("self._config.api_version", self._config.api_version, "str"),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = kwargs.pop("stream", False)
        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                try:
                    response.read()  # Load the body in memory and close the socket
                except (StreamConsumedError, StreamClosedError):
                    pass
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = _deserialize(_models.FaceErrorResponse, response.json())
            raise HttpResponseError(response=response, model=error)

        if _stream:
            deserialized = response.iter_bytes()
        else:
            deserialized = _deserialize(_models.CreatePersonResult, response.json())

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore

    @distributed_trace
    def delete_person(  # pylint: disable=inconsistent-return-statements
        self, large_person_group_id: str, person_id: str, **kwargs: Any
    ) -> None:
        """Delete an existing person from a Large Person Group. The persistedFaceId, userData, person name
        and face feature(s) in the person entry will all be deleted.

        :param large_person_group_id: ID of the container. Required.
        :type large_person_group_id: str
        :param person_id: ID of the person. Required.
        :type person_id: str
        :return: None
        :rtype: None
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping[int, Type[HttpResponseError]] = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[None] = kwargs.pop("cls", None)

        _request = build_large_person_groups_delete_person_request(
            large_person_group_id=large_person_group_id,
            person_id=person_id,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, "str", skip_quote=True),
            "apiVersion": self._serialize.url("self._config.api_version", self._config.api_version, "str"),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = False
        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = _deserialize(_models.FaceErrorResponse, response.json())
            raise HttpResponseError(response=response, model=error)

        if cls:
            return cls(pipeline_response, None, {})  # type: ignore

    @distributed_trace
    def get_person(self, large_person_group_id: str, person_id: str, **kwargs: Any) -> _models.LargePersonGroupPerson:
        """Retrieve a person's name and userData, and the persisted faceIds representing the registered
        person face feature(s).

        :param large_person_group_id: ID of the container. Required.
        :type large_person_group_id: str
        :param person_id: ID of the person. Required.
        :type person_id: str
        :return: LargePersonGroupPerson. The LargePersonGroupPerson is compatible with MutableMapping
        :rtype: ~azure.ai.vision.face.models.LargePersonGroupPerson
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "name": "str",
                    "personId": "str",
                    "persistedFaceIds": [
                        "str"
                    ],
                    "userData": "str"
                }
        """
        error_map: MutableMapping[int, Type[HttpResponseError]] = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[_models.LargePersonGroupPerson] = kwargs.pop("cls", None)

        _request = build_large_person_groups_get_person_request(
            large_person_group_id=large_person_group_id,
            person_id=person_id,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, "str", skip_quote=True),
            "apiVersion": self._serialize.url("self._config.api_version", self._config.api_version, "str"),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = kwargs.pop("stream", False)
        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                try:
                    response.read()  # Load the body in memory and close the socket
                except (StreamConsumedError, StreamClosedError):
                    pass
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = _deserialize(_models.FaceErrorResponse, response.json())
            raise HttpResponseError(response=response, model=error)

        if _stream:
            deserialized = response.iter_bytes()
        else:
            deserialized = _deserialize(_models.LargePersonGroupPerson, response.json())

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore

    @overload
    def update_person(  # pylint: disable=inconsistent-return-statements
        self,
        large_person_group_id: str,
        person_id: str,
        body: JSON,
        *,
        content_type: str = "application/json",
        **kwargs: Any,
    ) -> None:
        """Update name or userData of a person.

        :param large_person_group_id: ID of the container. Required.
        :type large_person_group_id: str
        :param person_id: ID of the person. Required.
        :type person_id: str
        :param body: Required.
        :type body: JSON
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: None
        :rtype: None
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                body = {
                    "name": "str",
                    "userData": "str"
                }
        """

    @overload
    def update_person(  # pylint: disable=inconsistent-return-statements
        self,
        large_person_group_id: str,
        person_id: str,
        *,
        content_type: str = "application/json",
        name: Optional[str] = None,
        user_data: Optional[str] = None,
        **kwargs: Any,
    ) -> None:
        """Update name or userData of a person.

        :param large_person_group_id: ID of the container. Required.
        :type large_person_group_id: str
        :param person_id: ID of the person. Required.
        :type person_id: str
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :keyword name: User defined name, maximum length is 128. Default value is None.
        :paramtype name: str
        :keyword user_data: Optional user defined data. Length should not exceed 16K. Default value is
         None.
        :paramtype user_data: str
        :return: None
        :rtype: None
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @overload
    def update_person(  # pylint: disable=inconsistent-return-statements
        self,
        large_person_group_id: str,
        person_id: str,
        body: IO[bytes],
        *,
        content_type: str = "application/json",
        **kwargs: Any,
    ) -> None:
        """Update name or userData of a person.

        :param large_person_group_id: ID of the container. Required.
        :type large_person_group_id: str
        :param person_id: ID of the person. Required.
        :type person_id: str
        :param body: Required.
        :type body: IO[bytes]
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: None
        :rtype: None
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @distributed_trace
    def update_person(  # pylint: disable=inconsistent-return-statements
        self,
        large_person_group_id: str,
        person_id: str,
        body: Union[JSON, IO[bytes]] = _Unset,
        *,
        name: Optional[str] = None,
        user_data: Optional[str] = None,
        **kwargs: Any,
    ) -> None:
        """Update name or userData of a person.

        :param large_person_group_id: ID of the container. Required.
        :type large_person_group_id: str
        :param person_id: ID of the person. Required.
        :type person_id: str
        :param body: Is either a JSON type or a IO[bytes] type. Required.
        :type body: JSON or IO[bytes]
        :keyword name: User defined name, maximum length is 128. Default value is None.
        :paramtype name: str
        :keyword user_data: Optional user defined data. Length should not exceed 16K. Default value is
         None.
        :paramtype user_data: str
        :return: None
        :rtype: None
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                body = {
                    "name": "str",
                    "userData": "str"
                }
        """
        error_map: MutableMapping[int, Type[HttpResponseError]] = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[None] = kwargs.pop("cls", None)

        if body is _Unset:
            body = {"name": name, "userData": user_data}
            body = {k: v for k, v in body.items() if v is not None}
        content_type = content_type or "application/json"
        _content = None
        if isinstance(body, (IOBase, bytes)):
            _content = body
        else:
            _content = json.dumps(body, cls=SdkJSONEncoder, exclude_readonly=True)  # type: ignore

        _request = build_large_person_groups_update_person_request(
            large_person_group_id=large_person_group_id,
            person_id=person_id,
            content_type=content_type,
            content=_content,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, "str", skip_quote=True),
            "apiVersion": self._serialize.url("self._config.api_version", self._config.api_version, "str"),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = False
        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = _deserialize(_models.FaceErrorResponse, response.json())
            raise HttpResponseError(response=response, model=error)

        if cls:
            return cls(pipeline_response, None, {})  # type: ignore

    @distributed_trace
    def get_persons(
        self, large_person_group_id: str, *, start: Optional[str] = None, top: Optional[int] = None, **kwargs: Any
    ) -> List[_models.LargePersonGroupPerson]:
        """List all persons' information in the specified Large Person Group, including personId, name,
        userData and persistedFaceIds of registered person faces.

        Persons are stored in alphabetical order of personId created in "Create Large Person Group
        Person".
        >
        *


        * "start" parameter (string, optional) specifies an ID value from which returned entries will
        have larger IDs based on string comparison. Setting "start" to an empty value indicates that
        entries should be returned starting from the first item.
        * "top" parameter (int, optional) determines the maximum number of entries to be returned, with
        a limit of up to 1000 entries per call. To retrieve additional entries beyond this limit,
        specify "start" with the personId of the last entry returned in the current call.

        ..

           [!TIP]


           * For example, there are total 5 items with their IDs: "itemId1", ..., "itemId5".

             * "start=&top=" will return all 5 items.
             * "start=&top=2" will return "itemId1", "itemId2".
             * "start=itemId2&top=3" will return "itemId3", "itemId4", "itemId5".

        :param large_person_group_id: ID of the container. Required.
        :type large_person_group_id: str
        :keyword start: List resources greater than the "start". It contains no more than 64
         characters. Default is empty. Default value is None.
        :paramtype start: str
        :keyword top: The number of items to list, ranging in [1, 1000]. Default is 1000. Default value
         is None.
        :paramtype top: int
        :return: list of LargePersonGroupPerson
        :rtype: list[~azure.ai.vision.face.models.LargePersonGroupPerson]
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == [
                    {
                        "name": "str",
                        "personId": "str",
                        "persistedFaceIds": [
                            "str"
                        ],
                        "userData": "str"
                    }
                ]
        """
        error_map: MutableMapping[int, Type[HttpResponseError]] = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[List[_models.LargePersonGroupPerson]] = kwargs.pop("cls", None)

        _request = build_large_person_groups_get_persons_request(
            large_person_group_id=large_person_group_id,
            start=start,
            top=top,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, "str", skip_quote=True),
            "apiVersion": self._serialize.url("self._config.api_version", self._config.api_version, "str"),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = kwargs.pop("stream", False)
        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                try:
                    response.read()  # Load the body in memory and close the socket
                except (StreamConsumedError, StreamClosedError):
                    pass
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = _deserialize(_models.FaceErrorResponse, response.json())
            raise HttpResponseError(response=response, model=error)

        if _stream:
            deserialized = response.iter_bytes()
        else:
            deserialized = _deserialize(List[_models.LargePersonGroupPerson], response.json())

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore

    @overload
    def add_face_from_url(
        self,
        large_person_group_id: str,
        person_id: str,
        body: JSON,
        *,
        target_face: Optional[List[int]] = None,
        detection_model: Optional[Union[str, _models.FaceDetectionModel]] = None,
        user_data: Optional[str] = None,
        content_type: str = "application/json",
        **kwargs: Any,
    ) -> _models.AddFaceResult:
        """Add a face to a person into a Large Person Group for face identification or verification.

        To deal with an image containing multiple faces, input face can be specified as an image with a
        targetFace rectangle. It returns a persistedFaceId representing the added face. No image will
        be stored. Only the extracted face feature(s) will be stored on server until "Delete Large
        Person Group Person Face", "Delete Large Person Group Person" or "Delete Large Person Group" is
        called.

        Note that persistedFaceId is different from faceId generated by "Detect".
        >
        *


        * Higher face image quality means better recognition precision. Please consider high-quality
        faces: frontal, clear, and face size is 200x200 pixels (100 pixels between eyes) or bigger.
        * Each person entry can hold up to 248 faces.
        * JPEG, PNG, GIF (the first frame), and BMP format are supported. The allowed image file size
        is from 1KB to 6MB.
        * "targetFace" rectangle should contain one face. Zero or multiple faces will be regarded as an
        error. If the provided "targetFace" rectangle is not returned from "Detect", there's no
        guarantee to detect and add the face successfully.
        * Out of detectable face size (36x36 - 4096x4096 pixels), large head-pose, or large occlusions
        will cause failures.
        * The minimum detectable face size is 36x36 pixels in an image no larger than 1920x1080 pixels.
        Images with dimensions higher than 1920x1080 pixels will need a proportionally larger minimum
        face size.
        * Different 'detectionModel' values can be provided. To use and compare different detection
        models, please refer to
        https://learn.microsoft.com/azure/ai-services/computer-vision/how-to/specify-detection-model.

        :param large_person_group_id: ID of the container. Required.
        :type large_person_group_id: str
        :param person_id: ID of the person. Required.
        :type person_id: str
        :param body: Required.
        :type body: JSON
        :keyword target_face: A face rectangle to specify the target face to be added to a person, in
         the format of 'targetFace=left,top,width,height'. Default value is None.
        :paramtype target_face: list[int]
        :keyword detection_model: The 'detectionModel' associated with the detected faceIds. Supported
         'detectionModel' values include 'detection_01', 'detection_02' and 'detection_03'. The default
         value is 'detection_01'. Known values are: "detection_01", "detection_02", and "detection_03".
         Default value is None.
        :paramtype detection_model: str or ~azure.ai.vision.face.models.FaceDetectionModel
        :keyword user_data: User-provided data attached to the face. The size limit is 1K. Default
         value is None.
        :paramtype user_data: str
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: AddFaceResult. The AddFaceResult is compatible with MutableMapping
        :rtype: ~azure.ai.vision.face.models.AddFaceResult
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                body = {
                    "url": "str"
                }

                # response body for status code(s): 200
                response == {
                    "persistedFaceId": "str"
                }
        """

    @overload
    def add_face_from_url(
        self,
        large_person_group_id: str,
        person_id: str,
        *,
        url: str,
        target_face: Optional[List[int]] = None,
        detection_model: Optional[Union[str, _models.FaceDetectionModel]] = None,
        user_data: Optional[str] = None,
        content_type: str = "application/json",
        **kwargs: Any,
    ) -> _models.AddFaceResult:
        """Add a face to a person into a Large Person Group for face identification or verification.

        To deal with an image containing multiple faces, input face can be specified as an image with a
        targetFace rectangle. It returns a persistedFaceId representing the added face. No image will
        be stored. Only the extracted face feature(s) will be stored on server until "Delete Large
        Person Group Person Face", "Delete Large Person Group Person" or "Delete Large Person Group" is
        called.

        Note that persistedFaceId is different from faceId generated by "Detect".
        >
        *


        * Higher face image quality means better recognition precision. Please consider high-quality
        faces: frontal, clear, and face size is 200x200 pixels (100 pixels between eyes) or bigger.
        * Each person entry can hold up to 248 faces.
        * JPEG, PNG, GIF (the first frame), and BMP format are supported. The allowed image file size
        is from 1KB to 6MB.
        * "targetFace" rectangle should contain one face. Zero or multiple faces will be regarded as an
        error. If the provided "targetFace" rectangle is not returned from "Detect", there's no
        guarantee to detect and add the face successfully.
        * Out of detectable face size (36x36 - 4096x4096 pixels), large head-pose, or large occlusions
        will cause failures.
        * The minimum detectable face size is 36x36 pixels in an image no larger than 1920x1080 pixels.
        Images with dimensions higher than 1920x1080 pixels will need a proportionally larger minimum
        face size.
        * Different 'detectionModel' values can be provided. To use and compare different detection
        models, please refer to
        https://learn.microsoft.com/azure/ai-services/computer-vision/how-to/specify-detection-model.

        :param large_person_group_id: ID of the container. Required.
        :type large_person_group_id: str
        :param person_id: ID of the person. Required.
        :type person_id: str
        :keyword url: URL of input image. Required.
        :paramtype url: str
        :keyword target_face: A face rectangle to specify the target face to be added to a person, in
         the format of 'targetFace=left,top,width,height'. Default value is None.
        :paramtype target_face: list[int]
        :keyword detection_model: The 'detectionModel' associated with the detected faceIds. Supported
         'detectionModel' values include 'detection_01', 'detection_02' and 'detection_03'. The default
         value is 'detection_01'. Known values are: "detection_01", "detection_02", and "detection_03".
         Default value is None.
        :paramtype detection_model: str or ~azure.ai.vision.face.models.FaceDetectionModel
        :keyword user_data: User-provided data attached to the face. The size limit is 1K. Default
         value is None.
        :paramtype user_data: str
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: AddFaceResult. The AddFaceResult is compatible with MutableMapping
        :rtype: ~azure.ai.vision.face.models.AddFaceResult
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "persistedFaceId": "str"
                }
        """

    @overload
    def add_face_from_url(
        self,
        large_person_group_id: str,
        person_id: str,
        body: IO[bytes],
        *,
        target_face: Optional[List[int]] = None,
        detection_model: Optional[Union[str, _models.FaceDetectionModel]] = None,
        user_data: Optional[str] = None,
        content_type: str = "application/json",
        **kwargs: Any,
    ) -> _models.AddFaceResult:
        """Add a face to a person into a Large Person Group for face identification or verification.

        To deal with an image containing multiple faces, input face can be specified as an image with a
        targetFace rectangle. It returns a persistedFaceId representing the added face. No image will
        be stored. Only the extracted face feature(s) will be stored on server until "Delete Large
        Person Group Person Face", "Delete Large Person Group Person" or "Delete Large Person Group" is
        called.

        Note that persistedFaceId is different from faceId generated by "Detect".
        >
        *


        * Higher face image quality means better recognition precision. Please consider high-quality
        faces: frontal, clear, and face size is 200x200 pixels (100 pixels between eyes) or bigger.
        * Each person entry can hold up to 248 faces.
        * JPEG, PNG, GIF (the first frame), and BMP format are supported. The allowed image file size
        is from 1KB to 6MB.
        * "targetFace" rectangle should contain one face. Zero or multiple faces will be regarded as an
        error. If the provided "targetFace" rectangle is not returned from "Detect", there's no
        guarantee to detect and add the face successfully.
        * Out of detectable face size (36x36 - 4096x4096 pixels), large head-pose, or large occlusions
        will cause failures.
        * The minimum detectable face size is 36x36 pixels in an image no larger than 1920x1080 pixels.
        Images with dimensions higher than 1920x1080 pixels will need a proportionally larger minimum
        face size.
        * Different 'detectionModel' values can be provided. To use and compare different detection
        models, please refer to
        https://learn.microsoft.com/azure/ai-services/computer-vision/how-to/specify-detection-model.

        :param large_person_group_id: ID of the container. Required.
        :type large_person_group_id: str
        :param person_id: ID of the person. Required.
        :type person_id: str
        :param body: Required.
        :type body: IO[bytes]
        :keyword target_face: A face rectangle to specify the target face to be added to a person, in
         the format of 'targetFace=left,top,width,height'. Default value is None.
        :paramtype target_face: list[int]
        :keyword detection_model: The 'detectionModel' associated with the detected faceIds. Supported
         'detectionModel' values include 'detection_01', 'detection_02' and 'detection_03'. The default
         value is 'detection_01'. Known values are: "detection_01", "detection_02", and "detection_03".
         Default value is None.
        :paramtype detection_model: str or ~azure.ai.vision.face.models.FaceDetectionModel
        :keyword user_data: User-provided data attached to the face. The size limit is 1K. Default
         value is None.
        :paramtype user_data: str
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: AddFaceResult. The AddFaceResult is compatible with MutableMapping
        :rtype: ~azure.ai.vision.face.models.AddFaceResult
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "persistedFaceId": "str"
                }
        """

    @distributed_trace
    def add_face_from_url(
        self,
        large_person_group_id: str,
        person_id: str,
        body: Union[JSON, IO[bytes]] = _Unset,
        *,
        url: str = _Unset,
        target_face: Optional[List[int]] = None,
        detection_model: Optional[Union[str, _models.FaceDetectionModel]] = None,
        user_data: Optional[str] = None,
        **kwargs: Any,
    ) -> _models.AddFaceResult:
        """Add a face to a person into a Large Person Group for face identification or verification.

        To deal with an image containing multiple faces, input face can be specified as an image with a
        targetFace rectangle. It returns a persistedFaceId representing the added face. No image will
        be stored. Only the extracted face feature(s) will be stored on server until "Delete Large
        Person Group Person Face", "Delete Large Person Group Person" or "Delete Large Person Group" is
        called.

        Note that persistedFaceId is different from faceId generated by "Detect".
        >
        *


        * Higher face image quality means better recognition precision. Please consider high-quality
        faces: frontal, clear, and face size is 200x200 pixels (100 pixels between eyes) or bigger.
        * Each person entry can hold up to 248 faces.
        * JPEG, PNG, GIF (the first frame), and BMP format are supported. The allowed image file size
        is from 1KB to 6MB.
        * "targetFace" rectangle should contain one face. Zero or multiple faces will be regarded as an
        error. If the provided "targetFace" rectangle is not returned from "Detect", there's no
        guarantee to detect and add the face successfully.
        * Out of detectable face size (36x36 - 4096x4096 pixels), large head-pose, or large occlusions
        will cause failures.
        * The minimum detectable face size is 36x36 pixels in an image no larger than 1920x1080 pixels.
        Images with dimensions higher than 1920x1080 pixels will need a proportionally larger minimum
        face size.
        * Different 'detectionModel' values can be provided. To use and compare different detection
        models, please refer to
        https://learn.microsoft.com/azure/ai-services/computer-vision/how-to/specify-detection-model.

        :param large_person_group_id: ID of the container. Required.
        :type large_person_group_id: str
        :param person_id: ID of the person. Required.
        :type person_id: str
        :param body: Is either a JSON type or a IO[bytes] type. Required.
        :type body: JSON or IO[bytes]
        :keyword url: URL of input image. Required.
        :paramtype url: str
        :keyword target_face: A face rectangle to specify the target face to be added to a person, in
         the format of 'targetFace=left,top,width,height'. Default value is None.
        :paramtype target_face: list[int]
        :keyword detection_model: The 'detectionModel' associated with the detected faceIds. Supported
         'detectionModel' values include 'detection_01', 'detection_02' and 'detection_03'. The default
         value is 'detection_01'. Known values are: "detection_01", "detection_02", and "detection_03".
         Default value is None.
        :paramtype detection_model: str or ~azure.ai.vision.face.models.FaceDetectionModel
        :keyword user_data: User-provided data attached to the face. The size limit is 1K. Default
         value is None.
        :paramtype user_data: str
        :return: AddFaceResult. The AddFaceResult is compatible with MutableMapping
        :rtype: ~azure.ai.vision.face.models.AddFaceResult
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                body = {
                    "url": "str"
                }

                # response body for status code(s): 200
                response == {
                    "persistedFaceId": "str"
                }
        """
        error_map: MutableMapping[int, Type[HttpResponseError]] = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[_models.AddFaceResult] = kwargs.pop("cls", None)

        if body is _Unset:
            if url is _Unset:
                raise TypeError("missing required argument: url")
            body = {"url": url}
            body = {k: v for k, v in body.items() if v is not None}
        content_type = content_type or "application/json"
        _content = None
        if isinstance(body, (IOBase, bytes)):
            _content = body
        else:
            _content = json.dumps(body, cls=SdkJSONEncoder, exclude_readonly=True)  # type: ignore

        _request = build_large_person_groups_add_face_from_url_request(
            large_person_group_id=large_person_group_id,
            person_id=person_id,
            target_face=target_face,
            detection_model=detection_model,
            user_data=user_data,
            content_type=content_type,
            content=_content,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, "str", skip_quote=True),
            "apiVersion": self._serialize.url("self._config.api_version", self._config.api_version, "str"),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = kwargs.pop("stream", False)
        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                try:
                    response.read()  # Load the body in memory and close the socket
                except (StreamConsumedError, StreamClosedError):
                    pass
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = _deserialize(_models.FaceErrorResponse, response.json())
            raise HttpResponseError(response=response, model=error)

        if _stream:
            deserialized = response.iter_bytes()
        else:
            deserialized = _deserialize(_models.AddFaceResult, response.json())

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore

    @distributed_trace
    def add_face(
        self,
        large_person_group_id: str,
        person_id: str,
        image_content: bytes,
        *,
        target_face: Optional[List[int]] = None,
        detection_model: Optional[Union[str, _models.FaceDetectionModel]] = None,
        user_data: Optional[str] = None,
        **kwargs: Any,
    ) -> _models.AddFaceResult:
        """Add a face to a person into a Large Person Group for face identification or verification.

        To deal with an image containing multiple faces, input face can be specified as an image with a
        targetFace rectangle. It returns a persistedFaceId representing the added face. No image will
        be stored. Only the extracted face feature(s) will be stored on server until "Delete Large
        Person Group Person Face", "Delete Large Person Group Person" or "Delete Large Person Group" is
        called.

        Note that persistedFaceId is different from faceId generated by "Detect".
        >
        *


        * Higher face image quality means better recognition precision. Please consider high-quality
        faces: frontal, clear, and face size is 200x200 pixels (100 pixels between eyes) or bigger.
        * Each person entry can hold up to 248 faces.
        * JPEG, PNG, GIF (the first frame), and BMP format are supported. The allowed image file size
        is from 1KB to 6MB.
        * "targetFace" rectangle should contain one face. Zero or multiple faces will be regarded as an
        error. If the provided "targetFace" rectangle is not returned from "Detect", there's no
        guarantee to detect and add the face successfully.
        * Out of detectable face size (36x36 - 4096x4096 pixels), large head-pose, or large occlusions
        will cause failures.
        * The minimum detectable face size is 36x36 pixels in an image no larger than 1920x1080 pixels.
        Images with dimensions higher than 1920x1080 pixels will need a proportionally larger minimum
        face size.
        * Different 'detectionModel' values can be provided. To use and compare different detection
        models, please refer to
        https://learn.microsoft.com/azure/ai-services/computer-vision/how-to/specify-detection-model.

        :param large_person_group_id: ID of the container. Required.
        :type large_person_group_id: str
        :param person_id: ID of the person. Required.
        :type person_id: str
        :param image_content: The image to be analyzed. Required.
        :type image_content: bytes
        :keyword target_face: A face rectangle to specify the target face to be added to a person, in
         the format of 'targetFace=left,top,width,height'. Default value is None.
        :paramtype target_face: list[int]
        :keyword detection_model: The 'detectionModel' associated with the detected faceIds. Supported
         'detectionModel' values include 'detection_01', 'detection_02' and 'detection_03'. The default
         value is 'detection_01'. Known values are: "detection_01", "detection_02", and "detection_03".
         Default value is None.
        :paramtype detection_model: str or ~azure.ai.vision.face.models.FaceDetectionModel
        :keyword user_data: User-provided data attached to the face. The size limit is 1K. Default
         value is None.
        :paramtype user_data: str
        :return: AddFaceResult. The AddFaceResult is compatible with MutableMapping
        :rtype: ~azure.ai.vision.face.models.AddFaceResult
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "persistedFaceId": "str"
                }
        """
        error_map: MutableMapping[int, Type[HttpResponseError]] = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: str = kwargs.pop("content_type", _headers.pop("content-type", "application/octet-stream"))
        cls: ClsType[_models.AddFaceResult] = kwargs.pop("cls", None)

        _content = image_content

        _request = build_large_person_groups_add_face_request(
            large_person_group_id=large_person_group_id,
            person_id=person_id,
            target_face=target_face,
            detection_model=detection_model,
            user_data=user_data,
            content_type=content_type,
            content=_content,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, "str", skip_quote=True),
            "apiVersion": self._serialize.url("self._config.api_version", self._config.api_version, "str"),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = kwargs.pop("stream", False)
        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                try:
                    response.read()  # Load the body in memory and close the socket
                except (StreamConsumedError, StreamClosedError):
                    pass
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = _deserialize(_models.FaceErrorResponse, response.json())
            raise HttpResponseError(response=response, model=error)

        if _stream:
            deserialized = response.iter_bytes()
        else:
            deserialized = _deserialize(_models.AddFaceResult, response.json())

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore

    @distributed_trace
    def delete_face(  # pylint: disable=inconsistent-return-statements
        self, large_person_group_id: str, person_id: str, persisted_face_id: str, **kwargs: Any
    ) -> None:
        """Delete a face from a person in a Large Person Group by specified largePersonGroupId, personId
        and persistedFaceId.

        Adding/deleting faces to/from a same person will be processed sequentially. Adding/deleting
        faces to/from different persons are processed in parallel.

        :param large_person_group_id: ID of the container. Required.
        :type large_person_group_id: str
        :param person_id: ID of the person. Required.
        :type person_id: str
        :param persisted_face_id: Face ID of the face. Required.
        :type persisted_face_id: str
        :return: None
        :rtype: None
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping[int, Type[HttpResponseError]] = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[None] = kwargs.pop("cls", None)

        _request = build_large_person_groups_delete_face_request(
            large_person_group_id=large_person_group_id,
            person_id=person_id,
            persisted_face_id=persisted_face_id,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, "str", skip_quote=True),
            "apiVersion": self._serialize.url("self._config.api_version", self._config.api_version, "str"),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = False
        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = _deserialize(_models.FaceErrorResponse, response.json())
            raise HttpResponseError(response=response, model=error)

        if cls:
            return cls(pipeline_response, None, {})  # type: ignore

    @distributed_trace
    def get_face(
        self, large_person_group_id: str, person_id: str, persisted_face_id: str, **kwargs: Any
    ) -> _models.LargePersonGroupPersonFace:
        """Retrieve person face information. The persisted person face is specified by its
        largePersonGroupId, personId and persistedFaceId.

        :param large_person_group_id: ID of the container. Required.
        :type large_person_group_id: str
        :param person_id: ID of the person. Required.
        :type person_id: str
        :param persisted_face_id: Face ID of the face. Required.
        :type persisted_face_id: str
        :return: LargePersonGroupPersonFace. The LargePersonGroupPersonFace is compatible with
         MutableMapping
        :rtype: ~azure.ai.vision.face.models.LargePersonGroupPersonFace
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "persistedFaceId": "str",
                    "userData": "str"
                }
        """
        error_map: MutableMapping[int, Type[HttpResponseError]] = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[_models.LargePersonGroupPersonFace] = kwargs.pop("cls", None)

        _request = build_large_person_groups_get_face_request(
            large_person_group_id=large_person_group_id,
            person_id=person_id,
            persisted_face_id=persisted_face_id,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, "str", skip_quote=True),
            "apiVersion": self._serialize.url("self._config.api_version", self._config.api_version, "str"),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = kwargs.pop("stream", False)
        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                try:
                    response.read()  # Load the body in memory and close the socket
                except (StreamConsumedError, StreamClosedError):
                    pass
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = _deserialize(_models.FaceErrorResponse, response.json())
            raise HttpResponseError(response=response, model=error)

        if _stream:
            deserialized = response.iter_bytes()
        else:
            deserialized = _deserialize(_models.LargePersonGroupPersonFace, response.json())

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore

    @overload
    def update_face(  # pylint: disable=inconsistent-return-statements
        self,
        large_person_group_id: str,
        person_id: str,
        persisted_face_id: str,
        body: JSON,
        *,
        content_type: str = "application/json",
        **kwargs: Any,
    ) -> None:
        """Update a person persisted face's userData field.

        :param large_person_group_id: ID of the container. Required.
        :type large_person_group_id: str
        :param person_id: ID of the person. Required.
        :type person_id: str
        :param persisted_face_id: Face ID of the face. Required.
        :type persisted_face_id: str
        :param body: Required.
        :type body: JSON
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: None
        :rtype: None
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                body = {
                    "userData": "str"
                }
        """

    @overload
    def update_face(  # pylint: disable=inconsistent-return-statements
        self,
        large_person_group_id: str,
        person_id: str,
        persisted_face_id: str,
        *,
        content_type: str = "application/json",
        user_data: Optional[str] = None,
        **kwargs: Any,
    ) -> None:
        """Update a person persisted face's userData field.

        :param large_person_group_id: ID of the container. Required.
        :type large_person_group_id: str
        :param person_id: ID of the person. Required.
        :type person_id: str
        :param persisted_face_id: Face ID of the face. Required.
        :type persisted_face_id: str
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :keyword user_data: User-provided data attached to the face. The length limit is 1K. Default
         value is None.
        :paramtype user_data: str
        :return: None
        :rtype: None
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @overload
    def update_face(  # pylint: disable=inconsistent-return-statements
        self,
        large_person_group_id: str,
        person_id: str,
        persisted_face_id: str,
        body: IO[bytes],
        *,
        content_type: str = "application/json",
        **kwargs: Any,
    ) -> None:
        """Update a person persisted face's userData field.

        :param large_person_group_id: ID of the container. Required.
        :type large_person_group_id: str
        :param person_id: ID of the person. Required.
        :type person_id: str
        :param persisted_face_id: Face ID of the face. Required.
        :type persisted_face_id: str
        :param body: Required.
        :type body: IO[bytes]
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: None
        :rtype: None
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @distributed_trace
    def update_face(  # pylint: disable=inconsistent-return-statements
        self,
        large_person_group_id: str,
        person_id: str,
        persisted_face_id: str,
        body: Union[JSON, IO[bytes]] = _Unset,
        *,
        user_data: Optional[str] = None,
        **kwargs: Any,
    ) -> None:
        """Update a person persisted face's userData field.

        :param large_person_group_id: ID of the container. Required.
        :type large_person_group_id: str
        :param person_id: ID of the person. Required.
        :type person_id: str
        :param persisted_face_id: Face ID of the face. Required.
        :type persisted_face_id: str
        :param body: Is either a JSON type or a IO[bytes] type. Required.
        :type body: JSON or IO[bytes]
        :keyword user_data: User-provided data attached to the face. The length limit is 1K. Default
         value is None.
        :paramtype user_data: str
        :return: None
        :rtype: None
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                body = {
                    "userData": "str"
                }
        """
        error_map: MutableMapping[int, Type[HttpResponseError]] = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[None] = kwargs.pop("cls", None)

        if body is _Unset:
            body = {"userData": user_data}
            body = {k: v for k, v in body.items() if v is not None}
        content_type = content_type or "application/json"
        _content = None
        if isinstance(body, (IOBase, bytes)):
            _content = body
        else:
            _content = json.dumps(body, cls=SdkJSONEncoder, exclude_readonly=True)  # type: ignore

        _request = build_large_person_groups_update_face_request(
            large_person_group_id=large_person_group_id,
            person_id=person_id,
            persisted_face_id=persisted_face_id,
            content_type=content_type,
            content=_content,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, "str", skip_quote=True),
            "apiVersion": self._serialize.url("self._config.api_version", self._config.api_version, "str"),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = False
        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = _deserialize(_models.FaceErrorResponse, response.json())
            raise HttpResponseError(response=response, model=error)

        if cls:
            return cls(pipeline_response, None, {})  # type: ignore


class FaceClientOperationsMixin(FaceClientMixinABC):

    @overload
    def _detect_from_url(
        self,
        body: JSON,
        *,
        content_type: str = "application/json",
        detection_model: Optional[Union[str, _models.FaceDetectionModel]] = None,
        recognition_model: Optional[Union[str, _models.FaceRecognitionModel]] = None,
        return_face_id: Optional[bool] = None,
        return_face_attributes: Optional[List[Union[str, _models.FaceAttributeType]]] = None,
        return_face_landmarks: Optional[bool] = None,
        return_recognition_model: Optional[bool] = None,
        face_id_time_to_live: Optional[int] = None,
        **kwargs: Any,
    ) -> List[_models.FaceDetectionResult]: ...
    @overload
    def _detect_from_url(
        self,
        *,
        url: str,
        content_type: str = "application/json",
        detection_model: Optional[Union[str, _models.FaceDetectionModel]] = None,
        recognition_model: Optional[Union[str, _models.FaceRecognitionModel]] = None,
        return_face_id: Optional[bool] = None,
        return_face_attributes: Optional[List[Union[str, _models.FaceAttributeType]]] = None,
        return_face_landmarks: Optional[bool] = None,
        return_recognition_model: Optional[bool] = None,
        face_id_time_to_live: Optional[int] = None,
        **kwargs: Any,
    ) -> List[_models.FaceDetectionResult]: ...
    @overload
    def _detect_from_url(
        self,
        body: IO[bytes],
        *,
        content_type: str = "application/json",
        detection_model: Optional[Union[str, _models.FaceDetectionModel]] = None,
        recognition_model: Optional[Union[str, _models.FaceRecognitionModel]] = None,
        return_face_id: Optional[bool] = None,
        return_face_attributes: Optional[List[Union[str, _models.FaceAttributeType]]] = None,
        return_face_landmarks: Optional[bool] = None,
        return_recognition_model: Optional[bool] = None,
        face_id_time_to_live: Optional[int] = None,
        **kwargs: Any,
    ) -> List[_models.FaceDetectionResult]: ...

    @distributed_trace
    def _detect_from_url(
        self,
        body: Union[JSON, IO[bytes]] = _Unset,
        *,
        url: str = _Unset,
        detection_model: Optional[Union[str, _models.FaceDetectionModel]] = None,
        recognition_model: Optional[Union[str, _models.FaceRecognitionModel]] = None,
        return_face_id: Optional[bool] = None,
        return_face_attributes: Optional[List[Union[str, _models.FaceAttributeType]]] = None,
        return_face_landmarks: Optional[bool] = None,
        return_recognition_model: Optional[bool] = None,
        face_id_time_to_live: Optional[int] = None,
        **kwargs: Any,
    ) -> List[_models.FaceDetectionResult]:
        """Detect human faces in an image, return face rectangles, and optionally with faceIds, landmarks,
        and attributes.

        ..

           [!IMPORTANT]
           Microsoft has retired or limited facial recognition capabilities that can be used to try to
        infer emotional states and identity attributes which, if misused, can subject people to
        stereotyping, discrimination or unfair denial of services. The retired capabilities are emotion
        and gender. The limited capabilities are age, smile, facial hair, hair and makeup. Email Azure
        Face API azureface@microsoft.com if you have a responsible use case that would benefit from the
        use of any of the limited capabilities. Read more about this decision
        https://azure.microsoft.com/blog/responsible-ai-investments-and-safeguards-for-facial-recognition/.


        *


        * No image will be stored. Only the extracted face feature(s) will be stored on server. The
        faceId is an identifier of the face feature and will be used in "Identify", "Verify", and "Find
        Similar". The stored face features will expire and be deleted at the time specified by
        faceIdTimeToLive after the original detection call.
        * Optional parameters include faceId, landmarks, and attributes. Attributes include headPose,
        glasses, occlusion, accessories, blur, exposure, noise, mask, and qualityForRecognition. Some
        of the results returned for specific attributes may not be highly accurate.
        * JPEG, PNG, GIF (the first frame), and BMP format are supported. The allowed image file size
        is from 1KB to 6MB.
        * The minimum detectable face size is 36x36 pixels in an image no larger than 1920x1080 pixels.
        Images with dimensions higher than 1920x1080 pixels will need a proportionally larger minimum
        face size.
        * Up to 100 faces can be returned for an image. Faces are ranked by face rectangle size from
        large to small.
        * For optimal results when querying "Identify", "Verify", and "Find Similar" ('returnFaceId' is
        true), please use faces that are: frontal, clear, and with a minimum size of 200x200 pixels
        (100 pixels between eyes).
        * Different 'detectionModel' values can be provided. To use and compare different detection
        models, please refer to
        https://learn.microsoft.com/azure/ai-services/computer-vision/how-to/specify-detection-model

          * 'detection_02': Face attributes and landmarks are disabled if you choose this detection
        model.
          * 'detection_03': Face attributes (mask, blur, and headPose) and landmarks are supported if
        you choose this detection model.

        * Different 'recognitionModel' values are provided. If follow-up operations like "Verify",
        "Identify", "Find Similar" are needed, please specify the recognition model with
        'recognitionModel' parameter. The default value for 'recognitionModel' is 'recognition_01', if
        latest model needed, please explicitly specify the model you need in this parameter. Once
        specified, the detected faceIds will be associated with the specified recognition model. More
        details, please refer to
        https://learn.microsoft.com/azure/ai-services/computer-vision/how-to/specify-recognition-model.

        :param body: Is either a JSON type or a IO[bytes] type. Required.
        :type body: JSON or IO[bytes]
        :keyword url: URL of input image. Required.
        :paramtype url: str
        :keyword detection_model: The 'detectionModel' associated with the detected faceIds. Supported
         'detectionModel' values include 'detection_01', 'detection_02' and 'detection_03'. The default
         value is 'detection_01'. Known values are: "detection_01", "detection_02", and "detection_03".
         Default value is None.
        :paramtype detection_model: str or ~azure.ai.vision.face.models.FaceDetectionModel
        :keyword recognition_model: The 'recognitionModel' associated with the detected faceIds.
         Supported 'recognitionModel' values include 'recognition_01', 'recognition_02',
         'recognition_03' or 'recognition_04'. The default value is 'recognition_01'. 'recognition_04'
         is recommended since its accuracy is improved on faces wearing masks compared with
         'recognition_03', and its overall accuracy is improved compared with 'recognition_01' and
         'recognition_02'. Known values are: "recognition_01", "recognition_02", "recognition_03", and
         "recognition_04". Default value is None.
        :paramtype recognition_model: str or ~azure.ai.vision.face.models.FaceRecognitionModel
        :keyword return_face_id: Return faceIds of the detected faces or not. The default value is
         true. Default value is None.
        :paramtype return_face_id: bool
        :keyword return_face_attributes: Analyze and return the one or more specified face attributes
         in the comma-separated string like 'returnFaceAttributes=headPose,glasses'. Face attribute
         analysis has additional computational and time cost. Default value is None.
        :paramtype return_face_attributes: list[str or ~azure.ai.vision.face.models.FaceAttributeType]
        :keyword return_face_landmarks: Return face landmarks of the detected faces or not. The default
         value is false. Default value is None.
        :paramtype return_face_landmarks: bool
        :keyword return_recognition_model: Return 'recognitionModel' or not. The default value is
         false. This is only applicable when returnFaceId = true. Default value is None.
        :paramtype return_recognition_model: bool
        :keyword face_id_time_to_live: The number of seconds for the face ID being cached. Supported
         range from 60 seconds up to 86400 seconds. The default value is 86400 (24 hours). Default value
         is None.
        :paramtype face_id_time_to_live: int
        :return: list of FaceDetectionResult
        :rtype: list[~azure.ai.vision.face.models.FaceDetectionResult]
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                body = {
                    "url": "str"
                }

                # response body for status code(s): 200
                response == [
                    {
                        "faceRectangle": {
                            "height": 0,
                            "left": 0,
                            "top": 0,
                            "width": 0
                        },
                        "faceAttributes": {
                            "accessories": [
                                {
                                    "confidence": 0.0,
                                    "type": "str"
                                }
                            ],
                            "age": 0.0,
                            "blur": {
                                "blurLevel": "str",
                                "value": 0.0
                            },
                            "exposure": {
                                "exposureLevel": "str",
                                "value": 0.0
                            },
                            "facialHair": {
                                "beard": 0.0,
                                "moustache": 0.0,
                                "sideburns": 0.0
                            },
                            "glasses": "str",
                            "hair": {
                                "bald": 0.0,
                                "hairColor": [
                                    {
                                        "color": "str",
                                        "confidence": 0.0
                                    }
                                ],
                                "invisible": bool
                            },
                            "headPose": {
                                "pitch": 0.0,
                                "roll": 0.0,
                                "yaw": 0.0
                            },
                            "mask": {
                                "noseAndMouthCovered": bool,
                                "type": "str"
                            },
                            "noise": {
                                "noiseLevel": "str",
                                "value": 0.0
                            },
                            "occlusion": {
                                "eyeOccluded": bool,
                                "foreheadOccluded": bool,
                                "mouthOccluded": bool
                            },
                            "qualityForRecognition": "str",
                            "smile": 0.0
                        },
                        "faceId": "str",
                        "faceLandmarks": {
                            "eyeLeftBottom": {
                                "x": 0.0,
                                "y": 0.0
                            },
                            "eyeLeftInner": {
                                "x": 0.0,
                                "y": 0.0
                            },
                            "eyeLeftOuter": {
                                "x": 0.0,
                                "y": 0.0
                            },
                            "eyeLeftTop": {
                                "x": 0.0,
                                "y": 0.0
                            },
                            "eyeRightBottom": {
                                "x": 0.0,
                                "y": 0.0
                            },
                            "eyeRightInner": {
                                "x": 0.0,
                                "y": 0.0
                            },
                            "eyeRightOuter": {
                                "x": 0.0,
                                "y": 0.0
                            },
                            "eyeRightTop": {
                                "x": 0.0,
                                "y": 0.0
                            },
                            "eyebrowLeftInner": {
                                "x": 0.0,
                                "y": 0.0
                            },
                            "eyebrowLeftOuter": {
                                "x": 0.0,
                                "y": 0.0
                            },
                            "eyebrowRightInner": {
                                "x": 0.0,
                                "y": 0.0
                            },
                            "eyebrowRightOuter": {
                                "x": 0.0,
                                "y": 0.0
                            },
                            "mouthLeft": {
                                "x": 0.0,
                                "y": 0.0
                            },
                            "mouthRight": {
                                "x": 0.0,
                                "y": 0.0
                            },
                            "noseLeftAlarOutTip": {
                                "x": 0.0,
                                "y": 0.0
                            },
                            "noseLeftAlarTop": {
                                "x": 0.0,
                                "y": 0.0
                            },
                            "noseRightAlarOutTip": {
                                "x": 0.0,
                                "y": 0.0
                            },
                            "noseRightAlarTop": {
                                "x": 0.0,
                                "y": 0.0
                            },
                            "noseRootLeft": {
                                "x": 0.0,
                                "y": 0.0
                            },
                            "noseRootRight": {
                                "x": 0.0,
                                "y": 0.0
                            },
                            "noseTip": {
                                "x": 0.0,
                                "y": 0.0
                            },
                            "pupilLeft": {
                                "x": 0.0,
                                "y": 0.0
                            },
                            "pupilRight": {
                                "x": 0.0,
                                "y": 0.0
                            },
                            "underLipBottom": {
                                "x": 0.0,
                                "y": 0.0
                            },
                            "underLipTop": {
                                "x": 0.0,
                                "y": 0.0
                            },
                            "upperLipBottom": {
                                "x": 0.0,
                                "y": 0.0
                            },
                            "upperLipTop": {
                                "x": 0.0,
                                "y": 0.0
                            }
                        },
                        "recognitionModel": "str"
                    }
                ]
        """
        error_map: MutableMapping[int, Type[HttpResponseError]] = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("content-type", None))
        cls: ClsType[List[_models.FaceDetectionResult]] = kwargs.pop("cls", None)

        if body is _Unset:
            if url is _Unset:
                raise TypeError("missing required argument: url")
            body = {"url": url}
            body = {k: v for k, v in body.items() if v is not None}
        content_type = content_type or "application/json"
        _content = None
        if isinstance(body, (IOBase, bytes)):
            _content = body
        else:
            _content = json.dumps(body, cls=SdkJSONEncoder, exclude_readonly=True)  # type: ignore

        _request = build_face_detect_from_url_request(
            detection_model=detection_model,
            recognition_model=recognition_model,
            return_face_id=return_face_id,
            return_face_attributes=return_face_attributes,
            return_face_landmarks=return_face_landmarks,
            return_recognition_model=return_recognition_model,
            face_id_time_to_live=face_id_time_to_live,
            content_type=content_type,
            content=_content,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, "str", skip_quote=True),
            "apiVersion": self._serialize.url("self._config.api_version", self._config.api_version, "str"),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = kwargs.pop("stream", False)
        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                try:
                    response.read()  # Load the body in memory and close the socket
                except (StreamConsumedError, StreamClosedError):
                    pass
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = _deserialize(_models.FaceErrorResponse, response.json())
            raise HttpResponseError(response=response, model=error)

        if _stream:
            deserialized = response.iter_bytes()
        else:
            deserialized = _deserialize(List[_models.FaceDetectionResult], response.json())

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore

    @distributed_trace
    def _detect(
        self,
        image_content: bytes,
        *,
        detection_model: Optional[Union[str, _models.FaceDetectionModel]] = None,
        recognition_model: Optional[Union[str, _models.FaceRecognitionModel]] = None,
        return_face_id: Optional[bool] = None,
        return_face_attributes: Optional[List[Union[str, _models.FaceAttributeType]]] = None,
        return_face_landmarks: Optional[bool] = None,
        return_recognition_model: Optional[bool] = None,
        face_id_time_to_live: Optional[int] = None,
        **kwargs: Any,
    ) -> List[_models.FaceDetectionResult]:
        """Detect human faces in an image, return face rectangles, and optionally with faceIds, landmarks,
        and attributes.

        ..

           [!IMPORTANT]
           Microsoft has retired or limited facial recognition capabilities that can be used to try to
        infer emotional states and identity attributes which, if misused, can subject people to
        stereotyping, discrimination or unfair denial of services. The retired capabilities are emotion
        and gender. The limited capabilities are age, smile, facial hair, hair and makeup. Email Azure
        Face API azureface@microsoft.com if you have a responsible use case that would benefit from the
        use of any of the limited capabilities. Read more about this decision
        https://azure.microsoft.com/blog/responsible-ai-investments-and-safeguards-for-facial-recognition/.


        *


        * No image will be stored. Only the extracted face feature(s) will be stored on server. The
        faceId is an identifier of the face feature and will be used in "Identify", "Verify", and "Find
        Similar". The stored face features will expire and be deleted at the time specified by
        faceIdTimeToLive after the original detection call.
        * Optional parameters include faceId, landmarks, and attributes. Attributes include headPose,
        glasses, occlusion, accessories, blur, exposure, noise, mask, and qualityForRecognition. Some
        of the results returned for specific attributes may not be highly accurate.
        * JPEG, PNG, GIF (the first frame), and BMP format are supported. The allowed image file size
        is from 1KB to 6MB.
        * The minimum detectable face size is 36x36 pixels in an image no larger than 1920x1080 pixels.
        Images with dimensions higher than 1920x1080 pixels will need a proportionally larger minimum
        face size.
        * Up to 100 faces can be returned for an image. Faces are ranked by face rectangle size from
        large to small.
        * For optimal results when querying "Identify", "Verify", and "Find Similar" ('returnFaceId' is
        true), please use faces that are: frontal, clear, and with a minimum size of 200x200 pixels
        (100 pixels between eyes).
        * Different 'detectionModel' values can be provided. To use and compare different detection
        models, please refer to
        https://learn.microsoft.com/azure/ai-services/computer-vision/how-to/specify-detection-model

          * 'detection_02': Face attributes and landmarks are disabled if you choose this detection
        model.
          * 'detection_03': Face attributes (mask, blur, and headPose) and landmarks are supported if
        you choose this detection model.

        * Different 'recognitionModel' values are provided. If follow-up operations like "Verify",
        "Identify", "Find Similar" are needed, please specify the recognition model with
        'recognitionModel' parameter. The default value for 'recognitionModel' is 'recognition_01', if
        latest model needed, please explicitly specify the model you need in this parameter. Once
        specified, the detected faceIds will be associated with the specified recognition model. More
        details, please refer to
        https://learn.microsoft.com/azure/ai-services/computer-vision/how-to/specify-recognition-model.

        :param image_content: The input image binary. Required.
        :type image_content: bytes
        :keyword detection_model: The 'detectionModel' associated with the detected faceIds. Supported
         'detectionModel' values include 'detection_01', 'detection_02' and 'detection_03'. The default
         value is 'detection_01'. Known values are: "detection_01", "detection_02", and "detection_03".
         Default value is None.
        :paramtype detection_model: str or ~azure.ai.vision.face.models.FaceDetectionModel
        :keyword recognition_model: The 'recognitionModel' associated with the detected faceIds.
         Supported 'recognitionModel' values include 'recognition_01', 'recognition_02',
         'recognition_03' or 'recognition_04'. The default value is 'recognition_01'. 'recognition_04'
         is recommended since its accuracy is improved on faces wearing masks compared with
         'recognition_03', and its overall accuracy is improved compared with 'recognition_01' and
         'recognition_02'. Known values are: "recognition_01", "recognition_02", "recognition_03", and
         "recognition_04". Default value is None.
        :paramtype recognition_model: str or ~azure.ai.vision.face.models.FaceRecognitionModel
        :keyword return_face_id: Return faceIds of the detected faces or not. The default value is
         true. Default value is None.
        :paramtype return_face_id: bool
        :keyword return_face_attributes: Analyze and return the one or more specified face attributes
         in the comma-separated string like 'returnFaceAttributes=headPose,glasses'. Face attribute
         analysis has additional computational and time cost. Default value is None.
        :paramtype return_face_attributes: list[str or ~azure.ai.vision.face.models.FaceAttributeType]
        :keyword return_face_landmarks: Return face landmarks of the detected faces or not. The default
         value is false. Default value is None.
        :paramtype return_face_landmarks: bool
        :keyword return_recognition_model: Return 'recognitionModel' or not. The default value is
         false. This is only applicable when returnFaceId = true. Default value is None.
        :paramtype return_recognition_model: bool
        :keyword face_id_time_to_live: The number of seconds for the face ID being cached. Supported
         range from 60 seconds up to 86400 seconds. The default value is 86400 (24 hours). Default value
         is None.
        :paramtype face_id_time_to_live: int
        :return: list of FaceDetectionResult
        :rtype: list[~azure.ai.vision.face.models.FaceDetectionResult]
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == [
                    {
                        "faceRectangle": {
                            "height": 0,
                            "left": 0,
                            "top": 0,
                            "width": 0
                        },
                        "faceAttributes": {
                            "accessories": [
                                {
                                    "confidence": 0.0,
                                    "type": "str"
                                }
                            ],
                            "age": 0.0,
                            "blur": {
                                "blurLevel": "str",
                                "value": 0.0
                            },
                            "exposure": {
                                "exposureLevel": "str",
                                "value": 0.0
                            },
                            "facialHair": {
                                "beard": 0.0,
                                "moustache": 0.0,
                                "sideburns": 0.0
                            },
                            "glasses": "str",
                            "hair": {
                                "bald": 0.0,
                                "hairColor": [
                                    {
                                        "color": "str",
                                        "confidence": 0.0
                                    }
                                ],
                                "invisible": bool
                            },
                            "headPose": {
                                "pitch": 0.0,
                                "roll": 0.0,
                                "yaw": 0.0
                            },
                            "mask": {
                                "noseAndMouthCovered": bool,
                                "type": "str"
                            },
                            "noise": {
                                "noiseLevel": "str",
                                "value": 0.0
                            },
                            "occlusion": {
                                "eyeOccluded": bool,
                                "foreheadOccluded": bool,
                                "mouthOccluded": bool
                            },
                            "qualityForRecognition": "str",
                            "smile": 0.0
                        },
                        "faceId": "str",
                        "faceLandmarks": {
                            "eyeLeftBottom": {
                                "x": 0.0,
                                "y": 0.0
                            },
                            "eyeLeftInner": {
                                "x": 0.0,
                                "y": 0.0
                            },
                            "eyeLeftOuter": {
                                "x": 0.0,
                                "y": 0.0
                            },
                            "eyeLeftTop": {
                                "x": 0.0,
                                "y": 0.0
                            },
                            "eyeRightBottom": {
                                "x": 0.0,
                                "y": 0.0
                            },
                            "eyeRightInner": {
                                "x": 0.0,
                                "y": 0.0
                            },
                            "eyeRightOuter": {
                                "x": 0.0,
                                "y": 0.0
                            },
                            "eyeRightTop": {
                                "x": 0.0,
                                "y": 0.0
                            },
                            "eyebrowLeftInner": {
                                "x": 0.0,
                                "y": 0.0
                            },
                            "eyebrowLeftOuter": {
                                "x": 0.0,
                                "y": 0.0
                            },
                            "eyebrowRightInner": {
                                "x": 0.0,
                                "y": 0.0
                            },
                            "eyebrowRightOuter": {
                                "x": 0.0,
                                "y": 0.0
                            },
                            "mouthLeft": {
                                "x": 0.0,
                                "y": 0.0
                            },
                            "mouthRight": {
                                "x": 0.0,
                                "y": 0.0
                            },
                            "noseLeftAlarOutTip": {
                                "x": 0.0,
                                "y": 0.0
                            },
                            "noseLeftAlarTop": {
                                "x": 0.0,
                                "y": 0.0
                            },
                            "noseRightAlarOutTip": {
                                "x": 0.0,
                                "y": 0.0
                            },
                            "noseRightAlarTop": {
                                "x": 0.0,
                                "y": 0.0
                            },
                            "noseRootLeft": {
                                "x": 0.0,
                                "y": 0.0
                            },
                            "noseRootRight": {
                                "x": 0.0,
                                "y": 0.0
                            },
                            "noseTip": {
                                "x": 0.0,
                                "y": 0.0
                            },
                            "pupilLeft": {
                                "x": 0.0,
                                "y": 0.0
                            },
                            "pupilRight": {
                                "x": 0.0,
                                "y": 0.0
                            },
                            "underLipBottom": {
                                "x": 0.0,
                                "y": 0.0
                            },
                            "underLipTop": {
                                "x": 0.0,
                                "y": 0.0
                            },
                            "upperLipBottom": {
                                "x": 0.0,
                                "y": 0.0
                            },
                            "upperLipTop": {
                                "x": 0.0,
                                "y": 0.0
                            }
                        },
                        "recognitionModel": "str"
                    }
                ]
        """
        error_map: MutableMapping[int, Type[HttpResponseError]] = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: str = kwargs.pop("content_type", _headers.pop("content-type", "application/octet-stream"))
        cls: ClsType[List[_models.FaceDetectionResult]] = kwargs.pop("cls", None)

        _content = image_content

        _request = build_face_detect_request(
            detection_model=detection_model,
            recognition_model=recognition_model,
            return_face_id=return_face_id,
            return_face_attributes=return_face_attributes,
            return_face_landmarks=return_face_landmarks,
            return_recognition_model=return_recognition_model,
            face_id_time_to_live=face_id_time_to_live,
            content_type=content_type,
            content=_content,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, "str", skip_quote=True),
            "apiVersion": self._serialize.url("self._config.api_version", self._config.api_version, "str"),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = kwargs.pop("stream", False)
        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                try:
                    response.read()  # Load the body in memory and close the socket
                except (StreamConsumedError, StreamClosedError):
                    pass
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = _deserialize(_models.FaceErrorResponse, response.json())
            raise HttpResponseError(response=response, model=error)

        if _stream:
            deserialized = response.iter_bytes()
        else:
            deserialized = _deserialize(List[_models.FaceDetectionResult], response.json())

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore

    @overload
    def find_similar(
        self, body: JSON, *, content_type: str = "application/json", **kwargs: Any
    ) -> List[_models.FaceFindSimilarResult]:
        """Given query face's faceId, to search the similar-looking faces from a faceId array. A faceId
        array contains the faces created by Detect.

        Depending on the input the returned similar faces list contains faceIds or persistedFaceIds
        ranked by similarity.

        Find similar has two working modes, "matchPerson" and "matchFace". "matchPerson" is the default
        mode that it tries to find faces of the same person as possible by using internal same-person
        thresholds. It is useful to find a known person's other photos. Note that an empty list will be
        returned if no faces pass the internal thresholds. "matchFace" mode ignores same-person
        thresholds and returns ranked similar faces anyway, even the similarity is low. It can be used
        in the cases like searching celebrity-looking faces.

        The 'recognitionModel' associated with the query faceId should be the same as the
        'recognitionModel' used by the target faceId array.

        :param body: Required.
        :type body: JSON
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: list of FaceFindSimilarResult
        :rtype: list[~azure.ai.vision.face.models.FaceFindSimilarResult]
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                body = {
                    "faceId": "str",
                    "faceIds": [
                        "str"
                    ],
                    "maxNumOfCandidatesReturned": 0,
                    "mode": "str"
                }

                # response body for status code(s): 200
                response == [
                    {
                        "confidence": 0.0,
                        "faceId": "str",
                        "persistedFaceId": "str"
                    }
                ]
        """

    @overload
    def find_similar(
        self,
        *,
        face_id: str,
        face_ids: List[str],
        content_type: str = "application/json",
        max_num_of_candidates_returned: Optional[int] = None,
        mode: Optional[Union[str, _models.FindSimilarMatchMode]] = None,
        **kwargs: Any,
    ) -> List[_models.FaceFindSimilarResult]:
        """Given query face's faceId, to search the similar-looking faces from a faceId array. A faceId
        array contains the faces created by Detect.

        Depending on the input the returned similar faces list contains faceIds or persistedFaceIds
        ranked by similarity.

        Find similar has two working modes, "matchPerson" and "matchFace". "matchPerson" is the default
        mode that it tries to find faces of the same person as possible by using internal same-person
        thresholds. It is useful to find a known person's other photos. Note that an empty list will be
        returned if no faces pass the internal thresholds. "matchFace" mode ignores same-person
        thresholds and returns ranked similar faces anyway, even the similarity is low. It can be used
        in the cases like searching celebrity-looking faces.

        The 'recognitionModel' associated with the query faceId should be the same as the
        'recognitionModel' used by the target faceId array.

        :keyword face_id: faceId of the query face. User needs to call "Detect" first to get a valid
         faceId. Note that this faceId is not persisted and will expire 24 hours after the detection
         call. Required.
        :paramtype face_id: str
        :keyword face_ids: An array of candidate faceIds. All of them are created by "Detect" and the
         faceIds will expire 24 hours after the detection call. The number of faceIds is limited to
         1000. Required.
        :paramtype face_ids: list[str]
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :keyword max_num_of_candidates_returned: The number of top similar faces returned. The valid
         range is [1, 1000]. Default value is 20. Default value is None.
        :paramtype max_num_of_candidates_returned: int
        :keyword mode: Similar face searching mode. It can be 'matchPerson' or 'matchFace'. Default
         value is 'matchPerson'. Known values are: "matchPerson" and "matchFace". Default value is None.
        :paramtype mode: str or ~azure.ai.vision.face.models.FindSimilarMatchMode
        :return: list of FaceFindSimilarResult
        :rtype: list[~azure.ai.vision.face.models.FaceFindSimilarResult]
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == [
                    {
                        "confidence": 0.0,
                        "faceId": "str",
                        "persistedFaceId": "str"
                    }
                ]
        """

    @overload
    def find_similar(
        self, body: IO[bytes], *, content_type: str = "application/json", **kwargs: Any
    ) -> List[_models.FaceFindSimilarResult]:
        """Given query face's faceId, to search the similar-looking faces from a faceId array. A faceId
        array contains the faces created by Detect.

        Depending on the input the returned similar faces list contains faceIds or persistedFaceIds
        ranked by similarity.

        Find similar has two working modes, "matchPerson" and "matchFace". "matchPerson" is the default
        mode that it tries to find faces of the same person as possible by using internal same-person
        thresholds. It is useful to find a known person's other photos. Note that an empty list will be
        returned if no faces pass the internal thresholds. "matchFace" mode ignores same-person
        thresholds and returns ranked similar faces anyway, even the similarity is low. It can be used
        in the cases like searching celebrity-looking faces.

        The 'recognitionModel' associated with the query faceId should be the same as the
        'recognitionModel' used by the target faceId array.

        :param body: Required.
        :type body: IO[bytes]
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: list of FaceFindSimilarResult
        :rtype: list[~azure.ai.vision.face.models.FaceFindSimilarResult]
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == [
                    {
                        "confidence": 0.0,
                        "faceId": "str",
                        "persistedFaceId": "str"
                    }
                ]
        """

    @distributed_trace
    def find_similar(
        self,
        body: Union[JSON, IO[bytes]] = _Unset,
        *,
        face_id: str = _Unset,
        face_ids: List[str] = _Unset,
        max_num_of_candidates_returned: Optional[int] = None,
        mode: Optional[Union[str, _models.FindSimilarMatchMode]] = None,
        **kwargs: Any,
    ) -> List[_models.FaceFindSimilarResult]:
        """Given query face's faceId, to search the similar-looking faces from a faceId array. A faceId
        array contains the faces created by Detect.

        Depending on the input the returned similar faces list contains faceIds or persistedFaceIds
        ranked by similarity.

        Find similar has two working modes, "matchPerson" and "matchFace". "matchPerson" is the default
        mode that it tries to find faces of the same person as possible by using internal same-person
        thresholds. It is useful to find a known person's other photos. Note that an empty list will be
        returned if no faces pass the internal thresholds. "matchFace" mode ignores same-person
        thresholds and returns ranked similar faces anyway, even the similarity is low. It can be used
        in the cases like searching celebrity-looking faces.

        The 'recognitionModel' associated with the query faceId should be the same as the
        'recognitionModel' used by the target faceId array.

        :param body: Is either a JSON type or a IO[bytes] type. Required.
        :type body: JSON or IO[bytes]
        :keyword face_id: faceId of the query face. User needs to call "Detect" first to get a valid
         faceId. Note that this faceId is not persisted and will expire 24 hours after the detection
         call. Required.
        :paramtype face_id: str
        :keyword face_ids: An array of candidate faceIds. All of them are created by "Detect" and the
         faceIds will expire 24 hours after the detection call. The number of faceIds is limited to
         1000. Required.
        :paramtype face_ids: list[str]
        :keyword max_num_of_candidates_returned: The number of top similar faces returned. The valid
         range is [1, 1000]. Default value is 20. Default value is None.
        :paramtype max_num_of_candidates_returned: int
        :keyword mode: Similar face searching mode. It can be 'matchPerson' or 'matchFace'. Default
         value is 'matchPerson'. Known values are: "matchPerson" and "matchFace". Default value is None.
        :paramtype mode: str or ~azure.ai.vision.face.models.FindSimilarMatchMode
        :return: list of FaceFindSimilarResult
        :rtype: list[~azure.ai.vision.face.models.FaceFindSimilarResult]
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                body = {
                    "faceId": "str",
                    "faceIds": [
                        "str"
                    ],
                    "maxNumOfCandidatesReturned": 0,
                    "mode": "str"
                }

                # response body for status code(s): 200
                response == [
                    {
                        "confidence": 0.0,
                        "faceId": "str",
                        "persistedFaceId": "str"
                    }
                ]
        """
        error_map: MutableMapping[int, Type[HttpResponseError]] = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[List[_models.FaceFindSimilarResult]] = kwargs.pop("cls", None)

        if body is _Unset:
            if face_id is _Unset:
                raise TypeError("missing required argument: face_id")
            if face_ids is _Unset:
                raise TypeError("missing required argument: face_ids")
            body = {
                "faceId": face_id,
                "faceIds": face_ids,
                "maxNumOfCandidatesReturned": max_num_of_candidates_returned,
                "mode": mode,
            }
            body = {k: v for k, v in body.items() if v is not None}
        content_type = content_type or "application/json"
        _content = None
        if isinstance(body, (IOBase, bytes)):
            _content = body
        else:
            _content = json.dumps(body, cls=SdkJSONEncoder, exclude_readonly=True)  # type: ignore

        _request = build_face_find_similar_request(
            content_type=content_type,
            content=_content,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, "str", skip_quote=True),
            "apiVersion": self._serialize.url("self._config.api_version", self._config.api_version, "str"),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = kwargs.pop("stream", False)
        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                try:
                    response.read()  # Load the body in memory and close the socket
                except (StreamConsumedError, StreamClosedError):
                    pass
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = _deserialize(_models.FaceErrorResponse, response.json())
            raise HttpResponseError(response=response, model=error)

        if _stream:
            deserialized = response.iter_bytes()
        else:
            deserialized = _deserialize(List[_models.FaceFindSimilarResult], response.json())

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore

    @overload
    def verify_face_to_face(
        self, body: JSON, *, content_type: str = "application/json", **kwargs: Any
    ) -> _models.FaceVerificationResult:
        """Verify whether two faces belong to a same person.

        ..

           [!NOTE]

           *


           * Higher face image quality means better identification precision. Please consider
        high-quality faces: frontal, clear, and face size is 200x200 pixels (100 pixels between eyes)
        or bigger.
           * For the scenarios that are sensitive to accuracy please make your own judgment.
           * The 'recognitionModel' associated with the both faces should be the same.

        :param body: Required.
        :type body: JSON
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: FaceVerificationResult. The FaceVerificationResult is compatible with MutableMapping
        :rtype: ~azure.ai.vision.face.models.FaceVerificationResult
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                body = {
                    "faceId1": "str",
                    "faceId2": "str"
                }

                # response body for status code(s): 200
                response == {
                    "confidence": 0.0,
                    "isIdentical": bool
                }
        """

    @overload
    def verify_face_to_face(
        self, *, face_id1: str, face_id2: str, content_type: str = "application/json", **kwargs: Any
    ) -> _models.FaceVerificationResult:
        """Verify whether two faces belong to a same person.

        ..

           [!NOTE]

           *


           * Higher face image quality means better identification precision. Please consider
        high-quality faces: frontal, clear, and face size is 200x200 pixels (100 pixels between eyes)
        or bigger.
           * For the scenarios that are sensitive to accuracy please make your own judgment.
           * The 'recognitionModel' associated with the both faces should be the same.

        :keyword face_id1: The faceId of one face, come from "Detect". Required.
        :paramtype face_id1: str
        :keyword face_id2: The faceId of another face, come from "Detect". Required.
        :paramtype face_id2: str
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: FaceVerificationResult. The FaceVerificationResult is compatible with MutableMapping
        :rtype: ~azure.ai.vision.face.models.FaceVerificationResult
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "confidence": 0.0,
                    "isIdentical": bool
                }
        """

    @overload
    def verify_face_to_face(
        self, body: IO[bytes], *, content_type: str = "application/json", **kwargs: Any
    ) -> _models.FaceVerificationResult:
        """Verify whether two faces belong to a same person.

        ..

           [!NOTE]

           *


           * Higher face image quality means better identification precision. Please consider
        high-quality faces: frontal, clear, and face size is 200x200 pixels (100 pixels between eyes)
        or bigger.
           * For the scenarios that are sensitive to accuracy please make your own judgment.
           * The 'recognitionModel' associated with the both faces should be the same.

        :param body: Required.
        :type body: IO[bytes]
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: FaceVerificationResult. The FaceVerificationResult is compatible with MutableMapping
        :rtype: ~azure.ai.vision.face.models.FaceVerificationResult
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "confidence": 0.0,
                    "isIdentical": bool
                }
        """

    @distributed_trace
    def verify_face_to_face(
        self, body: Union[JSON, IO[bytes]] = _Unset, *, face_id1: str = _Unset, face_id2: str = _Unset, **kwargs: Any
    ) -> _models.FaceVerificationResult:
        """Verify whether two faces belong to a same person.

        ..

           [!NOTE]

           *


           * Higher face image quality means better identification precision. Please consider
        high-quality faces: frontal, clear, and face size is 200x200 pixels (100 pixels between eyes)
        or bigger.
           * For the scenarios that are sensitive to accuracy please make your own judgment.
           * The 'recognitionModel' associated with the both faces should be the same.

        :param body: Is either a JSON type or a IO[bytes] type. Required.
        :type body: JSON or IO[bytes]
        :keyword face_id1: The faceId of one face, come from "Detect". Required.
        :paramtype face_id1: str
        :keyword face_id2: The faceId of another face, come from "Detect". Required.
        :paramtype face_id2: str
        :return: FaceVerificationResult. The FaceVerificationResult is compatible with MutableMapping
        :rtype: ~azure.ai.vision.face.models.FaceVerificationResult
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                body = {
                    "faceId1": "str",
                    "faceId2": "str"
                }

                # response body for status code(s): 200
                response == {
                    "confidence": 0.0,
                    "isIdentical": bool
                }
        """
        error_map: MutableMapping[int, Type[HttpResponseError]] = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[_models.FaceVerificationResult] = kwargs.pop("cls", None)

        if body is _Unset:
            if face_id1 is _Unset:
                raise TypeError("missing required argument: face_id1")
            if face_id2 is _Unset:
                raise TypeError("missing required argument: face_id2")
            body = {"faceId1": face_id1, "faceId2": face_id2}
            body = {k: v for k, v in body.items() if v is not None}
        content_type = content_type or "application/json"
        _content = None
        if isinstance(body, (IOBase, bytes)):
            _content = body
        else:
            _content = json.dumps(body, cls=SdkJSONEncoder, exclude_readonly=True)  # type: ignore

        _request = build_face_verify_face_to_face_request(
            content_type=content_type,
            content=_content,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, "str", skip_quote=True),
            "apiVersion": self._serialize.url("self._config.api_version", self._config.api_version, "str"),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = kwargs.pop("stream", False)
        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                try:
                    response.read()  # Load the body in memory and close the socket
                except (StreamConsumedError, StreamClosedError):
                    pass
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = _deserialize(_models.FaceErrorResponse, response.json())
            raise HttpResponseError(response=response, model=error)

        if _stream:
            deserialized = response.iter_bytes()
        else:
            deserialized = _deserialize(_models.FaceVerificationResult, response.json())

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore

    @overload
    def group(self, body: JSON, *, content_type: str = "application/json", **kwargs: Any) -> _models.FaceGroupingResult:
        """Divide candidate faces into groups based on face similarity.

        >
        *


        * The output is one or more disjointed face groups and a messyGroup. A face group contains
        faces that have similar looking, often of the same person. Face groups are ranked by group
        size, i.e. number of faces. Notice that faces belonging to a same person might be split into
        several groups in the result.
        * MessyGroup is a special face group containing faces that cannot find any similar counterpart
        face from original faces. The messyGroup will not appear in the result if all faces found their
        counterparts.
        * Group API needs at least 2 candidate faces and 1000 at most. We suggest to try "Verify Face
        To Face" when you only have 2 candidate faces.
        * The 'recognitionModel' associated with the query faces' faceIds should be the same.

        :param body: Required.
        :type body: JSON
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: FaceGroupingResult. The FaceGroupingResult is compatible with MutableMapping
        :rtype: ~azure.ai.vision.face.models.FaceGroupingResult
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                body = {
                    "faceIds": [
                        "str"
                    ]
                }

                # response body for status code(s): 200
                response == {
                    "groups": [
                        [
                            "str"
                        ]
                    ],
                    "messyGroup": [
                        "str"
                    ]
                }
        """

    @overload
    def group(
        self, *, face_ids: List[str], content_type: str = "application/json", **kwargs: Any
    ) -> _models.FaceGroupingResult:
        """Divide candidate faces into groups based on face similarity.

        >
        *


        * The output is one or more disjointed face groups and a messyGroup. A face group contains
        faces that have similar looking, often of the same person. Face groups are ranked by group
        size, i.e. number of faces. Notice that faces belonging to a same person might be split into
        several groups in the result.
        * MessyGroup is a special face group containing faces that cannot find any similar counterpart
        face from original faces. The messyGroup will not appear in the result if all faces found their
        counterparts.
        * Group API needs at least 2 candidate faces and 1000 at most. We suggest to try "Verify Face
        To Face" when you only have 2 candidate faces.
        * The 'recognitionModel' associated with the query faces' faceIds should be the same.

        :keyword face_ids: Array of candidate faceIds created by "Detect". The maximum is 1000 faces.
         Required.
        :paramtype face_ids: list[str]
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: FaceGroupingResult. The FaceGroupingResult is compatible with MutableMapping
        :rtype: ~azure.ai.vision.face.models.FaceGroupingResult
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "groups": [
                        [
                            "str"
                        ]
                    ],
                    "messyGroup": [
                        "str"
                    ]
                }
        """

    @overload
    def group(
        self, body: IO[bytes], *, content_type: str = "application/json", **kwargs: Any
    ) -> _models.FaceGroupingResult:
        """Divide candidate faces into groups based on face similarity.

        >
        *


        * The output is one or more disjointed face groups and a messyGroup. A face group contains
        faces that have similar looking, often of the same person. Face groups are ranked by group
        size, i.e. number of faces. Notice that faces belonging to a same person might be split into
        several groups in the result.
        * MessyGroup is a special face group containing faces that cannot find any similar counterpart
        face from original faces. The messyGroup will not appear in the result if all faces found their
        counterparts.
        * Group API needs at least 2 candidate faces and 1000 at most. We suggest to try "Verify Face
        To Face" when you only have 2 candidate faces.
        * The 'recognitionModel' associated with the query faces' faceIds should be the same.

        :param body: Required.
        :type body: IO[bytes]
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: FaceGroupingResult. The FaceGroupingResult is compatible with MutableMapping
        :rtype: ~azure.ai.vision.face.models.FaceGroupingResult
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "groups": [
                        [
                            "str"
                        ]
                    ],
                    "messyGroup": [
                        "str"
                    ]
                }
        """

    @distributed_trace
    def group(
        self, body: Union[JSON, IO[bytes]] = _Unset, *, face_ids: List[str] = _Unset, **kwargs: Any
    ) -> _models.FaceGroupingResult:
        """Divide candidate faces into groups based on face similarity.

        >
        *


        * The output is one or more disjointed face groups and a messyGroup. A face group contains
        faces that have similar looking, often of the same person. Face groups are ranked by group
        size, i.e. number of faces. Notice that faces belonging to a same person might be split into
        several groups in the result.
        * MessyGroup is a special face group containing faces that cannot find any similar counterpart
        face from original faces. The messyGroup will not appear in the result if all faces found their
        counterparts.
        * Group API needs at least 2 candidate faces and 1000 at most. We suggest to try "Verify Face
        To Face" when you only have 2 candidate faces.
        * The 'recognitionModel' associated with the query faces' faceIds should be the same.

        :param body: Is either a JSON type or a IO[bytes] type. Required.
        :type body: JSON or IO[bytes]
        :keyword face_ids: Array of candidate faceIds created by "Detect". The maximum is 1000 faces.
         Required.
        :paramtype face_ids: list[str]
        :return: FaceGroupingResult. The FaceGroupingResult is compatible with MutableMapping
        :rtype: ~azure.ai.vision.face.models.FaceGroupingResult
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                body = {
                    "faceIds": [
                        "str"
                    ]
                }

                # response body for status code(s): 200
                response == {
                    "groups": [
                        [
                            "str"
                        ]
                    ],
                    "messyGroup": [
                        "str"
                    ]
                }
        """
        error_map: MutableMapping[int, Type[HttpResponseError]] = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[_models.FaceGroupingResult] = kwargs.pop("cls", None)

        if body is _Unset:
            if face_ids is _Unset:
                raise TypeError("missing required argument: face_ids")
            body = {"faceIds": face_ids}
            body = {k: v for k, v in body.items() if v is not None}
        content_type = content_type or "application/json"
        _content = None
        if isinstance(body, (IOBase, bytes)):
            _content = body
        else:
            _content = json.dumps(body, cls=SdkJSONEncoder, exclude_readonly=True)  # type: ignore

        _request = build_face_group_request(
            content_type=content_type,
            content=_content,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, "str", skip_quote=True),
            "apiVersion": self._serialize.url("self._config.api_version", self._config.api_version, "str"),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = kwargs.pop("stream", False)
        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                try:
                    response.read()  # Load the body in memory and close the socket
                except (StreamConsumedError, StreamClosedError):
                    pass
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = _deserialize(_models.FaceErrorResponse, response.json())
            raise HttpResponseError(response=response, model=error)

        if _stream:
            deserialized = response.iter_bytes()
        else:
            deserialized = _deserialize(_models.FaceGroupingResult, response.json())

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore


class FaceSessionClientOperationsMixin(FaceSessionClientMixinABC):

    @overload
    def create_liveness_session(
        self, body: _models.CreateLivenessSessionContent, *, content_type: str = "application/json", **kwargs: Any
    ) -> _models.CreateLivenessSessionResult:
        """Create a new detect liveness session.

        A session is best for client device scenarios where developers want to authorize a client
        device to perform only a liveness detection without granting full access to their resource.
        Created sessions have a limited life span and only authorize clients to perform the desired
        action before access is expired.

        Permissions includes...
        >
        *


        * Ability to call /detectLiveness/singleModal for up to 3 retries.
        * A token lifetime of 10 minutes.

        ..

           [!NOTE]
           Client access can be revoked by deleting the session using the Delete Liveness Session
        operation. To retrieve a result, use the Get Liveness Session. To audit the individual requests
        that a client has made to your resource, use the List Liveness Session Audit Entries.

        :param body: Body parameter. Required.
        :type body: ~azure.ai.vision.face.models.CreateLivenessSessionContent
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: CreateLivenessSessionResult. The CreateLivenessSessionResult is compatible with
         MutableMapping
        :rtype: ~azure.ai.vision.face.models.CreateLivenessSessionResult
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                body = {
                    "livenessOperationMode": "str",
                    "authTokenTimeToLiveInSeconds": 0,
                    "deviceCorrelationId": "str",
                    "deviceCorrelationIdSetInClient": bool,
                    "sendResultsToClient": bool
                }

                # response body for status code(s): 200
                response == {
                    "authToken": "str",
                    "sessionId": "str"
                }
        """

    @overload
    def create_liveness_session(
        self, body: JSON, *, content_type: str = "application/json", **kwargs: Any
    ) -> _models.CreateLivenessSessionResult:
        """Create a new detect liveness session.

        A session is best for client device scenarios where developers want to authorize a client
        device to perform only a liveness detection without granting full access to their resource.
        Created sessions have a limited life span and only authorize clients to perform the desired
        action before access is expired.

        Permissions includes...
        >
        *


        * Ability to call /detectLiveness/singleModal for up to 3 retries.
        * A token lifetime of 10 minutes.

        ..

           [!NOTE]
           Client access can be revoked by deleting the session using the Delete Liveness Session
        operation. To retrieve a result, use the Get Liveness Session. To audit the individual requests
        that a client has made to your resource, use the List Liveness Session Audit Entries.

        :param body: Body parameter. Required.
        :type body: JSON
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: CreateLivenessSessionResult. The CreateLivenessSessionResult is compatible with
         MutableMapping
        :rtype: ~azure.ai.vision.face.models.CreateLivenessSessionResult
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "authToken": "str",
                    "sessionId": "str"
                }
        """

    @overload
    def create_liveness_session(
        self, body: IO[bytes], *, content_type: str = "application/json", **kwargs: Any
    ) -> _models.CreateLivenessSessionResult:
        """Create a new detect liveness session.

        A session is best for client device scenarios where developers want to authorize a client
        device to perform only a liveness detection without granting full access to their resource.
        Created sessions have a limited life span and only authorize clients to perform the desired
        action before access is expired.

        Permissions includes...
        >
        *


        * Ability to call /detectLiveness/singleModal for up to 3 retries.
        * A token lifetime of 10 minutes.

        ..

           [!NOTE]
           Client access can be revoked by deleting the session using the Delete Liveness Session
        operation. To retrieve a result, use the Get Liveness Session. To audit the individual requests
        that a client has made to your resource, use the List Liveness Session Audit Entries.

        :param body: Body parameter. Required.
        :type body: IO[bytes]
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: CreateLivenessSessionResult. The CreateLivenessSessionResult is compatible with
         MutableMapping
        :rtype: ~azure.ai.vision.face.models.CreateLivenessSessionResult
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "authToken": "str",
                    "sessionId": "str"
                }
        """

    @distributed_trace
    def create_liveness_session(
        self, body: Union[_models.CreateLivenessSessionContent, JSON, IO[bytes]], **kwargs: Any
    ) -> _models.CreateLivenessSessionResult:
        """Create a new detect liveness session.

        A session is best for client device scenarios where developers want to authorize a client
        device to perform only a liveness detection without granting full access to their resource.
        Created sessions have a limited life span and only authorize clients to perform the desired
        action before access is expired.

        Permissions includes...
        >
        *


        * Ability to call /detectLiveness/singleModal for up to 3 retries.
        * A token lifetime of 10 minutes.

        ..

           [!NOTE]
           Client access can be revoked by deleting the session using the Delete Liveness Session
        operation. To retrieve a result, use the Get Liveness Session. To audit the individual requests
        that a client has made to your resource, use the List Liveness Session Audit Entries.

        :param body: Body parameter. Is one of the following types: CreateLivenessSessionContent, JSON,
         IO[bytes] Required.
        :type body: ~azure.ai.vision.face.models.CreateLivenessSessionContent or JSON or IO[bytes]
        :return: CreateLivenessSessionResult. The CreateLivenessSessionResult is compatible with
         MutableMapping
        :rtype: ~azure.ai.vision.face.models.CreateLivenessSessionResult
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                body = {
                    "livenessOperationMode": "str",
                    "authTokenTimeToLiveInSeconds": 0,
                    "deviceCorrelationId": "str",
                    "deviceCorrelationIdSetInClient": bool,
                    "sendResultsToClient": bool
                }

                # response body for status code(s): 200
                response == {
                    "authToken": "str",
                    "sessionId": "str"
                }
        """
        error_map: MutableMapping[int, Type[HttpResponseError]] = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[_models.CreateLivenessSessionResult] = kwargs.pop("cls", None)

        content_type = content_type or "application/json"
        _content = None
        if isinstance(body, (IOBase, bytes)):
            _content = body
        else:
            _content = json.dumps(body, cls=SdkJSONEncoder, exclude_readonly=True)  # type: ignore

        _request = build_face_session_create_liveness_session_request(
            content_type=content_type,
            content=_content,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, "str", skip_quote=True),
            "apiVersion": self._serialize.url("self._config.api_version", self._config.api_version, "str"),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = kwargs.pop("stream", False)
        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                try:
                    response.read()  # Load the body in memory and close the socket
                except (StreamConsumedError, StreamClosedError):
                    pass
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = _deserialize(_models.FaceErrorResponse, response.json())
            raise HttpResponseError(response=response, model=error)

        if _stream:
            deserialized = response.iter_bytes()
        else:
            deserialized = _deserialize(_models.CreateLivenessSessionResult, response.json())

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore

    @distributed_trace
    def delete_liveness_session(  # pylint: disable=inconsistent-return-statements
        self, session_id: str, **kwargs: Any
    ) -> None:
        """Delete all session related information for matching the specified session id.

        ..

           [!NOTE]
           Deleting a session deactivates the Session Auth Token by blocking future API calls made with
        that Auth Token. While this can be used to remove any access for that token, those requests
        will still count towards overall resource rate limits. It's best to leverage TokenTTL to limit
        length of tokens in the case that it is misused.

        :param session_id: The unique ID to reference this session. Required.
        :type session_id: str
        :return: None
        :rtype: None
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping[int, Type[HttpResponseError]] = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[None] = kwargs.pop("cls", None)

        _request = build_face_session_delete_liveness_session_request(
            session_id=session_id,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, "str", skip_quote=True),
            "apiVersion": self._serialize.url("self._config.api_version", self._config.api_version, "str"),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = False
        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = _deserialize(_models.FaceErrorResponse, response.json())
            raise HttpResponseError(response=response, model=error)

        if cls:
            return cls(pipeline_response, None, {})  # type: ignore

    @distributed_trace
    def get_liveness_session_result(self, session_id: str, **kwargs: Any) -> _models.LivenessSession:
        """Get session result of detectLiveness/singleModal call.

        :param session_id: The unique ID to reference this session. Required.
        :type session_id: str
        :return: LivenessSession. The LivenessSession is compatible with MutableMapping
        :rtype: ~azure.ai.vision.face.models.LivenessSession
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "createdDateTime": "2020-02-20 00:00:00",
                    "id": "str",
                    "sessionExpired": bool,
                    "status": "str",
                    "authTokenTimeToLiveInSeconds": 0,
                    "deviceCorrelationId": "str",
                    "result": {
                        "clientRequestId": "str",
                        "digest": "str",
                        "id": 0,
                        "receivedDateTime": "2020-02-20 00:00:00",
                        "request": {
                            "contentType": "str",
                            "method": "str",
                            "url": "str",
                            "contentLength": 0,
                            "userAgent": "str"
                        },
                        "requestId": "str",
                        "response": {
                            "body": {
                                "livenessDecision": "str",
                                "modelVersionUsed": "str",
                                "target": {
                                    "faceRectangle": {
                                        "height": 0,
                                        "left": 0,
                                        "top": 0,
                                        "width": 0
                                    },
                                    "fileName": "str",
                                    "imageType": "str",
                                    "timeOffsetWithinFile": 0
                                },
                                "verifyResult": {
                                    "isIdentical": bool,
                                    "matchConfidence": 0.0,
                                    "verifyImage": {
                                        "faceRectangle": {
                                            "height": 0,
                                            "left": 0,
                                            "top": 0,
                                            "width": 0
                                        },
                                        "qualityForRecognition": "str"
                                    }
                                }
                            },
                            "latencyInMilliseconds": 0,
                            "statusCode": 0
                        },
                        "sessionId": "str"
                    },
                    "sessionStartDateTime": "2020-02-20 00:00:00"
                }
        """
        error_map: MutableMapping[int, Type[HttpResponseError]] = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[_models.LivenessSession] = kwargs.pop("cls", None)

        _request = build_face_session_get_liveness_session_result_request(
            session_id=session_id,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, "str", skip_quote=True),
            "apiVersion": self._serialize.url("self._config.api_version", self._config.api_version, "str"),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = kwargs.pop("stream", False)
        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                try:
                    response.read()  # Load the body in memory and close the socket
                except (StreamConsumedError, StreamClosedError):
                    pass
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = _deserialize(_models.FaceErrorResponse, response.json())
            raise HttpResponseError(response=response, model=error)

        if _stream:
            deserialized = response.iter_bytes()
        else:
            deserialized = _deserialize(_models.LivenessSession, response.json())

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore

    @distributed_trace
    def get_liveness_sessions(
        self, *, start: Optional[str] = None, top: Optional[int] = None, **kwargs: Any
    ) -> List[_models.LivenessSessionItem]:
        """Lists sessions for /detectLiveness/SingleModal.

        List sessions from the last sessionId greater than the 'start'.

        The result should be ordered by sessionId in ascending order.

        :keyword start: List resources greater than the "start". It contains no more than 64
         characters. Default is empty. Default value is None.
        :paramtype start: str
        :keyword top: The number of items to list, ranging in [1, 1000]. Default is 1000. Default value
         is None.
        :paramtype top: int
        :return: list of LivenessSessionItem
        :rtype: list[~azure.ai.vision.face.models.LivenessSessionItem]
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == [
                    {
                        "createdDateTime": "2020-02-20 00:00:00",
                        "id": "str",
                        "sessionExpired": bool,
                        "authTokenTimeToLiveInSeconds": 0,
                        "deviceCorrelationId": "str",
                        "sessionStartDateTime": "2020-02-20 00:00:00"
                    }
                ]
        """
        error_map: MutableMapping[int, Type[HttpResponseError]] = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[List[_models.LivenessSessionItem]] = kwargs.pop("cls", None)

        _request = build_face_session_get_liveness_sessions_request(
            start=start,
            top=top,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, "str", skip_quote=True),
            "apiVersion": self._serialize.url("self._config.api_version", self._config.api_version, "str"),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = kwargs.pop("stream", False)
        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                try:
                    response.read()  # Load the body in memory and close the socket
                except (StreamConsumedError, StreamClosedError):
                    pass
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = _deserialize(_models.FaceErrorResponse, response.json())
            raise HttpResponseError(response=response, model=error)

        if _stream:
            deserialized = response.iter_bytes()
        else:
            deserialized = _deserialize(List[_models.LivenessSessionItem], response.json())

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore

    @distributed_trace
    def get_liveness_session_audit_entries(
        self, session_id: str, *, start: Optional[str] = None, top: Optional[int] = None, **kwargs: Any
    ) -> List[_models.LivenessSessionAuditEntry]:
        """Gets session requests and response body for the session.

        :param session_id: The unique ID to reference this session. Required.
        :type session_id: str
        :keyword start: List resources greater than the "start". It contains no more than 64
         characters. Default is empty. Default value is None.
        :paramtype start: str
        :keyword top: The number of items to list, ranging in [1, 1000]. Default is 1000. Default value
         is None.
        :paramtype top: int
        :return: list of LivenessSessionAuditEntry
        :rtype: list[~azure.ai.vision.face.models.LivenessSessionAuditEntry]
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == [
                    {
                        "clientRequestId": "str",
                        "digest": "str",
                        "id": 0,
                        "receivedDateTime": "2020-02-20 00:00:00",
                        "request": {
                            "contentType": "str",
                            "method": "str",
                            "url": "str",
                            "contentLength": 0,
                            "userAgent": "str"
                        },
                        "requestId": "str",
                        "response": {
                            "body": {
                                "livenessDecision": "str",
                                "modelVersionUsed": "str",
                                "target": {
                                    "faceRectangle": {
                                        "height": 0,
                                        "left": 0,
                                        "top": 0,
                                        "width": 0
                                    },
                                    "fileName": "str",
                                    "imageType": "str",
                                    "timeOffsetWithinFile": 0
                                },
                                "verifyResult": {
                                    "isIdentical": bool,
                                    "matchConfidence": 0.0,
                                    "verifyImage": {
                                        "faceRectangle": {
                                            "height": 0,
                                            "left": 0,
                                            "top": 0,
                                            "width": 0
                                        },
                                        "qualityForRecognition": "str"
                                    }
                                }
                            },
                            "latencyInMilliseconds": 0,
                            "statusCode": 0
                        },
                        "sessionId": "str"
                    }
                ]
        """
        error_map: MutableMapping[int, Type[HttpResponseError]] = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[List[_models.LivenessSessionAuditEntry]] = kwargs.pop("cls", None)

        _request = build_face_session_get_liveness_session_audit_entries_request(
            session_id=session_id,
            start=start,
            top=top,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, "str", skip_quote=True),
            "apiVersion": self._serialize.url("self._config.api_version", self._config.api_version, "str"),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = kwargs.pop("stream", False)
        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                try:
                    response.read()  # Load the body in memory and close the socket
                except (StreamConsumedError, StreamClosedError):
                    pass
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = _deserialize(_models.FaceErrorResponse, response.json())
            raise HttpResponseError(response=response, model=error)

        if _stream:
            deserialized = response.iter_bytes()
        else:
            deserialized = _deserialize(List[_models.LivenessSessionAuditEntry], response.json())

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore

    @overload
    def _create_liveness_with_verify_session(
        self, body: _models.CreateLivenessSessionContent, *, content_type: str = "application/json", **kwargs: Any
    ) -> _models.CreateLivenessWithVerifySessionResult: ...
    @overload
    def _create_liveness_with_verify_session(
        self, body: JSON, *, content_type: str = "application/json", **kwargs: Any
    ) -> _models.CreateLivenessWithVerifySessionResult: ...
    @overload
    def _create_liveness_with_verify_session(
        self, body: IO[bytes], *, content_type: str = "application/json", **kwargs: Any
    ) -> _models.CreateLivenessWithVerifySessionResult: ...

    @distributed_trace
    def _create_liveness_with_verify_session(
        self, body: Union[_models.CreateLivenessSessionContent, JSON, IO[bytes]], **kwargs: Any
    ) -> _models.CreateLivenessWithVerifySessionResult:
        """Create a new liveness session with verify. Client device submits VerifyImage during the
        /detectLivenessWithVerify/singleModal call.

        A session is best for client device scenarios where developers want to authorize a client
        device to perform only a liveness detection without granting full access to their resource.
        Created sessions have a limited life span and only authorize clients to perform the desired
        action before access is expired.

        Permissions includes...
        >
        *


        * Ability to call /detectLivenessWithVerify/singleModal for up to 3 retries.
        * A token lifetime of 10 minutes.

        ..

           [!NOTE]

           *


           * Client access can be revoked by deleting the session using the Delete Liveness With Verify
        Session operation.
           * To retrieve a result, use the Get Liveness With Verify Session.
           * To audit the individual requests that a client has made to your resource, use the List
        Liveness With Verify Session Audit Entries.


        Alternative Option: Client device submits VerifyImage during the
        /detectLivenessWithVerify/singleModal call.

        ..

           [!NOTE]
           Extra measures should be taken to validate that the client is sending the expected
        VerifyImage.

        :param body: Body parameter. Is one of the following types: CreateLivenessSessionContent, JSON,
         IO[bytes] Required.
        :type body: ~azure.ai.vision.face.models.CreateLivenessSessionContent or JSON or IO[bytes]
        :return: CreateLivenessWithVerifySessionResult. The CreateLivenessWithVerifySessionResult is
         compatible with MutableMapping
        :rtype: ~azure.ai.vision.face.models.CreateLivenessWithVerifySessionResult
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                body = {
                    "livenessOperationMode": "str",
                    "authTokenTimeToLiveInSeconds": 0,
                    "deviceCorrelationId": "str",
                    "deviceCorrelationIdSetInClient": bool,
                    "sendResultsToClient": bool
                }

                # response body for status code(s): 200
                response == {
                    "authToken": "str",
                    "sessionId": "str",
                    "verifyImage": {
                        "faceRectangle": {
                            "height": 0,
                            "left": 0,
                            "top": 0,
                            "width": 0
                        },
                        "qualityForRecognition": "str"
                    }
                }
        """
        error_map: MutableMapping[int, Type[HttpResponseError]] = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[_models.CreateLivenessWithVerifySessionResult] = kwargs.pop("cls", None)

        content_type = content_type or "application/json"
        _content = None
        if isinstance(body, (IOBase, bytes)):
            _content = body
        else:
            _content = json.dumps(body, cls=SdkJSONEncoder, exclude_readonly=True)  # type: ignore

        _request = build_face_session_create_liveness_with_verify_session_request(
            content_type=content_type,
            content=_content,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, "str", skip_quote=True),
            "apiVersion": self._serialize.url("self._config.api_version", self._config.api_version, "str"),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = kwargs.pop("stream", False)
        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                try:
                    response.read()  # Load the body in memory and close the socket
                except (StreamConsumedError, StreamClosedError):
                    pass
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = _deserialize(_models.FaceErrorResponse, response.json())
            raise HttpResponseError(response=response, model=error)

        if _stream:
            deserialized = response.iter_bytes()
        else:
            deserialized = _deserialize(_models.CreateLivenessWithVerifySessionResult, response.json())

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore

    @overload
    def _create_liveness_with_verify_session_with_verify_image(  # pylint: disable=protected-access,name-too-long
        self, body: _models._models.CreateLivenessWithVerifySessionContent, **kwargs: Any
    ) -> _models.CreateLivenessWithVerifySessionResult: ...
    @overload
    def _create_liveness_with_verify_session_with_verify_image(  # pylint: disable=name-too-long
        self, body: JSON, **kwargs: Any
    ) -> _models.CreateLivenessWithVerifySessionResult: ...

    @distributed_trace
    def _create_liveness_with_verify_session_with_verify_image(  # pylint: disable=name-too-long
        self, body: Union[_models._models.CreateLivenessWithVerifySessionContent, JSON], **kwargs: Any
    ) -> _models.CreateLivenessWithVerifySessionResult:
        """Create a new liveness session with verify. Provide the verify image during session creation.

        A session is best for client device scenarios where developers want to authorize a client
        device to perform only a liveness detection without granting full access to their resource.
        Created sessions have a limited life span and only authorize clients to perform the desired
        action before access is expired.

        Permissions includes...
        >
        *


        * Ability to call /detectLivenessWithVerify/singleModal for up to 3 retries.
        * A token lifetime of 10 minutes.

        ..

           [!NOTE]

           *


           * Client access can be revoked by deleting the session using the Delete Liveness With Verify
        Session operation.
           * To retrieve a result, use the Get Liveness With Verify Session.
           * To audit the individual requests that a client has made to your resource, use the List
        Liveness With Verify Session Audit Entries.


        Recommended Option: VerifyImage is provided during session creation.

        :param body: Request content of liveness with verify session creation. Is either a
         CreateLivenessWithVerifySessionContent type or a JSON type. Required.
        :type body: ~azure.ai.vision.face.models._models.CreateLivenessWithVerifySessionContent or JSON
        :return: CreateLivenessWithVerifySessionResult. The CreateLivenessWithVerifySessionResult is
         compatible with MutableMapping
        :rtype: ~azure.ai.vision.face.models.CreateLivenessWithVerifySessionResult
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                body = {
                    "Parameters": {
                        "livenessOperationMode": "str",
                        "authTokenTimeToLiveInSeconds": 0,
                        "deviceCorrelationId": "str",
                        "deviceCorrelationIdSetInClient": bool,
                        "sendResultsToClient": bool
                    },
                    "VerifyImage": filetype
                }

                # response body for status code(s): 200
                response == {
                    "authToken": "str",
                    "sessionId": "str",
                    "verifyImage": {
                        "faceRectangle": {
                            "height": 0,
                            "left": 0,
                            "top": 0,
                            "width": 0
                        },
                        "qualityForRecognition": "str"
                    }
                }
        """
        error_map: MutableMapping[int, Type[HttpResponseError]] = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[_models.CreateLivenessWithVerifySessionResult] = kwargs.pop("cls", None)

        _body = body.as_dict() if isinstance(body, _model_base.Model) else body
        _file_fields: List[str] = ["VerifyImage"]
        _data_fields: List[str] = ["Parameters"]
        _files, _data = prepare_multipart_form_data(_body, _file_fields, _data_fields)

        _request = build_face_session_create_liveness_with_verify_session_with_verify_image_request(
            files=_files,
            data=_data,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, "str", skip_quote=True),
            "apiVersion": self._serialize.url("self._config.api_version", self._config.api_version, "str"),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = kwargs.pop("stream", False)
        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                try:
                    response.read()  # Load the body in memory and close the socket
                except (StreamConsumedError, StreamClosedError):
                    pass
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = _deserialize(_models.FaceErrorResponse, response.json())
            raise HttpResponseError(response=response, model=error)

        if _stream:
            deserialized = response.iter_bytes()
        else:
            deserialized = _deserialize(_models.CreateLivenessWithVerifySessionResult, response.json())

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore

    @distributed_trace
    def delete_liveness_with_verify_session(  # pylint: disable=inconsistent-return-statements
        self, session_id: str, **kwargs: Any
    ) -> None:
        """Delete all session related information for matching the specified session id.

        ..

           [!NOTE]
           Deleting a session deactivates the Session Auth Token by blocking future API calls made with
        that Auth Token. While this can be used to remove any access for that token, those requests
        will still count towards overall resource rate limits. It's best to leverage TokenTTL to limit
        length of tokens in the case that it is misused.

        :param session_id: The unique ID to reference this session. Required.
        :type session_id: str
        :return: None
        :rtype: None
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping[int, Type[HttpResponseError]] = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[None] = kwargs.pop("cls", None)

        _request = build_face_session_delete_liveness_with_verify_session_request(
            session_id=session_id,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, "str", skip_quote=True),
            "apiVersion": self._serialize.url("self._config.api_version", self._config.api_version, "str"),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = False
        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = _deserialize(_models.FaceErrorResponse, response.json())
            raise HttpResponseError(response=response, model=error)

        if cls:
            return cls(pipeline_response, None, {})  # type: ignore

    @distributed_trace
    def get_liveness_with_verify_session_result(
        self, session_id: str, **kwargs: Any
    ) -> _models.LivenessWithVerifySession:
        """Get session result of detectLivenessWithVerify/singleModal call.

        :param session_id: The unique ID to reference this session. Required.
        :type session_id: str
        :return: LivenessWithVerifySession. The LivenessWithVerifySession is compatible with
         MutableMapping
        :rtype: ~azure.ai.vision.face.models.LivenessWithVerifySession
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "createdDateTime": "2020-02-20 00:00:00",
                    "id": "str",
                    "sessionExpired": bool,
                    "status": "str",
                    "authTokenTimeToLiveInSeconds": 0,
                    "deviceCorrelationId": "str",
                    "result": {
                        "clientRequestId": "str",
                        "digest": "str",
                        "id": 0,
                        "receivedDateTime": "2020-02-20 00:00:00",
                        "request": {
                            "contentType": "str",
                            "method": "str",
                            "url": "str",
                            "contentLength": 0,
                            "userAgent": "str"
                        },
                        "requestId": "str",
                        "response": {
                            "body": {
                                "livenessDecision": "str",
                                "modelVersionUsed": "str",
                                "target": {
                                    "faceRectangle": {
                                        "height": 0,
                                        "left": 0,
                                        "top": 0,
                                        "width": 0
                                    },
                                    "fileName": "str",
                                    "imageType": "str",
                                    "timeOffsetWithinFile": 0
                                },
                                "verifyResult": {
                                    "isIdentical": bool,
                                    "matchConfidence": 0.0,
                                    "verifyImage": {
                                        "faceRectangle": {
                                            "height": 0,
                                            "left": 0,
                                            "top": 0,
                                            "width": 0
                                        },
                                        "qualityForRecognition": "str"
                                    }
                                }
                            },
                            "latencyInMilliseconds": 0,
                            "statusCode": 0
                        },
                        "sessionId": "str"
                    },
                    "sessionStartDateTime": "2020-02-20 00:00:00"
                }
        """
        error_map: MutableMapping[int, Type[HttpResponseError]] = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[_models.LivenessWithVerifySession] = kwargs.pop("cls", None)

        _request = build_face_session_get_liveness_with_verify_session_result_request(
            session_id=session_id,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, "str", skip_quote=True),
            "apiVersion": self._serialize.url("self._config.api_version", self._config.api_version, "str"),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = kwargs.pop("stream", False)
        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                try:
                    response.read()  # Load the body in memory and close the socket
                except (StreamConsumedError, StreamClosedError):
                    pass
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = _deserialize(_models.FaceErrorResponse, response.json())
            raise HttpResponseError(response=response, model=error)

        if _stream:
            deserialized = response.iter_bytes()
        else:
            deserialized = _deserialize(_models.LivenessWithVerifySession, response.json())

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore

    @distributed_trace
    def get_liveness_with_verify_sessions(
        self, *, start: Optional[str] = None, top: Optional[int] = None, **kwargs: Any
    ) -> List[_models.LivenessSessionItem]:
        """Lists sessions for /detectLivenessWithVerify/SingleModal.

        List sessions from the last sessionId greater than the "start".

        The result should be ordered by sessionId in ascending order.

        :keyword start: List resources greater than the "start". It contains no more than 64
         characters. Default is empty. Default value is None.
        :paramtype start: str
        :keyword top: The number of items to list, ranging in [1, 1000]. Default is 1000. Default value
         is None.
        :paramtype top: int
        :return: list of LivenessSessionItem
        :rtype: list[~azure.ai.vision.face.models.LivenessSessionItem]
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == [
                    {
                        "createdDateTime": "2020-02-20 00:00:00",
                        "id": "str",
                        "sessionExpired": bool,
                        "authTokenTimeToLiveInSeconds": 0,
                        "deviceCorrelationId": "str",
                        "sessionStartDateTime": "2020-02-20 00:00:00"
                    }
                ]
        """
        error_map: MutableMapping[int, Type[HttpResponseError]] = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[List[_models.LivenessSessionItem]] = kwargs.pop("cls", None)

        _request = build_face_session_get_liveness_with_verify_sessions_request(
            start=start,
            top=top,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, "str", skip_quote=True),
            "apiVersion": self._serialize.url("self._config.api_version", self._config.api_version, "str"),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = kwargs.pop("stream", False)
        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                try:
                    response.read()  # Load the body in memory and close the socket
                except (StreamConsumedError, StreamClosedError):
                    pass
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = _deserialize(_models.FaceErrorResponse, response.json())
            raise HttpResponseError(response=response, model=error)

        if _stream:
            deserialized = response.iter_bytes()
        else:
            deserialized = _deserialize(List[_models.LivenessSessionItem], response.json())

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore

    @distributed_trace
    def get_liveness_with_verify_session_audit_entries(  # pylint: disable=name-too-long
        self, session_id: str, *, start: Optional[str] = None, top: Optional[int] = None, **kwargs: Any
    ) -> List[_models.LivenessSessionAuditEntry]:
        """Gets session requests and response body for the session.

        :param session_id: The unique ID to reference this session. Required.
        :type session_id: str
        :keyword start: List resources greater than the "start". It contains no more than 64
         characters. Default is empty. Default value is None.
        :paramtype start: str
        :keyword top: The number of items to list, ranging in [1, 1000]. Default is 1000. Default value
         is None.
        :paramtype top: int
        :return: list of LivenessSessionAuditEntry
        :rtype: list[~azure.ai.vision.face.models.LivenessSessionAuditEntry]
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == [
                    {
                        "clientRequestId": "str",
                        "digest": "str",
                        "id": 0,
                        "receivedDateTime": "2020-02-20 00:00:00",
                        "request": {
                            "contentType": "str",
                            "method": "str",
                            "url": "str",
                            "contentLength": 0,
                            "userAgent": "str"
                        },
                        "requestId": "str",
                        "response": {
                            "body": {
                                "livenessDecision": "str",
                                "modelVersionUsed": "str",
                                "target": {
                                    "faceRectangle": {
                                        "height": 0,
                                        "left": 0,
                                        "top": 0,
                                        "width": 0
                                    },
                                    "fileName": "str",
                                    "imageType": "str",
                                    "timeOffsetWithinFile": 0
                                },
                                "verifyResult": {
                                    "isIdentical": bool,
                                    "matchConfidence": 0.0,
                                    "verifyImage": {
                                        "faceRectangle": {
                                            "height": 0,
                                            "left": 0,
                                            "top": 0,
                                            "width": 0
                                        },
                                        "qualityForRecognition": "str"
                                    }
                                }
                            },
                            "latencyInMilliseconds": 0,
                            "statusCode": 0
                        },
                        "sessionId": "str"
                    }
                ]
        """
        error_map: MutableMapping[int, Type[HttpResponseError]] = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[List[_models.LivenessSessionAuditEntry]] = kwargs.pop("cls", None)

        _request = build_face_session_get_liveness_with_verify_session_audit_entries_request(
            session_id=session_id,
            start=start,
            top=top,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, "str", skip_quote=True),
            "apiVersion": self._serialize.url("self._config.api_version", self._config.api_version, "str"),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = kwargs.pop("stream", False)
        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                try:
                    response.read()  # Load the body in memory and close the socket
                except (StreamConsumedError, StreamClosedError):
                    pass
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = _deserialize(_models.FaceErrorResponse, response.json())
            raise HttpResponseError(response=response, model=error)

        if _stream:
            deserialized = response.iter_bytes()
        else:
            deserialized = _deserialize(List[_models.LivenessSessionAuditEntry], response.json())

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore
