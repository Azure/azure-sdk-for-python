# coding=utf-8
# --------------------------------------------------------------------------
# Copyright (c) Microsoft Corporation. All rights reserved.
# Licensed under the MIT License. See License.txt in the project root for license information.
# Code generated by Microsoft (R) AutoRest Code Generator.
# Changes may cause incorrect behavior and will be lost if the code is regenerated.
# --------------------------------------------------------------------------
import functools
from typing import TYPE_CHECKING
import warnings

from azure.core.exceptions import ClientAuthenticationError, HttpResponseError, ResourceExistsError, ResourceNotFoundError, map_error
from azure.core.pipeline import PipelineResponse
from azure.core.pipeline.transport import HttpResponse
from azure.core.rest import HttpRequest
from azure.core.tracing.decorator import distributed_trace
from msrest import Serializer

from .. import models as _models
from .._vendor import _convert_request, _format_url_section

if TYPE_CHECKING:
    # pylint: disable=unused-import,ungrouped-imports
    from typing import Any, Callable, Dict, Generic, IO, Optional, TypeVar, Union

    T = TypeVar('T')
    ClsType = Optional[Callable[[PipelineResponse[HttpRequest, HttpResponse], T, Dict[str, Any]], Any]]

_SERIALIZER = Serializer()
# fmt: off

def build_create_request(
    share_name,  # type: str
    directory,  # type: str
    file_name,  # type: str
    **kwargs  # type: Any
):
    # type: (...) -> HttpRequest
    file_content_length = kwargs.pop('file_content_length')  # type: int
    timeout = kwargs.pop('timeout', None)  # type: Optional[int]
    file_content_type = kwargs.pop('file_content_type', None)  # type: Optional[str]
    file_content_encoding = kwargs.pop('file_content_encoding', None)  # type: Optional[str]
    file_content_language = kwargs.pop('file_content_language', None)  # type: Optional[str]
    file_cache_control = kwargs.pop('file_cache_control', None)  # type: Optional[str]
    file_content_md5 = kwargs.pop('file_content_md5', None)  # type: Optional[bytearray]
    file_content_disposition = kwargs.pop('file_content_disposition', None)  # type: Optional[str]
    metadata = kwargs.pop('metadata', None)  # type: Optional[Dict[str, str]]
    file_permission = kwargs.pop('file_permission', "inherit")  # type: Optional[str]
    file_permission_key = kwargs.pop('file_permission_key', None)  # type: Optional[str]
    file_attributes = kwargs.pop('file_attributes', "none")  # type: str
    file_creation_time = kwargs.pop('file_creation_time', "now")  # type: str
    file_last_write_time = kwargs.pop('file_last_write_time', "now")  # type: str
    lease_id = kwargs.pop('lease_id', None)  # type: Optional[str]

    version = "2020-10-02"
    file_type_constant = "file"
    accept = "application/xml"
    # Construct URL
    url = kwargs.pop("template_url", '/{shareName}/{directory}/{fileName}')
    path_format_arguments = {
        "shareName": _SERIALIZER.url("share_name", share_name, 'str'),
        "directory": _SERIALIZER.url("directory", directory, 'str'),
        "fileName": _SERIALIZER.url("file_name", file_name, 'str'),
    }

    url = _format_url_section(url, **path_format_arguments)

    # Construct parameters
    query_parameters = kwargs.pop("params", {})  # type: Dict[str, Any]
    if timeout is not None:
        query_parameters['timeout'] = _SERIALIZER.query("timeout", timeout, 'int', minimum=0)

    # Construct headers
    header_parameters = kwargs.pop("headers", {})  # type: Dict[str, Any]
    header_parameters['x-ms-version'] = _SERIALIZER.header("version", version, 'str')
    header_parameters['x-ms-content-length'] = _SERIALIZER.header("file_content_length", file_content_length, 'long')
    header_parameters['x-ms-type'] = _SERIALIZER.header("file_type_constant", file_type_constant, 'str')
    if file_content_type is not None:
        header_parameters['x-ms-content-type'] = _SERIALIZER.header("file_content_type", file_content_type, 'str')
    if file_content_encoding is not None:
        header_parameters['x-ms-content-encoding'] = _SERIALIZER.header("file_content_encoding", file_content_encoding, 'str')
    if file_content_language is not None:
        header_parameters['x-ms-content-language'] = _SERIALIZER.header("file_content_language", file_content_language, 'str')
    if file_cache_control is not None:
        header_parameters['x-ms-cache-control'] = _SERIALIZER.header("file_cache_control", file_cache_control, 'str')
    if file_content_md5 is not None:
        header_parameters['x-ms-content-md5'] = _SERIALIZER.header("file_content_md5", file_content_md5, 'bytearray')
    if file_content_disposition is not None:
        header_parameters['x-ms-content-disposition'] = _SERIALIZER.header("file_content_disposition", file_content_disposition, 'str')
    if metadata is not None:
        header_parameters['x-ms-meta'] = _SERIALIZER.header("metadata", metadata, '{str}')
    if file_permission is not None:
        header_parameters['x-ms-file-permission'] = _SERIALIZER.header("file_permission", file_permission, 'str')
    if file_permission_key is not None:
        header_parameters['x-ms-file-permission-key'] = _SERIALIZER.header("file_permission_key", file_permission_key, 'str')
    header_parameters['x-ms-file-attributes'] = _SERIALIZER.header("file_attributes", file_attributes, 'str')
    header_parameters['x-ms-file-creation-time'] = _SERIALIZER.header("file_creation_time", file_creation_time, 'str')
    header_parameters['x-ms-file-last-write-time'] = _SERIALIZER.header("file_last_write_time", file_last_write_time, 'str')
    if lease_id is not None:
        header_parameters['x-ms-lease-id'] = _SERIALIZER.header("lease_id", lease_id, 'str')
    header_parameters['Accept'] = _SERIALIZER.header("accept", accept, 'str')

    return HttpRequest(
        method="PUT",
        url=url,
        params=query_parameters,
        headers=header_parameters,
        **kwargs
    )


def build_download_request(
    share_name,  # type: str
    directory,  # type: str
    file_name,  # type: str
    **kwargs  # type: Any
):
    # type: (...) -> HttpRequest
    timeout = kwargs.pop('timeout', None)  # type: Optional[int]
    range = kwargs.pop('range', None)  # type: Optional[str]
    range_get_content_md5 = kwargs.pop('range_get_content_md5', None)  # type: Optional[bool]
    lease_id = kwargs.pop('lease_id', None)  # type: Optional[str]

    version = "2020-10-02"
    accept = "application/xml"
    # Construct URL
    url = kwargs.pop("template_url", '/{shareName}/{directory}/{fileName}')
    path_format_arguments = {
        "shareName": _SERIALIZER.url("share_name", share_name, 'str'),
        "directory": _SERIALIZER.url("directory", directory, 'str'),
        "fileName": _SERIALIZER.url("file_name", file_name, 'str'),
    }

    url = _format_url_section(url, **path_format_arguments)

    # Construct parameters
    query_parameters = kwargs.pop("params", {})  # type: Dict[str, Any]
    if timeout is not None:
        query_parameters['timeout'] = _SERIALIZER.query("timeout", timeout, 'int', minimum=0)

    # Construct headers
    header_parameters = kwargs.pop("headers", {})  # type: Dict[str, Any]
    header_parameters['x-ms-version'] = _SERIALIZER.header("version", version, 'str')
    if range is not None:
        header_parameters['x-ms-range'] = _SERIALIZER.header("range", range, 'str')
    if range_get_content_md5 is not None:
        header_parameters['x-ms-range-get-content-md5'] = _SERIALIZER.header("range_get_content_md5", range_get_content_md5, 'bool')
    if lease_id is not None:
        header_parameters['x-ms-lease-id'] = _SERIALIZER.header("lease_id", lease_id, 'str')
    header_parameters['Accept'] = _SERIALIZER.header("accept", accept, 'str')

    return HttpRequest(
        method="GET",
        url=url,
        params=query_parameters,
        headers=header_parameters,
        **kwargs
    )


def build_get_properties_request(
    share_name,  # type: str
    directory,  # type: str
    file_name,  # type: str
    **kwargs  # type: Any
):
    # type: (...) -> HttpRequest
    sharesnapshot = kwargs.pop('sharesnapshot', None)  # type: Optional[str]
    timeout = kwargs.pop('timeout', None)  # type: Optional[int]
    lease_id = kwargs.pop('lease_id', None)  # type: Optional[str]

    version = "2020-10-02"
    accept = "application/xml"
    # Construct URL
    url = kwargs.pop("template_url", '/{shareName}/{directory}/{fileName}')
    path_format_arguments = {
        "shareName": _SERIALIZER.url("share_name", share_name, 'str'),
        "directory": _SERIALIZER.url("directory", directory, 'str'),
        "fileName": _SERIALIZER.url("file_name", file_name, 'str'),
    }

    url = _format_url_section(url, **path_format_arguments)

    # Construct parameters
    query_parameters = kwargs.pop("params", {})  # type: Dict[str, Any]
    if sharesnapshot is not None:
        query_parameters['sharesnapshot'] = _SERIALIZER.query("sharesnapshot", sharesnapshot, 'str')
    if timeout is not None:
        query_parameters['timeout'] = _SERIALIZER.query("timeout", timeout, 'int', minimum=0)

    # Construct headers
    header_parameters = kwargs.pop("headers", {})  # type: Dict[str, Any]
    header_parameters['x-ms-version'] = _SERIALIZER.header("version", version, 'str')
    if lease_id is not None:
        header_parameters['x-ms-lease-id'] = _SERIALIZER.header("lease_id", lease_id, 'str')
    header_parameters['Accept'] = _SERIALIZER.header("accept", accept, 'str')

    return HttpRequest(
        method="HEAD",
        url=url,
        params=query_parameters,
        headers=header_parameters,
        **kwargs
    )


def build_delete_request(
    share_name,  # type: str
    directory,  # type: str
    file_name,  # type: str
    **kwargs  # type: Any
):
    # type: (...) -> HttpRequest
    timeout = kwargs.pop('timeout', None)  # type: Optional[int]
    lease_id = kwargs.pop('lease_id', None)  # type: Optional[str]

    version = "2020-10-02"
    accept = "application/xml"
    # Construct URL
    url = kwargs.pop("template_url", '/{shareName}/{directory}/{fileName}')
    path_format_arguments = {
        "shareName": _SERIALIZER.url("share_name", share_name, 'str'),
        "directory": _SERIALIZER.url("directory", directory, 'str'),
        "fileName": _SERIALIZER.url("file_name", file_name, 'str'),
    }

    url = _format_url_section(url, **path_format_arguments)

    # Construct parameters
    query_parameters = kwargs.pop("params", {})  # type: Dict[str, Any]
    if timeout is not None:
        query_parameters['timeout'] = _SERIALIZER.query("timeout", timeout, 'int', minimum=0)

    # Construct headers
    header_parameters = kwargs.pop("headers", {})  # type: Dict[str, Any]
    header_parameters['x-ms-version'] = _SERIALIZER.header("version", version, 'str')
    if lease_id is not None:
        header_parameters['x-ms-lease-id'] = _SERIALIZER.header("lease_id", lease_id, 'str')
    header_parameters['Accept'] = _SERIALIZER.header("accept", accept, 'str')

    return HttpRequest(
        method="DELETE",
        url=url,
        params=query_parameters,
        headers=header_parameters,
        **kwargs
    )


def build_set_http_headers_request(
    share_name,  # type: str
    directory,  # type: str
    file_name,  # type: str
    **kwargs  # type: Any
):
    # type: (...) -> HttpRequest
    timeout = kwargs.pop('timeout', None)  # type: Optional[int]
    file_content_length = kwargs.pop('file_content_length', None)  # type: Optional[int]
    file_content_type = kwargs.pop('file_content_type', None)  # type: Optional[str]
    file_content_encoding = kwargs.pop('file_content_encoding', None)  # type: Optional[str]
    file_content_language = kwargs.pop('file_content_language', None)  # type: Optional[str]
    file_cache_control = kwargs.pop('file_cache_control', None)  # type: Optional[str]
    file_content_md5 = kwargs.pop('file_content_md5', None)  # type: Optional[bytearray]
    file_content_disposition = kwargs.pop('file_content_disposition', None)  # type: Optional[str]
    file_permission = kwargs.pop('file_permission', "inherit")  # type: Optional[str]
    file_permission_key = kwargs.pop('file_permission_key', None)  # type: Optional[str]
    file_attributes = kwargs.pop('file_attributes', "none")  # type: str
    file_creation_time = kwargs.pop('file_creation_time', "now")  # type: str
    file_last_write_time = kwargs.pop('file_last_write_time', "now")  # type: str
    lease_id = kwargs.pop('lease_id', None)  # type: Optional[str]

    comp = "properties"
    version = "2020-10-02"
    accept = "application/xml"
    # Construct URL
    url = kwargs.pop("template_url", '/{shareName}/{directory}/{fileName}')
    path_format_arguments = {
        "shareName": _SERIALIZER.url("share_name", share_name, 'str'),
        "directory": _SERIALIZER.url("directory", directory, 'str'),
        "fileName": _SERIALIZER.url("file_name", file_name, 'str'),
    }

    url = _format_url_section(url, **path_format_arguments)

    # Construct parameters
    query_parameters = kwargs.pop("params", {})  # type: Dict[str, Any]
    query_parameters['comp'] = _SERIALIZER.query("comp", comp, 'str')
    if timeout is not None:
        query_parameters['timeout'] = _SERIALIZER.query("timeout", timeout, 'int', minimum=0)

    # Construct headers
    header_parameters = kwargs.pop("headers", {})  # type: Dict[str, Any]
    header_parameters['x-ms-version'] = _SERIALIZER.header("version", version, 'str')
    if file_content_length is not None:
        header_parameters['x-ms-content-length'] = _SERIALIZER.header("file_content_length", file_content_length, 'long')
    if file_content_type is not None:
        header_parameters['x-ms-content-type'] = _SERIALIZER.header("file_content_type", file_content_type, 'str')
    if file_content_encoding is not None:
        header_parameters['x-ms-content-encoding'] = _SERIALIZER.header("file_content_encoding", file_content_encoding, 'str')
    if file_content_language is not None:
        header_parameters['x-ms-content-language'] = _SERIALIZER.header("file_content_language", file_content_language, 'str')
    if file_cache_control is not None:
        header_parameters['x-ms-cache-control'] = _SERIALIZER.header("file_cache_control", file_cache_control, 'str')
    if file_content_md5 is not None:
        header_parameters['x-ms-content-md5'] = _SERIALIZER.header("file_content_md5", file_content_md5, 'bytearray')
    if file_content_disposition is not None:
        header_parameters['x-ms-content-disposition'] = _SERIALIZER.header("file_content_disposition", file_content_disposition, 'str')
    if file_permission is not None:
        header_parameters['x-ms-file-permission'] = _SERIALIZER.header("file_permission", file_permission, 'str')
    if file_permission_key is not None:
        header_parameters['x-ms-file-permission-key'] = _SERIALIZER.header("file_permission_key", file_permission_key, 'str')
    header_parameters['x-ms-file-attributes'] = _SERIALIZER.header("file_attributes", file_attributes, 'str')
    header_parameters['x-ms-file-creation-time'] = _SERIALIZER.header("file_creation_time", file_creation_time, 'str')
    header_parameters['x-ms-file-last-write-time'] = _SERIALIZER.header("file_last_write_time", file_last_write_time, 'str')
    if lease_id is not None:
        header_parameters['x-ms-lease-id'] = _SERIALIZER.header("lease_id", lease_id, 'str')
    header_parameters['Accept'] = _SERIALIZER.header("accept", accept, 'str')

    return HttpRequest(
        method="PUT",
        url=url,
        params=query_parameters,
        headers=header_parameters,
        **kwargs
    )


def build_set_metadata_request(
    share_name,  # type: str
    directory,  # type: str
    file_name,  # type: str
    **kwargs  # type: Any
):
    # type: (...) -> HttpRequest
    timeout = kwargs.pop('timeout', None)  # type: Optional[int]
    metadata = kwargs.pop('metadata', None)  # type: Optional[Dict[str, str]]
    lease_id = kwargs.pop('lease_id', None)  # type: Optional[str]

    comp = "metadata"
    version = "2020-10-02"
    accept = "application/xml"
    # Construct URL
    url = kwargs.pop("template_url", '/{shareName}/{directory}/{fileName}')
    path_format_arguments = {
        "shareName": _SERIALIZER.url("share_name", share_name, 'str'),
        "directory": _SERIALIZER.url("directory", directory, 'str'),
        "fileName": _SERIALIZER.url("file_name", file_name, 'str'),
    }

    url = _format_url_section(url, **path_format_arguments)

    # Construct parameters
    query_parameters = kwargs.pop("params", {})  # type: Dict[str, Any]
    query_parameters['comp'] = _SERIALIZER.query("comp", comp, 'str')
    if timeout is not None:
        query_parameters['timeout'] = _SERIALIZER.query("timeout", timeout, 'int', minimum=0)

    # Construct headers
    header_parameters = kwargs.pop("headers", {})  # type: Dict[str, Any]
    if metadata is not None:
        header_parameters['x-ms-meta'] = _SERIALIZER.header("metadata", metadata, '{str}')
    header_parameters['x-ms-version'] = _SERIALIZER.header("version", version, 'str')
    if lease_id is not None:
        header_parameters['x-ms-lease-id'] = _SERIALIZER.header("lease_id", lease_id, 'str')
    header_parameters['Accept'] = _SERIALIZER.header("accept", accept, 'str')

    return HttpRequest(
        method="PUT",
        url=url,
        params=query_parameters,
        headers=header_parameters,
        **kwargs
    )


def build_acquire_lease_request(
    share_name,  # type: str
    directory,  # type: str
    file_name,  # type: str
    **kwargs  # type: Any
):
    # type: (...) -> HttpRequest
    timeout = kwargs.pop('timeout', None)  # type: Optional[int]
    duration = kwargs.pop('duration', None)  # type: Optional[int]
    proposed_lease_id = kwargs.pop('proposed_lease_id', None)  # type: Optional[str]
    request_id_parameter = kwargs.pop('request_id_parameter', None)  # type: Optional[str]

    comp = "lease"
    action = "acquire"
    version = "2020-10-02"
    accept = "application/xml"
    # Construct URL
    url = kwargs.pop("template_url", '/{shareName}/{directory}/{fileName}')
    path_format_arguments = {
        "shareName": _SERIALIZER.url("share_name", share_name, 'str'),
        "directory": _SERIALIZER.url("directory", directory, 'str'),
        "fileName": _SERIALIZER.url("file_name", file_name, 'str'),
    }

    url = _format_url_section(url, **path_format_arguments)

    # Construct parameters
    query_parameters = kwargs.pop("params", {})  # type: Dict[str, Any]
    query_parameters['comp'] = _SERIALIZER.query("comp", comp, 'str')
    if timeout is not None:
        query_parameters['timeout'] = _SERIALIZER.query("timeout", timeout, 'int', minimum=0)

    # Construct headers
    header_parameters = kwargs.pop("headers", {})  # type: Dict[str, Any]
    header_parameters['x-ms-lease-action'] = _SERIALIZER.header("action", action, 'str')
    if duration is not None:
        header_parameters['x-ms-lease-duration'] = _SERIALIZER.header("duration", duration, 'int')
    if proposed_lease_id is not None:
        header_parameters['x-ms-proposed-lease-id'] = _SERIALIZER.header("proposed_lease_id", proposed_lease_id, 'str')
    header_parameters['x-ms-version'] = _SERIALIZER.header("version", version, 'str')
    if request_id_parameter is not None:
        header_parameters['x-ms-client-request-id'] = _SERIALIZER.header("request_id_parameter", request_id_parameter, 'str')
    header_parameters['Accept'] = _SERIALIZER.header("accept", accept, 'str')

    return HttpRequest(
        method="PUT",
        url=url,
        params=query_parameters,
        headers=header_parameters,
        **kwargs
    )


def build_release_lease_request(
    share_name,  # type: str
    directory,  # type: str
    file_name,  # type: str
    **kwargs  # type: Any
):
    # type: (...) -> HttpRequest
    lease_id = kwargs.pop('lease_id')  # type: str
    timeout = kwargs.pop('timeout', None)  # type: Optional[int]
    request_id_parameter = kwargs.pop('request_id_parameter', None)  # type: Optional[str]

    comp = "lease"
    action = "release"
    version = "2020-10-02"
    accept = "application/xml"
    # Construct URL
    url = kwargs.pop("template_url", '/{shareName}/{directory}/{fileName}')
    path_format_arguments = {
        "shareName": _SERIALIZER.url("share_name", share_name, 'str'),
        "directory": _SERIALIZER.url("directory", directory, 'str'),
        "fileName": _SERIALIZER.url("file_name", file_name, 'str'),
    }

    url = _format_url_section(url, **path_format_arguments)

    # Construct parameters
    query_parameters = kwargs.pop("params", {})  # type: Dict[str, Any]
    query_parameters['comp'] = _SERIALIZER.query("comp", comp, 'str')
    if timeout is not None:
        query_parameters['timeout'] = _SERIALIZER.query("timeout", timeout, 'int', minimum=0)

    # Construct headers
    header_parameters = kwargs.pop("headers", {})  # type: Dict[str, Any]
    header_parameters['x-ms-lease-action'] = _SERIALIZER.header("action", action, 'str')
    header_parameters['x-ms-lease-id'] = _SERIALIZER.header("lease_id", lease_id, 'str')
    header_parameters['x-ms-version'] = _SERIALIZER.header("version", version, 'str')
    if request_id_parameter is not None:
        header_parameters['x-ms-client-request-id'] = _SERIALIZER.header("request_id_parameter", request_id_parameter, 'str')
    header_parameters['Accept'] = _SERIALIZER.header("accept", accept, 'str')

    return HttpRequest(
        method="PUT",
        url=url,
        params=query_parameters,
        headers=header_parameters,
        **kwargs
    )


def build_change_lease_request(
    share_name,  # type: str
    directory,  # type: str
    file_name,  # type: str
    **kwargs  # type: Any
):
    # type: (...) -> HttpRequest
    lease_id = kwargs.pop('lease_id')  # type: str
    timeout = kwargs.pop('timeout', None)  # type: Optional[int]
    proposed_lease_id = kwargs.pop('proposed_lease_id', None)  # type: Optional[str]
    request_id_parameter = kwargs.pop('request_id_parameter', None)  # type: Optional[str]

    comp = "lease"
    action = "change"
    version = "2020-10-02"
    accept = "application/xml"
    # Construct URL
    url = kwargs.pop("template_url", '/{shareName}/{directory}/{fileName}')
    path_format_arguments = {
        "shareName": _SERIALIZER.url("share_name", share_name, 'str'),
        "directory": _SERIALIZER.url("directory", directory, 'str'),
        "fileName": _SERIALIZER.url("file_name", file_name, 'str'),
    }

    url = _format_url_section(url, **path_format_arguments)

    # Construct parameters
    query_parameters = kwargs.pop("params", {})  # type: Dict[str, Any]
    query_parameters['comp'] = _SERIALIZER.query("comp", comp, 'str')
    if timeout is not None:
        query_parameters['timeout'] = _SERIALIZER.query("timeout", timeout, 'int', minimum=0)

    # Construct headers
    header_parameters = kwargs.pop("headers", {})  # type: Dict[str, Any]
    header_parameters['x-ms-lease-action'] = _SERIALIZER.header("action", action, 'str')
    header_parameters['x-ms-lease-id'] = _SERIALIZER.header("lease_id", lease_id, 'str')
    if proposed_lease_id is not None:
        header_parameters['x-ms-proposed-lease-id'] = _SERIALIZER.header("proposed_lease_id", proposed_lease_id, 'str')
    header_parameters['x-ms-version'] = _SERIALIZER.header("version", version, 'str')
    if request_id_parameter is not None:
        header_parameters['x-ms-client-request-id'] = _SERIALIZER.header("request_id_parameter", request_id_parameter, 'str')
    header_parameters['Accept'] = _SERIALIZER.header("accept", accept, 'str')

    return HttpRequest(
        method="PUT",
        url=url,
        params=query_parameters,
        headers=header_parameters,
        **kwargs
    )


def build_break_lease_request(
    share_name,  # type: str
    directory,  # type: str
    file_name,  # type: str
    **kwargs  # type: Any
):
    # type: (...) -> HttpRequest
    timeout = kwargs.pop('timeout', None)  # type: Optional[int]
    lease_id = kwargs.pop('lease_id', None)  # type: Optional[str]
    request_id_parameter = kwargs.pop('request_id_parameter', None)  # type: Optional[str]

    comp = "lease"
    action = "break"
    version = "2020-10-02"
    accept = "application/xml"
    # Construct URL
    url = kwargs.pop("template_url", '/{shareName}/{directory}/{fileName}')
    path_format_arguments = {
        "shareName": _SERIALIZER.url("share_name", share_name, 'str'),
        "directory": _SERIALIZER.url("directory", directory, 'str'),
        "fileName": _SERIALIZER.url("file_name", file_name, 'str'),
    }

    url = _format_url_section(url, **path_format_arguments)

    # Construct parameters
    query_parameters = kwargs.pop("params", {})  # type: Dict[str, Any]
    query_parameters['comp'] = _SERIALIZER.query("comp", comp, 'str')
    if timeout is not None:
        query_parameters['timeout'] = _SERIALIZER.query("timeout", timeout, 'int', minimum=0)

    # Construct headers
    header_parameters = kwargs.pop("headers", {})  # type: Dict[str, Any]
    header_parameters['x-ms-lease-action'] = _SERIALIZER.header("action", action, 'str')
    if lease_id is not None:
        header_parameters['x-ms-lease-id'] = _SERIALIZER.header("lease_id", lease_id, 'str')
    header_parameters['x-ms-version'] = _SERIALIZER.header("version", version, 'str')
    if request_id_parameter is not None:
        header_parameters['x-ms-client-request-id'] = _SERIALIZER.header("request_id_parameter", request_id_parameter, 'str')
    header_parameters['Accept'] = _SERIALIZER.header("accept", accept, 'str')

    return HttpRequest(
        method="PUT",
        url=url,
        params=query_parameters,
        headers=header_parameters,
        **kwargs
    )


def build_upload_range_request(
    share_name,  # type: str
    directory,  # type: str
    file_name,  # type: str
    **kwargs  # type: Any
):
    # type: (...) -> HttpRequest
    content_type = kwargs.pop('content_type', None)  # type: Optional[str]
    range = kwargs.pop('range')  # type: str
    content_length = kwargs.pop('content_length')  # type: int
    timeout = kwargs.pop('timeout', None)  # type: Optional[int]
    file_range_write = kwargs.pop('file_range_write', "update")  # type: Union[str, "_models.FileRangeWriteType"]
    content_md5 = kwargs.pop('content_md5', None)  # type: Optional[bytearray]
    lease_id = kwargs.pop('lease_id', None)  # type: Optional[str]

    comp = "range"
    version = "2020-10-02"
    accept = "application/xml"
    # Construct URL
    url = kwargs.pop("template_url", '/{shareName}/{directory}/{fileName}')
    path_format_arguments = {
        "shareName": _SERIALIZER.url("share_name", share_name, 'str'),
        "directory": _SERIALIZER.url("directory", directory, 'str'),
        "fileName": _SERIALIZER.url("file_name", file_name, 'str'),
    }

    url = _format_url_section(url, **path_format_arguments)

    # Construct parameters
    query_parameters = kwargs.pop("params", {})  # type: Dict[str, Any]
    query_parameters['comp'] = _SERIALIZER.query("comp", comp, 'str')
    if timeout is not None:
        query_parameters['timeout'] = _SERIALIZER.query("timeout", timeout, 'int', minimum=0)

    # Construct headers
    header_parameters = kwargs.pop("headers", {})  # type: Dict[str, Any]
    header_parameters['x-ms-range'] = _SERIALIZER.header("range", range, 'str')
    header_parameters['x-ms-write'] = _SERIALIZER.header("file_range_write", file_range_write, 'str')
    header_parameters['Content-Length'] = _SERIALIZER.header("content_length", content_length, 'long')
    if content_md5 is not None:
        header_parameters['Content-MD5'] = _SERIALIZER.header("content_md5", content_md5, 'bytearray')
    header_parameters['x-ms-version'] = _SERIALIZER.header("version", version, 'str')
    if lease_id is not None:
        header_parameters['x-ms-lease-id'] = _SERIALIZER.header("lease_id", lease_id, 'str')
    if content_type is not None:
        header_parameters['Content-Type'] = _SERIALIZER.header("content_type", content_type, 'str')
    header_parameters['Accept'] = _SERIALIZER.header("accept", accept, 'str')

    return HttpRequest(
        method="PUT",
        url=url,
        params=query_parameters,
        headers=header_parameters,
        **kwargs
    )


def build_upload_range_from_url_request(
    share_name,  # type: str
    directory,  # type: str
    file_name,  # type: str
    **kwargs  # type: Any
):
    # type: (...) -> HttpRequest
    range = kwargs.pop('range')  # type: str
    copy_source = kwargs.pop('copy_source')  # type: str
    content_length = kwargs.pop('content_length')  # type: int
    timeout = kwargs.pop('timeout', None)  # type: Optional[int]
    source_range = kwargs.pop('source_range', None)  # type: Optional[str]
    source_content_crc64 = kwargs.pop('source_content_crc64', None)  # type: Optional[bytearray]
    source_if_match_crc64 = kwargs.pop('source_if_match_crc64', None)  # type: Optional[bytearray]
    source_if_none_match_crc64 = kwargs.pop('source_if_none_match_crc64', None)  # type: Optional[bytearray]
    lease_id = kwargs.pop('lease_id', None)  # type: Optional[str]
    copy_source_authorization = kwargs.pop('copy_source_authorization', None)  # type: Optional[str]

    comp = "range"
    file_range_write_from_url = "update"
    version = "2020-10-02"
    accept = "application/xml"
    # Construct URL
    url = kwargs.pop("template_url", '/{shareName}/{directory}/{fileName}')
    path_format_arguments = {
        "shareName": _SERIALIZER.url("share_name", share_name, 'str'),
        "directory": _SERIALIZER.url("directory", directory, 'str'),
        "fileName": _SERIALIZER.url("file_name", file_name, 'str'),
    }

    url = _format_url_section(url, **path_format_arguments)

    # Construct parameters
    query_parameters = kwargs.pop("params", {})  # type: Dict[str, Any]
    query_parameters['comp'] = _SERIALIZER.query("comp", comp, 'str')
    if timeout is not None:
        query_parameters['timeout'] = _SERIALIZER.query("timeout", timeout, 'int', minimum=0)

    # Construct headers
    header_parameters = kwargs.pop("headers", {})  # type: Dict[str, Any]
    header_parameters['x-ms-range'] = _SERIALIZER.header("range", range, 'str')
    header_parameters['x-ms-copy-source'] = _SERIALIZER.header("copy_source", copy_source, 'str')
    if source_range is not None:
        header_parameters['x-ms-source-range'] = _SERIALIZER.header("source_range", source_range, 'str')
    header_parameters['x-ms-write'] = _SERIALIZER.header("file_range_write_from_url", file_range_write_from_url, 'str')
    header_parameters['Content-Length'] = _SERIALIZER.header("content_length", content_length, 'long')
    if source_content_crc64 is not None:
        header_parameters['x-ms-source-content-crc64'] = _SERIALIZER.header("source_content_crc64", source_content_crc64, 'bytearray')
    if source_if_match_crc64 is not None:
        header_parameters['x-ms-source-if-match-crc64'] = _SERIALIZER.header("source_if_match_crc64", source_if_match_crc64, 'bytearray')
    if source_if_none_match_crc64 is not None:
        header_parameters['x-ms-source-if-none-match-crc64'] = _SERIALIZER.header("source_if_none_match_crc64", source_if_none_match_crc64, 'bytearray')
    header_parameters['x-ms-version'] = _SERIALIZER.header("version", version, 'str')
    if lease_id is not None:
        header_parameters['x-ms-lease-id'] = _SERIALIZER.header("lease_id", lease_id, 'str')
    if copy_source_authorization is not None:
        header_parameters['x-ms-copy-source-authorization'] = _SERIALIZER.header("copy_source_authorization", copy_source_authorization, 'str')
    header_parameters['Accept'] = _SERIALIZER.header("accept", accept, 'str')

    return HttpRequest(
        method="PUT",
        url=url,
        params=query_parameters,
        headers=header_parameters,
        **kwargs
    )


def build_get_range_list_request(
    share_name,  # type: str
    directory,  # type: str
    file_name,  # type: str
    **kwargs  # type: Any
):
    # type: (...) -> HttpRequest
    sharesnapshot = kwargs.pop('sharesnapshot', None)  # type: Optional[str]
    prevsharesnapshot = kwargs.pop('prevsharesnapshot', None)  # type: Optional[str]
    timeout = kwargs.pop('timeout', None)  # type: Optional[int]
    range = kwargs.pop('range', None)  # type: Optional[str]
    lease_id = kwargs.pop('lease_id', None)  # type: Optional[str]

    comp = "rangelist"
    version = "2020-10-02"
    accept = "application/xml"
    # Construct URL
    url = kwargs.pop("template_url", '/{shareName}/{directory}/{fileName}')
    path_format_arguments = {
        "shareName": _SERIALIZER.url("share_name", share_name, 'str'),
        "directory": _SERIALIZER.url("directory", directory, 'str'),
        "fileName": _SERIALIZER.url("file_name", file_name, 'str'),
    }

    url = _format_url_section(url, **path_format_arguments)

    # Construct parameters
    query_parameters = kwargs.pop("params", {})  # type: Dict[str, Any]
    query_parameters['comp'] = _SERIALIZER.query("comp", comp, 'str')
    if sharesnapshot is not None:
        query_parameters['sharesnapshot'] = _SERIALIZER.query("sharesnapshot", sharesnapshot, 'str')
    if prevsharesnapshot is not None:
        query_parameters['prevsharesnapshot'] = _SERIALIZER.query("prevsharesnapshot", prevsharesnapshot, 'str')
    if timeout is not None:
        query_parameters['timeout'] = _SERIALIZER.query("timeout", timeout, 'int', minimum=0)

    # Construct headers
    header_parameters = kwargs.pop("headers", {})  # type: Dict[str, Any]
    header_parameters['x-ms-version'] = _SERIALIZER.header("version", version, 'str')
    if range is not None:
        header_parameters['x-ms-range'] = _SERIALIZER.header("range", range, 'str')
    if lease_id is not None:
        header_parameters['x-ms-lease-id'] = _SERIALIZER.header("lease_id", lease_id, 'str')
    header_parameters['Accept'] = _SERIALIZER.header("accept", accept, 'str')

    return HttpRequest(
        method="GET",
        url=url,
        params=query_parameters,
        headers=header_parameters,
        **kwargs
    )


def build_start_copy_request(
    share_name,  # type: str
    directory,  # type: str
    file_name,  # type: str
    **kwargs  # type: Any
):
    # type: (...) -> HttpRequest
    copy_source = kwargs.pop('copy_source')  # type: str
    timeout = kwargs.pop('timeout', None)  # type: Optional[int]
    metadata = kwargs.pop('metadata', None)  # type: Optional[Dict[str, str]]
    file_permission = kwargs.pop('file_permission', "inherit")  # type: Optional[str]
    file_permission_key = kwargs.pop('file_permission_key', None)  # type: Optional[str]
    file_permission_copy_mode = kwargs.pop('file_permission_copy_mode', None)  # type: Optional[Union[str, "_models.PermissionCopyModeType"]]
    ignore_read_only = kwargs.pop('ignore_read_only', None)  # type: Optional[bool]
    file_attributes = kwargs.pop('file_attributes', None)  # type: Optional[str]
    file_creation_time = kwargs.pop('file_creation_time', None)  # type: Optional[str]
    file_last_write_time = kwargs.pop('file_last_write_time', None)  # type: Optional[str]
    set_archive_attribute = kwargs.pop('set_archive_attribute', None)  # type: Optional[bool]
    lease_id = kwargs.pop('lease_id', None)  # type: Optional[str]

    version = "2020-10-02"
    accept = "application/xml"
    # Construct URL
    url = kwargs.pop("template_url", '/{shareName}/{directory}/{fileName}')
    path_format_arguments = {
        "shareName": _SERIALIZER.url("share_name", share_name, 'str'),
        "directory": _SERIALIZER.url("directory", directory, 'str'),
        "fileName": _SERIALIZER.url("file_name", file_name, 'str'),
    }

    url = _format_url_section(url, **path_format_arguments)

    # Construct parameters
    query_parameters = kwargs.pop("params", {})  # type: Dict[str, Any]
    if timeout is not None:
        query_parameters['timeout'] = _SERIALIZER.query("timeout", timeout, 'int', minimum=0)

    # Construct headers
    header_parameters = kwargs.pop("headers", {})  # type: Dict[str, Any]
    header_parameters['x-ms-version'] = _SERIALIZER.header("version", version, 'str')
    if metadata is not None:
        header_parameters['x-ms-meta'] = _SERIALIZER.header("metadata", metadata, '{str}')
    header_parameters['x-ms-copy-source'] = _SERIALIZER.header("copy_source", copy_source, 'str')
    if file_permission is not None:
        header_parameters['x-ms-file-permission'] = _SERIALIZER.header("file_permission", file_permission, 'str')
    if file_permission_key is not None:
        header_parameters['x-ms-file-permission-key'] = _SERIALIZER.header("file_permission_key", file_permission_key, 'str')
    if file_permission_copy_mode is not None:
        header_parameters['x-ms-file-permission-copy-mode'] = _SERIALIZER.header("file_permission_copy_mode", file_permission_copy_mode, 'str')
    if ignore_read_only is not None:
        header_parameters['x-ms-file-copy-ignore-read-only'] = _SERIALIZER.header("ignore_read_only", ignore_read_only, 'bool')
    if file_attributes is not None:
        header_parameters['x-ms-file-attributes'] = _SERIALIZER.header("file_attributes", file_attributes, 'str')
    if file_creation_time is not None:
        header_parameters['x-ms-file-creation-time'] = _SERIALIZER.header("file_creation_time", file_creation_time, 'str')
    if file_last_write_time is not None:
        header_parameters['x-ms-file-last-write-time'] = _SERIALIZER.header("file_last_write_time", file_last_write_time, 'str')
    if set_archive_attribute is not None:
        header_parameters['x-ms-file-copy-set-archive'] = _SERIALIZER.header("set_archive_attribute", set_archive_attribute, 'bool')
    if lease_id is not None:
        header_parameters['x-ms-lease-id'] = _SERIALIZER.header("lease_id", lease_id, 'str')
    header_parameters['Accept'] = _SERIALIZER.header("accept", accept, 'str')

    return HttpRequest(
        method="PUT",
        url=url,
        params=query_parameters,
        headers=header_parameters,
        **kwargs
    )


def build_abort_copy_request(
    share_name,  # type: str
    directory,  # type: str
    file_name,  # type: str
    **kwargs  # type: Any
):
    # type: (...) -> HttpRequest
    copy_id = kwargs.pop('copy_id')  # type: str
    timeout = kwargs.pop('timeout', None)  # type: Optional[int]
    lease_id = kwargs.pop('lease_id', None)  # type: Optional[str]

    comp = "copy"
    copy_action_abort_constant = "abort"
    version = "2020-10-02"
    accept = "application/xml"
    # Construct URL
    url = kwargs.pop("template_url", '/{shareName}/{directory}/{fileName}')
    path_format_arguments = {
        "shareName": _SERIALIZER.url("share_name", share_name, 'str'),
        "directory": _SERIALIZER.url("directory", directory, 'str'),
        "fileName": _SERIALIZER.url("file_name", file_name, 'str'),
    }

    url = _format_url_section(url, **path_format_arguments)

    # Construct parameters
    query_parameters = kwargs.pop("params", {})  # type: Dict[str, Any]
    query_parameters['comp'] = _SERIALIZER.query("comp", comp, 'str')
    query_parameters['copyid'] = _SERIALIZER.query("copy_id", copy_id, 'str')
    if timeout is not None:
        query_parameters['timeout'] = _SERIALIZER.query("timeout", timeout, 'int', minimum=0)

    # Construct headers
    header_parameters = kwargs.pop("headers", {})  # type: Dict[str, Any]
    header_parameters['x-ms-copy-action'] = _SERIALIZER.header("copy_action_abort_constant", copy_action_abort_constant, 'str')
    header_parameters['x-ms-version'] = _SERIALIZER.header("version", version, 'str')
    if lease_id is not None:
        header_parameters['x-ms-lease-id'] = _SERIALIZER.header("lease_id", lease_id, 'str')
    header_parameters['Accept'] = _SERIALIZER.header("accept", accept, 'str')

    return HttpRequest(
        method="PUT",
        url=url,
        params=query_parameters,
        headers=header_parameters,
        **kwargs
    )


def build_list_handles_request(
    share_name,  # type: str
    directory,  # type: str
    file_name,  # type: str
    **kwargs  # type: Any
):
    # type: (...) -> HttpRequest
    marker = kwargs.pop('marker', None)  # type: Optional[str]
    maxresults = kwargs.pop('maxresults', None)  # type: Optional[int]
    timeout = kwargs.pop('timeout', None)  # type: Optional[int]
    sharesnapshot = kwargs.pop('sharesnapshot', None)  # type: Optional[str]

    comp = "listhandles"
    version = "2020-10-02"
    accept = "application/xml"
    # Construct URL
    url = kwargs.pop("template_url", '/{shareName}/{directory}/{fileName}')
    path_format_arguments = {
        "shareName": _SERIALIZER.url("share_name", share_name, 'str'),
        "directory": _SERIALIZER.url("directory", directory, 'str'),
        "fileName": _SERIALIZER.url("file_name", file_name, 'str'),
    }

    url = _format_url_section(url, **path_format_arguments)

    # Construct parameters
    query_parameters = kwargs.pop("params", {})  # type: Dict[str, Any]
    query_parameters['comp'] = _SERIALIZER.query("comp", comp, 'str')
    if marker is not None:
        query_parameters['marker'] = _SERIALIZER.query("marker", marker, 'str')
    if maxresults is not None:
        query_parameters['maxresults'] = _SERIALIZER.query("maxresults", maxresults, 'int', minimum=1)
    if timeout is not None:
        query_parameters['timeout'] = _SERIALIZER.query("timeout", timeout, 'int', minimum=0)
    if sharesnapshot is not None:
        query_parameters['sharesnapshot'] = _SERIALIZER.query("sharesnapshot", sharesnapshot, 'str')

    # Construct headers
    header_parameters = kwargs.pop("headers", {})  # type: Dict[str, Any]
    header_parameters['x-ms-version'] = _SERIALIZER.header("version", version, 'str')
    header_parameters['Accept'] = _SERIALIZER.header("accept", accept, 'str')

    return HttpRequest(
        method="GET",
        url=url,
        params=query_parameters,
        headers=header_parameters,
        **kwargs
    )


def build_force_close_handles_request(
    share_name,  # type: str
    directory,  # type: str
    file_name,  # type: str
    **kwargs  # type: Any
):
    # type: (...) -> HttpRequest
    handle_id = kwargs.pop('handle_id')  # type: str
    timeout = kwargs.pop('timeout', None)  # type: Optional[int]
    marker = kwargs.pop('marker', None)  # type: Optional[str]
    sharesnapshot = kwargs.pop('sharesnapshot', None)  # type: Optional[str]

    comp = "forceclosehandles"
    version = "2020-10-02"
    accept = "application/xml"
    # Construct URL
    url = kwargs.pop("template_url", '/{shareName}/{directory}/{fileName}')
    path_format_arguments = {
        "shareName": _SERIALIZER.url("share_name", share_name, 'str'),
        "directory": _SERIALIZER.url("directory", directory, 'str'),
        "fileName": _SERIALIZER.url("file_name", file_name, 'str'),
    }

    url = _format_url_section(url, **path_format_arguments)

    # Construct parameters
    query_parameters = kwargs.pop("params", {})  # type: Dict[str, Any]
    query_parameters['comp'] = _SERIALIZER.query("comp", comp, 'str')
    if timeout is not None:
        query_parameters['timeout'] = _SERIALIZER.query("timeout", timeout, 'int', minimum=0)
    if marker is not None:
        query_parameters['marker'] = _SERIALIZER.query("marker", marker, 'str')
    if sharesnapshot is not None:
        query_parameters['sharesnapshot'] = _SERIALIZER.query("sharesnapshot", sharesnapshot, 'str')

    # Construct headers
    header_parameters = kwargs.pop("headers", {})  # type: Dict[str, Any]
    header_parameters['x-ms-handle-id'] = _SERIALIZER.header("handle_id", handle_id, 'str')
    header_parameters['x-ms-version'] = _SERIALIZER.header("version", version, 'str')
    header_parameters['Accept'] = _SERIALIZER.header("accept", accept, 'str')

    return HttpRequest(
        method="PUT",
        url=url,
        params=query_parameters,
        headers=header_parameters,
        **kwargs
    )

# fmt: on
class FileOperations(object):
    """FileOperations operations.

    You should not instantiate this class directly. Instead, you should create a Client instance that
    instantiates it for you and attaches it as an attribute.

    :ivar models: Alias to model classes used in this operation group.
    :type models: ~azure.storage.fileshare.models
    :param client: Client for service requests.
    :param config: Configuration of service client.
    :param serializer: An object model serializer.
    :param deserializer: An object model deserializer.
    """

    models = _models

    def __init__(self, client, config, serializer, deserializer):
        self._client = client
        self._serialize = serializer
        self._deserialize = deserializer
        self._config = config

    @distributed_trace
    def create(
        self,
        share_name,  # type: str
        directory,  # type: str
        file_name,  # type: str
        file_content_length,  # type: int
        timeout=None,  # type: Optional[int]
        metadata=None,  # type: Optional[Dict[str, str]]
        file_permission="inherit",  # type: Optional[str]
        file_permission_key=None,  # type: Optional[str]
        file_attributes="none",  # type: str
        file_creation_time="now",  # type: str
        file_last_write_time="now",  # type: str
        file_http_headers=None,  # type: Optional["_models.FileHTTPHeaders"]
        lease_access_conditions=None,  # type: Optional["_models.LeaseAccessConditions"]
        **kwargs  # type: Any
    ):
        # type: (...) -> None
        """Creates a new file or replaces a file. Note it only initializes the file with no content.

        :param share_name: The name of the target share.
        :type share_name: str
        :param directory: The path of the target directory.
        :type directory: str
        :param file_name: The path of the target file.
        :type file_name: str
        :param file_content_length: Specifies the maximum size for the file, up to 4 TB.
        :type file_content_length: long
        :param timeout: The timeout parameter is expressed in seconds. For more information, see
         :code:`<a
         href="https://docs.microsoft.com/en-us/rest/api/storageservices/Setting-Timeouts-for-File-Service-Operations?redirectedfrom=MSDN">Setting
         Timeouts for File Service Operations.</a>`.
        :type timeout: int
        :param metadata: A name-value pair to associate with a file storage object.
        :type metadata: dict[str, str]
        :param file_permission: If specified the permission (security descriptor) shall be set for the
         directory/file. This header can be used if Permission size is <= 8KB, else
         x-ms-file-permission-key header shall be used. Default value: Inherit. If SDDL is specified as
         input, it must have owner, group and dacl. Note: Only one of the x-ms-file-permission or
         x-ms-file-permission-key should be specified.
        :type file_permission: str
        :param file_permission_key: Key of the permission to be set for the directory/file. Note: Only
         one of the x-ms-file-permission or x-ms-file-permission-key should be specified.
        :type file_permission_key: str
        :param file_attributes: If specified, the provided file attributes shall be set. Default value:
         ‘Archive’ for file and ‘Directory’ for directory. ‘None’ can also be specified as default.
        :type file_attributes: str
        :param file_creation_time: Creation time for the file/directory. Default value: Now.
        :type file_creation_time: str
        :param file_last_write_time: Last write time for the file/directory. Default value: Now.
        :type file_last_write_time: str
        :param file_http_headers: Parameter group.
        :type file_http_headers: ~azure.storage.fileshare.models.FileHTTPHeaders
        :param lease_access_conditions: Parameter group.
        :type lease_access_conditions: ~azure.storage.fileshare.models.LeaseAccessConditions
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: None, or the result of cls(response)
        :rtype: None
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType[None]
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}))

        _file_content_type = None
        _file_content_encoding = None
        _file_content_language = None
        _file_cache_control = None
        _file_content_md5 = None
        _file_content_disposition = None
        _lease_id = None
        if file_http_headers is not None:
            _file_content_type = file_http_headers.file_content_type
            _file_content_encoding = file_http_headers.file_content_encoding
            _file_content_language = file_http_headers.file_content_language
            _file_cache_control = file_http_headers.file_cache_control
            _file_content_md5 = file_http_headers.file_content_md5
            _file_content_disposition = file_http_headers.file_content_disposition
        if lease_access_conditions is not None:
            _lease_id = lease_access_conditions.lease_id

        request = build_create_request(
            share_name=share_name,
            directory=directory,
            file_name=file_name,
            file_content_length=file_content_length,
            timeout=timeout,
            file_content_type=_file_content_type,
            file_content_encoding=_file_content_encoding,
            file_content_language=_file_content_language,
            file_cache_control=_file_cache_control,
            file_content_md5=_file_content_md5,
            file_content_disposition=_file_content_disposition,
            metadata=metadata,
            file_permission=file_permission,
            file_permission_key=file_permission_key,
            file_attributes=file_attributes,
            file_creation_time=file_creation_time,
            file_last_write_time=file_last_write_time,
            lease_id=_lease_id,
            template_url=self.create.metadata['url'],
        )
        request = _convert_request(request)
        path_format_arguments = {
            "url": self._serialize.url("self._config.url", self._config.url, 'str', skip_quote=True),
        }
        request.url = self._client.format_url(request.url, **path_format_arguments)

        pipeline_response = self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [201]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize.failsafe_deserialize(_models.StorageError, pipeline_response)
            raise HttpResponseError(response=response, model=error)

        response_headers = {}
        response_headers['ETag']=self._deserialize('str', response.headers.get('ETag'))
        response_headers['Last-Modified']=self._deserialize('rfc-1123', response.headers.get('Last-Modified'))
        response_headers['x-ms-request-id']=self._deserialize('str', response.headers.get('x-ms-request-id'))
        response_headers['x-ms-version']=self._deserialize('str', response.headers.get('x-ms-version'))
        response_headers['Date']=self._deserialize('rfc-1123', response.headers.get('Date'))
        response_headers['x-ms-request-server-encrypted']=self._deserialize('bool', response.headers.get('x-ms-request-server-encrypted'))
        response_headers['x-ms-file-permission-key']=self._deserialize('str', response.headers.get('x-ms-file-permission-key'))
        response_headers['x-ms-file-attributes']=self._deserialize('str', response.headers.get('x-ms-file-attributes'))
        response_headers['x-ms-file-creation-time']=self._deserialize('str', response.headers.get('x-ms-file-creation-time'))
        response_headers['x-ms-file-last-write-time']=self._deserialize('str', response.headers.get('x-ms-file-last-write-time'))
        response_headers['x-ms-file-change-time']=self._deserialize('str', response.headers.get('x-ms-file-change-time'))
        response_headers['x-ms-file-id']=self._deserialize('str', response.headers.get('x-ms-file-id'))
        response_headers['x-ms-file-parent-id']=self._deserialize('str', response.headers.get('x-ms-file-parent-id'))


        if cls:
            return cls(pipeline_response, None, response_headers)

    create.metadata = {'url': '/{shareName}/{directory}/{fileName}'}  # type: ignore


    @distributed_trace
    def download(
        self,
        share_name,  # type: str
        directory,  # type: str
        file_name,  # type: str
        timeout=None,  # type: Optional[int]
        range=None,  # type: Optional[str]
        range_get_content_md5=None,  # type: Optional[bool]
        lease_access_conditions=None,  # type: Optional["_models.LeaseAccessConditions"]
        **kwargs  # type: Any
    ):
        # type: (...) -> IO
        """Reads or downloads a file from the system, including its metadata and properties.

        :param share_name: The name of the target share.
        :type share_name: str
        :param directory: The path of the target directory.
        :type directory: str
        :param file_name: The path of the target file.
        :type file_name: str
        :param timeout: The timeout parameter is expressed in seconds. For more information, see
         :code:`<a
         href="https://docs.microsoft.com/en-us/rest/api/storageservices/Setting-Timeouts-for-File-Service-Operations?redirectedfrom=MSDN">Setting
         Timeouts for File Service Operations.</a>`.
        :type timeout: int
        :param range: Return file data only from the specified byte range.
        :type range: str
        :param range_get_content_md5: When this header is set to true and specified together with the
         Range header, the service returns the MD5 hash for the range, as long as the range is less than
         or equal to 4 MB in size.
        :type range_get_content_md5: bool
        :param lease_access_conditions: Parameter group.
        :type lease_access_conditions: ~azure.storage.fileshare.models.LeaseAccessConditions
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: IO, or the result of cls(response)
        :rtype: IO
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType[IO]
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}))

        _lease_id = None
        if lease_access_conditions is not None:
            _lease_id = lease_access_conditions.lease_id

        request = build_download_request(
            share_name=share_name,
            directory=directory,
            file_name=file_name,
            timeout=timeout,
            range=range,
            range_get_content_md5=range_get_content_md5,
            lease_id=_lease_id,
            template_url=self.download.metadata['url'],
        )
        request = _convert_request(request)
        path_format_arguments = {
            "url": self._serialize.url("self._config.url", self._config.url, 'str', skip_quote=True),
        }
        request.url = self._client.format_url(request.url, **path_format_arguments)

        pipeline_response = self._client._pipeline.run(request, stream=True, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [200, 206]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize.failsafe_deserialize(_models.StorageError, pipeline_response)
            raise HttpResponseError(response=response, model=error)

        response_headers = {}
        if response.status_code == 200:
            response_headers['Last-Modified']=self._deserialize('rfc-1123', response.headers.get('Last-Modified'))
            response_headers['x-ms-meta']=self._deserialize('{str}', response.headers.get('x-ms-meta'))
            response_headers['Content-Length']=self._deserialize('long', response.headers.get('Content-Length'))
            response_headers['Content-Type']=self._deserialize('str', response.headers.get('Content-Type'))
            response_headers['Content-Range']=self._deserialize('str', response.headers.get('Content-Range'))
            response_headers['ETag']=self._deserialize('str', response.headers.get('ETag'))
            response_headers['Content-MD5']=self._deserialize('bytearray', response.headers.get('Content-MD5'))
            response_headers['Content-Encoding']=self._deserialize('str', response.headers.get('Content-Encoding'))
            response_headers['Cache-Control']=self._deserialize('str', response.headers.get('Cache-Control'))
            response_headers['Content-Disposition']=self._deserialize('str', response.headers.get('Content-Disposition'))
            response_headers['Content-Language']=self._deserialize('str', response.headers.get('Content-Language'))
            response_headers['x-ms-request-id']=self._deserialize('str', response.headers.get('x-ms-request-id'))
            response_headers['x-ms-version']=self._deserialize('str', response.headers.get('x-ms-version'))
            response_headers['Accept-Ranges']=self._deserialize('str', response.headers.get('Accept-Ranges'))
            response_headers['Date']=self._deserialize('rfc-1123', response.headers.get('Date'))
            response_headers['x-ms-copy-completion-time']=self._deserialize('rfc-1123', response.headers.get('x-ms-copy-completion-time'))
            response_headers['x-ms-copy-status-description']=self._deserialize('str', response.headers.get('x-ms-copy-status-description'))
            response_headers['x-ms-copy-id']=self._deserialize('str', response.headers.get('x-ms-copy-id'))
            response_headers['x-ms-copy-progress']=self._deserialize('str', response.headers.get('x-ms-copy-progress'))
            response_headers['x-ms-copy-source']=self._deserialize('str', response.headers.get('x-ms-copy-source'))
            response_headers['x-ms-copy-status']=self._deserialize('str', response.headers.get('x-ms-copy-status'))
            response_headers['x-ms-content-md5']=self._deserialize('bytearray', response.headers.get('x-ms-content-md5'))
            response_headers['x-ms-server-encrypted']=self._deserialize('bool', response.headers.get('x-ms-server-encrypted'))
            response_headers['x-ms-file-attributes']=self._deserialize('str', response.headers.get('x-ms-file-attributes'))
            response_headers['x-ms-file-creation-time']=self._deserialize('str', response.headers.get('x-ms-file-creation-time'))
            response_headers['x-ms-file-last-write-time']=self._deserialize('str', response.headers.get('x-ms-file-last-write-time'))
            response_headers['x-ms-file-change-time']=self._deserialize('str', response.headers.get('x-ms-file-change-time'))
            response_headers['x-ms-file-permission-key']=self._deserialize('str', response.headers.get('x-ms-file-permission-key'))
            response_headers['x-ms-file-id']=self._deserialize('str', response.headers.get('x-ms-file-id'))
            response_headers['x-ms-file-parent-id']=self._deserialize('str', response.headers.get('x-ms-file-parent-id'))
            response_headers['x-ms-lease-duration']=self._deserialize('str', response.headers.get('x-ms-lease-duration'))
            response_headers['x-ms-lease-state']=self._deserialize('str', response.headers.get('x-ms-lease-state'))
            response_headers['x-ms-lease-status']=self._deserialize('str', response.headers.get('x-ms-lease-status'))
            
            deserialized = response.stream_download(self._client._pipeline)

        if response.status_code == 206:
            response_headers['Last-Modified']=self._deserialize('rfc-1123', response.headers.get('Last-Modified'))
            response_headers['x-ms-meta']=self._deserialize('{str}', response.headers.get('x-ms-meta'))
            response_headers['Content-Length']=self._deserialize('long', response.headers.get('Content-Length'))
            response_headers['Content-Type']=self._deserialize('str', response.headers.get('Content-Type'))
            response_headers['Content-Range']=self._deserialize('str', response.headers.get('Content-Range'))
            response_headers['ETag']=self._deserialize('str', response.headers.get('ETag'))
            response_headers['Content-MD5']=self._deserialize('bytearray', response.headers.get('Content-MD5'))
            response_headers['Content-Encoding']=self._deserialize('str', response.headers.get('Content-Encoding'))
            response_headers['Cache-Control']=self._deserialize('str', response.headers.get('Cache-Control'))
            response_headers['Content-Disposition']=self._deserialize('str', response.headers.get('Content-Disposition'))
            response_headers['Content-Language']=self._deserialize('str', response.headers.get('Content-Language'))
            response_headers['x-ms-request-id']=self._deserialize('str', response.headers.get('x-ms-request-id'))
            response_headers['x-ms-version']=self._deserialize('str', response.headers.get('x-ms-version'))
            response_headers['Accept-Ranges']=self._deserialize('str', response.headers.get('Accept-Ranges'))
            response_headers['Date']=self._deserialize('rfc-1123', response.headers.get('Date'))
            response_headers['x-ms-copy-completion-time']=self._deserialize('rfc-1123', response.headers.get('x-ms-copy-completion-time'))
            response_headers['x-ms-copy-status-description']=self._deserialize('str', response.headers.get('x-ms-copy-status-description'))
            response_headers['x-ms-copy-id']=self._deserialize('str', response.headers.get('x-ms-copy-id'))
            response_headers['x-ms-copy-progress']=self._deserialize('str', response.headers.get('x-ms-copy-progress'))
            response_headers['x-ms-copy-source']=self._deserialize('str', response.headers.get('x-ms-copy-source'))
            response_headers['x-ms-copy-status']=self._deserialize('str', response.headers.get('x-ms-copy-status'))
            response_headers['x-ms-content-md5']=self._deserialize('bytearray', response.headers.get('x-ms-content-md5'))
            response_headers['x-ms-server-encrypted']=self._deserialize('bool', response.headers.get('x-ms-server-encrypted'))
            response_headers['x-ms-file-attributes']=self._deserialize('str', response.headers.get('x-ms-file-attributes'))
            response_headers['x-ms-file-creation-time']=self._deserialize('str', response.headers.get('x-ms-file-creation-time'))
            response_headers['x-ms-file-last-write-time']=self._deserialize('str', response.headers.get('x-ms-file-last-write-time'))
            response_headers['x-ms-file-change-time']=self._deserialize('str', response.headers.get('x-ms-file-change-time'))
            response_headers['x-ms-file-permission-key']=self._deserialize('str', response.headers.get('x-ms-file-permission-key'))
            response_headers['x-ms-file-id']=self._deserialize('str', response.headers.get('x-ms-file-id'))
            response_headers['x-ms-file-parent-id']=self._deserialize('str', response.headers.get('x-ms-file-parent-id'))
            response_headers['x-ms-lease-duration']=self._deserialize('str', response.headers.get('x-ms-lease-duration'))
            response_headers['x-ms-lease-state']=self._deserialize('str', response.headers.get('x-ms-lease-state'))
            response_headers['x-ms-lease-status']=self._deserialize('str', response.headers.get('x-ms-lease-status'))
            
            deserialized = response.stream_download(self._client._pipeline)

        if cls:
            return cls(pipeline_response, deserialized, response_headers)

        return deserialized

    download.metadata = {'url': '/{shareName}/{directory}/{fileName}'}  # type: ignore


    @distributed_trace
    def get_properties(
        self,
        share_name,  # type: str
        directory,  # type: str
        file_name,  # type: str
        sharesnapshot=None,  # type: Optional[str]
        timeout=None,  # type: Optional[int]
        lease_access_conditions=None,  # type: Optional["_models.LeaseAccessConditions"]
        **kwargs  # type: Any
    ):
        # type: (...) -> None
        """Returns all user-defined metadata, standard HTTP properties, and system properties for the
        file. It does not return the content of the file.

        :param share_name: The name of the target share.
        :type share_name: str
        :param directory: The path of the target directory.
        :type directory: str
        :param file_name: The path of the target file.
        :type file_name: str
        :param sharesnapshot: The snapshot parameter is an opaque DateTime value that, when present,
         specifies the share snapshot to query.
        :type sharesnapshot: str
        :param timeout: The timeout parameter is expressed in seconds. For more information, see
         :code:`<a
         href="https://docs.microsoft.com/en-us/rest/api/storageservices/Setting-Timeouts-for-File-Service-Operations?redirectedfrom=MSDN">Setting
         Timeouts for File Service Operations.</a>`.
        :type timeout: int
        :param lease_access_conditions: Parameter group.
        :type lease_access_conditions: ~azure.storage.fileshare.models.LeaseAccessConditions
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: None, or the result of cls(response)
        :rtype: None
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType[None]
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}))

        _lease_id = None
        if lease_access_conditions is not None:
            _lease_id = lease_access_conditions.lease_id

        request = build_get_properties_request(
            share_name=share_name,
            directory=directory,
            file_name=file_name,
            sharesnapshot=sharesnapshot,
            timeout=timeout,
            lease_id=_lease_id,
            template_url=self.get_properties.metadata['url'],
        )
        request = _convert_request(request)
        path_format_arguments = {
            "url": self._serialize.url("self._config.url", self._config.url, 'str', skip_quote=True),
        }
        request.url = self._client.format_url(request.url, **path_format_arguments)

        pipeline_response = self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize.failsafe_deserialize(_models.StorageError, pipeline_response)
            raise HttpResponseError(response=response, model=error)

        response_headers = {}
        response_headers['Last-Modified']=self._deserialize('rfc-1123', response.headers.get('Last-Modified'))
        response_headers['x-ms-meta']=self._deserialize('{str}', response.headers.get('x-ms-meta'))
        response_headers['x-ms-type']=self._deserialize('str', response.headers.get('x-ms-type'))
        response_headers['Content-Length']=self._deserialize('long', response.headers.get('Content-Length'))
        response_headers['Content-Type']=self._deserialize('str', response.headers.get('Content-Type'))
        response_headers['ETag']=self._deserialize('str', response.headers.get('ETag'))
        response_headers['Content-MD5']=self._deserialize('bytearray', response.headers.get('Content-MD5'))
        response_headers['Content-Encoding']=self._deserialize('str', response.headers.get('Content-Encoding'))
        response_headers['Cache-Control']=self._deserialize('str', response.headers.get('Cache-Control'))
        response_headers['Content-Disposition']=self._deserialize('str', response.headers.get('Content-Disposition'))
        response_headers['Content-Language']=self._deserialize('str', response.headers.get('Content-Language'))
        response_headers['x-ms-request-id']=self._deserialize('str', response.headers.get('x-ms-request-id'))
        response_headers['x-ms-version']=self._deserialize('str', response.headers.get('x-ms-version'))
        response_headers['Date']=self._deserialize('rfc-1123', response.headers.get('Date'))
        response_headers['x-ms-copy-completion-time']=self._deserialize('rfc-1123', response.headers.get('x-ms-copy-completion-time'))
        response_headers['x-ms-copy-status-description']=self._deserialize('str', response.headers.get('x-ms-copy-status-description'))
        response_headers['x-ms-copy-id']=self._deserialize('str', response.headers.get('x-ms-copy-id'))
        response_headers['x-ms-copy-progress']=self._deserialize('str', response.headers.get('x-ms-copy-progress'))
        response_headers['x-ms-copy-source']=self._deserialize('str', response.headers.get('x-ms-copy-source'))
        response_headers['x-ms-copy-status']=self._deserialize('str', response.headers.get('x-ms-copy-status'))
        response_headers['x-ms-server-encrypted']=self._deserialize('bool', response.headers.get('x-ms-server-encrypted'))
        response_headers['x-ms-file-attributes']=self._deserialize('str', response.headers.get('x-ms-file-attributes'))
        response_headers['x-ms-file-creation-time']=self._deserialize('str', response.headers.get('x-ms-file-creation-time'))
        response_headers['x-ms-file-last-write-time']=self._deserialize('str', response.headers.get('x-ms-file-last-write-time'))
        response_headers['x-ms-file-change-time']=self._deserialize('str', response.headers.get('x-ms-file-change-time'))
        response_headers['x-ms-file-permission-key']=self._deserialize('str', response.headers.get('x-ms-file-permission-key'))
        response_headers['x-ms-file-id']=self._deserialize('str', response.headers.get('x-ms-file-id'))
        response_headers['x-ms-file-parent-id']=self._deserialize('str', response.headers.get('x-ms-file-parent-id'))
        response_headers['x-ms-lease-duration']=self._deserialize('str', response.headers.get('x-ms-lease-duration'))
        response_headers['x-ms-lease-state']=self._deserialize('str', response.headers.get('x-ms-lease-state'))
        response_headers['x-ms-lease-status']=self._deserialize('str', response.headers.get('x-ms-lease-status'))


        if cls:
            return cls(pipeline_response, None, response_headers)

    get_properties.metadata = {'url': '/{shareName}/{directory}/{fileName}'}  # type: ignore


    @distributed_trace
    def delete(
        self,
        share_name,  # type: str
        directory,  # type: str
        file_name,  # type: str
        timeout=None,  # type: Optional[int]
        lease_access_conditions=None,  # type: Optional["_models.LeaseAccessConditions"]
        **kwargs  # type: Any
    ):
        # type: (...) -> None
        """removes the file from the storage account.

        :param share_name: The name of the target share.
        :type share_name: str
        :param directory: The path of the target directory.
        :type directory: str
        :param file_name: The path of the target file.
        :type file_name: str
        :param timeout: The timeout parameter is expressed in seconds. For more information, see
         :code:`<a
         href="https://docs.microsoft.com/en-us/rest/api/storageservices/Setting-Timeouts-for-File-Service-Operations?redirectedfrom=MSDN">Setting
         Timeouts for File Service Operations.</a>`.
        :type timeout: int
        :param lease_access_conditions: Parameter group.
        :type lease_access_conditions: ~azure.storage.fileshare.models.LeaseAccessConditions
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: None, or the result of cls(response)
        :rtype: None
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType[None]
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}))

        _lease_id = None
        if lease_access_conditions is not None:
            _lease_id = lease_access_conditions.lease_id

        request = build_delete_request(
            share_name=share_name,
            directory=directory,
            file_name=file_name,
            timeout=timeout,
            lease_id=_lease_id,
            template_url=self.delete.metadata['url'],
        )
        request = _convert_request(request)
        path_format_arguments = {
            "url": self._serialize.url("self._config.url", self._config.url, 'str', skip_quote=True),
        }
        request.url = self._client.format_url(request.url, **path_format_arguments)

        pipeline_response = self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [202]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize.failsafe_deserialize(_models.StorageError, pipeline_response)
            raise HttpResponseError(response=response, model=error)

        response_headers = {}
        response_headers['x-ms-request-id']=self._deserialize('str', response.headers.get('x-ms-request-id'))
        response_headers['x-ms-version']=self._deserialize('str', response.headers.get('x-ms-version'))
        response_headers['Date']=self._deserialize('rfc-1123', response.headers.get('Date'))


        if cls:
            return cls(pipeline_response, None, response_headers)

    delete.metadata = {'url': '/{shareName}/{directory}/{fileName}'}  # type: ignore


    @distributed_trace
    def set_http_headers(
        self,
        share_name,  # type: str
        directory,  # type: str
        file_name,  # type: str
        timeout=None,  # type: Optional[int]
        file_content_length=None,  # type: Optional[int]
        file_permission="inherit",  # type: Optional[str]
        file_permission_key=None,  # type: Optional[str]
        file_attributes="none",  # type: str
        file_creation_time="now",  # type: str
        file_last_write_time="now",  # type: str
        file_http_headers=None,  # type: Optional["_models.FileHTTPHeaders"]
        lease_access_conditions=None,  # type: Optional["_models.LeaseAccessConditions"]
        **kwargs  # type: Any
    ):
        # type: (...) -> None
        """Sets HTTP headers on the file.

        :param share_name: The name of the target share.
        :type share_name: str
        :param directory: The path of the target directory.
        :type directory: str
        :param file_name: The path of the target file.
        :type file_name: str
        :param timeout: The timeout parameter is expressed in seconds. For more information, see
         :code:`<a
         href="https://docs.microsoft.com/en-us/rest/api/storageservices/Setting-Timeouts-for-File-Service-Operations?redirectedfrom=MSDN">Setting
         Timeouts for File Service Operations.</a>`.
        :type timeout: int
        :param file_content_length: Resizes a file to the specified size. If the specified byte value
         is less than the current size of the file, then all ranges above the specified byte value are
         cleared.
        :type file_content_length: long
        :param file_permission: If specified the permission (security descriptor) shall be set for the
         directory/file. This header can be used if Permission size is <= 8KB, else
         x-ms-file-permission-key header shall be used. Default value: Inherit. If SDDL is specified as
         input, it must have owner, group and dacl. Note: Only one of the x-ms-file-permission or
         x-ms-file-permission-key should be specified.
        :type file_permission: str
        :param file_permission_key: Key of the permission to be set for the directory/file. Note: Only
         one of the x-ms-file-permission or x-ms-file-permission-key should be specified.
        :type file_permission_key: str
        :param file_attributes: If specified, the provided file attributes shall be set. Default value:
         ‘Archive’ for file and ‘Directory’ for directory. ‘None’ can also be specified as default.
        :type file_attributes: str
        :param file_creation_time: Creation time for the file/directory. Default value: Now.
        :type file_creation_time: str
        :param file_last_write_time: Last write time for the file/directory. Default value: Now.
        :type file_last_write_time: str
        :param file_http_headers: Parameter group.
        :type file_http_headers: ~azure.storage.fileshare.models.FileHTTPHeaders
        :param lease_access_conditions: Parameter group.
        :type lease_access_conditions: ~azure.storage.fileshare.models.LeaseAccessConditions
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: None, or the result of cls(response)
        :rtype: None
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType[None]
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}))

        _file_content_type = None
        _file_content_encoding = None
        _file_content_language = None
        _file_cache_control = None
        _file_content_md5 = None
        _file_content_disposition = None
        _lease_id = None
        if file_http_headers is not None:
            _file_content_type = file_http_headers.file_content_type
            _file_content_encoding = file_http_headers.file_content_encoding
            _file_content_language = file_http_headers.file_content_language
            _file_cache_control = file_http_headers.file_cache_control
            _file_content_md5 = file_http_headers.file_content_md5
            _file_content_disposition = file_http_headers.file_content_disposition
        if lease_access_conditions is not None:
            _lease_id = lease_access_conditions.lease_id

        request = build_set_http_headers_request(
            share_name=share_name,
            directory=directory,
            file_name=file_name,
            timeout=timeout,
            file_content_length=file_content_length,
            file_content_type=_file_content_type,
            file_content_encoding=_file_content_encoding,
            file_content_language=_file_content_language,
            file_cache_control=_file_cache_control,
            file_content_md5=_file_content_md5,
            file_content_disposition=_file_content_disposition,
            file_permission=file_permission,
            file_permission_key=file_permission_key,
            file_attributes=file_attributes,
            file_creation_time=file_creation_time,
            file_last_write_time=file_last_write_time,
            lease_id=_lease_id,
            template_url=self.set_http_headers.metadata['url'],
        )
        request = _convert_request(request)
        path_format_arguments = {
            "url": self._serialize.url("self._config.url", self._config.url, 'str', skip_quote=True),
        }
        request.url = self._client.format_url(request.url, **path_format_arguments)

        pipeline_response = self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize.failsafe_deserialize(_models.StorageError, pipeline_response)
            raise HttpResponseError(response=response, model=error)

        response_headers = {}
        response_headers['ETag']=self._deserialize('str', response.headers.get('ETag'))
        response_headers['Last-Modified']=self._deserialize('rfc-1123', response.headers.get('Last-Modified'))
        response_headers['x-ms-request-id']=self._deserialize('str', response.headers.get('x-ms-request-id'))
        response_headers['x-ms-version']=self._deserialize('str', response.headers.get('x-ms-version'))
        response_headers['Date']=self._deserialize('rfc-1123', response.headers.get('Date'))
        response_headers['x-ms-request-server-encrypted']=self._deserialize('bool', response.headers.get('x-ms-request-server-encrypted'))
        response_headers['x-ms-file-permission-key']=self._deserialize('str', response.headers.get('x-ms-file-permission-key'))
        response_headers['x-ms-file-attributes']=self._deserialize('str', response.headers.get('x-ms-file-attributes'))
        response_headers['x-ms-file-creation-time']=self._deserialize('str', response.headers.get('x-ms-file-creation-time'))
        response_headers['x-ms-file-last-write-time']=self._deserialize('str', response.headers.get('x-ms-file-last-write-time'))
        response_headers['x-ms-file-change-time']=self._deserialize('str', response.headers.get('x-ms-file-change-time'))
        response_headers['x-ms-file-id']=self._deserialize('str', response.headers.get('x-ms-file-id'))
        response_headers['x-ms-file-parent-id']=self._deserialize('str', response.headers.get('x-ms-file-parent-id'))


        if cls:
            return cls(pipeline_response, None, response_headers)

    set_http_headers.metadata = {'url': '/{shareName}/{directory}/{fileName}'}  # type: ignore


    @distributed_trace
    def set_metadata(
        self,
        share_name,  # type: str
        directory,  # type: str
        file_name,  # type: str
        timeout=None,  # type: Optional[int]
        metadata=None,  # type: Optional[Dict[str, str]]
        lease_access_conditions=None,  # type: Optional["_models.LeaseAccessConditions"]
        **kwargs  # type: Any
    ):
        # type: (...) -> None
        """Updates user-defined metadata for the specified file.

        :param share_name: The name of the target share.
        :type share_name: str
        :param directory: The path of the target directory.
        :type directory: str
        :param file_name: The path of the target file.
        :type file_name: str
        :param timeout: The timeout parameter is expressed in seconds. For more information, see
         :code:`<a
         href="https://docs.microsoft.com/en-us/rest/api/storageservices/Setting-Timeouts-for-File-Service-Operations?redirectedfrom=MSDN">Setting
         Timeouts for File Service Operations.</a>`.
        :type timeout: int
        :param metadata: A name-value pair to associate with a file storage object.
        :type metadata: dict[str, str]
        :param lease_access_conditions: Parameter group.
        :type lease_access_conditions: ~azure.storage.fileshare.models.LeaseAccessConditions
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: None, or the result of cls(response)
        :rtype: None
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType[None]
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}))

        _lease_id = None
        if lease_access_conditions is not None:
            _lease_id = lease_access_conditions.lease_id

        request = build_set_metadata_request(
            share_name=share_name,
            directory=directory,
            file_name=file_name,
            timeout=timeout,
            metadata=metadata,
            lease_id=_lease_id,
            template_url=self.set_metadata.metadata['url'],
        )
        request = _convert_request(request)
        path_format_arguments = {
            "url": self._serialize.url("self._config.url", self._config.url, 'str', skip_quote=True),
        }
        request.url = self._client.format_url(request.url, **path_format_arguments)

        pipeline_response = self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize.failsafe_deserialize(_models.StorageError, pipeline_response)
            raise HttpResponseError(response=response, model=error)

        response_headers = {}
        response_headers['ETag']=self._deserialize('str', response.headers.get('ETag'))
        response_headers['x-ms-request-id']=self._deserialize('str', response.headers.get('x-ms-request-id'))
        response_headers['x-ms-version']=self._deserialize('str', response.headers.get('x-ms-version'))
        response_headers['Date']=self._deserialize('rfc-1123', response.headers.get('Date'))
        response_headers['x-ms-request-server-encrypted']=self._deserialize('bool', response.headers.get('x-ms-request-server-encrypted'))


        if cls:
            return cls(pipeline_response, None, response_headers)

    set_metadata.metadata = {'url': '/{shareName}/{directory}/{fileName}'}  # type: ignore


    @distributed_trace
    def acquire_lease(
        self,
        share_name,  # type: str
        directory,  # type: str
        file_name,  # type: str
        timeout=None,  # type: Optional[int]
        duration=None,  # type: Optional[int]
        proposed_lease_id=None,  # type: Optional[str]
        request_id_parameter=None,  # type: Optional[str]
        **kwargs  # type: Any
    ):
        # type: (...) -> None
        """[Update] The Lease File operation establishes and manages a lock on a file for write and delete
        operations.

        :param share_name: The name of the target share.
        :type share_name: str
        :param directory: The path of the target directory.
        :type directory: str
        :param file_name: The path of the target file.
        :type file_name: str
        :param timeout: The timeout parameter is expressed in seconds. For more information, see
         :code:`<a
         href="https://docs.microsoft.com/en-us/rest/api/storageservices/Setting-Timeouts-for-File-Service-Operations?redirectedfrom=MSDN">Setting
         Timeouts for File Service Operations.</a>`.
        :type timeout: int
        :param duration: Specifies the duration of the lease, in seconds, or negative one (-1) for a
         lease that never expires. A non-infinite lease can be between 15 and 60 seconds. A lease
         duration cannot be changed using renew or change.
        :type duration: int
        :param proposed_lease_id: Proposed lease ID, in a GUID string format. The File service returns
         400 (Invalid request) if the proposed lease ID is not in the correct format. See Guid
         Constructor (String) for a list of valid GUID string formats.
        :type proposed_lease_id: str
        :param request_id_parameter: Provides a client-generated, opaque value with a 1 KB character
         limit that is recorded in the analytics logs when storage analytics logging is enabled.
        :type request_id_parameter: str
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: None, or the result of cls(response)
        :rtype: None
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType[None]
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}))

        
        request = build_acquire_lease_request(
            share_name=share_name,
            directory=directory,
            file_name=file_name,
            timeout=timeout,
            duration=duration,
            proposed_lease_id=proposed_lease_id,
            request_id_parameter=request_id_parameter,
            template_url=self.acquire_lease.metadata['url'],
        )
        request = _convert_request(request)
        path_format_arguments = {
            "url": self._serialize.url("self._config.url", self._config.url, 'str', skip_quote=True),
        }
        request.url = self._client.format_url(request.url, **path_format_arguments)

        pipeline_response = self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [201]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize.failsafe_deserialize(_models.StorageError, pipeline_response)
            raise HttpResponseError(response=response, model=error)

        response_headers = {}
        response_headers['ETag']=self._deserialize('str', response.headers.get('ETag'))
        response_headers['Last-Modified']=self._deserialize('rfc-1123', response.headers.get('Last-Modified'))
        response_headers['x-ms-lease-id']=self._deserialize('str', response.headers.get('x-ms-lease-id'))
        response_headers['x-ms-client-request-id']=self._deserialize('str', response.headers.get('x-ms-client-request-id'))
        response_headers['x-ms-request-id']=self._deserialize('str', response.headers.get('x-ms-request-id'))
        response_headers['x-ms-version']=self._deserialize('str', response.headers.get('x-ms-version'))
        response_headers['Date']=self._deserialize('rfc-1123', response.headers.get('Date'))


        if cls:
            return cls(pipeline_response, None, response_headers)

    acquire_lease.metadata = {'url': '/{shareName}/{directory}/{fileName}'}  # type: ignore


    @distributed_trace
    def release_lease(
        self,
        share_name,  # type: str
        directory,  # type: str
        file_name,  # type: str
        lease_id,  # type: str
        timeout=None,  # type: Optional[int]
        request_id_parameter=None,  # type: Optional[str]
        **kwargs  # type: Any
    ):
        # type: (...) -> None
        """[Update] The Lease File operation establishes and manages a lock on a file for write and delete
        operations.

        :param share_name: The name of the target share.
        :type share_name: str
        :param directory: The path of the target directory.
        :type directory: str
        :param file_name: The path of the target file.
        :type file_name: str
        :param lease_id: Specifies the current lease ID on the resource.
        :type lease_id: str
        :param timeout: The timeout parameter is expressed in seconds. For more information, see
         :code:`<a
         href="https://docs.microsoft.com/en-us/rest/api/storageservices/Setting-Timeouts-for-File-Service-Operations?redirectedfrom=MSDN">Setting
         Timeouts for File Service Operations.</a>`.
        :type timeout: int
        :param request_id_parameter: Provides a client-generated, opaque value with a 1 KB character
         limit that is recorded in the analytics logs when storage analytics logging is enabled.
        :type request_id_parameter: str
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: None, or the result of cls(response)
        :rtype: None
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType[None]
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}))

        
        request = build_release_lease_request(
            share_name=share_name,
            directory=directory,
            file_name=file_name,
            lease_id=lease_id,
            timeout=timeout,
            request_id_parameter=request_id_parameter,
            template_url=self.release_lease.metadata['url'],
        )
        request = _convert_request(request)
        path_format_arguments = {
            "url": self._serialize.url("self._config.url", self._config.url, 'str', skip_quote=True),
        }
        request.url = self._client.format_url(request.url, **path_format_arguments)

        pipeline_response = self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize.failsafe_deserialize(_models.StorageError, pipeline_response)
            raise HttpResponseError(response=response, model=error)

        response_headers = {}
        response_headers['ETag']=self._deserialize('str', response.headers.get('ETag'))
        response_headers['Last-Modified']=self._deserialize('rfc-1123', response.headers.get('Last-Modified'))
        response_headers['x-ms-client-request-id']=self._deserialize('str', response.headers.get('x-ms-client-request-id'))
        response_headers['x-ms-request-id']=self._deserialize('str', response.headers.get('x-ms-request-id'))
        response_headers['x-ms-version']=self._deserialize('str', response.headers.get('x-ms-version'))
        response_headers['Date']=self._deserialize('rfc-1123', response.headers.get('Date'))


        if cls:
            return cls(pipeline_response, None, response_headers)

    release_lease.metadata = {'url': '/{shareName}/{directory}/{fileName}'}  # type: ignore


    @distributed_trace
    def change_lease(
        self,
        share_name,  # type: str
        directory,  # type: str
        file_name,  # type: str
        lease_id,  # type: str
        timeout=None,  # type: Optional[int]
        proposed_lease_id=None,  # type: Optional[str]
        request_id_parameter=None,  # type: Optional[str]
        **kwargs  # type: Any
    ):
        # type: (...) -> None
        """[Update] The Lease File operation establishes and manages a lock on a file for write and delete
        operations.

        :param share_name: The name of the target share.
        :type share_name: str
        :param directory: The path of the target directory.
        :type directory: str
        :param file_name: The path of the target file.
        :type file_name: str
        :param lease_id: Specifies the current lease ID on the resource.
        :type lease_id: str
        :param timeout: The timeout parameter is expressed in seconds. For more information, see
         :code:`<a
         href="https://docs.microsoft.com/en-us/rest/api/storageservices/Setting-Timeouts-for-File-Service-Operations?redirectedfrom=MSDN">Setting
         Timeouts for File Service Operations.</a>`.
        :type timeout: int
        :param proposed_lease_id: Proposed lease ID, in a GUID string format. The File service returns
         400 (Invalid request) if the proposed lease ID is not in the correct format. See Guid
         Constructor (String) for a list of valid GUID string formats.
        :type proposed_lease_id: str
        :param request_id_parameter: Provides a client-generated, opaque value with a 1 KB character
         limit that is recorded in the analytics logs when storage analytics logging is enabled.
        :type request_id_parameter: str
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: None, or the result of cls(response)
        :rtype: None
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType[None]
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}))

        
        request = build_change_lease_request(
            share_name=share_name,
            directory=directory,
            file_name=file_name,
            lease_id=lease_id,
            timeout=timeout,
            proposed_lease_id=proposed_lease_id,
            request_id_parameter=request_id_parameter,
            template_url=self.change_lease.metadata['url'],
        )
        request = _convert_request(request)
        path_format_arguments = {
            "url": self._serialize.url("self._config.url", self._config.url, 'str', skip_quote=True),
        }
        request.url = self._client.format_url(request.url, **path_format_arguments)

        pipeline_response = self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize.failsafe_deserialize(_models.StorageError, pipeline_response)
            raise HttpResponseError(response=response, model=error)

        response_headers = {}
        response_headers['ETag']=self._deserialize('str', response.headers.get('ETag'))
        response_headers['Last-Modified']=self._deserialize('rfc-1123', response.headers.get('Last-Modified'))
        response_headers['x-ms-lease-id']=self._deserialize('str', response.headers.get('x-ms-lease-id'))
        response_headers['x-ms-client-request-id']=self._deserialize('str', response.headers.get('x-ms-client-request-id'))
        response_headers['x-ms-request-id']=self._deserialize('str', response.headers.get('x-ms-request-id'))
        response_headers['x-ms-version']=self._deserialize('str', response.headers.get('x-ms-version'))
        response_headers['Date']=self._deserialize('rfc-1123', response.headers.get('Date'))


        if cls:
            return cls(pipeline_response, None, response_headers)

    change_lease.metadata = {'url': '/{shareName}/{directory}/{fileName}'}  # type: ignore


    @distributed_trace
    def break_lease(
        self,
        share_name,  # type: str
        directory,  # type: str
        file_name,  # type: str
        timeout=None,  # type: Optional[int]
        request_id_parameter=None,  # type: Optional[str]
        lease_access_conditions=None,  # type: Optional["_models.LeaseAccessConditions"]
        **kwargs  # type: Any
    ):
        # type: (...) -> None
        """[Update] The Lease File operation establishes and manages a lock on a file for write and delete
        operations.

        :param share_name: The name of the target share.
        :type share_name: str
        :param directory: The path of the target directory.
        :type directory: str
        :param file_name: The path of the target file.
        :type file_name: str
        :param timeout: The timeout parameter is expressed in seconds. For more information, see
         :code:`<a
         href="https://docs.microsoft.com/en-us/rest/api/storageservices/Setting-Timeouts-for-File-Service-Operations?redirectedfrom=MSDN">Setting
         Timeouts for File Service Operations.</a>`.
        :type timeout: int
        :param request_id_parameter: Provides a client-generated, opaque value with a 1 KB character
         limit that is recorded in the analytics logs when storage analytics logging is enabled.
        :type request_id_parameter: str
        :param lease_access_conditions: Parameter group.
        :type lease_access_conditions: ~azure.storage.fileshare.models.LeaseAccessConditions
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: None, or the result of cls(response)
        :rtype: None
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType[None]
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}))

        _lease_id = None
        if lease_access_conditions is not None:
            _lease_id = lease_access_conditions.lease_id

        request = build_break_lease_request(
            share_name=share_name,
            directory=directory,
            file_name=file_name,
            timeout=timeout,
            lease_id=_lease_id,
            request_id_parameter=request_id_parameter,
            template_url=self.break_lease.metadata['url'],
        )
        request = _convert_request(request)
        path_format_arguments = {
            "url": self._serialize.url("self._config.url", self._config.url, 'str', skip_quote=True),
        }
        request.url = self._client.format_url(request.url, **path_format_arguments)

        pipeline_response = self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [202]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize.failsafe_deserialize(_models.StorageError, pipeline_response)
            raise HttpResponseError(response=response, model=error)

        response_headers = {}
        response_headers['ETag']=self._deserialize('str', response.headers.get('ETag'))
        response_headers['Last-Modified']=self._deserialize('rfc-1123', response.headers.get('Last-Modified'))
        response_headers['x-ms-lease-id']=self._deserialize('str', response.headers.get('x-ms-lease-id'))
        response_headers['x-ms-client-request-id']=self._deserialize('str', response.headers.get('x-ms-client-request-id'))
        response_headers['x-ms-request-id']=self._deserialize('str', response.headers.get('x-ms-request-id'))
        response_headers['x-ms-version']=self._deserialize('str', response.headers.get('x-ms-version'))
        response_headers['Date']=self._deserialize('rfc-1123', response.headers.get('Date'))


        if cls:
            return cls(pipeline_response, None, response_headers)

    break_lease.metadata = {'url': '/{shareName}/{directory}/{fileName}'}  # type: ignore


    @distributed_trace
    def upload_range(
        self,
        share_name,  # type: str
        directory,  # type: str
        file_name,  # type: str
        range,  # type: str
        content_length,  # type: int
        timeout=None,  # type: Optional[int]
        file_range_write="update",  # type: Union[str, "_models.FileRangeWriteType"]
        content_md5=None,  # type: Optional[bytearray]
        optionalbody=None,  # type: Optional[IO]
        lease_access_conditions=None,  # type: Optional["_models.LeaseAccessConditions"]
        **kwargs  # type: Any
    ):
        # type: (...) -> None
        """Upload a range of bytes to a file.

        :param share_name: The name of the target share.
        :type share_name: str
        :param directory: The path of the target directory.
        :type directory: str
        :param file_name: The path of the target file.
        :type file_name: str
        :param range: Specifies the range of bytes to be written. Both the start and end of the range
         must be specified. For an update operation, the range can be up to 4 MB in size. For a clear
         operation, the range can be up to the value of the file's full size. The File service accepts
         only a single byte range for the Range and 'x-ms-range' headers, and the byte range must be
         specified in the following format: bytes=startByte-endByte.
        :type range: str
        :param content_length: Specifies the number of bytes being transmitted in the request body.
         When the x-ms-write header is set to clear, the value of this header must be set to zero.
        :type content_length: long
        :param timeout: The timeout parameter is expressed in seconds. For more information, see
         :code:`<a
         href="https://docs.microsoft.com/en-us/rest/api/storageservices/Setting-Timeouts-for-File-Service-Operations?redirectedfrom=MSDN">Setting
         Timeouts for File Service Operations.</a>`.
        :type timeout: int
        :param file_range_write: Specify one of the following options: - Update: Writes the bytes
         specified by the request body into the specified range. The Range and Content-Length headers
         must match to perform the update. - Clear: Clears the specified range and releases the space
         used in storage for that range. To clear a range, set the Content-Length header to zero, and
         set the Range header to a value that indicates the range to clear, up to maximum file size.
        :type file_range_write: str or ~azure.storage.fileshare.models.FileRangeWriteType
        :param content_md5: An MD5 hash of the content. This hash is used to verify the integrity of
         the data during transport. When the Content-MD5 header is specified, the File service compares
         the hash of the content that has arrived with the header value that was sent. If the two hashes
         do not match, the operation will fail with error code 400 (Bad Request).
        :type content_md5: bytearray
        :param optionalbody: Initial data.
        :type optionalbody: IO
        :param lease_access_conditions: Parameter group.
        :type lease_access_conditions: ~azure.storage.fileshare.models.LeaseAccessConditions
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: None, or the result of cls(response)
        :rtype: None
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType[None]
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}))

        content_type = kwargs.pop('content_type', "application/octet-stream")  # type: Optional[str]

        _lease_id = None
        if lease_access_conditions is not None:
            _lease_id = lease_access_conditions.lease_id
        content = optionalbody

        request = build_upload_range_request(
            share_name=share_name,
            directory=directory,
            file_name=file_name,
            content_type=content_type,
            range=range,
            content_length=content_length,
            timeout=timeout,
            file_range_write=file_range_write,
            content_md5=content_md5,
            lease_id=_lease_id,
            content=content,
            template_url=self.upload_range.metadata['url'],
        )
        request = _convert_request(request)
        path_format_arguments = {
            "url": self._serialize.url("self._config.url", self._config.url, 'str', skip_quote=True),
        }
        request.url = self._client.format_url(request.url, **path_format_arguments)

        pipeline_response = self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [201]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize.failsafe_deserialize(_models.StorageError, pipeline_response)
            raise HttpResponseError(response=response, model=error)

        response_headers = {}
        response_headers['ETag']=self._deserialize('str', response.headers.get('ETag'))
        response_headers['Last-Modified']=self._deserialize('rfc-1123', response.headers.get('Last-Modified'))
        response_headers['Content-MD5']=self._deserialize('bytearray', response.headers.get('Content-MD5'))
        response_headers['x-ms-request-id']=self._deserialize('str', response.headers.get('x-ms-request-id'))
        response_headers['x-ms-version']=self._deserialize('str', response.headers.get('x-ms-version'))
        response_headers['Date']=self._deserialize('rfc-1123', response.headers.get('Date'))
        response_headers['x-ms-request-server-encrypted']=self._deserialize('bool', response.headers.get('x-ms-request-server-encrypted'))


        if cls:
            return cls(pipeline_response, None, response_headers)

    upload_range.metadata = {'url': '/{shareName}/{directory}/{fileName}'}  # type: ignore


    @distributed_trace
    def upload_range_from_url(
        self,
        share_name,  # type: str
        directory,  # type: str
        file_name,  # type: str
        range,  # type: str
        copy_source,  # type: str
        content_length,  # type: int
        timeout=None,  # type: Optional[int]
        source_range=None,  # type: Optional[str]
        source_content_crc64=None,  # type: Optional[bytearray]
        copy_source_authorization=None,  # type: Optional[str]
        source_modified_access_conditions=None,  # type: Optional["_models.SourceModifiedAccessConditions"]
        lease_access_conditions=None,  # type: Optional["_models.LeaseAccessConditions"]
        **kwargs  # type: Any
    ):
        # type: (...) -> None
        """Upload a range of bytes to a file where the contents are read from a URL.

        :param share_name: The name of the target share.
        :type share_name: str
        :param directory: The path of the target directory.
        :type directory: str
        :param file_name: The path of the target file.
        :type file_name: str
        :param range: Writes data to the specified byte range in the file.
        :type range: str
        :param copy_source: Specifies the URL of the source file or blob, up to 2 KB in length. To copy
         a file to another file within the same storage account, you may use Shared Key to authenticate
         the source file. If you are copying a file from another storage account, or if you are copying
         a blob from the same storage account or another storage account, then you must authenticate the
         source file or blob using a shared access signature. If the source is a public blob, no
         authentication is required to perform the copy operation. A file in a share snapshot can also
         be specified as a copy source.
        :type copy_source: str
        :param content_length: Specifies the number of bytes being transmitted in the request body.
         When the x-ms-write header is set to clear, the value of this header must be set to zero.
        :type content_length: long
        :param timeout: The timeout parameter is expressed in seconds. For more information, see
         :code:`<a
         href="https://docs.microsoft.com/en-us/rest/api/storageservices/Setting-Timeouts-for-File-Service-Operations?redirectedfrom=MSDN">Setting
         Timeouts for File Service Operations.</a>`.
        :type timeout: int
        :param source_range: Bytes of source data in the specified range.
        :type source_range: str
        :param source_content_crc64: Specify the crc64 calculated for the range of bytes that must be
         read from the copy source.
        :type source_content_crc64: bytearray
        :param copy_source_authorization: Only Bearer type is supported. Credentials should be a valid
         OAuth access token to copy source.
        :type copy_source_authorization: str
        :param source_modified_access_conditions: Parameter group.
        :type source_modified_access_conditions:
         ~azure.storage.fileshare.models.SourceModifiedAccessConditions
        :param lease_access_conditions: Parameter group.
        :type lease_access_conditions: ~azure.storage.fileshare.models.LeaseAccessConditions
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: None, or the result of cls(response)
        :rtype: None
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType[None]
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}))

        _source_if_match_crc64 = None
        _source_if_none_match_crc64 = None
        _lease_id = None
        if source_modified_access_conditions is not None:
            _source_if_match_crc64 = source_modified_access_conditions.source_if_match_crc64
            _source_if_none_match_crc64 = source_modified_access_conditions.source_if_none_match_crc64
        if lease_access_conditions is not None:
            _lease_id = lease_access_conditions.lease_id

        request = build_upload_range_from_url_request(
            share_name=share_name,
            directory=directory,
            file_name=file_name,
            range=range,
            copy_source=copy_source,
            content_length=content_length,
            timeout=timeout,
            source_range=source_range,
            source_content_crc64=source_content_crc64,
            source_if_match_crc64=_source_if_match_crc64,
            source_if_none_match_crc64=_source_if_none_match_crc64,
            lease_id=_lease_id,
            copy_source_authorization=copy_source_authorization,
            template_url=self.upload_range_from_url.metadata['url'],
        )
        request = _convert_request(request)
        path_format_arguments = {
            "url": self._serialize.url("self._config.url", self._config.url, 'str', skip_quote=True),
        }
        request.url = self._client.format_url(request.url, **path_format_arguments)

        pipeline_response = self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [201]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize.failsafe_deserialize(_models.StorageError, pipeline_response)
            raise HttpResponseError(response=response, model=error)

        response_headers = {}
        response_headers['ETag']=self._deserialize('str', response.headers.get('ETag'))
        response_headers['Last-Modified']=self._deserialize('rfc-1123', response.headers.get('Last-Modified'))
        response_headers['x-ms-content-crc64']=self._deserialize('bytearray', response.headers.get('x-ms-content-crc64'))
        response_headers['x-ms-request-id']=self._deserialize('str', response.headers.get('x-ms-request-id'))
        response_headers['x-ms-version']=self._deserialize('str', response.headers.get('x-ms-version'))
        response_headers['Date']=self._deserialize('rfc-1123', response.headers.get('Date'))
        response_headers['x-ms-request-server-encrypted']=self._deserialize('bool', response.headers.get('x-ms-request-server-encrypted'))


        if cls:
            return cls(pipeline_response, None, response_headers)

    upload_range_from_url.metadata = {'url': '/{shareName}/{directory}/{fileName}'}  # type: ignore


    @distributed_trace
    def get_range_list(
        self,
        share_name,  # type: str
        directory,  # type: str
        file_name,  # type: str
        sharesnapshot=None,  # type: Optional[str]
        prevsharesnapshot=None,  # type: Optional[str]
        timeout=None,  # type: Optional[int]
        range=None,  # type: Optional[str]
        lease_access_conditions=None,  # type: Optional["_models.LeaseAccessConditions"]
        **kwargs  # type: Any
    ):
        # type: (...) -> "_models.ShareFileRangeList"
        """Returns the list of valid ranges for a file.

        :param share_name: The name of the target share.
        :type share_name: str
        :param directory: The path of the target directory.
        :type directory: str
        :param file_name: The path of the target file.
        :type file_name: str
        :param sharesnapshot: The snapshot parameter is an opaque DateTime value that, when present,
         specifies the share snapshot to query.
        :type sharesnapshot: str
        :param prevsharesnapshot: The previous snapshot parameter is an opaque DateTime value that,
         when present, specifies the previous snapshot.
        :type prevsharesnapshot: str
        :param timeout: The timeout parameter is expressed in seconds. For more information, see
         :code:`<a
         href="https://docs.microsoft.com/en-us/rest/api/storageservices/Setting-Timeouts-for-File-Service-Operations?redirectedfrom=MSDN">Setting
         Timeouts for File Service Operations.</a>`.
        :type timeout: int
        :param range: Specifies the range of bytes over which to list ranges, inclusively.
        :type range: str
        :param lease_access_conditions: Parameter group.
        :type lease_access_conditions: ~azure.storage.fileshare.models.LeaseAccessConditions
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: ShareFileRangeList, or the result of cls(response)
        :rtype: ~azure.storage.fileshare.models.ShareFileRangeList
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType["_models.ShareFileRangeList"]
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}))

        _lease_id = None
        if lease_access_conditions is not None:
            _lease_id = lease_access_conditions.lease_id

        request = build_get_range_list_request(
            share_name=share_name,
            directory=directory,
            file_name=file_name,
            sharesnapshot=sharesnapshot,
            prevsharesnapshot=prevsharesnapshot,
            timeout=timeout,
            range=range,
            lease_id=_lease_id,
            template_url=self.get_range_list.metadata['url'],
        )
        request = _convert_request(request)
        path_format_arguments = {
            "url": self._serialize.url("self._config.url", self._config.url, 'str', skip_quote=True),
        }
        request.url = self._client.format_url(request.url, **path_format_arguments)

        pipeline_response = self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize.failsafe_deserialize(_models.StorageError, pipeline_response)
            raise HttpResponseError(response=response, model=error)

        response_headers = {}
        response_headers['Last-Modified']=self._deserialize('rfc-1123', response.headers.get('Last-Modified'))
        response_headers['ETag']=self._deserialize('str', response.headers.get('ETag'))
        response_headers['x-ms-content-length']=self._deserialize('long', response.headers.get('x-ms-content-length'))
        response_headers['x-ms-request-id']=self._deserialize('str', response.headers.get('x-ms-request-id'))
        response_headers['x-ms-version']=self._deserialize('str', response.headers.get('x-ms-version'))
        response_headers['Date']=self._deserialize('rfc-1123', response.headers.get('Date'))

        deserialized = self._deserialize('ShareFileRangeList', pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, response_headers)

        return deserialized

    get_range_list.metadata = {'url': '/{shareName}/{directory}/{fileName}'}  # type: ignore


    @distributed_trace
    def start_copy(
        self,
        share_name,  # type: str
        directory,  # type: str
        file_name,  # type: str
        copy_source,  # type: str
        timeout=None,  # type: Optional[int]
        metadata=None,  # type: Optional[Dict[str, str]]
        file_permission="inherit",  # type: Optional[str]
        file_permission_key=None,  # type: Optional[str]
        copy_file_smb_info=None,  # type: Optional["_models.CopyFileSmbInfo"]
        lease_access_conditions=None,  # type: Optional["_models.LeaseAccessConditions"]
        **kwargs  # type: Any
    ):
        # type: (...) -> None
        """Copies a blob or file to a destination file within the storage account.

        :param share_name: The name of the target share.
        :type share_name: str
        :param directory: The path of the target directory.
        :type directory: str
        :param file_name: The path of the target file.
        :type file_name: str
        :param copy_source: Specifies the URL of the source file or blob, up to 2 KB in length. To copy
         a file to another file within the same storage account, you may use Shared Key to authenticate
         the source file. If you are copying a file from another storage account, or if you are copying
         a blob from the same storage account or another storage account, then you must authenticate the
         source file or blob using a shared access signature. If the source is a public blob, no
         authentication is required to perform the copy operation. A file in a share snapshot can also
         be specified as a copy source.
        :type copy_source: str
        :param timeout: The timeout parameter is expressed in seconds. For more information, see
         :code:`<a
         href="https://docs.microsoft.com/en-us/rest/api/storageservices/Setting-Timeouts-for-File-Service-Operations?redirectedfrom=MSDN">Setting
         Timeouts for File Service Operations.</a>`.
        :type timeout: int
        :param metadata: A name-value pair to associate with a file storage object.
        :type metadata: dict[str, str]
        :param file_permission: If specified the permission (security descriptor) shall be set for the
         directory/file. This header can be used if Permission size is <= 8KB, else
         x-ms-file-permission-key header shall be used. Default value: Inherit. If SDDL is specified as
         input, it must have owner, group and dacl. Note: Only one of the x-ms-file-permission or
         x-ms-file-permission-key should be specified.
        :type file_permission: str
        :param file_permission_key: Key of the permission to be set for the directory/file. Note: Only
         one of the x-ms-file-permission or x-ms-file-permission-key should be specified.
        :type file_permission_key: str
        :param copy_file_smb_info: Parameter group.
        :type copy_file_smb_info: ~azure.storage.fileshare.models.CopyFileSmbInfo
        :param lease_access_conditions: Parameter group.
        :type lease_access_conditions: ~azure.storage.fileshare.models.LeaseAccessConditions
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: None, or the result of cls(response)
        :rtype: None
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType[None]
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}))

        _file_permission_copy_mode = None
        _ignore_read_only = None
        _file_attributes = None
        _file_creation_time = None
        _file_last_write_time = None
        _set_archive_attribute = None
        _lease_id = None
        if copy_file_smb_info is not None:
            _file_permission_copy_mode = copy_file_smb_info.file_permission_copy_mode
            _ignore_read_only = copy_file_smb_info.ignore_read_only
            _file_attributes = copy_file_smb_info.file_attributes
            _file_creation_time = copy_file_smb_info.file_creation_time
            _file_last_write_time = copy_file_smb_info.file_last_write_time
            _set_archive_attribute = copy_file_smb_info.set_archive_attribute
        if lease_access_conditions is not None:
            _lease_id = lease_access_conditions.lease_id

        request = build_start_copy_request(
            share_name=share_name,
            directory=directory,
            file_name=file_name,
            copy_source=copy_source,
            timeout=timeout,
            metadata=metadata,
            file_permission=file_permission,
            file_permission_key=file_permission_key,
            file_permission_copy_mode=_file_permission_copy_mode,
            ignore_read_only=_ignore_read_only,
            file_attributes=_file_attributes,
            file_creation_time=_file_creation_time,
            file_last_write_time=_file_last_write_time,
            set_archive_attribute=_set_archive_attribute,
            lease_id=_lease_id,
            template_url=self.start_copy.metadata['url'],
        )
        request = _convert_request(request)
        path_format_arguments = {
            "url": self._serialize.url("self._config.url", self._config.url, 'str', skip_quote=True),
        }
        request.url = self._client.format_url(request.url, **path_format_arguments)

        pipeline_response = self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [202]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize.failsafe_deserialize(_models.StorageError, pipeline_response)
            raise HttpResponseError(response=response, model=error)

        response_headers = {}
        response_headers['ETag']=self._deserialize('str', response.headers.get('ETag'))
        response_headers['Last-Modified']=self._deserialize('rfc-1123', response.headers.get('Last-Modified'))
        response_headers['x-ms-request-id']=self._deserialize('str', response.headers.get('x-ms-request-id'))
        response_headers['x-ms-version']=self._deserialize('str', response.headers.get('x-ms-version'))
        response_headers['Date']=self._deserialize('rfc-1123', response.headers.get('Date'))
        response_headers['x-ms-copy-id']=self._deserialize('str', response.headers.get('x-ms-copy-id'))
        response_headers['x-ms-copy-status']=self._deserialize('str', response.headers.get('x-ms-copy-status'))


        if cls:
            return cls(pipeline_response, None, response_headers)

    start_copy.metadata = {'url': '/{shareName}/{directory}/{fileName}'}  # type: ignore


    @distributed_trace
    def abort_copy(
        self,
        share_name,  # type: str
        directory,  # type: str
        file_name,  # type: str
        copy_id,  # type: str
        timeout=None,  # type: Optional[int]
        lease_access_conditions=None,  # type: Optional["_models.LeaseAccessConditions"]
        **kwargs  # type: Any
    ):
        # type: (...) -> None
        """Aborts a pending Copy File operation, and leaves a destination file with zero length and full
        metadata.

        :param share_name: The name of the target share.
        :type share_name: str
        :param directory: The path of the target directory.
        :type directory: str
        :param file_name: The path of the target file.
        :type file_name: str
        :param copy_id: The copy identifier provided in the x-ms-copy-id header of the original Copy
         File operation.
        :type copy_id: str
        :param timeout: The timeout parameter is expressed in seconds. For more information, see
         :code:`<a
         href="https://docs.microsoft.com/en-us/rest/api/storageservices/Setting-Timeouts-for-File-Service-Operations?redirectedfrom=MSDN">Setting
         Timeouts for File Service Operations.</a>`.
        :type timeout: int
        :param lease_access_conditions: Parameter group.
        :type lease_access_conditions: ~azure.storage.fileshare.models.LeaseAccessConditions
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: None, or the result of cls(response)
        :rtype: None
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType[None]
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}))

        _lease_id = None
        if lease_access_conditions is not None:
            _lease_id = lease_access_conditions.lease_id

        request = build_abort_copy_request(
            share_name=share_name,
            directory=directory,
            file_name=file_name,
            copy_id=copy_id,
            timeout=timeout,
            lease_id=_lease_id,
            template_url=self.abort_copy.metadata['url'],
        )
        request = _convert_request(request)
        path_format_arguments = {
            "url": self._serialize.url("self._config.url", self._config.url, 'str', skip_quote=True),
        }
        request.url = self._client.format_url(request.url, **path_format_arguments)

        pipeline_response = self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [204]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize.failsafe_deserialize(_models.StorageError, pipeline_response)
            raise HttpResponseError(response=response, model=error)

        response_headers = {}
        response_headers['x-ms-request-id']=self._deserialize('str', response.headers.get('x-ms-request-id'))
        response_headers['x-ms-version']=self._deserialize('str', response.headers.get('x-ms-version'))
        response_headers['Date']=self._deserialize('rfc-1123', response.headers.get('Date'))


        if cls:
            return cls(pipeline_response, None, response_headers)

    abort_copy.metadata = {'url': '/{shareName}/{directory}/{fileName}'}  # type: ignore


    @distributed_trace
    def list_handles(
        self,
        share_name,  # type: str
        directory,  # type: str
        file_name,  # type: str
        marker=None,  # type: Optional[str]
        maxresults=None,  # type: Optional[int]
        timeout=None,  # type: Optional[int]
        sharesnapshot=None,  # type: Optional[str]
        **kwargs  # type: Any
    ):
        # type: (...) -> "_models.ListHandlesResponse"
        """Lists handles for file.

        :param share_name: The name of the target share.
        :type share_name: str
        :param directory: The path of the target directory.
        :type directory: str
        :param file_name: The path of the target file.
        :type file_name: str
        :param marker: A string value that identifies the portion of the list to be returned with the
         next list operation. The operation returns a marker value within the response body if the list
         returned was not complete. The marker value may then be used in a subsequent call to request
         the next set of list items. The marker value is opaque to the client.
        :type marker: str
        :param maxresults: Specifies the maximum number of entries to return. If the request does not
         specify maxresults, or specifies a value greater than 5,000, the server will return up to 5,000
         items.
        :type maxresults: int
        :param timeout: The timeout parameter is expressed in seconds. For more information, see
         :code:`<a
         href="https://docs.microsoft.com/en-us/rest/api/storageservices/Setting-Timeouts-for-File-Service-Operations?redirectedfrom=MSDN">Setting
         Timeouts for File Service Operations.</a>`.
        :type timeout: int
        :param sharesnapshot: The snapshot parameter is an opaque DateTime value that, when present,
         specifies the share snapshot to query.
        :type sharesnapshot: str
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: ListHandlesResponse, or the result of cls(response)
        :rtype: ~azure.storage.fileshare.models.ListHandlesResponse
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType["_models.ListHandlesResponse"]
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}))

        
        request = build_list_handles_request(
            share_name=share_name,
            directory=directory,
            file_name=file_name,
            marker=marker,
            maxresults=maxresults,
            timeout=timeout,
            sharesnapshot=sharesnapshot,
            template_url=self.list_handles.metadata['url'],
        )
        request = _convert_request(request)
        path_format_arguments = {
            "url": self._serialize.url("self._config.url", self._config.url, 'str', skip_quote=True),
        }
        request.url = self._client.format_url(request.url, **path_format_arguments)

        pipeline_response = self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize.failsafe_deserialize(_models.StorageError, pipeline_response)
            raise HttpResponseError(response=response, model=error)

        response_headers = {}
        response_headers['Content-Type']=self._deserialize('str', response.headers.get('Content-Type'))
        response_headers['x-ms-request-id']=self._deserialize('str', response.headers.get('x-ms-request-id'))
        response_headers['x-ms-version']=self._deserialize('str', response.headers.get('x-ms-version'))
        response_headers['Date']=self._deserialize('rfc-1123', response.headers.get('Date'))

        deserialized = self._deserialize('ListHandlesResponse', pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, response_headers)

        return deserialized

    list_handles.metadata = {'url': '/{shareName}/{directory}/{fileName}'}  # type: ignore


    @distributed_trace
    def force_close_handles(
        self,
        share_name,  # type: str
        directory,  # type: str
        file_name,  # type: str
        handle_id,  # type: str
        timeout=None,  # type: Optional[int]
        marker=None,  # type: Optional[str]
        sharesnapshot=None,  # type: Optional[str]
        **kwargs  # type: Any
    ):
        # type: (...) -> None
        """Closes all handles open for given file.

        :param share_name: The name of the target share.
        :type share_name: str
        :param directory: The path of the target directory.
        :type directory: str
        :param file_name: The path of the target file.
        :type file_name: str
        :param handle_id: Specifies handle ID opened on the file or directory to be closed. Asterisk
         (‘*’) is a wildcard that specifies all handles.
        :type handle_id: str
        :param timeout: The timeout parameter is expressed in seconds. For more information, see
         :code:`<a
         href="https://docs.microsoft.com/en-us/rest/api/storageservices/Setting-Timeouts-for-File-Service-Operations?redirectedfrom=MSDN">Setting
         Timeouts for File Service Operations.</a>`.
        :type timeout: int
        :param marker: A string value that identifies the portion of the list to be returned with the
         next list operation. The operation returns a marker value within the response body if the list
         returned was not complete. The marker value may then be used in a subsequent call to request
         the next set of list items. The marker value is opaque to the client.
        :type marker: str
        :param sharesnapshot: The snapshot parameter is an opaque DateTime value that, when present,
         specifies the share snapshot to query.
        :type sharesnapshot: str
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: None, or the result of cls(response)
        :rtype: None
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType[None]
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}))

        
        request = build_force_close_handles_request(
            share_name=share_name,
            directory=directory,
            file_name=file_name,
            handle_id=handle_id,
            timeout=timeout,
            marker=marker,
            sharesnapshot=sharesnapshot,
            template_url=self.force_close_handles.metadata['url'],
        )
        request = _convert_request(request)
        path_format_arguments = {
            "url": self._serialize.url("self._config.url", self._config.url, 'str', skip_quote=True),
        }
        request.url = self._client.format_url(request.url, **path_format_arguments)

        pipeline_response = self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize.failsafe_deserialize(_models.StorageError, pipeline_response)
            raise HttpResponseError(response=response, model=error)

        response_headers = {}
        response_headers['x-ms-request-id']=self._deserialize('str', response.headers.get('x-ms-request-id'))
        response_headers['x-ms-version']=self._deserialize('str', response.headers.get('x-ms-version'))
        response_headers['Date']=self._deserialize('rfc-1123', response.headers.get('Date'))
        response_headers['x-ms-marker']=self._deserialize('str', response.headers.get('x-ms-marker'))
        response_headers['x-ms-number-of-handles-closed']=self._deserialize('int', response.headers.get('x-ms-number-of-handles-closed'))
        response_headers['x-ms-number-of-handles-failed']=self._deserialize('int', response.headers.get('x-ms-number-of-handles-failed'))


        if cls:
            return cls(pipeline_response, None, response_headers)

    force_close_handles.metadata = {'url': '/{shareName}/{directory}/{fileName}'}  # type: ignore

