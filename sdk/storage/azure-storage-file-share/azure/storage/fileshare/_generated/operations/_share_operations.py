# coding=utf-8
# --------------------------------------------------------------------------
# Copyright (c) Microsoft Corporation. All rights reserved.
# Licensed under the MIT License. See License.txt in the project root for license information.
# Code generated by Microsoft (R) AutoRest Code Generator.
# Changes may cause incorrect behavior and will be lost if the code is regenerated.
# --------------------------------------------------------------------------
import functools
from typing import TYPE_CHECKING
import warnings

from azure.core.exceptions import ClientAuthenticationError, HttpResponseError, ResourceExistsError, ResourceNotFoundError, map_error
from azure.core.pipeline import PipelineResponse
from azure.core.pipeline.transport import HttpResponse
from azure.core.rest import HttpRequest
from azure.core.tracing.decorator import distributed_trace
from msrest import Serializer

from .. import models as _models
from .._vendor import _convert_request, _format_url_section

if TYPE_CHECKING:
    # pylint: disable=unused-import,ungrouped-imports
    from typing import Any, Callable, Dict, Generic, List, Optional, TypeVar, Union

    T = TypeVar('T')
    ClsType = Optional[Callable[[PipelineResponse[HttpRequest, HttpResponse], T, Dict[str, Any]], Any]]

_SERIALIZER = Serializer()
# fmt: off

def build_create_request(
    share_name,  # type: str
    **kwargs  # type: Any
):
    # type: (...) -> HttpRequest
    timeout = kwargs.pop('timeout', None)  # type: Optional[int]
    metadata = kwargs.pop('metadata', None)  # type: Optional[Dict[str, str]]
    quota = kwargs.pop('quota', None)  # type: Optional[int]
    access_tier = kwargs.pop('access_tier', None)  # type: Optional[Union[str, "_models.ShareAccessTier"]]
    enabled_protocols = kwargs.pop('enabled_protocols', None)  # type: Optional[str]
    root_squash = kwargs.pop('root_squash', None)  # type: Optional[Union[str, "_models.ShareRootSquash"]]

    restype = "share"
    version = "2020-10-02"
    accept = "application/xml"
    # Construct URL
    url = kwargs.pop("template_url", '/{shareName}')
    path_format_arguments = {
        "shareName": _SERIALIZER.url("share_name", share_name, 'str'),
    }

    url = _format_url_section(url, **path_format_arguments)

    # Construct parameters
    query_parameters = kwargs.pop("params", {})  # type: Dict[str, Any]
    query_parameters['restype'] = _SERIALIZER.query("restype", restype, 'str')
    if timeout is not None:
        query_parameters['timeout'] = _SERIALIZER.query("timeout", timeout, 'int', minimum=0)

    # Construct headers
    header_parameters = kwargs.pop("headers", {})  # type: Dict[str, Any]
    if metadata is not None:
        header_parameters['x-ms-meta'] = _SERIALIZER.header("metadata", metadata, '{str}')
    if quota is not None:
        header_parameters['x-ms-share-quota'] = _SERIALIZER.header("quota", quota, 'int', minimum=1)
    if access_tier is not None:
        header_parameters['x-ms-access-tier'] = _SERIALIZER.header("access_tier", access_tier, 'str')
    header_parameters['x-ms-version'] = _SERIALIZER.header("version", version, 'str')
    if enabled_protocols is not None:
        header_parameters['x-ms-enabled-protocols'] = _SERIALIZER.header("enabled_protocols", enabled_protocols, 'str')
    if root_squash is not None:
        header_parameters['x-ms-root-squash'] = _SERIALIZER.header("root_squash", root_squash, 'str')
    header_parameters['Accept'] = _SERIALIZER.header("accept", accept, 'str')

    return HttpRequest(
        method="PUT",
        url=url,
        params=query_parameters,
        headers=header_parameters,
        **kwargs
    )


def build_get_properties_request(
    share_name,  # type: str
    **kwargs  # type: Any
):
    # type: (...) -> HttpRequest
    sharesnapshot = kwargs.pop('sharesnapshot', None)  # type: Optional[str]
    timeout = kwargs.pop('timeout', None)  # type: Optional[int]
    lease_id = kwargs.pop('lease_id', None)  # type: Optional[str]

    restype = "share"
    version = "2020-10-02"
    accept = "application/xml"
    # Construct URL
    url = kwargs.pop("template_url", '/{shareName}')
    path_format_arguments = {
        "shareName": _SERIALIZER.url("share_name", share_name, 'str'),
    }

    url = _format_url_section(url, **path_format_arguments)

    # Construct parameters
    query_parameters = kwargs.pop("params", {})  # type: Dict[str, Any]
    query_parameters['restype'] = _SERIALIZER.query("restype", restype, 'str')
    if sharesnapshot is not None:
        query_parameters['sharesnapshot'] = _SERIALIZER.query("sharesnapshot", sharesnapshot, 'str')
    if timeout is not None:
        query_parameters['timeout'] = _SERIALIZER.query("timeout", timeout, 'int', minimum=0)

    # Construct headers
    header_parameters = kwargs.pop("headers", {})  # type: Dict[str, Any]
    header_parameters['x-ms-version'] = _SERIALIZER.header("version", version, 'str')
    if lease_id is not None:
        header_parameters['x-ms-lease-id'] = _SERIALIZER.header("lease_id", lease_id, 'str')
    header_parameters['Accept'] = _SERIALIZER.header("accept", accept, 'str')

    return HttpRequest(
        method="GET",
        url=url,
        params=query_parameters,
        headers=header_parameters,
        **kwargs
    )


def build_delete_request(
    share_name,  # type: str
    **kwargs  # type: Any
):
    # type: (...) -> HttpRequest
    sharesnapshot = kwargs.pop('sharesnapshot', None)  # type: Optional[str]
    timeout = kwargs.pop('timeout', None)  # type: Optional[int]
    delete_snapshots = kwargs.pop('delete_snapshots', None)  # type: Optional[Union[str, "_models.DeleteSnapshotsOptionType"]]
    lease_id = kwargs.pop('lease_id', None)  # type: Optional[str]

    restype = "share"
    version = "2020-10-02"
    accept = "application/xml"
    # Construct URL
    url = kwargs.pop("template_url", '/{shareName}')
    path_format_arguments = {
        "shareName": _SERIALIZER.url("share_name", share_name, 'str'),
    }

    url = _format_url_section(url, **path_format_arguments)

    # Construct parameters
    query_parameters = kwargs.pop("params", {})  # type: Dict[str, Any]
    query_parameters['restype'] = _SERIALIZER.query("restype", restype, 'str')
    if sharesnapshot is not None:
        query_parameters['sharesnapshot'] = _SERIALIZER.query("sharesnapshot", sharesnapshot, 'str')
    if timeout is not None:
        query_parameters['timeout'] = _SERIALIZER.query("timeout", timeout, 'int', minimum=0)

    # Construct headers
    header_parameters = kwargs.pop("headers", {})  # type: Dict[str, Any]
    header_parameters['x-ms-version'] = _SERIALIZER.header("version", version, 'str')
    if delete_snapshots is not None:
        header_parameters['x-ms-delete-snapshots'] = _SERIALIZER.header("delete_snapshots", delete_snapshots, 'str')
    if lease_id is not None:
        header_parameters['x-ms-lease-id'] = _SERIALIZER.header("lease_id", lease_id, 'str')
    header_parameters['Accept'] = _SERIALIZER.header("accept", accept, 'str')

    return HttpRequest(
        method="DELETE",
        url=url,
        params=query_parameters,
        headers=header_parameters,
        **kwargs
    )


def build_acquire_lease_request(
    share_name,  # type: str
    **kwargs  # type: Any
):
    # type: (...) -> HttpRequest
    timeout = kwargs.pop('timeout', None)  # type: Optional[int]
    duration = kwargs.pop('duration', None)  # type: Optional[int]
    proposed_lease_id = kwargs.pop('proposed_lease_id', None)  # type: Optional[str]
    sharesnapshot = kwargs.pop('sharesnapshot', None)  # type: Optional[str]
    request_id_parameter = kwargs.pop('request_id_parameter', None)  # type: Optional[str]

    comp = "lease"
    action = "acquire"
    restype = "share"
    version = "2020-10-02"
    accept = "application/xml"
    # Construct URL
    url = kwargs.pop("template_url", '/{shareName}')
    path_format_arguments = {
        "shareName": _SERIALIZER.url("share_name", share_name, 'str'),
    }

    url = _format_url_section(url, **path_format_arguments)

    # Construct parameters
    query_parameters = kwargs.pop("params", {})  # type: Dict[str, Any]
    query_parameters['comp'] = _SERIALIZER.query("comp", comp, 'str')
    query_parameters['restype'] = _SERIALIZER.query("restype", restype, 'str')
    if timeout is not None:
        query_parameters['timeout'] = _SERIALIZER.query("timeout", timeout, 'int', minimum=0)
    if sharesnapshot is not None:
        query_parameters['sharesnapshot'] = _SERIALIZER.query("sharesnapshot", sharesnapshot, 'str')

    # Construct headers
    header_parameters = kwargs.pop("headers", {})  # type: Dict[str, Any]
    header_parameters['x-ms-lease-action'] = _SERIALIZER.header("action", action, 'str')
    if duration is not None:
        header_parameters['x-ms-lease-duration'] = _SERIALIZER.header("duration", duration, 'int')
    if proposed_lease_id is not None:
        header_parameters['x-ms-proposed-lease-id'] = _SERIALIZER.header("proposed_lease_id", proposed_lease_id, 'str')
    header_parameters['x-ms-version'] = _SERIALIZER.header("version", version, 'str')
    if request_id_parameter is not None:
        header_parameters['x-ms-client-request-id'] = _SERIALIZER.header("request_id_parameter", request_id_parameter, 'str')
    header_parameters['Accept'] = _SERIALIZER.header("accept", accept, 'str')

    return HttpRequest(
        method="PUT",
        url=url,
        params=query_parameters,
        headers=header_parameters,
        **kwargs
    )


def build_release_lease_request(
    share_name,  # type: str
    **kwargs  # type: Any
):
    # type: (...) -> HttpRequest
    lease_id = kwargs.pop('lease_id')  # type: str
    timeout = kwargs.pop('timeout', None)  # type: Optional[int]
    sharesnapshot = kwargs.pop('sharesnapshot', None)  # type: Optional[str]
    request_id_parameter = kwargs.pop('request_id_parameter', None)  # type: Optional[str]

    comp = "lease"
    action = "release"
    restype = "share"
    version = "2020-10-02"
    accept = "application/xml"
    # Construct URL
    url = kwargs.pop("template_url", '/{shareName}')
    path_format_arguments = {
        "shareName": _SERIALIZER.url("share_name", share_name, 'str'),
    }

    url = _format_url_section(url, **path_format_arguments)

    # Construct parameters
    query_parameters = kwargs.pop("params", {})  # type: Dict[str, Any]
    query_parameters['comp'] = _SERIALIZER.query("comp", comp, 'str')
    query_parameters['restype'] = _SERIALIZER.query("restype", restype, 'str')
    if timeout is not None:
        query_parameters['timeout'] = _SERIALIZER.query("timeout", timeout, 'int', minimum=0)
    if sharesnapshot is not None:
        query_parameters['sharesnapshot'] = _SERIALIZER.query("sharesnapshot", sharesnapshot, 'str')

    # Construct headers
    header_parameters = kwargs.pop("headers", {})  # type: Dict[str, Any]
    header_parameters['x-ms-lease-action'] = _SERIALIZER.header("action", action, 'str')
    header_parameters['x-ms-lease-id'] = _SERIALIZER.header("lease_id", lease_id, 'str')
    header_parameters['x-ms-version'] = _SERIALIZER.header("version", version, 'str')
    if request_id_parameter is not None:
        header_parameters['x-ms-client-request-id'] = _SERIALIZER.header("request_id_parameter", request_id_parameter, 'str')
    header_parameters['Accept'] = _SERIALIZER.header("accept", accept, 'str')

    return HttpRequest(
        method="PUT",
        url=url,
        params=query_parameters,
        headers=header_parameters,
        **kwargs
    )


def build_change_lease_request(
    share_name,  # type: str
    **kwargs  # type: Any
):
    # type: (...) -> HttpRequest
    lease_id = kwargs.pop('lease_id')  # type: str
    timeout = kwargs.pop('timeout', None)  # type: Optional[int]
    proposed_lease_id = kwargs.pop('proposed_lease_id', None)  # type: Optional[str]
    sharesnapshot = kwargs.pop('sharesnapshot', None)  # type: Optional[str]
    request_id_parameter = kwargs.pop('request_id_parameter', None)  # type: Optional[str]

    comp = "lease"
    action = "change"
    restype = "share"
    version = "2020-10-02"
    accept = "application/xml"
    # Construct URL
    url = kwargs.pop("template_url", '/{shareName}')
    path_format_arguments = {
        "shareName": _SERIALIZER.url("share_name", share_name, 'str'),
    }

    url = _format_url_section(url, **path_format_arguments)

    # Construct parameters
    query_parameters = kwargs.pop("params", {})  # type: Dict[str, Any]
    query_parameters['comp'] = _SERIALIZER.query("comp", comp, 'str')
    query_parameters['restype'] = _SERIALIZER.query("restype", restype, 'str')
    if timeout is not None:
        query_parameters['timeout'] = _SERIALIZER.query("timeout", timeout, 'int', minimum=0)
    if sharesnapshot is not None:
        query_parameters['sharesnapshot'] = _SERIALIZER.query("sharesnapshot", sharesnapshot, 'str')

    # Construct headers
    header_parameters = kwargs.pop("headers", {})  # type: Dict[str, Any]
    header_parameters['x-ms-lease-action'] = _SERIALIZER.header("action", action, 'str')
    header_parameters['x-ms-lease-id'] = _SERIALIZER.header("lease_id", lease_id, 'str')
    if proposed_lease_id is not None:
        header_parameters['x-ms-proposed-lease-id'] = _SERIALIZER.header("proposed_lease_id", proposed_lease_id, 'str')
    header_parameters['x-ms-version'] = _SERIALIZER.header("version", version, 'str')
    if request_id_parameter is not None:
        header_parameters['x-ms-client-request-id'] = _SERIALIZER.header("request_id_parameter", request_id_parameter, 'str')
    header_parameters['Accept'] = _SERIALIZER.header("accept", accept, 'str')

    return HttpRequest(
        method="PUT",
        url=url,
        params=query_parameters,
        headers=header_parameters,
        **kwargs
    )


def build_renew_lease_request(
    share_name,  # type: str
    **kwargs  # type: Any
):
    # type: (...) -> HttpRequest
    lease_id = kwargs.pop('lease_id')  # type: str
    timeout = kwargs.pop('timeout', None)  # type: Optional[int]
    sharesnapshot = kwargs.pop('sharesnapshot', None)  # type: Optional[str]
    request_id_parameter = kwargs.pop('request_id_parameter', None)  # type: Optional[str]

    comp = "lease"
    action = "renew"
    restype = "share"
    version = "2020-10-02"
    accept = "application/xml"
    # Construct URL
    url = kwargs.pop("template_url", '/{shareName}')
    path_format_arguments = {
        "shareName": _SERIALIZER.url("share_name", share_name, 'str'),
    }

    url = _format_url_section(url, **path_format_arguments)

    # Construct parameters
    query_parameters = kwargs.pop("params", {})  # type: Dict[str, Any]
    query_parameters['comp'] = _SERIALIZER.query("comp", comp, 'str')
    query_parameters['restype'] = _SERIALIZER.query("restype", restype, 'str')
    if timeout is not None:
        query_parameters['timeout'] = _SERIALIZER.query("timeout", timeout, 'int', minimum=0)
    if sharesnapshot is not None:
        query_parameters['sharesnapshot'] = _SERIALIZER.query("sharesnapshot", sharesnapshot, 'str')

    # Construct headers
    header_parameters = kwargs.pop("headers", {})  # type: Dict[str, Any]
    header_parameters['x-ms-lease-action'] = _SERIALIZER.header("action", action, 'str')
    header_parameters['x-ms-lease-id'] = _SERIALIZER.header("lease_id", lease_id, 'str')
    header_parameters['x-ms-version'] = _SERIALIZER.header("version", version, 'str')
    if request_id_parameter is not None:
        header_parameters['x-ms-client-request-id'] = _SERIALIZER.header("request_id_parameter", request_id_parameter, 'str')
    header_parameters['Accept'] = _SERIALIZER.header("accept", accept, 'str')

    return HttpRequest(
        method="PUT",
        url=url,
        params=query_parameters,
        headers=header_parameters,
        **kwargs
    )


def build_break_lease_request(
    share_name,  # type: str
    **kwargs  # type: Any
):
    # type: (...) -> HttpRequest
    timeout = kwargs.pop('timeout', None)  # type: Optional[int]
    break_period = kwargs.pop('break_period', None)  # type: Optional[int]
    lease_id = kwargs.pop('lease_id', None)  # type: Optional[str]
    request_id_parameter = kwargs.pop('request_id_parameter', None)  # type: Optional[str]
    sharesnapshot = kwargs.pop('sharesnapshot', None)  # type: Optional[str]

    comp = "lease"
    action = "break"
    restype = "share"
    version = "2020-10-02"
    accept = "application/xml"
    # Construct URL
    url = kwargs.pop("template_url", '/{shareName}')
    path_format_arguments = {
        "shareName": _SERIALIZER.url("share_name", share_name, 'str'),
    }

    url = _format_url_section(url, **path_format_arguments)

    # Construct parameters
    query_parameters = kwargs.pop("params", {})  # type: Dict[str, Any]
    query_parameters['comp'] = _SERIALIZER.query("comp", comp, 'str')
    query_parameters['restype'] = _SERIALIZER.query("restype", restype, 'str')
    if timeout is not None:
        query_parameters['timeout'] = _SERIALIZER.query("timeout", timeout, 'int', minimum=0)
    if sharesnapshot is not None:
        query_parameters['sharesnapshot'] = _SERIALIZER.query("sharesnapshot", sharesnapshot, 'str')

    # Construct headers
    header_parameters = kwargs.pop("headers", {})  # type: Dict[str, Any]
    header_parameters['x-ms-lease-action'] = _SERIALIZER.header("action", action, 'str')
    if break_period is not None:
        header_parameters['x-ms-lease-break-period'] = _SERIALIZER.header("break_period", break_period, 'int')
    if lease_id is not None:
        header_parameters['x-ms-lease-id'] = _SERIALIZER.header("lease_id", lease_id, 'str')
    header_parameters['x-ms-version'] = _SERIALIZER.header("version", version, 'str')
    if request_id_parameter is not None:
        header_parameters['x-ms-client-request-id'] = _SERIALIZER.header("request_id_parameter", request_id_parameter, 'str')
    header_parameters['Accept'] = _SERIALIZER.header("accept", accept, 'str')

    return HttpRequest(
        method="PUT",
        url=url,
        params=query_parameters,
        headers=header_parameters,
        **kwargs
    )


def build_create_snapshot_request(
    share_name,  # type: str
    **kwargs  # type: Any
):
    # type: (...) -> HttpRequest
    timeout = kwargs.pop('timeout', None)  # type: Optional[int]
    metadata = kwargs.pop('metadata', None)  # type: Optional[Dict[str, str]]

    restype = "share"
    comp = "snapshot"
    version = "2020-10-02"
    accept = "application/xml"
    # Construct URL
    url = kwargs.pop("template_url", '/{shareName}')
    path_format_arguments = {
        "shareName": _SERIALIZER.url("share_name", share_name, 'str'),
    }

    url = _format_url_section(url, **path_format_arguments)

    # Construct parameters
    query_parameters = kwargs.pop("params", {})  # type: Dict[str, Any]
    query_parameters['restype'] = _SERIALIZER.query("restype", restype, 'str')
    query_parameters['comp'] = _SERIALIZER.query("comp", comp, 'str')
    if timeout is not None:
        query_parameters['timeout'] = _SERIALIZER.query("timeout", timeout, 'int', minimum=0)

    # Construct headers
    header_parameters = kwargs.pop("headers", {})  # type: Dict[str, Any]
    if metadata is not None:
        header_parameters['x-ms-meta'] = _SERIALIZER.header("metadata", metadata, '{str}')
    header_parameters['x-ms-version'] = _SERIALIZER.header("version", version, 'str')
    header_parameters['Accept'] = _SERIALIZER.header("accept", accept, 'str')

    return HttpRequest(
        method="PUT",
        url=url,
        params=query_parameters,
        headers=header_parameters,
        **kwargs
    )


def build_create_permission_request(
    share_name,  # type: str
    **kwargs  # type: Any
):
    # type: (...) -> HttpRequest
    content_type = kwargs.pop('content_type', None)  # type: Optional[str]
    timeout = kwargs.pop('timeout', None)  # type: Optional[int]

    restype = "share"
    comp = "filepermission"
    version = "2020-10-02"
    accept = "application/xml"
    # Construct URL
    url = kwargs.pop("template_url", '/{shareName}')
    path_format_arguments = {
        "shareName": _SERIALIZER.url("share_name", share_name, 'str'),
    }

    url = _format_url_section(url, **path_format_arguments)

    # Construct parameters
    query_parameters = kwargs.pop("params", {})  # type: Dict[str, Any]
    query_parameters['restype'] = _SERIALIZER.query("restype", restype, 'str')
    query_parameters['comp'] = _SERIALIZER.query("comp", comp, 'str')
    if timeout is not None:
        query_parameters['timeout'] = _SERIALIZER.query("timeout", timeout, 'int', minimum=0)

    # Construct headers
    header_parameters = kwargs.pop("headers", {})  # type: Dict[str, Any]
    header_parameters['x-ms-version'] = _SERIALIZER.header("version", version, 'str')
    if content_type is not None:
        header_parameters['Content-Type'] = _SERIALIZER.header("content_type", content_type, 'str')
    header_parameters['Accept'] = _SERIALIZER.header("accept", accept, 'str')

    return HttpRequest(
        method="PUT",
        url=url,
        params=query_parameters,
        headers=header_parameters,
        **kwargs
    )


def build_get_permission_request(
    share_name,  # type: str
    **kwargs  # type: Any
):
    # type: (...) -> HttpRequest
    file_permission_key = kwargs.pop('file_permission_key')  # type: str
    timeout = kwargs.pop('timeout', None)  # type: Optional[int]

    restype = "share"
    comp = "filepermission"
    version = "2020-10-02"
    accept = "application/json"
    # Construct URL
    url = kwargs.pop("template_url", '/{shareName}')
    path_format_arguments = {
        "shareName": _SERIALIZER.url("share_name", share_name, 'str'),
    }

    url = _format_url_section(url, **path_format_arguments)

    # Construct parameters
    query_parameters = kwargs.pop("params", {})  # type: Dict[str, Any]
    query_parameters['restype'] = _SERIALIZER.query("restype", restype, 'str')
    query_parameters['comp'] = _SERIALIZER.query("comp", comp, 'str')
    if timeout is not None:
        query_parameters['timeout'] = _SERIALIZER.query("timeout", timeout, 'int', minimum=0)

    # Construct headers
    header_parameters = kwargs.pop("headers", {})  # type: Dict[str, Any]
    header_parameters['x-ms-file-permission-key'] = _SERIALIZER.header("file_permission_key", file_permission_key, 'str')
    header_parameters['x-ms-version'] = _SERIALIZER.header("version", version, 'str')
    header_parameters['Accept'] = _SERIALIZER.header("accept", accept, 'str')

    return HttpRequest(
        method="GET",
        url=url,
        params=query_parameters,
        headers=header_parameters,
        **kwargs
    )


def build_set_properties_request(
    share_name,  # type: str
    **kwargs  # type: Any
):
    # type: (...) -> HttpRequest
    timeout = kwargs.pop('timeout', None)  # type: Optional[int]
    quota = kwargs.pop('quota', None)  # type: Optional[int]
    access_tier = kwargs.pop('access_tier', None)  # type: Optional[Union[str, "_models.ShareAccessTier"]]
    lease_id = kwargs.pop('lease_id', None)  # type: Optional[str]
    root_squash = kwargs.pop('root_squash', None)  # type: Optional[Union[str, "_models.ShareRootSquash"]]

    restype = "share"
    comp = "properties"
    version = "2020-10-02"
    accept = "application/xml"
    # Construct URL
    url = kwargs.pop("template_url", '/{shareName}')
    path_format_arguments = {
        "shareName": _SERIALIZER.url("share_name", share_name, 'str'),
    }

    url = _format_url_section(url, **path_format_arguments)

    # Construct parameters
    query_parameters = kwargs.pop("params", {})  # type: Dict[str, Any]
    query_parameters['restype'] = _SERIALIZER.query("restype", restype, 'str')
    query_parameters['comp'] = _SERIALIZER.query("comp", comp, 'str')
    if timeout is not None:
        query_parameters['timeout'] = _SERIALIZER.query("timeout", timeout, 'int', minimum=0)

    # Construct headers
    header_parameters = kwargs.pop("headers", {})  # type: Dict[str, Any]
    header_parameters['x-ms-version'] = _SERIALIZER.header("version", version, 'str')
    if quota is not None:
        header_parameters['x-ms-share-quota'] = _SERIALIZER.header("quota", quota, 'int', minimum=1)
    if access_tier is not None:
        header_parameters['x-ms-access-tier'] = _SERIALIZER.header("access_tier", access_tier, 'str')
    if lease_id is not None:
        header_parameters['x-ms-lease-id'] = _SERIALIZER.header("lease_id", lease_id, 'str')
    if root_squash is not None:
        header_parameters['x-ms-root-squash'] = _SERIALIZER.header("root_squash", root_squash, 'str')
    header_parameters['Accept'] = _SERIALIZER.header("accept", accept, 'str')

    return HttpRequest(
        method="PUT",
        url=url,
        params=query_parameters,
        headers=header_parameters,
        **kwargs
    )


def build_set_metadata_request(
    share_name,  # type: str
    **kwargs  # type: Any
):
    # type: (...) -> HttpRequest
    timeout = kwargs.pop('timeout', None)  # type: Optional[int]
    metadata = kwargs.pop('metadata', None)  # type: Optional[Dict[str, str]]
    lease_id = kwargs.pop('lease_id', None)  # type: Optional[str]

    restype = "share"
    comp = "metadata"
    version = "2020-10-02"
    accept = "application/xml"
    # Construct URL
    url = kwargs.pop("template_url", '/{shareName}')
    path_format_arguments = {
        "shareName": _SERIALIZER.url("share_name", share_name, 'str'),
    }

    url = _format_url_section(url, **path_format_arguments)

    # Construct parameters
    query_parameters = kwargs.pop("params", {})  # type: Dict[str, Any]
    query_parameters['restype'] = _SERIALIZER.query("restype", restype, 'str')
    query_parameters['comp'] = _SERIALIZER.query("comp", comp, 'str')
    if timeout is not None:
        query_parameters['timeout'] = _SERIALIZER.query("timeout", timeout, 'int', minimum=0)

    # Construct headers
    header_parameters = kwargs.pop("headers", {})  # type: Dict[str, Any]
    if metadata is not None:
        header_parameters['x-ms-meta'] = _SERIALIZER.header("metadata", metadata, '{str}')
    header_parameters['x-ms-version'] = _SERIALIZER.header("version", version, 'str')
    if lease_id is not None:
        header_parameters['x-ms-lease-id'] = _SERIALIZER.header("lease_id", lease_id, 'str')
    header_parameters['Accept'] = _SERIALIZER.header("accept", accept, 'str')

    return HttpRequest(
        method="PUT",
        url=url,
        params=query_parameters,
        headers=header_parameters,
        **kwargs
    )


def build_get_access_policy_request(
    share_name,  # type: str
    **kwargs  # type: Any
):
    # type: (...) -> HttpRequest
    timeout = kwargs.pop('timeout', None)  # type: Optional[int]
    lease_id = kwargs.pop('lease_id', None)  # type: Optional[str]

    restype = "share"
    comp = "acl"
    version = "2020-10-02"
    accept = "application/xml"
    # Construct URL
    url = kwargs.pop("template_url", '/{shareName}')
    path_format_arguments = {
        "shareName": _SERIALIZER.url("share_name", share_name, 'str'),
    }

    url = _format_url_section(url, **path_format_arguments)

    # Construct parameters
    query_parameters = kwargs.pop("params", {})  # type: Dict[str, Any]
    query_parameters['restype'] = _SERIALIZER.query("restype", restype, 'str')
    query_parameters['comp'] = _SERIALIZER.query("comp", comp, 'str')
    if timeout is not None:
        query_parameters['timeout'] = _SERIALIZER.query("timeout", timeout, 'int', minimum=0)

    # Construct headers
    header_parameters = kwargs.pop("headers", {})  # type: Dict[str, Any]
    header_parameters['x-ms-version'] = _SERIALIZER.header("version", version, 'str')
    if lease_id is not None:
        header_parameters['x-ms-lease-id'] = _SERIALIZER.header("lease_id", lease_id, 'str')
    header_parameters['Accept'] = _SERIALIZER.header("accept", accept, 'str')

    return HttpRequest(
        method="GET",
        url=url,
        params=query_parameters,
        headers=header_parameters,
        **kwargs
    )


def build_set_access_policy_request(
    share_name,  # type: str
    **kwargs  # type: Any
):
    # type: (...) -> HttpRequest
    content_type = kwargs.pop('content_type', None)  # type: Optional[str]
    timeout = kwargs.pop('timeout', None)  # type: Optional[int]
    lease_id = kwargs.pop('lease_id', None)  # type: Optional[str]

    restype = "share"
    comp = "acl"
    version = "2020-10-02"
    accept = "application/xml"
    # Construct URL
    url = kwargs.pop("template_url", '/{shareName}')
    path_format_arguments = {
        "shareName": _SERIALIZER.url("share_name", share_name, 'str'),
    }

    url = _format_url_section(url, **path_format_arguments)

    # Construct parameters
    query_parameters = kwargs.pop("params", {})  # type: Dict[str, Any]
    query_parameters['restype'] = _SERIALIZER.query("restype", restype, 'str')
    query_parameters['comp'] = _SERIALIZER.query("comp", comp, 'str')
    if timeout is not None:
        query_parameters['timeout'] = _SERIALIZER.query("timeout", timeout, 'int', minimum=0)

    # Construct headers
    header_parameters = kwargs.pop("headers", {})  # type: Dict[str, Any]
    header_parameters['x-ms-version'] = _SERIALIZER.header("version", version, 'str')
    if lease_id is not None:
        header_parameters['x-ms-lease-id'] = _SERIALIZER.header("lease_id", lease_id, 'str')
    if content_type is not None:
        header_parameters['Content-Type'] = _SERIALIZER.header("content_type", content_type, 'str')
    header_parameters['Accept'] = _SERIALIZER.header("accept", accept, 'str')

    return HttpRequest(
        method="PUT",
        url=url,
        params=query_parameters,
        headers=header_parameters,
        **kwargs
    )


def build_get_statistics_request(
    share_name,  # type: str
    **kwargs  # type: Any
):
    # type: (...) -> HttpRequest
    timeout = kwargs.pop('timeout', None)  # type: Optional[int]
    lease_id = kwargs.pop('lease_id', None)  # type: Optional[str]

    restype = "share"
    comp = "stats"
    version = "2020-10-02"
    accept = "application/xml"
    # Construct URL
    url = kwargs.pop("template_url", '/{shareName}')
    path_format_arguments = {
        "shareName": _SERIALIZER.url("share_name", share_name, 'str'),
    }

    url = _format_url_section(url, **path_format_arguments)

    # Construct parameters
    query_parameters = kwargs.pop("params", {})  # type: Dict[str, Any]
    query_parameters['restype'] = _SERIALIZER.query("restype", restype, 'str')
    query_parameters['comp'] = _SERIALIZER.query("comp", comp, 'str')
    if timeout is not None:
        query_parameters['timeout'] = _SERIALIZER.query("timeout", timeout, 'int', minimum=0)

    # Construct headers
    header_parameters = kwargs.pop("headers", {})  # type: Dict[str, Any]
    header_parameters['x-ms-version'] = _SERIALIZER.header("version", version, 'str')
    if lease_id is not None:
        header_parameters['x-ms-lease-id'] = _SERIALIZER.header("lease_id", lease_id, 'str')
    header_parameters['Accept'] = _SERIALIZER.header("accept", accept, 'str')

    return HttpRequest(
        method="GET",
        url=url,
        params=query_parameters,
        headers=header_parameters,
        **kwargs
    )


def build_restore_request(
    share_name,  # type: str
    **kwargs  # type: Any
):
    # type: (...) -> HttpRequest
    timeout = kwargs.pop('timeout', None)  # type: Optional[int]
    request_id_parameter = kwargs.pop('request_id_parameter', None)  # type: Optional[str]
    deleted_share_name = kwargs.pop('deleted_share_name', None)  # type: Optional[str]
    deleted_share_version = kwargs.pop('deleted_share_version', None)  # type: Optional[str]

    restype = "share"
    comp = "undelete"
    version = "2020-10-02"
    accept = "application/xml"
    # Construct URL
    url = kwargs.pop("template_url", '/{shareName}')
    path_format_arguments = {
        "shareName": _SERIALIZER.url("share_name", share_name, 'str'),
    }

    url = _format_url_section(url, **path_format_arguments)

    # Construct parameters
    query_parameters = kwargs.pop("params", {})  # type: Dict[str, Any]
    query_parameters['restype'] = _SERIALIZER.query("restype", restype, 'str')
    query_parameters['comp'] = _SERIALIZER.query("comp", comp, 'str')
    if timeout is not None:
        query_parameters['timeout'] = _SERIALIZER.query("timeout", timeout, 'int', minimum=0)

    # Construct headers
    header_parameters = kwargs.pop("headers", {})  # type: Dict[str, Any]
    header_parameters['x-ms-version'] = _SERIALIZER.header("version", version, 'str')
    if request_id_parameter is not None:
        header_parameters['x-ms-client-request-id'] = _SERIALIZER.header("request_id_parameter", request_id_parameter, 'str')
    if deleted_share_name is not None:
        header_parameters['x-ms-deleted-share-name'] = _SERIALIZER.header("deleted_share_name", deleted_share_name, 'str')
    if deleted_share_version is not None:
        header_parameters['x-ms-deleted-share-version'] = _SERIALIZER.header("deleted_share_version", deleted_share_version, 'str')
    header_parameters['Accept'] = _SERIALIZER.header("accept", accept, 'str')

    return HttpRequest(
        method="PUT",
        url=url,
        params=query_parameters,
        headers=header_parameters,
        **kwargs
    )

# fmt: on
class ShareOperations(object):
    """ShareOperations operations.

    You should not instantiate this class directly. Instead, you should create a Client instance that
    instantiates it for you and attaches it as an attribute.

    :ivar models: Alias to model classes used in this operation group.
    :type models: ~azure.storage.fileshare.models
    :param client: Client for service requests.
    :param config: Configuration of service client.
    :param serializer: An object model serializer.
    :param deserializer: An object model deserializer.
    """

    models = _models

    def __init__(self, client, config, serializer, deserializer):
        self._client = client
        self._serialize = serializer
        self._deserialize = deserializer
        self._config = config

    @distributed_trace
    def create(
        self,
        share_name,  # type: str
        timeout=None,  # type: Optional[int]
        metadata=None,  # type: Optional[Dict[str, str]]
        quota=None,  # type: Optional[int]
        access_tier=None,  # type: Optional[Union[str, "_models.ShareAccessTier"]]
        enabled_protocols=None,  # type: Optional[str]
        root_squash=None,  # type: Optional[Union[str, "_models.ShareRootSquash"]]
        **kwargs  # type: Any
    ):
        # type: (...) -> None
        """Creates a new share under the specified account. If the share with the same name already
        exists, the operation fails.

        :param share_name: The name of the target share.
        :type share_name: str
        :param timeout: The timeout parameter is expressed in seconds. For more information, see
         :code:`<a
         href="https://docs.microsoft.com/en-us/rest/api/storageservices/Setting-Timeouts-for-File-Service-Operations?redirectedfrom=MSDN">Setting
         Timeouts for File Service Operations.</a>`.
        :type timeout: int
        :param metadata: A name-value pair to associate with a file storage object.
        :type metadata: dict[str, str]
        :param quota: Specifies the maximum size of the share, in gigabytes.
        :type quota: int
        :param access_tier: Specifies the access tier of the share.
        :type access_tier: str or ~azure.storage.fileshare.models.ShareAccessTier
        :param enabled_protocols: Protocols to enable on the share.
        :type enabled_protocols: str
        :param root_squash: Root squash to set on the share.  Only valid for NFS shares.
        :type root_squash: str or ~azure.storage.fileshare.models.ShareRootSquash
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: None, or the result of cls(response)
        :rtype: None
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType[None]
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}))

        
        request = build_create_request(
            share_name=share_name,
            timeout=timeout,
            metadata=metadata,
            quota=quota,
            access_tier=access_tier,
            enabled_protocols=enabled_protocols,
            root_squash=root_squash,
            template_url=self.create.metadata['url'],
        )
        request = _convert_request(request)
        path_format_arguments = {
            "url": self._serialize.url("self._config.url", self._config.url, 'str', skip_quote=True),
        }
        request.url = self._client.format_url(request.url, **path_format_arguments)

        pipeline_response = self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [201]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize.failsafe_deserialize(_models.StorageError, pipeline_response)
            raise HttpResponseError(response=response, model=error)

        response_headers = {}
        response_headers['ETag']=self._deserialize('str', response.headers.get('ETag'))
        response_headers['Last-Modified']=self._deserialize('rfc-1123', response.headers.get('Last-Modified'))
        response_headers['x-ms-request-id']=self._deserialize('str', response.headers.get('x-ms-request-id'))
        response_headers['x-ms-version']=self._deserialize('str', response.headers.get('x-ms-version'))
        response_headers['Date']=self._deserialize('rfc-1123', response.headers.get('Date'))


        if cls:
            return cls(pipeline_response, None, response_headers)

    create.metadata = {'url': '/{shareName}'}  # type: ignore


    @distributed_trace
    def get_properties(
        self,
        share_name,  # type: str
        sharesnapshot=None,  # type: Optional[str]
        timeout=None,  # type: Optional[int]
        lease_access_conditions=None,  # type: Optional["_models.LeaseAccessConditions"]
        **kwargs  # type: Any
    ):
        # type: (...) -> None
        """Returns all user-defined metadata and system properties for the specified share or share
        snapshot. The data returned does not include the share's list of files.

        :param share_name: The name of the target share.
        :type share_name: str
        :param sharesnapshot: The snapshot parameter is an opaque DateTime value that, when present,
         specifies the share snapshot to query.
        :type sharesnapshot: str
        :param timeout: The timeout parameter is expressed in seconds. For more information, see
         :code:`<a
         href="https://docs.microsoft.com/en-us/rest/api/storageservices/Setting-Timeouts-for-File-Service-Operations?redirectedfrom=MSDN">Setting
         Timeouts for File Service Operations.</a>`.
        :type timeout: int
        :param lease_access_conditions: Parameter group.
        :type lease_access_conditions: ~azure.storage.fileshare.models.LeaseAccessConditions
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: None, or the result of cls(response)
        :rtype: None
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType[None]
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}))

        _lease_id = None
        if lease_access_conditions is not None:
            _lease_id = lease_access_conditions.lease_id

        request = build_get_properties_request(
            share_name=share_name,
            sharesnapshot=sharesnapshot,
            timeout=timeout,
            lease_id=_lease_id,
            template_url=self.get_properties.metadata['url'],
        )
        request = _convert_request(request)
        path_format_arguments = {
            "url": self._serialize.url("self._config.url", self._config.url, 'str', skip_quote=True),
        }
        request.url = self._client.format_url(request.url, **path_format_arguments)

        pipeline_response = self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize.failsafe_deserialize(_models.StorageError, pipeline_response)
            raise HttpResponseError(response=response, model=error)

        response_headers = {}
        response_headers['x-ms-meta']=self._deserialize('{str}', response.headers.get('x-ms-meta'))
        response_headers['ETag']=self._deserialize('str', response.headers.get('ETag'))
        response_headers['Last-Modified']=self._deserialize('rfc-1123', response.headers.get('Last-Modified'))
        response_headers['x-ms-request-id']=self._deserialize('str', response.headers.get('x-ms-request-id'))
        response_headers['x-ms-version']=self._deserialize('str', response.headers.get('x-ms-version'))
        response_headers['Date']=self._deserialize('rfc-1123', response.headers.get('Date'))
        response_headers['x-ms-share-quota']=self._deserialize('int', response.headers.get('x-ms-share-quota'))
        response_headers['x-ms-share-provisioned-iops']=self._deserialize('int', response.headers.get('x-ms-share-provisioned-iops'))
        response_headers['x-ms-share-provisioned-ingress-mbps']=self._deserialize('int', response.headers.get('x-ms-share-provisioned-ingress-mbps'))
        response_headers['x-ms-share-provisioned-egress-mbps']=self._deserialize('int', response.headers.get('x-ms-share-provisioned-egress-mbps'))
        response_headers['x-ms-share-next-allowed-quota-downgrade-time']=self._deserialize('rfc-1123', response.headers.get('x-ms-share-next-allowed-quota-downgrade-time'))
        response_headers['x-ms-lease-duration']=self._deserialize('str', response.headers.get('x-ms-lease-duration'))
        response_headers['x-ms-lease-state']=self._deserialize('str', response.headers.get('x-ms-lease-state'))
        response_headers['x-ms-lease-status']=self._deserialize('str', response.headers.get('x-ms-lease-status'))
        response_headers['x-ms-access-tier']=self._deserialize('str', response.headers.get('x-ms-access-tier'))
        response_headers['x-ms-access-tier-change-time']=self._deserialize('rfc-1123', response.headers.get('x-ms-access-tier-change-time'))
        response_headers['x-ms-access-tier-transition-state']=self._deserialize('str', response.headers.get('x-ms-access-tier-transition-state'))
        response_headers['x-ms-enabled-protocols']=self._deserialize('str', response.headers.get('x-ms-enabled-protocols'))
        response_headers['x-ms-root-squash']=self._deserialize('str', response.headers.get('x-ms-root-squash'))


        if cls:
            return cls(pipeline_response, None, response_headers)

    get_properties.metadata = {'url': '/{shareName}'}  # type: ignore


    @distributed_trace
    def delete(
        self,
        share_name,  # type: str
        sharesnapshot=None,  # type: Optional[str]
        timeout=None,  # type: Optional[int]
        delete_snapshots=None,  # type: Optional[Union[str, "_models.DeleteSnapshotsOptionType"]]
        lease_access_conditions=None,  # type: Optional["_models.LeaseAccessConditions"]
        **kwargs  # type: Any
    ):
        # type: (...) -> None
        """Operation marks the specified share or share snapshot for deletion. The share or share snapshot
        and any files contained within it are later deleted during garbage collection.

        :param share_name: The name of the target share.
        :type share_name: str
        :param sharesnapshot: The snapshot parameter is an opaque DateTime value that, when present,
         specifies the share snapshot to query.
        :type sharesnapshot: str
        :param timeout: The timeout parameter is expressed in seconds. For more information, see
         :code:`<a
         href="https://docs.microsoft.com/en-us/rest/api/storageservices/Setting-Timeouts-for-File-Service-Operations?redirectedfrom=MSDN">Setting
         Timeouts for File Service Operations.</a>`.
        :type timeout: int
        :param delete_snapshots: Specifies the option include to delete the base share and all of its
         snapshots.
        :type delete_snapshots: str or ~azure.storage.fileshare.models.DeleteSnapshotsOptionType
        :param lease_access_conditions: Parameter group.
        :type lease_access_conditions: ~azure.storage.fileshare.models.LeaseAccessConditions
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: None, or the result of cls(response)
        :rtype: None
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType[None]
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}))

        _lease_id = None
        if lease_access_conditions is not None:
            _lease_id = lease_access_conditions.lease_id

        request = build_delete_request(
            share_name=share_name,
            sharesnapshot=sharesnapshot,
            timeout=timeout,
            delete_snapshots=delete_snapshots,
            lease_id=_lease_id,
            template_url=self.delete.metadata['url'],
        )
        request = _convert_request(request)
        path_format_arguments = {
            "url": self._serialize.url("self._config.url", self._config.url, 'str', skip_quote=True),
        }
        request.url = self._client.format_url(request.url, **path_format_arguments)

        pipeline_response = self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [202]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize.failsafe_deserialize(_models.StorageError, pipeline_response)
            raise HttpResponseError(response=response, model=error)

        response_headers = {}
        response_headers['x-ms-request-id']=self._deserialize('str', response.headers.get('x-ms-request-id'))
        response_headers['x-ms-version']=self._deserialize('str', response.headers.get('x-ms-version'))
        response_headers['Date']=self._deserialize('rfc-1123', response.headers.get('Date'))


        if cls:
            return cls(pipeline_response, None, response_headers)

    delete.metadata = {'url': '/{shareName}'}  # type: ignore


    @distributed_trace
    def acquire_lease(
        self,
        share_name,  # type: str
        timeout=None,  # type: Optional[int]
        duration=None,  # type: Optional[int]
        proposed_lease_id=None,  # type: Optional[str]
        sharesnapshot=None,  # type: Optional[str]
        request_id_parameter=None,  # type: Optional[str]
        **kwargs  # type: Any
    ):
        # type: (...) -> None
        """The Lease Share operation establishes and manages a lock on a share, or the specified snapshot
        for set and delete share operations.

        :param share_name: The name of the target share.
        :type share_name: str
        :param timeout: The timeout parameter is expressed in seconds. For more information, see
         :code:`<a
         href="https://docs.microsoft.com/en-us/rest/api/storageservices/Setting-Timeouts-for-File-Service-Operations?redirectedfrom=MSDN">Setting
         Timeouts for File Service Operations.</a>`.
        :type timeout: int
        :param duration: Specifies the duration of the lease, in seconds, or negative one (-1) for a
         lease that never expires. A non-infinite lease can be between 15 and 60 seconds. A lease
         duration cannot be changed using renew or change.
        :type duration: int
        :param proposed_lease_id: Proposed lease ID, in a GUID string format. The File service returns
         400 (Invalid request) if the proposed lease ID is not in the correct format. See Guid
         Constructor (String) for a list of valid GUID string formats.
        :type proposed_lease_id: str
        :param sharesnapshot: The snapshot parameter is an opaque DateTime value that, when present,
         specifies the share snapshot to query.
        :type sharesnapshot: str
        :param request_id_parameter: Provides a client-generated, opaque value with a 1 KB character
         limit that is recorded in the analytics logs when storage analytics logging is enabled.
        :type request_id_parameter: str
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: None, or the result of cls(response)
        :rtype: None
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType[None]
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}))

        
        request = build_acquire_lease_request(
            share_name=share_name,
            timeout=timeout,
            duration=duration,
            proposed_lease_id=proposed_lease_id,
            sharesnapshot=sharesnapshot,
            request_id_parameter=request_id_parameter,
            template_url=self.acquire_lease.metadata['url'],
        )
        request = _convert_request(request)
        path_format_arguments = {
            "url": self._serialize.url("self._config.url", self._config.url, 'str', skip_quote=True),
        }
        request.url = self._client.format_url(request.url, **path_format_arguments)

        pipeline_response = self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [201]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize.failsafe_deserialize(_models.StorageError, pipeline_response)
            raise HttpResponseError(response=response, model=error)

        response_headers = {}
        response_headers['ETag']=self._deserialize('str', response.headers.get('ETag'))
        response_headers['Last-Modified']=self._deserialize('rfc-1123', response.headers.get('Last-Modified'))
        response_headers['x-ms-lease-id']=self._deserialize('str', response.headers.get('x-ms-lease-id'))
        response_headers['x-ms-client-request-id']=self._deserialize('str', response.headers.get('x-ms-client-request-id'))
        response_headers['x-ms-request-id']=self._deserialize('str', response.headers.get('x-ms-request-id'))
        response_headers['x-ms-version']=self._deserialize('str', response.headers.get('x-ms-version'))
        response_headers['Date']=self._deserialize('rfc-1123', response.headers.get('Date'))


        if cls:
            return cls(pipeline_response, None, response_headers)

    acquire_lease.metadata = {'url': '/{shareName}'}  # type: ignore


    @distributed_trace
    def release_lease(
        self,
        share_name,  # type: str
        lease_id,  # type: str
        timeout=None,  # type: Optional[int]
        sharesnapshot=None,  # type: Optional[str]
        request_id_parameter=None,  # type: Optional[str]
        **kwargs  # type: Any
    ):
        # type: (...) -> None
        """The Lease Share operation establishes and manages a lock on a share, or the specified snapshot
        for set and delete share operations.

        :param share_name: The name of the target share.
        :type share_name: str
        :param lease_id: Specifies the current lease ID on the resource.
        :type lease_id: str
        :param timeout: The timeout parameter is expressed in seconds. For more information, see
         :code:`<a
         href="https://docs.microsoft.com/en-us/rest/api/storageservices/Setting-Timeouts-for-File-Service-Operations?redirectedfrom=MSDN">Setting
         Timeouts for File Service Operations.</a>`.
        :type timeout: int
        :param sharesnapshot: The snapshot parameter is an opaque DateTime value that, when present,
         specifies the share snapshot to query.
        :type sharesnapshot: str
        :param request_id_parameter: Provides a client-generated, opaque value with a 1 KB character
         limit that is recorded in the analytics logs when storage analytics logging is enabled.
        :type request_id_parameter: str
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: None, or the result of cls(response)
        :rtype: None
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType[None]
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}))

        
        request = build_release_lease_request(
            share_name=share_name,
            lease_id=lease_id,
            timeout=timeout,
            sharesnapshot=sharesnapshot,
            request_id_parameter=request_id_parameter,
            template_url=self.release_lease.metadata['url'],
        )
        request = _convert_request(request)
        path_format_arguments = {
            "url": self._serialize.url("self._config.url", self._config.url, 'str', skip_quote=True),
        }
        request.url = self._client.format_url(request.url, **path_format_arguments)

        pipeline_response = self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize.failsafe_deserialize(_models.StorageError, pipeline_response)
            raise HttpResponseError(response=response, model=error)

        response_headers = {}
        response_headers['ETag']=self._deserialize('str', response.headers.get('ETag'))
        response_headers['Last-Modified']=self._deserialize('rfc-1123', response.headers.get('Last-Modified'))
        response_headers['x-ms-client-request-id']=self._deserialize('str', response.headers.get('x-ms-client-request-id'))
        response_headers['x-ms-request-id']=self._deserialize('str', response.headers.get('x-ms-request-id'))
        response_headers['x-ms-version']=self._deserialize('str', response.headers.get('x-ms-version'))
        response_headers['Date']=self._deserialize('rfc-1123', response.headers.get('Date'))


        if cls:
            return cls(pipeline_response, None, response_headers)

    release_lease.metadata = {'url': '/{shareName}'}  # type: ignore


    @distributed_trace
    def change_lease(
        self,
        share_name,  # type: str
        lease_id,  # type: str
        timeout=None,  # type: Optional[int]
        proposed_lease_id=None,  # type: Optional[str]
        sharesnapshot=None,  # type: Optional[str]
        request_id_parameter=None,  # type: Optional[str]
        **kwargs  # type: Any
    ):
        # type: (...) -> None
        """The Lease Share operation establishes and manages a lock on a share, or the specified snapshot
        for set and delete share operations.

        :param share_name: The name of the target share.
        :type share_name: str
        :param lease_id: Specifies the current lease ID on the resource.
        :type lease_id: str
        :param timeout: The timeout parameter is expressed in seconds. For more information, see
         :code:`<a
         href="https://docs.microsoft.com/en-us/rest/api/storageservices/Setting-Timeouts-for-File-Service-Operations?redirectedfrom=MSDN">Setting
         Timeouts for File Service Operations.</a>`.
        :type timeout: int
        :param proposed_lease_id: Proposed lease ID, in a GUID string format. The File service returns
         400 (Invalid request) if the proposed lease ID is not in the correct format. See Guid
         Constructor (String) for a list of valid GUID string formats.
        :type proposed_lease_id: str
        :param sharesnapshot: The snapshot parameter is an opaque DateTime value that, when present,
         specifies the share snapshot to query.
        :type sharesnapshot: str
        :param request_id_parameter: Provides a client-generated, opaque value with a 1 KB character
         limit that is recorded in the analytics logs when storage analytics logging is enabled.
        :type request_id_parameter: str
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: None, or the result of cls(response)
        :rtype: None
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType[None]
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}))

        
        request = build_change_lease_request(
            share_name=share_name,
            lease_id=lease_id,
            timeout=timeout,
            proposed_lease_id=proposed_lease_id,
            sharesnapshot=sharesnapshot,
            request_id_parameter=request_id_parameter,
            template_url=self.change_lease.metadata['url'],
        )
        request = _convert_request(request)
        path_format_arguments = {
            "url": self._serialize.url("self._config.url", self._config.url, 'str', skip_quote=True),
        }
        request.url = self._client.format_url(request.url, **path_format_arguments)

        pipeline_response = self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize.failsafe_deserialize(_models.StorageError, pipeline_response)
            raise HttpResponseError(response=response, model=error)

        response_headers = {}
        response_headers['ETag']=self._deserialize('str', response.headers.get('ETag'))
        response_headers['Last-Modified']=self._deserialize('rfc-1123', response.headers.get('Last-Modified'))
        response_headers['x-ms-lease-id']=self._deserialize('str', response.headers.get('x-ms-lease-id'))
        response_headers['x-ms-client-request-id']=self._deserialize('str', response.headers.get('x-ms-client-request-id'))
        response_headers['x-ms-request-id']=self._deserialize('str', response.headers.get('x-ms-request-id'))
        response_headers['x-ms-version']=self._deserialize('str', response.headers.get('x-ms-version'))
        response_headers['Date']=self._deserialize('rfc-1123', response.headers.get('Date'))


        if cls:
            return cls(pipeline_response, None, response_headers)

    change_lease.metadata = {'url': '/{shareName}'}  # type: ignore


    @distributed_trace
    def renew_lease(
        self,
        share_name,  # type: str
        lease_id,  # type: str
        timeout=None,  # type: Optional[int]
        sharesnapshot=None,  # type: Optional[str]
        request_id_parameter=None,  # type: Optional[str]
        **kwargs  # type: Any
    ):
        # type: (...) -> None
        """The Lease Share operation establishes and manages a lock on a share, or the specified snapshot
        for set and delete share operations.

        :param share_name: The name of the target share.
        :type share_name: str
        :param lease_id: Specifies the current lease ID on the resource.
        :type lease_id: str
        :param timeout: The timeout parameter is expressed in seconds. For more information, see
         :code:`<a
         href="https://docs.microsoft.com/en-us/rest/api/storageservices/Setting-Timeouts-for-File-Service-Operations?redirectedfrom=MSDN">Setting
         Timeouts for File Service Operations.</a>`.
        :type timeout: int
        :param sharesnapshot: The snapshot parameter is an opaque DateTime value that, when present,
         specifies the share snapshot to query.
        :type sharesnapshot: str
        :param request_id_parameter: Provides a client-generated, opaque value with a 1 KB character
         limit that is recorded in the analytics logs when storage analytics logging is enabled.
        :type request_id_parameter: str
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: None, or the result of cls(response)
        :rtype: None
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType[None]
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}))

        
        request = build_renew_lease_request(
            share_name=share_name,
            lease_id=lease_id,
            timeout=timeout,
            sharesnapshot=sharesnapshot,
            request_id_parameter=request_id_parameter,
            template_url=self.renew_lease.metadata['url'],
        )
        request = _convert_request(request)
        path_format_arguments = {
            "url": self._serialize.url("self._config.url", self._config.url, 'str', skip_quote=True),
        }
        request.url = self._client.format_url(request.url, **path_format_arguments)

        pipeline_response = self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize.failsafe_deserialize(_models.StorageError, pipeline_response)
            raise HttpResponseError(response=response, model=error)

        response_headers = {}
        response_headers['ETag']=self._deserialize('str', response.headers.get('ETag'))
        response_headers['Last-Modified']=self._deserialize('rfc-1123', response.headers.get('Last-Modified'))
        response_headers['x-ms-lease-id']=self._deserialize('str', response.headers.get('x-ms-lease-id'))
        response_headers['x-ms-client-request-id']=self._deserialize('str', response.headers.get('x-ms-client-request-id'))
        response_headers['x-ms-request-id']=self._deserialize('str', response.headers.get('x-ms-request-id'))
        response_headers['x-ms-version']=self._deserialize('str', response.headers.get('x-ms-version'))
        response_headers['Date']=self._deserialize('rfc-1123', response.headers.get('Date'))


        if cls:
            return cls(pipeline_response, None, response_headers)

    renew_lease.metadata = {'url': '/{shareName}'}  # type: ignore


    @distributed_trace
    def break_lease(
        self,
        share_name,  # type: str
        timeout=None,  # type: Optional[int]
        break_period=None,  # type: Optional[int]
        request_id_parameter=None,  # type: Optional[str]
        sharesnapshot=None,  # type: Optional[str]
        lease_access_conditions=None,  # type: Optional["_models.LeaseAccessConditions"]
        **kwargs  # type: Any
    ):
        # type: (...) -> None
        """The Lease Share operation establishes and manages a lock on a share, or the specified snapshot
        for set and delete share operations.

        :param share_name: The name of the target share.
        :type share_name: str
        :param timeout: The timeout parameter is expressed in seconds. For more information, see
         :code:`<a
         href="https://docs.microsoft.com/en-us/rest/api/storageservices/Setting-Timeouts-for-File-Service-Operations?redirectedfrom=MSDN">Setting
         Timeouts for File Service Operations.</a>`.
        :type timeout: int
        :param break_period: For a break operation, proposed duration the lease should continue before
         it is broken, in seconds, between 0 and 60. This break period is only used if it is shorter
         than the time remaining on the lease. If longer, the time remaining on the lease is used. A new
         lease will not be available before the break period has expired, but the lease may be held for
         longer than the break period. If this header does not appear with a break operation, a
         fixed-duration lease breaks after the remaining lease period elapses, and an infinite lease
         breaks immediately.
        :type break_period: int
        :param request_id_parameter: Provides a client-generated, opaque value with a 1 KB character
         limit that is recorded in the analytics logs when storage analytics logging is enabled.
        :type request_id_parameter: str
        :param sharesnapshot: The snapshot parameter is an opaque DateTime value that, when present,
         specifies the share snapshot to query.
        :type sharesnapshot: str
        :param lease_access_conditions: Parameter group.
        :type lease_access_conditions: ~azure.storage.fileshare.models.LeaseAccessConditions
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: None, or the result of cls(response)
        :rtype: None
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType[None]
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}))

        _lease_id = None
        if lease_access_conditions is not None:
            _lease_id = lease_access_conditions.lease_id

        request = build_break_lease_request(
            share_name=share_name,
            timeout=timeout,
            break_period=break_period,
            lease_id=_lease_id,
            request_id_parameter=request_id_parameter,
            sharesnapshot=sharesnapshot,
            template_url=self.break_lease.metadata['url'],
        )
        request = _convert_request(request)
        path_format_arguments = {
            "url": self._serialize.url("self._config.url", self._config.url, 'str', skip_quote=True),
        }
        request.url = self._client.format_url(request.url, **path_format_arguments)

        pipeline_response = self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [202]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize.failsafe_deserialize(_models.StorageError, pipeline_response)
            raise HttpResponseError(response=response, model=error)

        response_headers = {}
        response_headers['ETag']=self._deserialize('str', response.headers.get('ETag'))
        response_headers['Last-Modified']=self._deserialize('rfc-1123', response.headers.get('Last-Modified'))
        response_headers['x-ms-lease-time']=self._deserialize('int', response.headers.get('x-ms-lease-time'))
        response_headers['x-ms-lease-id']=self._deserialize('str', response.headers.get('x-ms-lease-id'))
        response_headers['x-ms-client-request-id']=self._deserialize('str', response.headers.get('x-ms-client-request-id'))
        response_headers['x-ms-request-id']=self._deserialize('str', response.headers.get('x-ms-request-id'))
        response_headers['x-ms-version']=self._deserialize('str', response.headers.get('x-ms-version'))
        response_headers['Date']=self._deserialize('rfc-1123', response.headers.get('Date'))


        if cls:
            return cls(pipeline_response, None, response_headers)

    break_lease.metadata = {'url': '/{shareName}'}  # type: ignore


    @distributed_trace
    def create_snapshot(
        self,
        share_name,  # type: str
        timeout=None,  # type: Optional[int]
        metadata=None,  # type: Optional[Dict[str, str]]
        **kwargs  # type: Any
    ):
        # type: (...) -> None
        """Creates a read-only snapshot of a share.

        :param share_name: The name of the target share.
        :type share_name: str
        :param timeout: The timeout parameter is expressed in seconds. For more information, see
         :code:`<a
         href="https://docs.microsoft.com/en-us/rest/api/storageservices/Setting-Timeouts-for-File-Service-Operations?redirectedfrom=MSDN">Setting
         Timeouts for File Service Operations.</a>`.
        :type timeout: int
        :param metadata: A name-value pair to associate with a file storage object.
        :type metadata: dict[str, str]
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: None, or the result of cls(response)
        :rtype: None
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType[None]
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}))

        
        request = build_create_snapshot_request(
            share_name=share_name,
            timeout=timeout,
            metadata=metadata,
            template_url=self.create_snapshot.metadata['url'],
        )
        request = _convert_request(request)
        path_format_arguments = {
            "url": self._serialize.url("self._config.url", self._config.url, 'str', skip_quote=True),
        }
        request.url = self._client.format_url(request.url, **path_format_arguments)

        pipeline_response = self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [201]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize.failsafe_deserialize(_models.StorageError, pipeline_response)
            raise HttpResponseError(response=response, model=error)

        response_headers = {}
        response_headers['x-ms-snapshot']=self._deserialize('str', response.headers.get('x-ms-snapshot'))
        response_headers['ETag']=self._deserialize('str', response.headers.get('ETag'))
        response_headers['Last-Modified']=self._deserialize('rfc-1123', response.headers.get('Last-Modified'))
        response_headers['x-ms-request-id']=self._deserialize('str', response.headers.get('x-ms-request-id'))
        response_headers['x-ms-version']=self._deserialize('str', response.headers.get('x-ms-version'))
        response_headers['Date']=self._deserialize('rfc-1123', response.headers.get('Date'))


        if cls:
            return cls(pipeline_response, None, response_headers)

    create_snapshot.metadata = {'url': '/{shareName}'}  # type: ignore


    @distributed_trace
    def create_permission(
        self,
        share_name,  # type: str
        share_permission,  # type: "_models.SharePermission"
        timeout=None,  # type: Optional[int]
        **kwargs  # type: Any
    ):
        # type: (...) -> None
        """Create a permission (a security descriptor).

        :param share_name: The name of the target share.
        :type share_name: str
        :param share_permission: A permission (a security descriptor) at the share level.
        :type share_permission: ~azure.storage.fileshare.models.SharePermission
        :param timeout: The timeout parameter is expressed in seconds. For more information, see
         :code:`<a
         href="https://docs.microsoft.com/en-us/rest/api/storageservices/Setting-Timeouts-for-File-Service-Operations?redirectedfrom=MSDN">Setting
         Timeouts for File Service Operations.</a>`.
        :type timeout: int
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: None, or the result of cls(response)
        :rtype: None
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType[None]
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}))

        content_type = kwargs.pop('content_type', "application/json")  # type: Optional[str]

        json = self._serialize.body(share_permission, 'SharePermission')

        request = build_create_permission_request(
            share_name=share_name,
            content_type=content_type,
            timeout=timeout,
            json=json,
            template_url=self.create_permission.metadata['url'],
        )
        request = _convert_request(request)
        path_format_arguments = {
            "url": self._serialize.url("self._config.url", self._config.url, 'str', skip_quote=True),
        }
        request.url = self._client.format_url(request.url, **path_format_arguments)

        pipeline_response = self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [201]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize.failsafe_deserialize(_models.StorageError, pipeline_response)
            raise HttpResponseError(response=response, model=error)

        response_headers = {}
        response_headers['x-ms-request-id']=self._deserialize('str', response.headers.get('x-ms-request-id'))
        response_headers['x-ms-version']=self._deserialize('str', response.headers.get('x-ms-version'))
        response_headers['Date']=self._deserialize('rfc-1123', response.headers.get('Date'))
        response_headers['x-ms-file-permission-key']=self._deserialize('str', response.headers.get('x-ms-file-permission-key'))


        if cls:
            return cls(pipeline_response, None, response_headers)

    create_permission.metadata = {'url': '/{shareName}'}  # type: ignore


    @distributed_trace
    def get_permission(
        self,
        share_name,  # type: str
        file_permission_key,  # type: str
        timeout=None,  # type: Optional[int]
        **kwargs  # type: Any
    ):
        # type: (...) -> "_models.SharePermission"
        """Returns the permission (security descriptor) for a given key.

        :param share_name: The name of the target share.
        :type share_name: str
        :param file_permission_key: Key of the permission to be set for the directory/file.
        :type file_permission_key: str
        :param timeout: The timeout parameter is expressed in seconds. For more information, see
         :code:`<a
         href="https://docs.microsoft.com/en-us/rest/api/storageservices/Setting-Timeouts-for-File-Service-Operations?redirectedfrom=MSDN">Setting
         Timeouts for File Service Operations.</a>`.
        :type timeout: int
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: SharePermission, or the result of cls(response)
        :rtype: ~azure.storage.fileshare.models.SharePermission
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType["_models.SharePermission"]
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}))

        
        request = build_get_permission_request(
            share_name=share_name,
            file_permission_key=file_permission_key,
            timeout=timeout,
            template_url=self.get_permission.metadata['url'],
        )
        request = _convert_request(request)
        path_format_arguments = {
            "url": self._serialize.url("self._config.url", self._config.url, 'str', skip_quote=True),
        }
        request.url = self._client.format_url(request.url, **path_format_arguments)

        pipeline_response = self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize.failsafe_deserialize(_models.StorageError, pipeline_response)
            raise HttpResponseError(response=response, model=error)

        response_headers = {}
        response_headers['x-ms-request-id']=self._deserialize('str', response.headers.get('x-ms-request-id'))
        response_headers['x-ms-version']=self._deserialize('str', response.headers.get('x-ms-version'))
        response_headers['Date']=self._deserialize('rfc-1123', response.headers.get('Date'))

        deserialized = self._deserialize('SharePermission', pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, response_headers)

        return deserialized

    get_permission.metadata = {'url': '/{shareName}'}  # type: ignore


    @distributed_trace
    def set_properties(
        self,
        share_name,  # type: str
        timeout=None,  # type: Optional[int]
        quota=None,  # type: Optional[int]
        access_tier=None,  # type: Optional[Union[str, "_models.ShareAccessTier"]]
        root_squash=None,  # type: Optional[Union[str, "_models.ShareRootSquash"]]
        lease_access_conditions=None,  # type: Optional["_models.LeaseAccessConditions"]
        **kwargs  # type: Any
    ):
        # type: (...) -> None
        """Sets properties for the specified share.

        :param share_name: The name of the target share.
        :type share_name: str
        :param timeout: The timeout parameter is expressed in seconds. For more information, see
         :code:`<a
         href="https://docs.microsoft.com/en-us/rest/api/storageservices/Setting-Timeouts-for-File-Service-Operations?redirectedfrom=MSDN">Setting
         Timeouts for File Service Operations.</a>`.
        :type timeout: int
        :param quota: Specifies the maximum size of the share, in gigabytes.
        :type quota: int
        :param access_tier: Specifies the access tier of the share.
        :type access_tier: str or ~azure.storage.fileshare.models.ShareAccessTier
        :param root_squash: Root squash to set on the share.  Only valid for NFS shares.
        :type root_squash: str or ~azure.storage.fileshare.models.ShareRootSquash
        :param lease_access_conditions: Parameter group.
        :type lease_access_conditions: ~azure.storage.fileshare.models.LeaseAccessConditions
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: None, or the result of cls(response)
        :rtype: None
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType[None]
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}))

        _lease_id = None
        if lease_access_conditions is not None:
            _lease_id = lease_access_conditions.lease_id

        request = build_set_properties_request(
            share_name=share_name,
            timeout=timeout,
            quota=quota,
            access_tier=access_tier,
            lease_id=_lease_id,
            root_squash=root_squash,
            template_url=self.set_properties.metadata['url'],
        )
        request = _convert_request(request)
        path_format_arguments = {
            "url": self._serialize.url("self._config.url", self._config.url, 'str', skip_quote=True),
        }
        request.url = self._client.format_url(request.url, **path_format_arguments)

        pipeline_response = self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize.failsafe_deserialize(_models.StorageError, pipeline_response)
            raise HttpResponseError(response=response, model=error)

        response_headers = {}
        response_headers['ETag']=self._deserialize('str', response.headers.get('ETag'))
        response_headers['Last-Modified']=self._deserialize('rfc-1123', response.headers.get('Last-Modified'))
        response_headers['x-ms-request-id']=self._deserialize('str', response.headers.get('x-ms-request-id'))
        response_headers['x-ms-version']=self._deserialize('str', response.headers.get('x-ms-version'))
        response_headers['Date']=self._deserialize('rfc-1123', response.headers.get('Date'))


        if cls:
            return cls(pipeline_response, None, response_headers)

    set_properties.metadata = {'url': '/{shareName}'}  # type: ignore


    @distributed_trace
    def set_metadata(
        self,
        share_name,  # type: str
        timeout=None,  # type: Optional[int]
        metadata=None,  # type: Optional[Dict[str, str]]
        lease_access_conditions=None,  # type: Optional["_models.LeaseAccessConditions"]
        **kwargs  # type: Any
    ):
        # type: (...) -> None
        """Sets one or more user-defined name-value pairs for the specified share.

        :param share_name: The name of the target share.
        :type share_name: str
        :param timeout: The timeout parameter is expressed in seconds. For more information, see
         :code:`<a
         href="https://docs.microsoft.com/en-us/rest/api/storageservices/Setting-Timeouts-for-File-Service-Operations?redirectedfrom=MSDN">Setting
         Timeouts for File Service Operations.</a>`.
        :type timeout: int
        :param metadata: A name-value pair to associate with a file storage object.
        :type metadata: dict[str, str]
        :param lease_access_conditions: Parameter group.
        :type lease_access_conditions: ~azure.storage.fileshare.models.LeaseAccessConditions
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: None, or the result of cls(response)
        :rtype: None
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType[None]
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}))

        _lease_id = None
        if lease_access_conditions is not None:
            _lease_id = lease_access_conditions.lease_id

        request = build_set_metadata_request(
            share_name=share_name,
            timeout=timeout,
            metadata=metadata,
            lease_id=_lease_id,
            template_url=self.set_metadata.metadata['url'],
        )
        request = _convert_request(request)
        path_format_arguments = {
            "url": self._serialize.url("self._config.url", self._config.url, 'str', skip_quote=True),
        }
        request.url = self._client.format_url(request.url, **path_format_arguments)

        pipeline_response = self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize.failsafe_deserialize(_models.StorageError, pipeline_response)
            raise HttpResponseError(response=response, model=error)

        response_headers = {}
        response_headers['ETag']=self._deserialize('str', response.headers.get('ETag'))
        response_headers['Last-Modified']=self._deserialize('rfc-1123', response.headers.get('Last-Modified'))
        response_headers['x-ms-request-id']=self._deserialize('str', response.headers.get('x-ms-request-id'))
        response_headers['x-ms-version']=self._deserialize('str', response.headers.get('x-ms-version'))
        response_headers['Date']=self._deserialize('rfc-1123', response.headers.get('Date'))


        if cls:
            return cls(pipeline_response, None, response_headers)

    set_metadata.metadata = {'url': '/{shareName}'}  # type: ignore


    @distributed_trace
    def get_access_policy(
        self,
        share_name,  # type: str
        timeout=None,  # type: Optional[int]
        lease_access_conditions=None,  # type: Optional["_models.LeaseAccessConditions"]
        **kwargs  # type: Any
    ):
        # type: (...) -> List["_models.SignedIdentifier"]
        """Returns information about stored access policies specified on the share.

        :param share_name: The name of the target share.
        :type share_name: str
        :param timeout: The timeout parameter is expressed in seconds. For more information, see
         :code:`<a
         href="https://docs.microsoft.com/en-us/rest/api/storageservices/Setting-Timeouts-for-File-Service-Operations?redirectedfrom=MSDN">Setting
         Timeouts for File Service Operations.</a>`.
        :type timeout: int
        :param lease_access_conditions: Parameter group.
        :type lease_access_conditions: ~azure.storage.fileshare.models.LeaseAccessConditions
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: list of SignedIdentifier, or the result of cls(response)
        :rtype: list[~azure.storage.fileshare.models.SignedIdentifier]
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType[List["_models.SignedIdentifier"]]
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}))

        _lease_id = None
        if lease_access_conditions is not None:
            _lease_id = lease_access_conditions.lease_id

        request = build_get_access_policy_request(
            share_name=share_name,
            timeout=timeout,
            lease_id=_lease_id,
            template_url=self.get_access_policy.metadata['url'],
        )
        request = _convert_request(request)
        path_format_arguments = {
            "url": self._serialize.url("self._config.url", self._config.url, 'str', skip_quote=True),
        }
        request.url = self._client.format_url(request.url, **path_format_arguments)

        pipeline_response = self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize.failsafe_deserialize(_models.StorageError, pipeline_response)
            raise HttpResponseError(response=response, model=error)

        response_headers = {}
        response_headers['ETag']=self._deserialize('str', response.headers.get('ETag'))
        response_headers['Last-Modified']=self._deserialize('rfc-1123', response.headers.get('Last-Modified'))
        response_headers['x-ms-request-id']=self._deserialize('str', response.headers.get('x-ms-request-id'))
        response_headers['x-ms-version']=self._deserialize('str', response.headers.get('x-ms-version'))
        response_headers['Date']=self._deserialize('rfc-1123', response.headers.get('Date'))

        deserialized = self._deserialize('[SignedIdentifier]', pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, response_headers)

        return deserialized

    get_access_policy.metadata = {'url': '/{shareName}'}  # type: ignore


    @distributed_trace
    def set_access_policy(
        self,
        share_name,  # type: str
        timeout=None,  # type: Optional[int]
        share_acl=None,  # type: Optional[List["_models.SignedIdentifier"]]
        lease_access_conditions=None,  # type: Optional["_models.LeaseAccessConditions"]
        **kwargs  # type: Any
    ):
        # type: (...) -> None
        """Sets a stored access policy for use with shared access signatures.

        :param share_name: The name of the target share.
        :type share_name: str
        :param timeout: The timeout parameter is expressed in seconds. For more information, see
         :code:`<a
         href="https://docs.microsoft.com/en-us/rest/api/storageservices/Setting-Timeouts-for-File-Service-Operations?redirectedfrom=MSDN">Setting
         Timeouts for File Service Operations.</a>`.
        :type timeout: int
        :param share_acl: The ACL for the share.
        :type share_acl: list[~azure.storage.fileshare.models.SignedIdentifier]
        :param lease_access_conditions: Parameter group.
        :type lease_access_conditions: ~azure.storage.fileshare.models.LeaseAccessConditions
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: None, or the result of cls(response)
        :rtype: None
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType[None]
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}))

        content_type = kwargs.pop('content_type', "application/xml")  # type: Optional[str]

        _lease_id = None
        if lease_access_conditions is not None:
            _lease_id = lease_access_conditions.lease_id
        serialization_ctxt = {"xml": {'name': 'SignedIdentifiers', 'wrapped': True}}
        if share_acl is not None:
            content = self._serialize.body(share_acl, '[SignedIdentifier]', is_xml=True, serialization_ctxt=serialization_ctxt)
        else:
            content = None

        request = build_set_access_policy_request(
            share_name=share_name,
            content_type=content_type,
            timeout=timeout,
            lease_id=_lease_id,
            content=content,
            template_url=self.set_access_policy.metadata['url'],
        )
        request = _convert_request(request)
        path_format_arguments = {
            "url": self._serialize.url("self._config.url", self._config.url, 'str', skip_quote=True),
        }
        request.url = self._client.format_url(request.url, **path_format_arguments)

        pipeline_response = self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize.failsafe_deserialize(_models.StorageError, pipeline_response)
            raise HttpResponseError(response=response, model=error)

        response_headers = {}
        response_headers['ETag']=self._deserialize('str', response.headers.get('ETag'))
        response_headers['Last-Modified']=self._deserialize('rfc-1123', response.headers.get('Last-Modified'))
        response_headers['x-ms-request-id']=self._deserialize('str', response.headers.get('x-ms-request-id'))
        response_headers['x-ms-version']=self._deserialize('str', response.headers.get('x-ms-version'))
        response_headers['Date']=self._deserialize('rfc-1123', response.headers.get('Date'))


        if cls:
            return cls(pipeline_response, None, response_headers)

    set_access_policy.metadata = {'url': '/{shareName}'}  # type: ignore


    @distributed_trace
    def get_statistics(
        self,
        share_name,  # type: str
        timeout=None,  # type: Optional[int]
        lease_access_conditions=None,  # type: Optional["_models.LeaseAccessConditions"]
        **kwargs  # type: Any
    ):
        # type: (...) -> "_models.ShareStats"
        """Retrieves statistics related to the share.

        :param share_name: The name of the target share.
        :type share_name: str
        :param timeout: The timeout parameter is expressed in seconds. For more information, see
         :code:`<a
         href="https://docs.microsoft.com/en-us/rest/api/storageservices/Setting-Timeouts-for-File-Service-Operations?redirectedfrom=MSDN">Setting
         Timeouts for File Service Operations.</a>`.
        :type timeout: int
        :param lease_access_conditions: Parameter group.
        :type lease_access_conditions: ~azure.storage.fileshare.models.LeaseAccessConditions
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: ShareStats, or the result of cls(response)
        :rtype: ~azure.storage.fileshare.models.ShareStats
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType["_models.ShareStats"]
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}))

        _lease_id = None
        if lease_access_conditions is not None:
            _lease_id = lease_access_conditions.lease_id

        request = build_get_statistics_request(
            share_name=share_name,
            timeout=timeout,
            lease_id=_lease_id,
            template_url=self.get_statistics.metadata['url'],
        )
        request = _convert_request(request)
        path_format_arguments = {
            "url": self._serialize.url("self._config.url", self._config.url, 'str', skip_quote=True),
        }
        request.url = self._client.format_url(request.url, **path_format_arguments)

        pipeline_response = self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize.failsafe_deserialize(_models.StorageError, pipeline_response)
            raise HttpResponseError(response=response, model=error)

        response_headers = {}
        response_headers['ETag']=self._deserialize('str', response.headers.get('ETag'))
        response_headers['Last-Modified']=self._deserialize('rfc-1123', response.headers.get('Last-Modified'))
        response_headers['x-ms-request-id']=self._deserialize('str', response.headers.get('x-ms-request-id'))
        response_headers['x-ms-version']=self._deserialize('str', response.headers.get('x-ms-version'))
        response_headers['Date']=self._deserialize('rfc-1123', response.headers.get('Date'))

        deserialized = self._deserialize('ShareStats', pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, response_headers)

        return deserialized

    get_statistics.metadata = {'url': '/{shareName}'}  # type: ignore


    @distributed_trace
    def restore(
        self,
        share_name,  # type: str
        timeout=None,  # type: Optional[int]
        request_id_parameter=None,  # type: Optional[str]
        deleted_share_name=None,  # type: Optional[str]
        deleted_share_version=None,  # type: Optional[str]
        **kwargs  # type: Any
    ):
        # type: (...) -> None
        """Restores a previously deleted Share.

        :param share_name: The name of the target share.
        :type share_name: str
        :param timeout: The timeout parameter is expressed in seconds. For more information, see
         :code:`<a
         href="https://docs.microsoft.com/en-us/rest/api/storageservices/Setting-Timeouts-for-File-Service-Operations?redirectedfrom=MSDN">Setting
         Timeouts for File Service Operations.</a>`.
        :type timeout: int
        :param request_id_parameter: Provides a client-generated, opaque value with a 1 KB character
         limit that is recorded in the analytics logs when storage analytics logging is enabled.
        :type request_id_parameter: str
        :param deleted_share_name: Specifies the name of the previously-deleted share.
        :type deleted_share_name: str
        :param deleted_share_version: Specifies the version of the previously-deleted share.
        :type deleted_share_version: str
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: None, or the result of cls(response)
        :rtype: None
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType[None]
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}))

        
        request = build_restore_request(
            share_name=share_name,
            timeout=timeout,
            request_id_parameter=request_id_parameter,
            deleted_share_name=deleted_share_name,
            deleted_share_version=deleted_share_version,
            template_url=self.restore.metadata['url'],
        )
        request = _convert_request(request)
        path_format_arguments = {
            "url": self._serialize.url("self._config.url", self._config.url, 'str', skip_quote=True),
        }
        request.url = self._client.format_url(request.url, **path_format_arguments)

        pipeline_response = self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [201]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize.failsafe_deserialize(_models.StorageError, pipeline_response)
            raise HttpResponseError(response=response, model=error)

        response_headers = {}
        response_headers['ETag']=self._deserialize('str', response.headers.get('ETag'))
        response_headers['Last-Modified']=self._deserialize('rfc-1123', response.headers.get('Last-Modified'))
        response_headers['x-ms-request-id']=self._deserialize('str', response.headers.get('x-ms-request-id'))
        response_headers['x-ms-client-request-id']=self._deserialize('str', response.headers.get('x-ms-client-request-id'))
        response_headers['x-ms-version']=self._deserialize('str', response.headers.get('x-ms-version'))
        response_headers['Date']=self._deserialize('rfc-1123', response.headers.get('Date'))


        if cls:
            return cls(pipeline_response, None, response_headers)

    restore.metadata = {'url': '/{shareName}'}  # type: ignore

