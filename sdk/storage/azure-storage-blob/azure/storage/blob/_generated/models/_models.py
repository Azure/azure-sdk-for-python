# coding=utf-8
# --------------------------------------------------------------------------
# Copyright (c) Microsoft Corporation. All rights reserved.
# Licensed under the MIT License. See License.txt in the project root for license information.
# Code generated by Microsoft (R) AutoRest Code Generator.
# Changes may cause incorrect behavior and will be lost if the code is regenerated.
# --------------------------------------------------------------------------

from azure.core.exceptions import HttpResponseError
import msrest.serialization


class AccessPolicy(msrest.serialization.Model):
    """An Access policy.

    :param start: the date-time the policy is active.
    :type start: str
    :param expiry: the date-time the policy expires.
    :type expiry: str
    :param permission: the permissions for the acl policy.
    :type permission: str
    """

    _attribute_map = {
        'start': {'key': 'Start', 'type': 'str'},
        'expiry': {'key': 'Expiry', 'type': 'str'},
        'permission': {'key': 'Permission', 'type': 'str'},
    }

    def __init__(
        self,
        **kwargs
    ):
        super(AccessPolicy, self).__init__(**kwargs)
        self.start = kwargs.get('start', None)
        self.expiry = kwargs.get('expiry', None)
        self.permission = kwargs.get('permission', None)


class AppendPositionAccessConditions(msrest.serialization.Model):
    """Parameter group.

    :param max_size: Optional conditional header. The max length in bytes permitted for the append
     blob. If the Append Block operation would cause the blob to exceed that limit or if the blob
     size is already greater than the value specified in this header, the request will fail with
     MaxBlobSizeConditionNotMet error (HTTP status code 412 - Precondition Failed).
    :type max_size: long
    :param append_position: Optional conditional header, used only for the Append Block operation.
     A number indicating the byte offset to compare. Append Block will succeed only if the append
     position is equal to this number. If it is not, the request will fail with the
     AppendPositionConditionNotMet error (HTTP status code 412 - Precondition Failed).
    :type append_position: long
    """

    _attribute_map = {
        'max_size': {'key': 'maxSize', 'type': 'long'},
        'append_position': {'key': 'appendPosition', 'type': 'long'},
    }

    def __init__(
        self,
        **kwargs
    ):
        super(AppendPositionAccessConditions, self).__init__(**kwargs)
        self.max_size = kwargs.get('max_size', None)
        self.append_position = kwargs.get('append_position', None)


class ArrowConfiguration(msrest.serialization.Model):
    """arrow configuration.

    All required parameters must be populated in order to send to Azure.

    :param schema: Required.
    :type schema: list[~azure.storage.blob.models.ArrowField]
    """

    _validation = {
        'schema': {'required': True},
    }

    _attribute_map = {
        'schema': {'key': 'Schema', 'type': '[ArrowField]', 'xml': {'name': 'Schema', 'wrapped': True, 'itemsName': 'Field'}},
    }
    _xml_map = {
        'name': 'ArrowConfiguration'
    }

    def __init__(
        self,
        **kwargs
    ):
        super(ArrowConfiguration, self).__init__(**kwargs)
        self.schema = kwargs['schema']


class ArrowField(msrest.serialization.Model):
    """field of an arrow schema.

    All required parameters must be populated in order to send to Azure.

    :param type: Required.
    :type type: str
    :param name:
    :type name: str
    :param precision:
    :type precision: int
    :param scale:
    :type scale: int
    """

    _validation = {
        'type': {'required': True},
    }

    _attribute_map = {
        'type': {'key': 'Type', 'type': 'str'},
        'name': {'key': 'Name', 'type': 'str'},
        'precision': {'key': 'Precision', 'type': 'int'},
        'scale': {'key': 'Scale', 'type': 'int'},
    }
    _xml_map = {
        'name': 'Field'
    }

    def __init__(
        self,
        **kwargs
    ):
        super(ArrowField, self).__init__(**kwargs)
        self.type = kwargs['type']
        self.name = kwargs.get('name', None)
        self.precision = kwargs.get('precision', None)
        self.scale = kwargs.get('scale', None)


class BlobFlatListSegment(msrest.serialization.Model):
    """BlobFlatListSegment.

    All required parameters must be populated in order to send to Azure.

    :param blob_items: Required.
    :type blob_items: list[~azure.storage.blob.models.BlobItemInternal]
    """

    _validation = {
        'blob_items': {'required': True},
    }

    _attribute_map = {
        'blob_items': {'key': 'BlobItems', 'type': '[BlobItemInternal]'},
    }
    _xml_map = {
        'name': 'Blobs'
    }

    def __init__(
        self,
        **kwargs
    ):
        super(BlobFlatListSegment, self).__init__(**kwargs)
        self.blob_items = kwargs['blob_items']


class BlobHierarchyListSegment(msrest.serialization.Model):
    """BlobHierarchyListSegment.

    All required parameters must be populated in order to send to Azure.

    :param blob_prefixes:
    :type blob_prefixes: list[~azure.storage.blob.models.BlobPrefix]
    :param blob_items: Required.
    :type blob_items: list[~azure.storage.blob.models.BlobItemInternal]
    """

    _validation = {
        'blob_items': {'required': True},
    }

    _attribute_map = {
        'blob_prefixes': {'key': 'BlobPrefixes', 'type': '[BlobPrefix]', 'xml': {'name': 'BlobPrefix'}},
        'blob_items': {'key': 'BlobItems', 'type': '[BlobItemInternal]', 'xml': {'name': 'Blob', 'itemsName': 'Blob'}},
    }
    _xml_map = {
        'name': 'Blobs'
    }

    def __init__(
        self,
        **kwargs
    ):
        super(BlobHierarchyListSegment, self).__init__(**kwargs)
        self.blob_prefixes = kwargs.get('blob_prefixes', None)
        self.blob_items = kwargs['blob_items']


class BlobHTTPHeaders(msrest.serialization.Model):
    """Parameter group.

    :param blob_cache_control: Optional. Sets the blob's cache control. If specified, this property
     is stored with the blob and returned with a read request.
    :type blob_cache_control: str
    :param blob_content_type: Optional. Sets the blob's content type. If specified, this property
     is stored with the blob and returned with a read request.
    :type blob_content_type: str
    :param blob_content_md5: Optional. An MD5 hash of the blob content. Note that this hash is not
     validated, as the hashes for the individual blocks were validated when each was uploaded.
    :type blob_content_md5: bytearray
    :param blob_content_encoding: Optional. Sets the blob's content encoding. If specified, this
     property is stored with the blob and returned with a read request.
    :type blob_content_encoding: str
    :param blob_content_language: Optional. Set the blob's content language. If specified, this
     property is stored with the blob and returned with a read request.
    :type blob_content_language: str
    :param blob_content_disposition: Optional. Sets the blob's Content-Disposition header.
    :type blob_content_disposition: str
    """

    _attribute_map = {
        'blob_cache_control': {'key': 'blobCacheControl', 'type': 'str'},
        'blob_content_type': {'key': 'blobContentType', 'type': 'str'},
        'blob_content_md5': {'key': 'blobContentMD5', 'type': 'bytearray'},
        'blob_content_encoding': {'key': 'blobContentEncoding', 'type': 'str'},
        'blob_content_language': {'key': 'blobContentLanguage', 'type': 'str'},
        'blob_content_disposition': {'key': 'blobContentDisposition', 'type': 'str'},
    }

    def __init__(
        self,
        **kwargs
    ):
        super(BlobHTTPHeaders, self).__init__(**kwargs)
        self.blob_cache_control = kwargs.get('blob_cache_control', None)
        self.blob_content_type = kwargs.get('blob_content_type', None)
        self.blob_content_md5 = kwargs.get('blob_content_md5', None)
        self.blob_content_encoding = kwargs.get('blob_content_encoding', None)
        self.blob_content_language = kwargs.get('blob_content_language', None)
        self.blob_content_disposition = kwargs.get('blob_content_disposition', None)


class BlobItemInternal(msrest.serialization.Model):
    """An Azure Storage blob.

    All required parameters must be populated in order to send to Azure.

    :param name: Required.
    :type name: str
    :param deleted: Required.
    :type deleted: bool
    :param snapshot: Required.
    :type snapshot: str
    :param version_id:
    :type version_id: str
    :param is_current_version:
    :type is_current_version: bool
    :param properties: Required. Properties of a blob.
    :type properties: ~azure.storage.blob.models.BlobPropertiesInternal
    :param metadata:
    :type metadata: ~azure.storage.blob.models.BlobMetadata
    :param blob_tags: Blob tags.
    :type blob_tags: ~azure.storage.blob.models.BlobTags
    :param object_replication_metadata: Dictionary of :code:`<string>`.
    :type object_replication_metadata: dict[str, str]
    """

    _validation = {
        'name': {'required': True},
        'deleted': {'required': True},
        'snapshot': {'required': True},
        'properties': {'required': True},
    }

    _attribute_map = {
        'name': {'key': 'Name', 'type': 'str'},
        'deleted': {'key': 'Deleted', 'type': 'bool'},
        'snapshot': {'key': 'Snapshot', 'type': 'str'},
        'version_id': {'key': 'VersionId', 'type': 'str'},
        'is_current_version': {'key': 'IsCurrentVersion', 'type': 'bool'},
        'properties': {'key': 'Properties', 'type': 'BlobPropertiesInternal'},
        'metadata': {'key': 'Metadata', 'type': 'BlobMetadata'},
        'blob_tags': {'key': 'BlobTags', 'type': 'BlobTags'},
        'object_replication_metadata': {'key': 'OrMetadata', 'type': '{str}'},
    }
    _xml_map = {
        'name': 'Blob'
    }

    def __init__(
        self,
        **kwargs
    ):
        super(BlobItemInternal, self).__init__(**kwargs)
        self.name = kwargs['name']
        self.deleted = kwargs['deleted']
        self.snapshot = kwargs['snapshot']
        self.version_id = kwargs.get('version_id', None)
        self.is_current_version = kwargs.get('is_current_version', None)
        self.properties = kwargs['properties']
        self.metadata = kwargs.get('metadata', None)
        self.blob_tags = kwargs.get('blob_tags', None)
        self.object_replication_metadata = kwargs.get('object_replication_metadata', None)


class BlobMetadata(msrest.serialization.Model):
    """BlobMetadata.

    :param additional_properties: Unmatched properties from the message are deserialized to this
     collection.
    :type additional_properties: dict[str, str]
    :param encrypted:
    :type encrypted: str
    """

    _attribute_map = {
        'additional_properties': {'key': '', 'type': '{str}'},
        'encrypted': {'key': 'Encrypted', 'type': 'str', 'xml': {'attr': True}},
    }
    _xml_map = {
        'name': 'Metadata'
    }

    def __init__(
        self,
        **kwargs
    ):
        super(BlobMetadata, self).__init__(**kwargs)
        self.additional_properties = kwargs.get('additional_properties', None)
        self.encrypted = kwargs.get('encrypted', None)


class BlobPrefix(msrest.serialization.Model):
    """BlobPrefix.

    All required parameters must be populated in order to send to Azure.

    :param name: Required.
    :type name: str
    """

    _validation = {
        'name': {'required': True},
    }

    _attribute_map = {
        'name': {'key': 'Name', 'type': 'str'},
    }

    def __init__(
        self,
        **kwargs
    ):
        super(BlobPrefix, self).__init__(**kwargs)
        self.name = kwargs['name']


class BlobPropertiesInternal(msrest.serialization.Model):
    """Properties of a blob.

    All required parameters must be populated in order to send to Azure.

    :param creation_time:
    :type creation_time: ~datetime.datetime
    :param last_modified: Required.
    :type last_modified: ~datetime.datetime
    :param etag: Required.
    :type etag: str
    :param content_length: Size in bytes.
    :type content_length: long
    :param content_type:
    :type content_type: str
    :param content_encoding:
    :type content_encoding: str
    :param content_language:
    :type content_language: str
    :param content_md5:
    :type content_md5: bytearray
    :param content_disposition:
    :type content_disposition: str
    :param cache_control:
    :type cache_control: str
    :param blob_sequence_number:
    :type blob_sequence_number: long
    :param blob_type:  Possible values include: "BlockBlob", "PageBlob", "AppendBlob".
    :type blob_type: str or ~azure.storage.blob.models.BlobType
    :param lease_status:  Possible values include: "locked", "unlocked".
    :type lease_status: str or ~azure.storage.blob.models.LeaseStatusType
    :param lease_state:  Possible values include: "available", "leased", "expired", "breaking",
     "broken".
    :type lease_state: str or ~azure.storage.blob.models.LeaseStateType
    :param lease_duration:  Possible values include: "infinite", "fixed".
    :type lease_duration: str or ~azure.storage.blob.models.LeaseDurationType
    :param copy_id:
    :type copy_id: str
    :param copy_status:  Possible values include: "pending", "success", "aborted", "failed".
    :type copy_status: str or ~azure.storage.blob.models.CopyStatusType
    :param copy_source:
    :type copy_source: str
    :param copy_progress:
    :type copy_progress: str
    :param copy_completion_time:
    :type copy_completion_time: ~datetime.datetime
    :param copy_status_description:
    :type copy_status_description: str
    :param server_encrypted:
    :type server_encrypted: bool
    :param incremental_copy:
    :type incremental_copy: bool
    :param destination_snapshot:
    :type destination_snapshot: str
    :param deleted_time:
    :type deleted_time: ~datetime.datetime
    :param remaining_retention_days:
    :type remaining_retention_days: int
    :param access_tier:  Possible values include: "P4", "P6", "P10", "P15", "P20", "P30", "P40",
     "P50", "P60", "P70", "P80", "Hot", "Cool", "Archive".
    :type access_tier: str or ~azure.storage.blob.models.AccessTier
    :param access_tier_inferred:
    :type access_tier_inferred: bool
    :param archive_status:  Possible values include: "rehydrate-pending-to-hot", "rehydrate-
     pending-to-cool".
    :type archive_status: str or ~azure.storage.blob.models.ArchiveStatus
    :param customer_provided_key_sha256:
    :type customer_provided_key_sha256: str
    :param encryption_scope: The name of the encryption scope under which the blob is encrypted.
    :type encryption_scope: str
    :param access_tier_change_time:
    :type access_tier_change_time: ~datetime.datetime
    :param tag_count:
    :type tag_count: int
    :param expires_on:
    :type expires_on: ~datetime.datetime
    :param is_sealed:
    :type is_sealed: bool
    :param rehydrate_priority: If an object is in rehydrate pending state then this header is
     returned with priority of rehydrate. Valid values are High and Standard. Possible values
     include: "High", "Standard".
    :type rehydrate_priority: str or ~azure.storage.blob.models.RehydratePriority
    :param last_accessed_on:
    :type last_accessed_on: ~datetime.datetime
    """

    _validation = {
        'last_modified': {'required': True},
        'etag': {'required': True},
    }

    _attribute_map = {
        'creation_time': {'key': 'Creation-Time', 'type': 'rfc-1123'},
        'last_modified': {'key': 'Last-Modified', 'type': 'rfc-1123'},
        'etag': {'key': 'Etag', 'type': 'str'},
        'content_length': {'key': 'Content-Length', 'type': 'long'},
        'content_type': {'key': 'Content-Type', 'type': 'str'},
        'content_encoding': {'key': 'Content-Encoding', 'type': 'str'},
        'content_language': {'key': 'Content-Language', 'type': 'str'},
        'content_md5': {'key': 'Content-MD5', 'type': 'bytearray'},
        'content_disposition': {'key': 'Content-Disposition', 'type': 'str'},
        'cache_control': {'key': 'Cache-Control', 'type': 'str'},
        'blob_sequence_number': {'key': 'x-ms-blob-sequence-number', 'type': 'long'},
        'blob_type': {'key': 'BlobType', 'type': 'str'},
        'lease_status': {'key': 'LeaseStatus', 'type': 'str'},
        'lease_state': {'key': 'LeaseState', 'type': 'str'},
        'lease_duration': {'key': 'LeaseDuration', 'type': 'str'},
        'copy_id': {'key': 'CopyId', 'type': 'str'},
        'copy_status': {'key': 'CopyStatus', 'type': 'str'},
        'copy_source': {'key': 'CopySource', 'type': 'str'},
        'copy_progress': {'key': 'CopyProgress', 'type': 'str'},
        'copy_completion_time': {'key': 'CopyCompletionTime', 'type': 'rfc-1123'},
        'copy_status_description': {'key': 'CopyStatusDescription', 'type': 'str'},
        'server_encrypted': {'key': 'ServerEncrypted', 'type': 'bool'},
        'incremental_copy': {'key': 'IncrementalCopy', 'type': 'bool'},
        'destination_snapshot': {'key': 'DestinationSnapshot', 'type': 'str'},
        'deleted_time': {'key': 'DeletedTime', 'type': 'rfc-1123'},
        'remaining_retention_days': {'key': 'RemainingRetentionDays', 'type': 'int'},
        'access_tier': {'key': 'AccessTier', 'type': 'str'},
        'access_tier_inferred': {'key': 'AccessTierInferred', 'type': 'bool'},
        'archive_status': {'key': 'ArchiveStatus', 'type': 'str'},
        'customer_provided_key_sha256': {'key': 'CustomerProvidedKeySha256', 'type': 'str'},
        'encryption_scope': {'key': 'EncryptionScope', 'type': 'str'},
        'access_tier_change_time': {'key': 'AccessTierChangeTime', 'type': 'rfc-1123'},
        'tag_count': {'key': 'TagCount', 'type': 'int'},
        'expires_on': {'key': 'Expiry-Time', 'type': 'rfc-1123'},
        'is_sealed': {'key': 'Sealed', 'type': 'bool'},
        'rehydrate_priority': {'key': 'RehydratePriority', 'type': 'str'},
        'last_accessed_on': {'key': 'LastAccessTime', 'type': 'rfc-1123'},
    }
    _xml_map = {
        'name': 'Properties'
    }

    def __init__(
        self,
        **kwargs
    ):
        super(BlobPropertiesInternal, self).__init__(**kwargs)
        self.creation_time = kwargs.get('creation_time', None)
        self.last_modified = kwargs['last_modified']
        self.etag = kwargs['etag']
        self.content_length = kwargs.get('content_length', None)
        self.content_type = kwargs.get('content_type', None)
        self.content_encoding = kwargs.get('content_encoding', None)
        self.content_language = kwargs.get('content_language', None)
        self.content_md5 = kwargs.get('content_md5', None)
        self.content_disposition = kwargs.get('content_disposition', None)
        self.cache_control = kwargs.get('cache_control', None)
        self.blob_sequence_number = kwargs.get('blob_sequence_number', None)
        self.blob_type = kwargs.get('blob_type', None)
        self.lease_status = kwargs.get('lease_status', None)
        self.lease_state = kwargs.get('lease_state', None)
        self.lease_duration = kwargs.get('lease_duration', None)
        self.copy_id = kwargs.get('copy_id', None)
        self.copy_status = kwargs.get('copy_status', None)
        self.copy_source = kwargs.get('copy_source', None)
        self.copy_progress = kwargs.get('copy_progress', None)
        self.copy_completion_time = kwargs.get('copy_completion_time', None)
        self.copy_status_description = kwargs.get('copy_status_description', None)
        self.server_encrypted = kwargs.get('server_encrypted', None)
        self.incremental_copy = kwargs.get('incremental_copy', None)
        self.destination_snapshot = kwargs.get('destination_snapshot', None)
        self.deleted_time = kwargs.get('deleted_time', None)
        self.remaining_retention_days = kwargs.get('remaining_retention_days', None)
        self.access_tier = kwargs.get('access_tier', None)
        self.access_tier_inferred = kwargs.get('access_tier_inferred', None)
        self.archive_status = kwargs.get('archive_status', None)
        self.customer_provided_key_sha256 = kwargs.get('customer_provided_key_sha256', None)
        self.encryption_scope = kwargs.get('encryption_scope', None)
        self.access_tier_change_time = kwargs.get('access_tier_change_time', None)
        self.tag_count = kwargs.get('tag_count', None)
        self.expires_on = kwargs.get('expires_on', None)
        self.is_sealed = kwargs.get('is_sealed', None)
        self.rehydrate_priority = kwargs.get('rehydrate_priority', None)
        self.last_accessed_on = kwargs.get('last_accessed_on', None)


class BlobTag(msrest.serialization.Model):
    """BlobTag.

    All required parameters must be populated in order to send to Azure.

    :param key: Required.
    :type key: str
    :param value: Required.
    :type value: str
    """

    _validation = {
        'key': {'required': True},
        'value': {'required': True},
    }

    _attribute_map = {
        'key': {'key': 'Key', 'type': 'str'},
        'value': {'key': 'Value', 'type': 'str'},
    }
    _xml_map = {
        'name': 'Tag'
    }

    def __init__(
        self,
        **kwargs
    ):
        super(BlobTag, self).__init__(**kwargs)
        self.key = kwargs['key']
        self.value = kwargs['value']


class BlobTags(msrest.serialization.Model):
    """Blob tags.

    All required parameters must be populated in order to send to Azure.

    :param blob_tag_set: Required.
    :type blob_tag_set: list[~azure.storage.blob.models.BlobTag]
    """

    _validation = {
        'blob_tag_set': {'required': True},
    }

    _attribute_map = {
        'blob_tag_set': {'key': 'BlobTagSet', 'type': '[BlobTag]', 'xml': {'name': 'TagSet', 'wrapped': True, 'itemsName': 'Tag'}},
    }
    _xml_map = {
        'name': 'Tags'
    }

    def __init__(
        self,
        **kwargs
    ):
        super(BlobTags, self).__init__(**kwargs)
        self.blob_tag_set = kwargs['blob_tag_set']


class Block(msrest.serialization.Model):
    """Represents a single block in a block blob.  It describes the block's ID and size.

    All required parameters must be populated in order to send to Azure.

    :param name: Required. The base64 encoded block ID.
    :type name: str
    :param size: Required. The block size in bytes.
    :type size: int
    """

    _validation = {
        'name': {'required': True},
        'size': {'required': True},
    }

    _attribute_map = {
        'name': {'key': 'Name', 'type': 'str'},
        'size': {'key': 'Size', 'type': 'int'},
    }

    def __init__(
        self,
        **kwargs
    ):
        super(Block, self).__init__(**kwargs)
        self.name = kwargs['name']
        self.size = kwargs['size']


class BlockList(msrest.serialization.Model):
    """BlockList.

    :param committed_blocks:
    :type committed_blocks: list[~azure.storage.blob.models.Block]
    :param uncommitted_blocks:
    :type uncommitted_blocks: list[~azure.storage.blob.models.Block]
    """

    _attribute_map = {
        'committed_blocks': {'key': 'CommittedBlocks', 'type': '[Block]', 'xml': {'wrapped': True}},
        'uncommitted_blocks': {'key': 'UncommittedBlocks', 'type': '[Block]', 'xml': {'wrapped': True}},
    }

    def __init__(
        self,
        **kwargs
    ):
        super(BlockList, self).__init__(**kwargs)
        self.committed_blocks = kwargs.get('committed_blocks', None)
        self.uncommitted_blocks = kwargs.get('uncommitted_blocks', None)


class BlockLookupList(msrest.serialization.Model):
    """BlockLookupList.

    :param committed:
    :type committed: list[str]
    :param uncommitted:
    :type uncommitted: list[str]
    :param latest:
    :type latest: list[str]
    """

    _attribute_map = {
        'committed': {'key': 'Committed', 'type': '[str]', 'xml': {'itemsName': 'Committed'}},
        'uncommitted': {'key': 'Uncommitted', 'type': '[str]', 'xml': {'itemsName': 'Uncommitted'}},
        'latest': {'key': 'Latest', 'type': '[str]', 'xml': {'itemsName': 'Latest'}},
    }
    _xml_map = {
        'name': 'BlockList'
    }

    def __init__(
        self,
        **kwargs
    ):
        super(BlockLookupList, self).__init__(**kwargs)
        self.committed = kwargs.get('committed', None)
        self.uncommitted = kwargs.get('uncommitted', None)
        self.latest = kwargs.get('latest', None)


class ClearRange(msrest.serialization.Model):
    """ClearRange.

    All required parameters must be populated in order to send to Azure.

    :param start: Required.
    :type start: long
    :param end: Required.
    :type end: long
    """

    _validation = {
        'start': {'required': True},
        'end': {'required': True},
    }

    _attribute_map = {
        'start': {'key': 'Start', 'type': 'long', 'xml': {'name': 'Start'}},
        'end': {'key': 'End', 'type': 'long', 'xml': {'name': 'End'}},
    }
    _xml_map = {
        'name': 'ClearRange'
    }

    def __init__(
        self,
        **kwargs
    ):
        super(ClearRange, self).__init__(**kwargs)
        self.start = kwargs['start']
        self.end = kwargs['end']


class ContainerCpkScopeInfo(msrest.serialization.Model):
    """Parameter group.

    :param default_encryption_scope: Optional.  Version 2019-07-07 and later.  Specifies the
     default encryption scope to set on the container and use for all future writes.
    :type default_encryption_scope: str
    :param prevent_encryption_scope_override: Optional.  Version 2019-07-07 and newer.  If true,
     prevents any request from specifying a different encryption scope than the scope set on the
     container.
    :type prevent_encryption_scope_override: bool
    """

    _attribute_map = {
        'default_encryption_scope': {'key': 'DefaultEncryptionScope', 'type': 'str'},
        'prevent_encryption_scope_override': {'key': 'PreventEncryptionScopeOverride', 'type': 'bool'},
    }

    def __init__(
        self,
        **kwargs
    ):
        super(ContainerCpkScopeInfo, self).__init__(**kwargs)
        self.default_encryption_scope = kwargs.get('default_encryption_scope', None)
        self.prevent_encryption_scope_override = kwargs.get('prevent_encryption_scope_override', None)


class ContainerItem(msrest.serialization.Model):
    """An Azure Storage container.

    All required parameters must be populated in order to send to Azure.

    :param name: Required.
    :type name: str
    :param deleted:
    :type deleted: bool
    :param version:
    :type version: str
    :param properties: Required. Properties of a container.
    :type properties: ~azure.storage.blob.models.ContainerProperties
    :param metadata: Dictionary of :code:`<string>`.
    :type metadata: dict[str, str]
    """

    _validation = {
        'name': {'required': True},
        'properties': {'required': True},
    }

    _attribute_map = {
        'name': {'key': 'Name', 'type': 'str'},
        'deleted': {'key': 'Deleted', 'type': 'bool'},
        'version': {'key': 'Version', 'type': 'str'},
        'properties': {'key': 'Properties', 'type': 'ContainerProperties'},
        'metadata': {'key': 'Metadata', 'type': '{str}'},
    }
    _xml_map = {
        'name': 'Container'
    }

    def __init__(
        self,
        **kwargs
    ):
        super(ContainerItem, self).__init__(**kwargs)
        self.name = kwargs['name']
        self.deleted = kwargs.get('deleted', None)
        self.version = kwargs.get('version', None)
        self.properties = kwargs['properties']
        self.metadata = kwargs.get('metadata', None)


class ContainerProperties(msrest.serialization.Model):
    """Properties of a container.

    All required parameters must be populated in order to send to Azure.

    :param last_modified: Required.
    :type last_modified: ~datetime.datetime
    :param etag: Required.
    :type etag: str
    :param lease_status:  Possible values include: "locked", "unlocked".
    :type lease_status: str or ~azure.storage.blob.models.LeaseStatusType
    :param lease_state:  Possible values include: "available", "leased", "expired", "breaking",
     "broken".
    :type lease_state: str or ~azure.storage.blob.models.LeaseStateType
    :param lease_duration:  Possible values include: "infinite", "fixed".
    :type lease_duration: str or ~azure.storage.blob.models.LeaseDurationType
    :param public_access:  Possible values include: "container", "blob".
    :type public_access: str or ~azure.storage.blob.models.PublicAccessType
    :param has_immutability_policy:
    :type has_immutability_policy: bool
    :param has_legal_hold:
    :type has_legal_hold: bool
    :param default_encryption_scope:
    :type default_encryption_scope: str
    :param prevent_encryption_scope_override:
    :type prevent_encryption_scope_override: bool
    :param deleted_time:
    :type deleted_time: ~datetime.datetime
    :param remaining_retention_days:
    :type remaining_retention_days: int
    """

    _validation = {
        'last_modified': {'required': True},
        'etag': {'required': True},
    }

    _attribute_map = {
        'last_modified': {'key': 'Last-Modified', 'type': 'rfc-1123'},
        'etag': {'key': 'Etag', 'type': 'str'},
        'lease_status': {'key': 'LeaseStatus', 'type': 'str'},
        'lease_state': {'key': 'LeaseState', 'type': 'str'},
        'lease_duration': {'key': 'LeaseDuration', 'type': 'str'},
        'public_access': {'key': 'PublicAccess', 'type': 'str'},
        'has_immutability_policy': {'key': 'HasImmutabilityPolicy', 'type': 'bool'},
        'has_legal_hold': {'key': 'HasLegalHold', 'type': 'bool'},
        'default_encryption_scope': {'key': 'DefaultEncryptionScope', 'type': 'str'},
        'prevent_encryption_scope_override': {'key': 'DenyEncryptionScopeOverride', 'type': 'bool'},
        'deleted_time': {'key': 'DeletedTime', 'type': 'rfc-1123'},
        'remaining_retention_days': {'key': 'RemainingRetentionDays', 'type': 'int'},
    }

    def __init__(
        self,
        **kwargs
    ):
        super(ContainerProperties, self).__init__(**kwargs)
        self.last_modified = kwargs['last_modified']
        self.etag = kwargs['etag']
        self.lease_status = kwargs.get('lease_status', None)
        self.lease_state = kwargs.get('lease_state', None)
        self.lease_duration = kwargs.get('lease_duration', None)
        self.public_access = kwargs.get('public_access', None)
        self.has_immutability_policy = kwargs.get('has_immutability_policy', None)
        self.has_legal_hold = kwargs.get('has_legal_hold', None)
        self.default_encryption_scope = kwargs.get('default_encryption_scope', None)
        self.prevent_encryption_scope_override = kwargs.get('prevent_encryption_scope_override', None)
        self.deleted_time = kwargs.get('deleted_time', None)
        self.remaining_retention_days = kwargs.get('remaining_retention_days', None)


class CorsRule(msrest.serialization.Model):
    """CORS is an HTTP feature that enables a web application running under one domain to access resources in another domain. Web browsers implement a security restriction known as same-origin policy that prevents a web page from calling APIs in a different domain; CORS provides a secure way to allow one domain (the origin domain) to call APIs in another domain.

    All required parameters must be populated in order to send to Azure.

    :param allowed_origins: Required. The origin domains that are permitted to make a request
     against the storage service via CORS. The origin domain is the domain from which the request
     originates. Note that the origin must be an exact case-sensitive match with the origin that the
     user age sends to the service. You can also use the wildcard character '*' to allow all origin
     domains to make requests via CORS.
    :type allowed_origins: str
    :param allowed_methods: Required. The methods (HTTP request verbs) that the origin domain may
     use for a CORS request. (comma separated).
    :type allowed_methods: str
    :param allowed_headers: Required. the request headers that the origin domain may specify on the
     CORS request.
    :type allowed_headers: str
    :param exposed_headers: Required. The response headers that may be sent in the response to the
     CORS request and exposed by the browser to the request issuer.
    :type exposed_headers: str
    :param max_age_in_seconds: Required. The maximum amount time that a browser should cache the
     preflight OPTIONS request.
    :type max_age_in_seconds: int
    """

    _validation = {
        'allowed_origins': {'required': True},
        'allowed_methods': {'required': True},
        'allowed_headers': {'required': True},
        'exposed_headers': {'required': True},
        'max_age_in_seconds': {'required': True, 'minimum': 0},
    }

    _attribute_map = {
        'allowed_origins': {'key': 'AllowedOrigins', 'type': 'str'},
        'allowed_methods': {'key': 'AllowedMethods', 'type': 'str'},
        'allowed_headers': {'key': 'AllowedHeaders', 'type': 'str'},
        'exposed_headers': {'key': 'ExposedHeaders', 'type': 'str'},
        'max_age_in_seconds': {'key': 'MaxAgeInSeconds', 'type': 'int'},
    }

    def __init__(
        self,
        **kwargs
    ):
        super(CorsRule, self).__init__(**kwargs)
        self.allowed_origins = kwargs['allowed_origins']
        self.allowed_methods = kwargs['allowed_methods']
        self.allowed_headers = kwargs['allowed_headers']
        self.exposed_headers = kwargs['exposed_headers']
        self.max_age_in_seconds = kwargs['max_age_in_seconds']


class CpkInfo(msrest.serialization.Model):
    """Parameter group.

    :param encryption_key: Optional. Specifies the encryption key to use to encrypt the data
     provided in the request. If not specified, encryption is performed with the root account
     encryption key.  For more information, see Encryption at Rest for Azure Storage Services.
    :type encryption_key: str
    :param encryption_key_sha256: The SHA-256 hash of the provided encryption key. Must be provided
     if the x-ms-encryption-key header is provided.
    :type encryption_key_sha256: str
    """

    _attribute_map = {
        'encryption_key': {'key': 'encryptionKey', 'type': 'str'},
        'encryption_key_sha256': {'key': 'encryptionKeySha256', 'type': 'str'},
    }

    def __init__(
        self,
        **kwargs
    ):
        super(CpkInfo, self).__init__(**kwargs)
        self.encryption_key = kwargs.get('encryption_key', None)
        self.encryption_key_sha256 = kwargs.get('encryption_key_sha256', None)


class CpkScopeInfo(msrest.serialization.Model):
    """Parameter group.

    :param encryption_scope: Optional. Version 2019-07-07 and later.  Specifies the name of the
     encryption scope to use to encrypt the data provided in the request. If not specified,
     encryption is performed with the default account encryption scope.  For more information, see
     Encryption at Rest for Azure Storage Services.
    :type encryption_scope: str
    """

    _attribute_map = {
        'encryption_scope': {'key': 'encryptionScope', 'type': 'str'},
    }

    def __init__(
        self,
        **kwargs
    ):
        super(CpkScopeInfo, self).__init__(**kwargs)
        self.encryption_scope = kwargs.get('encryption_scope', None)


class DataLakeStorageError(msrest.serialization.Model):
    """DataLakeStorageError.

    :param data_lake_storage_error_details: The service error response object.
    :type data_lake_storage_error_details: ~azure.storage.blob.models.DataLakeStorageErrorDetails
    """

    _attribute_map = {
        'data_lake_storage_error_details': {'key': 'error', 'type': 'DataLakeStorageErrorDetails'},
    }

    def __init__(
        self,
        **kwargs
    ):
        super(DataLakeStorageError, self).__init__(**kwargs)
        self.data_lake_storage_error_details = kwargs.get('data_lake_storage_error_details', None)


class DataLakeStorageErrorDetails(msrest.serialization.Model):
    """The service error response object.

    :param code: The service error code.
    :type code: str
    :param message: The service error message.
    :type message: str
    """

    _attribute_map = {
        'code': {'key': 'Code', 'type': 'str'},
        'message': {'key': 'Message', 'type': 'str'},
    }

    def __init__(
        self,
        **kwargs
    ):
        super(DataLakeStorageErrorDetails, self).__init__(**kwargs)
        self.code = kwargs.get('code', None)
        self.message = kwargs.get('message', None)


class DelimitedTextConfiguration(msrest.serialization.Model):
    """delimited text configuration.

    All required parameters must be populated in order to send to Azure.

    :param column_separator: Required. column separator.
    :type column_separator: str
    :param field_quote: Required. field quote.
    :type field_quote: str
    :param record_separator: Required. record separator.
    :type record_separator: str
    :param escape_char: Required. escape char.
    :type escape_char: str
    :param headers_present: Required. has headers.
    :type headers_present: bool
    """

    _validation = {
        'column_separator': {'required': True},
        'field_quote': {'required': True},
        'record_separator': {'required': True},
        'escape_char': {'required': True},
        'headers_present': {'required': True},
    }

    _attribute_map = {
        'column_separator': {'key': 'ColumnSeparator', 'type': 'str', 'xml': {'name': 'ColumnSeparator'}},
        'field_quote': {'key': 'FieldQuote', 'type': 'str', 'xml': {'name': 'FieldQuote'}},
        'record_separator': {'key': 'RecordSeparator', 'type': 'str', 'xml': {'name': 'RecordSeparator'}},
        'escape_char': {'key': 'EscapeChar', 'type': 'str', 'xml': {'name': 'EscapeChar'}},
        'headers_present': {'key': 'HeadersPresent', 'type': 'bool', 'xml': {'name': 'HasHeaders'}},
    }
    _xml_map = {
        'name': 'DelimitedTextConfiguration'
    }

    def __init__(
        self,
        **kwargs
    ):
        super(DelimitedTextConfiguration, self).__init__(**kwargs)
        self.column_separator = kwargs['column_separator']
        self.field_quote = kwargs['field_quote']
        self.record_separator = kwargs['record_separator']
        self.escape_char = kwargs['escape_char']
        self.headers_present = kwargs['headers_present']


class DirectoryHttpHeaders(msrest.serialization.Model):
    """Parameter group.

    :param cache_control: Cache control for given resource.
    :type cache_control: str
    :param content_type: Content type for given resource.
    :type content_type: str
    :param content_encoding: Content encoding for given resource.
    :type content_encoding: str
    :param content_language: Content language for given resource.
    :type content_language: str
    :param content_disposition: Content disposition for given resource.
    :type content_disposition: str
    """

    _attribute_map = {
        'cache_control': {'key': 'cacheControl', 'type': 'str'},
        'content_type': {'key': 'contentType', 'type': 'str'},
        'content_encoding': {'key': 'contentEncoding', 'type': 'str'},
        'content_language': {'key': 'contentLanguage', 'type': 'str'},
        'content_disposition': {'key': 'contentDisposition', 'type': 'str'},
    }

    def __init__(
        self,
        **kwargs
    ):
        super(DirectoryHttpHeaders, self).__init__(**kwargs)
        self.cache_control = kwargs.get('cache_control', None)
        self.content_type = kwargs.get('content_type', None)
        self.content_encoding = kwargs.get('content_encoding', None)
        self.content_language = kwargs.get('content_language', None)
        self.content_disposition = kwargs.get('content_disposition', None)


class FilterBlobItem(msrest.serialization.Model):
    """Blob info from a Filter Blobs API call.

    All required parameters must be populated in order to send to Azure.

    :param name: Required.
    :type name: str
    :param container_name: Required.
    :type container_name: str
    :param tags: A set of tags. Blob tags.
    :type tags: ~azure.storage.blob.models.BlobTags
    """

    _validation = {
        'name': {'required': True},
        'container_name': {'required': True},
    }

    _attribute_map = {
        'name': {'key': 'Name', 'type': 'str'},
        'container_name': {'key': 'ContainerName', 'type': 'str'},
        'tags': {'key': 'Tags', 'type': 'BlobTags'},
    }
    _xml_map = {
        'name': 'Blob'
    }

    def __init__(
        self,
        **kwargs
    ):
        super(FilterBlobItem, self).__init__(**kwargs)
        self.name = kwargs['name']
        self.container_name = kwargs['container_name']
        self.tags = kwargs.get('tags', None)


class FilterBlobSegment(msrest.serialization.Model):
    """The result of a Filter Blobs API call.

    All required parameters must be populated in order to send to Azure.

    :param service_endpoint: Required.
    :type service_endpoint: str
    :param where: Required.
    :type where: str
    :param blobs: Required.
    :type blobs: list[~azure.storage.blob.models.FilterBlobItem]
    :param next_marker:
    :type next_marker: str
    """

    _validation = {
        'service_endpoint': {'required': True},
        'where': {'required': True},
        'blobs': {'required': True},
    }

    _attribute_map = {
        'service_endpoint': {'key': 'ServiceEndpoint', 'type': 'str', 'xml': {'attr': True}},
        'where': {'key': 'Where', 'type': 'str'},
        'blobs': {'key': 'Blobs', 'type': '[FilterBlobItem]', 'xml': {'name': 'Blobs', 'wrapped': True, 'itemsName': 'Blob'}},
        'next_marker': {'key': 'NextMarker', 'type': 'str'},
    }
    _xml_map = {
        'name': 'EnumerationResults'
    }

    def __init__(
        self,
        **kwargs
    ):
        super(FilterBlobSegment, self).__init__(**kwargs)
        self.service_endpoint = kwargs['service_endpoint']
        self.where = kwargs['where']
        self.blobs = kwargs['blobs']
        self.next_marker = kwargs.get('next_marker', None)


class GeoReplication(msrest.serialization.Model):
    """Geo-Replication information for the Secondary Storage Service.

    All required parameters must be populated in order to send to Azure.

    :param status: Required. The status of the secondary location. Possible values include: "live",
     "bootstrap", "unavailable".
    :type status: str or ~azure.storage.blob.models.GeoReplicationStatusType
    :param last_sync_time: Required. A GMT date/time value, to the second. All primary writes
     preceding this value are guaranteed to be available for read operations at the secondary.
     Primary writes after this point in time may or may not be available for reads.
    :type last_sync_time: ~datetime.datetime
    """

    _validation = {
        'status': {'required': True},
        'last_sync_time': {'required': True},
    }

    _attribute_map = {
        'status': {'key': 'Status', 'type': 'str'},
        'last_sync_time': {'key': 'LastSyncTime', 'type': 'rfc-1123'},
    }

    def __init__(
        self,
        **kwargs
    ):
        super(GeoReplication, self).__init__(**kwargs)
        self.status = kwargs['status']
        self.last_sync_time = kwargs['last_sync_time']


class JsonTextConfiguration(msrest.serialization.Model):
    """json text configuration.

    All required parameters must be populated in order to send to Azure.

    :param record_separator: Required. record separator.
    :type record_separator: str
    """

    _validation = {
        'record_separator': {'required': True},
    }

    _attribute_map = {
        'record_separator': {'key': 'RecordSeparator', 'type': 'str', 'xml': {'name': 'RecordSeparator'}},
    }
    _xml_map = {
        'name': 'JsonTextConfiguration'
    }

    def __init__(
        self,
        **kwargs
    ):
        super(JsonTextConfiguration, self).__init__(**kwargs)
        self.record_separator = kwargs['record_separator']


class KeyInfo(msrest.serialization.Model):
    """Key information.

    All required parameters must be populated in order to send to Azure.

    :param start: Required. The date-time the key is active in ISO 8601 UTC time.
    :type start: str
    :param expiry: Required. The date-time the key expires in ISO 8601 UTC time.
    :type expiry: str
    """

    _validation = {
        'start': {'required': True},
        'expiry': {'required': True},
    }

    _attribute_map = {
        'start': {'key': 'Start', 'type': 'str'},
        'expiry': {'key': 'Expiry', 'type': 'str'},
    }

    def __init__(
        self,
        **kwargs
    ):
        super(KeyInfo, self).__init__(**kwargs)
        self.start = kwargs['start']
        self.expiry = kwargs['expiry']


class LeaseAccessConditions(msrest.serialization.Model):
    """Parameter group.

    :param lease_id: If specified, the operation only succeeds if the resource's lease is active
     and matches this ID.
    :type lease_id: str
    """

    _attribute_map = {
        'lease_id': {'key': 'leaseId', 'type': 'str'},
    }

    def __init__(
        self,
        **kwargs
    ):
        super(LeaseAccessConditions, self).__init__(**kwargs)
        self.lease_id = kwargs.get('lease_id', None)


class ListBlobsFlatSegmentResponse(msrest.serialization.Model):
    """An enumeration of blobs.

    All required parameters must be populated in order to send to Azure.

    :param service_endpoint: Required.
    :type service_endpoint: str
    :param container_name: Required.
    :type container_name: str
    :param prefix:
    :type prefix: str
    :param marker:
    :type marker: str
    :param max_results:
    :type max_results: int
    :param segment: Required.
    :type segment: ~azure.storage.blob.models.BlobFlatListSegment
    :param next_marker:
    :type next_marker: str
    """

    _validation = {
        'service_endpoint': {'required': True},
        'container_name': {'required': True},
        'segment': {'required': True},
    }

    _attribute_map = {
        'service_endpoint': {'key': 'ServiceEndpoint', 'type': 'str', 'xml': {'attr': True}},
        'container_name': {'key': 'ContainerName', 'type': 'str', 'xml': {'attr': True}},
        'prefix': {'key': 'Prefix', 'type': 'str'},
        'marker': {'key': 'Marker', 'type': 'str'},
        'max_results': {'key': 'MaxResults', 'type': 'int'},
        'segment': {'key': 'Segment', 'type': 'BlobFlatListSegment'},
        'next_marker': {'key': 'NextMarker', 'type': 'str'},
    }
    _xml_map = {
        'name': 'EnumerationResults'
    }

    def __init__(
        self,
        **kwargs
    ):
        super(ListBlobsFlatSegmentResponse, self).__init__(**kwargs)
        self.service_endpoint = kwargs['service_endpoint']
        self.container_name = kwargs['container_name']
        self.prefix = kwargs.get('prefix', None)
        self.marker = kwargs.get('marker', None)
        self.max_results = kwargs.get('max_results', None)
        self.segment = kwargs['segment']
        self.next_marker = kwargs.get('next_marker', None)


class ListBlobsHierarchySegmentResponse(msrest.serialization.Model):
    """An enumeration of blobs.

    All required parameters must be populated in order to send to Azure.

    :param service_endpoint: Required.
    :type service_endpoint: str
    :param container_name: Required.
    :type container_name: str
    :param prefix:
    :type prefix: str
    :param marker:
    :type marker: str
    :param max_results:
    :type max_results: int
    :param delimiter:
    :type delimiter: str
    :param segment: Required.
    :type segment: ~azure.storage.blob.models.BlobHierarchyListSegment
    :param next_marker:
    :type next_marker: str
    """

    _validation = {
        'service_endpoint': {'required': True},
        'container_name': {'required': True},
        'segment': {'required': True},
    }

    _attribute_map = {
        'service_endpoint': {'key': 'ServiceEndpoint', 'type': 'str', 'xml': {'attr': True}},
        'container_name': {'key': 'ContainerName', 'type': 'str', 'xml': {'attr': True}},
        'prefix': {'key': 'Prefix', 'type': 'str'},
        'marker': {'key': 'Marker', 'type': 'str'},
        'max_results': {'key': 'MaxResults', 'type': 'int'},
        'delimiter': {'key': 'Delimiter', 'type': 'str'},
        'segment': {'key': 'Segment', 'type': 'BlobHierarchyListSegment'},
        'next_marker': {'key': 'NextMarker', 'type': 'str'},
    }
    _xml_map = {
        'name': 'EnumerationResults'
    }

    def __init__(
        self,
        **kwargs
    ):
        super(ListBlobsHierarchySegmentResponse, self).__init__(**kwargs)
        self.service_endpoint = kwargs['service_endpoint']
        self.container_name = kwargs['container_name']
        self.prefix = kwargs.get('prefix', None)
        self.marker = kwargs.get('marker', None)
        self.max_results = kwargs.get('max_results', None)
        self.delimiter = kwargs.get('delimiter', None)
        self.segment = kwargs['segment']
        self.next_marker = kwargs.get('next_marker', None)


class ListContainersSegmentResponse(msrest.serialization.Model):
    """An enumeration of containers.

    All required parameters must be populated in order to send to Azure.

    :param service_endpoint: Required.
    :type service_endpoint: str
    :param prefix:
    :type prefix: str
    :param marker:
    :type marker: str
    :param max_results:
    :type max_results: int
    :param container_items: Required.
    :type container_items: list[~azure.storage.blob.models.ContainerItem]
    :param next_marker:
    :type next_marker: str
    """

    _validation = {
        'service_endpoint': {'required': True},
        'container_items': {'required': True},
    }

    _attribute_map = {
        'service_endpoint': {'key': 'ServiceEndpoint', 'type': 'str', 'xml': {'attr': True}},
        'prefix': {'key': 'Prefix', 'type': 'str'},
        'marker': {'key': 'Marker', 'type': 'str'},
        'max_results': {'key': 'MaxResults', 'type': 'int'},
        'container_items': {'key': 'ContainerItems', 'type': '[ContainerItem]', 'xml': {'name': 'Containers', 'wrapped': True, 'itemsName': 'Container'}},
        'next_marker': {'key': 'NextMarker', 'type': 'str'},
    }
    _xml_map = {
        'name': 'EnumerationResults'
    }

    def __init__(
        self,
        **kwargs
    ):
        super(ListContainersSegmentResponse, self).__init__(**kwargs)
        self.service_endpoint = kwargs['service_endpoint']
        self.prefix = kwargs.get('prefix', None)
        self.marker = kwargs.get('marker', None)
        self.max_results = kwargs.get('max_results', None)
        self.container_items = kwargs['container_items']
        self.next_marker = kwargs.get('next_marker', None)


class Logging(msrest.serialization.Model):
    """Azure Analytics Logging settings.

    All required parameters must be populated in order to send to Azure.

    :param version: Required. The version of Storage Analytics to configure.
    :type version: str
    :param delete: Required. Indicates whether all delete requests should be logged.
    :type delete: bool
    :param read: Required. Indicates whether all read requests should be logged.
    :type read: bool
    :param write: Required. Indicates whether all write requests should be logged.
    :type write: bool
    :param retention_policy: Required. the retention policy which determines how long the
     associated data should persist.
    :type retention_policy: ~azure.storage.blob.models.RetentionPolicy
    """

    _validation = {
        'version': {'required': True},
        'delete': {'required': True},
        'read': {'required': True},
        'write': {'required': True},
        'retention_policy': {'required': True},
    }

    _attribute_map = {
        'version': {'key': 'Version', 'type': 'str'},
        'delete': {'key': 'Delete', 'type': 'bool'},
        'read': {'key': 'Read', 'type': 'bool'},
        'write': {'key': 'Write', 'type': 'bool'},
        'retention_policy': {'key': 'RetentionPolicy', 'type': 'RetentionPolicy'},
    }

    def __init__(
        self,
        **kwargs
    ):
        super(Logging, self).__init__(**kwargs)
        self.version = kwargs['version']
        self.delete = kwargs['delete']
        self.read = kwargs['read']
        self.write = kwargs['write']
        self.retention_policy = kwargs['retention_policy']


class Metrics(msrest.serialization.Model):
    """a summary of request statistics grouped by API in hour or minute aggregates for blobs.

    All required parameters must be populated in order to send to Azure.

    :param version: The version of Storage Analytics to configure.
    :type version: str
    :param enabled: Required. Indicates whether metrics are enabled for the Blob service.
    :type enabled: bool
    :param include_apis: Indicates whether metrics should generate summary statistics for called
     API operations.
    :type include_apis: bool
    :param retention_policy: the retention policy which determines how long the associated data
     should persist.
    :type retention_policy: ~azure.storage.blob.models.RetentionPolicy
    """

    _validation = {
        'enabled': {'required': True},
    }

    _attribute_map = {
        'version': {'key': 'Version', 'type': 'str'},
        'enabled': {'key': 'Enabled', 'type': 'bool'},
        'include_apis': {'key': 'IncludeAPIs', 'type': 'bool'},
        'retention_policy': {'key': 'RetentionPolicy', 'type': 'RetentionPolicy'},
    }

    def __init__(
        self,
        **kwargs
    ):
        super(Metrics, self).__init__(**kwargs)
        self.version = kwargs.get('version', None)
        self.enabled = kwargs['enabled']
        self.include_apis = kwargs.get('include_apis', None)
        self.retention_policy = kwargs.get('retention_policy', None)


class ModifiedAccessConditions(msrest.serialization.Model):
    """Parameter group.

    :param if_modified_since: Specify this header value to operate only on a blob if it has been
     modified since the specified date/time.
    :type if_modified_since: ~datetime.datetime
    :param if_unmodified_since: Specify this header value to operate only on a blob if it has not
     been modified since the specified date/time.
    :type if_unmodified_since: ~datetime.datetime
    :param if_match: Specify an ETag value to operate only on blobs with a matching value.
    :type if_match: str
    :param if_none_match: Specify an ETag value to operate only on blobs without a matching value.
    :type if_none_match: str
    :param if_tags: Specify a SQL where clause on blob tags to operate only on blobs with a
     matching value.
    :type if_tags: str
    """

    _attribute_map = {
        'if_modified_since': {'key': 'ifModifiedSince', 'type': 'rfc-1123'},
        'if_unmodified_since': {'key': 'ifUnmodifiedSince', 'type': 'rfc-1123'},
        'if_match': {'key': 'ifMatch', 'type': 'str'},
        'if_none_match': {'key': 'ifNoneMatch', 'type': 'str'},
        'if_tags': {'key': 'ifTags', 'type': 'str'},
    }

    def __init__(
        self,
        **kwargs
    ):
        super(ModifiedAccessConditions, self).__init__(**kwargs)
        self.if_modified_since = kwargs.get('if_modified_since', None)
        self.if_unmodified_since = kwargs.get('if_unmodified_since', None)
        self.if_match = kwargs.get('if_match', None)
        self.if_none_match = kwargs.get('if_none_match', None)
        self.if_tags = kwargs.get('if_tags', None)


class PageList(msrest.serialization.Model):
    """the list of pages.

    :param page_range:
    :type page_range: list[~azure.storage.blob.models.PageRange]
    :param clear_range:
    :type clear_range: list[~azure.storage.blob.models.ClearRange]
    """

    _attribute_map = {
        'page_range': {'key': 'PageRange', 'type': '[PageRange]'},
        'clear_range': {'key': 'ClearRange', 'type': '[ClearRange]'},
    }

    def __init__(
        self,
        **kwargs
    ):
        super(PageList, self).__init__(**kwargs)
        self.page_range = kwargs.get('page_range', None)
        self.clear_range = kwargs.get('clear_range', None)


class PageRange(msrest.serialization.Model):
    """PageRange.

    All required parameters must be populated in order to send to Azure.

    :param start: Required.
    :type start: long
    :param end: Required.
    :type end: long
    """

    _validation = {
        'start': {'required': True},
        'end': {'required': True},
    }

    _attribute_map = {
        'start': {'key': 'Start', 'type': 'long', 'xml': {'name': 'Start'}},
        'end': {'key': 'End', 'type': 'long', 'xml': {'name': 'End'}},
    }
    _xml_map = {
        'name': 'PageRange'
    }

    def __init__(
        self,
        **kwargs
    ):
        super(PageRange, self).__init__(**kwargs)
        self.start = kwargs['start']
        self.end = kwargs['end']


class QueryFormat(msrest.serialization.Model):
    """QueryFormat.

    :param type: The quick query format type. Possible values include: "delimited", "json",
     "arrow".
    :type type: str or ~azure.storage.blob.models.QueryFormatType
    :param delimited_text_configuration: delimited text configuration.
    :type delimited_text_configuration: ~azure.storage.blob.models.DelimitedTextConfiguration
    :param json_text_configuration: json text configuration.
    :type json_text_configuration: ~azure.storage.blob.models.JsonTextConfiguration
    :param arrow_configuration: arrow configuration.
    :type arrow_configuration: ~azure.storage.blob.models.ArrowConfiguration
    """

    _attribute_map = {
        'type': {'key': 'Type', 'type': 'str', 'xml': {'name': 'Type'}},
        'delimited_text_configuration': {'key': 'DelimitedTextConfiguration', 'type': 'DelimitedTextConfiguration'},
        'json_text_configuration': {'key': 'JsonTextConfiguration', 'type': 'JsonTextConfiguration'},
        'arrow_configuration': {'key': 'ArrowConfiguration', 'type': 'ArrowConfiguration'},
    }

    def __init__(
        self,
        **kwargs
    ):
        super(QueryFormat, self).__init__(**kwargs)
        self.type = kwargs.get('type', None)
        self.delimited_text_configuration = kwargs.get('delimited_text_configuration', None)
        self.json_text_configuration = kwargs.get('json_text_configuration', None)
        self.arrow_configuration = kwargs.get('arrow_configuration', None)


class QueryRequest(msrest.serialization.Model):
    """the quick query body.

    Variables are only populated by the server, and will be ignored when sending a request.

    All required parameters must be populated in order to send to Azure.

    :ivar query_type: Required. the query type. Default value: "SQL".
    :vartype query_type: str
    :param expression: Required. a query statement.
    :type expression: str
    :param input_serialization:
    :type input_serialization: ~azure.storage.blob.models.QuerySerialization
    :param output_serialization:
    :type output_serialization: ~azure.storage.blob.models.QuerySerialization
    """

    _validation = {
        'query_type': {'required': True, 'constant': True},
        'expression': {'required': True},
    }

    _attribute_map = {
        'query_type': {'key': 'QueryType', 'type': 'str', 'xml': {'name': 'QueryType'}},
        'expression': {'key': 'Expression', 'type': 'str', 'xml': {'name': 'Expression'}},
        'input_serialization': {'key': 'InputSerialization', 'type': 'QuerySerialization'},
        'output_serialization': {'key': 'OutputSerialization', 'type': 'QuerySerialization'},
    }
    _xml_map = {
        'name': 'QueryRequest'
    }

    query_type = "SQL"

    def __init__(
        self,
        **kwargs
    ):
        super(QueryRequest, self).__init__(**kwargs)
        self.expression = kwargs['expression']
        self.input_serialization = kwargs.get('input_serialization', None)
        self.output_serialization = kwargs.get('output_serialization', None)


class QuerySerialization(msrest.serialization.Model):
    """QuerySerialization.

    All required parameters must be populated in order to send to Azure.

    :param format: Required.
    :type format: ~azure.storage.blob.models.QueryFormat
    """

    _validation = {
        'format': {'required': True},
    }

    _attribute_map = {
        'format': {'key': 'Format', 'type': 'QueryFormat'},
    }

    def __init__(
        self,
        **kwargs
    ):
        super(QuerySerialization, self).__init__(**kwargs)
        self.format = kwargs['format']


class RetentionPolicy(msrest.serialization.Model):
    """the retention policy which determines how long the associated data should persist.

    All required parameters must be populated in order to send to Azure.

    :param enabled: Required. Indicates whether a retention policy is enabled for the storage
     service.
    :type enabled: bool
    :param days: Indicates the number of days that metrics or logging or soft-deleted data should
     be retained. All data older than this value will be deleted.
    :type days: int
    :param allow_permanent_delete: Indicates whether permanent delete is allowed on this storage
     account.
    :type allow_permanent_delete: bool
    """

    _validation = {
        'enabled': {'required': True},
        'days': {'minimum': 1},
    }

    _attribute_map = {
        'enabled': {'key': 'Enabled', 'type': 'bool'},
        'days': {'key': 'Days', 'type': 'int'},
        'allow_permanent_delete': {'key': 'AllowPermanentDelete', 'type': 'bool'},
    }

    def __init__(
        self,
        **kwargs
    ):
        super(RetentionPolicy, self).__init__(**kwargs)
        self.enabled = kwargs['enabled']
        self.days = kwargs.get('days', None)
        self.allow_permanent_delete = kwargs.get('allow_permanent_delete', None)


class SequenceNumberAccessConditions(msrest.serialization.Model):
    """Parameter group.

    :param if_sequence_number_less_than_or_equal_to: Specify this header value to operate only on a
     blob if it has a sequence number less than or equal to the specified.
    :type if_sequence_number_less_than_or_equal_to: long
    :param if_sequence_number_less_than: Specify this header value to operate only on a blob if it
     has a sequence number less than the specified.
    :type if_sequence_number_less_than: long
    :param if_sequence_number_equal_to: Specify this header value to operate only on a blob if it
     has the specified sequence number.
    :type if_sequence_number_equal_to: long
    """

    _attribute_map = {
        'if_sequence_number_less_than_or_equal_to': {'key': 'ifSequenceNumberLessThanOrEqualTo', 'type': 'long'},
        'if_sequence_number_less_than': {'key': 'ifSequenceNumberLessThan', 'type': 'long'},
        'if_sequence_number_equal_to': {'key': 'ifSequenceNumberEqualTo', 'type': 'long'},
    }

    def __init__(
        self,
        **kwargs
    ):
        super(SequenceNumberAccessConditions, self).__init__(**kwargs)
        self.if_sequence_number_less_than_or_equal_to = kwargs.get('if_sequence_number_less_than_or_equal_to', None)
        self.if_sequence_number_less_than = kwargs.get('if_sequence_number_less_than', None)
        self.if_sequence_number_equal_to = kwargs.get('if_sequence_number_equal_to', None)


class SignedIdentifier(msrest.serialization.Model):
    """signed identifier.

    All required parameters must be populated in order to send to Azure.

    :param id: Required. a unique id.
    :type id: str
    :param access_policy: An Access policy.
    :type access_policy: ~azure.storage.blob.models.AccessPolicy
    """

    _validation = {
        'id': {'required': True},
    }

    _attribute_map = {
        'id': {'key': 'Id', 'type': 'str'},
        'access_policy': {'key': 'AccessPolicy', 'type': 'AccessPolicy'},
    }
    _xml_map = {
        'name': 'SignedIdentifier'
    }

    def __init__(
        self,
        **kwargs
    ):
        super(SignedIdentifier, self).__init__(**kwargs)
        self.id = kwargs['id']
        self.access_policy = kwargs.get('access_policy', None)


class SourceModifiedAccessConditions(msrest.serialization.Model):
    """Parameter group.

    :param source_if_modified_since: Specify this header value to operate only on a blob if it has
     been modified since the specified date/time.
    :type source_if_modified_since: ~datetime.datetime
    :param source_if_unmodified_since: Specify this header value to operate only on a blob if it
     has not been modified since the specified date/time.
    :type source_if_unmodified_since: ~datetime.datetime
    :param source_if_match: Specify an ETag value to operate only on blobs with a matching value.
    :type source_if_match: str
    :param source_if_none_match: Specify an ETag value to operate only on blobs without a matching
     value.
    :type source_if_none_match: str
    :param source_if_tags: Specify a SQL where clause on blob tags to operate only on blobs with a
     matching value.
    :type source_if_tags: str
    """

    _attribute_map = {
        'source_if_modified_since': {'key': 'sourceIfModifiedSince', 'type': 'rfc-1123'},
        'source_if_unmodified_since': {'key': 'sourceIfUnmodifiedSince', 'type': 'rfc-1123'},
        'source_if_match': {'key': 'sourceIfMatch', 'type': 'str'},
        'source_if_none_match': {'key': 'sourceIfNoneMatch', 'type': 'str'},
        'source_if_tags': {'key': 'sourceIfTags', 'type': 'str'},
    }

    def __init__(
        self,
        **kwargs
    ):
        super(SourceModifiedAccessConditions, self).__init__(**kwargs)
        self.source_if_modified_since = kwargs.get('source_if_modified_since', None)
        self.source_if_unmodified_since = kwargs.get('source_if_unmodified_since', None)
        self.source_if_match = kwargs.get('source_if_match', None)
        self.source_if_none_match = kwargs.get('source_if_none_match', None)
        self.source_if_tags = kwargs.get('source_if_tags', None)


class StaticWebsite(msrest.serialization.Model):
    """The properties that enable an account to host a static website.

    All required parameters must be populated in order to send to Azure.

    :param enabled: Required. Indicates whether this account is hosting a static website.
    :type enabled: bool
    :param index_document: The default name of the index page under each directory.
    :type index_document: str
    :param error_document404_path: The absolute path of the custom 404 page.
    :type error_document404_path: str
    :param default_index_document_path: Absolute path of the default index page.
    :type default_index_document_path: str
    """

    _validation = {
        'enabled': {'required': True},
    }

    _attribute_map = {
        'enabled': {'key': 'Enabled', 'type': 'bool'},
        'index_document': {'key': 'IndexDocument', 'type': 'str'},
        'error_document404_path': {'key': 'ErrorDocument404Path', 'type': 'str'},
        'default_index_document_path': {'key': 'DefaultIndexDocumentPath', 'type': 'str'},
    }

    def __init__(
        self,
        **kwargs
    ):
        super(StaticWebsite, self).__init__(**kwargs)
        self.enabled = kwargs['enabled']
        self.index_document = kwargs.get('index_document', None)
        self.error_document404_path = kwargs.get('error_document404_path', None)
        self.default_index_document_path = kwargs.get('default_index_document_path', None)


class StorageError(msrest.serialization.Model):
    """StorageError.

    :param message:
    :type message: str
    """

    _attribute_map = {
        'message': {'key': 'Message', 'type': 'str'},
    }

    def __init__(
        self,
        **kwargs
    ):
        super(StorageError, self).__init__(**kwargs)
        self.message = kwargs.get('message', None)


class StorageServiceProperties(msrest.serialization.Model):
    """Storage Service Properties.

    :param logging: Azure Analytics Logging settings.
    :type logging: ~azure.storage.blob.models.Logging
    :param hour_metrics: a summary of request statistics grouped by API in hour or minute
     aggregates for blobs.
    :type hour_metrics: ~azure.storage.blob.models.Metrics
    :param minute_metrics: a summary of request statistics grouped by API in hour or minute
     aggregates for blobs.
    :type minute_metrics: ~azure.storage.blob.models.Metrics
    :param cors: The set of CORS rules.
    :type cors: list[~azure.storage.blob.models.CorsRule]
    :param default_service_version: The default version to use for requests to the Blob service if
     an incoming request's version is not specified. Possible values include version 2008-10-27 and
     all more recent versions.
    :type default_service_version: str
    :param delete_retention_policy: the retention policy which determines how long the associated
     data should persist.
    :type delete_retention_policy: ~azure.storage.blob.models.RetentionPolicy
    :param static_website: The properties that enable an account to host a static website.
    :type static_website: ~azure.storage.blob.models.StaticWebsite
    """

    _attribute_map = {
        'logging': {'key': 'Logging', 'type': 'Logging'},
        'hour_metrics': {'key': 'HourMetrics', 'type': 'Metrics'},
        'minute_metrics': {'key': 'MinuteMetrics', 'type': 'Metrics'},
        'cors': {'key': 'Cors', 'type': '[CorsRule]', 'xml': {'wrapped': True}},
        'default_service_version': {'key': 'DefaultServiceVersion', 'type': 'str'},
        'delete_retention_policy': {'key': 'DeleteRetentionPolicy', 'type': 'RetentionPolicy'},
        'static_website': {'key': 'StaticWebsite', 'type': 'StaticWebsite'},
    }

    def __init__(
        self,
        **kwargs
    ):
        super(StorageServiceProperties, self).__init__(**kwargs)
        self.logging = kwargs.get('logging', None)
        self.hour_metrics = kwargs.get('hour_metrics', None)
        self.minute_metrics = kwargs.get('minute_metrics', None)
        self.cors = kwargs.get('cors', None)
        self.default_service_version = kwargs.get('default_service_version', None)
        self.delete_retention_policy = kwargs.get('delete_retention_policy', None)
        self.static_website = kwargs.get('static_website', None)


class StorageServiceStats(msrest.serialization.Model):
    """Stats for the storage service.

    :param geo_replication: Geo-Replication information for the Secondary Storage Service.
    :type geo_replication: ~azure.storage.blob.models.GeoReplication
    """

    _attribute_map = {
        'geo_replication': {'key': 'GeoReplication', 'type': 'GeoReplication'},
    }

    def __init__(
        self,
        **kwargs
    ):
        super(StorageServiceStats, self).__init__(**kwargs)
        self.geo_replication = kwargs.get('geo_replication', None)


class UserDelegationKey(msrest.serialization.Model):
    """A user delegation key.

    All required parameters must be populated in order to send to Azure.

    :param signed_oid: Required. The Azure Active Directory object ID in GUID format.
    :type signed_oid: str
    :param signed_tid: Required. The Azure Active Directory tenant ID in GUID format.
    :type signed_tid: str
    :param signed_start: Required. The date-time the key is active.
    :type signed_start: ~datetime.datetime
    :param signed_expiry: Required. The date-time the key expires.
    :type signed_expiry: ~datetime.datetime
    :param signed_service: Required. Abbreviation of the Azure Storage service that accepts the
     key.
    :type signed_service: str
    :param signed_version: Required. The service version that created the key.
    :type signed_version: str
    :param value: Required. The key as a base64 string.
    :type value: str
    """

    _validation = {
        'signed_oid': {'required': True},
        'signed_tid': {'required': True},
        'signed_start': {'required': True},
        'signed_expiry': {'required': True},
        'signed_service': {'required': True},
        'signed_version': {'required': True},
        'value': {'required': True},
    }

    _attribute_map = {
        'signed_oid': {'key': 'SignedOid', 'type': 'str'},
        'signed_tid': {'key': 'SignedTid', 'type': 'str'},
        'signed_start': {'key': 'SignedStart', 'type': 'iso-8601'},
        'signed_expiry': {'key': 'SignedExpiry', 'type': 'iso-8601'},
        'signed_service': {'key': 'SignedService', 'type': 'str'},
        'signed_version': {'key': 'SignedVersion', 'type': 'str'},
        'value': {'key': 'Value', 'type': 'str'},
    }

    def __init__(
        self,
        **kwargs
    ):
        super(UserDelegationKey, self).__init__(**kwargs)
        self.signed_oid = kwargs['signed_oid']
        self.signed_tid = kwargs['signed_tid']
        self.signed_start = kwargs['signed_start']
        self.signed_expiry = kwargs['signed_expiry']
        self.signed_service = kwargs['signed_service']
        self.signed_version = kwargs['signed_version']
        self.value = kwargs['value']
