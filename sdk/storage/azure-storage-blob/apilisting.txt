class AccessPolicy(Model, object):
	permission:permission
	expiry:expiry
	start:start

	def __eq__(self, other): ...
	def __init__(self, permission: permission=None, expiry: expiry=None, start: start=None): ...
	def __ne__(self, other): ...
	def __str__(self): ...
	def as_dict(self, keep_readonly=True, key_transformer: function=<function attribute_transformer at 0x10e6a4510>) -> dict: ...
	@classmethod
	def deserialize(cls, data: str, content_type: str=None): ...
	@classmethod
	def enable_additional_properties_sending(cls): ...
	@classmethod
	def from_dict(cls, data: dict, key_extractors=None, content_type: str=None): ...
	@classmethod
	def is_xml_model(cls): ...
	def serialize(self, keep_readonly: bool=False) -> dict: ...
	def validate(self) -> list: ...

class AccountPermissions(object):
	AccountPermissions.ADD:AccountPermissions
	AccountPermissions.CREATE:AccountPermissions
	AccountPermissions.DELETE:AccountPermissions
	AccountPermissions.LIST:AccountPermissions
	AccountPermissions.PROCESS:AccountPermissions
	AccountPermissions.READ:AccountPermissions
	AccountPermissions.UPDATE:AccountPermissions
	AccountPermissions.WRITE:AccountPermissions
	read:bool
	write:bool
	delete:bool
	list:bool
	add:bool
	create:bool
	update:bool
	process:bool
	_str:str

	def __add__(self, other): ...
	def __init__(self, read: bool=False, write: bool=False, delete: bool=False, list: bool=False, add: bool=False, create: bool=False, update: bool=False, process: bool=False, _str: str=None, *, AccountPermissions.ADD, AccountPermissions.CREATE, AccountPermissions.DELETE, AccountPermissions.LIST, AccountPermissions.PROCESS, AccountPermissions.READ, AccountPermissions.UPDATE, AccountPermissions.WRITE): ...
	def __or__(self, other): ...
	def __str__(self): ...

class BlobBlock(DictMixin, object):
	block_id:str
	state:str
	size:int

	def __init__(self, block_id: str=None, state: str=Latest, *, size): ...
	def __str__(self): ...
	def get(self, key, default=None): ...
	def has_key(self, k): ...
	def items(self): ...
	def keys(self): ...
	def update(self, *args, **kwargs): ...
	def values(self): ...

class BlobClient(AsyncStorageAccountHostsMixin, StorageAccountHostsMixin, object):
	url:str
	primary_endpoint:str
	primary_hostname:str
	secondary_endpoint:str
	secondary_hostname:str
	location_mode:str
	blob_url:str
	container:container
	blob:blob
	snapshot:str
	credential

	def __aenter__(self): ...
	def __aexit__(self, *args): ...
	def __enter__(self): ...
	def __exit__(self, *args): ...
	def __init__(self, blob_url: str, container: container=None, blob: blob=None, snapshot: str=None, credential=None, loop=None, *, url, primary_endpoint, primary_hostname, secondary_endpoint, secondary_hostname, location_mode, **kwargs): ...
	def abort_copy(self, copy_id: copy_id, **kwargs) -> None: ...
	def acquire_lease(self, lease_duration: int=-1, lease_id: str=None, *, if_modified_since, if_unmodified_since, if_match, if_none_match, timeout, **kwargs) -> ~azure.storage.blob.aio.lease_async.LeaseClient: ...
	def append_block(self, data, length: int=None, validate_content: bool=False, maxsize_condition: int=None, appendpos_condition: int=None, *, lease, if_modified_since, if_unmodified_since, if_match, if_none_match, encoding, cpk, timeout, **kwargs) -> dict(str, Any): ...
	def append_block_from_url(self, copy_source_url: str, source_range_start: int=None, source_range_end: int=None, source_content_md5: bytearray=None, maxsize_condition: int=None, appendpos_condition: int=None, *, lease, if_modified_since, if_unmodified_since, if_match, if_none_match, source_if_modified_since, source_if_unmodified_since, source_if_match, source_if_none_match, cpk, timeout, **kwargs): ...
	def clear_page(self, start_range: int, end_range: int, *, lease, if_sequence_number_lte, if_sequence_number_lt, if_sequence_number_eq, if_modified_since, if_unmodified_since, if_match, if_none_match, premium_page_blob_tier, timeout, **kwargs) -> dict(str, Any): ...
	def commit_block_list(self, block_list: list, content_settings: ~azure.storage.blob.models.ContentSettings=None, metadata: metadata=None, validate_content: bool=False, *, lease, if_modified_since, if_unmodified_since, if_match, if_none_match, cpk, timeout, **kwargs) -> dict(str, Any): ...
	def create_append_blob(self, content_settings: ~azure.storage.blob.models.ContentSettings=None, metadata: metadata=None, *, lease, if_modified_since, if_unmodified_since, if_match, if_none_match, cpk, timeout, **kwargs) -> dict[str, Any]: ...
	def create_page_blob(self, size: int, content_settings: ~azure.storage.blob.models.ContentSettings=None, sequence_number: int=None, metadata: metadata=None, premium_page_blob_tier: ~azure.storage.blob.models.PremiumPageBlobTier=None, *, lease, if_modified_since, if_unmodified_since, if_match, if_none_match, cpk, timeout, **kwargs) -> dict[str, Any]: ...
	def create_snapshot(self, metadata: metadata=None, *, if_modified_since, if_unmodified_since, if_match, if_none_match, lease, cpk, timeout, **kwargs) -> dict[str, Any]: ...
	def delete_blob(self, delete_snapshots: str=False, *, lease, if_modified_since, if_unmodified_since, if_match, if_none_match, timeout, **kwargs) -> None: ...
	def download_blob(self, offset: int=None, length: int=None, validate_content: bool=False, *, lease, if_modified_since, if_unmodified_since, if_match, if_none_match, cpk, timeout, **kwargs) -> ~azure.storage.blob._blob_utils.StorageStreamDownloader: ...
	@classmethod
	def from_connection_string(cls, conn_str: str, container: container, blob: blob, snapshot: str=None, credential=None, **kwargs): ...
	def generate_shared_access_signature(self, permission: permission=None, expiry: expiry=None, start: start=None, policy_id: str=None, ip: str=None, protocol: str=None, account_name: str=None, cache_control: str=None, content_disposition: str=None, content_encoding: str=None, content_language: str=None, content_type: str=None, user_delegation_key: ~azure.storage.blob._shared.models.UserDelegationKey=None) -> str: ...
	def get_account_information(self, **kwargs) -> dict(str, str): ...
	def get_blob_properties(self, *, lease, if_modified_since, if_unmodified_since, if_match, if_none_match, cpk, timeout, **kwargs) -> ~azure.storage.blob.models.BlobProperties: ...
	def get_block_list(self, block_list_type: str=committed, *, lease, timeout, **kwargs) -> tuple(list(~azure.storage.blob.models.BlobBlock), list(~azure.storage.blob.models.BlobBlock)): ...
	def get_page_ranges(self, start_range: int=None, end_range: int=None, previous_snapshot_diff: str=None, *, lease, if_modified_since, if_unmodified_since, if_match, if_none_match, timeout, **kwargs) -> tuple(list(dict(str, str), list(dict(str, str)): ...
	def resize_blob(self, size: int, *, lease, if_modified_since, if_unmodified_since, if_match, if_none_match, premium_page_blob_tier, timeout, **kwargs) -> dict(str, Any): ...
	def set_blob_metadata(self, metadata: metadata=None, *, lease, if_modified_since, if_unmodified_since, if_match, if_none_match, cpk, timeout, **kwargs): ...
	def set_http_headers(self, content_settings: ~azure.storage.blob.models.ContentSettings=None, *, lease, if_modified_since, if_unmodified_since, if_match, if_none_match, timeout, **kwargs) -> Dict[str, Any]: ...
	def set_premium_page_blob_tier(self, premium_page_blob_tier: premium_page_blob_tier, *, timeout, lease, **kwargs) -> None: ...
	def set_sequence_number(self, sequence_number_action: str, sequence_number: str=None, *, lease, if_modified_since, if_unmodified_since, if_match, if_none_match, timeout, **kwargs) -> dict(str, Any): ...
	def set_standard_blob_tier(self, standard_blob_tier: standard_blob_tier, *, timeout, lease, **kwargs) -> None: ...
	def stage_block(self, block_id: str, data, length: int=None, validate_content: bool=False, *, lease, encoding, cpk, timeout, **kwargs) -> None: ...
	def stage_block_from_url(self, block_id: str, source_url, source_offset=None, source_length=None, source_content_md5: bytearray=None, *, lease, cpk, timeout, **kwargs) -> None: ...
	def start_copy_from_url(self, source_url: str, metadata: metadata=None, incremental_copy: bool=False, *, source_if_modified_since, source_if_unmodified_since, source_if_match, source_if_none_match, destination_if_modified_since, destination_if_unmodified_since, destination_if_match, destination_if_none_match, destination_lease, source_lease, timeout, premium_page_blob_tier, requires_sync, **kwargs) -> Dict[str, Union[str, datetime]]: ...
	def undelete_blob(self, *, timeout, **kwargs) -> None: ...
	def upload_blob(self, data, blob_type: ~azure.storage.blob.models.BlobType=BlockBlob, overwrite: bool=False, length: int=None, metadata: metadata=None, content_settings: ~azure.storage.blob.models.ContentSettings=None, validate_content: bool=False, max_connections: int=1, *, lease, if_modified_since, if_unmodified_since, if_match, if_none_match, premium_page_blob_tier, maxsize_condition, cpk, encoding, timeout, **kwargs) -> dict[str, Any]: ...
	def upload_page(self, page: bytes, start_range: int, end_range: int, length: int=None, validate_content: bool=False, *, lease, if_sequence_number_lte, if_sequence_number_lt, if_sequence_number_eq, if_modified_since, if_unmodified_since, if_match, if_none_match, cpk, encoding, timeout, **kwargs) -> dict(str, Any): ...
	def upload_pages_from_url(self, source_url: str, range_start: int, range_end: int, source_range_start: int, source_content_md5: bytes=None, *, source_if_modified_since, source_if_unmodified_since, source_if_match, source_if_none_match, lease, if_sequence_number_lte, if_sequence_number_lt, if_sequence_number_eq, if_modified_since, if_unmodified_since, if_match, if_none_match, cpk, timeout, **kwargs): ...

class BlobPermissions(object):
	BlobPermissions.ADD:BlobPermissions
	BlobPermissions.CREATE:BlobPermissions
	BlobPermissions.DELETE:BlobPermissions
	BlobPermissions.READ:BlobPermissions
	BlobPermissions.WRITE:BlobPermissions
	read:bool
	add:bool
	create:bool
	write:bool
	delete:bool
	_str:str

	def __add__(self, other): ...
	def __init__(self, read: bool=False, add: bool=False, create: bool=False, write: bool=False, delete: bool=False, _str: str=None, *, BlobPermissions.ADD, BlobPermissions.CREATE, BlobPermissions.DELETE, BlobPermissions.READ, BlobPermissions.WRITE): ...
	def __or__(self, other): ...
	def __str__(self): ...

class BlobPrefix(AsyncItemPaged, AsyncIterator, AsyncIterable, Generic, DictMixin, object):
	name:str
	prefix:str
	results_per_page:int
	marker:str
	location_mode:str
	current_page
	container:str
	delimiter:str
	command:callable

	def __aiter__(self): ...
	def __anext__(self, *, return): ...
	def __class_getitem__(cls, params): ...
	def __init__(self, *args, *, name, prefix, results_per_page, marker, location_mode, current_page, container, delimiter, command, **kwargs): ...
	def __init_subclass__(cls, *args, **kwargs): ...
	def __new__(cls, *args, **kwargs): ...
	def __str__(self): ...
	def by_page(self, continuation_token: typing.Union[str, NoneType]=None, *, return): ...
	def get(self, key, default=None): ...
	def has_key(self, k): ...
	def items(self): ...
	def keys(self): ...
	def update(self, *args, **kwargs): ...
	def values(self): ...

class BlobProperties(DictMixin, object):
	name:str
	container
	snapshot:str
	blob_type:~azure.blob.storage.models.BlobType
	metadata:dict
	last_modified:datetime
	etag:str
	size:int
	content_range:str
	append_blob_committed_block_count:int
	page_blob_sequence_number:int
	server_encrypted:bool
	copy:~azure.storage.blob.models.CopyProperties
	content_settings:~azure.storage.blob.models.ContentSettings
	lease:~azure.storage.blob.models.LeaseProperties
	blob_tier:~azure.storage.blob.models.StandardBlobTier
	blob_tier_change_time:datetime
	blob_tier_inferred:bool
	deleted:bool
	deleted_time:datetime
	remaining_retention_days:int
	creation_time:datetime
	archive_status:str

	def __init__(self, *, name, container, snapshot, blob_type, metadata, last_modified, etag, size, content_range, append_blob_committed_block_count, page_blob_sequence_number, server_encrypted, copy, content_settings, lease, blob_tier, blob_tier_change_time, blob_tier_inferred, deleted, deleted_time, remaining_retention_days, creation_time, archive_status, **kwargs): ...
	def __str__(self): ...
	def get(self, key, default=None): ...
	def has_key(self, k): ...
	def items(self): ...
	def keys(self): ...
	def update(self, *args, **kwargs): ...
	def values(self): ...

class BlobPropertiesPaged(AsyncPageIterator, AsyncIterator, AsyncIterable, Generic, object):
	service_endpoint:str
	prefix:str
	marker:str
	results_per_page:int
	location_mode:str
	current_page
	container:str
	delimiter:str
	command:callable
	continuation_token:str

	def __aiter__(self): ...
	def __anext__(self): ...
	def __class_getitem__(cls, params): ...
	def __init__(self, command: callable, container: str=None, prefix: str=None, results_per_page: int=None, continuation_token: str=None, delimiter: str=None, location_mode: str=None, *, service_endpoint, marker, current_page, get_next, extract_data): ...
	def __init_subclass__(cls, *args, **kwargs): ...
	def __new__(cls, *args, **kwargs): ...

class BlobServiceClient(AsyncStorageAccountHostsMixin, StorageAccountHostsMixin, object):
	url:str
	primary_endpoint:str
	primary_hostname:str
	secondary_endpoint:str
	secondary_hostname:str
	location_mode:str
	account_url:str
	credential

	def __aenter__(self): ...
	def __aexit__(self, *args): ...
	def __enter__(self): ...
	def __exit__(self, *args): ...
	def __init__(self, account_url: str, credential=None, loop=None, *, url, primary_endpoint, primary_hostname, secondary_endpoint, secondary_hostname, location_mode, **kwargs): ...
	def create_container(self, name: str, metadata: metadata=None, public_access: public_access=None, timeout: int=None, **kwargs) -> ~azure.storage.blob.aio.container_client_async.ContainerClient: ...
	def delete_container(self, container: container, lease: ~azure.storage.blob.lease.LeaseClient=None, timeout: int=None, *, if_modified_since, if_unmodified_since, if_match, if_none_match, **kwargs) -> None: ...
	@classmethod
	def from_connection_string(cls, conn_str: str, credential=None, **kwargs): ...
	def generate_shared_access_signature(self, resource_types: resource_types, permission: permission, expiry: expiry, start: start=None, ip: str=None, protocol: str=None) -> str: ...
	def get_account_information(self, **kwargs) -> dict(str, str): ...
	def get_blob_client(self, container: container, blob: blob, snapshot: snapshot=None) -> ~azure.storage.blob.aio.blob_client_async.BlobClient: ...
	def get_container_client(self, container: container) -> ~azure.core.blob.aio.container_client_async.ContainerClient: ...
	def get_service_properties(self, timeout: int=None, **kwargs) -> ~azure.storage.blob._generated.models.StorageServiceProperties: ...
	def get_service_stats(self, timeout: int=None, **kwargs) -> ~azure.storage.blob._generated.models.StorageServiceStats: ...
	def get_user_delegation_key(self, key_start_time: datetime, key_expiry_time: datetime, timeout: int=None, **kwargs) -> ~azure.storage.blob._shared.models.UserDelegationKey: ...
	def list_containers(self, name_starts_with: str=None, include_metadata: bool=False, results_per_page: int=None, timeout: int=None, **kwargs) -> ~azure.core.async_paging.AsyncItemPaged[~azure.storage.blob.models.ContainerProperties]: ...
	def set_service_properties(self, logging: logging=None, hour_metrics: hour_metrics=None, minute_metrics: minute_metrics=None, cors: cors=None, target_version: str=None, delete_retention_policy: delete_retention_policy=None, static_website: static_website=None, timeout: int=None, **kwargs) -> None: ...

class BlobType(str, Enum, object):
	...

class BlockState(str, Enum, object):
	...

class ContainerClient(AsyncStorageAccountHostsMixin, StorageAccountHostsMixin, object):
	url:str
	primary_endpoint:str
	primary_hostname:str
	secondary_endpoint:str
	secondary_hostname:str
	location_mode:str
	container_url:str
	container:container
	credential

	def __aenter__(self): ...
	def __aexit__(self, *args): ...
	def __enter__(self): ...
	def __exit__(self, *args): ...
	def __init__(self, container_url: str, container: container=None, credential=None, loop=None, *, url, primary_endpoint, primary_hostname, secondary_endpoint, secondary_hostname, location_mode, **kwargs): ...
	def acquire_lease(self, lease_duration: int=-1, lease_id: str=None, timeout: int=None, *, if_modified_since, if_unmodified_since, if_match, if_none_match, **kwargs) -> ~azure.storage.blob.aio.lease_async.LeaseClient: ...
	def create_container(self, metadata: metadata=None, public_access: ~azure.storage.blob.models.PublicAccess=None, timeout: int=None, **kwargs) -> None: ...
	def delete_blob(self, blob: blob, delete_snapshots: str=None, lease: lease=None, timeout: int=None, *, if_modified_since, if_unmodified_since, if_match, if_none_match, **kwargs) -> None: ...
	def delete_container(self, lease: ~azure.storage.blob.aio.lease_async.LeaseClient=None, timeout: int=None, *, if_modified_since, if_unmodified_since, if_match, if_none_match, **kwargs) -> None: ...
	@classmethod
	def from_connection_string(cls, conn_str: str, container: container, credential=None, **kwargs): ...
	def generate_shared_access_signature(self, permission: permission=None, expiry: expiry=None, start: start=None, policy_id: str=None, ip: str=None, protocol: str=None, account_name: str=None, cache_control: str=None, content_disposition: str=None, content_encoding: str=None, content_language: str=None, content_type: str=None, user_delegation_key: ~azure.storage.blob._shared.models.UserDelegationKey=None) -> str: ...
	def get_account_information(self, **kwargs) -> dict(str, str): ...
	def get_blob_client(self, blob: blob, snapshot: str=None) -> ~azure.storage.blob.aio.blob_client_async.BlobClient: ...
	def get_container_access_policy(self, lease: str=None, timeout: int=None, **kwargs) -> dict[str, str]: ...
	def get_container_properties(self, lease: ~azure.storage.blob.aio.lease_async.LeaseClient=None, timeout: int=None, **kwargs) -> ~azure.storage.blob.models.ContainerProperties: ...
	def list_blobs(self, name_starts_with: str=None, include: list[str]=None, timeout: int=None, **kwargs) -> ~azure.core.async_paging.AsyncItemPaged[~azure.storage.blob.models.BlobProperties]: ...
	def set_container_access_policy(self, signed_identifiers: signed_identifiers=None, public_access: ~azure.storage.blob.models.PublicAccess=None, lease: lease=None, timeout: int=None, *, if_modified_since, if_unmodified_since, **kwargs): ...
	def set_container_metadata(self, metadata: metadata=None, lease: str=None, timeout: int=None, *, if_modified_since, **kwargs): ...
	def upload_blob(self, name: name, data, blob_type: ~azure.storage.blob.models.BlobType=BlockBlob, overwrite: bool=False, length: int=None, metadata: metadata=None, content_settings: ~azure.storage.blob.models.ContentSettings=None, validate_content: bool=False, lease: lease=None, timeout: int=None, max_connections: int=1, encoding: str=UTF-8, *, if_modified_since, if_unmodified_since, if_match, if_none_match, premium_page_blob_tier, maxsize_condition, **kwargs) -> ~azure.storage.blob.aio.blob_client_async.BlobClient: ...
	def walk_blobs(self, name_starts_with: str=None, include: list[str]=None, delimiter: str=/, timeout: int=None, **kwargs) -> ~azure.core.async_paging.AsyncItemPaged[~azure.storage.blob.models.BlobProperties]: ...

class ContainerPermissions(object):
	ContainerPermissions.DELETE:ContainerPermissions
	ContainerPermissions.LIST:ContainerPermissions
	ContainerPermissions.READ:ContainerPermissions
	ContainerPermissions.WRITE:ContainerPermissions
	read:bool
	write:bool
	delete:bool
	list:bool
	_str:str

	def __add__(self, other): ...
	def __init__(self, read: bool=False, write: bool=False, delete: bool=False, list: bool=False, _str: str=None, *, ContainerPermissions.DELETE, ContainerPermissions.LIST, ContainerPermissions.READ, ContainerPermissions.WRITE): ...
	def __or__(self, other): ...
	def __str__(self): ...

class ContainerProperties(DictMixin, object):
	last_modified:datetime
	etag:str
	lease:~azure.storage.blob.models.LeaseProperties
	public_access:str
	has_immutability_policy:bool
	has_legal_hold:bool
	metadata:dict

	def __init__(self, *, last_modified, etag, lease, public_access, has_immutability_policy, has_legal_hold, metadata, **kwargs): ...
	def __str__(self): ...
	def get(self, key, default=None): ...
	def has_key(self, k): ...
	def items(self): ...
	def keys(self): ...
	def update(self, *args, **kwargs): ...
	def values(self): ...

class ContainerPropertiesPaged(AsyncPageIterator, AsyncIterator, AsyncIterable, Generic, object):
	service_endpoint:str
	prefix:str
	marker:str
	results_per_page:int
	location_mode:str
	current_page
	command:callable
	continuation_token:str

	def __aiter__(self): ...
	def __anext__(self): ...
	def __class_getitem__(cls, params): ...
	def __init__(self, command: callable, prefix: str=None, results_per_page: int=None, continuation_token: str=None, *, service_endpoint, marker, location_mode, current_page, get_next, extract_data): ...
	def __init_subclass__(cls, *args, **kwargs): ...
	def __new__(cls, *args, **kwargs): ...

class ContentSettings(DictMixin, object):
	content_type:str
	content_encoding:str
	content_language:str
	content_disposition:str
	cache_control:str
	content_md5:str

	def __init__(self, content_type: str=None, content_encoding: str=None, content_language: str=None, content_disposition: str=None, cache_control: str=None, content_md5: str=None, **kwargs): ...
	def __str__(self): ...
	def get(self, key, default=None): ...
	def has_key(self, k): ...
	def items(self): ...
	def keys(self): ...
	def update(self, *args, **kwargs): ...
	def values(self): ...

class CopyProperties(DictMixin, object):
	id:str
	source:str
	status:str
	progress:str
	completion_time:datetime
	status_description:str
	incremental_copy:bool
	destination_snapshot:datetime

	def __init__(self, *, id, source, status, progress, completion_time, status_description, incremental_copy, destination_snapshot, **kwargs): ...
	def __str__(self): ...
	def get(self, key, default=None): ...
	def has_key(self, k): ...
	def items(self): ...
	def keys(self): ...
	def update(self, *args, **kwargs): ...
	def values(self): ...

class CorsRule(Model, object):
	allowed_origins:list(str)
	allowed_methods:list(str)
	allowed_headers:list(str)
	exposed_headers:list(str)
	max_age_in_seconds:int

	def __eq__(self, other): ...
	def __init__(self, allowed_origins: list(str), allowed_methods: list(str), *, allowed_headers, exposed_headers, max_age_in_seconds, **kwargs): ...
	def __ne__(self, other): ...
	def __str__(self): ...
	def as_dict(self, keep_readonly=True, key_transformer: function=<function attribute_transformer at 0x10e6a4510>) -> dict: ...
	@classmethod
	def deserialize(cls, data: str, content_type: str=None): ...
	@classmethod
	def enable_additional_properties_sending(cls): ...
	@classmethod
	def from_dict(cls, data: dict, key_extractors=None, content_type: str=None): ...
	@classmethod
	def is_xml_model(cls): ...
	def serialize(self, keep_readonly: bool=False) -> dict: ...
	def validate(self) -> list: ...

class ExponentialRetry(AsyncStorageRetryPolicy, StorageRetryPolicy, HTTPPolicy, ABC, Generic, object):
	def __class_getitem__(cls, params): ...
	def __init__(self, initial_backoff: int=15, increment_base: int=3, retry_total=3, retry_to_secondary: bool=False, random_jitter_range: int=3, *, max_attempts, **kwargs): ...
	def __init_subclass__(cls, *args, **kwargs): ...
	def __new__(cls, *args, **kwargs): ...
	def configure_retries(self, request): ...
	def get_backoff_time(self, settings) -> int or None: ...
	def increment(self, settings, request, response=None, error=None): ...
	def send(self, request: request) -> ~azure.core.pipeline.PipelineResponse: ...
	def sleep(self, settings, transport): ...

class LeaseClient(object):
	id:str
	etag:str
	last_modified:datetime
	client:client
	lease_id:str

	def __aenter__(self): ...
	def __aexit__(self, *args): ...
	def __enter__(self): ...
	def __exit__(self, *args): ...
	def __init__(self, client: client, lease_id: str=None, *, id, etag, last_modified): ...
	def acquire(self, lease_duration: int=-1, timeout: int=None, *, if_modified_since, if_unmodified_since, if_match, if_none_match, **kwargs) -> None: ...
	def break_lease(self, lease_break_period: int=None, timeout: int=None, *, if_modified_since, if_unmodified_since, **kwargs) -> int: ...
	def change(self, proposed_lease_id: str, timeout: int=None, *, if_modified_since, if_unmodified_since, if_match, if_none_match, **kwargs): ...
	def release(self, timeout: int=None, *, if_modified_since, if_unmodified_since, if_match, if_none_match, **kwargs): ...
	def renew(self, timeout: int=None, *, if_modified_since, if_unmodified_since, if_match, if_none_match, **kwargs): ...

class LeaseProperties(DictMixin, object):
	status:str
	state:str
	duration:str

	def __init__(self, *, status, state, duration, **kwargs): ...
	def __str__(self): ...
	def get(self, key, default=None): ...
	def has_key(self, k): ...
	def items(self): ...
	def keys(self): ...
	def update(self, *args, **kwargs): ...
	def values(self): ...

class LinearRetry(AsyncStorageRetryPolicy, StorageRetryPolicy, HTTPPolicy, ABC, Generic, object):
	def __class_getitem__(cls, params): ...
	def __init__(self, backoff: int=15, retry_total=3, retry_to_secondary: bool=False, random_jitter_range: int=3, *, max_attempts, **kwargs): ...
	def __init_subclass__(cls, *args, **kwargs): ...
	def __new__(cls, *args, **kwargs): ...
	def configure_retries(self, request): ...
	def get_backoff_time(self, settings) -> int or None: ...
	def increment(self, settings, request, response=None, error=None): ...
	def send(self, request: request) -> ~azure.core.pipeline.PipelineResponse: ...
	def sleep(self, settings, transport): ...

class LocationMode(object):
	...

class Logging(Model, object):
	version:str
	delete:bool
	read:bool
	write:bool
	retention_policy:retention_policy

	def __eq__(self, other): ...
	def __init__(self, *, version, delete, read, write, retention_policy, **kwargs): ...
	def __ne__(self, other): ...
	def __str__(self): ...
	def as_dict(self, keep_readonly=True, key_transformer: function=<function attribute_transformer at 0x10e6a4510>) -> dict: ...
	@classmethod
	def deserialize(cls, data: str, content_type: str=None): ...
	@classmethod
	def enable_additional_properties_sending(cls): ...
	@classmethod
	def from_dict(cls, data: dict, key_extractors=None, content_type: str=None): ...
	@classmethod
	def is_xml_model(cls): ...
	def serialize(self, keep_readonly: bool=False) -> dict: ...
	def validate(self) -> list: ...

class Metrics(Model, object):
	version:str
	enabled:bool
	include_apis:bool
	retention_policy:retention_policy

	def __eq__(self, other): ...
	def __init__(self, *, version, enabled, include_apis, retention_policy, **kwargs): ...
	def __ne__(self, other): ...
	def __str__(self): ...
	def as_dict(self, keep_readonly=True, key_transformer: function=<function attribute_transformer at 0x10e6a4510>) -> dict: ...
	@classmethod
	def deserialize(cls, data: str, content_type: str=None): ...
	@classmethod
	def enable_additional_properties_sending(cls): ...
	@classmethod
	def from_dict(cls, data: dict, key_extractors=None, content_type: str=None): ...
	@classmethod
	def is_xml_model(cls): ...
	def serialize(self, keep_readonly: bool=False) -> dict: ...
	def validate(self) -> list: ...

class NoRetry(AsyncStorageRetryPolicy, StorageRetryPolicy, HTTPPolicy, ABC, Generic, object):
	def __class_getitem__(cls, params): ...
	def __init__(self): ...
	def __init_subclass__(cls, *args, **kwargs): ...
	def __new__(cls, *args, **kwargs): ...
	def configure_retries(self, request): ...
	def get_backoff_time(self, settings) -> float: ...
	def increment(self, *args, *, response, error, **kwargs): ...
	def send(self, request: request) -> ~azure.core.pipeline.PipelineResponse: ...
	def sleep(self, settings, transport): ...

class PageRange(DictMixin, object):
	start:int
	end:int

	def __init__(self, start: int=None, end: int=None): ...
	def __str__(self): ...
	def get(self, key, default=None): ...
	def has_key(self, k): ...
	def items(self): ...
	def keys(self): ...
	def update(self, *args, **kwargs): ...
	def values(self): ...

class PremiumPageBlobTier(str, Enum, object):
	...

class PublicAccess(str, Enum, object):
	...

class ResourceTypes(object):
	ResourceTypes.CONTAINER:ResourceTypes
	ResourceTypes.OBJECT:ResourceTypes
	ResourceTypes.SERVICE:ResourceTypes
	service:bool
	container:bool
	object:bool
	_str:str

	def __add__(self, other): ...
	def __init__(self, service: bool=False, container: bool=False, object: bool=False, _str: str=None, *, ResourceTypes.CONTAINER, ResourceTypes.OBJECT, ResourceTypes.SERVICE): ...
	def __or__(self, other): ...
	def __str__(self): ...

class RetentionPolicy(Model, object):
	enabled:bool
	days:int

	def __eq__(self, other): ...
	def __init__(self, enabled: bool=False, days: int=None): ...
	def __ne__(self, other): ...
	def __str__(self): ...
	def as_dict(self, keep_readonly=True, key_transformer: function=<function attribute_transformer at 0x10e6a4510>) -> dict: ...
	@classmethod
	def deserialize(cls, data: str, content_type: str=None): ...
	@classmethod
	def enable_additional_properties_sending(cls): ...
	@classmethod
	def from_dict(cls, data: dict, key_extractors=None, content_type: str=None): ...
	@classmethod
	def is_xml_model(cls): ...
	def serialize(self, keep_readonly: bool=False) -> dict: ...
	def validate(self) -> list: ...

class SequenceNumberAction(str, Enum, object):
	...

class StandardBlobTier(str, Enum, object):
	...

class StaticWebsite(Model, object):
	enabled:bool
	index_document:str
	error_document404_path:str

	def __eq__(self, other): ...
	def __init__(self, *, enabled, index_document, error_document404_path, **kwargs): ...
	def __ne__(self, other): ...
	def __str__(self): ...
	def as_dict(self, keep_readonly=True, key_transformer: function=<function attribute_transformer at 0x10e6a4510>) -> dict: ...
	@classmethod
	def deserialize(cls, data: str, content_type: str=None): ...
	@classmethod
	def enable_additional_properties_sending(cls): ...
	@classmethod
	def from_dict(cls, data: dict, key_extractors=None, content_type: str=None): ...
	@classmethod
	def is_xml_model(cls): ...
	def serialize(self, keep_readonly: bool=False) -> dict: ...
	def validate(self) -> list: ...

class StorageErrorCode(str, Enum, object):
	...

class StorageStreamDownloader(object):
	def __aiter__(self): ...
	def __anext__(self): ...
	def __init__(self, service=None, config=None, offset=None, length=None, validate_content=None, encryption_options=None, **kwargs): ...
	def __iter__(self): ...
	def __len__(self): ...
	def content_as_bytes(self, max_connections: int=1) -> bytes: ...
	def content_as_text(self, max_connections: int=1, encoding=UTF-8) -> str: ...
	def download_to_stream(self, stream, max_connections=1) -> Any: ...
	def setup(self, extra_properties=None): ...

