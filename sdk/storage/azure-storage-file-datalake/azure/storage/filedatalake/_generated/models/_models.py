# coding=utf-8
# --------------------------------------------------------------------------
# Copyright (c) Microsoft Corporation. All rights reserved.
# Licensed under the MIT License. See License.txt in the project root for
# license information.
#
# Code generated by Microsoft (R) AutoRest Code Generator.
# Changes may cause incorrect behavior and will be lost if the code is
# regenerated.
# --------------------------------------------------------------------------

from msrest.serialization import Model
from azure.core.exceptions import HttpResponseError


class FileSystem(Model):
    """FileSystem.

    :param name:
    :type name: str
    :param last_modified:
    :type last_modified: str
    :param e_tag:
    :type e_tag: str
    """

    _attribute_map = {
        'name': {'key': 'name', 'type': 'str'},
        'last_modified': {'key': 'lastModified', 'type': 'str'},
        'e_tag': {'key': 'eTag', 'type': 'str'},
    }

    def __init__(self, **kwargs):
        super(FileSystem, self).__init__(**kwargs)
        self.name = kwargs.get('name', None)
        self.last_modified = kwargs.get('last_modified', None)
        self.e_tag = kwargs.get('e_tag', None)


class FileSystemList(Model):
    """FileSystemList.

    :param filesystems:
    :type filesystems: list[~azure.storage.file.datalake.models.FileSystem]
    """

    _attribute_map = {
        'filesystems': {'key': 'filesystems', 'type': '[FileSystem]'},
    }

    def __init__(self, **kwargs):
        super(FileSystemList, self).__init__(**kwargs)
        self.filesystems = kwargs.get('filesystems', None)


class LeaseAccessConditions(Model):
    """Additional parameters for a set of operations.

    :param lease_id: If specified, the operation only succeeds if the
     resource's lease is active and matches this ID.
    :type lease_id: str
    """

    _attribute_map = {
        'lease_id': {'key': '', 'type': 'str'},
    }

    def __init__(self, **kwargs):
        super(LeaseAccessConditions, self).__init__(**kwargs)
        self.lease_id = kwargs.get('lease_id', None)


class ModifiedAccessConditions(Model):
    """Additional parameters for a set of operations.

    :param if_modified_since: Specify this header value to operate only on a
     blob if it has been modified since the specified date/time.
    :type if_modified_since: datetime
    :param if_unmodified_since: Specify this header value to operate only on a
     blob if it has not been modified since the specified date/time.
    :type if_unmodified_since: datetime
    :param if_match: Specify an ETag value to operate only on blobs with a
     matching value.
    :type if_match: str
    :param if_none_match: Specify an ETag value to operate only on blobs
     without a matching value.
    :type if_none_match: str
    """

    _attribute_map = {
        'if_modified_since': {'key': '', 'type': 'rfc-1123'},
        'if_unmodified_since': {'key': '', 'type': 'rfc-1123'},
        'if_match': {'key': '', 'type': 'str'},
        'if_none_match': {'key': '', 'type': 'str'},
    }

    def __init__(self, **kwargs):
        super(ModifiedAccessConditions, self).__init__(**kwargs)
        self.if_modified_since = kwargs.get('if_modified_since', None)
        self.if_unmodified_since = kwargs.get('if_unmodified_since', None)
        self.if_match = kwargs.get('if_match', None)
        self.if_none_match = kwargs.get('if_none_match', None)


class Path(Model):
    """Path.

    :param name:
    :type name: str
    :param is_directory:  Default value: False .
    :type is_directory: bool
    :param last_modified:
    :type last_modified: str
    :param e_tag:
    :type e_tag: str
    :param content_length:
    :type content_length: long
    :param owner:
    :type owner: str
    :param group:
    :type group: str
    :param permissions:
    :type permissions: str
    """

    _attribute_map = {
        'name': {'key': 'name', 'type': 'str'},
        'is_directory': {'key': 'isDirectory', 'type': 'bool'},
        'last_modified': {'key': 'lastModified', 'type': 'str'},
        'etag': {'key': 'etag', 'type': 'str'},
        'content_length': {'key': 'contentLength', 'type': 'long'},
        'owner': {'key': 'owner', 'type': 'str'},
        'group': {'key': 'group', 'type': 'str'},
        'permissions': {'key': 'permissions', 'type': 'str'},
    }

    def __init__(self, **kwargs):
        super(Path, self).__init__(**kwargs)
        self.name = kwargs.get('name', None)
        self.is_directory = kwargs.get('is_directory', False)
        self.last_modified = kwargs.get('last_modified', None)
        self.etag = kwargs.get('etag', None)
        self.content_length = kwargs.get('content_length', None)
        self.owner = kwargs.get('owner', None)
        self.group = kwargs.get('group', None)
        self.permissions = kwargs.get('permissions', None)


class PathHTTPHeaders(Model):
    """Additional parameters for a set of operations, such as: Path_create,
    Path_update, Path_flush_data, Path_append_data.

    :param cache_control: Optional. Sets the blob's cache control. If
     specified, this property is stored with the blob and returned with a read
     request.
    :type cache_control: str
    :param content_encoding: Optional. Sets the blob's content encoding. If
     specified, this property is stored with the blob and returned with a read
     request.
    :type content_encoding: str
    :param content_language: Optional. Set the blob's content language. If
     specified, this property is stored with the blob and returned with a read
     request.
    :type content_language: str
    :param content_disposition: Optional. Sets the blob's Content-Disposition
     header.
    :type content_disposition: str
    :param content_type: Optional. Sets the blob's content type. If specified,
     this property is stored with the blob and returned with a read request.
    :type content_type: str
    :param content_md5: Specify the transactional md5 for the body, to be
     validated by the service.
    :type content_md5: bytearray
    :param transactional_content_hash: Specify the transactional md5 for the
     body, to be validated by the service.
    :type transactional_content_hash: bytearray
    """

    _attribute_map = {
        'cache_control': {'key': '', 'type': 'str'},
        'content_encoding': {'key': '', 'type': 'str'},
        'content_language': {'key': '', 'type': 'str'},
        'content_disposition': {'key': '', 'type': 'str'},
        'content_type': {'key': '', 'type': 'str'},
        'content_md5': {'key': '', 'type': 'bytearray'},
        'transactional_content_hash': {'key': '', 'type': 'bytearray'},
    }

    def __init__(self, **kwargs):
        super(PathHTTPHeaders, self).__init__(**kwargs)
        self.cache_control = kwargs.get('cache_control', None)
        self.content_encoding = kwargs.get('content_encoding', None)
        self.content_language = kwargs.get('content_language', None)
        self.content_disposition = kwargs.get('content_disposition', None)
        self.content_type = kwargs.get('content_type', None)
        self.content_md5 = kwargs.get('content_md5', None)
        self.transactional_content_hash = kwargs.get('transactional_content_hash', None)


class PathList(Model):
    """PathList.

    :param paths:
    :type paths: list[~azure.storage.file.datalake.models.Path]
    """

    _attribute_map = {
        'paths': {'key': 'paths', 'type': '[Path]'},
    }

    def __init__(self, **kwargs):
        super(PathList, self).__init__(**kwargs)
        self.paths = kwargs.get('paths', None)


class SourceModifiedAccessConditions(Model):
    """Additional parameters for create operation.

    :param source_if_match: Specify an ETag value to operate only on blobs
     with a matching value.
    :type source_if_match: str
    :param source_if_none_match: Specify an ETag value to operate only on
     blobs without a matching value.
    :type source_if_none_match: str
    :param source_if_modified_since: Specify this header value to operate only
     on a blob if it has been modified since the specified date/time.
    :type source_if_modified_since: datetime
    :param source_if_unmodified_since: Specify this header value to operate
     only on a blob if it has not been modified since the specified date/time.
    :type source_if_unmodified_since: datetime
    """

    _attribute_map = {
        'source_if_match': {'key': '', 'type': 'str'},
        'source_if_none_match': {'key': '', 'type': 'str'},
        'source_if_modified_since': {'key': '', 'type': 'rfc-1123'},
        'source_if_unmodified_since': {'key': '', 'type': 'rfc-1123'},
    }

    def __init__(self, **kwargs):
        super(SourceModifiedAccessConditions, self).__init__(**kwargs)
        self.source_if_match = kwargs.get('source_if_match', None)
        self.source_if_none_match = kwargs.get('source_if_none_match', None)
        self.source_if_modified_since = kwargs.get('source_if_modified_since', None)
        self.source_if_unmodified_since = kwargs.get('source_if_unmodified_since', None)


class StorageError(Model):
    """StorageError.

    :param error: The service error response object.
    :type error: ~azure.storage.file.datalake.models.StorageErrorError
    """

    _attribute_map = {
        'error': {'key': 'error', 'type': 'StorageErrorError'},
    }

    def __init__(self, **kwargs):
        super(StorageError, self).__init__(**kwargs)
        self.error = kwargs.get('error', None)


class StorageErrorException(HttpResponseError):
    """Server responsed with exception of type: 'StorageError'.

    :param deserialize: A deserializer
    :param response: Server response to be deserialized.
    """

    def __init__(self, response, deserialize, *args):

      model_name = 'StorageError'
      self.error = deserialize(model_name, response)
      if self.error is None:
          self.error = deserialize.dependencies[model_name]()
      super(StorageErrorException, self).__init__(response=response)


class StorageErrorError(Model):
    """The service error response object.

    :param code: The service error code.
    :type code: str
    :param message: The service error message.
    :type message: str
    """

    _attribute_map = {
        'code': {'key': 'Code', 'type': 'str'},
        'message': {'key': 'Message', 'type': 'str'},
    }

    def __init__(self, **kwargs):
        super(StorageErrorError, self).__init__(**kwargs)
        self.code = kwargs.get('code', None)
        self.message = kwargs.get('message', None)
