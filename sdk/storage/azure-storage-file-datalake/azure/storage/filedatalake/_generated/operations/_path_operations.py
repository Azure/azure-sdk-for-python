# pylint: disable=too-many-lines
# coding=utf-8
# --------------------------------------------------------------------------
# Copyright (c) Microsoft Corporation. All rights reserved.
# Licensed under the MIT License. See License.txt in the project root for license information.
# Code generated by Microsoft (R) AutoRest Code Generator.
# Changes may cause incorrect behavior and will be lost if the code is regenerated.
# --------------------------------------------------------------------------
import datetime
from typing import TYPE_CHECKING

from msrest import Serializer

from azure.core.exceptions import ClientAuthenticationError, HttpResponseError, ResourceExistsError, ResourceNotFoundError, map_error
from azure.core.pipeline import PipelineResponse
from azure.core.pipeline.transport import HttpResponse
from azure.core.rest import HttpRequest
from azure.core.tracing.decorator import distributed_trace
from azure.core.utils import case_insensitive_dict

from .. import models as _models
from .._vendor import _convert_request, _format_url_section

if TYPE_CHECKING:
    # pylint: disable=unused-import,ungrouped-imports
    from typing import Any, Callable, Dict, IO, Optional, TypeVar, Union
    T = TypeVar('T')
    ClsType = Optional[Callable[[PipelineResponse[HttpRequest, HttpResponse], T, Dict[str, Any]], Any]]

_SERIALIZER = Serializer()
_SERIALIZER.client_side_validation = False
# fmt: off

def build_create_request(
    url,  # type: str
    **kwargs  # type: Any
):
    # type: (...) -> HttpRequest
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    version = kwargs.pop('version', _headers.pop('x-ms-version', "2021-06-08"))  # type: str
    request_id_parameter = kwargs.pop('request_id_parameter', _headers.pop('x-ms-client-request-id', None))  # type: Optional[str]
    timeout = kwargs.pop('timeout', _params.pop('timeout', None))  # type: Optional[int]
    resource = kwargs.pop('resource', _params.pop('resource', None))  # type: Optional[Union[str, "_models.PathResourceType"]]
    continuation = kwargs.pop('continuation', _params.pop('continuation', None))  # type: Optional[str]
    mode = kwargs.pop('mode', _params.pop('mode', None))  # type: Optional[Union[str, "_models.PathRenameMode"]]
    cache_control = kwargs.pop('cache_control', _headers.pop('x-ms-cache-control', None))  # type: Optional[str]
    content_encoding = kwargs.pop('content_encoding', _headers.pop('x-ms-content-encoding', None))  # type: Optional[str]
    content_language = kwargs.pop('content_language', _headers.pop('x-ms-content-language', None))  # type: Optional[str]
    content_disposition = kwargs.pop('content_disposition', _headers.pop('x-ms-content-disposition', None))  # type: Optional[str]
    content_type_parameter = kwargs.pop('content_type_parameter', _headers.pop('x-ms-content-type', None))  # type: Optional[str]
    rename_source = kwargs.pop('rename_source', _headers.pop('x-ms-rename-source', None))  # type: Optional[str]
    lease_id = kwargs.pop('lease_id', _headers.pop('x-ms-lease-id', None))  # type: Optional[str]
    source_lease_id = kwargs.pop('source_lease_id', _headers.pop('x-ms-source-lease-id', None))  # type: Optional[str]
    properties = kwargs.pop('properties', _headers.pop('x-ms-properties', None))  # type: Optional[str]
    permissions = kwargs.pop('permissions', _headers.pop('x-ms-permissions', None))  # type: Optional[str]
    umask = kwargs.pop('umask', _headers.pop('x-ms-umask', None))  # type: Optional[str]
    if_match = kwargs.pop('if_match', _headers.pop('If-Match', None))  # type: Optional[str]
    if_none_match = kwargs.pop('if_none_match', _headers.pop('If-None-Match', None))  # type: Optional[str]
    if_modified_since = kwargs.pop('if_modified_since', _headers.pop('If-Modified-Since', None))  # type: Optional[datetime.datetime]
    if_unmodified_since = kwargs.pop('if_unmodified_since', _headers.pop('If-Unmodified-Since', None))  # type: Optional[datetime.datetime]
    source_if_match = kwargs.pop('source_if_match', _headers.pop('x-ms-source-if-match', None))  # type: Optional[str]
    source_if_none_match = kwargs.pop('source_if_none_match', _headers.pop('x-ms-source-if-none-match', None))  # type: Optional[str]
    source_if_modified_since = kwargs.pop('source_if_modified_since', _headers.pop('x-ms-source-if-modified-since', None))  # type: Optional[datetime.datetime]
    source_if_unmodified_since = kwargs.pop('source_if_unmodified_since', _headers.pop('x-ms-source-if-unmodified-since', None))  # type: Optional[datetime.datetime]
    encryption_key = kwargs.pop('encryption_key', _headers.pop('x-ms-encryption-key', None))  # type: Optional[str]
    encryption_key_sha256 = kwargs.pop('encryption_key_sha256', _headers.pop('x-ms-encryption-key-sha256', None))  # type: Optional[str]
    encryption_algorithm = kwargs.pop('encryption_algorithm', _headers.pop('x-ms-encryption-algorithm', "AES256"))  # type: Optional[str]
    owner = kwargs.pop('owner', _headers.pop('x-ms-owner', None))  # type: Optional[str]
    group = kwargs.pop('group', _headers.pop('x-ms-group', None))  # type: Optional[str]
    acl = kwargs.pop('acl', _headers.pop('x-ms-acl', None))  # type: Optional[str]
    proposed_lease_id = kwargs.pop('proposed_lease_id', _headers.pop('x-ms-proposed-lease-id', None))  # type: Optional[str]
    lease_duration = kwargs.pop('lease_duration', _headers.pop('x-ms-lease-duration', None))  # type: Optional[int]
    expiry_options = kwargs.pop('expiry_options', _headers.pop('x-ms-expiry-option', None))  # type: Optional[Union[str, "_models.PathExpiryOptions"]]
    expires_on = kwargs.pop('expires_on', _headers.pop('x-ms-expiry-time', None))  # type: Optional[str]
    accept = _headers.pop('Accept', "application/json")

    # Construct URL
    _url = kwargs.pop("template_url", "{url}/{filesystem}/{path}")
    path_format_arguments = {
        "url": _SERIALIZER.url("url", url, 'str', skip_quote=True),
    }

    _url = _format_url_section(_url, **path_format_arguments)

    # Construct parameters
    if timeout is not None:
        _params['timeout'] = _SERIALIZER.query("timeout", timeout, 'int', minimum=0)
    if resource is not None:
        _params['resource'] = _SERIALIZER.query("resource", resource, 'str')
    if continuation is not None:
        _params['continuation'] = _SERIALIZER.query("continuation", continuation, 'str')
    if mode is not None:
        _params['mode'] = _SERIALIZER.query("mode", mode, 'str')

    # Construct headers
    if request_id_parameter is not None:
        _headers['x-ms-client-request-id'] = _SERIALIZER.header("request_id_parameter", request_id_parameter, 'str')
    _headers['x-ms-version'] = _SERIALIZER.header("version", version, 'str')
    if cache_control is not None:
        _headers['x-ms-cache-control'] = _SERIALIZER.header("cache_control", cache_control, 'str')
    if content_encoding is not None:
        _headers['x-ms-content-encoding'] = _SERIALIZER.header("content_encoding", content_encoding, 'str')
    if content_language is not None:
        _headers['x-ms-content-language'] = _SERIALIZER.header("content_language", content_language, 'str')
    if content_disposition is not None:
        _headers['x-ms-content-disposition'] = _SERIALIZER.header("content_disposition", content_disposition, 'str')
    if content_type_parameter is not None:
        _headers['x-ms-content-type'] = _SERIALIZER.header("content_type_parameter", content_type_parameter, 'str')
    if rename_source is not None:
        _headers['x-ms-rename-source'] = _SERIALIZER.header("rename_source", rename_source, 'str')
    if lease_id is not None:
        _headers['x-ms-lease-id'] = _SERIALIZER.header("lease_id", lease_id, 'str')
    if source_lease_id is not None:
        _headers['x-ms-source-lease-id'] = _SERIALIZER.header("source_lease_id", source_lease_id, 'str')
    if properties is not None:
        _headers['x-ms-properties'] = _SERIALIZER.header("properties", properties, 'str')
    if permissions is not None:
        _headers['x-ms-permissions'] = _SERIALIZER.header("permissions", permissions, 'str')
    if umask is not None:
        _headers['x-ms-umask'] = _SERIALIZER.header("umask", umask, 'str')
    if if_match is not None:
        _headers['If-Match'] = _SERIALIZER.header("if_match", if_match, 'str')
    if if_none_match is not None:
        _headers['If-None-Match'] = _SERIALIZER.header("if_none_match", if_none_match, 'str')
    if if_modified_since is not None:
        _headers['If-Modified-Since'] = _SERIALIZER.header("if_modified_since", if_modified_since, 'rfc-1123')
    if if_unmodified_since is not None:
        _headers['If-Unmodified-Since'] = _SERIALIZER.header("if_unmodified_since", if_unmodified_since, 'rfc-1123')
    if source_if_match is not None:
        _headers['x-ms-source-if-match'] = _SERIALIZER.header("source_if_match", source_if_match, 'str')
    if source_if_none_match is not None:
        _headers['x-ms-source-if-none-match'] = _SERIALIZER.header("source_if_none_match", source_if_none_match, 'str')
    if source_if_modified_since is not None:
        _headers['x-ms-source-if-modified-since'] = _SERIALIZER.header("source_if_modified_since", source_if_modified_since, 'rfc-1123')
    if source_if_unmodified_since is not None:
        _headers['x-ms-source-if-unmodified-since'] = _SERIALIZER.header("source_if_unmodified_since", source_if_unmodified_since, 'rfc-1123')
    if encryption_key is not None:
        _headers['x-ms-encryption-key'] = _SERIALIZER.header("encryption_key", encryption_key, 'str')
    if encryption_key_sha256 is not None:
        _headers['x-ms-encryption-key-sha256'] = _SERIALIZER.header("encryption_key_sha256", encryption_key_sha256, 'str')
    if encryption_algorithm is not None:
        _headers['x-ms-encryption-algorithm'] = _SERIALIZER.header("encryption_algorithm", encryption_algorithm, 'str')
    if owner is not None:
        _headers['x-ms-owner'] = _SERIALIZER.header("owner", owner, 'str')
    if group is not None:
        _headers['x-ms-group'] = _SERIALIZER.header("group", group, 'str')
    if acl is not None:
        _headers['x-ms-acl'] = _SERIALIZER.header("acl", acl, 'str')
    if proposed_lease_id is not None:
        _headers['x-ms-proposed-lease-id'] = _SERIALIZER.header("proposed_lease_id", proposed_lease_id, 'str')
    if lease_duration is not None:
        _headers['x-ms-lease-duration'] = _SERIALIZER.header("lease_duration", lease_duration, 'long')
    if expiry_options is not None:
        _headers['x-ms-expiry-option'] = _SERIALIZER.header("expiry_options", expiry_options, 'str')
    if expires_on is not None:
        _headers['x-ms-expiry-time'] = _SERIALIZER.header("expires_on", expires_on, 'str')
    _headers['Accept'] = _SERIALIZER.header("accept", accept, 'str')

    return HttpRequest(
        method="PUT",
        url=_url,
        params=_params,
        headers=_headers,
        **kwargs
    )


def build_update_request(
    url,  # type: str
    **kwargs  # type: Any
):
    # type: (...) -> HttpRequest
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    version = kwargs.pop('version', _headers.pop('x-ms-version', "2021-06-08"))  # type: str
    content_type = kwargs.pop('content_type', _headers.pop('Content-Type', None))  # type: Optional[str]
    action = kwargs.pop('action')  # type: Union[str, "_models.PathUpdateAction"]
    mode = kwargs.pop('mode')  # type: Union[str, "_models.PathSetAccessControlRecursiveMode"]
    request_id_parameter = kwargs.pop('request_id_parameter', _headers.pop('x-ms-client-request-id', None))  # type: Optional[str]
    timeout = kwargs.pop('timeout', _params.pop('timeout', None))  # type: Optional[int]
    max_records = kwargs.pop('max_records', _params.pop('maxRecords', None))  # type: Optional[int]
    continuation = kwargs.pop('continuation', _params.pop('continuation', None))  # type: Optional[str]
    force_flag = kwargs.pop('force_flag', _params.pop('forceFlag', None))  # type: Optional[bool]
    position = kwargs.pop('position', _params.pop('position', None))  # type: Optional[int]
    retain_uncommitted_data = kwargs.pop('retain_uncommitted_data', _params.pop('retainUncommittedData', None))  # type: Optional[bool]
    close = kwargs.pop('close', _params.pop('close', None))  # type: Optional[bool]
    content_length = kwargs.pop('content_length', _headers.pop('Content-Length', None))  # type: Optional[int]
    content_md5 = kwargs.pop('content_md5', _headers.pop('x-ms-content-md5', None))  # type: Optional[bytearray]
    lease_id = kwargs.pop('lease_id', _headers.pop('x-ms-lease-id', None))  # type: Optional[str]
    cache_control = kwargs.pop('cache_control', _headers.pop('x-ms-cache-control', None))  # type: Optional[str]
    content_type_parameter = kwargs.pop('content_type_parameter', _headers.pop('x-ms-content-type', None))  # type: Optional[str]
    content_disposition = kwargs.pop('content_disposition', _headers.pop('x-ms-content-disposition', None))  # type: Optional[str]
    content_encoding = kwargs.pop('content_encoding', _headers.pop('x-ms-content-encoding', None))  # type: Optional[str]
    content_language = kwargs.pop('content_language', _headers.pop('x-ms-content-language', None))  # type: Optional[str]
    properties = kwargs.pop('properties', _headers.pop('x-ms-properties', None))  # type: Optional[str]
    owner = kwargs.pop('owner', _headers.pop('x-ms-owner', None))  # type: Optional[str]
    group = kwargs.pop('group', _headers.pop('x-ms-group', None))  # type: Optional[str]
    permissions = kwargs.pop('permissions', _headers.pop('x-ms-permissions', None))  # type: Optional[str]
    acl = kwargs.pop('acl', _headers.pop('x-ms-acl', None))  # type: Optional[str]
    if_match = kwargs.pop('if_match', _headers.pop('If-Match', None))  # type: Optional[str]
    if_none_match = kwargs.pop('if_none_match', _headers.pop('If-None-Match', None))  # type: Optional[str]
    if_modified_since = kwargs.pop('if_modified_since', _headers.pop('If-Modified-Since', None))  # type: Optional[datetime.datetime]
    if_unmodified_since = kwargs.pop('if_unmodified_since', _headers.pop('If-Unmodified-Since', None))  # type: Optional[datetime.datetime]
    accept = _headers.pop('Accept', "application/json")

    # Construct URL
    _url = kwargs.pop("template_url", "{url}/{filesystem}/{path}")
    path_format_arguments = {
        "url": _SERIALIZER.url("url", url, 'str', skip_quote=True),
    }

    _url = _format_url_section(_url, **path_format_arguments)

    # Construct parameters
    if timeout is not None:
        _params['timeout'] = _SERIALIZER.query("timeout", timeout, 'int', minimum=0)
    _params['action'] = _SERIALIZER.query("action", action, 'str')
    if max_records is not None:
        _params['maxRecords'] = _SERIALIZER.query("max_records", max_records, 'int', minimum=1)
    if continuation is not None:
        _params['continuation'] = _SERIALIZER.query("continuation", continuation, 'str')
    _params['mode'] = _SERIALIZER.query("mode", mode, 'str')
    if force_flag is not None:
        _params['forceFlag'] = _SERIALIZER.query("force_flag", force_flag, 'bool')
    if position is not None:
        _params['position'] = _SERIALIZER.query("position", position, 'long')
    if retain_uncommitted_data is not None:
        _params['retainUncommittedData'] = _SERIALIZER.query("retain_uncommitted_data", retain_uncommitted_data, 'bool')
    if close is not None:
        _params['close'] = _SERIALIZER.query("close", close, 'bool')

    # Construct headers
    if request_id_parameter is not None:
        _headers['x-ms-client-request-id'] = _SERIALIZER.header("request_id_parameter", request_id_parameter, 'str')
    _headers['x-ms-version'] = _SERIALIZER.header("version", version, 'str')
    if content_length is not None:
        _headers['Content-Length'] = _SERIALIZER.header("content_length", content_length, 'long', minimum=0)
    if content_md5 is not None:
        _headers['x-ms-content-md5'] = _SERIALIZER.header("content_md5", content_md5, 'bytearray')
    if lease_id is not None:
        _headers['x-ms-lease-id'] = _SERIALIZER.header("lease_id", lease_id, 'str')
    if cache_control is not None:
        _headers['x-ms-cache-control'] = _SERIALIZER.header("cache_control", cache_control, 'str')
    if content_type_parameter is not None:
        _headers['x-ms-content-type'] = _SERIALIZER.header("content_type_parameter", content_type_parameter, 'str')
    if content_disposition is not None:
        _headers['x-ms-content-disposition'] = _SERIALIZER.header("content_disposition", content_disposition, 'str')
    if content_encoding is not None:
        _headers['x-ms-content-encoding'] = _SERIALIZER.header("content_encoding", content_encoding, 'str')
    if content_language is not None:
        _headers['x-ms-content-language'] = _SERIALIZER.header("content_language", content_language, 'str')
    if properties is not None:
        _headers['x-ms-properties'] = _SERIALIZER.header("properties", properties, 'str')
    if owner is not None:
        _headers['x-ms-owner'] = _SERIALIZER.header("owner", owner, 'str')
    if group is not None:
        _headers['x-ms-group'] = _SERIALIZER.header("group", group, 'str')
    if permissions is not None:
        _headers['x-ms-permissions'] = _SERIALIZER.header("permissions", permissions, 'str')
    if acl is not None:
        _headers['x-ms-acl'] = _SERIALIZER.header("acl", acl, 'str')
    if if_match is not None:
        _headers['If-Match'] = _SERIALIZER.header("if_match", if_match, 'str')
    if if_none_match is not None:
        _headers['If-None-Match'] = _SERIALIZER.header("if_none_match", if_none_match, 'str')
    if if_modified_since is not None:
        _headers['If-Modified-Since'] = _SERIALIZER.header("if_modified_since", if_modified_since, 'rfc-1123')
    if if_unmodified_since is not None:
        _headers['If-Unmodified-Since'] = _SERIALIZER.header("if_unmodified_since", if_unmodified_since, 'rfc-1123')
    if content_type is not None:
        _headers['Content-Type'] = _SERIALIZER.header("content_type", content_type, 'str')
    _headers['Accept'] = _SERIALIZER.header("accept", accept, 'str')

    return HttpRequest(
        method="PATCH",
        url=_url,
        params=_params,
        headers=_headers,
        **kwargs
    )


def build_lease_request(
    url,  # type: str
    **kwargs  # type: Any
):
    # type: (...) -> HttpRequest
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    version = kwargs.pop('version', _headers.pop('x-ms-version', "2021-06-08"))  # type: str
    x_ms_lease_action = kwargs.pop('x_ms_lease_action')  # type: Union[str, "_models.PathLeaseAction"]
    request_id_parameter = kwargs.pop('request_id_parameter', _headers.pop('x-ms-client-request-id', None))  # type: Optional[str]
    timeout = kwargs.pop('timeout', _params.pop('timeout', None))  # type: Optional[int]
    x_ms_lease_duration = kwargs.pop('x_ms_lease_duration', _headers.pop('x-ms-lease-duration', None))  # type: Optional[int]
    x_ms_lease_break_period = kwargs.pop('x_ms_lease_break_period', _headers.pop('x-ms-lease-break-period', None))  # type: Optional[int]
    lease_id = kwargs.pop('lease_id', _headers.pop('x-ms-lease-id', None))  # type: Optional[str]
    proposed_lease_id = kwargs.pop('proposed_lease_id', _headers.pop('x-ms-proposed-lease-id', None))  # type: Optional[str]
    if_match = kwargs.pop('if_match', _headers.pop('If-Match', None))  # type: Optional[str]
    if_none_match = kwargs.pop('if_none_match', _headers.pop('If-None-Match', None))  # type: Optional[str]
    if_modified_since = kwargs.pop('if_modified_since', _headers.pop('If-Modified-Since', None))  # type: Optional[datetime.datetime]
    if_unmodified_since = kwargs.pop('if_unmodified_since', _headers.pop('If-Unmodified-Since', None))  # type: Optional[datetime.datetime]
    accept = _headers.pop('Accept', "application/json")

    # Construct URL
    _url = kwargs.pop("template_url", "{url}/{filesystem}/{path}")
    path_format_arguments = {
        "url": _SERIALIZER.url("url", url, 'str', skip_quote=True),
    }

    _url = _format_url_section(_url, **path_format_arguments)

    # Construct parameters
    if timeout is not None:
        _params['timeout'] = _SERIALIZER.query("timeout", timeout, 'int', minimum=0)

    # Construct headers
    if request_id_parameter is not None:
        _headers['x-ms-client-request-id'] = _SERIALIZER.header("request_id_parameter", request_id_parameter, 'str')
    _headers['x-ms-version'] = _SERIALIZER.header("version", version, 'str')
    _headers['x-ms-lease-action'] = _SERIALIZER.header("x_ms_lease_action", x_ms_lease_action, 'str')
    if x_ms_lease_duration is not None:
        _headers['x-ms-lease-duration'] = _SERIALIZER.header("x_ms_lease_duration", x_ms_lease_duration, 'int')
    if x_ms_lease_break_period is not None:
        _headers['x-ms-lease-break-period'] = _SERIALIZER.header("x_ms_lease_break_period", x_ms_lease_break_period, 'int')
    if lease_id is not None:
        _headers['x-ms-lease-id'] = _SERIALIZER.header("lease_id", lease_id, 'str')
    if proposed_lease_id is not None:
        _headers['x-ms-proposed-lease-id'] = _SERIALIZER.header("proposed_lease_id", proposed_lease_id, 'str')
    if if_match is not None:
        _headers['If-Match'] = _SERIALIZER.header("if_match", if_match, 'str')
    if if_none_match is not None:
        _headers['If-None-Match'] = _SERIALIZER.header("if_none_match", if_none_match, 'str')
    if if_modified_since is not None:
        _headers['If-Modified-Since'] = _SERIALIZER.header("if_modified_since", if_modified_since, 'rfc-1123')
    if if_unmodified_since is not None:
        _headers['If-Unmodified-Since'] = _SERIALIZER.header("if_unmodified_since", if_unmodified_since, 'rfc-1123')
    _headers['Accept'] = _SERIALIZER.header("accept", accept, 'str')

    return HttpRequest(
        method="POST",
        url=_url,
        params=_params,
        headers=_headers,
        **kwargs
    )


def build_read_request(
    url,  # type: str
    **kwargs  # type: Any
):
    # type: (...) -> HttpRequest
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    version = kwargs.pop('version', _headers.pop('x-ms-version', "2021-06-08"))  # type: str
    request_id_parameter = kwargs.pop('request_id_parameter', _headers.pop('x-ms-client-request-id', None))  # type: Optional[str]
    timeout = kwargs.pop('timeout', _params.pop('timeout', None))  # type: Optional[int]
    range = kwargs.pop('range', _headers.pop('Range', None))  # type: Optional[str]
    lease_id = kwargs.pop('lease_id', _headers.pop('x-ms-lease-id', None))  # type: Optional[str]
    x_ms_range_get_content_md5 = kwargs.pop('x_ms_range_get_content_md5', _headers.pop('x-ms-range-get-content-md5', None))  # type: Optional[bool]
    if_match = kwargs.pop('if_match', _headers.pop('If-Match', None))  # type: Optional[str]
    if_none_match = kwargs.pop('if_none_match', _headers.pop('If-None-Match', None))  # type: Optional[str]
    if_modified_since = kwargs.pop('if_modified_since', _headers.pop('If-Modified-Since', None))  # type: Optional[datetime.datetime]
    if_unmodified_since = kwargs.pop('if_unmodified_since', _headers.pop('If-Unmodified-Since', None))  # type: Optional[datetime.datetime]
    encryption_key = kwargs.pop('encryption_key', _headers.pop('x-ms-encryption-key', None))  # type: Optional[str]
    encryption_key_sha256 = kwargs.pop('encryption_key_sha256', _headers.pop('x-ms-encryption-key-sha256', None))  # type: Optional[str]
    encryption_algorithm = kwargs.pop('encryption_algorithm', _headers.pop('x-ms-encryption-algorithm', "AES256"))  # type: Optional[str]
    accept = _headers.pop('Accept', "application/json")

    # Construct URL
    _url = kwargs.pop("template_url", "{url}/{filesystem}/{path}")
    path_format_arguments = {
        "url": _SERIALIZER.url("url", url, 'str', skip_quote=True),
    }

    _url = _format_url_section(_url, **path_format_arguments)

    # Construct parameters
    if timeout is not None:
        _params['timeout'] = _SERIALIZER.query("timeout", timeout, 'int', minimum=0)

    # Construct headers
    if request_id_parameter is not None:
        _headers['x-ms-client-request-id'] = _SERIALIZER.header("request_id_parameter", request_id_parameter, 'str')
    _headers['x-ms-version'] = _SERIALIZER.header("version", version, 'str')
    if range is not None:
        _headers['Range'] = _SERIALIZER.header("range", range, 'str')
    if lease_id is not None:
        _headers['x-ms-lease-id'] = _SERIALIZER.header("lease_id", lease_id, 'str')
    if x_ms_range_get_content_md5 is not None:
        _headers['x-ms-range-get-content-md5'] = _SERIALIZER.header("x_ms_range_get_content_md5", x_ms_range_get_content_md5, 'bool')
    if if_match is not None:
        _headers['If-Match'] = _SERIALIZER.header("if_match", if_match, 'str')
    if if_none_match is not None:
        _headers['If-None-Match'] = _SERIALIZER.header("if_none_match", if_none_match, 'str')
    if if_modified_since is not None:
        _headers['If-Modified-Since'] = _SERIALIZER.header("if_modified_since", if_modified_since, 'rfc-1123')
    if if_unmodified_since is not None:
        _headers['If-Unmodified-Since'] = _SERIALIZER.header("if_unmodified_since", if_unmodified_since, 'rfc-1123')
    if encryption_key is not None:
        _headers['x-ms-encryption-key'] = _SERIALIZER.header("encryption_key", encryption_key, 'str')
    if encryption_key_sha256 is not None:
        _headers['x-ms-encryption-key-sha256'] = _SERIALIZER.header("encryption_key_sha256", encryption_key_sha256, 'str')
    if encryption_algorithm is not None:
        _headers['x-ms-encryption-algorithm'] = _SERIALIZER.header("encryption_algorithm", encryption_algorithm, 'str')
    _headers['Accept'] = _SERIALIZER.header("accept", accept, 'str')

    return HttpRequest(
        method="GET",
        url=_url,
        params=_params,
        headers=_headers,
        **kwargs
    )


def build_get_properties_request(
    url,  # type: str
    **kwargs  # type: Any
):
    # type: (...) -> HttpRequest
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    version = kwargs.pop('version', _headers.pop('x-ms-version', "2021-06-08"))  # type: str
    request_id_parameter = kwargs.pop('request_id_parameter', _headers.pop('x-ms-client-request-id', None))  # type: Optional[str]
    timeout = kwargs.pop('timeout', _params.pop('timeout', None))  # type: Optional[int]
    action = kwargs.pop('action', _params.pop('action', None))  # type: Optional[Union[str, "_models.PathGetPropertiesAction"]]
    upn = kwargs.pop('upn', _params.pop('upn', None))  # type: Optional[bool]
    lease_id = kwargs.pop('lease_id', _headers.pop('x-ms-lease-id', None))  # type: Optional[str]
    if_match = kwargs.pop('if_match', _headers.pop('If-Match', None))  # type: Optional[str]
    if_none_match = kwargs.pop('if_none_match', _headers.pop('If-None-Match', None))  # type: Optional[str]
    if_modified_since = kwargs.pop('if_modified_since', _headers.pop('If-Modified-Since', None))  # type: Optional[datetime.datetime]
    if_unmodified_since = kwargs.pop('if_unmodified_since', _headers.pop('If-Unmodified-Since', None))  # type: Optional[datetime.datetime]
    accept = _headers.pop('Accept', "application/json")

    # Construct URL
    _url = kwargs.pop("template_url", "{url}/{filesystem}/{path}")
    path_format_arguments = {
        "url": _SERIALIZER.url("url", url, 'str', skip_quote=True),
    }

    _url = _format_url_section(_url, **path_format_arguments)

    # Construct parameters
    if timeout is not None:
        _params['timeout'] = _SERIALIZER.query("timeout", timeout, 'int', minimum=0)
    if action is not None:
        _params['action'] = _SERIALIZER.query("action", action, 'str')
    if upn is not None:
        _params['upn'] = _SERIALIZER.query("upn", upn, 'bool')

    # Construct headers
    if request_id_parameter is not None:
        _headers['x-ms-client-request-id'] = _SERIALIZER.header("request_id_parameter", request_id_parameter, 'str')
    _headers['x-ms-version'] = _SERIALIZER.header("version", version, 'str')
    if lease_id is not None:
        _headers['x-ms-lease-id'] = _SERIALIZER.header("lease_id", lease_id, 'str')
    if if_match is not None:
        _headers['If-Match'] = _SERIALIZER.header("if_match", if_match, 'str')
    if if_none_match is not None:
        _headers['If-None-Match'] = _SERIALIZER.header("if_none_match", if_none_match, 'str')
    if if_modified_since is not None:
        _headers['If-Modified-Since'] = _SERIALIZER.header("if_modified_since", if_modified_since, 'rfc-1123')
    if if_unmodified_since is not None:
        _headers['If-Unmodified-Since'] = _SERIALIZER.header("if_unmodified_since", if_unmodified_since, 'rfc-1123')
    _headers['Accept'] = _SERIALIZER.header("accept", accept, 'str')

    return HttpRequest(
        method="HEAD",
        url=_url,
        params=_params,
        headers=_headers,
        **kwargs
    )


def build_delete_request(
    url,  # type: str
    **kwargs  # type: Any
):
    # type: (...) -> HttpRequest
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    version = kwargs.pop('version', _headers.pop('x-ms-version', "2021-06-08"))  # type: str
    request_id_parameter = kwargs.pop('request_id_parameter', _headers.pop('x-ms-client-request-id', None))  # type: Optional[str]
    timeout = kwargs.pop('timeout', _params.pop('timeout', None))  # type: Optional[int]
    recursive = kwargs.pop('recursive', _params.pop('recursive', None))  # type: Optional[bool]
    continuation = kwargs.pop('continuation', _params.pop('continuation', None))  # type: Optional[str]
    lease_id = kwargs.pop('lease_id', _headers.pop('x-ms-lease-id', None))  # type: Optional[str]
    if_match = kwargs.pop('if_match', _headers.pop('If-Match', None))  # type: Optional[str]
    if_none_match = kwargs.pop('if_none_match', _headers.pop('If-None-Match', None))  # type: Optional[str]
    if_modified_since = kwargs.pop('if_modified_since', _headers.pop('If-Modified-Since', None))  # type: Optional[datetime.datetime]
    if_unmodified_since = kwargs.pop('if_unmodified_since', _headers.pop('If-Unmodified-Since', None))  # type: Optional[datetime.datetime]
    accept = _headers.pop('Accept', "application/json")

    # Construct URL
    _url = kwargs.pop("template_url", "{url}/{filesystem}/{path}")
    path_format_arguments = {
        "url": _SERIALIZER.url("url", url, 'str', skip_quote=True),
    }

    _url = _format_url_section(_url, **path_format_arguments)

    # Construct parameters
    if timeout is not None:
        _params['timeout'] = _SERIALIZER.query("timeout", timeout, 'int', minimum=0)
    if recursive is not None:
        _params['recursive'] = _SERIALIZER.query("recursive", recursive, 'bool')
    if continuation is not None:
        _params['continuation'] = _SERIALIZER.query("continuation", continuation, 'str')

    # Construct headers
    if request_id_parameter is not None:
        _headers['x-ms-client-request-id'] = _SERIALIZER.header("request_id_parameter", request_id_parameter, 'str')
    _headers['x-ms-version'] = _SERIALIZER.header("version", version, 'str')
    if lease_id is not None:
        _headers['x-ms-lease-id'] = _SERIALIZER.header("lease_id", lease_id, 'str')
    if if_match is not None:
        _headers['If-Match'] = _SERIALIZER.header("if_match", if_match, 'str')
    if if_none_match is not None:
        _headers['If-None-Match'] = _SERIALIZER.header("if_none_match", if_none_match, 'str')
    if if_modified_since is not None:
        _headers['If-Modified-Since'] = _SERIALIZER.header("if_modified_since", if_modified_since, 'rfc-1123')
    if if_unmodified_since is not None:
        _headers['If-Unmodified-Since'] = _SERIALIZER.header("if_unmodified_since", if_unmodified_since, 'rfc-1123')
    _headers['Accept'] = _SERIALIZER.header("accept", accept, 'str')

    return HttpRequest(
        method="DELETE",
        url=_url,
        params=_params,
        headers=_headers,
        **kwargs
    )


def build_set_access_control_request(
    url,  # type: str
    **kwargs  # type: Any
):
    # type: (...) -> HttpRequest
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    action = kwargs.pop('action', _params.pop('action', "setAccessControl"))  # type: str
    version = kwargs.pop('version', _headers.pop('x-ms-version', "2021-06-08"))  # type: str
    timeout = kwargs.pop('timeout', _params.pop('timeout', None))  # type: Optional[int]
    lease_id = kwargs.pop('lease_id', _headers.pop('x-ms-lease-id', None))  # type: Optional[str]
    owner = kwargs.pop('owner', _headers.pop('x-ms-owner', None))  # type: Optional[str]
    group = kwargs.pop('group', _headers.pop('x-ms-group', None))  # type: Optional[str]
    permissions = kwargs.pop('permissions', _headers.pop('x-ms-permissions', None))  # type: Optional[str]
    acl = kwargs.pop('acl', _headers.pop('x-ms-acl', None))  # type: Optional[str]
    if_match = kwargs.pop('if_match', _headers.pop('If-Match', None))  # type: Optional[str]
    if_none_match = kwargs.pop('if_none_match', _headers.pop('If-None-Match', None))  # type: Optional[str]
    if_modified_since = kwargs.pop('if_modified_since', _headers.pop('If-Modified-Since', None))  # type: Optional[datetime.datetime]
    if_unmodified_since = kwargs.pop('if_unmodified_since', _headers.pop('If-Unmodified-Since', None))  # type: Optional[datetime.datetime]
    request_id_parameter = kwargs.pop('request_id_parameter', _headers.pop('x-ms-client-request-id', None))  # type: Optional[str]
    accept = _headers.pop('Accept', "application/json")

    # Construct URL
    _url = kwargs.pop("template_url", "{url}/{filesystem}/{path}")
    path_format_arguments = {
        "url": _SERIALIZER.url("url", url, 'str', skip_quote=True),
    }

    _url = _format_url_section(_url, **path_format_arguments)

    # Construct parameters
    _params['action'] = _SERIALIZER.query("action", action, 'str')
    if timeout is not None:
        _params['timeout'] = _SERIALIZER.query("timeout", timeout, 'int', minimum=0)

    # Construct headers
    if lease_id is not None:
        _headers['x-ms-lease-id'] = _SERIALIZER.header("lease_id", lease_id, 'str')
    if owner is not None:
        _headers['x-ms-owner'] = _SERIALIZER.header("owner", owner, 'str')
    if group is not None:
        _headers['x-ms-group'] = _SERIALIZER.header("group", group, 'str')
    if permissions is not None:
        _headers['x-ms-permissions'] = _SERIALIZER.header("permissions", permissions, 'str')
    if acl is not None:
        _headers['x-ms-acl'] = _SERIALIZER.header("acl", acl, 'str')
    if if_match is not None:
        _headers['If-Match'] = _SERIALIZER.header("if_match", if_match, 'str')
    if if_none_match is not None:
        _headers['If-None-Match'] = _SERIALIZER.header("if_none_match", if_none_match, 'str')
    if if_modified_since is not None:
        _headers['If-Modified-Since'] = _SERIALIZER.header("if_modified_since", if_modified_since, 'rfc-1123')
    if if_unmodified_since is not None:
        _headers['If-Unmodified-Since'] = _SERIALIZER.header("if_unmodified_since", if_unmodified_since, 'rfc-1123')
    if request_id_parameter is not None:
        _headers['x-ms-client-request-id'] = _SERIALIZER.header("request_id_parameter", request_id_parameter, 'str')
    _headers['x-ms-version'] = _SERIALIZER.header("version", version, 'str')
    _headers['Accept'] = _SERIALIZER.header("accept", accept, 'str')

    return HttpRequest(
        method="PATCH",
        url=_url,
        params=_params,
        headers=_headers,
        **kwargs
    )


def build_set_access_control_recursive_request(
    url,  # type: str
    **kwargs  # type: Any
):
    # type: (...) -> HttpRequest
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    action = kwargs.pop('action', _params.pop('action', "setAccessControlRecursive"))  # type: str
    version = kwargs.pop('version', _headers.pop('x-ms-version', "2021-06-08"))  # type: str
    mode = kwargs.pop('mode')  # type: Union[str, "_models.PathSetAccessControlRecursiveMode"]
    timeout = kwargs.pop('timeout', _params.pop('timeout', None))  # type: Optional[int]
    continuation = kwargs.pop('continuation', _params.pop('continuation', None))  # type: Optional[str]
    force_flag = kwargs.pop('force_flag', _params.pop('forceFlag', None))  # type: Optional[bool]
    max_records = kwargs.pop('max_records', _params.pop('maxRecords', None))  # type: Optional[int]
    acl = kwargs.pop('acl', _headers.pop('x-ms-acl', None))  # type: Optional[str]
    request_id_parameter = kwargs.pop('request_id_parameter', _headers.pop('x-ms-client-request-id', None))  # type: Optional[str]
    accept = _headers.pop('Accept', "application/json")

    # Construct URL
    _url = kwargs.pop("template_url", "{url}/{filesystem}/{path}")
    path_format_arguments = {
        "url": _SERIALIZER.url("url", url, 'str', skip_quote=True),
    }

    _url = _format_url_section(_url, **path_format_arguments)

    # Construct parameters
    _params['action'] = _SERIALIZER.query("action", action, 'str')
    if timeout is not None:
        _params['timeout'] = _SERIALIZER.query("timeout", timeout, 'int', minimum=0)
    if continuation is not None:
        _params['continuation'] = _SERIALIZER.query("continuation", continuation, 'str')
    _params['mode'] = _SERIALIZER.query("mode", mode, 'str')
    if force_flag is not None:
        _params['forceFlag'] = _SERIALIZER.query("force_flag", force_flag, 'bool')
    if max_records is not None:
        _params['maxRecords'] = _SERIALIZER.query("max_records", max_records, 'int', minimum=1)

    # Construct headers
    if acl is not None:
        _headers['x-ms-acl'] = _SERIALIZER.header("acl", acl, 'str')
    if request_id_parameter is not None:
        _headers['x-ms-client-request-id'] = _SERIALIZER.header("request_id_parameter", request_id_parameter, 'str')
    _headers['x-ms-version'] = _SERIALIZER.header("version", version, 'str')
    _headers['Accept'] = _SERIALIZER.header("accept", accept, 'str')

    return HttpRequest(
        method="PATCH",
        url=_url,
        params=_params,
        headers=_headers,
        **kwargs
    )


def build_flush_data_request(
    url,  # type: str
    **kwargs  # type: Any
):
    # type: (...) -> HttpRequest
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    action = kwargs.pop('action', _params.pop('action', "flush"))  # type: str
    version = kwargs.pop('version', _headers.pop('x-ms-version', "2021-06-08"))  # type: str
    timeout = kwargs.pop('timeout', _params.pop('timeout', None))  # type: Optional[int]
    position = kwargs.pop('position', _params.pop('position', None))  # type: Optional[int]
    retain_uncommitted_data = kwargs.pop('retain_uncommitted_data', _params.pop('retainUncommittedData', None))  # type: Optional[bool]
    close = kwargs.pop('close', _params.pop('close', None))  # type: Optional[bool]
    content_length = kwargs.pop('content_length', _headers.pop('Content-Length', None))  # type: Optional[int]
    content_md5 = kwargs.pop('content_md5', _headers.pop('x-ms-content-md5', None))  # type: Optional[bytearray]
    lease_id = kwargs.pop('lease_id', _headers.pop('x-ms-lease-id', None))  # type: Optional[str]
    cache_control = kwargs.pop('cache_control', _headers.pop('x-ms-cache-control', None))  # type: Optional[str]
    content_type_parameter = kwargs.pop('content_type_parameter', _headers.pop('x-ms-content-type', None))  # type: Optional[str]
    content_disposition = kwargs.pop('content_disposition', _headers.pop('x-ms-content-disposition', None))  # type: Optional[str]
    content_encoding = kwargs.pop('content_encoding', _headers.pop('x-ms-content-encoding', None))  # type: Optional[str]
    content_language = kwargs.pop('content_language', _headers.pop('x-ms-content-language', None))  # type: Optional[str]
    if_match = kwargs.pop('if_match', _headers.pop('If-Match', None))  # type: Optional[str]
    if_none_match = kwargs.pop('if_none_match', _headers.pop('If-None-Match', None))  # type: Optional[str]
    if_modified_since = kwargs.pop('if_modified_since', _headers.pop('If-Modified-Since', None))  # type: Optional[datetime.datetime]
    if_unmodified_since = kwargs.pop('if_unmodified_since', _headers.pop('If-Unmodified-Since', None))  # type: Optional[datetime.datetime]
    request_id_parameter = kwargs.pop('request_id_parameter', _headers.pop('x-ms-client-request-id', None))  # type: Optional[str]
    encryption_key = kwargs.pop('encryption_key', _headers.pop('x-ms-encryption-key', None))  # type: Optional[str]
    encryption_key_sha256 = kwargs.pop('encryption_key_sha256', _headers.pop('x-ms-encryption-key-sha256', None))  # type: Optional[str]
    encryption_algorithm = kwargs.pop('encryption_algorithm', _headers.pop('x-ms-encryption-algorithm', "AES256"))  # type: Optional[str]
    accept = _headers.pop('Accept', "application/json")

    # Construct URL
    _url = kwargs.pop("template_url", "{url}/{filesystem}/{path}")
    path_format_arguments = {
        "url": _SERIALIZER.url("url", url, 'str', skip_quote=True),
    }

    _url = _format_url_section(_url, **path_format_arguments)

    # Construct parameters
    _params['action'] = _SERIALIZER.query("action", action, 'str')
    if timeout is not None:
        _params['timeout'] = _SERIALIZER.query("timeout", timeout, 'int', minimum=0)
    if position is not None:
        _params['position'] = _SERIALIZER.query("position", position, 'long')
    if retain_uncommitted_data is not None:
        _params['retainUncommittedData'] = _SERIALIZER.query("retain_uncommitted_data", retain_uncommitted_data, 'bool')
    if close is not None:
        _params['close'] = _SERIALIZER.query("close", close, 'bool')

    # Construct headers
    if content_length is not None:
        _headers['Content-Length'] = _SERIALIZER.header("content_length", content_length, 'long', minimum=0)
    if content_md5 is not None:
        _headers['x-ms-content-md5'] = _SERIALIZER.header("content_md5", content_md5, 'bytearray')
    if lease_id is not None:
        _headers['x-ms-lease-id'] = _SERIALIZER.header("lease_id", lease_id, 'str')
    if cache_control is not None:
        _headers['x-ms-cache-control'] = _SERIALIZER.header("cache_control", cache_control, 'str')
    if content_type_parameter is not None:
        _headers['x-ms-content-type'] = _SERIALIZER.header("content_type_parameter", content_type_parameter, 'str')
    if content_disposition is not None:
        _headers['x-ms-content-disposition'] = _SERIALIZER.header("content_disposition", content_disposition, 'str')
    if content_encoding is not None:
        _headers['x-ms-content-encoding'] = _SERIALIZER.header("content_encoding", content_encoding, 'str')
    if content_language is not None:
        _headers['x-ms-content-language'] = _SERIALIZER.header("content_language", content_language, 'str')
    if if_match is not None:
        _headers['If-Match'] = _SERIALIZER.header("if_match", if_match, 'str')
    if if_none_match is not None:
        _headers['If-None-Match'] = _SERIALIZER.header("if_none_match", if_none_match, 'str')
    if if_modified_since is not None:
        _headers['If-Modified-Since'] = _SERIALIZER.header("if_modified_since", if_modified_since, 'rfc-1123')
    if if_unmodified_since is not None:
        _headers['If-Unmodified-Since'] = _SERIALIZER.header("if_unmodified_since", if_unmodified_since, 'rfc-1123')
    if request_id_parameter is not None:
        _headers['x-ms-client-request-id'] = _SERIALIZER.header("request_id_parameter", request_id_parameter, 'str')
    _headers['x-ms-version'] = _SERIALIZER.header("version", version, 'str')
    if encryption_key is not None:
        _headers['x-ms-encryption-key'] = _SERIALIZER.header("encryption_key", encryption_key, 'str')
    if encryption_key_sha256 is not None:
        _headers['x-ms-encryption-key-sha256'] = _SERIALIZER.header("encryption_key_sha256", encryption_key_sha256, 'str')
    if encryption_algorithm is not None:
        _headers['x-ms-encryption-algorithm'] = _SERIALIZER.header("encryption_algorithm", encryption_algorithm, 'str')
    _headers['Accept'] = _SERIALIZER.header("accept", accept, 'str')

    return HttpRequest(
        method="PATCH",
        url=_url,
        params=_params,
        headers=_headers,
        **kwargs
    )


def build_append_data_request(
    url,  # type: str
    **kwargs  # type: Any
):
    # type: (...) -> HttpRequest
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    action = kwargs.pop('action', _params.pop('action', "append"))  # type: str
    version = kwargs.pop('version', _headers.pop('x-ms-version', "2021-06-08"))  # type: str
    content_type = kwargs.pop('content_type', _headers.pop('Content-Type', None))  # type: Optional[str]
    position = kwargs.pop('position', _params.pop('position', None))  # type: Optional[int]
    timeout = kwargs.pop('timeout', _params.pop('timeout', None))  # type: Optional[int]
    content_length = kwargs.pop('content_length', _headers.pop('Content-Length', None))  # type: Optional[int]
    transactional_content_hash = kwargs.pop('transactional_content_hash', _headers.pop('Content-MD5', None))  # type: Optional[bytearray]
    transactional_content_crc64 = kwargs.pop('transactional_content_crc64', _headers.pop('x-ms-content-crc64', None))  # type: Optional[bytearray]
    lease_id = kwargs.pop('lease_id', _headers.pop('x-ms-lease-id', None))  # type: Optional[str]
    request_id_parameter = kwargs.pop('request_id_parameter', _headers.pop('x-ms-client-request-id', None))  # type: Optional[str]
    encryption_key = kwargs.pop('encryption_key', _headers.pop('x-ms-encryption-key', None))  # type: Optional[str]
    encryption_key_sha256 = kwargs.pop('encryption_key_sha256', _headers.pop('x-ms-encryption-key-sha256', None))  # type: Optional[str]
    encryption_algorithm = kwargs.pop('encryption_algorithm', _headers.pop('x-ms-encryption-algorithm', "AES256"))  # type: Optional[str]
    accept = _headers.pop('Accept', "application/json")

    # Construct URL
    _url = kwargs.pop("template_url", "{url}/{filesystem}/{path}")
    path_format_arguments = {
        "url": _SERIALIZER.url("url", url, 'str', skip_quote=True),
    }

    _url = _format_url_section(_url, **path_format_arguments)

    # Construct parameters
    _params['action'] = _SERIALIZER.query("action", action, 'str')
    if position is not None:
        _params['position'] = _SERIALIZER.query("position", position, 'long')
    if timeout is not None:
        _params['timeout'] = _SERIALIZER.query("timeout", timeout, 'int', minimum=0)

    # Construct headers
    if content_length is not None:
        _headers['Content-Length'] = _SERIALIZER.header("content_length", content_length, 'long', minimum=0)
    if transactional_content_hash is not None:
        _headers['Content-MD5'] = _SERIALIZER.header("transactional_content_hash", transactional_content_hash, 'bytearray')
    if transactional_content_crc64 is not None:
        _headers['x-ms-content-crc64'] = _SERIALIZER.header("transactional_content_crc64", transactional_content_crc64, 'bytearray')
    if lease_id is not None:
        _headers['x-ms-lease-id'] = _SERIALIZER.header("lease_id", lease_id, 'str')
    if request_id_parameter is not None:
        _headers['x-ms-client-request-id'] = _SERIALIZER.header("request_id_parameter", request_id_parameter, 'str')
    _headers['x-ms-version'] = _SERIALIZER.header("version", version, 'str')
    if encryption_key is not None:
        _headers['x-ms-encryption-key'] = _SERIALIZER.header("encryption_key", encryption_key, 'str')
    if encryption_key_sha256 is not None:
        _headers['x-ms-encryption-key-sha256'] = _SERIALIZER.header("encryption_key_sha256", encryption_key_sha256, 'str')
    if encryption_algorithm is not None:
        _headers['x-ms-encryption-algorithm'] = _SERIALIZER.header("encryption_algorithm", encryption_algorithm, 'str')
    if content_type is not None:
        _headers['Content-Type'] = _SERIALIZER.header("content_type", content_type, 'str')
    _headers['Accept'] = _SERIALIZER.header("accept", accept, 'str')

    return HttpRequest(
        method="PATCH",
        url=_url,
        params=_params,
        headers=_headers,
        **kwargs
    )


def build_set_expiry_request(
    url,  # type: str
    **kwargs  # type: Any
):
    # type: (...) -> HttpRequest
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    comp = kwargs.pop('comp', _params.pop('comp', "expiry"))  # type: str
    version = kwargs.pop('version', _headers.pop('x-ms-version', "2021-06-08"))  # type: str
    expiry_options = kwargs.pop('expiry_options')  # type: Union[str, "_models.PathExpiryOptions"]
    timeout = kwargs.pop('timeout', _params.pop('timeout', None))  # type: Optional[int]
    request_id_parameter = kwargs.pop('request_id_parameter', _headers.pop('x-ms-client-request-id', None))  # type: Optional[str]
    expires_on = kwargs.pop('expires_on', _headers.pop('x-ms-expiry-time', None))  # type: Optional[str]
    accept = _headers.pop('Accept', "application/json")

    # Construct URL
    _url = kwargs.pop("template_url", "{url}/{filesystem}/{path}")
    path_format_arguments = {
        "url": _SERIALIZER.url("url", url, 'str', skip_quote=True),
    }

    _url = _format_url_section(_url, **path_format_arguments)

    # Construct parameters
    _params['comp'] = _SERIALIZER.query("comp", comp, 'str')
    if timeout is not None:
        _params['timeout'] = _SERIALIZER.query("timeout", timeout, 'int', minimum=0)

    # Construct headers
    _headers['x-ms-version'] = _SERIALIZER.header("version", version, 'str')
    if request_id_parameter is not None:
        _headers['x-ms-client-request-id'] = _SERIALIZER.header("request_id_parameter", request_id_parameter, 'str')
    _headers['x-ms-expiry-option'] = _SERIALIZER.header("expiry_options", expiry_options, 'str')
    if expires_on is not None:
        _headers['x-ms-expiry-time'] = _SERIALIZER.header("expires_on", expires_on, 'str')
    _headers['Accept'] = _SERIALIZER.header("accept", accept, 'str')

    return HttpRequest(
        method="PUT",
        url=_url,
        params=_params,
        headers=_headers,
        **kwargs
    )


def build_undelete_request(
    url,  # type: str
    **kwargs  # type: Any
):
    # type: (...) -> HttpRequest
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    comp = kwargs.pop('comp', _params.pop('comp', "undelete"))  # type: str
    version = kwargs.pop('version', _headers.pop('x-ms-version', "2021-06-08"))  # type: str
    timeout = kwargs.pop('timeout', _params.pop('timeout', None))  # type: Optional[int]
    undelete_source = kwargs.pop('undelete_source', _headers.pop('x-ms-undelete-source', None))  # type: Optional[str]
    request_id_parameter = kwargs.pop('request_id_parameter', _headers.pop('x-ms-client-request-id', None))  # type: Optional[str]
    accept = _headers.pop('Accept', "application/json")

    # Construct URL
    _url = kwargs.pop("template_url", "{url}/{filesystem}/{path}")
    path_format_arguments = {
        "url": _SERIALIZER.url("url", url, 'str', skip_quote=True),
    }

    _url = _format_url_section(_url, **path_format_arguments)

    # Construct parameters
    _params['comp'] = _SERIALIZER.query("comp", comp, 'str')
    if timeout is not None:
        _params['timeout'] = _SERIALIZER.query("timeout", timeout, 'int', minimum=0)

    # Construct headers
    if undelete_source is not None:
        _headers['x-ms-undelete-source'] = _SERIALIZER.header("undelete_source", undelete_source, 'str')
    _headers['x-ms-version'] = _SERIALIZER.header("version", version, 'str')
    if request_id_parameter is not None:
        _headers['x-ms-client-request-id'] = _SERIALIZER.header("request_id_parameter", request_id_parameter, 'str')
    _headers['Accept'] = _SERIALIZER.header("accept", accept, 'str')

    return HttpRequest(
        method="PUT",
        url=_url,
        params=_params,
        headers=_headers,
        **kwargs
    )

# fmt: on
class PathOperations(object):
    """
    .. warning::
        **DO NOT** instantiate this class directly.

        Instead, you should access the following operations through
        :class:`~azure.storage.filedatalake.AzureDataLakeStorageRESTAPI`'s
        :attr:`path` attribute.
    """

    models = _models

    def __init__(self, *args, **kwargs):
        input_args = list(args)
        self._client = input_args.pop(0) if input_args else kwargs.pop("client")
        self._config = input_args.pop(0) if input_args else kwargs.pop("config")
        self._serialize = input_args.pop(0) if input_args else kwargs.pop("serializer")
        self._deserialize = input_args.pop(0) if input_args else kwargs.pop("deserializer")


    @distributed_trace
    def create(  # pylint: disable=inconsistent-return-statements
        self,
        request_id_parameter=None,  # type: Optional[str]
        timeout=None,  # type: Optional[int]
        resource=None,  # type: Optional[Union[str, "_models.PathResourceType"]]
        continuation=None,  # type: Optional[str]
        mode=None,  # type: Optional[Union[str, "_models.PathRenameMode"]]
        rename_source=None,  # type: Optional[str]
        source_lease_id=None,  # type: Optional[str]
        properties=None,  # type: Optional[str]
        permissions=None,  # type: Optional[str]
        umask=None,  # type: Optional[str]
        owner=None,  # type: Optional[str]
        group=None,  # type: Optional[str]
        acl=None,  # type: Optional[str]
        proposed_lease_id=None,  # type: Optional[str]
        lease_duration=None,  # type: Optional[int]
        expiry_options=None,  # type: Optional[Union[str, "_models.PathExpiryOptions"]]
        expires_on=None,  # type: Optional[str]
        path_http_headers=None,  # type: Optional[_models.PathHTTPHeaders]
        lease_access_conditions=None,  # type: Optional[_models.LeaseAccessConditions]
        modified_access_conditions=None,  # type: Optional[_models.ModifiedAccessConditions]
        source_modified_access_conditions=None,  # type: Optional[_models.SourceModifiedAccessConditions]
        cpk_info=None,  # type: Optional[_models.CpkInfo]
        **kwargs  # type: Any
    ):
        # type: (...) -> None
        """Create File | Create Directory | Rename File | Rename Directory.

        Create or rename a file or directory.    By default, the destination is overwritten and if the
        destination already exists and has a lease the lease is broken.  This operation supports
        conditional HTTP requests.  For more information, see `Specifying Conditional Headers for Blob
        Service Operations
        <https://docs.microsoft.com/en-us/rest/api/storageservices/specifying-conditional-headers-for-blob-service-operations>`_.
        To fail if the destination already exists, use a conditional request with If-None-Match: "*".

        :param request_id_parameter: Provides a client-generated, opaque value with a 1 KB character
         limit that is recorded in the analytics logs when storage analytics logging is enabled. Default
         value is None.
        :type request_id_parameter: str
        :param timeout: The timeout parameter is expressed in seconds. For more information, see
         :code:`<a
         href="https://docs.microsoft.com/en-us/rest/api/storageservices/fileservices/setting-timeouts-for-blob-service-operations">Setting
         Timeouts for Blob Service Operations.</a>`. Default value is None.
        :type timeout: int
        :param resource: Required only for Create File and Create Directory. The value must be "file"
         or "directory". Default value is None.
        :type resource: str or ~azure.storage.filedatalake.models.PathResourceType
        :param continuation: Optional.  When deleting a directory, the number of paths that are deleted
         with each invocation is limited.  If the number of paths to be deleted exceeds this limit, a
         continuation token is returned in this response header.  When a continuation token is returned
         in the response, it must be specified in a subsequent invocation of the delete operation to
         continue deleting the directory. Default value is None.
        :type continuation: str
        :param mode: Optional. Valid only when namespace is enabled. This parameter determines the
         behavior of the rename operation. The value must be "legacy" or "posix", and the default value
         will be "posix". Default value is None.
        :type mode: str or ~azure.storage.filedatalake.models.PathRenameMode
        :param rename_source: An optional file or directory to be renamed.  The value must have the
         following format: "/{filesystem}/{path}".  If "x-ms-properties" is specified, the properties
         will overwrite the existing properties; otherwise, the existing properties will be preserved.
         This value must be a URL percent-encoded string. Note that the string may only contain ASCII
         characters in the ISO-8859-1 character set. Default value is None.
        :type rename_source: str
        :param source_lease_id: A lease ID for the source path. If specified, the source path must have
         an active lease and the lease ID must match. Default value is None.
        :type source_lease_id: str
        :param properties: Optional. User-defined properties to be stored with the filesystem, in the
         format of a comma-separated list of name and value pairs "n1=v1, n2=v2, ...", where each value
         is a base64 encoded string. Note that the string may only contain ASCII characters in the
         ISO-8859-1 character set.  If the filesystem exists, any properties not included in the list
         will be removed.  All properties are removed if the header is omitted.  To merge new and
         existing properties, first get all existing properties and the current E-Tag, then make a
         conditional request with the E-Tag and include values for all properties. Default value is
         None.
        :type properties: str
        :param permissions: Optional and only valid if Hierarchical Namespace is enabled for the
         account. Sets POSIX access permissions for the file owner, the file owning group, and others.
         Each class may be granted read, write, or execute permission.  The sticky bit is also
         supported.  Both symbolic (rwxrw-rw-) and 4-digit octal notation (e.g. 0766) are supported.
         Default value is None.
        :type permissions: str
        :param umask: Optional and only valid if Hierarchical Namespace is enabled for the account.
         When creating a file or directory and the parent folder does not have a default ACL, the umask
         restricts the permissions of the file or directory to be created.  The resulting permission is
         given by p bitwise and not u, where p is the permission and u is the umask.  For example, if p
         is 0777 and u is 0057, then the resulting permission is 0720.  The default permission is 0777
         for a directory and 0666 for a file.  The default umask is 0027.  The umask must be specified
         in 4-digit octal notation (e.g. 0766). Default value is None.
        :type umask: str
        :param owner: Optional. The owner of the blob or directory. Default value is None.
        :type owner: str
        :param group: Optional. The owning group of the blob or directory. Default value is None.
        :type group: str
        :param acl: Sets POSIX access control rights on files and directories. The value is a
         comma-separated list of access control entries. Each access control entry (ACE) consists of a
         scope, a type, a user or group identifier, and permissions in the format
         "[scope:][type]:[id]:[permissions]". Default value is None.
        :type acl: str
        :param proposed_lease_id: Proposed lease ID, in a GUID string format. The Blob service returns
         400 (Invalid request) if the proposed lease ID is not in the correct format. See Guid
         Constructor (String) for a list of valid GUID string formats. Default value is None.
        :type proposed_lease_id: str
        :param lease_duration: The lease duration is required to acquire a lease, and specifies the
         duration of the lease in seconds.  The lease duration must be between 15 and 60 seconds or -1
         for infinite lease. Default value is None.
        :type lease_duration: long
        :param expiry_options: Required. Indicates mode of the expiry time. Default value is None.
        :type expiry_options: str or ~azure.storage.filedatalake.models.PathExpiryOptions
        :param expires_on: The time to set the blob to expiry. Default value is None.
        :type expires_on: str
        :param path_http_headers: Parameter group. Default value is None.
        :type path_http_headers: ~azure.storage.filedatalake.models.PathHTTPHeaders
        :param lease_access_conditions: Parameter group. Default value is None.
        :type lease_access_conditions: ~azure.storage.filedatalake.models.LeaseAccessConditions
        :param modified_access_conditions: Parameter group. Default value is None.
        :type modified_access_conditions: ~azure.storage.filedatalake.models.ModifiedAccessConditions
        :param source_modified_access_conditions: Parameter group. Default value is None.
        :type source_modified_access_conditions:
         ~azure.storage.filedatalake.models.SourceModifiedAccessConditions
        :param cpk_info: Parameter group. Default value is None.
        :type cpk_info: ~azure.storage.filedatalake.models.CpkInfo
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: None, or the result of cls(response)
        :rtype: None
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls = kwargs.pop('cls', None)  # type: ClsType[None]

        _cache_control = None
        _content_encoding = None
        _content_language = None
        _content_disposition = None
        _content_type_parameter = None
        _lease_id = None
        _if_match = None
        _if_none_match = None
        _if_modified_since = None
        _if_unmodified_since = None
        _source_if_match = None
        _source_if_none_match = None
        _source_if_modified_since = None
        _source_if_unmodified_since = None
        _encryption_key = None
        _encryption_key_sha256 = None
        encryption_algorithm = None
        if path_http_headers is not None:
            _cache_control = path_http_headers.cache_control
            _content_encoding = path_http_headers.content_encoding
            _content_language = path_http_headers.content_language
            _content_disposition = path_http_headers.content_disposition
            _content_type_parameter = path_http_headers.content_type
        if lease_access_conditions is not None:
            _lease_id = lease_access_conditions.lease_id
        if modified_access_conditions is not None:
            _if_match = modified_access_conditions.if_match
            _if_none_match = modified_access_conditions.if_none_match
            _if_modified_since = modified_access_conditions.if_modified_since
            _if_unmodified_since = modified_access_conditions.if_unmodified_since
        if source_modified_access_conditions is not None:
            _source_if_match = source_modified_access_conditions.source_if_match
            _source_if_none_match = source_modified_access_conditions.source_if_none_match
            _source_if_modified_since = source_modified_access_conditions.source_if_modified_since
            _source_if_unmodified_since = source_modified_access_conditions.source_if_unmodified_since
        if cpk_info is not None:
            _encryption_key = cpk_info.encryption_key
            _encryption_key_sha256 = cpk_info.encryption_key_sha256
            encryption_algorithm = cpk_info.encryption_algorithm

        request = build_create_request(
            url=self._config.url,
            version=self._config.version,
            request_id_parameter=request_id_parameter,
            timeout=timeout,
            resource=resource,
            continuation=continuation,
            mode=mode,
            cache_control=_cache_control,
            content_encoding=_content_encoding,
            content_language=_content_language,
            content_disposition=_content_disposition,
            content_type_parameter=_content_type_parameter,
            rename_source=rename_source,
            lease_id=_lease_id,
            source_lease_id=source_lease_id,
            properties=properties,
            permissions=permissions,
            umask=umask,
            if_match=_if_match,
            if_none_match=_if_none_match,
            if_modified_since=_if_modified_since,
            if_unmodified_since=_if_unmodified_since,
            source_if_match=_source_if_match,
            source_if_none_match=_source_if_none_match,
            source_if_modified_since=_source_if_modified_since,
            source_if_unmodified_since=_source_if_unmodified_since,
            encryption_key=_encryption_key,
            encryption_key_sha256=_encryption_key_sha256,
            encryption_algorithm=encryption_algorithm,
            owner=owner,
            group=group,
            acl=acl,
            proposed_lease_id=proposed_lease_id,
            lease_duration=lease_duration,
            expiry_options=expiry_options,
            expires_on=expires_on,
            template_url=self.create.metadata['url'],
            headers=_headers,
            params=_params,
        )
        request = _convert_request(request)
        request.url = self._client.format_url(request.url)  # type: ignore

        pipeline_response = self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
            request,
            stream=False,
            **kwargs
        )
        response = pipeline_response.http_response

        if response.status_code not in [201]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize.failsafe_deserialize(_models.StorageError, pipeline_response)
            raise HttpResponseError(response=response, model=error)

        response_headers = {}
        response_headers['Date']=self._deserialize('rfc-1123', response.headers.get('Date'))
        response_headers['ETag']=self._deserialize('str', response.headers.get('ETag'))
        response_headers['Last-Modified']=self._deserialize('rfc-1123', response.headers.get('Last-Modified'))
        response_headers['x-ms-request-id']=self._deserialize('str', response.headers.get('x-ms-request-id'))
        response_headers['x-ms-version']=self._deserialize('str', response.headers.get('x-ms-version'))
        response_headers['x-ms-continuation']=self._deserialize('str', response.headers.get('x-ms-continuation'))
        response_headers['Content-Length']=self._deserialize('long', response.headers.get('Content-Length'))
        response_headers['x-ms-request-server-encrypted']=self._deserialize('bool', response.headers.get('x-ms-request-server-encrypted'))
        response_headers['x-ms-encryption-key-sha256']=self._deserialize('str', response.headers.get('x-ms-encryption-key-sha256'))


        if cls:
            return cls(pipeline_response, None, response_headers)

    create.metadata = {'url': "{url}/{filesystem}/{path}"}  # type: ignore


    @distributed_trace
    def update(
        self,
        action,  # type: Union[str, "_models.PathUpdateAction"]
        mode,  # type: Union[str, "_models.PathSetAccessControlRecursiveMode"]
        body,  # type: IO
        request_id_parameter=None,  # type: Optional[str]
        timeout=None,  # type: Optional[int]
        max_records=None,  # type: Optional[int]
        continuation=None,  # type: Optional[str]
        force_flag=None,  # type: Optional[bool]
        position=None,  # type: Optional[int]
        retain_uncommitted_data=None,  # type: Optional[bool]
        close=None,  # type: Optional[bool]
        content_length=None,  # type: Optional[int]
        properties=None,  # type: Optional[str]
        owner=None,  # type: Optional[str]
        group=None,  # type: Optional[str]
        permissions=None,  # type: Optional[str]
        acl=None,  # type: Optional[str]
        path_http_headers=None,  # type: Optional[_models.PathHTTPHeaders]
        lease_access_conditions=None,  # type: Optional[_models.LeaseAccessConditions]
        modified_access_conditions=None,  # type: Optional[_models.ModifiedAccessConditions]
        **kwargs  # type: Any
    ):
        # type: (...) -> Optional[_models.SetAccessControlRecursiveResponse]
        """Append Data | Flush Data | Set Properties | Set Access Control.

        Uploads data to be appended to a file, flushes (writes) previously uploaded data to a file,
        sets properties for a file or directory, or sets access control for a file or directory. Data
        can only be appended to a file. Concurrent writes to the same file using multiple clients are
        not supported. This operation supports conditional HTTP requests. For more information, see
        `Specifying Conditional Headers for Blob Service Operations
        <https://docs.microsoft.com/en-us/rest/api/storageservices/specifying-conditional-headers-for-blob-service-operations>`_.

        :param action: The action must be "append" to upload data to be appended to a file, "flush" to
         flush previously uploaded data to a file, "setProperties" to set the properties of a file or
         directory, "setAccessControl" to set the owner, group, permissions, or access control list for
         a file or directory, or  "setAccessControlRecursive" to set the access control list for a
         directory recursively. Note that Hierarchical Namespace must be enabled for the account in
         order to use access control.  Also note that the Access Control List (ACL) includes permissions
         for the owner, owning group, and others, so the x-ms-permissions and x-ms-acl request headers
         are mutually exclusive.
        :type action: str or ~azure.storage.filedatalake.models.PathUpdateAction
        :param mode: Mode "set" sets POSIX access control rights on files and directories, "modify"
         modifies one or more POSIX access control rights  that pre-exist on files and directories,
         "remove" removes one or more POSIX access control rights  that were present earlier on files
         and directories.
        :type mode: str or ~azure.storage.filedatalake.models.PathSetAccessControlRecursiveMode
        :param body: Initial data.
        :type body: IO
        :param request_id_parameter: Provides a client-generated, opaque value with a 1 KB character
         limit that is recorded in the analytics logs when storage analytics logging is enabled. Default
         value is None.
        :type request_id_parameter: str
        :param timeout: The timeout parameter is expressed in seconds. For more information, see
         :code:`<a
         href="https://docs.microsoft.com/en-us/rest/api/storageservices/fileservices/setting-timeouts-for-blob-service-operations">Setting
         Timeouts for Blob Service Operations.</a>`. Default value is None.
        :type timeout: int
        :param max_records: Optional. Valid for "SetAccessControlRecursive" operation. It specifies the
         maximum number of files or directories on which the acl change will be applied. If omitted or
         greater than 2,000, the request will process up to 2,000 items. Default value is None.
        :type max_records: int
        :param continuation: Optional. The number of paths processed with each invocation is limited.
         If the number of paths to be processed exceeds this limit, a continuation token is returned in
         the response header x-ms-continuation. When a continuation token is  returned in the response,
         it must be percent-encoded and specified in a subsequent invocation of
         setAccessControlRecursive operation. Default value is None.
        :type continuation: str
        :param force_flag: Optional. Valid for "SetAccessControlRecursive" operation. If set to false,
         the operation will terminate quickly on encountering user errors (4XX). If true, the operation
         will ignore user errors and proceed with the operation on other sub-entities of the directory.
         Continuation token will only be returned when forceFlag is true in case of user errors. If not
         set the default value is false for this.
        :type force_flag: bool
        :param position: This parameter allows the caller to upload data in parallel and control the
         order in which it is appended to the file.  It is required when uploading data to be appended
         to the file and when flushing previously uploaded data to the file.  The value must be the
         position where the data is to be appended.  Uploaded data is not immediately flushed, or
         written, to the file.  To flush, the previously uploaded data must be contiguous, the position
         parameter must be specified and equal to the length of the file after all data has been
         written, and there must not be a request entity body included with the request. Default value
         is None.
        :type position: long
        :param retain_uncommitted_data: Valid only for flush operations.  If "true", uncommitted data
         is retained after the flush operation completes; otherwise, the uncommitted data is deleted
         after the flush operation.  The default is false.  Data at offsets less than the specified
         position are written to the file when flush succeeds, but this optional parameter allows data
         after the flush position to be retained for a future flush operation.
        :type retain_uncommitted_data: bool
        :param close: Azure Storage Events allow applications to receive notifications when files
         change. When Azure Storage Events are enabled, a file changed event is raised. This event has a
         property indicating whether this is the final change to distinguish the difference between an
         intermediate flush to a file stream and the final close of a file stream. The close query
         parameter is valid only when the action is "flush" and change notifications are enabled. If the
         value of close is "true" and the flush operation completes successfully, the service raises a
         file change notification with a property indicating that this is the final update (the file
         stream has been closed). If "false" a change notification is raised indicating the file has
         changed. The default is false. This query parameter is set to true by the Hadoop ABFS driver to
         indicate that the file stream has been closed.".
        :type close: bool
        :param content_length: Required for "Append Data" and "Flush Data".  Must be 0 for "Flush
         Data".  Must be the length of the request content in bytes for "Append Data". Default value is
         None.
        :type content_length: long
        :param properties: Optional. User-defined properties to be stored with the filesystem, in the
         format of a comma-separated list of name and value pairs "n1=v1, n2=v2, ...", where each value
         is a base64 encoded string. Note that the string may only contain ASCII characters in the
         ISO-8859-1 character set.  If the filesystem exists, any properties not included in the list
         will be removed.  All properties are removed if the header is omitted.  To merge new and
         existing properties, first get all existing properties and the current E-Tag, then make a
         conditional request with the E-Tag and include values for all properties. Default value is
         None.
        :type properties: str
        :param owner: Optional. The owner of the blob or directory. Default value is None.
        :type owner: str
        :param group: Optional. The owning group of the blob or directory. Default value is None.
        :type group: str
        :param permissions: Optional and only valid if Hierarchical Namespace is enabled for the
         account. Sets POSIX access permissions for the file owner, the file owning group, and others.
         Each class may be granted read, write, or execute permission.  The sticky bit is also
         supported.  Both symbolic (rwxrw-rw-) and 4-digit octal notation (e.g. 0766) are supported.
         Default value is None.
        :type permissions: str
        :param acl: Sets POSIX access control rights on files and directories. The value is a
         comma-separated list of access control entries. Each access control entry (ACE) consists of a
         scope, a type, a user or group identifier, and permissions in the format
         "[scope:][type]:[id]:[permissions]". Default value is None.
        :type acl: str
        :param path_http_headers: Parameter group. Default value is None.
        :type path_http_headers: ~azure.storage.filedatalake.models.PathHTTPHeaders
        :param lease_access_conditions: Parameter group. Default value is None.
        :type lease_access_conditions: ~azure.storage.filedatalake.models.LeaseAccessConditions
        :param modified_access_conditions: Parameter group. Default value is None.
        :type modified_access_conditions: ~azure.storage.filedatalake.models.ModifiedAccessConditions
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: SetAccessControlRecursiveResponse, or the result of cls(response)
        :rtype: ~azure.storage.filedatalake.models.SetAccessControlRecursiveResponse or None
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type = kwargs.pop('content_type', _headers.pop('Content-Type', "application/octet-stream"))  # type: Optional[str]
        cls = kwargs.pop('cls', None)  # type: ClsType[Optional[_models.SetAccessControlRecursiveResponse]]

        _content_md5 = None
        _lease_id = None
        _cache_control = None
        _content_type_parameter = None
        _content_disposition = None
        _content_encoding = None
        _content_language = None
        _if_match = None
        _if_none_match = None
        _if_modified_since = None
        _if_unmodified_since = None
        if path_http_headers is not None:
            _content_md5 = path_http_headers.content_md5
        if lease_access_conditions is not None:
            _lease_id = lease_access_conditions.lease_id
        if path_http_headers is not None:
            _cache_control = path_http_headers.cache_control
            _content_type_parameter = path_http_headers.content_type
            _content_disposition = path_http_headers.content_disposition
            _content_encoding = path_http_headers.content_encoding
            _content_language = path_http_headers.content_language
        if modified_access_conditions is not None:
            _if_match = modified_access_conditions.if_match
            _if_none_match = modified_access_conditions.if_none_match
            _if_modified_since = modified_access_conditions.if_modified_since
            _if_unmodified_since = modified_access_conditions.if_unmodified_since
        _content = body

        request = build_update_request(
            url=self._config.url,
            version=self._config.version,
            content_type=content_type,
            content=_content,
            action=action,
            mode=mode,
            request_id_parameter=request_id_parameter,
            timeout=timeout,
            max_records=max_records,
            continuation=continuation,
            force_flag=force_flag,
            position=position,
            retain_uncommitted_data=retain_uncommitted_data,
            close=close,
            content_length=content_length,
            content_md5=_content_md5,
            lease_id=_lease_id,
            cache_control=_cache_control,
            content_type_parameter=_content_type_parameter,
            content_disposition=_content_disposition,
            content_encoding=_content_encoding,
            content_language=_content_language,
            properties=properties,
            owner=owner,
            group=group,
            permissions=permissions,
            acl=acl,
            if_match=_if_match,
            if_none_match=_if_none_match,
            if_modified_since=_if_modified_since,
            if_unmodified_since=_if_unmodified_since,
            template_url=self.update.metadata['url'],
            headers=_headers,
            params=_params,
        )
        request = _convert_request(request)
        request.url = self._client.format_url(request.url)  # type: ignore

        pipeline_response = self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
            request,
            stream=False,
            **kwargs
        )
        response = pipeline_response.http_response

        if response.status_code not in [200, 202]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize.failsafe_deserialize(_models.StorageError, pipeline_response)
            raise HttpResponseError(response=response, model=error)

        deserialized = None
        response_headers = {}
        if response.status_code == 200:
            response_headers['Date']=self._deserialize('rfc-1123', response.headers.get('Date'))
            response_headers['ETag']=self._deserialize('str', response.headers.get('ETag'))
            response_headers['Last-Modified']=self._deserialize('rfc-1123', response.headers.get('Last-Modified'))
            response_headers['Accept-Ranges']=self._deserialize('str', response.headers.get('Accept-Ranges'))
            response_headers['Cache-Control']=self._deserialize('str', response.headers.get('Cache-Control'))
            response_headers['Content-Disposition']=self._deserialize('str', response.headers.get('Content-Disposition'))
            response_headers['Content-Encoding']=self._deserialize('str', response.headers.get('Content-Encoding'))
            response_headers['Content-Language']=self._deserialize('str', response.headers.get('Content-Language'))
            response_headers['Content-Length']=self._deserialize('long', response.headers.get('Content-Length'))
            response_headers['Content-Range']=self._deserialize('str', response.headers.get('Content-Range'))
            response_headers['Content-Type']=self._deserialize('str', response.headers.get('Content-Type'))
            response_headers['Content-MD5']=self._deserialize('str', response.headers.get('Content-MD5'))
            response_headers['x-ms-properties']=self._deserialize('str', response.headers.get('x-ms-properties'))
            response_headers['x-ms-continuation']=self._deserialize('str', response.headers.get('x-ms-continuation'))
            response_headers['x-ms-request-id']=self._deserialize('str', response.headers.get('x-ms-request-id'))
            response_headers['x-ms-version']=self._deserialize('str', response.headers.get('x-ms-version'))
            
            deserialized = self._deserialize('SetAccessControlRecursiveResponse', pipeline_response)

        if response.status_code == 202:
            response_headers['Content-MD5']=self._deserialize('str', response.headers.get('Content-MD5'))
            response_headers['Date']=self._deserialize('rfc-1123', response.headers.get('Date'))
            response_headers['x-ms-request-id']=self._deserialize('str', response.headers.get('x-ms-request-id'))
            response_headers['x-ms-version']=self._deserialize('str', response.headers.get('x-ms-version'))
            

        if cls:
            return cls(pipeline_response, deserialized, response_headers)

        return deserialized

    update.metadata = {'url': "{url}/{filesystem}/{path}"}  # type: ignore


    @distributed_trace
    def lease(  # pylint: disable=inconsistent-return-statements
        self,
        x_ms_lease_action,  # type: Union[str, "_models.PathLeaseAction"]
        request_id_parameter=None,  # type: Optional[str]
        timeout=None,  # type: Optional[int]
        x_ms_lease_break_period=None,  # type: Optional[int]
        proposed_lease_id=None,  # type: Optional[str]
        lease_access_conditions=None,  # type: Optional[_models.LeaseAccessConditions]
        modified_access_conditions=None,  # type: Optional[_models.ModifiedAccessConditions]
        **kwargs  # type: Any
    ):
        # type: (...) -> None
        """Lease Path.

        Create and manage a lease to restrict write and delete access to the path. This operation
        supports conditional HTTP requests.  For more information, see `Specifying Conditional Headers
        for Blob Service Operations
        <https://docs.microsoft.com/en-us/rest/api/storageservices/specifying-conditional-headers-for-blob-service-operations>`_.

        :param x_ms_lease_action: There are five lease actions: "acquire", "break", "change", "renew",
         and "release". Use "acquire" and specify the "x-ms-proposed-lease-id" and "x-ms-lease-duration"
         to acquire a new lease. Use "break" to break an existing lease. When a lease is broken, the
         lease break period is allowed to elapse, during which time no lease operation except break and
         release can be performed on the file. When a lease is successfully broken, the response
         indicates the interval in seconds until a new lease can be acquired. Use "change" and specify
         the current lease ID in "x-ms-lease-id" and the new lease ID in "x-ms-proposed-lease-id" to
         change the lease ID of an active lease. Use "renew" and specify the "x-ms-lease-id" to renew an
         existing lease. Use "release" and specify the "x-ms-lease-id" to release a lease.
        :type x_ms_lease_action: str or ~azure.storage.filedatalake.models.PathLeaseAction
        :param request_id_parameter: Provides a client-generated, opaque value with a 1 KB character
         limit that is recorded in the analytics logs when storage analytics logging is enabled. Default
         value is None.
        :type request_id_parameter: str
        :param timeout: The timeout parameter is expressed in seconds. For more information, see
         :code:`<a
         href="https://docs.microsoft.com/en-us/rest/api/storageservices/fileservices/setting-timeouts-for-blob-service-operations">Setting
         Timeouts for Blob Service Operations.</a>`. Default value is None.
        :type timeout: int
        :param x_ms_lease_break_period: The lease break period duration is optional to break a lease,
         and  specifies the break period of the lease in seconds.  The lease break  duration must be
         between 0 and 60 seconds. Default value is None.
        :type x_ms_lease_break_period: int
        :param proposed_lease_id: Proposed lease ID, in a GUID string format. The Blob service returns
         400 (Invalid request) if the proposed lease ID is not in the correct format. See Guid
         Constructor (String) for a list of valid GUID string formats. Default value is None.
        :type proposed_lease_id: str
        :param lease_access_conditions: Parameter group. Default value is None.
        :type lease_access_conditions: ~azure.storage.filedatalake.models.LeaseAccessConditions
        :param modified_access_conditions: Parameter group. Default value is None.
        :type modified_access_conditions: ~azure.storage.filedatalake.models.ModifiedAccessConditions
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: None, or the result of cls(response)
        :rtype: None
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls = kwargs.pop('cls', None)  # type: ClsType[None]

        _lease_id = None
        _if_match = None
        _if_none_match = None
        _if_modified_since = None
        _if_unmodified_since = None
        if lease_access_conditions is not None:
            _lease_id = lease_access_conditions.lease_id
        if modified_access_conditions is not None:
            _if_match = modified_access_conditions.if_match
            _if_none_match = modified_access_conditions.if_none_match
            _if_modified_since = modified_access_conditions.if_modified_since
            _if_unmodified_since = modified_access_conditions.if_unmodified_since

        request = build_lease_request(
            url=self._config.url,
            version=self._config.version,
            x_ms_lease_action=x_ms_lease_action,
            request_id_parameter=request_id_parameter,
            timeout=timeout,
            x_ms_lease_duration=self._config.x_ms_lease_duration,
            x_ms_lease_break_period=x_ms_lease_break_period,
            lease_id=_lease_id,
            proposed_lease_id=proposed_lease_id,
            if_match=_if_match,
            if_none_match=_if_none_match,
            if_modified_since=_if_modified_since,
            if_unmodified_since=_if_unmodified_since,
            template_url=self.lease.metadata['url'],
            headers=_headers,
            params=_params,
        )
        request = _convert_request(request)
        request.url = self._client.format_url(request.url)  # type: ignore

        pipeline_response = self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
            request,
            stream=False,
            **kwargs
        )
        response = pipeline_response.http_response

        if response.status_code not in [200, 201, 202]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize.failsafe_deserialize(_models.StorageError, pipeline_response)
            raise HttpResponseError(response=response, model=error)

        response_headers = {}
        if response.status_code == 200:
            response_headers['Date']=self._deserialize('rfc-1123', response.headers.get('Date'))
            response_headers['ETag']=self._deserialize('str', response.headers.get('ETag'))
            response_headers['Last-Modified']=self._deserialize('rfc-1123', response.headers.get('Last-Modified'))
            response_headers['x-ms-request-id']=self._deserialize('str', response.headers.get('x-ms-request-id'))
            response_headers['x-ms-version']=self._deserialize('str', response.headers.get('x-ms-version'))
            response_headers['x-ms-lease-id']=self._deserialize('str', response.headers.get('x-ms-lease-id'))
            

        if response.status_code == 201:
            response_headers['Date']=self._deserialize('rfc-1123', response.headers.get('Date'))
            response_headers['ETag']=self._deserialize('str', response.headers.get('ETag'))
            response_headers['Last-Modified']=self._deserialize('rfc-1123', response.headers.get('Last-Modified'))
            response_headers['x-ms-request-id']=self._deserialize('str', response.headers.get('x-ms-request-id'))
            response_headers['x-ms-version']=self._deserialize('str', response.headers.get('x-ms-version'))
            response_headers['x-ms-lease-id']=self._deserialize('str', response.headers.get('x-ms-lease-id'))
            

        if response.status_code == 202:
            response_headers['ETag']=self._deserialize('str', response.headers.get('ETag'))
            response_headers['Last-Modified']=self._deserialize('rfc-1123', response.headers.get('Last-Modified'))
            response_headers['x-ms-request-id']=self._deserialize('str', response.headers.get('x-ms-request-id'))
            response_headers['x-ms-version']=self._deserialize('str', response.headers.get('x-ms-version'))
            response_headers['x-ms-lease-time']=self._deserialize('str', response.headers.get('x-ms-lease-time'))
            

        if cls:
            return cls(pipeline_response, None, response_headers)

    lease.metadata = {'url': "{url}/{filesystem}/{path}"}  # type: ignore


    @distributed_trace
    def read(
        self,
        request_id_parameter=None,  # type: Optional[str]
        timeout=None,  # type: Optional[int]
        range=None,  # type: Optional[str]
        x_ms_range_get_content_md5=None,  # type: Optional[bool]
        lease_access_conditions=None,  # type: Optional[_models.LeaseAccessConditions]
        modified_access_conditions=None,  # type: Optional[_models.ModifiedAccessConditions]
        cpk_info=None,  # type: Optional[_models.CpkInfo]
        **kwargs  # type: Any
    ):
        # type: (...) -> IO
        """Read File.

        Read the contents of a file.  For read operations, range requests are supported. This operation
        supports conditional HTTP requests.  For more information, see `Specifying Conditional Headers
        for Blob Service Operations
        <https://docs.microsoft.com/en-us/rest/api/storageservices/specifying-conditional-headers-for-blob-service-operations>`_.

        :param request_id_parameter: Provides a client-generated, opaque value with a 1 KB character
         limit that is recorded in the analytics logs when storage analytics logging is enabled. Default
         value is None.
        :type request_id_parameter: str
        :param timeout: The timeout parameter is expressed in seconds. For more information, see
         :code:`<a
         href="https://docs.microsoft.com/en-us/rest/api/storageservices/fileservices/setting-timeouts-for-blob-service-operations">Setting
         Timeouts for Blob Service Operations.</a>`. Default value is None.
        :type timeout: int
        :param range: The HTTP Range request header specifies one or more byte ranges of the resource
         to be retrieved. Default value is None.
        :type range: str
        :param x_ms_range_get_content_md5: Optional. When this header is set to "true" and specified
         together with the Range header, the service returns the MD5 hash for the range, as long as the
         range is less than or equal to 4MB in size. If this header is specified without the Range
         header, the service returns status code 400 (Bad Request). If this header is set to true when
         the range exceeds 4 MB in size, the service returns status code 400 (Bad Request). Default
         value is None.
        :type x_ms_range_get_content_md5: bool
        :param lease_access_conditions: Parameter group. Default value is None.
        :type lease_access_conditions: ~azure.storage.filedatalake.models.LeaseAccessConditions
        :param modified_access_conditions: Parameter group. Default value is None.
        :type modified_access_conditions: ~azure.storage.filedatalake.models.ModifiedAccessConditions
        :param cpk_info: Parameter group. Default value is None.
        :type cpk_info: ~azure.storage.filedatalake.models.CpkInfo
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: IO, or the result of cls(response)
        :rtype: IO
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls = kwargs.pop('cls', None)  # type: ClsType[IO]

        _lease_id = None
        _if_match = None
        _if_none_match = None
        _if_modified_since = None
        _if_unmodified_since = None
        _encryption_key = None
        _encryption_key_sha256 = None
        encryption_algorithm = None
        if lease_access_conditions is not None:
            _lease_id = lease_access_conditions.lease_id
        if modified_access_conditions is not None:
            _if_match = modified_access_conditions.if_match
            _if_none_match = modified_access_conditions.if_none_match
            _if_modified_since = modified_access_conditions.if_modified_since
            _if_unmodified_since = modified_access_conditions.if_unmodified_since
        if cpk_info is not None:
            _encryption_key = cpk_info.encryption_key
            _encryption_key_sha256 = cpk_info.encryption_key_sha256
            encryption_algorithm = cpk_info.encryption_algorithm

        request = build_read_request(
            url=self._config.url,
            version=self._config.version,
            request_id_parameter=request_id_parameter,
            timeout=timeout,
            range=range,
            lease_id=_lease_id,
            x_ms_range_get_content_md5=x_ms_range_get_content_md5,
            if_match=_if_match,
            if_none_match=_if_none_match,
            if_modified_since=_if_modified_since,
            if_unmodified_since=_if_unmodified_since,
            encryption_key=_encryption_key,
            encryption_key_sha256=_encryption_key_sha256,
            encryption_algorithm=encryption_algorithm,
            template_url=self.read.metadata['url'],
            headers=_headers,
            params=_params,
        )
        request = _convert_request(request)
        request.url = self._client.format_url(request.url)  # type: ignore

        pipeline_response = self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
            request,
            stream=True,
            **kwargs
        )
        response = pipeline_response.http_response

        if response.status_code not in [200, 206]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize.failsafe_deserialize(_models.StorageError, pipeline_response)
            raise HttpResponseError(response=response, model=error)

        response_headers = {}
        if response.status_code == 200:
            response_headers['Accept-Ranges']=self._deserialize('str', response.headers.get('Accept-Ranges'))
            response_headers['Cache-Control']=self._deserialize('str', response.headers.get('Cache-Control'))
            response_headers['Content-Disposition']=self._deserialize('str', response.headers.get('Content-Disposition'))
            response_headers['Content-Encoding']=self._deserialize('str', response.headers.get('Content-Encoding'))
            response_headers['Content-Language']=self._deserialize('str', response.headers.get('Content-Language'))
            response_headers['Content-Length']=self._deserialize('long', response.headers.get('Content-Length'))
            response_headers['Content-Range']=self._deserialize('str', response.headers.get('Content-Range'))
            response_headers['Content-Type']=self._deserialize('str', response.headers.get('Content-Type'))
            response_headers['Content-MD5']=self._deserialize('str', response.headers.get('Content-MD5'))
            response_headers['Date']=self._deserialize('rfc-1123', response.headers.get('Date'))
            response_headers['ETag']=self._deserialize('str', response.headers.get('ETag'))
            response_headers['Last-Modified']=self._deserialize('rfc-1123', response.headers.get('Last-Modified'))
            response_headers['x-ms-request-id']=self._deserialize('str', response.headers.get('x-ms-request-id'))
            response_headers['x-ms-version']=self._deserialize('str', response.headers.get('x-ms-version'))
            response_headers['x-ms-resource-type']=self._deserialize('str', response.headers.get('x-ms-resource-type'))
            response_headers['x-ms-properties']=self._deserialize('str', response.headers.get('x-ms-properties'))
            response_headers['x-ms-lease-duration']=self._deserialize('str', response.headers.get('x-ms-lease-duration'))
            response_headers['x-ms-lease-state']=self._deserialize('str', response.headers.get('x-ms-lease-state'))
            response_headers['x-ms-lease-status']=self._deserialize('str', response.headers.get('x-ms-lease-status'))
            response_headers['x-ms-request-server-encrypted']=self._deserialize('bool', response.headers.get('x-ms-request-server-encrypted'))
            response_headers['x-ms-encryption-key-sha256']=self._deserialize('str', response.headers.get('x-ms-encryption-key-sha256'))
            
            deserialized = response.stream_download(self._client._pipeline)

        if response.status_code == 206:
            response_headers['Accept-Ranges']=self._deserialize('str', response.headers.get('Accept-Ranges'))
            response_headers['Cache-Control']=self._deserialize('str', response.headers.get('Cache-Control'))
            response_headers['Content-Disposition']=self._deserialize('str', response.headers.get('Content-Disposition'))
            response_headers['Content-Encoding']=self._deserialize('str', response.headers.get('Content-Encoding'))
            response_headers['Content-Language']=self._deserialize('str', response.headers.get('Content-Language'))
            response_headers['Content-Length']=self._deserialize('long', response.headers.get('Content-Length'))
            response_headers['Content-Range']=self._deserialize('str', response.headers.get('Content-Range'))
            response_headers['Content-Type']=self._deserialize('str', response.headers.get('Content-Type'))
            response_headers['Content-MD5']=self._deserialize('str', response.headers.get('Content-MD5'))
            response_headers['x-ms-content-md5']=self._deserialize('str', response.headers.get('x-ms-content-md5'))
            response_headers['Date']=self._deserialize('rfc-1123', response.headers.get('Date'))
            response_headers['ETag']=self._deserialize('str', response.headers.get('ETag'))
            response_headers['Last-Modified']=self._deserialize('rfc-1123', response.headers.get('Last-Modified'))
            response_headers['x-ms-request-id']=self._deserialize('str', response.headers.get('x-ms-request-id'))
            response_headers['x-ms-version']=self._deserialize('str', response.headers.get('x-ms-version'))
            response_headers['x-ms-resource-type']=self._deserialize('str', response.headers.get('x-ms-resource-type'))
            response_headers['x-ms-properties']=self._deserialize('str', response.headers.get('x-ms-properties'))
            response_headers['x-ms-lease-duration']=self._deserialize('str', response.headers.get('x-ms-lease-duration'))
            response_headers['x-ms-lease-state']=self._deserialize('str', response.headers.get('x-ms-lease-state'))
            response_headers['x-ms-lease-status']=self._deserialize('str', response.headers.get('x-ms-lease-status'))
            response_headers['x-ms-request-server-encrypted']=self._deserialize('bool', response.headers.get('x-ms-request-server-encrypted'))
            response_headers['x-ms-encryption-key-sha256']=self._deserialize('str', response.headers.get('x-ms-encryption-key-sha256'))
            
            deserialized = response.stream_download(self._client._pipeline)

        if cls:
            return cls(pipeline_response, deserialized, response_headers)

        return deserialized

    read.metadata = {'url': "{url}/{filesystem}/{path}"}  # type: ignore


    @distributed_trace
    def get_properties(  # pylint: disable=inconsistent-return-statements
        self,
        request_id_parameter=None,  # type: Optional[str]
        timeout=None,  # type: Optional[int]
        action=None,  # type: Optional[Union[str, "_models.PathGetPropertiesAction"]]
        upn=None,  # type: Optional[bool]
        lease_access_conditions=None,  # type: Optional[_models.LeaseAccessConditions]
        modified_access_conditions=None,  # type: Optional[_models.ModifiedAccessConditions]
        **kwargs  # type: Any
    ):
        # type: (...) -> None
        """Get Properties | Get Status | Get Access Control List.

        Get Properties returns all system and user defined properties for a path. Get Status returns
        all system defined properties for a path. Get Access Control List returns the access control
        list for a path. This operation supports conditional HTTP requests.  For more information, see
        `Specifying Conditional Headers for Blob Service Operations
        <https://docs.microsoft.com/en-us/rest/api/storageservices/specifying-conditional-headers-for-blob-service-operations>`_.

        :param request_id_parameter: Provides a client-generated, opaque value with a 1 KB character
         limit that is recorded in the analytics logs when storage analytics logging is enabled. Default
         value is None.
        :type request_id_parameter: str
        :param timeout: The timeout parameter is expressed in seconds. For more information, see
         :code:`<a
         href="https://docs.microsoft.com/en-us/rest/api/storageservices/fileservices/setting-timeouts-for-blob-service-operations">Setting
         Timeouts for Blob Service Operations.</a>`. Default value is None.
        :type timeout: int
        :param action: Optional. If the value is "getStatus" only the system defined properties for the
         path are returned. If the value is "getAccessControl" the access control list is returned in
         the response headers (Hierarchical Namespace must be enabled for the account), otherwise the
         properties are returned. Default value is None.
        :type action: str or ~azure.storage.filedatalake.models.PathGetPropertiesAction
        :param upn: Optional. Valid only when Hierarchical Namespace is enabled for the account. If
         "true", the user identity values returned in the x-ms-owner, x-ms-group, and x-ms-acl response
         headers will be transformed from Azure Active Directory Object IDs to User Principal Names.  If
         "false", the values will be returned as Azure Active Directory Object IDs. The default value is
         false. Note that group and application Object IDs are not translated because they do not have
         unique friendly names.
        :type upn: bool
        :param lease_access_conditions: Parameter group. Default value is None.
        :type lease_access_conditions: ~azure.storage.filedatalake.models.LeaseAccessConditions
        :param modified_access_conditions: Parameter group. Default value is None.
        :type modified_access_conditions: ~azure.storage.filedatalake.models.ModifiedAccessConditions
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: None, or the result of cls(response)
        :rtype: None
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls = kwargs.pop('cls', None)  # type: ClsType[None]

        _lease_id = None
        _if_match = None
        _if_none_match = None
        _if_modified_since = None
        _if_unmodified_since = None
        if lease_access_conditions is not None:
            _lease_id = lease_access_conditions.lease_id
        if modified_access_conditions is not None:
            _if_match = modified_access_conditions.if_match
            _if_none_match = modified_access_conditions.if_none_match
            _if_modified_since = modified_access_conditions.if_modified_since
            _if_unmodified_since = modified_access_conditions.if_unmodified_since

        request = build_get_properties_request(
            url=self._config.url,
            version=self._config.version,
            request_id_parameter=request_id_parameter,
            timeout=timeout,
            action=action,
            upn=upn,
            lease_id=_lease_id,
            if_match=_if_match,
            if_none_match=_if_none_match,
            if_modified_since=_if_modified_since,
            if_unmodified_since=_if_unmodified_since,
            template_url=self.get_properties.metadata['url'],
            headers=_headers,
            params=_params,
        )
        request = _convert_request(request)
        request.url = self._client.format_url(request.url)  # type: ignore

        pipeline_response = self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
            request,
            stream=False,
            **kwargs
        )
        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize.failsafe_deserialize(_models.StorageError, pipeline_response)
            raise HttpResponseError(response=response, model=error)

        response_headers = {}
        response_headers['Accept-Ranges']=self._deserialize('str', response.headers.get('Accept-Ranges'))
        response_headers['Cache-Control']=self._deserialize('str', response.headers.get('Cache-Control'))
        response_headers['Content-Disposition']=self._deserialize('str', response.headers.get('Content-Disposition'))
        response_headers['Content-Encoding']=self._deserialize('str', response.headers.get('Content-Encoding'))
        response_headers['Content-Language']=self._deserialize('str', response.headers.get('Content-Language'))
        response_headers['Content-Length']=self._deserialize('long', response.headers.get('Content-Length'))
        response_headers['Content-Range']=self._deserialize('str', response.headers.get('Content-Range'))
        response_headers['Content-Type']=self._deserialize('str', response.headers.get('Content-Type'))
        response_headers['Content-MD5']=self._deserialize('str', response.headers.get('Content-MD5'))
        response_headers['Date']=self._deserialize('rfc-1123', response.headers.get('Date'))
        response_headers['ETag']=self._deserialize('str', response.headers.get('ETag'))
        response_headers['Last-Modified']=self._deserialize('rfc-1123', response.headers.get('Last-Modified'))
        response_headers['x-ms-request-id']=self._deserialize('str', response.headers.get('x-ms-request-id'))
        response_headers['x-ms-version']=self._deserialize('str', response.headers.get('x-ms-version'))
        response_headers['x-ms-resource-type']=self._deserialize('str', response.headers.get('x-ms-resource-type'))
        response_headers['x-ms-properties']=self._deserialize('str', response.headers.get('x-ms-properties'))
        response_headers['x-ms-owner']=self._deserialize('str', response.headers.get('x-ms-owner'))
        response_headers['x-ms-group']=self._deserialize('str', response.headers.get('x-ms-group'))
        response_headers['x-ms-permissions']=self._deserialize('str', response.headers.get('x-ms-permissions'))
        response_headers['x-ms-acl']=self._deserialize('str', response.headers.get('x-ms-acl'))
        response_headers['x-ms-lease-duration']=self._deserialize('str', response.headers.get('x-ms-lease-duration'))
        response_headers['x-ms-lease-state']=self._deserialize('str', response.headers.get('x-ms-lease-state'))
        response_headers['x-ms-lease-status']=self._deserialize('str', response.headers.get('x-ms-lease-status'))


        if cls:
            return cls(pipeline_response, None, response_headers)

    get_properties.metadata = {'url': "{url}/{filesystem}/{path}"}  # type: ignore


    @distributed_trace
    def delete(  # pylint: disable=inconsistent-return-statements
        self,
        request_id_parameter=None,  # type: Optional[str]
        timeout=None,  # type: Optional[int]
        recursive=None,  # type: Optional[bool]
        continuation=None,  # type: Optional[str]
        lease_access_conditions=None,  # type: Optional[_models.LeaseAccessConditions]
        modified_access_conditions=None,  # type: Optional[_models.ModifiedAccessConditions]
        **kwargs  # type: Any
    ):
        # type: (...) -> None
        """Delete File | Delete Directory.

        Delete the file or directory. This operation supports conditional HTTP requests.  For more
        information, see `Specifying Conditional Headers for Blob Service Operations
        <https://docs.microsoft.com/en-us/rest/api/storageservices/specifying-conditional-headers-for-blob-service-operations>`_.

        :param request_id_parameter: Provides a client-generated, opaque value with a 1 KB character
         limit that is recorded in the analytics logs when storage analytics logging is enabled. Default
         value is None.
        :type request_id_parameter: str
        :param timeout: The timeout parameter is expressed in seconds. For more information, see
         :code:`<a
         href="https://docs.microsoft.com/en-us/rest/api/storageservices/fileservices/setting-timeouts-for-blob-service-operations">Setting
         Timeouts for Blob Service Operations.</a>`. Default value is None.
        :type timeout: int
        :param recursive: Required. Default value is None.
        :type recursive: bool
        :param continuation: Optional.  When deleting a directory, the number of paths that are deleted
         with each invocation is limited.  If the number of paths to be deleted exceeds this limit, a
         continuation token is returned in this response header.  When a continuation token is returned
         in the response, it must be specified in a subsequent invocation of the delete operation to
         continue deleting the directory. Default value is None.
        :type continuation: str
        :param lease_access_conditions: Parameter group. Default value is None.
        :type lease_access_conditions: ~azure.storage.filedatalake.models.LeaseAccessConditions
        :param modified_access_conditions: Parameter group. Default value is None.
        :type modified_access_conditions: ~azure.storage.filedatalake.models.ModifiedAccessConditions
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: None, or the result of cls(response)
        :rtype: None
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls = kwargs.pop('cls', None)  # type: ClsType[None]

        _lease_id = None
        _if_match = None
        _if_none_match = None
        _if_modified_since = None
        _if_unmodified_since = None
        if lease_access_conditions is not None:
            _lease_id = lease_access_conditions.lease_id
        if modified_access_conditions is not None:
            _if_match = modified_access_conditions.if_match
            _if_none_match = modified_access_conditions.if_none_match
            _if_modified_since = modified_access_conditions.if_modified_since
            _if_unmodified_since = modified_access_conditions.if_unmodified_since

        request = build_delete_request(
            url=self._config.url,
            version=self._config.version,
            request_id_parameter=request_id_parameter,
            timeout=timeout,
            recursive=recursive,
            continuation=continuation,
            lease_id=_lease_id,
            if_match=_if_match,
            if_none_match=_if_none_match,
            if_modified_since=_if_modified_since,
            if_unmodified_since=_if_unmodified_since,
            template_url=self.delete.metadata['url'],
            headers=_headers,
            params=_params,
        )
        request = _convert_request(request)
        request.url = self._client.format_url(request.url)  # type: ignore

        pipeline_response = self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
            request,
            stream=False,
            **kwargs
        )
        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize.failsafe_deserialize(_models.StorageError, pipeline_response)
            raise HttpResponseError(response=response, model=error)

        response_headers = {}
        response_headers['Date']=self._deserialize('rfc-1123', response.headers.get('Date'))
        response_headers['x-ms-request-id']=self._deserialize('str', response.headers.get('x-ms-request-id'))
        response_headers['x-ms-version']=self._deserialize('str', response.headers.get('x-ms-version'))
        response_headers['x-ms-continuation']=self._deserialize('str', response.headers.get('x-ms-continuation'))
        response_headers['x-ms-deletion-id']=self._deserialize('str', response.headers.get('x-ms-deletion-id'))


        if cls:
            return cls(pipeline_response, None, response_headers)

    delete.metadata = {'url': "{url}/{filesystem}/{path}"}  # type: ignore


    @distributed_trace
    def set_access_control(  # pylint: disable=inconsistent-return-statements
        self,
        timeout=None,  # type: Optional[int]
        owner=None,  # type: Optional[str]
        group=None,  # type: Optional[str]
        permissions=None,  # type: Optional[str]
        acl=None,  # type: Optional[str]
        request_id_parameter=None,  # type: Optional[str]
        lease_access_conditions=None,  # type: Optional[_models.LeaseAccessConditions]
        modified_access_conditions=None,  # type: Optional[_models.ModifiedAccessConditions]
        **kwargs  # type: Any
    ):
        # type: (...) -> None
        """Set the owner, group, permissions, or access control list for a path.

        :param timeout: The timeout parameter is expressed in seconds. For more information, see
         :code:`<a
         href="https://docs.microsoft.com/en-us/rest/api/storageservices/fileservices/setting-timeouts-for-blob-service-operations">Setting
         Timeouts for Blob Service Operations.</a>`. Default value is None.
        :type timeout: int
        :param owner: Optional. The owner of the blob or directory. Default value is None.
        :type owner: str
        :param group: Optional. The owning group of the blob or directory. Default value is None.
        :type group: str
        :param permissions: Optional and only valid if Hierarchical Namespace is enabled for the
         account. Sets POSIX access permissions for the file owner, the file owning group, and others.
         Each class may be granted read, write, or execute permission.  The sticky bit is also
         supported.  Both symbolic (rwxrw-rw-) and 4-digit octal notation (e.g. 0766) are supported.
         Default value is None.
        :type permissions: str
        :param acl: Sets POSIX access control rights on files and directories. The value is a
         comma-separated list of access control entries. Each access control entry (ACE) consists of a
         scope, a type, a user or group identifier, and permissions in the format
         "[scope:][type]:[id]:[permissions]". Default value is None.
        :type acl: str
        :param request_id_parameter: Provides a client-generated, opaque value with a 1 KB character
         limit that is recorded in the analytics logs when storage analytics logging is enabled. Default
         value is None.
        :type request_id_parameter: str
        :param lease_access_conditions: Parameter group. Default value is None.
        :type lease_access_conditions: ~azure.storage.filedatalake.models.LeaseAccessConditions
        :param modified_access_conditions: Parameter group. Default value is None.
        :type modified_access_conditions: ~azure.storage.filedatalake.models.ModifiedAccessConditions
        :keyword action: action. Default value is "setAccessControl". Note that overriding this default
         value may result in unsupported behavior.
        :paramtype action: str
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: None, or the result of cls(response)
        :rtype: None
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

        action = kwargs.pop('action', _params.pop('action', "setAccessControl"))  # type: str
        cls = kwargs.pop('cls', None)  # type: ClsType[None]

        _lease_id = None
        _if_match = None
        _if_none_match = None
        _if_modified_since = None
        _if_unmodified_since = None
        if lease_access_conditions is not None:
            _lease_id = lease_access_conditions.lease_id
        if modified_access_conditions is not None:
            _if_match = modified_access_conditions.if_match
            _if_none_match = modified_access_conditions.if_none_match
            _if_modified_since = modified_access_conditions.if_modified_since
            _if_unmodified_since = modified_access_conditions.if_unmodified_since

        request = build_set_access_control_request(
            url=self._config.url,
            action=action,
            version=self._config.version,
            timeout=timeout,
            lease_id=_lease_id,
            owner=owner,
            group=group,
            permissions=permissions,
            acl=acl,
            if_match=_if_match,
            if_none_match=_if_none_match,
            if_modified_since=_if_modified_since,
            if_unmodified_since=_if_unmodified_since,
            request_id_parameter=request_id_parameter,
            template_url=self.set_access_control.metadata['url'],
            headers=_headers,
            params=_params,
        )
        request = _convert_request(request)
        request.url = self._client.format_url(request.url)  # type: ignore

        pipeline_response = self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
            request,
            stream=False,
            **kwargs
        )
        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize.failsafe_deserialize(_models.StorageError, pipeline_response)
            raise HttpResponseError(response=response, model=error)

        response_headers = {}
        response_headers['Date']=self._deserialize('rfc-1123', response.headers.get('Date'))
        response_headers['ETag']=self._deserialize('str', response.headers.get('ETag'))
        response_headers['Last-Modified']=self._deserialize('rfc-1123', response.headers.get('Last-Modified'))
        response_headers['x-ms-client-request-id']=self._deserialize('str', response.headers.get('x-ms-client-request-id'))
        response_headers['x-ms-request-id']=self._deserialize('str', response.headers.get('x-ms-request-id'))
        response_headers['x-ms-version']=self._deserialize('str', response.headers.get('x-ms-version'))


        if cls:
            return cls(pipeline_response, None, response_headers)

    set_access_control.metadata = {'url': "{url}/{filesystem}/{path}"}  # type: ignore


    @distributed_trace
    def set_access_control_recursive(
        self,
        mode,  # type: Union[str, "_models.PathSetAccessControlRecursiveMode"]
        timeout=None,  # type: Optional[int]
        continuation=None,  # type: Optional[str]
        force_flag=None,  # type: Optional[bool]
        max_records=None,  # type: Optional[int]
        acl=None,  # type: Optional[str]
        request_id_parameter=None,  # type: Optional[str]
        **kwargs  # type: Any
    ):
        # type: (...) -> _models.SetAccessControlRecursiveResponse
        """Set the access control list for a path and sub-paths.

        :param mode: Mode "set" sets POSIX access control rights on files and directories, "modify"
         modifies one or more POSIX access control rights  that pre-exist on files and directories,
         "remove" removes one or more POSIX access control rights  that were present earlier on files
         and directories.
        :type mode: str or ~azure.storage.filedatalake.models.PathSetAccessControlRecursiveMode
        :param timeout: The timeout parameter is expressed in seconds. For more information, see
         :code:`<a
         href="https://docs.microsoft.com/en-us/rest/api/storageservices/fileservices/setting-timeouts-for-blob-service-operations">Setting
         Timeouts for Blob Service Operations.</a>`. Default value is None.
        :type timeout: int
        :param continuation: Optional.  When deleting a directory, the number of paths that are deleted
         with each invocation is limited.  If the number of paths to be deleted exceeds this limit, a
         continuation token is returned in this response header.  When a continuation token is returned
         in the response, it must be specified in a subsequent invocation of the delete operation to
         continue deleting the directory. Default value is None.
        :type continuation: str
        :param force_flag: Optional. Valid for "SetAccessControlRecursive" operation. If set to false,
         the operation will terminate quickly on encountering user errors (4XX). If true, the operation
         will ignore user errors and proceed with the operation on other sub-entities of the directory.
         Continuation token will only be returned when forceFlag is true in case of user errors. If not
         set the default value is false for this.
        :type force_flag: bool
        :param max_records: Optional. It specifies the maximum number of files or directories on which
         the acl change will be applied. If omitted or greater than 2,000, the request will process up
         to 2,000 items. Default value is None.
        :type max_records: int
        :param acl: Sets POSIX access control rights on files and directories. The value is a
         comma-separated list of access control entries. Each access control entry (ACE) consists of a
         scope, a type, a user or group identifier, and permissions in the format
         "[scope:][type]:[id]:[permissions]". Default value is None.
        :type acl: str
        :param request_id_parameter: Provides a client-generated, opaque value with a 1 KB character
         limit that is recorded in the analytics logs when storage analytics logging is enabled. Default
         value is None.
        :type request_id_parameter: str
        :keyword action: action. Default value is "setAccessControlRecursive". Note that overriding
         this default value may result in unsupported behavior.
        :paramtype action: str
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: SetAccessControlRecursiveResponse, or the result of cls(response)
        :rtype: ~azure.storage.filedatalake.models.SetAccessControlRecursiveResponse
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

        action = kwargs.pop('action', _params.pop('action', "setAccessControlRecursive"))  # type: str
        cls = kwargs.pop('cls', None)  # type: ClsType[_models.SetAccessControlRecursiveResponse]

        
        request = build_set_access_control_recursive_request(
            url=self._config.url,
            action=action,
            version=self._config.version,
            mode=mode,
            timeout=timeout,
            continuation=continuation,
            force_flag=force_flag,
            max_records=max_records,
            acl=acl,
            request_id_parameter=request_id_parameter,
            template_url=self.set_access_control_recursive.metadata['url'],
            headers=_headers,
            params=_params,
        )
        request = _convert_request(request)
        request.url = self._client.format_url(request.url)  # type: ignore

        pipeline_response = self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
            request,
            stream=False,
            **kwargs
        )
        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize.failsafe_deserialize(_models.StorageError, pipeline_response)
            raise HttpResponseError(response=response, model=error)

        response_headers = {}
        response_headers['Date']=self._deserialize('rfc-1123', response.headers.get('Date'))
        response_headers['x-ms-client-request-id']=self._deserialize('str', response.headers.get('x-ms-client-request-id'))
        response_headers['x-ms-continuation']=self._deserialize('str', response.headers.get('x-ms-continuation'))
        response_headers['x-ms-request-id']=self._deserialize('str', response.headers.get('x-ms-request-id'))
        response_headers['x-ms-version']=self._deserialize('str', response.headers.get('x-ms-version'))

        deserialized = self._deserialize('SetAccessControlRecursiveResponse', pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, response_headers)

        return deserialized

    set_access_control_recursive.metadata = {'url': "{url}/{filesystem}/{path}"}  # type: ignore


    @distributed_trace
    def flush_data(  # pylint: disable=inconsistent-return-statements
        self,
        timeout=None,  # type: Optional[int]
        position=None,  # type: Optional[int]
        retain_uncommitted_data=None,  # type: Optional[bool]
        close=None,  # type: Optional[bool]
        content_length=None,  # type: Optional[int]
        request_id_parameter=None,  # type: Optional[str]
        path_http_headers=None,  # type: Optional[_models.PathHTTPHeaders]
        lease_access_conditions=None,  # type: Optional[_models.LeaseAccessConditions]
        modified_access_conditions=None,  # type: Optional[_models.ModifiedAccessConditions]
        cpk_info=None,  # type: Optional[_models.CpkInfo]
        **kwargs  # type: Any
    ):
        # type: (...) -> None
        """Set the owner, group, permissions, or access control list for a path.

        :param timeout: The timeout parameter is expressed in seconds. For more information, see
         :code:`<a
         href="https://docs.microsoft.com/en-us/rest/api/storageservices/fileservices/setting-timeouts-for-blob-service-operations">Setting
         Timeouts for Blob Service Operations.</a>`. Default value is None.
        :type timeout: int
        :param position: This parameter allows the caller to upload data in parallel and control the
         order in which it is appended to the file.  It is required when uploading data to be appended
         to the file and when flushing previously uploaded data to the file.  The value must be the
         position where the data is to be appended.  Uploaded data is not immediately flushed, or
         written, to the file.  To flush, the previously uploaded data must be contiguous, the position
         parameter must be specified and equal to the length of the file after all data has been
         written, and there must not be a request entity body included with the request. Default value
         is None.
        :type position: long
        :param retain_uncommitted_data: Valid only for flush operations.  If "true", uncommitted data
         is retained after the flush operation completes; otherwise, the uncommitted data is deleted
         after the flush operation.  The default is false.  Data at offsets less than the specified
         position are written to the file when flush succeeds, but this optional parameter allows data
         after the flush position to be retained for a future flush operation.
        :type retain_uncommitted_data: bool
        :param close: Azure Storage Events allow applications to receive notifications when files
         change. When Azure Storage Events are enabled, a file changed event is raised. This event has a
         property indicating whether this is the final change to distinguish the difference between an
         intermediate flush to a file stream and the final close of a file stream. The close query
         parameter is valid only when the action is "flush" and change notifications are enabled. If the
         value of close is "true" and the flush operation completes successfully, the service raises a
         file change notification with a property indicating that this is the final update (the file
         stream has been closed). If "false" a change notification is raised indicating the file has
         changed. The default is false. This query parameter is set to true by the Hadoop ABFS driver to
         indicate that the file stream has been closed.".
        :type close: bool
        :param content_length: Required for "Append Data" and "Flush Data".  Must be 0 for "Flush
         Data".  Must be the length of the request content in bytes for "Append Data". Default value is
         None.
        :type content_length: long
        :param request_id_parameter: Provides a client-generated, opaque value with a 1 KB character
         limit that is recorded in the analytics logs when storage analytics logging is enabled. Default
         value is None.
        :type request_id_parameter: str
        :param path_http_headers: Parameter group. Default value is None.
        :type path_http_headers: ~azure.storage.filedatalake.models.PathHTTPHeaders
        :param lease_access_conditions: Parameter group. Default value is None.
        :type lease_access_conditions: ~azure.storage.filedatalake.models.LeaseAccessConditions
        :param modified_access_conditions: Parameter group. Default value is None.
        :type modified_access_conditions: ~azure.storage.filedatalake.models.ModifiedAccessConditions
        :param cpk_info: Parameter group. Default value is None.
        :type cpk_info: ~azure.storage.filedatalake.models.CpkInfo
        :keyword action: action. Default value is "flush". Note that overriding this default value may
         result in unsupported behavior.
        :paramtype action: str
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: None, or the result of cls(response)
        :rtype: None
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

        action = kwargs.pop('action', _params.pop('action', "flush"))  # type: str
        cls = kwargs.pop('cls', None)  # type: ClsType[None]

        _content_md5 = None
        _lease_id = None
        _cache_control = None
        _content_type_parameter = None
        _content_disposition = None
        _content_encoding = None
        _content_language = None
        _if_match = None
        _if_none_match = None
        _if_modified_since = None
        _if_unmodified_since = None
        _encryption_key = None
        _encryption_key_sha256 = None
        encryption_algorithm = None
        if path_http_headers is not None:
            _content_md5 = path_http_headers.content_md5
        if lease_access_conditions is not None:
            _lease_id = lease_access_conditions.lease_id
        if path_http_headers is not None:
            _cache_control = path_http_headers.cache_control
            _content_type_parameter = path_http_headers.content_type
            _content_disposition = path_http_headers.content_disposition
            _content_encoding = path_http_headers.content_encoding
            _content_language = path_http_headers.content_language
        if modified_access_conditions is not None:
            _if_match = modified_access_conditions.if_match
            _if_none_match = modified_access_conditions.if_none_match
            _if_modified_since = modified_access_conditions.if_modified_since
            _if_unmodified_since = modified_access_conditions.if_unmodified_since
        if cpk_info is not None:
            _encryption_key = cpk_info.encryption_key
            _encryption_key_sha256 = cpk_info.encryption_key_sha256
            encryption_algorithm = cpk_info.encryption_algorithm

        request = build_flush_data_request(
            url=self._config.url,
            action=action,
            version=self._config.version,
            timeout=timeout,
            position=position,
            retain_uncommitted_data=retain_uncommitted_data,
            close=close,
            content_length=content_length,
            content_md5=_content_md5,
            lease_id=_lease_id,
            cache_control=_cache_control,
            content_type_parameter=_content_type_parameter,
            content_disposition=_content_disposition,
            content_encoding=_content_encoding,
            content_language=_content_language,
            if_match=_if_match,
            if_none_match=_if_none_match,
            if_modified_since=_if_modified_since,
            if_unmodified_since=_if_unmodified_since,
            request_id_parameter=request_id_parameter,
            encryption_key=_encryption_key,
            encryption_key_sha256=_encryption_key_sha256,
            encryption_algorithm=encryption_algorithm,
            template_url=self.flush_data.metadata['url'],
            headers=_headers,
            params=_params,
        )
        request = _convert_request(request)
        request.url = self._client.format_url(request.url)  # type: ignore

        pipeline_response = self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
            request,
            stream=False,
            **kwargs
        )
        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize.failsafe_deserialize(_models.StorageError, pipeline_response)
            raise HttpResponseError(response=response, model=error)

        response_headers = {}
        response_headers['Date']=self._deserialize('rfc-1123', response.headers.get('Date'))
        response_headers['ETag']=self._deserialize('str', response.headers.get('ETag'))
        response_headers['Last-Modified']=self._deserialize('rfc-1123', response.headers.get('Last-Modified'))
        response_headers['Content-Length']=self._deserialize('long', response.headers.get('Content-Length'))
        response_headers['x-ms-client-request-id']=self._deserialize('str', response.headers.get('x-ms-client-request-id'))
        response_headers['x-ms-request-id']=self._deserialize('str', response.headers.get('x-ms-request-id'))
        response_headers['x-ms-version']=self._deserialize('str', response.headers.get('x-ms-version'))
        response_headers['x-ms-request-server-encrypted']=self._deserialize('bool', response.headers.get('x-ms-request-server-encrypted'))
        response_headers['x-ms-encryption-key-sha256']=self._deserialize('str', response.headers.get('x-ms-encryption-key-sha256'))


        if cls:
            return cls(pipeline_response, None, response_headers)

    flush_data.metadata = {'url': "{url}/{filesystem}/{path}"}  # type: ignore


    @distributed_trace
    def append_data(  # pylint: disable=inconsistent-return-statements
        self,
        body,  # type: IO
        position=None,  # type: Optional[int]
        timeout=None,  # type: Optional[int]
        content_length=None,  # type: Optional[int]
        transactional_content_crc64=None,  # type: Optional[bytearray]
        request_id_parameter=None,  # type: Optional[str]
        path_http_headers=None,  # type: Optional[_models.PathHTTPHeaders]
        lease_access_conditions=None,  # type: Optional[_models.LeaseAccessConditions]
        cpk_info=None,  # type: Optional[_models.CpkInfo]
        **kwargs  # type: Any
    ):
        # type: (...) -> None
        """Append data to the file.

        :param body: Initial data.
        :type body: IO
        :param position: This parameter allows the caller to upload data in parallel and control the
         order in which it is appended to the file.  It is required when uploading data to be appended
         to the file and when flushing previously uploaded data to the file.  The value must be the
         position where the data is to be appended.  Uploaded data is not immediately flushed, or
         written, to the file.  To flush, the previously uploaded data must be contiguous, the position
         parameter must be specified and equal to the length of the file after all data has been
         written, and there must not be a request entity body included with the request. Default value
         is None.
        :type position: long
        :param timeout: The timeout parameter is expressed in seconds. For more information, see
         :code:`<a
         href="https://docs.microsoft.com/en-us/rest/api/storageservices/fileservices/setting-timeouts-for-blob-service-operations">Setting
         Timeouts for Blob Service Operations.</a>`. Default value is None.
        :type timeout: int
        :param content_length: Required for "Append Data" and "Flush Data".  Must be 0 for "Flush
         Data".  Must be the length of the request content in bytes for "Append Data". Default value is
         None.
        :type content_length: long
        :param transactional_content_crc64: Specify the transactional crc64 for the body, to be
         validated by the service. Default value is None.
        :type transactional_content_crc64: bytearray
        :param request_id_parameter: Provides a client-generated, opaque value with a 1 KB character
         limit that is recorded in the analytics logs when storage analytics logging is enabled. Default
         value is None.
        :type request_id_parameter: str
        :param path_http_headers: Parameter group. Default value is None.
        :type path_http_headers: ~azure.storage.filedatalake.models.PathHTTPHeaders
        :param lease_access_conditions: Parameter group. Default value is None.
        :type lease_access_conditions: ~azure.storage.filedatalake.models.LeaseAccessConditions
        :param cpk_info: Parameter group. Default value is None.
        :type cpk_info: ~azure.storage.filedatalake.models.CpkInfo
        :keyword action: action. Default value is "append". Note that overriding this default value may
         result in unsupported behavior.
        :paramtype action: str
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: None, or the result of cls(response)
        :rtype: None
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

        action = kwargs.pop('action', _params.pop('action', "append"))  # type: str
        content_type = kwargs.pop('content_type', _headers.pop('Content-Type', "application/json"))  # type: Optional[str]
        cls = kwargs.pop('cls', None)  # type: ClsType[None]

        _transactional_content_hash = None
        _lease_id = None
        _encryption_key = None
        _encryption_key_sha256 = None
        encryption_algorithm = None
        if path_http_headers is not None:
            _transactional_content_hash = path_http_headers.transactional_content_hash
        if lease_access_conditions is not None:
            _lease_id = lease_access_conditions.lease_id
        if cpk_info is not None:
            _encryption_key = cpk_info.encryption_key
            _encryption_key_sha256 = cpk_info.encryption_key_sha256
            encryption_algorithm = cpk_info.encryption_algorithm
        _content = body

        request = build_append_data_request(
            url=self._config.url,
            action=action,
            version=self._config.version,
            content_type=content_type,
            content=_content,
            position=position,
            timeout=timeout,
            content_length=content_length,
            transactional_content_hash=_transactional_content_hash,
            transactional_content_crc64=transactional_content_crc64,
            lease_id=_lease_id,
            request_id_parameter=request_id_parameter,
            encryption_key=_encryption_key,
            encryption_key_sha256=_encryption_key_sha256,
            encryption_algorithm=encryption_algorithm,
            template_url=self.append_data.metadata['url'],
            headers=_headers,
            params=_params,
        )
        request = _convert_request(request)
        request.url = self._client.format_url(request.url)  # type: ignore

        pipeline_response = self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
            request,
            stream=False,
            **kwargs
        )
        response = pipeline_response.http_response

        if response.status_code not in [202]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize.failsafe_deserialize(_models.StorageError, pipeline_response)
            raise HttpResponseError(response=response, model=error)

        response_headers = {}
        response_headers['Date']=self._deserialize('rfc-1123', response.headers.get('Date'))
        response_headers['x-ms-request-id']=self._deserialize('str', response.headers.get('x-ms-request-id'))
        response_headers['x-ms-client-request-id']=self._deserialize('str', response.headers.get('x-ms-client-request-id'))
        response_headers['x-ms-version']=self._deserialize('str', response.headers.get('x-ms-version'))
        response_headers['ETag']=self._deserialize('str', response.headers.get('ETag'))
        response_headers['Content-MD5']=self._deserialize('bytearray', response.headers.get('Content-MD5'))
        response_headers['x-ms-content-crc64']=self._deserialize('bytearray', response.headers.get('x-ms-content-crc64'))
        response_headers['x-ms-request-server-encrypted']=self._deserialize('bool', response.headers.get('x-ms-request-server-encrypted'))
        response_headers['x-ms-encryption-key-sha256']=self._deserialize('str', response.headers.get('x-ms-encryption-key-sha256'))


        if cls:
            return cls(pipeline_response, None, response_headers)

    append_data.metadata = {'url': "{url}/{filesystem}/{path}"}  # type: ignore


    @distributed_trace
    def set_expiry(  # pylint: disable=inconsistent-return-statements
        self,
        expiry_options,  # type: Union[str, "_models.PathExpiryOptions"]
        timeout=None,  # type: Optional[int]
        request_id_parameter=None,  # type: Optional[str]
        expires_on=None,  # type: Optional[str]
        **kwargs  # type: Any
    ):
        # type: (...) -> None
        """Sets the time a blob will expire and be deleted.

        :param expiry_options: Required. Indicates mode of the expiry time.
        :type expiry_options: str or ~azure.storage.filedatalake.models.PathExpiryOptions
        :param timeout: The timeout parameter is expressed in seconds. For more information, see
         :code:`<a
         href="https://docs.microsoft.com/en-us/rest/api/storageservices/fileservices/setting-timeouts-for-blob-service-operations">Setting
         Timeouts for Blob Service Operations.</a>`. Default value is None.
        :type timeout: int
        :param request_id_parameter: Provides a client-generated, opaque value with a 1 KB character
         limit that is recorded in the analytics logs when storage analytics logging is enabled. Default
         value is None.
        :type request_id_parameter: str
        :param expires_on: The time to set the blob to expiry. Default value is None.
        :type expires_on: str
        :keyword comp: comp. Default value is "expiry". Note that overriding this default value may
         result in unsupported behavior.
        :paramtype comp: str
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: None, or the result of cls(response)
        :rtype: None
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

        comp = kwargs.pop('comp', _params.pop('comp', "expiry"))  # type: str
        cls = kwargs.pop('cls', None)  # type: ClsType[None]

        
        request = build_set_expiry_request(
            url=self._config.url,
            comp=comp,
            version=self._config.version,
            expiry_options=expiry_options,
            timeout=timeout,
            request_id_parameter=request_id_parameter,
            expires_on=expires_on,
            template_url=self.set_expiry.metadata['url'],
            headers=_headers,
            params=_params,
        )
        request = _convert_request(request)
        request.url = self._client.format_url(request.url)  # type: ignore

        pipeline_response = self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
            request,
            stream=False,
            **kwargs
        )
        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize.failsafe_deserialize(_models.StorageError, pipeline_response)
            raise HttpResponseError(response=response, model=error)

        response_headers = {}
        response_headers['ETag']=self._deserialize('str', response.headers.get('ETag'))
        response_headers['Last-Modified']=self._deserialize('rfc-1123', response.headers.get('Last-Modified'))
        response_headers['x-ms-client-request-id']=self._deserialize('str', response.headers.get('x-ms-client-request-id'))
        response_headers['x-ms-request-id']=self._deserialize('str', response.headers.get('x-ms-request-id'))
        response_headers['x-ms-version']=self._deserialize('str', response.headers.get('x-ms-version'))
        response_headers['Date']=self._deserialize('rfc-1123', response.headers.get('Date'))


        if cls:
            return cls(pipeline_response, None, response_headers)

    set_expiry.metadata = {'url': "{url}/{filesystem}/{path}"}  # type: ignore


    @distributed_trace
    def undelete(  # pylint: disable=inconsistent-return-statements
        self,
        timeout=None,  # type: Optional[int]
        undelete_source=None,  # type: Optional[str]
        request_id_parameter=None,  # type: Optional[str]
        **kwargs  # type: Any
    ):
        # type: (...) -> None
        """Undelete a path that was previously soft deleted.

        :param timeout: The timeout parameter is expressed in seconds. For more information, see
         :code:`<a
         href="https://docs.microsoft.com/en-us/rest/api/storageservices/fileservices/setting-timeouts-for-blob-service-operations">Setting
         Timeouts for Blob Service Operations.</a>`. Default value is None.
        :type timeout: int
        :param undelete_source: Only for hierarchical namespace enabled accounts. Optional. The path of
         the soft deleted blob to undelete. Default value is None.
        :type undelete_source: str
        :param request_id_parameter: Provides a client-generated, opaque value with a 1 KB character
         limit that is recorded in the analytics logs when storage analytics logging is enabled. Default
         value is None.
        :type request_id_parameter: str
        :keyword comp: comp. Default value is "undelete". Note that overriding this default value may
         result in unsupported behavior.
        :paramtype comp: str
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: None, or the result of cls(response)
        :rtype: None
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

        comp = kwargs.pop('comp', _params.pop('comp', "undelete"))  # type: str
        cls = kwargs.pop('cls', None)  # type: ClsType[None]

        
        request = build_undelete_request(
            url=self._config.url,
            comp=comp,
            version=self._config.version,
            timeout=timeout,
            undelete_source=undelete_source,
            request_id_parameter=request_id_parameter,
            template_url=self.undelete.metadata['url'],
            headers=_headers,
            params=_params,
        )
        request = _convert_request(request)
        request.url = self._client.format_url(request.url)  # type: ignore

        pipeline_response = self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
            request,
            stream=False,
            **kwargs
        )
        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize.failsafe_deserialize(_models.StorageError, pipeline_response)
            raise HttpResponseError(response=response, model=error)

        response_headers = {}
        response_headers['x-ms-client-request-id']=self._deserialize('str', response.headers.get('x-ms-client-request-id'))
        response_headers['x-ms-request-id']=self._deserialize('str', response.headers.get('x-ms-request-id'))
        response_headers['x-ms-resource-type']=self._deserialize('str', response.headers.get('x-ms-resource-type'))
        response_headers['x-ms-version']=self._deserialize('str', response.headers.get('x-ms-version'))
        response_headers['Date']=self._deserialize('rfc-1123', response.headers.get('Date'))


        if cls:
            return cls(pipeline_response, None, response_headers)

    undelete.metadata = {'url': "{url}/{filesystem}/{path}"}  # type: ignore

