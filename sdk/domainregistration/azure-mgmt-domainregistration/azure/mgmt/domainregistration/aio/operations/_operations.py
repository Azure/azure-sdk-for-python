# pylint: disable=line-too-long,useless-suppression,too-many-lines
# coding=utf-8
# --------------------------------------------------------------------------
# Copyright (c) Microsoft Corporation. All rights reserved.
# Licensed under the MIT License. See License.txt in the project root for license information.
# Code generated by Microsoft (R) Python Code Generator.
# Changes may cause incorrect behavior and will be lost if the code is regenerated.
# --------------------------------------------------------------------------
from collections.abc import MutableMapping
from io import IOBase
import json
from typing import Any, AsyncIterator, Callable, IO, Optional, TypeVar, Union, cast, overload
import urllib.parse

from azure.core import AsyncPipelineClient
from azure.core.async_paging import AsyncItemPaged, AsyncList
from azure.core.exceptions import (
    ClientAuthenticationError,
    HttpResponseError,
    ResourceExistsError,
    ResourceNotFoundError,
    ResourceNotModifiedError,
    StreamClosedError,
    StreamConsumedError,
    map_error,
)
from azure.core.pipeline import PipelineResponse
from azure.core.polling import AsyncLROPoller, AsyncNoPolling, AsyncPollingMethod
from azure.core.rest import AsyncHttpResponse, HttpRequest
from azure.core.tracing.decorator import distributed_trace
from azure.core.tracing.decorator_async import distributed_trace_async
from azure.core.utils import case_insensitive_dict
from azure.mgmt.core.exceptions import ARMErrorFormat
from azure.mgmt.core.polling.async_arm_polling import AsyncARMPolling

from ... import models as _models
from ..._utils.model_base import SdkJSONEncoder, _deserialize, _failsafe_deserialize
from ..._utils.serialization import Deserializer, Serializer
from ...operations._operations import (
    build_domain_registration_provider_list_operations_request,
    build_domains_check_availability_request,
    build_domains_create_or_update_ownership_identifier_request,
    build_domains_create_or_update_request,
    build_domains_delete_ownership_identifier_request,
    build_domains_delete_request,
    build_domains_get_control_center_sso_request_request,
    build_domains_get_ownership_identifier_request,
    build_domains_get_request,
    build_domains_list_by_resource_group_request,
    build_domains_list_ownership_identifiers_request,
    build_domains_list_recommendations_request,
    build_domains_list_request,
    build_domains_renew_request,
    build_domains_transfer_out_request,
    build_domains_update_ownership_identifier_request,
    build_domains_update_request,
    build_top_level_domains_get_request,
    build_top_level_domains_list_agreements_request,
    build_top_level_domains_list_request,
)
from .._configuration import DomainRegistrationClientConfiguration

JSON = MutableMapping[str, Any]
T = TypeVar("T")
ClsType = Optional[Callable[[PipelineResponse[HttpRequest, AsyncHttpResponse], T, dict[str, Any]], Any]]
List = list


class DomainsOperations:
    """
    .. warning::
        **DO NOT** instantiate this class directly.

        Instead, you should access the following operations through
        :class:`~azure.mgmt.domainregistration.aio.DomainRegistrationClient`'s
        :attr:`domains` attribute.
    """

    def __init__(self, *args, **kwargs) -> None:
        input_args = list(args)
        self._client: AsyncPipelineClient = input_args.pop(0) if input_args else kwargs.pop("client")
        self._config: DomainRegistrationClientConfiguration = input_args.pop(0) if input_args else kwargs.pop("config")
        self._serialize: Serializer = input_args.pop(0) if input_args else kwargs.pop("serializer")
        self._deserialize: Deserializer = input_args.pop(0) if input_args else kwargs.pop("deserializer")

    @distributed_trace_async
    async def get(self, resource_group_name: str, domain_name: str, **kwargs: Any) -> _models.Domain:
        """Get a domain.

        Description for Get a domain.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param domain_name: Name of the domain. Required.
        :type domain_name: str
        :return: Domain. The Domain is compatible with MutableMapping
        :rtype: ~azure.mgmt.domainregistration.models.Domain
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[_models.Domain] = kwargs.pop("cls", None)

        _request = build_domains_get_request(
            resource_group_name=resource_group_name,
            domain_name=domain_name,
            subscription_id=self._config.subscription_id,
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.base_url", self._config.base_url, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = kwargs.pop("stream", False)
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                try:
                    await response.read()  # Load the body in memory and close the socket
                except (StreamConsumedError, StreamClosedError):
                    pass
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = _failsafe_deserialize(
                _models.DefaultErrorResponse,
                response,
            )
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        if _stream:
            deserialized = response.iter_bytes()
        else:
            deserialized = _deserialize(_models.Domain, response.json())

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore

    async def _create_or_update_initial(
        self, resource_group_name: str, domain_name: str, domain: Union[_models.Domain, JSON, IO[bytes]], **kwargs: Any
    ) -> AsyncIterator[bytes]:
        error_map: MutableMapping = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[AsyncIterator[bytes]] = kwargs.pop("cls", None)

        content_type = content_type or "application/json"
        _content = None
        if isinstance(domain, (IOBase, bytes)):
            _content = domain
        else:
            _content = json.dumps(domain, cls=SdkJSONEncoder, exclude_readonly=True)  # type: ignore

        _request = build_domains_create_or_update_request(
            resource_group_name=resource_group_name,
            domain_name=domain_name,
            subscription_id=self._config.subscription_id,
            content_type=content_type,
            api_version=self._config.api_version,
            content=_content,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.base_url", self._config.base_url, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = True
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200, 202]:
            try:
                await response.read()  # Load the body in memory and close the socket
            except (StreamConsumedError, StreamClosedError):
                pass
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = _failsafe_deserialize(
                _models.DefaultErrorResponse,
                response,
            )
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        response_headers = {}
        if response.status_code == 202:
            response_headers["Location"] = self._deserialize("str", response.headers.get("Location"))

        deserialized = response.iter_bytes()

        if cls:
            return cls(pipeline_response, deserialized, response_headers)  # type: ignore

        return deserialized  # type: ignore

    @overload
    async def begin_create_or_update(
        self,
        resource_group_name: str,
        domain_name: str,
        domain: _models.Domain,
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> AsyncLROPoller[_models.Domain]:
        """Creates or updates a domain.

        Description for Creates or updates a domain.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param domain_name: Name of the domain. Required.
        :type domain_name: str
        :param domain: Domain registration information. Required.
        :type domain: ~azure.mgmt.domainregistration.models.Domain
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: An instance of AsyncLROPoller that returns Domain. The Domain is compatible with
         MutableMapping
        :rtype: ~azure.core.polling.AsyncLROPoller[~azure.mgmt.domainregistration.models.Domain]
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @overload
    async def begin_create_or_update(
        self,
        resource_group_name: str,
        domain_name: str,
        domain: JSON,
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> AsyncLROPoller[_models.Domain]:
        """Creates or updates a domain.

        Description for Creates or updates a domain.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param domain_name: Name of the domain. Required.
        :type domain_name: str
        :param domain: Domain registration information. Required.
        :type domain: JSON
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: An instance of AsyncLROPoller that returns Domain. The Domain is compatible with
         MutableMapping
        :rtype: ~azure.core.polling.AsyncLROPoller[~azure.mgmt.domainregistration.models.Domain]
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @overload
    async def begin_create_or_update(
        self,
        resource_group_name: str,
        domain_name: str,
        domain: IO[bytes],
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> AsyncLROPoller[_models.Domain]:
        """Creates or updates a domain.

        Description for Creates or updates a domain.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param domain_name: Name of the domain. Required.
        :type domain_name: str
        :param domain: Domain registration information. Required.
        :type domain: IO[bytes]
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: An instance of AsyncLROPoller that returns Domain. The Domain is compatible with
         MutableMapping
        :rtype: ~azure.core.polling.AsyncLROPoller[~azure.mgmt.domainregistration.models.Domain]
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @distributed_trace_async
    async def begin_create_or_update(
        self, resource_group_name: str, domain_name: str, domain: Union[_models.Domain, JSON, IO[bytes]], **kwargs: Any
    ) -> AsyncLROPoller[_models.Domain]:
        """Creates or updates a domain.

        Description for Creates or updates a domain.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param domain_name: Name of the domain. Required.
        :type domain_name: str
        :param domain: Domain registration information. Is one of the following types: Domain, JSON,
         IO[bytes] Required.
        :type domain: ~azure.mgmt.domainregistration.models.Domain or JSON or IO[bytes]
        :return: An instance of AsyncLROPoller that returns Domain. The Domain is compatible with
         MutableMapping
        :rtype: ~azure.core.polling.AsyncLROPoller[~azure.mgmt.domainregistration.models.Domain]
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[_models.Domain] = kwargs.pop("cls", None)
        polling: Union[bool, AsyncPollingMethod] = kwargs.pop("polling", True)
        lro_delay = kwargs.pop("polling_interval", self._config.polling_interval)
        cont_token: Optional[str] = kwargs.pop("continuation_token", None)
        if cont_token is None:
            raw_result = await self._create_or_update_initial(
                resource_group_name=resource_group_name,
                domain_name=domain_name,
                domain=domain,
                content_type=content_type,
                cls=lambda x, y, z: x,
                headers=_headers,
                params=_params,
                **kwargs
            )
            await raw_result.http_response.read()  # type: ignore
        kwargs.pop("error_map", None)

        def get_long_running_output(pipeline_response):
            response = pipeline_response.http_response
            deserialized = _deserialize(_models.Domain, response.json())
            if cls:
                return cls(pipeline_response, deserialized, {})  # type: ignore
            return deserialized

        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.base_url", self._config.base_url, "str", skip_quote=True),
        }

        if polling is True:
            polling_method: AsyncPollingMethod = cast(
                AsyncPollingMethod, AsyncARMPolling(lro_delay, path_format_arguments=path_format_arguments, **kwargs)
            )
        elif polling is False:
            polling_method = cast(AsyncPollingMethod, AsyncNoPolling())
        else:
            polling_method = polling
        if cont_token:
            return AsyncLROPoller[_models.Domain].from_continuation_token(
                polling_method=polling_method,
                continuation_token=cont_token,
                client=self._client,
                deserialization_callback=get_long_running_output,
            )
        return AsyncLROPoller[_models.Domain](
            self._client, raw_result, get_long_running_output, polling_method  # type: ignore
        )

    @overload
    async def update(
        self,
        resource_group_name: str,
        domain_name: str,
        domain: _models.DomainPatchResource,
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> _models.Domain:
        """Creates or updates a domain.

        Description for Creates or updates a domain.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param domain_name: Name of the domain. Required.
        :type domain_name: str
        :param domain: Domain registration information. Required.
        :type domain: ~azure.mgmt.domainregistration.models.DomainPatchResource
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: Domain. The Domain is compatible with MutableMapping
        :rtype: ~azure.mgmt.domainregistration.models.Domain
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @overload
    async def update(
        self,
        resource_group_name: str,
        domain_name: str,
        domain: JSON,
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> _models.Domain:
        """Creates or updates a domain.

        Description for Creates or updates a domain.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param domain_name: Name of the domain. Required.
        :type domain_name: str
        :param domain: Domain registration information. Required.
        :type domain: JSON
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: Domain. The Domain is compatible with MutableMapping
        :rtype: ~azure.mgmt.domainregistration.models.Domain
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @overload
    async def update(
        self,
        resource_group_name: str,
        domain_name: str,
        domain: IO[bytes],
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> _models.Domain:
        """Creates or updates a domain.

        Description for Creates or updates a domain.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param domain_name: Name of the domain. Required.
        :type domain_name: str
        :param domain: Domain registration information. Required.
        :type domain: IO[bytes]
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: Domain. The Domain is compatible with MutableMapping
        :rtype: ~azure.mgmt.domainregistration.models.Domain
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @distributed_trace_async
    async def update(
        self,
        resource_group_name: str,
        domain_name: str,
        domain: Union[_models.DomainPatchResource, JSON, IO[bytes]],
        **kwargs: Any
    ) -> _models.Domain:
        """Creates or updates a domain.

        Description for Creates or updates a domain.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param domain_name: Name of the domain. Required.
        :type domain_name: str
        :param domain: Domain registration information. Is one of the following types:
         DomainPatchResource, JSON, IO[bytes] Required.
        :type domain: ~azure.mgmt.domainregistration.models.DomainPatchResource or JSON or IO[bytes]
        :return: Domain. The Domain is compatible with MutableMapping
        :rtype: ~azure.mgmt.domainregistration.models.Domain
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[_models.Domain] = kwargs.pop("cls", None)

        content_type = content_type or "application/json"
        _content = None
        if isinstance(domain, (IOBase, bytes)):
            _content = domain
        else:
            _content = json.dumps(domain, cls=SdkJSONEncoder, exclude_readonly=True)  # type: ignore

        _request = build_domains_update_request(
            resource_group_name=resource_group_name,
            domain_name=domain_name,
            subscription_id=self._config.subscription_id,
            content_type=content_type,
            api_version=self._config.api_version,
            content=_content,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.base_url", self._config.base_url, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = kwargs.pop("stream", False)
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200, 202]:
            if _stream:
                try:
                    await response.read()  # Load the body in memory and close the socket
                except (StreamConsumedError, StreamClosedError):
                    pass
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = _failsafe_deserialize(
                _models.DefaultErrorResponse,
                response,
            )
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        response_headers = {}
        if response.status_code == 202:
            response_headers["Retry-After"] = self._deserialize("int", response.headers.get("Retry-After"))

        if _stream:
            deserialized = response.iter_bytes()
        else:
            deserialized = _deserialize(_models.Domain, response.json())

        if cls:
            return cls(pipeline_response, deserialized, response_headers)  # type: ignore

        return deserialized  # type: ignore

    @distributed_trace_async
    async def delete(
        self,
        resource_group_name: str,
        domain_name: str,
        *,
        force_hard_delete_domain: Optional[bool] = None,
        **kwargs: Any
    ) -> None:
        """Delete a domain.

        Description for Delete a domain.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param domain_name: Name of the domain. Required.
        :type domain_name: str
        :keyword force_hard_delete_domain: Specify <code>true</code> to delete the domain immediately.
         The default is <code>false</code> which deletes the domain after 24 hours. Default value is
         None.
        :paramtype force_hard_delete_domain: bool
        :return: None
        :rtype: None
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[None] = kwargs.pop("cls", None)

        _request = build_domains_delete_request(
            resource_group_name=resource_group_name,
            domain_name=domain_name,
            subscription_id=self._config.subscription_id,
            force_hard_delete_domain=force_hard_delete_domain,
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.base_url", self._config.base_url, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = False
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200, 204]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = _failsafe_deserialize(
                _models.DefaultErrorResponse,
                response,
            )
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        if cls:
            return cls(pipeline_response, None, {})  # type: ignore

    @distributed_trace
    def list_by_resource_group(self, resource_group_name: str, **kwargs: Any) -> AsyncItemPaged["_models.Domain"]:
        """Get all domains in a resource group.

        Description for Get all domains in a resource group.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :return: An iterator like instance of Domain
        :rtype: ~azure.core.async_paging.AsyncItemPaged[~azure.mgmt.domainregistration.models.Domain]
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[List[_models.Domain]] = kwargs.pop("cls", None)

        error_map: MutableMapping = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        def prepare_request(next_link=None):
            if not next_link:

                _request = build_domains_list_by_resource_group_request(
                    resource_group_name=resource_group_name,
                    subscription_id=self._config.subscription_id,
                    api_version=self._config.api_version,
                    headers=_headers,
                    params=_params,
                )
                path_format_arguments = {
                    "endpoint": self._serialize.url(
                        "self._config.base_url", self._config.base_url, "str", skip_quote=True
                    ),
                }
                _request.url = self._client.format_url(_request.url, **path_format_arguments)

            else:
                # make call to next link with the client's api-version
                _parsed_next_link = urllib.parse.urlparse(next_link)
                _next_request_params = case_insensitive_dict(
                    {
                        key: [urllib.parse.quote(v) for v in value]
                        for key, value in urllib.parse.parse_qs(_parsed_next_link.query).items()
                    }
                )
                _next_request_params["api-version"] = self._config.api_version
                _request = HttpRequest(
                    "GET", urllib.parse.urljoin(next_link, _parsed_next_link.path), params=_next_request_params
                )
                path_format_arguments = {
                    "endpoint": self._serialize.url(
                        "self._config.base_url", self._config.base_url, "str", skip_quote=True
                    ),
                }
                _request.url = self._client.format_url(_request.url, **path_format_arguments)

            return _request

        async def extract_data(pipeline_response):
            deserialized = pipeline_response.http_response.json()
            list_of_elem = _deserialize(List[_models.Domain], deserialized.get("value", []))
            if cls:
                list_of_elem = cls(list_of_elem)  # type: ignore
            return deserialized.get("nextLink") or None, AsyncList(list_of_elem)

        async def get_next(next_link=None):
            _request = prepare_request(next_link)

            _stream = False
            pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
                _request, stream=_stream, **kwargs
            )
            response = pipeline_response.http_response

            if response.status_code not in [200]:
                map_error(status_code=response.status_code, response=response, error_map=error_map)
                error = _failsafe_deserialize(
                    _models.DefaultErrorResponse,
                    response,
                )
                raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

            return pipeline_response

        return AsyncItemPaged(get_next, extract_data)

    @distributed_trace
    def list(self, **kwargs: Any) -> AsyncItemPaged["_models.Domain"]:
        """Get all domains in a subscription.

        Description for Get all domains in a subscription.

        :return: An iterator like instance of Domain
        :rtype: ~azure.core.async_paging.AsyncItemPaged[~azure.mgmt.domainregistration.models.Domain]
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[List[_models.Domain]] = kwargs.pop("cls", None)

        error_map: MutableMapping = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        def prepare_request(next_link=None):
            if not next_link:

                _request = build_domains_list_request(
                    subscription_id=self._config.subscription_id,
                    api_version=self._config.api_version,
                    headers=_headers,
                    params=_params,
                )
                path_format_arguments = {
                    "endpoint": self._serialize.url(
                        "self._config.base_url", self._config.base_url, "str", skip_quote=True
                    ),
                }
                _request.url = self._client.format_url(_request.url, **path_format_arguments)

            else:
                # make call to next link with the client's api-version
                _parsed_next_link = urllib.parse.urlparse(next_link)
                _next_request_params = case_insensitive_dict(
                    {
                        key: [urllib.parse.quote(v) for v in value]
                        for key, value in urllib.parse.parse_qs(_parsed_next_link.query).items()
                    }
                )
                _next_request_params["api-version"] = self._config.api_version
                _request = HttpRequest(
                    "GET", urllib.parse.urljoin(next_link, _parsed_next_link.path), params=_next_request_params
                )
                path_format_arguments = {
                    "endpoint": self._serialize.url(
                        "self._config.base_url", self._config.base_url, "str", skip_quote=True
                    ),
                }
                _request.url = self._client.format_url(_request.url, **path_format_arguments)

            return _request

        async def extract_data(pipeline_response):
            deserialized = pipeline_response.http_response.json()
            list_of_elem = _deserialize(List[_models.Domain], deserialized.get("value", []))
            if cls:
                list_of_elem = cls(list_of_elem)  # type: ignore
            return deserialized.get("nextLink") or None, AsyncList(list_of_elem)

        async def get_next(next_link=None):
            _request = prepare_request(next_link)

            _stream = False
            pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
                _request, stream=_stream, **kwargs
            )
            response = pipeline_response.http_response

            if response.status_code not in [200]:
                map_error(status_code=response.status_code, response=response, error_map=error_map)
                error = _failsafe_deserialize(
                    _models.DefaultErrorResponse,
                    response,
                )
                raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

            return pipeline_response

        return AsyncItemPaged(get_next, extract_data)

    @distributed_trace_async
    async def renew(self, resource_group_name: str, domain_name: str, **kwargs: Any) -> None:
        """Renew a domain.

        Description for Renew a domain.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param domain_name: Name of the domain. Required.
        :type domain_name: str
        :return: None
        :rtype: None
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[None] = kwargs.pop("cls", None)

        _request = build_domains_renew_request(
            resource_group_name=resource_group_name,
            domain_name=domain_name,
            subscription_id=self._config.subscription_id,
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.base_url", self._config.base_url, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = False
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200, 202, 204]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = _failsafe_deserialize(
                _models.DefaultErrorResponse,
                response,
            )
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        response_headers = {}
        if response.status_code == 202:
            response_headers["Retry-After"] = self._deserialize("int", response.headers.get("Retry-After"))

        if cls:
            return cls(pipeline_response, None, response_headers)  # type: ignore

    @distributed_trace_async
    async def transfer_out(self, resource_group_name: str, domain_name: str, **kwargs: Any) -> _models.Domain:
        """Transfer out domain to another registrar.

        Transfer out domain to another registrar.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param domain_name: Name of the domain. Required.
        :type domain_name: str
        :return: Domain. The Domain is compatible with MutableMapping
        :rtype: ~azure.mgmt.domainregistration.models.Domain
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[_models.Domain] = kwargs.pop("cls", None)

        _request = build_domains_transfer_out_request(
            resource_group_name=resource_group_name,
            domain_name=domain_name,
            subscription_id=self._config.subscription_id,
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.base_url", self._config.base_url, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = kwargs.pop("stream", False)
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                try:
                    await response.read()  # Load the body in memory and close the socket
                except (StreamConsumedError, StreamClosedError):
                    pass
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = _failsafe_deserialize(
                _models.DefaultErrorResponse,
                response,
            )
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        if _stream:
            deserialized = response.iter_bytes()
        else:
            deserialized = _deserialize(_models.Domain, response.json())

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore

    @distributed_trace_async
    async def get_ownership_identifier(
        self, resource_group_name: str, domain_name: str, name: str, **kwargs: Any
    ) -> _models.DomainOwnershipIdentifier:
        """Get ownership identifier for domain.

        Description for Get ownership identifier for domain.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param domain_name: Name of the domain. Required.
        :type domain_name: str
        :param name: Name of identifier. Required.
        :type name: str
        :return: DomainOwnershipIdentifier. The DomainOwnershipIdentifier is compatible with
         MutableMapping
        :rtype: ~azure.mgmt.domainregistration.models.DomainOwnershipIdentifier
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[_models.DomainOwnershipIdentifier] = kwargs.pop("cls", None)

        _request = build_domains_get_ownership_identifier_request(
            resource_group_name=resource_group_name,
            domain_name=domain_name,
            name=name,
            subscription_id=self._config.subscription_id,
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.base_url", self._config.base_url, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = kwargs.pop("stream", False)
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                try:
                    await response.read()  # Load the body in memory and close the socket
                except (StreamConsumedError, StreamClosedError):
                    pass
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = _failsafe_deserialize(
                _models.DefaultErrorResponse,
                response,
            )
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        if _stream:
            deserialized = response.iter_bytes()
        else:
            deserialized = _deserialize(_models.DomainOwnershipIdentifier, response.json())

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore

    @overload
    async def create_or_update_ownership_identifier(
        self,
        resource_group_name: str,
        domain_name: str,
        name: str,
        domain_ownership_identifier: _models.DomainOwnershipIdentifier,
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> _models.DomainOwnershipIdentifier:
        """Creates an ownership identifier for a domain or updates identifier details for an existing
        identifier.

        Description for Creates an ownership identifier for a domain or updates identifier details for
        an existing identifier.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param domain_name: Name of the domain. Required.
        :type domain_name: str
        :param name: Name of identifier. Required.
        :type name: str
        :param domain_ownership_identifier: A JSON representation of the domain ownership properties.
         Required.
        :type domain_ownership_identifier:
         ~azure.mgmt.domainregistration.models.DomainOwnershipIdentifier
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: DomainOwnershipIdentifier. The DomainOwnershipIdentifier is compatible with
         MutableMapping
        :rtype: ~azure.mgmt.domainregistration.models.DomainOwnershipIdentifier
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @overload
    async def create_or_update_ownership_identifier(
        self,
        resource_group_name: str,
        domain_name: str,
        name: str,
        domain_ownership_identifier: JSON,
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> _models.DomainOwnershipIdentifier:
        """Creates an ownership identifier for a domain or updates identifier details for an existing
        identifier.

        Description for Creates an ownership identifier for a domain or updates identifier details for
        an existing identifier.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param domain_name: Name of the domain. Required.
        :type domain_name: str
        :param name: Name of identifier. Required.
        :type name: str
        :param domain_ownership_identifier: A JSON representation of the domain ownership properties.
         Required.
        :type domain_ownership_identifier: JSON
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: DomainOwnershipIdentifier. The DomainOwnershipIdentifier is compatible with
         MutableMapping
        :rtype: ~azure.mgmt.domainregistration.models.DomainOwnershipIdentifier
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @overload
    async def create_or_update_ownership_identifier(
        self,
        resource_group_name: str,
        domain_name: str,
        name: str,
        domain_ownership_identifier: IO[bytes],
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> _models.DomainOwnershipIdentifier:
        """Creates an ownership identifier for a domain or updates identifier details for an existing
        identifier.

        Description for Creates an ownership identifier for a domain or updates identifier details for
        an existing identifier.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param domain_name: Name of the domain. Required.
        :type domain_name: str
        :param name: Name of identifier. Required.
        :type name: str
        :param domain_ownership_identifier: A JSON representation of the domain ownership properties.
         Required.
        :type domain_ownership_identifier: IO[bytes]
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: DomainOwnershipIdentifier. The DomainOwnershipIdentifier is compatible with
         MutableMapping
        :rtype: ~azure.mgmt.domainregistration.models.DomainOwnershipIdentifier
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @distributed_trace_async
    async def create_or_update_ownership_identifier(
        self,
        resource_group_name: str,
        domain_name: str,
        name: str,
        domain_ownership_identifier: Union[_models.DomainOwnershipIdentifier, JSON, IO[bytes]],
        **kwargs: Any
    ) -> _models.DomainOwnershipIdentifier:
        """Creates an ownership identifier for a domain or updates identifier details for an existing
        identifier.

        Description for Creates an ownership identifier for a domain or updates identifier details for
        an existing identifier.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param domain_name: Name of the domain. Required.
        :type domain_name: str
        :param name: Name of identifier. Required.
        :type name: str
        :param domain_ownership_identifier: A JSON representation of the domain ownership properties.
         Is one of the following types: DomainOwnershipIdentifier, JSON, IO[bytes] Required.
        :type domain_ownership_identifier:
         ~azure.mgmt.domainregistration.models.DomainOwnershipIdentifier or JSON or IO[bytes]
        :return: DomainOwnershipIdentifier. The DomainOwnershipIdentifier is compatible with
         MutableMapping
        :rtype: ~azure.mgmt.domainregistration.models.DomainOwnershipIdentifier
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[_models.DomainOwnershipIdentifier] = kwargs.pop("cls", None)

        content_type = content_type or "application/json"
        _content = None
        if isinstance(domain_ownership_identifier, (IOBase, bytes)):
            _content = domain_ownership_identifier
        else:
            _content = json.dumps(domain_ownership_identifier, cls=SdkJSONEncoder, exclude_readonly=True)  # type: ignore

        _request = build_domains_create_or_update_ownership_identifier_request(
            resource_group_name=resource_group_name,
            domain_name=domain_name,
            name=name,
            subscription_id=self._config.subscription_id,
            content_type=content_type,
            api_version=self._config.api_version,
            content=_content,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.base_url", self._config.base_url, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = kwargs.pop("stream", False)
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                try:
                    await response.read()  # Load the body in memory and close the socket
                except (StreamConsumedError, StreamClosedError):
                    pass
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = _failsafe_deserialize(
                _models.DefaultErrorResponse,
                response,
            )
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        if _stream:
            deserialized = response.iter_bytes()
        else:
            deserialized = _deserialize(_models.DomainOwnershipIdentifier, response.json())

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore

    @overload
    async def update_ownership_identifier(
        self,
        resource_group_name: str,
        domain_name: str,
        name: str,
        domain_ownership_identifier: _models.DomainOwnershipIdentifier,
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> _models.DomainOwnershipIdentifier:
        """Creates an ownership identifier for a domain or updates identifier details for an existing
        identifier.

        Description for Creates an ownership identifier for a domain or updates identifier details for
        an existing identifier.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param domain_name: Name of the domain. Required.
        :type domain_name: str
        :param name: Name of identifier. Required.
        :type name: str
        :param domain_ownership_identifier: A JSON representation of the domain ownership properties.
         Required.
        :type domain_ownership_identifier:
         ~azure.mgmt.domainregistration.models.DomainOwnershipIdentifier
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: DomainOwnershipIdentifier. The DomainOwnershipIdentifier is compatible with
         MutableMapping
        :rtype: ~azure.mgmt.domainregistration.models.DomainOwnershipIdentifier
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @overload
    async def update_ownership_identifier(
        self,
        resource_group_name: str,
        domain_name: str,
        name: str,
        domain_ownership_identifier: JSON,
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> _models.DomainOwnershipIdentifier:
        """Creates an ownership identifier for a domain or updates identifier details for an existing
        identifier.

        Description for Creates an ownership identifier for a domain or updates identifier details for
        an existing identifier.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param domain_name: Name of the domain. Required.
        :type domain_name: str
        :param name: Name of identifier. Required.
        :type name: str
        :param domain_ownership_identifier: A JSON representation of the domain ownership properties.
         Required.
        :type domain_ownership_identifier: JSON
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: DomainOwnershipIdentifier. The DomainOwnershipIdentifier is compatible with
         MutableMapping
        :rtype: ~azure.mgmt.domainregistration.models.DomainOwnershipIdentifier
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @overload
    async def update_ownership_identifier(
        self,
        resource_group_name: str,
        domain_name: str,
        name: str,
        domain_ownership_identifier: IO[bytes],
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> _models.DomainOwnershipIdentifier:
        """Creates an ownership identifier for a domain or updates identifier details for an existing
        identifier.

        Description for Creates an ownership identifier for a domain or updates identifier details for
        an existing identifier.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param domain_name: Name of the domain. Required.
        :type domain_name: str
        :param name: Name of identifier. Required.
        :type name: str
        :param domain_ownership_identifier: A JSON representation of the domain ownership properties.
         Required.
        :type domain_ownership_identifier: IO[bytes]
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: DomainOwnershipIdentifier. The DomainOwnershipIdentifier is compatible with
         MutableMapping
        :rtype: ~azure.mgmt.domainregistration.models.DomainOwnershipIdentifier
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @distributed_trace_async
    async def update_ownership_identifier(
        self,
        resource_group_name: str,
        domain_name: str,
        name: str,
        domain_ownership_identifier: Union[_models.DomainOwnershipIdentifier, JSON, IO[bytes]],
        **kwargs: Any
    ) -> _models.DomainOwnershipIdentifier:
        """Creates an ownership identifier for a domain or updates identifier details for an existing
        identifier.

        Description for Creates an ownership identifier for a domain or updates identifier details for
        an existing identifier.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param domain_name: Name of the domain. Required.
        :type domain_name: str
        :param name: Name of identifier. Required.
        :type name: str
        :param domain_ownership_identifier: A JSON representation of the domain ownership properties.
         Is one of the following types: DomainOwnershipIdentifier, JSON, IO[bytes] Required.
        :type domain_ownership_identifier:
         ~azure.mgmt.domainregistration.models.DomainOwnershipIdentifier or JSON or IO[bytes]
        :return: DomainOwnershipIdentifier. The DomainOwnershipIdentifier is compatible with
         MutableMapping
        :rtype: ~azure.mgmt.domainregistration.models.DomainOwnershipIdentifier
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[_models.DomainOwnershipIdentifier] = kwargs.pop("cls", None)

        content_type = content_type or "application/json"
        _content = None
        if isinstance(domain_ownership_identifier, (IOBase, bytes)):
            _content = domain_ownership_identifier
        else:
            _content = json.dumps(domain_ownership_identifier, cls=SdkJSONEncoder, exclude_readonly=True)  # type: ignore

        _request = build_domains_update_ownership_identifier_request(
            resource_group_name=resource_group_name,
            domain_name=domain_name,
            name=name,
            subscription_id=self._config.subscription_id,
            content_type=content_type,
            api_version=self._config.api_version,
            content=_content,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.base_url", self._config.base_url, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = kwargs.pop("stream", False)
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                try:
                    await response.read()  # Load the body in memory and close the socket
                except (StreamConsumedError, StreamClosedError):
                    pass
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = _failsafe_deserialize(
                _models.DefaultErrorResponse,
                response,
            )
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        if _stream:
            deserialized = response.iter_bytes()
        else:
            deserialized = _deserialize(_models.DomainOwnershipIdentifier, response.json())

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore

    @distributed_trace_async
    async def delete_ownership_identifier(
        self, resource_group_name: str, domain_name: str, name: str, **kwargs: Any
    ) -> None:
        """Delete ownership identifier for domain.

        Description for Delete ownership identifier for domain.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param domain_name: Name of the domain. Required.
        :type domain_name: str
        :param name: Name of identifier. Required.
        :type name: str
        :return: None
        :rtype: None
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[None] = kwargs.pop("cls", None)

        _request = build_domains_delete_ownership_identifier_request(
            resource_group_name=resource_group_name,
            domain_name=domain_name,
            name=name,
            subscription_id=self._config.subscription_id,
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.base_url", self._config.base_url, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = False
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200, 204]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = _failsafe_deserialize(
                _models.DefaultErrorResponse,
                response,
            )
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        if cls:
            return cls(pipeline_response, None, {})  # type: ignore

    @distributed_trace
    def list_ownership_identifiers(
        self, resource_group_name: str, domain_name: str, **kwargs: Any
    ) -> AsyncItemPaged["_models.DomainOwnershipIdentifier"]:
        """Lists domain ownership identifiers.

        Description for Lists domain ownership identifiers.

        :param resource_group_name: The name of the resource group. The name is case insensitive.
         Required.
        :type resource_group_name: str
        :param domain_name: Name of the domain. Required.
        :type domain_name: str
        :return: An iterator like instance of DomainOwnershipIdentifier
        :rtype:
         ~azure.core.async_paging.AsyncItemPaged[~azure.mgmt.domainregistration.models.DomainOwnershipIdentifier]
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[List[_models.DomainOwnershipIdentifier]] = kwargs.pop("cls", None)

        error_map: MutableMapping = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        def prepare_request(next_link=None):
            if not next_link:

                _request = build_domains_list_ownership_identifiers_request(
                    resource_group_name=resource_group_name,
                    domain_name=domain_name,
                    subscription_id=self._config.subscription_id,
                    api_version=self._config.api_version,
                    headers=_headers,
                    params=_params,
                )
                path_format_arguments = {
                    "endpoint": self._serialize.url(
                        "self._config.base_url", self._config.base_url, "str", skip_quote=True
                    ),
                }
                _request.url = self._client.format_url(_request.url, **path_format_arguments)

            else:
                # make call to next link with the client's api-version
                _parsed_next_link = urllib.parse.urlparse(next_link)
                _next_request_params = case_insensitive_dict(
                    {
                        key: [urllib.parse.quote(v) for v in value]
                        for key, value in urllib.parse.parse_qs(_parsed_next_link.query).items()
                    }
                )
                _next_request_params["api-version"] = self._config.api_version
                _request = HttpRequest(
                    "GET", urllib.parse.urljoin(next_link, _parsed_next_link.path), params=_next_request_params
                )
                path_format_arguments = {
                    "endpoint": self._serialize.url(
                        "self._config.base_url", self._config.base_url, "str", skip_quote=True
                    ),
                }
                _request.url = self._client.format_url(_request.url, **path_format_arguments)

            return _request

        async def extract_data(pipeline_response):
            deserialized = pipeline_response.http_response.json()
            list_of_elem = _deserialize(List[_models.DomainOwnershipIdentifier], deserialized.get("value", []))
            if cls:
                list_of_elem = cls(list_of_elem)  # type: ignore
            return deserialized.get("nextLink") or None, AsyncList(list_of_elem)

        async def get_next(next_link=None):
            _request = prepare_request(next_link)

            _stream = False
            pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
                _request, stream=_stream, **kwargs
            )
            response = pipeline_response.http_response

            if response.status_code not in [200]:
                map_error(status_code=response.status_code, response=response, error_map=error_map)
                error = _failsafe_deserialize(
                    _models.DefaultErrorResponse,
                    response,
                )
                raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

            return pipeline_response

        return AsyncItemPaged(get_next, extract_data)

    @overload
    async def check_availability(
        self, identifier: _models.NameIdentifier, *, content_type: str = "application/json", **kwargs: Any
    ) -> _models.DomainAvailabilityCheckResult:
        """Check if a domain is available for registration.

        Description for Check if a domain is available for registration.

        :param identifier: The request body. Required.
        :type identifier: ~azure.mgmt.domainregistration.models.NameIdentifier
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: DomainAvailabilityCheckResult. The DomainAvailabilityCheckResult is compatible with
         MutableMapping
        :rtype: ~azure.mgmt.domainregistration.models.DomainAvailabilityCheckResult
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @overload
    async def check_availability(
        self, identifier: JSON, *, content_type: str = "application/json", **kwargs: Any
    ) -> _models.DomainAvailabilityCheckResult:
        """Check if a domain is available for registration.

        Description for Check if a domain is available for registration.

        :param identifier: The request body. Required.
        :type identifier: JSON
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: DomainAvailabilityCheckResult. The DomainAvailabilityCheckResult is compatible with
         MutableMapping
        :rtype: ~azure.mgmt.domainregistration.models.DomainAvailabilityCheckResult
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @overload
    async def check_availability(
        self, identifier: IO[bytes], *, content_type: str = "application/json", **kwargs: Any
    ) -> _models.DomainAvailabilityCheckResult:
        """Check if a domain is available for registration.

        Description for Check if a domain is available for registration.

        :param identifier: The request body. Required.
        :type identifier: IO[bytes]
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: DomainAvailabilityCheckResult. The DomainAvailabilityCheckResult is compatible with
         MutableMapping
        :rtype: ~azure.mgmt.domainregistration.models.DomainAvailabilityCheckResult
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @distributed_trace_async
    async def check_availability(
        self, identifier: Union[_models.NameIdentifier, JSON, IO[bytes]], **kwargs: Any
    ) -> _models.DomainAvailabilityCheckResult:
        """Check if a domain is available for registration.

        Description for Check if a domain is available for registration.

        :param identifier: The request body. Is one of the following types: NameIdentifier, JSON,
         IO[bytes] Required.
        :type identifier: ~azure.mgmt.domainregistration.models.NameIdentifier or JSON or IO[bytes]
        :return: DomainAvailabilityCheckResult. The DomainAvailabilityCheckResult is compatible with
         MutableMapping
        :rtype: ~azure.mgmt.domainregistration.models.DomainAvailabilityCheckResult
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[_models.DomainAvailabilityCheckResult] = kwargs.pop("cls", None)

        content_type = content_type or "application/json"
        _content = None
        if isinstance(identifier, (IOBase, bytes)):
            _content = identifier
        else:
            _content = json.dumps(identifier, cls=SdkJSONEncoder, exclude_readonly=True)  # type: ignore

        _request = build_domains_check_availability_request(
            subscription_id=self._config.subscription_id,
            content_type=content_type,
            api_version=self._config.api_version,
            content=_content,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.base_url", self._config.base_url, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = kwargs.pop("stream", False)
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                try:
                    await response.read()  # Load the body in memory and close the socket
                except (StreamConsumedError, StreamClosedError):
                    pass
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = _failsafe_deserialize(
                _models.DefaultErrorResponse,
                response,
            )
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        if _stream:
            deserialized = response.iter_bytes()
        else:
            deserialized = _deserialize(_models.DomainAvailabilityCheckResult, response.json())

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore

    @distributed_trace_async
    async def get_control_center_sso_request(self, **kwargs: Any) -> _models.DomainControlCenterSsoRequest:
        """Generate a single sign-on request for the domain management portal.

        Description for Generate a single sign-on request for the domain management portal.

        :return: DomainControlCenterSsoRequest. The DomainControlCenterSsoRequest is compatible with
         MutableMapping
        :rtype: ~azure.mgmt.domainregistration.models.DomainControlCenterSsoRequest
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[_models.DomainControlCenterSsoRequest] = kwargs.pop("cls", None)

        _request = build_domains_get_control_center_sso_request_request(
            subscription_id=self._config.subscription_id,
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.base_url", self._config.base_url, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = kwargs.pop("stream", False)
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                try:
                    await response.read()  # Load the body in memory and close the socket
                except (StreamConsumedError, StreamClosedError):
                    pass
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = _failsafe_deserialize(
                _models.DefaultErrorResponse,
                response,
            )
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        if _stream:
            deserialized = response.iter_bytes()
        else:
            deserialized = _deserialize(_models.DomainControlCenterSsoRequest, response.json())

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore

    @overload
    def list_recommendations(
        self,
        parameters: _models.DomainRecommendationSearchParameters,
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> AsyncItemPaged["_models.NameIdentifier"]:
        """Get domain name recommendations based on keywords.

        Description for Get domain name recommendations based on keywords.

        :param parameters: The request body. Required.
        :type parameters: ~azure.mgmt.domainregistration.models.DomainRecommendationSearchParameters
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: An iterator like instance of NameIdentifier
        :rtype:
         ~azure.core.async_paging.AsyncItemPaged[~azure.mgmt.domainregistration.models.NameIdentifier]
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @overload
    def list_recommendations(
        self, parameters: JSON, *, content_type: str = "application/json", **kwargs: Any
    ) -> AsyncItemPaged["_models.NameIdentifier"]:
        """Get domain name recommendations based on keywords.

        Description for Get domain name recommendations based on keywords.

        :param parameters: The request body. Required.
        :type parameters: JSON
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: An iterator like instance of NameIdentifier
        :rtype:
         ~azure.core.async_paging.AsyncItemPaged[~azure.mgmt.domainregistration.models.NameIdentifier]
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @overload
    def list_recommendations(
        self, parameters: IO[bytes], *, content_type: str = "application/json", **kwargs: Any
    ) -> AsyncItemPaged["_models.NameIdentifier"]:
        """Get domain name recommendations based on keywords.

        Description for Get domain name recommendations based on keywords.

        :param parameters: The request body. Required.
        :type parameters: IO[bytes]
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: An iterator like instance of NameIdentifier
        :rtype:
         ~azure.core.async_paging.AsyncItemPaged[~azure.mgmt.domainregistration.models.NameIdentifier]
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @distributed_trace
    def list_recommendations(
        self, parameters: Union[_models.DomainRecommendationSearchParameters, JSON, IO[bytes]], **kwargs: Any
    ) -> AsyncItemPaged["_models.NameIdentifier"]:
        """Get domain name recommendations based on keywords.

        Description for Get domain name recommendations based on keywords.

        :param parameters: The request body. Is one of the following types:
         DomainRecommendationSearchParameters, JSON, IO[bytes] Required.
        :type parameters: ~azure.mgmt.domainregistration.models.DomainRecommendationSearchParameters or
         JSON or IO[bytes]
        :return: An iterator like instance of NameIdentifier
        :rtype:
         ~azure.core.async_paging.AsyncItemPaged[~azure.mgmt.domainregistration.models.NameIdentifier]
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[List[_models.NameIdentifier]] = kwargs.pop("cls", None)

        error_map: MutableMapping = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})
        content_type = content_type or "application/json"
        _content = None
        if isinstance(parameters, (IOBase, bytes)):
            _content = parameters
        else:
            _content = json.dumps(parameters, cls=SdkJSONEncoder, exclude_readonly=True)  # type: ignore

        def prepare_request(next_link=None):
            if not next_link:

                _request = build_domains_list_recommendations_request(
                    subscription_id=self._config.subscription_id,
                    content_type=content_type,
                    api_version=self._config.api_version,
                    content=_content,
                    headers=_headers,
                    params=_params,
                )
                path_format_arguments = {
                    "endpoint": self._serialize.url(
                        "self._config.base_url", self._config.base_url, "str", skip_quote=True
                    ),
                }
                _request.url = self._client.format_url(_request.url, **path_format_arguments)

            else:
                # make call to next link with the client's api-version
                _parsed_next_link = urllib.parse.urlparse(next_link)
                _next_request_params = case_insensitive_dict(
                    {
                        key: [urllib.parse.quote(v) for v in value]
                        for key, value in urllib.parse.parse_qs(_parsed_next_link.query).items()
                    }
                )
                _next_request_params["api-version"] = self._config.api_version
                _request = HttpRequest(
                    "GET", urllib.parse.urljoin(next_link, _parsed_next_link.path), params=_next_request_params
                )
                path_format_arguments = {
                    "endpoint": self._serialize.url(
                        "self._config.base_url", self._config.base_url, "str", skip_quote=True
                    ),
                }
                _request.url = self._client.format_url(_request.url, **path_format_arguments)

            return _request

        async def extract_data(pipeline_response):
            deserialized = pipeline_response.http_response.json()
            list_of_elem = _deserialize(List[_models.NameIdentifier], deserialized.get("value", []))
            if cls:
                list_of_elem = cls(list_of_elem)  # type: ignore
            return deserialized.get("nextLink") or None, AsyncList(list_of_elem)

        async def get_next(next_link=None):
            _request = prepare_request(next_link)

            _stream = False
            pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
                _request, stream=_stream, **kwargs
            )
            response = pipeline_response.http_response

            if response.status_code not in [200]:
                map_error(status_code=response.status_code, response=response, error_map=error_map)
                error = _failsafe_deserialize(
                    _models.DefaultErrorResponse,
                    response,
                )
                raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

            return pipeline_response

        return AsyncItemPaged(get_next, extract_data)


class TopLevelDomainsOperations:
    """
    .. warning::
        **DO NOT** instantiate this class directly.

        Instead, you should access the following operations through
        :class:`~azure.mgmt.domainregistration.aio.DomainRegistrationClient`'s
        :attr:`top_level_domains` attribute.
    """

    def __init__(self, *args, **kwargs) -> None:
        input_args = list(args)
        self._client: AsyncPipelineClient = input_args.pop(0) if input_args else kwargs.pop("client")
        self._config: DomainRegistrationClientConfiguration = input_args.pop(0) if input_args else kwargs.pop("config")
        self._serialize: Serializer = input_args.pop(0) if input_args else kwargs.pop("serializer")
        self._deserialize: Deserializer = input_args.pop(0) if input_args else kwargs.pop("deserializer")

    @distributed_trace_async
    async def get(self, name: str, **kwargs: Any) -> _models.TopLevelDomain:
        """Get details of a top-level domain.

        Description for Get details of a top-level domain.

        :param name: Name of the top-level domain. Required.
        :type name: str
        :return: TopLevelDomain. The TopLevelDomain is compatible with MutableMapping
        :rtype: ~azure.mgmt.domainregistration.models.TopLevelDomain
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[_models.TopLevelDomain] = kwargs.pop("cls", None)

        _request = build_top_level_domains_get_request(
            name=name,
            subscription_id=self._config.subscription_id,
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.base_url", self._config.base_url, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = kwargs.pop("stream", False)
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                try:
                    await response.read()  # Load the body in memory and close the socket
                except (StreamConsumedError, StreamClosedError):
                    pass
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = _failsafe_deserialize(
                _models.DefaultErrorResponse,
                response,
            )
            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

        if _stream:
            deserialized = response.iter_bytes()
        else:
            deserialized = _deserialize(_models.TopLevelDomain, response.json())

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore

    @distributed_trace
    def list(self, **kwargs: Any) -> AsyncItemPaged["_models.TopLevelDomain"]:
        """Get all top-level domains supported for registration.

        Description for Get all top-level domains supported for registration.

        :return: An iterator like instance of TopLevelDomain
        :rtype:
         ~azure.core.async_paging.AsyncItemPaged[~azure.mgmt.domainregistration.models.TopLevelDomain]
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[List[_models.TopLevelDomain]] = kwargs.pop("cls", None)

        error_map: MutableMapping = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        def prepare_request(next_link=None):
            if not next_link:

                _request = build_top_level_domains_list_request(
                    subscription_id=self._config.subscription_id,
                    api_version=self._config.api_version,
                    headers=_headers,
                    params=_params,
                )
                path_format_arguments = {
                    "endpoint": self._serialize.url(
                        "self._config.base_url", self._config.base_url, "str", skip_quote=True
                    ),
                }
                _request.url = self._client.format_url(_request.url, **path_format_arguments)

            else:
                # make call to next link with the client's api-version
                _parsed_next_link = urllib.parse.urlparse(next_link)
                _next_request_params = case_insensitive_dict(
                    {
                        key: [urllib.parse.quote(v) for v in value]
                        for key, value in urllib.parse.parse_qs(_parsed_next_link.query).items()
                    }
                )
                _next_request_params["api-version"] = self._config.api_version
                _request = HttpRequest(
                    "GET", urllib.parse.urljoin(next_link, _parsed_next_link.path), params=_next_request_params
                )
                path_format_arguments = {
                    "endpoint": self._serialize.url(
                        "self._config.base_url", self._config.base_url, "str", skip_quote=True
                    ),
                }
                _request.url = self._client.format_url(_request.url, **path_format_arguments)

            return _request

        async def extract_data(pipeline_response):
            deserialized = pipeline_response.http_response.json()
            list_of_elem = _deserialize(List[_models.TopLevelDomain], deserialized.get("value", []))
            if cls:
                list_of_elem = cls(list_of_elem)  # type: ignore
            return deserialized.get("nextLink") or None, AsyncList(list_of_elem)

        async def get_next(next_link=None):
            _request = prepare_request(next_link)

            _stream = False
            pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
                _request, stream=_stream, **kwargs
            )
            response = pipeline_response.http_response

            if response.status_code not in [200]:
                map_error(status_code=response.status_code, response=response, error_map=error_map)
                error = _failsafe_deserialize(
                    _models.DefaultErrorResponse,
                    response,
                )
                raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

            return pipeline_response

        return AsyncItemPaged(get_next, extract_data)

    @overload
    def list_agreements(
        self,
        name: str,
        agreement_option: _models.TopLevelDomainAgreementOption,
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> AsyncItemPaged["_models.TldLegalAgreement"]:
        """Gets all legal agreements that user needs to accept before purchasing a domain.

        Description for Gets all legal agreements that user needs to accept before purchasing a domain.

        :param name: Name of the top-level domain. Required.
        :type name: str
        :param agreement_option: Domain agreement options. Required.
        :type agreement_option: ~azure.mgmt.domainregistration.models.TopLevelDomainAgreementOption
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: An iterator like instance of TldLegalAgreement
        :rtype:
         ~azure.core.async_paging.AsyncItemPaged[~azure.mgmt.domainregistration.models.TldLegalAgreement]
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @overload
    def list_agreements(
        self, name: str, agreement_option: JSON, *, content_type: str = "application/json", **kwargs: Any
    ) -> AsyncItemPaged["_models.TldLegalAgreement"]:
        """Gets all legal agreements that user needs to accept before purchasing a domain.

        Description for Gets all legal agreements that user needs to accept before purchasing a domain.

        :param name: Name of the top-level domain. Required.
        :type name: str
        :param agreement_option: Domain agreement options. Required.
        :type agreement_option: JSON
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: An iterator like instance of TldLegalAgreement
        :rtype:
         ~azure.core.async_paging.AsyncItemPaged[~azure.mgmt.domainregistration.models.TldLegalAgreement]
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @overload
    def list_agreements(
        self, name: str, agreement_option: IO[bytes], *, content_type: str = "application/json", **kwargs: Any
    ) -> AsyncItemPaged["_models.TldLegalAgreement"]:
        """Gets all legal agreements that user needs to accept before purchasing a domain.

        Description for Gets all legal agreements that user needs to accept before purchasing a domain.

        :param name: Name of the top-level domain. Required.
        :type name: str
        :param agreement_option: Domain agreement options. Required.
        :type agreement_option: IO[bytes]
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: An iterator like instance of TldLegalAgreement
        :rtype:
         ~azure.core.async_paging.AsyncItemPaged[~azure.mgmt.domainregistration.models.TldLegalAgreement]
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @distributed_trace
    def list_agreements(
        self, name: str, agreement_option: Union[_models.TopLevelDomainAgreementOption, JSON, IO[bytes]], **kwargs: Any
    ) -> AsyncItemPaged["_models.TldLegalAgreement"]:
        """Gets all legal agreements that user needs to accept before purchasing a domain.

        Description for Gets all legal agreements that user needs to accept before purchasing a domain.

        :param name: Name of the top-level domain. Required.
        :type name: str
        :param agreement_option: Domain agreement options. Is one of the following types:
         TopLevelDomainAgreementOption, JSON, IO[bytes] Required.
        :type agreement_option: ~azure.mgmt.domainregistration.models.TopLevelDomainAgreementOption or
         JSON or IO[bytes]
        :return: An iterator like instance of TldLegalAgreement
        :rtype:
         ~azure.core.async_paging.AsyncItemPaged[~azure.mgmt.domainregistration.models.TldLegalAgreement]
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[List[_models.TldLegalAgreement]] = kwargs.pop("cls", None)

        error_map: MutableMapping = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})
        content_type = content_type or "application/json"
        _content = None
        if isinstance(agreement_option, (IOBase, bytes)):
            _content = agreement_option
        else:
            _content = json.dumps(agreement_option, cls=SdkJSONEncoder, exclude_readonly=True)  # type: ignore

        def prepare_request(next_link=None):
            if not next_link:

                _request = build_top_level_domains_list_agreements_request(
                    name=name,
                    subscription_id=self._config.subscription_id,
                    content_type=content_type,
                    api_version=self._config.api_version,
                    content=_content,
                    headers=_headers,
                    params=_params,
                )
                path_format_arguments = {
                    "endpoint": self._serialize.url(
                        "self._config.base_url", self._config.base_url, "str", skip_quote=True
                    ),
                }
                _request.url = self._client.format_url(_request.url, **path_format_arguments)

            else:
                # make call to next link with the client's api-version
                _parsed_next_link = urllib.parse.urlparse(next_link)
                _next_request_params = case_insensitive_dict(
                    {
                        key: [urllib.parse.quote(v) for v in value]
                        for key, value in urllib.parse.parse_qs(_parsed_next_link.query).items()
                    }
                )
                _next_request_params["api-version"] = self._config.api_version
                _request = HttpRequest(
                    "GET", urllib.parse.urljoin(next_link, _parsed_next_link.path), params=_next_request_params
                )
                path_format_arguments = {
                    "endpoint": self._serialize.url(
                        "self._config.base_url", self._config.base_url, "str", skip_quote=True
                    ),
                }
                _request.url = self._client.format_url(_request.url, **path_format_arguments)

            return _request

        async def extract_data(pipeline_response):
            deserialized = pipeline_response.http_response.json()
            list_of_elem = _deserialize(List[_models.TldLegalAgreement], deserialized.get("value", []))
            if cls:
                list_of_elem = cls(list_of_elem)  # type: ignore
            return deserialized.get("nextLink") or None, AsyncList(list_of_elem)

        async def get_next(next_link=None):
            _request = prepare_request(next_link)

            _stream = False
            pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
                _request, stream=_stream, **kwargs
            )
            response = pipeline_response.http_response

            if response.status_code not in [200]:
                map_error(status_code=response.status_code, response=response, error_map=error_map)
                error = _failsafe_deserialize(
                    _models.DefaultErrorResponse,
                    response,
                )
                raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

            return pipeline_response

        return AsyncItemPaged(get_next, extract_data)


class DomainRegistrationProviderOperations:
    """
    .. warning::
        **DO NOT** instantiate this class directly.

        Instead, you should access the following operations through
        :class:`~azure.mgmt.domainregistration.aio.DomainRegistrationClient`'s
        :attr:`domain_registration_provider` attribute.
    """

    def __init__(self, *args, **kwargs) -> None:
        input_args = list(args)
        self._client: AsyncPipelineClient = input_args.pop(0) if input_args else kwargs.pop("client")
        self._config: DomainRegistrationClientConfiguration = input_args.pop(0) if input_args else kwargs.pop("config")
        self._serialize: Serializer = input_args.pop(0) if input_args else kwargs.pop("serializer")
        self._deserialize: Deserializer = input_args.pop(0) if input_args else kwargs.pop("deserializer")

    @distributed_trace
    def list_operations(self, **kwargs: Any) -> AsyncItemPaged["_models.CsmOperationDescription"]:
        """Implements Csm operations Api to exposes the list of available Csm Apis under the resource
        provider.

        Description for Implements Csm operations Api to exposes the list of available Csm Apis under
        the resource provider.

        :return: An iterator like instance of CsmOperationDescription
        :rtype:
         ~azure.core.async_paging.AsyncItemPaged[~azure.mgmt.domainregistration.models.CsmOperationDescription]
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[List[_models.CsmOperationDescription]] = kwargs.pop("cls", None)

        error_map: MutableMapping = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        def prepare_request(next_link=None):
            if not next_link:

                _request = build_domain_registration_provider_list_operations_request(
                    api_version=self._config.api_version,
                    headers=_headers,
                    params=_params,
                )
                path_format_arguments = {
                    "endpoint": self._serialize.url(
                        "self._config.base_url", self._config.base_url, "str", skip_quote=True
                    ),
                }
                _request.url = self._client.format_url(_request.url, **path_format_arguments)

            else:
                # make call to next link with the client's api-version
                _parsed_next_link = urllib.parse.urlparse(next_link)
                _next_request_params = case_insensitive_dict(
                    {
                        key: [urllib.parse.quote(v) for v in value]
                        for key, value in urllib.parse.parse_qs(_parsed_next_link.query).items()
                    }
                )
                _next_request_params["api-version"] = self._config.api_version
                _request = HttpRequest(
                    "GET", urllib.parse.urljoin(next_link, _parsed_next_link.path), params=_next_request_params
                )
                path_format_arguments = {
                    "endpoint": self._serialize.url(
                        "self._config.base_url", self._config.base_url, "str", skip_quote=True
                    ),
                }
                _request.url = self._client.format_url(_request.url, **path_format_arguments)

            return _request

        async def extract_data(pipeline_response):
            deserialized = pipeline_response.http_response.json()
            list_of_elem = _deserialize(List[_models.CsmOperationDescription], deserialized.get("value", []))
            if cls:
                list_of_elem = cls(list_of_elem)  # type: ignore
            return deserialized.get("nextLink") or None, AsyncList(list_of_elem)

        async def get_next(next_link=None):
            _request = prepare_request(next_link)

            _stream = False
            pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
                _request, stream=_stream, **kwargs
            )
            response = pipeline_response.http_response

            if response.status_code not in [200]:
                map_error(status_code=response.status_code, response=response, error_map=error_map)
                error = _failsafe_deserialize(
                    _models.DefaultErrorResponse,
                    response,
                )
                raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)

            return pipeline_response

        return AsyncItemPaged(get_next, extract_data)
