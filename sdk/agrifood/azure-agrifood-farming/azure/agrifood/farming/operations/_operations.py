# pylint: disable=too-many-lines
# coding=utf-8
# --------------------------------------------------------------------------
# Copyright (c) Microsoft Corporation. All rights reserved.
# Licensed under the MIT License. See License.txt in the project root for license information.
# Code generated by Microsoft (R) AutoRest Code Generator.
# Changes may cause incorrect behavior and will be lost if the code is regenerated.
# --------------------------------------------------------------------------
import datetime
import sys
from typing import Any, Callable, Dict, IO, Iterable, Iterator, List, Optional, TypeVar, Union, cast, overload
from urllib.parse import parse_qs, urljoin, urlparse

from azure.core.exceptions import (
    ClientAuthenticationError,
    HttpResponseError,
    ResourceExistsError,
    ResourceNotFoundError,
    ResourceNotModifiedError,
    map_error,
)
from azure.core.paging import ItemPaged
from azure.core.pipeline import PipelineResponse
from azure.core.pipeline.transport import HttpResponse
from azure.core.polling import LROPoller, NoPolling, PollingMethod
from azure.core.polling.base_polling import LROBasePolling
from azure.core.rest import HttpRequest
from azure.core.tracing.decorator import distributed_trace
from azure.core.utils import case_insensitive_dict

from .._serialization import Serializer
from .._vendor import _format_url_section, raise_if_not_implemented

if sys.version_info >= (3, 9):
    from collections.abc import MutableMapping
else:
    from typing import MutableMapping  # type: ignore  # pylint: disable=ungrouped-imports
JSON = MutableMapping[str, Any]  # pylint: disable=unsubscriptable-object
T = TypeVar("T")
ClsType = Optional[Callable[[PipelineResponse[HttpRequest, HttpResponse], T, Dict[str, Any]], Any]]

_SERIALIZER = Serializer()
_SERIALIZER.client_side_validation = False


def build_application_data_list_request(
    *,
    min_avg_material: Optional[float] = None,
    max_avg_material: Optional[float] = None,
    min_total_material: Optional[float] = None,
    max_total_material: Optional[float] = None,
    sources: Optional[List[str]] = None,
    associated_boundary_ids: Optional[List[str]] = None,
    min_operation_start_date_time: Optional[datetime.datetime] = None,
    max_operation_start_date_time: Optional[datetime.datetime] = None,
    min_operation_end_date_time: Optional[datetime.datetime] = None,
    max_operation_end_date_time: Optional[datetime.datetime] = None,
    min_operation_modified_date_time: Optional[datetime.datetime] = None,
    max_operation_modified_date_time: Optional[datetime.datetime] = None,
    min_area: Optional[float] = None,
    max_area: Optional[float] = None,
    ids: Optional[List[str]] = None,
    names: Optional[List[str]] = None,
    property_filters: Optional[List[str]] = None,
    statuses: Optional[List[str]] = None,
    min_created_date_time: Optional[datetime.datetime] = None,
    max_created_date_time: Optional[datetime.datetime] = None,
    min_last_modified_date_time: Optional[datetime.datetime] = None,
    max_last_modified_date_time: Optional[datetime.datetime] = None,
    skip_token: Optional[str] = None,
    **kwargs: Any
) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    api_version = kwargs.pop("api_version", _params.pop("api-version", "2022-11-01-preview"))  # type: str
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/application-data"

    # Construct parameters
    if min_avg_material is not None:
        _params["minAvgMaterial"] = _SERIALIZER.query("min_avg_material", min_avg_material, "float")
    if max_avg_material is not None:
        _params["maxAvgMaterial"] = _SERIALIZER.query("max_avg_material", max_avg_material, "float")
    if min_total_material is not None:
        _params["minTotalMaterial"] = _SERIALIZER.query("min_total_material", min_total_material, "float")
    if max_total_material is not None:
        _params["maxTotalMaterial"] = _SERIALIZER.query("max_total_material", max_total_material, "float")
    if sources is not None:
        _params["sources"] = [_SERIALIZER.query("sources", q, "str") if q is not None else "" for q in sources]
    if associated_boundary_ids is not None:
        _params["associatedBoundaryIds"] = [
            _SERIALIZER.query("associated_boundary_ids", q, "str") if q is not None else ""
            for q in associated_boundary_ids
        ]
    if min_operation_start_date_time is not None:
        _params["minOperationStartDateTime"] = _SERIALIZER.query(
            "min_operation_start_date_time", min_operation_start_date_time, "iso-8601"
        )
    if max_operation_start_date_time is not None:
        _params["maxOperationStartDateTime"] = _SERIALIZER.query(
            "max_operation_start_date_time", max_operation_start_date_time, "iso-8601"
        )
    if min_operation_end_date_time is not None:
        _params["minOperationEndDateTime"] = _SERIALIZER.query(
            "min_operation_end_date_time", min_operation_end_date_time, "iso-8601"
        )
    if max_operation_end_date_time is not None:
        _params["maxOperationEndDateTime"] = _SERIALIZER.query(
            "max_operation_end_date_time", max_operation_end_date_time, "iso-8601"
        )
    if min_operation_modified_date_time is not None:
        _params["minOperationModifiedDateTime"] = _SERIALIZER.query(
            "min_operation_modified_date_time", min_operation_modified_date_time, "iso-8601"
        )
    if max_operation_modified_date_time is not None:
        _params["maxOperationModifiedDateTime"] = _SERIALIZER.query(
            "max_operation_modified_date_time", max_operation_modified_date_time, "iso-8601"
        )
    if min_area is not None:
        _params["minArea"] = _SERIALIZER.query("min_area", min_area, "float")
    if max_area is not None:
        _params["maxArea"] = _SERIALIZER.query("max_area", max_area, "float")
    if ids is not None:
        _params["ids"] = [_SERIALIZER.query("ids", q, "str") if q is not None else "" for q in ids]
    if names is not None:
        _params["names"] = [_SERIALIZER.query("names", q, "str") if q is not None else "" for q in names]
    if property_filters is not None:
        _params["propertyFilters"] = [
            _SERIALIZER.query("property_filters", q, "str") if q is not None else "" for q in property_filters
        ]
    if statuses is not None:
        _params["statuses"] = [_SERIALIZER.query("statuses", q, "str") if q is not None else "" for q in statuses]
    if min_created_date_time is not None:
        _params["minCreatedDateTime"] = _SERIALIZER.query("min_created_date_time", min_created_date_time, "iso-8601")
    if max_created_date_time is not None:
        _params["maxCreatedDateTime"] = _SERIALIZER.query("max_created_date_time", max_created_date_time, "iso-8601")
    if min_last_modified_date_time is not None:
        _params["minLastModifiedDateTime"] = _SERIALIZER.query(
            "min_last_modified_date_time", min_last_modified_date_time, "iso-8601"
        )
    if max_last_modified_date_time is not None:
        _params["maxLastModifiedDateTime"] = _SERIALIZER.query(
            "max_last_modified_date_time", max_last_modified_date_time, "iso-8601"
        )
    if skip_token is not None:
        _params["skipToken"] = _SERIALIZER.query("skip_token", skip_token, "str")
    _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")

    # Construct headers
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="GET", url=_url, params=_params, headers=_headers, **kwargs)


def build_application_data_create_cascade_delete_job_request(
    job_id: str, *, party_id: str, application_data_id: str, **kwargs: Any
) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    api_version = kwargs.pop("api_version", _params.pop("api-version", "2022-11-01-preview"))  # type: str
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/application-data/cascade-delete/{jobId}"
    path_format_arguments = {
        "jobId": _SERIALIZER.url("job_id", job_id, "str"),
    }

    _url = _format_url_section(_url, **path_format_arguments)

    # Construct parameters
    _params["partyId"] = _SERIALIZER.query("party_id", party_id, "str")
    _params["applicationDataId"] = _SERIALIZER.query("application_data_id", application_data_id, "str")
    _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")

    # Construct headers
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="PUT", url=_url, params=_params, headers=_headers, **kwargs)


def build_application_data_get_cascade_delete_job_details_request(job_id: str, **kwargs: Any) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    api_version = kwargs.pop("api_version", _params.pop("api-version", "2022-11-01-preview"))  # type: str
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/application-data/cascade-delete/{jobId}"
    path_format_arguments = {
        "jobId": _SERIALIZER.url("job_id", job_id, "str"),
    }

    _url = _format_url_section(_url, **path_format_arguments)

    # Construct parameters
    _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")

    # Construct headers
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="GET", url=_url, params=_params, headers=_headers, **kwargs)


def build_application_data_list_by_party_id_request(
    party_id: str,
    *,
    min_avg_material: Optional[float] = None,
    max_avg_material: Optional[float] = None,
    min_total_material: Optional[float] = None,
    max_total_material: Optional[float] = None,
    sources: Optional[List[str]] = None,
    associated_boundary_ids: Optional[List[str]] = None,
    min_operation_start_date_time: Optional[datetime.datetime] = None,
    max_operation_start_date_time: Optional[datetime.datetime] = None,
    min_operation_end_date_time: Optional[datetime.datetime] = None,
    max_operation_end_date_time: Optional[datetime.datetime] = None,
    min_operation_modified_date_time: Optional[datetime.datetime] = None,
    max_operation_modified_date_time: Optional[datetime.datetime] = None,
    min_area: Optional[float] = None,
    max_area: Optional[float] = None,
    ids: Optional[List[str]] = None,
    names: Optional[List[str]] = None,
    property_filters: Optional[List[str]] = None,
    statuses: Optional[List[str]] = None,
    min_created_date_time: Optional[datetime.datetime] = None,
    max_created_date_time: Optional[datetime.datetime] = None,
    min_last_modified_date_time: Optional[datetime.datetime] = None,
    max_last_modified_date_time: Optional[datetime.datetime] = None,
    skip_token: Optional[str] = None,
    **kwargs: Any
) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    api_version = kwargs.pop("api_version", _params.pop("api-version", "2022-11-01-preview"))  # type: str
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/parties/{partyId}/application-data"
    path_format_arguments = {
        "partyId": _SERIALIZER.url("party_id", party_id, "str"),
    }

    _url = _format_url_section(_url, **path_format_arguments)

    # Construct parameters
    if min_avg_material is not None:
        _params["minAvgMaterial"] = _SERIALIZER.query("min_avg_material", min_avg_material, "float")
    if max_avg_material is not None:
        _params["maxAvgMaterial"] = _SERIALIZER.query("max_avg_material", max_avg_material, "float")
    if min_total_material is not None:
        _params["minTotalMaterial"] = _SERIALIZER.query("min_total_material", min_total_material, "float")
    if max_total_material is not None:
        _params["maxTotalMaterial"] = _SERIALIZER.query("max_total_material", max_total_material, "float")
    if sources is not None:
        _params["sources"] = [_SERIALIZER.query("sources", q, "str") if q is not None else "" for q in sources]
    if associated_boundary_ids is not None:
        _params["associatedBoundaryIds"] = [
            _SERIALIZER.query("associated_boundary_ids", q, "str") if q is not None else ""
            for q in associated_boundary_ids
        ]
    if min_operation_start_date_time is not None:
        _params["minOperationStartDateTime"] = _SERIALIZER.query(
            "min_operation_start_date_time", min_operation_start_date_time, "iso-8601"
        )
    if max_operation_start_date_time is not None:
        _params["maxOperationStartDateTime"] = _SERIALIZER.query(
            "max_operation_start_date_time", max_operation_start_date_time, "iso-8601"
        )
    if min_operation_end_date_time is not None:
        _params["minOperationEndDateTime"] = _SERIALIZER.query(
            "min_operation_end_date_time", min_operation_end_date_time, "iso-8601"
        )
    if max_operation_end_date_time is not None:
        _params["maxOperationEndDateTime"] = _SERIALIZER.query(
            "max_operation_end_date_time", max_operation_end_date_time, "iso-8601"
        )
    if min_operation_modified_date_time is not None:
        _params["minOperationModifiedDateTime"] = _SERIALIZER.query(
            "min_operation_modified_date_time", min_operation_modified_date_time, "iso-8601"
        )
    if max_operation_modified_date_time is not None:
        _params["maxOperationModifiedDateTime"] = _SERIALIZER.query(
            "max_operation_modified_date_time", max_operation_modified_date_time, "iso-8601"
        )
    if min_area is not None:
        _params["minArea"] = _SERIALIZER.query("min_area", min_area, "float")
    if max_area is not None:
        _params["maxArea"] = _SERIALIZER.query("max_area", max_area, "float")
    if ids is not None:
        _params["ids"] = [_SERIALIZER.query("ids", q, "str") if q is not None else "" for q in ids]
    if names is not None:
        _params["names"] = [_SERIALIZER.query("names", q, "str") if q is not None else "" for q in names]
    if property_filters is not None:
        _params["propertyFilters"] = [
            _SERIALIZER.query("property_filters", q, "str") if q is not None else "" for q in property_filters
        ]
    if statuses is not None:
        _params["statuses"] = [_SERIALIZER.query("statuses", q, "str") if q is not None else "" for q in statuses]
    if min_created_date_time is not None:
        _params["minCreatedDateTime"] = _SERIALIZER.query("min_created_date_time", min_created_date_time, "iso-8601")
    if max_created_date_time is not None:
        _params["maxCreatedDateTime"] = _SERIALIZER.query("max_created_date_time", max_created_date_time, "iso-8601")
    if min_last_modified_date_time is not None:
        _params["minLastModifiedDateTime"] = _SERIALIZER.query(
            "min_last_modified_date_time", min_last_modified_date_time, "iso-8601"
        )
    if max_last_modified_date_time is not None:
        _params["maxLastModifiedDateTime"] = _SERIALIZER.query(
            "max_last_modified_date_time", max_last_modified_date_time, "iso-8601"
        )
    if skip_token is not None:
        _params["skipToken"] = _SERIALIZER.query("skip_token", skip_token, "str")
    _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")

    # Construct headers
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="GET", url=_url, params=_params, headers=_headers, **kwargs)


def build_application_data_get_request(party_id: str, application_data_id: str, **kwargs: Any) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    api_version = kwargs.pop("api_version", _params.pop("api-version", "2022-11-01-preview"))  # type: str
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/parties/{partyId}/application-data/{applicationDataId}"
    path_format_arguments = {
        "partyId": _SERIALIZER.url("party_id", party_id, "str"),
        "applicationDataId": _SERIALIZER.url("application_data_id", application_data_id, "str"),
    }

    _url = _format_url_section(_url, **path_format_arguments)

    # Construct parameters
    _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")

    # Construct headers
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="GET", url=_url, params=_params, headers=_headers, **kwargs)


def build_application_data_create_or_update_request(
    party_id: str, application_data_id: str, **kwargs: Any
) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    content_type = kwargs.pop("content_type", _headers.pop("Content-Type", None))  # type: Optional[str]
    api_version = kwargs.pop("api_version", _params.pop("api-version", "2022-11-01-preview"))  # type: str
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/parties/{partyId}/application-data/{applicationDataId}"
    path_format_arguments = {
        "partyId": _SERIALIZER.url("party_id", party_id, "str"),
        "applicationDataId": _SERIALIZER.url("application_data_id", application_data_id, "str"),
    }

    _url = _format_url_section(_url, **path_format_arguments)

    # Construct parameters
    _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")

    # Construct headers
    if content_type is not None:
        _headers["Content-Type"] = _SERIALIZER.header("content_type", content_type, "str")
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="PATCH", url=_url, params=_params, headers=_headers, **kwargs)


def build_application_data_delete_request(party_id: str, application_data_id: str, **kwargs: Any) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    api_version = kwargs.pop("api_version", _params.pop("api-version", "2022-11-01-preview"))  # type: str
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/parties/{partyId}/application-data/{applicationDataId}"
    path_format_arguments = {
        "partyId": _SERIALIZER.url("party_id", party_id, "str"),
        "applicationDataId": _SERIALIZER.url("application_data_id", application_data_id, "str"),
    }

    _url = _format_url_section(_url, **path_format_arguments)

    # Construct parameters
    _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")

    # Construct headers
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="DELETE", url=_url, params=_params, headers=_headers, **kwargs)


def build_attachments_list_by_party_id_request(
    party_id: str,
    *,
    resource_ids: Optional[List[str]] = None,
    resource_types: Optional[List[str]] = None,
    ids: Optional[List[str]] = None,
    names: Optional[List[str]] = None,
    property_filters: Optional[List[str]] = None,
    statuses: Optional[List[str]] = None,
    min_created_date_time: Optional[datetime.datetime] = None,
    max_created_date_time: Optional[datetime.datetime] = None,
    min_last_modified_date_time: Optional[datetime.datetime] = None,
    max_last_modified_date_time: Optional[datetime.datetime] = None,
    skip_token: Optional[str] = None,
    **kwargs: Any
) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    api_version = kwargs.pop("api_version", _params.pop("api-version", "2022-11-01-preview"))  # type: str
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/parties/{partyId}/attachments"
    path_format_arguments = {
        "partyId": _SERIALIZER.url("party_id", party_id, "str"),
    }

    _url = _format_url_section(_url, **path_format_arguments)

    # Construct parameters
    if resource_ids is not None:
        _params["resourceIds"] = [
            _SERIALIZER.query("resource_ids", q, "str") if q is not None else "" for q in resource_ids
        ]
    if resource_types is not None:
        _params["resourceTypes"] = [
            _SERIALIZER.query("resource_types", q, "str") if q is not None else "" for q in resource_types
        ]
    if ids is not None:
        _params["ids"] = [_SERIALIZER.query("ids", q, "str") if q is not None else "" for q in ids]
    if names is not None:
        _params["names"] = [_SERIALIZER.query("names", q, "str") if q is not None else "" for q in names]
    if property_filters is not None:
        _params["propertyFilters"] = [
            _SERIALIZER.query("property_filters", q, "str") if q is not None else "" for q in property_filters
        ]
    if statuses is not None:
        _params["statuses"] = [_SERIALIZER.query("statuses", q, "str") if q is not None else "" for q in statuses]
    if min_created_date_time is not None:
        _params["minCreatedDateTime"] = _SERIALIZER.query("min_created_date_time", min_created_date_time, "iso-8601")
    if max_created_date_time is not None:
        _params["maxCreatedDateTime"] = _SERIALIZER.query("max_created_date_time", max_created_date_time, "iso-8601")
    if min_last_modified_date_time is not None:
        _params["minLastModifiedDateTime"] = _SERIALIZER.query(
            "min_last_modified_date_time", min_last_modified_date_time, "iso-8601"
        )
    if max_last_modified_date_time is not None:
        _params["maxLastModifiedDateTime"] = _SERIALIZER.query(
            "max_last_modified_date_time", max_last_modified_date_time, "iso-8601"
        )
    if skip_token is not None:
        _params["skipToken"] = _SERIALIZER.query("skip_token", skip_token, "str")
    _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")

    # Construct headers
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="GET", url=_url, params=_params, headers=_headers, **kwargs)


def build_attachments_get_request(party_id: str, attachment_id: str, **kwargs: Any) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    api_version = kwargs.pop("api_version", _params.pop("api-version", "2022-11-01-preview"))  # type: str
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/parties/{partyId}/attachments/{attachmentId}"
    path_format_arguments = {
        "partyId": _SERIALIZER.url("party_id", party_id, "str"),
        "attachmentId": _SERIALIZER.url("attachment_id", attachment_id, "str"),
    }

    _url = _format_url_section(_url, **path_format_arguments)

    # Construct parameters
    _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")

    # Construct headers
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="GET", url=_url, params=_params, headers=_headers, **kwargs)


def build_attachments_delete_request(party_id: str, attachment_id: str, **kwargs: Any) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    api_version = kwargs.pop("api_version", _params.pop("api-version", "2022-11-01-preview"))  # type: str
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/parties/{partyId}/attachments/{attachmentId}"
    path_format_arguments = {
        "partyId": _SERIALIZER.url("party_id", party_id, "str"),
        "attachmentId": _SERIALIZER.url("attachment_id", attachment_id, "str"),
    }

    _url = _format_url_section(_url, **path_format_arguments)

    # Construct parameters
    _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")

    # Construct headers
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="DELETE", url=_url, params=_params, headers=_headers, **kwargs)


def build_attachments_download_request(party_id: str, attachment_id: str, **kwargs: Any) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    api_version = kwargs.pop("api_version", _params.pop("api-version", "2022-11-01-preview"))  # type: str
    accept = _headers.pop("Accept", "application/json, application/octet-stream")

    # Construct URL
    _url = "/parties/{partyId}/attachments/{attachmentId}/file"
    path_format_arguments = {
        "partyId": _SERIALIZER.url("party_id", party_id, "str"),
        "attachmentId": _SERIALIZER.url("attachment_id", attachment_id, "str"),
    }

    _url = _format_url_section(_url, **path_format_arguments)

    # Construct parameters
    _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")

    # Construct headers
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="GET", url=_url, params=_params, headers=_headers, **kwargs)


def build_boundaries_list_request(
    *,
    parent_type: Optional[str] = None,
    type: Optional[str] = None,
    parent_ids: Optional[List[str]] = None,
    min_area: Optional[float] = None,
    max_area: Optional[float] = None,
    ids: Optional[List[str]] = None,
    names: Optional[List[str]] = None,
    property_filters: Optional[List[str]] = None,
    statuses: Optional[List[str]] = None,
    min_created_date_time: Optional[datetime.datetime] = None,
    max_created_date_time: Optional[datetime.datetime] = None,
    min_last_modified_date_time: Optional[datetime.datetime] = None,
    max_last_modified_date_time: Optional[datetime.datetime] = None,
    skip_token: Optional[str] = None,
    **kwargs: Any
) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    api_version = kwargs.pop("api_version", _params.pop("api-version", "2022-11-01-preview"))  # type: str
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/boundaries"

    # Construct parameters
    if parent_type is not None:
        _params["parentType"] = _SERIALIZER.query("parent_type", parent_type, "str")
    if type is not None:
        _params["type"] = _SERIALIZER.query("type", type, "str")
    if parent_ids is not None:
        _params["parentIds"] = [_SERIALIZER.query("parent_ids", q, "str") if q is not None else "" for q in parent_ids]
    if min_area is not None:
        _params["minArea"] = _SERIALIZER.query("min_area", min_area, "float")
    if max_area is not None:
        _params["maxArea"] = _SERIALIZER.query("max_area", max_area, "float")
    if ids is not None:
        _params["ids"] = [_SERIALIZER.query("ids", q, "str") if q is not None else "" for q in ids]
    if names is not None:
        _params["names"] = [_SERIALIZER.query("names", q, "str") if q is not None else "" for q in names]
    if property_filters is not None:
        _params["propertyFilters"] = [
            _SERIALIZER.query("property_filters", q, "str") if q is not None else "" for q in property_filters
        ]
    if statuses is not None:
        _params["statuses"] = [_SERIALIZER.query("statuses", q, "str") if q is not None else "" for q in statuses]
    if min_created_date_time is not None:
        _params["minCreatedDateTime"] = _SERIALIZER.query("min_created_date_time", min_created_date_time, "iso-8601")
    if max_created_date_time is not None:
        _params["maxCreatedDateTime"] = _SERIALIZER.query("max_created_date_time", max_created_date_time, "iso-8601")
    if min_last_modified_date_time is not None:
        _params["minLastModifiedDateTime"] = _SERIALIZER.query(
            "min_last_modified_date_time", min_last_modified_date_time, "iso-8601"
        )
    if max_last_modified_date_time is not None:
        _params["maxLastModifiedDateTime"] = _SERIALIZER.query(
            "max_last_modified_date_time", max_last_modified_date_time, "iso-8601"
        )
    if skip_token is not None:
        _params["skipToken"] = _SERIALIZER.query("skip_token", skip_token, "str")
    _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")

    # Construct headers
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="GET", url=_url, params=_params, headers=_headers, **kwargs)


def build_boundaries_search_request(**kwargs: Any) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    content_type = kwargs.pop("content_type", _headers.pop("Content-Type", None))  # type: Optional[str]
    api_version = kwargs.pop("api_version", _params.pop("api-version", "2022-11-01-preview"))  # type: str
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/boundaries"

    # Construct parameters
    _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")

    # Construct headers
    if content_type is not None:
        _headers["Content-Type"] = _SERIALIZER.header("content_type", content_type, "str")
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="POST", url=_url, params=_params, headers=_headers, **kwargs)


def build_boundaries_create_cascade_delete_job_request(
    job_id: str, *, party_id: str, boundary_id: str, **kwargs: Any
) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    api_version = kwargs.pop("api_version", _params.pop("api-version", "2022-11-01-preview"))  # type: str
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/boundaries/cascade-delete/{jobId}"
    path_format_arguments = {
        "jobId": _SERIALIZER.url("job_id", job_id, "str"),
    }

    _url = _format_url_section(_url, **path_format_arguments)

    # Construct parameters
    _params["partyId"] = _SERIALIZER.query("party_id", party_id, "str")
    _params["boundaryId"] = _SERIALIZER.query("boundary_id", boundary_id, "str")
    _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")

    # Construct headers
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="PUT", url=_url, params=_params, headers=_headers, **kwargs)


def build_boundaries_get_cascade_delete_job_details_request(job_id: str, **kwargs: Any) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    api_version = kwargs.pop("api_version", _params.pop("api-version", "2022-11-01-preview"))  # type: str
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/boundaries/cascade-delete/{jobId}"
    path_format_arguments = {
        "jobId": _SERIALIZER.url("job_id", job_id, "str"),
    }

    _url = _format_url_section(_url, **path_format_arguments)

    # Construct parameters
    _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")

    # Construct headers
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="GET", url=_url, params=_params, headers=_headers, **kwargs)


def build_boundaries_list_by_party_id_request(
    party_id: str,
    *,
    parent_type: Optional[str] = None,
    type: Optional[str] = None,
    parent_ids: Optional[List[str]] = None,
    min_area: Optional[float] = None,
    max_area: Optional[float] = None,
    ids: Optional[List[str]] = None,
    names: Optional[List[str]] = None,
    property_filters: Optional[List[str]] = None,
    statuses: Optional[List[str]] = None,
    min_created_date_time: Optional[datetime.datetime] = None,
    max_created_date_time: Optional[datetime.datetime] = None,
    min_last_modified_date_time: Optional[datetime.datetime] = None,
    max_last_modified_date_time: Optional[datetime.datetime] = None,
    skip_token: Optional[str] = None,
    **kwargs: Any
) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    api_version = kwargs.pop("api_version", _params.pop("api-version", "2022-11-01-preview"))  # type: str
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/parties/{partyId}/boundaries"
    path_format_arguments = {
        "partyId": _SERIALIZER.url("party_id", party_id, "str"),
    }

    _url = _format_url_section(_url, **path_format_arguments)

    # Construct parameters
    if parent_type is not None:
        _params["parentType"] = _SERIALIZER.query("parent_type", parent_type, "str")
    if type is not None:
        _params["type"] = _SERIALIZER.query("type", type, "str")
    if parent_ids is not None:
        _params["parentIds"] = [_SERIALIZER.query("parent_ids", q, "str") if q is not None else "" for q in parent_ids]
    if min_area is not None:
        _params["minArea"] = _SERIALIZER.query("min_area", min_area, "float")
    if max_area is not None:
        _params["maxArea"] = _SERIALIZER.query("max_area", max_area, "float")
    if ids is not None:
        _params["ids"] = [_SERIALIZER.query("ids", q, "str") if q is not None else "" for q in ids]
    if names is not None:
        _params["names"] = [_SERIALIZER.query("names", q, "str") if q is not None else "" for q in names]
    if property_filters is not None:
        _params["propertyFilters"] = [
            _SERIALIZER.query("property_filters", q, "str") if q is not None else "" for q in property_filters
        ]
    if statuses is not None:
        _params["statuses"] = [_SERIALIZER.query("statuses", q, "str") if q is not None else "" for q in statuses]
    if min_created_date_time is not None:
        _params["minCreatedDateTime"] = _SERIALIZER.query("min_created_date_time", min_created_date_time, "iso-8601")
    if max_created_date_time is not None:
        _params["maxCreatedDateTime"] = _SERIALIZER.query("max_created_date_time", max_created_date_time, "iso-8601")
    if min_last_modified_date_time is not None:
        _params["minLastModifiedDateTime"] = _SERIALIZER.query(
            "min_last_modified_date_time", min_last_modified_date_time, "iso-8601"
        )
    if max_last_modified_date_time is not None:
        _params["maxLastModifiedDateTime"] = _SERIALIZER.query(
            "max_last_modified_date_time", max_last_modified_date_time, "iso-8601"
        )
    if skip_token is not None:
        _params["skipToken"] = _SERIALIZER.query("skip_token", skip_token, "str")
    _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")

    # Construct headers
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="GET", url=_url, params=_params, headers=_headers, **kwargs)


def build_boundaries_search_by_party_id_request(party_id: str, **kwargs: Any) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    content_type = kwargs.pop("content_type", _headers.pop("Content-Type", None))  # type: Optional[str]
    api_version = kwargs.pop("api_version", _params.pop("api-version", "2022-11-01-preview"))  # type: str
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/parties/{partyId}/boundaries"
    path_format_arguments = {
        "partyId": _SERIALIZER.url("party_id", party_id, "str"),
    }

    _url = _format_url_section(_url, **path_format_arguments)

    # Construct parameters
    _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")

    # Construct headers
    if content_type is not None:
        _headers["Content-Type"] = _SERIALIZER.header("content_type", content_type, "str")
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="POST", url=_url, params=_params, headers=_headers, **kwargs)


def build_boundaries_create_or_update_request(party_id: str, boundary_id: str, **kwargs: Any) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    content_type = kwargs.pop("content_type", _headers.pop("Content-Type", None))  # type: Optional[str]
    api_version = kwargs.pop("api_version", _params.pop("api-version", "2022-11-01-preview"))  # type: str
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/parties/{partyId}/boundaries/{boundaryId}"
    path_format_arguments = {
        "partyId": _SERIALIZER.url("party_id", party_id, "str"),
        "boundaryId": _SERIALIZER.url("boundary_id", boundary_id, "str"),
    }

    _url = _format_url_section(_url, **path_format_arguments)

    # Construct parameters
    _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")

    # Construct headers
    if content_type is not None:
        _headers["Content-Type"] = _SERIALIZER.header("content_type", content_type, "str")
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="PATCH", url=_url, params=_params, headers=_headers, **kwargs)


def build_boundaries_get_request(party_id: str, boundary_id: str, **kwargs: Any) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    api_version = kwargs.pop("api_version", _params.pop("api-version", "2022-11-01-preview"))  # type: str
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/parties/{partyId}/boundaries/{boundaryId}"
    path_format_arguments = {
        "partyId": _SERIALIZER.url("party_id", party_id, "str"),
        "boundaryId": _SERIALIZER.url("boundary_id", boundary_id, "str"),
    }

    _url = _format_url_section(_url, **path_format_arguments)

    # Construct parameters
    _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")

    # Construct headers
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="GET", url=_url, params=_params, headers=_headers, **kwargs)


def build_boundaries_delete_request(party_id: str, boundary_id: str, **kwargs: Any) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    api_version = kwargs.pop("api_version", _params.pop("api-version", "2022-11-01-preview"))  # type: str
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/parties/{partyId}/boundaries/{boundaryId}"
    path_format_arguments = {
        "partyId": _SERIALIZER.url("party_id", party_id, "str"),
        "boundaryId": _SERIALIZER.url("boundary_id", boundary_id, "str"),
    }

    _url = _format_url_section(_url, **path_format_arguments)

    # Construct parameters
    _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")

    # Construct headers
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="DELETE", url=_url, params=_params, headers=_headers, **kwargs)


def build_boundaries_get_overlap_request(
    party_id: str, boundary_id: str, *, other_party_id: str, other_boundary_id: str, **kwargs: Any
) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    api_version = kwargs.pop("api_version", _params.pop("api-version", "2022-11-01-preview"))  # type: str
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/parties/{partyId}/boundaries/{boundaryId}/overlap"
    path_format_arguments = {
        "partyId": _SERIALIZER.url("party_id", party_id, "str"),
        "boundaryId": _SERIALIZER.url("boundary_id", boundary_id, "str"),
    }

    _url = _format_url_section(_url, **path_format_arguments)

    # Construct parameters
    _params["otherPartyId"] = _SERIALIZER.query("other_party_id", other_party_id, "str")
    _params["otherBoundaryId"] = _SERIALIZER.query("other_boundary_id", other_boundary_id, "str")
    _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")

    # Construct headers
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="GET", url=_url, params=_params, headers=_headers, **kwargs)


def build_crop_products_list_request(
    *,
    crop_ids: Optional[List[str]] = None,
    brands: Optional[List[str]] = None,
    products: Optional[List[str]] = None,
    traits: Optional[List[str]] = None,
    ids: Optional[List[str]] = None,
    names: Optional[List[str]] = None,
    property_filters: Optional[List[str]] = None,
    statuses: Optional[List[str]] = None,
    min_created_date_time: Optional[datetime.datetime] = None,
    max_created_date_time: Optional[datetime.datetime] = None,
    min_last_modified_date_time: Optional[datetime.datetime] = None,
    max_last_modified_date_time: Optional[datetime.datetime] = None,
    skip_token: Optional[str] = None,
    **kwargs: Any
) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    api_version = kwargs.pop("api_version", _params.pop("api-version", "2022-11-01-preview"))  # type: str
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/crop-products"

    # Construct parameters
    if crop_ids is not None:
        _params["cropIds"] = [_SERIALIZER.query("crop_ids", q, "str") if q is not None else "" for q in crop_ids]
    if brands is not None:
        _params["brands"] = [_SERIALIZER.query("brands", q, "str") if q is not None else "" for q in brands]
    if products is not None:
        _params["products"] = [_SERIALIZER.query("products", q, "str") if q is not None else "" for q in products]
    if traits is not None:
        _params["traits"] = [_SERIALIZER.query("traits", q, "str") if q is not None else "" for q in traits]
    if ids is not None:
        _params["ids"] = [_SERIALIZER.query("ids", q, "str") if q is not None else "" for q in ids]
    if names is not None:
        _params["names"] = [_SERIALIZER.query("names", q, "str") if q is not None else "" for q in names]
    if property_filters is not None:
        _params["propertyFilters"] = [
            _SERIALIZER.query("property_filters", q, "str") if q is not None else "" for q in property_filters
        ]
    if statuses is not None:
        _params["statuses"] = [_SERIALIZER.query("statuses", q, "str") if q is not None else "" for q in statuses]
    if min_created_date_time is not None:
        _params["minCreatedDateTime"] = _SERIALIZER.query("min_created_date_time", min_created_date_time, "iso-8601")
    if max_created_date_time is not None:
        _params["maxCreatedDateTime"] = _SERIALIZER.query("max_created_date_time", max_created_date_time, "iso-8601")
    if min_last_modified_date_time is not None:
        _params["minLastModifiedDateTime"] = _SERIALIZER.query(
            "min_last_modified_date_time", min_last_modified_date_time, "iso-8601"
        )
    if max_last_modified_date_time is not None:
        _params["maxLastModifiedDateTime"] = _SERIALIZER.query(
            "max_last_modified_date_time", max_last_modified_date_time, "iso-8601"
        )
    if skip_token is not None:
        _params["skipToken"] = _SERIALIZER.query("skip_token", skip_token, "str")
    _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")

    # Construct headers
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="GET", url=_url, params=_params, headers=_headers, **kwargs)


def build_crop_products_get_request(crop_product_id: str, **kwargs: Any) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    api_version = kwargs.pop("api_version", _params.pop("api-version", "2022-11-01-preview"))  # type: str
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/crop-products/{cropProductId}"
    path_format_arguments = {
        "cropProductId": _SERIALIZER.url("crop_product_id", crop_product_id, "str"),
    }

    _url = _format_url_section(_url, **path_format_arguments)

    # Construct parameters
    _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")

    # Construct headers
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="GET", url=_url, params=_params, headers=_headers, **kwargs)


def build_crop_products_create_or_update_request(crop_product_id: str, **kwargs: Any) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    content_type = kwargs.pop("content_type", _headers.pop("Content-Type", None))  # type: Optional[str]
    api_version = kwargs.pop("api_version", _params.pop("api-version", "2022-11-01-preview"))  # type: str
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/crop-products/{cropProductId}"
    path_format_arguments = {
        "cropProductId": _SERIALIZER.url("crop_product_id", crop_product_id, "str"),
    }

    _url = _format_url_section(_url, **path_format_arguments)

    # Construct parameters
    _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")

    # Construct headers
    if content_type is not None:
        _headers["Content-Type"] = _SERIALIZER.header("content_type", content_type, "str")
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="PATCH", url=_url, params=_params, headers=_headers, **kwargs)


def build_crop_products_delete_request(crop_product_id: str, **kwargs: Any) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    api_version = kwargs.pop("api_version", _params.pop("api-version", "2022-11-01-preview"))  # type: str
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/crop-products/{cropProductId}"
    path_format_arguments = {
        "cropProductId": _SERIALIZER.url("crop_product_id", crop_product_id, "str"),
    }

    _url = _format_url_section(_url, **path_format_arguments)

    # Construct parameters
    _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")

    # Construct headers
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="DELETE", url=_url, params=_params, headers=_headers, **kwargs)


def build_crops_list_request(
    *,
    phenotypes: Optional[List[str]] = None,
    breeding_methods: Optional[List[str]] = None,
    ids: Optional[List[str]] = None,
    names: Optional[List[str]] = None,
    property_filters: Optional[List[str]] = None,
    statuses: Optional[List[str]] = None,
    min_created_date_time: Optional[datetime.datetime] = None,
    max_created_date_time: Optional[datetime.datetime] = None,
    min_last_modified_date_time: Optional[datetime.datetime] = None,
    max_last_modified_date_time: Optional[datetime.datetime] = None,
    skip_token: Optional[str] = None,
    **kwargs: Any
) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    api_version = kwargs.pop("api_version", _params.pop("api-version", "2022-11-01-preview"))  # type: str
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/crops"

    # Construct parameters
    if phenotypes is not None:
        _params["phenotypes"] = [_SERIALIZER.query("phenotypes", q, "str") if q is not None else "" for q in phenotypes]
    if breeding_methods is not None:
        _params["breedingMethods"] = [
            _SERIALIZER.query("breeding_methods", q, "str") if q is not None else "" for q in breeding_methods
        ]
    if ids is not None:
        _params["ids"] = [_SERIALIZER.query("ids", q, "str") if q is not None else "" for q in ids]
    if names is not None:
        _params["names"] = [_SERIALIZER.query("names", q, "str") if q is not None else "" for q in names]
    if property_filters is not None:
        _params["propertyFilters"] = [
            _SERIALIZER.query("property_filters", q, "str") if q is not None else "" for q in property_filters
        ]
    if statuses is not None:
        _params["statuses"] = [_SERIALIZER.query("statuses", q, "str") if q is not None else "" for q in statuses]
    if min_created_date_time is not None:
        _params["minCreatedDateTime"] = _SERIALIZER.query("min_created_date_time", min_created_date_time, "iso-8601")
    if max_created_date_time is not None:
        _params["maxCreatedDateTime"] = _SERIALIZER.query("max_created_date_time", max_created_date_time, "iso-8601")
    if min_last_modified_date_time is not None:
        _params["minLastModifiedDateTime"] = _SERIALIZER.query(
            "min_last_modified_date_time", min_last_modified_date_time, "iso-8601"
        )
    if max_last_modified_date_time is not None:
        _params["maxLastModifiedDateTime"] = _SERIALIZER.query(
            "max_last_modified_date_time", max_last_modified_date_time, "iso-8601"
        )
    if skip_token is not None:
        _params["skipToken"] = _SERIALIZER.query("skip_token", skip_token, "str")
    _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")

    # Construct headers
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="GET", url=_url, params=_params, headers=_headers, **kwargs)


def build_crops_get_request(crop_id: str, **kwargs: Any) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    api_version = kwargs.pop("api_version", _params.pop("api-version", "2022-11-01-preview"))  # type: str
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/crops/{cropId}"
    path_format_arguments = {
        "cropId": _SERIALIZER.url("crop_id", crop_id, "str"),
    }

    _url = _format_url_section(_url, **path_format_arguments)

    # Construct parameters
    _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")

    # Construct headers
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="GET", url=_url, params=_params, headers=_headers, **kwargs)


def build_crops_create_or_update_request(crop_id: str, **kwargs: Any) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    content_type = kwargs.pop("content_type", _headers.pop("Content-Type", None))  # type: Optional[str]
    api_version = kwargs.pop("api_version", _params.pop("api-version", "2022-11-01-preview"))  # type: str
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/crops/{cropId}"
    path_format_arguments = {
        "cropId": _SERIALIZER.url("crop_id", crop_id, "str"),
    }

    _url = _format_url_section(_url, **path_format_arguments)

    # Construct parameters
    _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")

    # Construct headers
    if content_type is not None:
        _headers["Content-Type"] = _SERIALIZER.header("content_type", content_type, "str")
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="PATCH", url=_url, params=_params, headers=_headers, **kwargs)


def build_crops_delete_request(crop_id: str, **kwargs: Any) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    api_version = kwargs.pop("api_version", _params.pop("api-version", "2022-11-01-preview"))  # type: str
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/crops/{cropId}"
    path_format_arguments = {
        "cropId": _SERIALIZER.url("crop_id", crop_id, "str"),
    }

    _url = _format_url_section(_url, **path_format_arguments)

    # Construct parameters
    _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")

    # Construct headers
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="DELETE", url=_url, params=_params, headers=_headers, **kwargs)


def build_device_data_models_list_request(
    sensor_partner_id: str,
    *,
    ids: Optional[List[str]] = None,
    names: Optional[List[str]] = None,
    property_filters: Optional[List[str]] = None,
    statuses: Optional[List[str]] = None,
    min_created_date_time: Optional[datetime.datetime] = None,
    max_created_date_time: Optional[datetime.datetime] = None,
    min_last_modified_date_time: Optional[datetime.datetime] = None,
    max_last_modified_date_time: Optional[datetime.datetime] = None,
    skip_token: Optional[str] = None,
    **kwargs: Any
) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    api_version = kwargs.pop("api_version", _params.pop("api-version", "2022-11-01-preview"))  # type: str
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/sensor-partners/{sensorPartnerId}/device-data-models"
    path_format_arguments = {
        "sensorPartnerId": _SERIALIZER.url("sensor_partner_id", sensor_partner_id, "str"),
    }

    _url = _format_url_section(_url, **path_format_arguments)

    # Construct parameters
    if ids is not None:
        _params["ids"] = [_SERIALIZER.query("ids", q, "str") if q is not None else "" for q in ids]
    if names is not None:
        _params["names"] = [_SERIALIZER.query("names", q, "str") if q is not None else "" for q in names]
    if property_filters is not None:
        _params["propertyFilters"] = [
            _SERIALIZER.query("property_filters", q, "str") if q is not None else "" for q in property_filters
        ]
    if statuses is not None:
        _params["statuses"] = [_SERIALIZER.query("statuses", q, "str") if q is not None else "" for q in statuses]
    if min_created_date_time is not None:
        _params["minCreatedDateTime"] = _SERIALIZER.query("min_created_date_time", min_created_date_time, "iso-8601")
    if max_created_date_time is not None:
        _params["maxCreatedDateTime"] = _SERIALIZER.query("max_created_date_time", max_created_date_time, "iso-8601")
    if min_last_modified_date_time is not None:
        _params["minLastModifiedDateTime"] = _SERIALIZER.query(
            "min_last_modified_date_time", min_last_modified_date_time, "iso-8601"
        )
    if max_last_modified_date_time is not None:
        _params["maxLastModifiedDateTime"] = _SERIALIZER.query(
            "max_last_modified_date_time", max_last_modified_date_time, "iso-8601"
        )
    if skip_token is not None:
        _params["skipToken"] = _SERIALIZER.query("skip_token", skip_token, "str")
    _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")

    # Construct headers
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="GET", url=_url, params=_params, headers=_headers, **kwargs)


def build_device_data_models_create_or_update_request(
    sensor_partner_id: str, device_data_model_id: str, **kwargs: Any
) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    content_type = kwargs.pop("content_type", _headers.pop("Content-Type", None))  # type: Optional[str]
    api_version = kwargs.pop("api_version", _params.pop("api-version", "2022-11-01-preview"))  # type: str
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/sensor-partners/{sensorPartnerId}/device-data-models/{deviceDataModelId}"
    path_format_arguments = {
        "sensorPartnerId": _SERIALIZER.url("sensor_partner_id", sensor_partner_id, "str"),
        "deviceDataModelId": _SERIALIZER.url("device_data_model_id", device_data_model_id, "str"),
    }

    _url = _format_url_section(_url, **path_format_arguments)

    # Construct parameters
    _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")

    # Construct headers
    if content_type is not None:
        _headers["Content-Type"] = _SERIALIZER.header("content_type", content_type, "str")
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="PATCH", url=_url, params=_params, headers=_headers, **kwargs)


def build_device_data_models_get_request(
    sensor_partner_id: str, device_data_model_id: str, **kwargs: Any
) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    api_version = kwargs.pop("api_version", _params.pop("api-version", "2022-11-01-preview"))  # type: str
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/sensor-partners/{sensorPartnerId}/device-data-models/{deviceDataModelId}"
    path_format_arguments = {
        "sensorPartnerId": _SERIALIZER.url("sensor_partner_id", sensor_partner_id, "str"),
        "deviceDataModelId": _SERIALIZER.url("device_data_model_id", device_data_model_id, "str"),
    }

    _url = _format_url_section(_url, **path_format_arguments)

    # Construct parameters
    _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")

    # Construct headers
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="GET", url=_url, params=_params, headers=_headers, **kwargs)


def build_device_data_models_delete_request(
    sensor_partner_id: str, device_data_model_id: str, **kwargs: Any
) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    api_version = kwargs.pop("api_version", _params.pop("api-version", "2022-11-01-preview"))  # type: str
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/sensor-partners/{sensorPartnerId}/device-data-models/{deviceDataModelId}"
    path_format_arguments = {
        "sensorPartnerId": _SERIALIZER.url("sensor_partner_id", sensor_partner_id, "str"),
        "deviceDataModelId": _SERIALIZER.url("device_data_model_id", device_data_model_id, "str"),
    }

    _url = _format_url_section(_url, **path_format_arguments)

    # Construct parameters
    _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")

    # Construct headers
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="DELETE", url=_url, params=_params, headers=_headers, **kwargs)


def build_devices_list_request(
    sensor_partner_id: str,
    *,
    parent_device_ids: Optional[List[str]] = None,
    device_data_model_ids: Optional[List[str]] = None,
    ids: Optional[List[str]] = None,
    names: Optional[List[str]] = None,
    property_filters: Optional[List[str]] = None,
    statuses: Optional[List[str]] = None,
    min_created_date_time: Optional[datetime.datetime] = None,
    max_created_date_time: Optional[datetime.datetime] = None,
    min_last_modified_date_time: Optional[datetime.datetime] = None,
    max_last_modified_date_time: Optional[datetime.datetime] = None,
    skip_token: Optional[str] = None,
    **kwargs: Any
) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    api_version = kwargs.pop("api_version", _params.pop("api-version", "2022-11-01-preview"))  # type: str
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/sensor-partners/{sensorPartnerId}/devices"
    path_format_arguments = {
        "sensorPartnerId": _SERIALIZER.url("sensor_partner_id", sensor_partner_id, "str"),
    }

    _url = _format_url_section(_url, **path_format_arguments)

    # Construct parameters
    if parent_device_ids is not None:
        _params["parentDeviceIds"] = [
            _SERIALIZER.query("parent_device_ids", q, "str") if q is not None else "" for q in parent_device_ids
        ]
    if device_data_model_ids is not None:
        _params["deviceDataModelIds"] = [
            _SERIALIZER.query("device_data_model_ids", q, "str") if q is not None else "" for q in device_data_model_ids
        ]
    if ids is not None:
        _params["ids"] = [_SERIALIZER.query("ids", q, "str") if q is not None else "" for q in ids]
    if names is not None:
        _params["names"] = [_SERIALIZER.query("names", q, "str") if q is not None else "" for q in names]
    if property_filters is not None:
        _params["propertyFilters"] = [
            _SERIALIZER.query("property_filters", q, "str") if q is not None else "" for q in property_filters
        ]
    if statuses is not None:
        _params["statuses"] = [_SERIALIZER.query("statuses", q, "str") if q is not None else "" for q in statuses]
    if min_created_date_time is not None:
        _params["minCreatedDateTime"] = _SERIALIZER.query("min_created_date_time", min_created_date_time, "iso-8601")
    if max_created_date_time is not None:
        _params["maxCreatedDateTime"] = _SERIALIZER.query("max_created_date_time", max_created_date_time, "iso-8601")
    if min_last_modified_date_time is not None:
        _params["minLastModifiedDateTime"] = _SERIALIZER.query(
            "min_last_modified_date_time", min_last_modified_date_time, "iso-8601"
        )
    if max_last_modified_date_time is not None:
        _params["maxLastModifiedDateTime"] = _SERIALIZER.query(
            "max_last_modified_date_time", max_last_modified_date_time, "iso-8601"
        )
    if skip_token is not None:
        _params["skipToken"] = _SERIALIZER.query("skip_token", skip_token, "str")
    _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")

    # Construct headers
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="GET", url=_url, params=_params, headers=_headers, **kwargs)


def build_devices_create_or_update_request(sensor_partner_id: str, device_id: str, **kwargs: Any) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    content_type = kwargs.pop("content_type", _headers.pop("Content-Type", None))  # type: Optional[str]
    api_version = kwargs.pop("api_version", _params.pop("api-version", "2022-11-01-preview"))  # type: str
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/sensor-partners/{sensorPartnerId}/devices/{deviceId}"
    path_format_arguments = {
        "sensorPartnerId": _SERIALIZER.url("sensor_partner_id", sensor_partner_id, "str"),
        "deviceId": _SERIALIZER.url("device_id", device_id, "str"),
    }

    _url = _format_url_section(_url, **path_format_arguments)

    # Construct parameters
    _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")

    # Construct headers
    if content_type is not None:
        _headers["Content-Type"] = _SERIALIZER.header("content_type", content_type, "str")
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="PATCH", url=_url, params=_params, headers=_headers, **kwargs)


def build_devices_get_request(sensor_partner_id: str, device_id: str, **kwargs: Any) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    api_version = kwargs.pop("api_version", _params.pop("api-version", "2022-11-01-preview"))  # type: str
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/sensor-partners/{sensorPartnerId}/devices/{deviceId}"
    path_format_arguments = {
        "sensorPartnerId": _SERIALIZER.url("sensor_partner_id", sensor_partner_id, "str"),
        "deviceId": _SERIALIZER.url("device_id", device_id, "str"),
    }

    _url = _format_url_section(_url, **path_format_arguments)

    # Construct parameters
    _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")

    # Construct headers
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="GET", url=_url, params=_params, headers=_headers, **kwargs)


def build_devices_delete_request(sensor_partner_id: str, device_id: str, **kwargs: Any) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    api_version = kwargs.pop("api_version", _params.pop("api-version", "2022-11-01-preview"))  # type: str
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/sensor-partners/{sensorPartnerId}/devices/{deviceId}"
    path_format_arguments = {
        "sensorPartnerId": _SERIALIZER.url("sensor_partner_id", sensor_partner_id, "str"),
        "deviceId": _SERIALIZER.url("device_id", device_id, "str"),
    }

    _url = _format_url_section(_url, **path_format_arguments)

    # Construct parameters
    _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")

    # Construct headers
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="DELETE", url=_url, params=_params, headers=_headers, **kwargs)


def build_farm_operations_create_data_ingestion_job_request(job_id: str, **kwargs: Any) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    content_type = kwargs.pop("content_type", _headers.pop("Content-Type", None))  # type: Optional[str]
    api_version = kwargs.pop("api_version", _params.pop("api-version", "2022-11-01-preview"))  # type: str
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/farm-operations/ingest-data/{jobId}"
    path_format_arguments = {
        "jobId": _SERIALIZER.url("job_id", job_id, "str"),
    }

    _url = _format_url_section(_url, **path_format_arguments)

    # Construct parameters
    _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")

    # Construct headers
    if content_type is not None:
        _headers["Content-Type"] = _SERIALIZER.header("content_type", content_type, "str")
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="PUT", url=_url, params=_params, headers=_headers, **kwargs)


def build_farm_operations_get_data_ingestion_job_details_request(job_id: str, **kwargs: Any) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    api_version = kwargs.pop("api_version", _params.pop("api-version", "2022-11-01-preview"))  # type: str
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/farm-operations/ingest-data/{jobId}"
    path_format_arguments = {
        "jobId": _SERIALIZER.url("job_id", job_id, "str"),
    }

    _url = _format_url_section(_url, **path_format_arguments)

    # Construct parameters
    _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")

    # Construct headers
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="GET", url=_url, params=_params, headers=_headers, **kwargs)


def build_farms_list_request(
    *,
    ids: Optional[List[str]] = None,
    names: Optional[List[str]] = None,
    property_filters: Optional[List[str]] = None,
    statuses: Optional[List[str]] = None,
    min_created_date_time: Optional[datetime.datetime] = None,
    max_created_date_time: Optional[datetime.datetime] = None,
    min_last_modified_date_time: Optional[datetime.datetime] = None,
    max_last_modified_date_time: Optional[datetime.datetime] = None,
    skip_token: Optional[str] = None,
    **kwargs: Any
) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    api_version = kwargs.pop("api_version", _params.pop("api-version", "2022-11-01-preview"))  # type: str
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/farms"

    # Construct parameters
    if ids is not None:
        _params["ids"] = [_SERIALIZER.query("ids", q, "str") if q is not None else "" for q in ids]
    if names is not None:
        _params["names"] = [_SERIALIZER.query("names", q, "str") if q is not None else "" for q in names]
    if property_filters is not None:
        _params["propertyFilters"] = [
            _SERIALIZER.query("property_filters", q, "str") if q is not None else "" for q in property_filters
        ]
    if statuses is not None:
        _params["statuses"] = [_SERIALIZER.query("statuses", q, "str") if q is not None else "" for q in statuses]
    if min_created_date_time is not None:
        _params["minCreatedDateTime"] = _SERIALIZER.query("min_created_date_time", min_created_date_time, "iso-8601")
    if max_created_date_time is not None:
        _params["maxCreatedDateTime"] = _SERIALIZER.query("max_created_date_time", max_created_date_time, "iso-8601")
    if min_last_modified_date_time is not None:
        _params["minLastModifiedDateTime"] = _SERIALIZER.query(
            "min_last_modified_date_time", min_last_modified_date_time, "iso-8601"
        )
    if max_last_modified_date_time is not None:
        _params["maxLastModifiedDateTime"] = _SERIALIZER.query(
            "max_last_modified_date_time", max_last_modified_date_time, "iso-8601"
        )
    if skip_token is not None:
        _params["skipToken"] = _SERIALIZER.query("skip_token", skip_token, "str")
    _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")

    # Construct headers
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="GET", url=_url, params=_params, headers=_headers, **kwargs)


def build_farms_create_cascade_delete_job_request(
    job_id: str, *, party_id: str, farm_id: str, **kwargs: Any
) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    api_version = kwargs.pop("api_version", _params.pop("api-version", "2022-11-01-preview"))  # type: str
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/farms/cascade-delete/{jobId}"
    path_format_arguments = {
        "jobId": _SERIALIZER.url("job_id", job_id, "str"),
    }

    _url = _format_url_section(_url, **path_format_arguments)

    # Construct parameters
    _params["partyId"] = _SERIALIZER.query("party_id", party_id, "str")
    _params["farmId"] = _SERIALIZER.query("farm_id", farm_id, "str")
    _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")

    # Construct headers
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="PUT", url=_url, params=_params, headers=_headers, **kwargs)


def build_farms_get_cascade_delete_job_details_request(job_id: str, **kwargs: Any) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    api_version = kwargs.pop("api_version", _params.pop("api-version", "2022-11-01-preview"))  # type: str
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/farms/cascade-delete/{jobId}"
    path_format_arguments = {
        "jobId": _SERIALIZER.url("job_id", job_id, "str"),
    }

    _url = _format_url_section(_url, **path_format_arguments)

    # Construct parameters
    _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")

    # Construct headers
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="GET", url=_url, params=_params, headers=_headers, **kwargs)


def build_farms_list_by_party_id_request(
    party_id: str,
    *,
    ids: Optional[List[str]] = None,
    names: Optional[List[str]] = None,
    property_filters: Optional[List[str]] = None,
    statuses: Optional[List[str]] = None,
    min_created_date_time: Optional[datetime.datetime] = None,
    max_created_date_time: Optional[datetime.datetime] = None,
    min_last_modified_date_time: Optional[datetime.datetime] = None,
    max_last_modified_date_time: Optional[datetime.datetime] = None,
    skip_token: Optional[str] = None,
    **kwargs: Any
) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    api_version = kwargs.pop("api_version", _params.pop("api-version", "2022-11-01-preview"))  # type: str
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/parties/{partyId}/farms"
    path_format_arguments = {
        "partyId": _SERIALIZER.url("party_id", party_id, "str"),
    }

    _url = _format_url_section(_url, **path_format_arguments)

    # Construct parameters
    if ids is not None:
        _params["ids"] = [_SERIALIZER.query("ids", q, "str") if q is not None else "" for q in ids]
    if names is not None:
        _params["names"] = [_SERIALIZER.query("names", q, "str") if q is not None else "" for q in names]
    if property_filters is not None:
        _params["propertyFilters"] = [
            _SERIALIZER.query("property_filters", q, "str") if q is not None else "" for q in property_filters
        ]
    if statuses is not None:
        _params["statuses"] = [_SERIALIZER.query("statuses", q, "str") if q is not None else "" for q in statuses]
    if min_created_date_time is not None:
        _params["minCreatedDateTime"] = _SERIALIZER.query("min_created_date_time", min_created_date_time, "iso-8601")
    if max_created_date_time is not None:
        _params["maxCreatedDateTime"] = _SERIALIZER.query("max_created_date_time", max_created_date_time, "iso-8601")
    if min_last_modified_date_time is not None:
        _params["minLastModifiedDateTime"] = _SERIALIZER.query(
            "min_last_modified_date_time", min_last_modified_date_time, "iso-8601"
        )
    if max_last_modified_date_time is not None:
        _params["maxLastModifiedDateTime"] = _SERIALIZER.query(
            "max_last_modified_date_time", max_last_modified_date_time, "iso-8601"
        )
    if skip_token is not None:
        _params["skipToken"] = _SERIALIZER.query("skip_token", skip_token, "str")
    _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")

    # Construct headers
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="GET", url=_url, params=_params, headers=_headers, **kwargs)


def build_farms_get_request(party_id: str, farm_id: str, **kwargs: Any) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    api_version = kwargs.pop("api_version", _params.pop("api-version", "2022-11-01-preview"))  # type: str
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/parties/{partyId}/farms/{farmId}"
    path_format_arguments = {
        "partyId": _SERIALIZER.url("party_id", party_id, "str"),
        "farmId": _SERIALIZER.url("farm_id", farm_id, "str"),
    }

    _url = _format_url_section(_url, **path_format_arguments)

    # Construct parameters
    _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")

    # Construct headers
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="GET", url=_url, params=_params, headers=_headers, **kwargs)


def build_farms_create_or_update_request(party_id: str, farm_id: str, **kwargs: Any) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    content_type = kwargs.pop("content_type", _headers.pop("Content-Type", None))  # type: Optional[str]
    api_version = kwargs.pop("api_version", _params.pop("api-version", "2022-11-01-preview"))  # type: str
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/parties/{partyId}/farms/{farmId}"
    path_format_arguments = {
        "partyId": _SERIALIZER.url("party_id", party_id, "str"),
        "farmId": _SERIALIZER.url("farm_id", farm_id, "str"),
    }

    _url = _format_url_section(_url, **path_format_arguments)

    # Construct parameters
    _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")

    # Construct headers
    if content_type is not None:
        _headers["Content-Type"] = _SERIALIZER.header("content_type", content_type, "str")
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="PATCH", url=_url, params=_params, headers=_headers, **kwargs)


def build_farms_delete_request(party_id: str, farm_id: str, **kwargs: Any) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    api_version = kwargs.pop("api_version", _params.pop("api-version", "2022-11-01-preview"))  # type: str
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/parties/{partyId}/farms/{farmId}"
    path_format_arguments = {
        "partyId": _SERIALIZER.url("party_id", party_id, "str"),
        "farmId": _SERIALIZER.url("farm_id", farm_id, "str"),
    }

    _url = _format_url_section(_url, **path_format_arguments)

    # Construct parameters
    _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")

    # Construct headers
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="DELETE", url=_url, params=_params, headers=_headers, **kwargs)


def build_fields_list_request(
    *,
    farm_ids: Optional[List[str]] = None,
    ids: Optional[List[str]] = None,
    names: Optional[List[str]] = None,
    property_filters: Optional[List[str]] = None,
    statuses: Optional[List[str]] = None,
    min_created_date_time: Optional[datetime.datetime] = None,
    max_created_date_time: Optional[datetime.datetime] = None,
    min_last_modified_date_time: Optional[datetime.datetime] = None,
    max_last_modified_date_time: Optional[datetime.datetime] = None,
    skip_token: Optional[str] = None,
    **kwargs: Any
) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    api_version = kwargs.pop("api_version", _params.pop("api-version", "2022-11-01-preview"))  # type: str
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/fields"

    # Construct parameters
    if farm_ids is not None:
        _params["farmIds"] = [_SERIALIZER.query("farm_ids", q, "str") if q is not None else "" for q in farm_ids]
    if ids is not None:
        _params["ids"] = [_SERIALIZER.query("ids", q, "str") if q is not None else "" for q in ids]
    if names is not None:
        _params["names"] = [_SERIALIZER.query("names", q, "str") if q is not None else "" for q in names]
    if property_filters is not None:
        _params["propertyFilters"] = [
            _SERIALIZER.query("property_filters", q, "str") if q is not None else "" for q in property_filters
        ]
    if statuses is not None:
        _params["statuses"] = [_SERIALIZER.query("statuses", q, "str") if q is not None else "" for q in statuses]
    if min_created_date_time is not None:
        _params["minCreatedDateTime"] = _SERIALIZER.query("min_created_date_time", min_created_date_time, "iso-8601")
    if max_created_date_time is not None:
        _params["maxCreatedDateTime"] = _SERIALIZER.query("max_created_date_time", max_created_date_time, "iso-8601")
    if min_last_modified_date_time is not None:
        _params["minLastModifiedDateTime"] = _SERIALIZER.query(
            "min_last_modified_date_time", min_last_modified_date_time, "iso-8601"
        )
    if max_last_modified_date_time is not None:
        _params["maxLastModifiedDateTime"] = _SERIALIZER.query(
            "max_last_modified_date_time", max_last_modified_date_time, "iso-8601"
        )
    if skip_token is not None:
        _params["skipToken"] = _SERIALIZER.query("skip_token", skip_token, "str")
    _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")

    # Construct headers
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="GET", url=_url, params=_params, headers=_headers, **kwargs)


def build_fields_get_cascade_delete_job_details_request(job_id: str, **kwargs: Any) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    api_version = kwargs.pop("api_version", _params.pop("api-version", "2022-11-01-preview"))  # type: str
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/fields/cascade-delete/{jobId}"
    path_format_arguments = {
        "jobId": _SERIALIZER.url("job_id", job_id, "str"),
    }

    _url = _format_url_section(_url, **path_format_arguments)

    # Construct parameters
    _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")

    # Construct headers
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="GET", url=_url, params=_params, headers=_headers, **kwargs)


def build_fields_create_cascade_delete_job_request(
    job_id: str, *, party_id: str, field_id: str, **kwargs: Any
) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    api_version = kwargs.pop("api_version", _params.pop("api-version", "2022-11-01-preview"))  # type: str
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/fields/cascade-delete/{jobId}"
    path_format_arguments = {
        "jobId": _SERIALIZER.url("job_id", job_id, "str"),
    }

    _url = _format_url_section(_url, **path_format_arguments)

    # Construct parameters
    _params["partyId"] = _SERIALIZER.query("party_id", party_id, "str")
    _params["fieldId"] = _SERIALIZER.query("field_id", field_id, "str")
    _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")

    # Construct headers
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="PUT", url=_url, params=_params, headers=_headers, **kwargs)


def build_fields_list_by_party_id_request(
    party_id: str,
    *,
    farm_ids: Optional[List[str]] = None,
    ids: Optional[List[str]] = None,
    names: Optional[List[str]] = None,
    property_filters: Optional[List[str]] = None,
    statuses: Optional[List[str]] = None,
    min_created_date_time: Optional[datetime.datetime] = None,
    max_created_date_time: Optional[datetime.datetime] = None,
    min_last_modified_date_time: Optional[datetime.datetime] = None,
    max_last_modified_date_time: Optional[datetime.datetime] = None,
    skip_token: Optional[str] = None,
    **kwargs: Any
) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    api_version = kwargs.pop("api_version", _params.pop("api-version", "2022-11-01-preview"))  # type: str
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/parties/{partyId}/fields"
    path_format_arguments = {
        "partyId": _SERIALIZER.url("party_id", party_id, "str"),
    }

    _url = _format_url_section(_url, **path_format_arguments)

    # Construct parameters
    if farm_ids is not None:
        _params["farmIds"] = [_SERIALIZER.query("farm_ids", q, "str") if q is not None else "" for q in farm_ids]
    if ids is not None:
        _params["ids"] = [_SERIALIZER.query("ids", q, "str") if q is not None else "" for q in ids]
    if names is not None:
        _params["names"] = [_SERIALIZER.query("names", q, "str") if q is not None else "" for q in names]
    if property_filters is not None:
        _params["propertyFilters"] = [
            _SERIALIZER.query("property_filters", q, "str") if q is not None else "" for q in property_filters
        ]
    if statuses is not None:
        _params["statuses"] = [_SERIALIZER.query("statuses", q, "str") if q is not None else "" for q in statuses]
    if min_created_date_time is not None:
        _params["minCreatedDateTime"] = _SERIALIZER.query("min_created_date_time", min_created_date_time, "iso-8601")
    if max_created_date_time is not None:
        _params["maxCreatedDateTime"] = _SERIALIZER.query("max_created_date_time", max_created_date_time, "iso-8601")
    if min_last_modified_date_time is not None:
        _params["minLastModifiedDateTime"] = _SERIALIZER.query(
            "min_last_modified_date_time", min_last_modified_date_time, "iso-8601"
        )
    if max_last_modified_date_time is not None:
        _params["maxLastModifiedDateTime"] = _SERIALIZER.query(
            "max_last_modified_date_time", max_last_modified_date_time, "iso-8601"
        )
    if skip_token is not None:
        _params["skipToken"] = _SERIALIZER.query("skip_token", skip_token, "str")
    _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")

    # Construct headers
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="GET", url=_url, params=_params, headers=_headers, **kwargs)


def build_fields_get_request(party_id: str, field_id: str, **kwargs: Any) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    api_version = kwargs.pop("api_version", _params.pop("api-version", "2022-11-01-preview"))  # type: str
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/parties/{partyId}/fields/{fieldId}"
    path_format_arguments = {
        "partyId": _SERIALIZER.url("party_id", party_id, "str"),
        "fieldId": _SERIALIZER.url("field_id", field_id, "str"),
    }

    _url = _format_url_section(_url, **path_format_arguments)

    # Construct parameters
    _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")

    # Construct headers
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="GET", url=_url, params=_params, headers=_headers, **kwargs)


def build_fields_create_or_update_request(party_id: str, field_id: str, **kwargs: Any) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    content_type = kwargs.pop("content_type", _headers.pop("Content-Type", None))  # type: Optional[str]
    api_version = kwargs.pop("api_version", _params.pop("api-version", "2022-11-01-preview"))  # type: str
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/parties/{partyId}/fields/{fieldId}"
    path_format_arguments = {
        "partyId": _SERIALIZER.url("party_id", party_id, "str"),
        "fieldId": _SERIALIZER.url("field_id", field_id, "str"),
    }

    _url = _format_url_section(_url, **path_format_arguments)

    # Construct parameters
    _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")

    # Construct headers
    if content_type is not None:
        _headers["Content-Type"] = _SERIALIZER.header("content_type", content_type, "str")
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="PATCH", url=_url, params=_params, headers=_headers, **kwargs)


def build_fields_delete_request(party_id: str, field_id: str, **kwargs: Any) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    api_version = kwargs.pop("api_version", _params.pop("api-version", "2022-11-01-preview"))  # type: str
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/parties/{partyId}/fields/{fieldId}"
    path_format_arguments = {
        "partyId": _SERIALIZER.url("party_id", party_id, "str"),
        "fieldId": _SERIALIZER.url("field_id", field_id, "str"),
    }

    _url = _format_url_section(_url, **path_format_arguments)

    # Construct parameters
    _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")

    # Construct headers
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="DELETE", url=_url, params=_params, headers=_headers, **kwargs)


def build_harvest_data_list_request(
    *,
    min_total_yield: Optional[float] = None,
    max_total_yield: Optional[float] = None,
    min_avg_yield: Optional[float] = None,
    max_avg_yield: Optional[float] = None,
    min_total_wet_mass: Optional[float] = None,
    max_total_wet_mass: Optional[float] = None,
    min_avg_wet_mass: Optional[float] = None,
    max_avg_wet_mass: Optional[float] = None,
    min_avg_moisture: Optional[float] = None,
    max_avg_moisture: Optional[float] = None,
    min_avg_speed: Optional[float] = None,
    max_avg_speed: Optional[float] = None,
    sources: Optional[List[str]] = None,
    associated_boundary_ids: Optional[List[str]] = None,
    min_operation_start_date_time: Optional[datetime.datetime] = None,
    max_operation_start_date_time: Optional[datetime.datetime] = None,
    min_operation_end_date_time: Optional[datetime.datetime] = None,
    max_operation_end_date_time: Optional[datetime.datetime] = None,
    min_operation_modified_date_time: Optional[datetime.datetime] = None,
    max_operation_modified_date_time: Optional[datetime.datetime] = None,
    min_area: Optional[float] = None,
    max_area: Optional[float] = None,
    ids: Optional[List[str]] = None,
    names: Optional[List[str]] = None,
    property_filters: Optional[List[str]] = None,
    statuses: Optional[List[str]] = None,
    min_created_date_time: Optional[datetime.datetime] = None,
    max_created_date_time: Optional[datetime.datetime] = None,
    min_last_modified_date_time: Optional[datetime.datetime] = None,
    max_last_modified_date_time: Optional[datetime.datetime] = None,
    skip_token: Optional[str] = None,
    **kwargs: Any
) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    api_version = kwargs.pop("api_version", _params.pop("api-version", "2022-11-01-preview"))  # type: str
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/harvest-data"

    # Construct parameters
    if min_total_yield is not None:
        _params["minTotalYield"] = _SERIALIZER.query("min_total_yield", min_total_yield, "float")
    if max_total_yield is not None:
        _params["maxTotalYield"] = _SERIALIZER.query("max_total_yield", max_total_yield, "float")
    if min_avg_yield is not None:
        _params["minAvgYield"] = _SERIALIZER.query("min_avg_yield", min_avg_yield, "float")
    if max_avg_yield is not None:
        _params["maxAvgYield"] = _SERIALIZER.query("max_avg_yield", max_avg_yield, "float")
    if min_total_wet_mass is not None:
        _params["minTotalWetMass"] = _SERIALIZER.query("min_total_wet_mass", min_total_wet_mass, "float")
    if max_total_wet_mass is not None:
        _params["maxTotalWetMass"] = _SERIALIZER.query("max_total_wet_mass", max_total_wet_mass, "float")
    if min_avg_wet_mass is not None:
        _params["minAvgWetMass"] = _SERIALIZER.query("min_avg_wet_mass", min_avg_wet_mass, "float")
    if max_avg_wet_mass is not None:
        _params["maxAvgWetMass"] = _SERIALIZER.query("max_avg_wet_mass", max_avg_wet_mass, "float")
    if min_avg_moisture is not None:
        _params["minAvgMoisture"] = _SERIALIZER.query("min_avg_moisture", min_avg_moisture, "float")
    if max_avg_moisture is not None:
        _params["maxAvgMoisture"] = _SERIALIZER.query("max_avg_moisture", max_avg_moisture, "float")
    if min_avg_speed is not None:
        _params["minAvgSpeed"] = _SERIALIZER.query("min_avg_speed", min_avg_speed, "float")
    if max_avg_speed is not None:
        _params["maxAvgSpeed"] = _SERIALIZER.query("max_avg_speed", max_avg_speed, "float")
    if sources is not None:
        _params["sources"] = [_SERIALIZER.query("sources", q, "str") if q is not None else "" for q in sources]
    if associated_boundary_ids is not None:
        _params["associatedBoundaryIds"] = [
            _SERIALIZER.query("associated_boundary_ids", q, "str") if q is not None else ""
            for q in associated_boundary_ids
        ]
    if min_operation_start_date_time is not None:
        _params["minOperationStartDateTime"] = _SERIALIZER.query(
            "min_operation_start_date_time", min_operation_start_date_time, "iso-8601"
        )
    if max_operation_start_date_time is not None:
        _params["maxOperationStartDateTime"] = _SERIALIZER.query(
            "max_operation_start_date_time", max_operation_start_date_time, "iso-8601"
        )
    if min_operation_end_date_time is not None:
        _params["minOperationEndDateTime"] = _SERIALIZER.query(
            "min_operation_end_date_time", min_operation_end_date_time, "iso-8601"
        )
    if max_operation_end_date_time is not None:
        _params["maxOperationEndDateTime"] = _SERIALIZER.query(
            "max_operation_end_date_time", max_operation_end_date_time, "iso-8601"
        )
    if min_operation_modified_date_time is not None:
        _params["minOperationModifiedDateTime"] = _SERIALIZER.query(
            "min_operation_modified_date_time", min_operation_modified_date_time, "iso-8601"
        )
    if max_operation_modified_date_time is not None:
        _params["maxOperationModifiedDateTime"] = _SERIALIZER.query(
            "max_operation_modified_date_time", max_operation_modified_date_time, "iso-8601"
        )
    if min_area is not None:
        _params["minArea"] = _SERIALIZER.query("min_area", min_area, "float")
    if max_area is not None:
        _params["maxArea"] = _SERIALIZER.query("max_area", max_area, "float")
    if ids is not None:
        _params["ids"] = [_SERIALIZER.query("ids", q, "str") if q is not None else "" for q in ids]
    if names is not None:
        _params["names"] = [_SERIALIZER.query("names", q, "str") if q is not None else "" for q in names]
    if property_filters is not None:
        _params["propertyFilters"] = [
            _SERIALIZER.query("property_filters", q, "str") if q is not None else "" for q in property_filters
        ]
    if statuses is not None:
        _params["statuses"] = [_SERIALIZER.query("statuses", q, "str") if q is not None else "" for q in statuses]
    if min_created_date_time is not None:
        _params["minCreatedDateTime"] = _SERIALIZER.query("min_created_date_time", min_created_date_time, "iso-8601")
    if max_created_date_time is not None:
        _params["maxCreatedDateTime"] = _SERIALIZER.query("max_created_date_time", max_created_date_time, "iso-8601")
    if min_last_modified_date_time is not None:
        _params["minLastModifiedDateTime"] = _SERIALIZER.query(
            "min_last_modified_date_time", min_last_modified_date_time, "iso-8601"
        )
    if max_last_modified_date_time is not None:
        _params["maxLastModifiedDateTime"] = _SERIALIZER.query(
            "max_last_modified_date_time", max_last_modified_date_time, "iso-8601"
        )
    if skip_token is not None:
        _params["skipToken"] = _SERIALIZER.query("skip_token", skip_token, "str")
    _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")

    # Construct headers
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="GET", url=_url, params=_params, headers=_headers, **kwargs)


def build_harvest_data_create_cascade_delete_job_request(
    job_id: str, *, party_id: str, harvest_data_id: str, **kwargs: Any
) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    api_version = kwargs.pop("api_version", _params.pop("api-version", "2022-11-01-preview"))  # type: str
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/harvest-data/cascade-delete/{jobId}"
    path_format_arguments = {
        "jobId": _SERIALIZER.url("job_id", job_id, "str"),
    }

    _url = _format_url_section(_url, **path_format_arguments)

    # Construct parameters
    _params["partyId"] = _SERIALIZER.query("party_id", party_id, "str")
    _params["harvestDataId"] = _SERIALIZER.query("harvest_data_id", harvest_data_id, "str")
    _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")

    # Construct headers
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="PUT", url=_url, params=_params, headers=_headers, **kwargs)


def build_harvest_data_get_cascade_delete_job_details_request(job_id: str, **kwargs: Any) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    api_version = kwargs.pop("api_version", _params.pop("api-version", "2022-11-01-preview"))  # type: str
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/harvest-data/cascade-delete/{jobId}"
    path_format_arguments = {
        "jobId": _SERIALIZER.url("job_id", job_id, "str"),
    }

    _url = _format_url_section(_url, **path_format_arguments)

    # Construct parameters
    _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")

    # Construct headers
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="GET", url=_url, params=_params, headers=_headers, **kwargs)


def build_harvest_data_list_by_party_id_request(
    party_id: str,
    *,
    min_total_yield: Optional[float] = None,
    max_total_yield: Optional[float] = None,
    min_avg_yield: Optional[float] = None,
    max_avg_yield: Optional[float] = None,
    min_total_wet_mass: Optional[float] = None,
    max_total_wet_mass: Optional[float] = None,
    min_avg_wet_mass: Optional[float] = None,
    max_avg_wet_mass: Optional[float] = None,
    min_avg_moisture: Optional[float] = None,
    max_avg_moisture: Optional[float] = None,
    min_avg_speed: Optional[float] = None,
    max_avg_speed: Optional[float] = None,
    sources: Optional[List[str]] = None,
    associated_boundary_ids: Optional[List[str]] = None,
    min_operation_start_date_time: Optional[datetime.datetime] = None,
    max_operation_start_date_time: Optional[datetime.datetime] = None,
    min_operation_end_date_time: Optional[datetime.datetime] = None,
    max_operation_end_date_time: Optional[datetime.datetime] = None,
    min_operation_modified_date_time: Optional[datetime.datetime] = None,
    max_operation_modified_date_time: Optional[datetime.datetime] = None,
    min_area: Optional[float] = None,
    max_area: Optional[float] = None,
    ids: Optional[List[str]] = None,
    names: Optional[List[str]] = None,
    property_filters: Optional[List[str]] = None,
    statuses: Optional[List[str]] = None,
    min_created_date_time: Optional[datetime.datetime] = None,
    max_created_date_time: Optional[datetime.datetime] = None,
    min_last_modified_date_time: Optional[datetime.datetime] = None,
    max_last_modified_date_time: Optional[datetime.datetime] = None,
    skip_token: Optional[str] = None,
    **kwargs: Any
) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    api_version = kwargs.pop("api_version", _params.pop("api-version", "2022-11-01-preview"))  # type: str
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/parties/{partyId}/harvest-data"
    path_format_arguments = {
        "partyId": _SERIALIZER.url("party_id", party_id, "str"),
    }

    _url = _format_url_section(_url, **path_format_arguments)

    # Construct parameters
    if min_total_yield is not None:
        _params["minTotalYield"] = _SERIALIZER.query("min_total_yield", min_total_yield, "float")
    if max_total_yield is not None:
        _params["maxTotalYield"] = _SERIALIZER.query("max_total_yield", max_total_yield, "float")
    if min_avg_yield is not None:
        _params["minAvgYield"] = _SERIALIZER.query("min_avg_yield", min_avg_yield, "float")
    if max_avg_yield is not None:
        _params["maxAvgYield"] = _SERIALIZER.query("max_avg_yield", max_avg_yield, "float")
    if min_total_wet_mass is not None:
        _params["minTotalWetMass"] = _SERIALIZER.query("min_total_wet_mass", min_total_wet_mass, "float")
    if max_total_wet_mass is not None:
        _params["maxTotalWetMass"] = _SERIALIZER.query("max_total_wet_mass", max_total_wet_mass, "float")
    if min_avg_wet_mass is not None:
        _params["minAvgWetMass"] = _SERIALIZER.query("min_avg_wet_mass", min_avg_wet_mass, "float")
    if max_avg_wet_mass is not None:
        _params["maxAvgWetMass"] = _SERIALIZER.query("max_avg_wet_mass", max_avg_wet_mass, "float")
    if min_avg_moisture is not None:
        _params["minAvgMoisture"] = _SERIALIZER.query("min_avg_moisture", min_avg_moisture, "float")
    if max_avg_moisture is not None:
        _params["maxAvgMoisture"] = _SERIALIZER.query("max_avg_moisture", max_avg_moisture, "float")
    if min_avg_speed is not None:
        _params["minAvgSpeed"] = _SERIALIZER.query("min_avg_speed", min_avg_speed, "float")
    if max_avg_speed is not None:
        _params["maxAvgSpeed"] = _SERIALIZER.query("max_avg_speed", max_avg_speed, "float")
    if sources is not None:
        _params["sources"] = [_SERIALIZER.query("sources", q, "str") if q is not None else "" for q in sources]
    if associated_boundary_ids is not None:
        _params["associatedBoundaryIds"] = [
            _SERIALIZER.query("associated_boundary_ids", q, "str") if q is not None else ""
            for q in associated_boundary_ids
        ]
    if min_operation_start_date_time is not None:
        _params["minOperationStartDateTime"] = _SERIALIZER.query(
            "min_operation_start_date_time", min_operation_start_date_time, "iso-8601"
        )
    if max_operation_start_date_time is not None:
        _params["maxOperationStartDateTime"] = _SERIALIZER.query(
            "max_operation_start_date_time", max_operation_start_date_time, "iso-8601"
        )
    if min_operation_end_date_time is not None:
        _params["minOperationEndDateTime"] = _SERIALIZER.query(
            "min_operation_end_date_time", min_operation_end_date_time, "iso-8601"
        )
    if max_operation_end_date_time is not None:
        _params["maxOperationEndDateTime"] = _SERIALIZER.query(
            "max_operation_end_date_time", max_operation_end_date_time, "iso-8601"
        )
    if min_operation_modified_date_time is not None:
        _params["minOperationModifiedDateTime"] = _SERIALIZER.query(
            "min_operation_modified_date_time", min_operation_modified_date_time, "iso-8601"
        )
    if max_operation_modified_date_time is not None:
        _params["maxOperationModifiedDateTime"] = _SERIALIZER.query(
            "max_operation_modified_date_time", max_operation_modified_date_time, "iso-8601"
        )
    if min_area is not None:
        _params["minArea"] = _SERIALIZER.query("min_area", min_area, "float")
    if max_area is not None:
        _params["maxArea"] = _SERIALIZER.query("max_area", max_area, "float")
    if ids is not None:
        _params["ids"] = [_SERIALIZER.query("ids", q, "str") if q is not None else "" for q in ids]
    if names is not None:
        _params["names"] = [_SERIALIZER.query("names", q, "str") if q is not None else "" for q in names]
    if property_filters is not None:
        _params["propertyFilters"] = [
            _SERIALIZER.query("property_filters", q, "str") if q is not None else "" for q in property_filters
        ]
    if statuses is not None:
        _params["statuses"] = [_SERIALIZER.query("statuses", q, "str") if q is not None else "" for q in statuses]
    if min_created_date_time is not None:
        _params["minCreatedDateTime"] = _SERIALIZER.query("min_created_date_time", min_created_date_time, "iso-8601")
    if max_created_date_time is not None:
        _params["maxCreatedDateTime"] = _SERIALIZER.query("max_created_date_time", max_created_date_time, "iso-8601")
    if min_last_modified_date_time is not None:
        _params["minLastModifiedDateTime"] = _SERIALIZER.query(
            "min_last_modified_date_time", min_last_modified_date_time, "iso-8601"
        )
    if max_last_modified_date_time is not None:
        _params["maxLastModifiedDateTime"] = _SERIALIZER.query(
            "max_last_modified_date_time", max_last_modified_date_time, "iso-8601"
        )
    if skip_token is not None:
        _params["skipToken"] = _SERIALIZER.query("skip_token", skip_token, "str")
    _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")

    # Construct headers
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="GET", url=_url, params=_params, headers=_headers, **kwargs)


def build_harvest_data_get_request(party_id: str, harvest_data_id: str, **kwargs: Any) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    api_version = kwargs.pop("api_version", _params.pop("api-version", "2022-11-01-preview"))  # type: str
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/parties/{partyId}/harvest-data/{harvestDataId}"
    path_format_arguments = {
        "partyId": _SERIALIZER.url("party_id", party_id, "str"),
        "harvestDataId": _SERIALIZER.url("harvest_data_id", harvest_data_id, "str"),
    }

    _url = _format_url_section(_url, **path_format_arguments)

    # Construct parameters
    _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")

    # Construct headers
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="GET", url=_url, params=_params, headers=_headers, **kwargs)


def build_harvest_data_create_or_update_request(party_id: str, harvest_data_id: str, **kwargs: Any) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    content_type = kwargs.pop("content_type", _headers.pop("Content-Type", None))  # type: Optional[str]
    api_version = kwargs.pop("api_version", _params.pop("api-version", "2022-11-01-preview"))  # type: str
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/parties/{partyId}/harvest-data/{harvestDataId}"
    path_format_arguments = {
        "partyId": _SERIALIZER.url("party_id", party_id, "str"),
        "harvestDataId": _SERIALIZER.url("harvest_data_id", harvest_data_id, "str"),
    }

    _url = _format_url_section(_url, **path_format_arguments)

    # Construct parameters
    _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")

    # Construct headers
    if content_type is not None:
        _headers["Content-Type"] = _SERIALIZER.header("content_type", content_type, "str")
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="PATCH", url=_url, params=_params, headers=_headers, **kwargs)


def build_harvest_data_delete_request(party_id: str, harvest_data_id: str, **kwargs: Any) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    api_version = kwargs.pop("api_version", _params.pop("api-version", "2022-11-01-preview"))  # type: str
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/parties/{partyId}/harvest-data/{harvestDataId}"
    path_format_arguments = {
        "partyId": _SERIALIZER.url("party_id", party_id, "str"),
        "harvestDataId": _SERIALIZER.url("harvest_data_id", harvest_data_id, "str"),
    }

    _url = _format_url_section(_url, **path_format_arguments)

    # Construct parameters
    _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")

    # Construct headers
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="DELETE", url=_url, params=_params, headers=_headers, **kwargs)


def build_image_processing_create_rasterize_job_request(job_id: str, **kwargs: Any) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    content_type = kwargs.pop("content_type", _headers.pop("Content-Type", None))  # type: Optional[str]
    api_version = kwargs.pop("api_version", _params.pop("api-version", "2022-11-01-preview"))  # type: str
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/image-processing/rasterize/{jobId}"
    path_format_arguments = {
        "jobId": _SERIALIZER.url("job_id", job_id, "str"),
    }

    _url = _format_url_section(_url, **path_format_arguments)

    # Construct parameters
    _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")

    # Construct headers
    if content_type is not None:
        _headers["Content-Type"] = _SERIALIZER.header("content_type", content_type, "str")
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="PUT", url=_url, params=_params, headers=_headers, **kwargs)


def build_image_processing_get_rasterize_job_request(job_id: str, **kwargs: Any) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    api_version = kwargs.pop("api_version", _params.pop("api-version", "2022-11-01-preview"))  # type: str
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/image-processing/rasterize/{jobId}"
    path_format_arguments = {
        "jobId": _SERIALIZER.url("job_id", job_id, "str"),
    }

    _url = _format_url_section(_url, **path_format_arguments)

    # Construct parameters
    _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")

    # Construct headers
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="GET", url=_url, params=_params, headers=_headers, **kwargs)


def build_insight_attachments_list_by_party_id_model_id_and_resource_request(
    party_id: str,
    model_id: str,
    resource_type: str,
    resource_id: str,
    *,
    insight_ids: Optional[List[str]] = None,
    ids: Optional[List[str]] = None,
    names: Optional[List[str]] = None,
    property_filters: Optional[List[str]] = None,
    statuses: Optional[List[str]] = None,
    min_created_date_time: Optional[datetime.datetime] = None,
    max_created_date_time: Optional[datetime.datetime] = None,
    min_last_modified_date_time: Optional[datetime.datetime] = None,
    max_last_modified_date_time: Optional[datetime.datetime] = None,
    skip_token: Optional[str] = None,
    **kwargs: Any
) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    api_version = kwargs.pop("api_version", _params.pop("api-version", "2022-11-01-preview"))  # type: str
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = (
        "/parties/{partyId}/models/{modelId}/resource-types/{resourceType}/resources/{resourceId}/insight-attachments"
    )
    path_format_arguments = {
        "partyId": _SERIALIZER.url("party_id", party_id, "str"),
        "modelId": _SERIALIZER.url("model_id", model_id, "str"),
        "resourceType": _SERIALIZER.url("resource_type", resource_type, "str"),
        "resourceId": _SERIALIZER.url("resource_id", resource_id, "str"),
    }

    _url = _format_url_section(_url, **path_format_arguments)

    # Construct parameters
    if insight_ids is not None:
        _params["insightIds"] = [
            _SERIALIZER.query("insight_ids", q, "str") if q is not None else "" for q in insight_ids
        ]
    if ids is not None:
        _params["ids"] = [_SERIALIZER.query("ids", q, "str") if q is not None else "" for q in ids]
    if names is not None:
        _params["names"] = [_SERIALIZER.query("names", q, "str") if q is not None else "" for q in names]
    if property_filters is not None:
        _params["propertyFilters"] = [
            _SERIALIZER.query("property_filters", q, "str") if q is not None else "" for q in property_filters
        ]
    if statuses is not None:
        _params["statuses"] = [_SERIALIZER.query("statuses", q, "str") if q is not None else "" for q in statuses]
    if min_created_date_time is not None:
        _params["minCreatedDateTime"] = _SERIALIZER.query("min_created_date_time", min_created_date_time, "iso-8601")
    if max_created_date_time is not None:
        _params["maxCreatedDateTime"] = _SERIALIZER.query("max_created_date_time", max_created_date_time, "iso-8601")
    if min_last_modified_date_time is not None:
        _params["minLastModifiedDateTime"] = _SERIALIZER.query(
            "min_last_modified_date_time", min_last_modified_date_time, "iso-8601"
        )
    if max_last_modified_date_time is not None:
        _params["maxLastModifiedDateTime"] = _SERIALIZER.query(
            "max_last_modified_date_time", max_last_modified_date_time, "iso-8601"
        )
    if skip_token is not None:
        _params["skipToken"] = _SERIALIZER.query("skip_token", skip_token, "str")
    _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")

    # Construct headers
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="GET", url=_url, params=_params, headers=_headers, **kwargs)


def build_insight_attachments_get_request(
    party_id: str, model_id: str, resource_type: str, resource_id: str, insight_attachment_id: str, **kwargs: Any
) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    api_version = kwargs.pop("api_version", _params.pop("api-version", "2022-11-01-preview"))  # type: str
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/parties/{partyId}/models/{modelId}/resource-types/{resourceType}/resources/{resourceId}/insight-attachments/{insightAttachmentId}"  # pylint: disable=line-too-long
    path_format_arguments = {
        "partyId": _SERIALIZER.url("party_id", party_id, "str"),
        "modelId": _SERIALIZER.url("model_id", model_id, "str"),
        "resourceType": _SERIALIZER.url("resource_type", resource_type, "str"),
        "resourceId": _SERIALIZER.url("resource_id", resource_id, "str"),
        "insightAttachmentId": _SERIALIZER.url("insight_attachment_id", insight_attachment_id, "str"),
    }

    _url = _format_url_section(_url, **path_format_arguments)

    # Construct parameters
    _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")

    # Construct headers
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="GET", url=_url, params=_params, headers=_headers, **kwargs)


def build_insight_attachments_delete_request(
    party_id: str, model_id: str, resource_type: str, resource_id: str, insight_attachment_id: str, **kwargs: Any
) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    api_version = kwargs.pop("api_version", _params.pop("api-version", "2022-11-01-preview"))  # type: str
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/parties/{partyId}/models/{modelId}/resource-types/{resourceType}/resources/{resourceId}/insight-attachments/{insightAttachmentId}"  # pylint: disable=line-too-long
    path_format_arguments = {
        "partyId": _SERIALIZER.url("party_id", party_id, "str"),
        "modelId": _SERIALIZER.url("model_id", model_id, "str"),
        "resourceType": _SERIALIZER.url("resource_type", resource_type, "str"),
        "resourceId": _SERIALIZER.url("resource_id", resource_id, "str"),
        "insightAttachmentId": _SERIALIZER.url("insight_attachment_id", insight_attachment_id, "str"),
    }

    _url = _format_url_section(_url, **path_format_arguments)

    # Construct parameters
    _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")

    # Construct headers
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="DELETE", url=_url, params=_params, headers=_headers, **kwargs)


def build_insight_attachments_download_request(
    party_id: str, model_id: str, resource_type: str, resource_id: str, insight_attachment_id: str, **kwargs: Any
) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    api_version = kwargs.pop("api_version", _params.pop("api-version", "2022-11-01-preview"))  # type: str
    accept = _headers.pop("Accept", "application/json, application/octet-stream")

    # Construct URL
    _url = "/parties/{partyId}/models/{modelId}/resource-types/{resourceType}/resources/{resourceId}/insight-attachments/{insightAttachmentId}/file"  # pylint: disable=line-too-long
    path_format_arguments = {
        "partyId": _SERIALIZER.url("party_id", party_id, "str"),
        "modelId": _SERIALIZER.url("model_id", model_id, "str"),
        "resourceType": _SERIALIZER.url("resource_type", resource_type, "str"),
        "resourceId": _SERIALIZER.url("resource_id", resource_id, "str"),
        "insightAttachmentId": _SERIALIZER.url("insight_attachment_id", insight_attachment_id, "str"),
    }

    _url = _format_url_section(_url, **path_format_arguments)

    # Construct parameters
    _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")

    # Construct headers
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="GET", url=_url, params=_params, headers=_headers, **kwargs)


def build_insights_create_cascade_delete_job_request(
    job_id: str, *, party_id: str, model_id: str, resource_type: str, resource_id: str, insight_id: str, **kwargs: Any
) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    api_version = kwargs.pop("api_version", _params.pop("api-version", "2022-11-01-preview"))  # type: str
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/insights/cascade-delete/{jobId}"
    path_format_arguments = {
        "jobId": _SERIALIZER.url("job_id", job_id, "str"),
    }

    _url = _format_url_section(_url, **path_format_arguments)

    # Construct parameters
    _params["partyId"] = _SERIALIZER.query("party_id", party_id, "str")
    _params["modelId"] = _SERIALIZER.query("model_id", model_id, "str")
    _params["resourceType"] = _SERIALIZER.query("resource_type", resource_type, "str")
    _params["resourceId"] = _SERIALIZER.query("resource_id", resource_id, "str")
    _params["insightId"] = _SERIALIZER.query("insight_id", insight_id, "str")
    _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")

    # Construct headers
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="PUT", url=_url, params=_params, headers=_headers, **kwargs)


def build_insights_get_cascade_delete_job_details_request(job_id: str, **kwargs: Any) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    api_version = kwargs.pop("api_version", _params.pop("api-version", "2022-11-01-preview"))  # type: str
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/insights/cascade-delete/{jobId}"
    path_format_arguments = {
        "jobId": _SERIALIZER.url("job_id", job_id, "str"),
    }

    _url = _format_url_section(_url, **path_format_arguments)

    # Construct parameters
    _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")

    # Construct headers
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="GET", url=_url, params=_params, headers=_headers, **kwargs)


def build_insights_list_by_party_id_model_id_and_resource_request(
    party_id: str,
    model_id: str,
    resource_type: str,
    resource_id: str,
    *,
    min_insight_start_date_time: Optional[datetime.datetime] = None,
    max_insight_start_date_time: Optional[datetime.datetime] = None,
    min_insight_end_date_time: Optional[datetime.datetime] = None,
    max_insight_end_date_time: Optional[datetime.datetime] = None,
    measurement_filters: Optional[List[str]] = None,
    ids: Optional[List[str]] = None,
    names: Optional[List[str]] = None,
    property_filters: Optional[List[str]] = None,
    statuses: Optional[List[str]] = None,
    min_created_date_time: Optional[datetime.datetime] = None,
    max_created_date_time: Optional[datetime.datetime] = None,
    min_last_modified_date_time: Optional[datetime.datetime] = None,
    max_last_modified_date_time: Optional[datetime.datetime] = None,
    skip_token: Optional[str] = None,
    **kwargs: Any
) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    api_version = kwargs.pop("api_version", _params.pop("api-version", "2022-11-01-preview"))  # type: str
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/parties/{partyId}/models/{modelId}/resource-types/{resourceType}/resources/{resourceId}/insights"
    path_format_arguments = {
        "partyId": _SERIALIZER.url("party_id", party_id, "str"),
        "modelId": _SERIALIZER.url("model_id", model_id, "str"),
        "resourceType": _SERIALIZER.url("resource_type", resource_type, "str"),
        "resourceId": _SERIALIZER.url("resource_id", resource_id, "str"),
    }

    _url = _format_url_section(_url, **path_format_arguments)

    # Construct parameters
    if min_insight_start_date_time is not None:
        _params["minInsightStartDateTime"] = _SERIALIZER.query(
            "min_insight_start_date_time", min_insight_start_date_time, "iso-8601"
        )
    if max_insight_start_date_time is not None:
        _params["maxInsightStartDateTime"] = _SERIALIZER.query(
            "max_insight_start_date_time", max_insight_start_date_time, "iso-8601"
        )
    if min_insight_end_date_time is not None:
        _params["minInsightEndDateTime"] = _SERIALIZER.query(
            "min_insight_end_date_time", min_insight_end_date_time, "iso-8601"
        )
    if max_insight_end_date_time is not None:
        _params["maxInsightEndDateTime"] = _SERIALIZER.query(
            "max_insight_end_date_time", max_insight_end_date_time, "iso-8601"
        )
    if measurement_filters is not None:
        _params["measurementFilters"] = [
            _SERIALIZER.query("measurement_filters", q, "str") if q is not None else "" for q in measurement_filters
        ]
    if ids is not None:
        _params["ids"] = [_SERIALIZER.query("ids", q, "str") if q is not None else "" for q in ids]
    if names is not None:
        _params["names"] = [_SERIALIZER.query("names", q, "str") if q is not None else "" for q in names]
    if property_filters is not None:
        _params["propertyFilters"] = [
            _SERIALIZER.query("property_filters", q, "str") if q is not None else "" for q in property_filters
        ]
    if statuses is not None:
        _params["statuses"] = [_SERIALIZER.query("statuses", q, "str") if q is not None else "" for q in statuses]
    if min_created_date_time is not None:
        _params["minCreatedDateTime"] = _SERIALIZER.query("min_created_date_time", min_created_date_time, "iso-8601")
    if max_created_date_time is not None:
        _params["maxCreatedDateTime"] = _SERIALIZER.query("max_created_date_time", max_created_date_time, "iso-8601")
    if min_last_modified_date_time is not None:
        _params["minLastModifiedDateTime"] = _SERIALIZER.query(
            "min_last_modified_date_time", min_last_modified_date_time, "iso-8601"
        )
    if max_last_modified_date_time is not None:
        _params["maxLastModifiedDateTime"] = _SERIALIZER.query(
            "max_last_modified_date_time", max_last_modified_date_time, "iso-8601"
        )
    if skip_token is not None:
        _params["skipToken"] = _SERIALIZER.query("skip_token", skip_token, "str")
    _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")

    # Construct headers
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="GET", url=_url, params=_params, headers=_headers, **kwargs)


def build_insights_create_or_update_request(
    party_id: str, model_id: str, resource_type: str, resource_id: str, insight_id: str, **kwargs: Any
) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    content_type = kwargs.pop("content_type", _headers.pop("Content-Type", None))  # type: Optional[str]
    api_version = kwargs.pop("api_version", _params.pop("api-version", "2022-11-01-preview"))  # type: str
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = (
        "/parties/{partyId}/models/{modelId}/resource-types/{resourceType}/resources/{resourceId}/insights/{insightId}"
    )
    path_format_arguments = {
        "partyId": _SERIALIZER.url("party_id", party_id, "str"),
        "modelId": _SERIALIZER.url("model_id", model_id, "str"),
        "resourceType": _SERIALIZER.url("resource_type", resource_type, "str"),
        "resourceId": _SERIALIZER.url("resource_id", resource_id, "str"),
        "insightId": _SERIALIZER.url("insight_id", insight_id, "str"),
    }

    _url = _format_url_section(_url, **path_format_arguments)

    # Construct parameters
    _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")

    # Construct headers
    if content_type is not None:
        _headers["Content-Type"] = _SERIALIZER.header("content_type", content_type, "str")
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="PATCH", url=_url, params=_params, headers=_headers, **kwargs)


def build_insights_get_request(
    party_id: str, model_id: str, resource_type: str, resource_id: str, insight_id: str, **kwargs: Any
) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    api_version = kwargs.pop("api_version", _params.pop("api-version", "2022-11-01-preview"))  # type: str
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = (
        "/parties/{partyId}/models/{modelId}/resource-types/{resourceType}/resources/{resourceId}/insights/{insightId}"
    )
    path_format_arguments = {
        "partyId": _SERIALIZER.url("party_id", party_id, "str"),
        "modelId": _SERIALIZER.url("model_id", model_id, "str"),
        "resourceType": _SERIALIZER.url("resource_type", resource_type, "str"),
        "resourceId": _SERIALIZER.url("resource_id", resource_id, "str"),
        "insightId": _SERIALIZER.url("insight_id", insight_id, "str"),
    }

    _url = _format_url_section(_url, **path_format_arguments)

    # Construct parameters
    _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")

    # Construct headers
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="GET", url=_url, params=_params, headers=_headers, **kwargs)


def build_insights_delete_request(
    party_id: str, model_id: str, resource_type: str, resource_id: str, insight_id: str, **kwargs: Any
) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    api_version = kwargs.pop("api_version", _params.pop("api-version", "2022-11-01-preview"))  # type: str
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = (
        "/parties/{partyId}/models/{modelId}/resource-types/{resourceType}/resources/{resourceId}/insights/{insightId}"
    )
    path_format_arguments = {
        "partyId": _SERIALIZER.url("party_id", party_id, "str"),
        "modelId": _SERIALIZER.url("model_id", model_id, "str"),
        "resourceType": _SERIALIZER.url("resource_type", resource_type, "str"),
        "resourceId": _SERIALIZER.url("resource_id", resource_id, "str"),
        "insightId": _SERIALIZER.url("insight_id", insight_id, "str"),
    }

    _url = _format_url_section(_url, **path_format_arguments)

    # Construct parameters
    _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")

    # Construct headers
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="DELETE", url=_url, params=_params, headers=_headers, **kwargs)


def build_management_zones_list_request(
    *,
    types: Optional[List[str]] = None,
    crop_ids: Optional[List[str]] = None,
    season_ids: Optional[List[str]] = None,
    field_ids: Optional[List[str]] = None,
    sources: Optional[List[str]] = None,
    ids: Optional[List[str]] = None,
    names: Optional[List[str]] = None,
    property_filters: Optional[List[str]] = None,
    statuses: Optional[List[str]] = None,
    min_created_date_time: Optional[datetime.datetime] = None,
    max_created_date_time: Optional[datetime.datetime] = None,
    min_last_modified_date_time: Optional[datetime.datetime] = None,
    max_last_modified_date_time: Optional[datetime.datetime] = None,
    skip_token: Optional[str] = None,
    **kwargs: Any
) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    api_version = kwargs.pop("api_version", _params.pop("api-version", "2022-11-01-preview"))  # type: str
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/management-zones"

    # Construct parameters
    if types is not None:
        _params["types"] = [_SERIALIZER.query("types", q, "str") if q is not None else "" for q in types]
    if crop_ids is not None:
        _params["cropIds"] = [_SERIALIZER.query("crop_ids", q, "str") if q is not None else "" for q in crop_ids]
    if season_ids is not None:
        _params["seasonIds"] = [_SERIALIZER.query("season_ids", q, "str") if q is not None else "" for q in season_ids]
    if field_ids is not None:
        _params["fieldIds"] = [_SERIALIZER.query("field_ids", q, "str") if q is not None else "" for q in field_ids]
    if sources is not None:
        _params["sources"] = [_SERIALIZER.query("sources", q, "str") if q is not None else "" for q in sources]
    if ids is not None:
        _params["ids"] = [_SERIALIZER.query("ids", q, "str") if q is not None else "" for q in ids]
    if names is not None:
        _params["names"] = [_SERIALIZER.query("names", q, "str") if q is not None else "" for q in names]
    if property_filters is not None:
        _params["propertyFilters"] = [
            _SERIALIZER.query("property_filters", q, "str") if q is not None else "" for q in property_filters
        ]
    if statuses is not None:
        _params["statuses"] = [_SERIALIZER.query("statuses", q, "str") if q is not None else "" for q in statuses]
    if min_created_date_time is not None:
        _params["minCreatedDateTime"] = _SERIALIZER.query("min_created_date_time", min_created_date_time, "iso-8601")
    if max_created_date_time is not None:
        _params["maxCreatedDateTime"] = _SERIALIZER.query("max_created_date_time", max_created_date_time, "iso-8601")
    if min_last_modified_date_time is not None:
        _params["minLastModifiedDateTime"] = _SERIALIZER.query(
            "min_last_modified_date_time", min_last_modified_date_time, "iso-8601"
        )
    if max_last_modified_date_time is not None:
        _params["maxLastModifiedDateTime"] = _SERIALIZER.query(
            "max_last_modified_date_time", max_last_modified_date_time, "iso-8601"
        )
    if skip_token is not None:
        _params["skipToken"] = _SERIALIZER.query("skip_token", skip_token, "str")
    _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")

    # Construct headers
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="GET", url=_url, params=_params, headers=_headers, **kwargs)


def build_management_zones_get_cascade_delete_job_details_request(job_id: str, **kwargs: Any) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    api_version = kwargs.pop("api_version", _params.pop("api-version", "2022-11-01-preview"))  # type: str
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/management-zones/cascade-delete/{jobId}"
    path_format_arguments = {
        "jobId": _SERIALIZER.url("job_id", job_id, "str"),
    }

    _url = _format_url_section(_url, **path_format_arguments)

    # Construct parameters
    _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")

    # Construct headers
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="GET", url=_url, params=_params, headers=_headers, **kwargs)


def build_management_zones_create_cascade_delete_job_request(
    job_id: str, *, party_id: str, management_zone_id: str, **kwargs: Any
) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    api_version = kwargs.pop("api_version", _params.pop("api-version", "2022-11-01-preview"))  # type: str
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/management-zones/cascade-delete/{jobId}"
    path_format_arguments = {
        "jobId": _SERIALIZER.url("job_id", job_id, "str"),
    }

    _url = _format_url_section(_url, **path_format_arguments)

    # Construct parameters
    _params["partyId"] = _SERIALIZER.query("party_id", party_id, "str")
    _params["managementZoneId"] = _SERIALIZER.query("management_zone_id", management_zone_id, "str")
    _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")

    # Construct headers
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="PUT", url=_url, params=_params, headers=_headers, **kwargs)


def build_management_zones_list_by_party_id_request(
    party_id: str,
    *,
    types: Optional[List[str]] = None,
    crop_ids: Optional[List[str]] = None,
    season_ids: Optional[List[str]] = None,
    field_ids: Optional[List[str]] = None,
    sources: Optional[List[str]] = None,
    ids: Optional[List[str]] = None,
    names: Optional[List[str]] = None,
    property_filters: Optional[List[str]] = None,
    statuses: Optional[List[str]] = None,
    min_created_date_time: Optional[datetime.datetime] = None,
    max_created_date_time: Optional[datetime.datetime] = None,
    min_last_modified_date_time: Optional[datetime.datetime] = None,
    max_last_modified_date_time: Optional[datetime.datetime] = None,
    skip_token: Optional[str] = None,
    **kwargs: Any
) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    api_version = kwargs.pop("api_version", _params.pop("api-version", "2022-11-01-preview"))  # type: str
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/parties/{partyId}/management-zones"
    path_format_arguments = {
        "partyId": _SERIALIZER.url("party_id", party_id, "str"),
    }

    _url = _format_url_section(_url, **path_format_arguments)

    # Construct parameters
    if types is not None:
        _params["types"] = [_SERIALIZER.query("types", q, "str") if q is not None else "" for q in types]
    if crop_ids is not None:
        _params["cropIds"] = [_SERIALIZER.query("crop_ids", q, "str") if q is not None else "" for q in crop_ids]
    if season_ids is not None:
        _params["seasonIds"] = [_SERIALIZER.query("season_ids", q, "str") if q is not None else "" for q in season_ids]
    if field_ids is not None:
        _params["fieldIds"] = [_SERIALIZER.query("field_ids", q, "str") if q is not None else "" for q in field_ids]
    if sources is not None:
        _params["sources"] = [_SERIALIZER.query("sources", q, "str") if q is not None else "" for q in sources]
    if ids is not None:
        _params["ids"] = [_SERIALIZER.query("ids", q, "str") if q is not None else "" for q in ids]
    if names is not None:
        _params["names"] = [_SERIALIZER.query("names", q, "str") if q is not None else "" for q in names]
    if property_filters is not None:
        _params["propertyFilters"] = [
            _SERIALIZER.query("property_filters", q, "str") if q is not None else "" for q in property_filters
        ]
    if statuses is not None:
        _params["statuses"] = [_SERIALIZER.query("statuses", q, "str") if q is not None else "" for q in statuses]
    if min_created_date_time is not None:
        _params["minCreatedDateTime"] = _SERIALIZER.query("min_created_date_time", min_created_date_time, "iso-8601")
    if max_created_date_time is not None:
        _params["maxCreatedDateTime"] = _SERIALIZER.query("max_created_date_time", max_created_date_time, "iso-8601")
    if min_last_modified_date_time is not None:
        _params["minLastModifiedDateTime"] = _SERIALIZER.query(
            "min_last_modified_date_time", min_last_modified_date_time, "iso-8601"
        )
    if max_last_modified_date_time is not None:
        _params["maxLastModifiedDateTime"] = _SERIALIZER.query(
            "max_last_modified_date_time", max_last_modified_date_time, "iso-8601"
        )
    if skip_token is not None:
        _params["skipToken"] = _SERIALIZER.query("skip_token", skip_token, "str")
    _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")

    # Construct headers
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="GET", url=_url, params=_params, headers=_headers, **kwargs)


def build_management_zones_get_request(party_id: str, management_zone_id: str, **kwargs: Any) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    api_version = kwargs.pop("api_version", _params.pop("api-version", "2022-11-01-preview"))  # type: str
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/parties/{partyId}/management-zones/{managementZoneId}"
    path_format_arguments = {
        "partyId": _SERIALIZER.url("party_id", party_id, "str"),
        "managementZoneId": _SERIALIZER.url("management_zone_id", management_zone_id, "str"),
    }

    _url = _format_url_section(_url, **path_format_arguments)

    # Construct parameters
    _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")

    # Construct headers
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="GET", url=_url, params=_params, headers=_headers, **kwargs)


def build_management_zones_create_or_update_request(
    party_id: str, management_zone_id: str, **kwargs: Any
) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    content_type = kwargs.pop("content_type", _headers.pop("Content-Type", None))  # type: Optional[str]
    api_version = kwargs.pop("api_version", _params.pop("api-version", "2022-11-01-preview"))  # type: str
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/parties/{partyId}/management-zones/{managementZoneId}"
    path_format_arguments = {
        "partyId": _SERIALIZER.url("party_id", party_id, "str"),
        "managementZoneId": _SERIALIZER.url("management_zone_id", management_zone_id, "str"),
    }

    _url = _format_url_section(_url, **path_format_arguments)

    # Construct parameters
    _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")

    # Construct headers
    if content_type is not None:
        _headers["Content-Type"] = _SERIALIZER.header("content_type", content_type, "str")
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="PATCH", url=_url, params=_params, headers=_headers, **kwargs)


def build_management_zones_delete_request(party_id: str, management_zone_id: str, **kwargs: Any) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    api_version = kwargs.pop("api_version", _params.pop("api-version", "2022-11-01-preview"))  # type: str
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/parties/{partyId}/management-zones/{managementZoneId}"
    path_format_arguments = {
        "partyId": _SERIALIZER.url("party_id", party_id, "str"),
        "managementZoneId": _SERIALIZER.url("management_zone_id", management_zone_id, "str"),
    }

    _url = _format_url_section(_url, **path_format_arguments)

    # Construct parameters
    _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")

    # Construct headers
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="DELETE", url=_url, params=_params, headers=_headers, **kwargs)


def build_model_inference_create_biomass_model_job_request(job_id: str, **kwargs: Any) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    content_type = kwargs.pop("content_type", _headers.pop("Content-Type", None))  # type: Optional[str]
    api_version = kwargs.pop("api_version", _params.pop("api-version", "2022-11-01-preview"))  # type: str
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/model-inference/models/microsoft-biomass/infer-data/{jobId}"
    path_format_arguments = {
        "jobId": _SERIALIZER.url("job_id", job_id, "str"),
    }

    _url = _format_url_section(_url, **path_format_arguments)

    # Construct parameters
    _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")

    # Construct headers
    if content_type is not None:
        _headers["Content-Type"] = _SERIALIZER.header("content_type", content_type, "str")
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="PUT", url=_url, params=_params, headers=_headers, **kwargs)


def build_model_inference_get_biomass_model_job_request(job_id: str, **kwargs: Any) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    api_version = kwargs.pop("api_version", _params.pop("api-version", "2022-11-01-preview"))  # type: str
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/model-inference/models/microsoft-biomass/infer-data/{jobId}"
    path_format_arguments = {
        "jobId": _SERIALIZER.url("job_id", job_id, "str"),
    }

    _url = _format_url_section(_url, **path_format_arguments)

    # Construct parameters
    _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")

    # Construct headers
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="GET", url=_url, params=_params, headers=_headers, **kwargs)


def build_model_inference_create_sensor_placement_model_job_request(job_id: str, **kwargs: Any) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    content_type = kwargs.pop("content_type", _headers.pop("Content-Type", None))  # type: Optional[str]
    api_version = kwargs.pop("api_version", _params.pop("api-version", "2022-11-01-preview"))  # type: str
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/model-inference/models/microsoft-sensor-placement/infer-data/{jobId}"
    path_format_arguments = {
        "jobId": _SERIALIZER.url("job_id", job_id, "str"),
    }

    _url = _format_url_section(_url, **path_format_arguments)

    # Construct parameters
    _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")

    # Construct headers
    if content_type is not None:
        _headers["Content-Type"] = _SERIALIZER.header("content_type", content_type, "str")
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="PUT", url=_url, params=_params, headers=_headers, **kwargs)


def build_model_inference_get_sensor_placement_model_job_request(job_id: str, **kwargs: Any) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    api_version = kwargs.pop("api_version", _params.pop("api-version", "2022-11-01-preview"))  # type: str
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/model-inference/models/microsoft-sensor-placement/infer-data/{jobId}"
    path_format_arguments = {
        "jobId": _SERIALIZER.url("job_id", job_id, "str"),
    }

    _url = _format_url_section(_url, **path_format_arguments)

    # Construct parameters
    _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")

    # Construct headers
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="GET", url=_url, params=_params, headers=_headers, **kwargs)


def build_model_inference_create_soil_moisture_model_job_request(job_id: str, **kwargs: Any) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    content_type = kwargs.pop("content_type", _headers.pop("Content-Type", None))  # type: Optional[str]
    api_version = kwargs.pop("api_version", _params.pop("api-version", "2022-11-01-preview"))  # type: str
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/model-inference/models/microsoft-soil-moisture/infer-data/{jobId}"
    path_format_arguments = {
        "jobId": _SERIALIZER.url("job_id", job_id, "str"),
    }

    _url = _format_url_section(_url, **path_format_arguments)

    # Construct parameters
    _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")

    # Construct headers
    if content_type is not None:
        _headers["Content-Type"] = _SERIALIZER.header("content_type", content_type, "str")
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="PUT", url=_url, params=_params, headers=_headers, **kwargs)


def build_model_inference_get_soil_moisture_model_job_request(job_id: str, **kwargs: Any) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    api_version = kwargs.pop("api_version", _params.pop("api-version", "2022-11-01-preview"))  # type: str
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/model-inference/models/microsoft-soil-moisture/infer-data/{jobId}"
    path_format_arguments = {
        "jobId": _SERIALIZER.url("job_id", job_id, "str"),
    }

    _url = _format_url_section(_url, **path_format_arguments)

    # Construct parameters
    _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")

    # Construct headers
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="GET", url=_url, params=_params, headers=_headers, **kwargs)


def build_nutrient_analyses_list_request(
    *,
    parent_type: Optional[str] = None,
    parent_ids: Optional[List[str]] = None,
    classifications: Optional[List[str]] = None,
    ids: Optional[List[str]] = None,
    names: Optional[List[str]] = None,
    property_filters: Optional[List[str]] = None,
    statuses: Optional[List[str]] = None,
    min_created_date_time: Optional[datetime.datetime] = None,
    max_created_date_time: Optional[datetime.datetime] = None,
    min_last_modified_date_time: Optional[datetime.datetime] = None,
    max_last_modified_date_time: Optional[datetime.datetime] = None,
    skip_token: Optional[str] = None,
    **kwargs: Any
) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    api_version = kwargs.pop("api_version", _params.pop("api-version", "2022-11-01-preview"))  # type: str
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/nutrient-analyses"

    # Construct parameters
    if parent_type is not None:
        _params["parentType"] = _SERIALIZER.query("parent_type", parent_type, "str")
    if parent_ids is not None:
        _params["parentIds"] = [_SERIALIZER.query("parent_ids", q, "str") if q is not None else "" for q in parent_ids]
    if classifications is not None:
        _params["classifications"] = [
            _SERIALIZER.query("classifications", q, "str") if q is not None else "" for q in classifications
        ]
    if ids is not None:
        _params["ids"] = [_SERIALIZER.query("ids", q, "str") if q is not None else "" for q in ids]
    if names is not None:
        _params["names"] = [_SERIALIZER.query("names", q, "str") if q is not None else "" for q in names]
    if property_filters is not None:
        _params["propertyFilters"] = [
            _SERIALIZER.query("property_filters", q, "str") if q is not None else "" for q in property_filters
        ]
    if statuses is not None:
        _params["statuses"] = [_SERIALIZER.query("statuses", q, "str") if q is not None else "" for q in statuses]
    if min_created_date_time is not None:
        _params["minCreatedDateTime"] = _SERIALIZER.query("min_created_date_time", min_created_date_time, "iso-8601")
    if max_created_date_time is not None:
        _params["maxCreatedDateTime"] = _SERIALIZER.query("max_created_date_time", max_created_date_time, "iso-8601")
    if min_last_modified_date_time is not None:
        _params["minLastModifiedDateTime"] = _SERIALIZER.query(
            "min_last_modified_date_time", min_last_modified_date_time, "iso-8601"
        )
    if max_last_modified_date_time is not None:
        _params["maxLastModifiedDateTime"] = _SERIALIZER.query(
            "max_last_modified_date_time", max_last_modified_date_time, "iso-8601"
        )
    if skip_token is not None:
        _params["skipToken"] = _SERIALIZER.query("skip_token", skip_token, "str")
    _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")

    # Construct headers
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="GET", url=_url, params=_params, headers=_headers, **kwargs)


def build_nutrient_analyses_list_by_party_id_request(
    party_id: str,
    *,
    parent_type: Optional[str] = None,
    parent_ids: Optional[List[str]] = None,
    classifications: Optional[List[str]] = None,
    ids: Optional[List[str]] = None,
    names: Optional[List[str]] = None,
    property_filters: Optional[List[str]] = None,
    statuses: Optional[List[str]] = None,
    min_created_date_time: Optional[datetime.datetime] = None,
    max_created_date_time: Optional[datetime.datetime] = None,
    min_last_modified_date_time: Optional[datetime.datetime] = None,
    max_last_modified_date_time: Optional[datetime.datetime] = None,
    skip_token: Optional[str] = None,
    **kwargs: Any
) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    api_version = kwargs.pop("api_version", _params.pop("api-version", "2022-11-01-preview"))  # type: str
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/parties/{partyId}/nutrient-analyses"
    path_format_arguments = {
        "partyId": _SERIALIZER.url("party_id", party_id, "str"),
    }

    _url = _format_url_section(_url, **path_format_arguments)

    # Construct parameters
    if parent_type is not None:
        _params["parentType"] = _SERIALIZER.query("parent_type", parent_type, "str")
    if parent_ids is not None:
        _params["parentIds"] = [_SERIALIZER.query("parent_ids", q, "str") if q is not None else "" for q in parent_ids]
    if classifications is not None:
        _params["classifications"] = [
            _SERIALIZER.query("classifications", q, "str") if q is not None else "" for q in classifications
        ]
    if ids is not None:
        _params["ids"] = [_SERIALIZER.query("ids", q, "str") if q is not None else "" for q in ids]
    if names is not None:
        _params["names"] = [_SERIALIZER.query("names", q, "str") if q is not None else "" for q in names]
    if property_filters is not None:
        _params["propertyFilters"] = [
            _SERIALIZER.query("property_filters", q, "str") if q is not None else "" for q in property_filters
        ]
    if statuses is not None:
        _params["statuses"] = [_SERIALIZER.query("statuses", q, "str") if q is not None else "" for q in statuses]
    if min_created_date_time is not None:
        _params["minCreatedDateTime"] = _SERIALIZER.query("min_created_date_time", min_created_date_time, "iso-8601")
    if max_created_date_time is not None:
        _params["maxCreatedDateTime"] = _SERIALIZER.query("max_created_date_time", max_created_date_time, "iso-8601")
    if min_last_modified_date_time is not None:
        _params["minLastModifiedDateTime"] = _SERIALIZER.query(
            "min_last_modified_date_time", min_last_modified_date_time, "iso-8601"
        )
    if max_last_modified_date_time is not None:
        _params["maxLastModifiedDateTime"] = _SERIALIZER.query(
            "max_last_modified_date_time", max_last_modified_date_time, "iso-8601"
        )
    if skip_token is not None:
        _params["skipToken"] = _SERIALIZER.query("skip_token", skip_token, "str")
    _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")

    # Construct headers
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="GET", url=_url, params=_params, headers=_headers, **kwargs)


def build_nutrient_analyses_get_request(party_id: str, nutrient_analysis_id: str, **kwargs: Any) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    api_version = kwargs.pop("api_version", _params.pop("api-version", "2022-11-01-preview"))  # type: str
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/parties/{partyId}/nutrient-analyses/{nutrientAnalysisId}"
    path_format_arguments = {
        "partyId": _SERIALIZER.url("party_id", party_id, "str"),
        "nutrientAnalysisId": _SERIALIZER.url("nutrient_analysis_id", nutrient_analysis_id, "str"),
    }

    _url = _format_url_section(_url, **path_format_arguments)

    # Construct parameters
    _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")

    # Construct headers
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="GET", url=_url, params=_params, headers=_headers, **kwargs)


def build_nutrient_analyses_create_or_update_request(
    party_id: str, nutrient_analysis_id: str, **kwargs: Any
) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    content_type = kwargs.pop("content_type", _headers.pop("Content-Type", None))  # type: Optional[str]
    api_version = kwargs.pop("api_version", _params.pop("api-version", "2022-11-01-preview"))  # type: str
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/parties/{partyId}/nutrient-analyses/{nutrientAnalysisId}"
    path_format_arguments = {
        "partyId": _SERIALIZER.url("party_id", party_id, "str"),
        "nutrientAnalysisId": _SERIALIZER.url("nutrient_analysis_id", nutrient_analysis_id, "str"),
    }

    _url = _format_url_section(_url, **path_format_arguments)

    # Construct parameters
    _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")

    # Construct headers
    if content_type is not None:
        _headers["Content-Type"] = _SERIALIZER.header("content_type", content_type, "str")
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="PATCH", url=_url, params=_params, headers=_headers, **kwargs)


def build_nutrient_analyses_delete_request(party_id: str, nutrient_analysis_id: str, **kwargs: Any) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    api_version = kwargs.pop("api_version", _params.pop("api-version", "2022-11-01-preview"))  # type: str
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/parties/{partyId}/nutrient-analyses/{nutrientAnalysisId}"
    path_format_arguments = {
        "partyId": _SERIALIZER.url("party_id", party_id, "str"),
        "nutrientAnalysisId": _SERIALIZER.url("nutrient_analysis_id", nutrient_analysis_id, "str"),
    }

    _url = _format_url_section(_url, **path_format_arguments)

    # Construct parameters
    _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")

    # Construct headers
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="DELETE", url=_url, params=_params, headers=_headers, **kwargs)


def build_oauth_providers_list_request(
    *,
    ids: Optional[List[str]] = None,
    names: Optional[List[str]] = None,
    property_filters: Optional[List[str]] = None,
    statuses: Optional[List[str]] = None,
    min_created_date_time: Optional[datetime.datetime] = None,
    max_created_date_time: Optional[datetime.datetime] = None,
    min_last_modified_date_time: Optional[datetime.datetime] = None,
    max_last_modified_date_time: Optional[datetime.datetime] = None,
    skip_token: Optional[str] = None,
    **kwargs: Any
) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    api_version = kwargs.pop("api_version", _params.pop("api-version", "2022-11-01-preview"))  # type: str
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/oauth/providers"

    # Construct parameters
    if ids is not None:
        _params["ids"] = [_SERIALIZER.query("ids", q, "str") if q is not None else "" for q in ids]
    if names is not None:
        _params["names"] = [_SERIALIZER.query("names", q, "str") if q is not None else "" for q in names]
    if property_filters is not None:
        _params["propertyFilters"] = [
            _SERIALIZER.query("property_filters", q, "str") if q is not None else "" for q in property_filters
        ]
    if statuses is not None:
        _params["statuses"] = [_SERIALIZER.query("statuses", q, "str") if q is not None else "" for q in statuses]
    if min_created_date_time is not None:
        _params["minCreatedDateTime"] = _SERIALIZER.query("min_created_date_time", min_created_date_time, "iso-8601")
    if max_created_date_time is not None:
        _params["maxCreatedDateTime"] = _SERIALIZER.query("max_created_date_time", max_created_date_time, "iso-8601")
    if min_last_modified_date_time is not None:
        _params["minLastModifiedDateTime"] = _SERIALIZER.query(
            "min_last_modified_date_time", min_last_modified_date_time, "iso-8601"
        )
    if max_last_modified_date_time is not None:
        _params["maxLastModifiedDateTime"] = _SERIALIZER.query(
            "max_last_modified_date_time", max_last_modified_date_time, "iso-8601"
        )
    if skip_token is not None:
        _params["skipToken"] = _SERIALIZER.query("skip_token", skip_token, "str")
    _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")

    # Construct headers
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="GET", url=_url, params=_params, headers=_headers, **kwargs)


def build_oauth_providers_get_request(oauth_provider_id: str, **kwargs: Any) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    api_version = kwargs.pop("api_version", _params.pop("api-version", "2022-11-01-preview"))  # type: str
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/oauth/providers/{oauthProviderId}"
    path_format_arguments = {
        "oauthProviderId": _SERIALIZER.url("oauth_provider_id", oauth_provider_id, "str"),
    }

    _url = _format_url_section(_url, **path_format_arguments)

    # Construct parameters
    _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")

    # Construct headers
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="GET", url=_url, params=_params, headers=_headers, **kwargs)


def build_oauth_providers_create_or_update_request(oauth_provider_id: str, **kwargs: Any) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    content_type = kwargs.pop("content_type", _headers.pop("Content-Type", None))  # type: Optional[str]
    api_version = kwargs.pop("api_version", _params.pop("api-version", "2022-11-01-preview"))  # type: str
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/oauth/providers/{oauthProviderId}"
    path_format_arguments = {
        "oauthProviderId": _SERIALIZER.url("oauth_provider_id", oauth_provider_id, "str"),
    }

    _url = _format_url_section(_url, **path_format_arguments)

    # Construct parameters
    _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")

    # Construct headers
    if content_type is not None:
        _headers["Content-Type"] = _SERIALIZER.header("content_type", content_type, "str")
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="PATCH", url=_url, params=_params, headers=_headers, **kwargs)


def build_oauth_providers_delete_request(oauth_provider_id: str, **kwargs: Any) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    api_version = kwargs.pop("api_version", _params.pop("api-version", "2022-11-01-preview"))  # type: str
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/oauth/providers/{oauthProviderId}"
    path_format_arguments = {
        "oauthProviderId": _SERIALIZER.url("oauth_provider_id", oauth_provider_id, "str"),
    }

    _url = _format_url_section(_url, **path_format_arguments)

    # Construct parameters
    _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")

    # Construct headers
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="DELETE", url=_url, params=_params, headers=_headers, **kwargs)


def build_oauth_providers_get_cascade_delete_job_details_request(job_id: str, **kwargs: Any) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    api_version = kwargs.pop("api_version", _params.pop("api-version", "2022-11-01-preview"))  # type: str
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/oauth/providers/cascade-delete/{jobId}"
    path_format_arguments = {
        "jobId": _SERIALIZER.url("job_id", job_id, "str"),
    }

    _url = _format_url_section(_url, **path_format_arguments)

    # Construct parameters
    _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")

    # Construct headers
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="GET", url=_url, params=_params, headers=_headers, **kwargs)


def build_oauth_providers_create_cascade_delete_job_request(
    job_id: str, *, oauth_provider_id: str, **kwargs: Any
) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    api_version = kwargs.pop("api_version", _params.pop("api-version", "2022-11-01-preview"))  # type: str
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/oauth/providers/cascade-delete/{jobId}"
    path_format_arguments = {
        "jobId": _SERIALIZER.url("job_id", job_id, "str"),
    }

    _url = _format_url_section(_url, **path_format_arguments)

    # Construct parameters
    _params["oauthProviderId"] = _SERIALIZER.query("oauth_provider_id", oauth_provider_id, "str")
    _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")

    # Construct headers
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="PUT", url=_url, params=_params, headers=_headers, **kwargs)


def build_oauth_tokens_list_request(
    *,
    auth_provider_ids: Optional[List[str]] = None,
    party_ids: Optional[List[str]] = None,
    is_valid: Optional[bool] = None,
    min_created_date_time: Optional[datetime.datetime] = None,
    max_created_date_time: Optional[datetime.datetime] = None,
    min_last_modified_date_time: Optional[datetime.datetime] = None,
    max_last_modified_date_time: Optional[datetime.datetime] = None,
    skip_token: Optional[str] = None,
    **kwargs: Any
) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    api_version = kwargs.pop("api_version", _params.pop("api-version", "2022-11-01-preview"))  # type: str
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/oauth/tokens"

    # Construct parameters
    if auth_provider_ids is not None:
        _params["authProviderIds"] = [
            _SERIALIZER.query("auth_provider_ids", q, "str") if q is not None else "" for q in auth_provider_ids
        ]
    if party_ids is not None:
        _params["partyIds"] = [_SERIALIZER.query("party_ids", q, "str") if q is not None else "" for q in party_ids]
    if is_valid is not None:
        _params["isValid"] = _SERIALIZER.query("is_valid", is_valid, "bool")
    if min_created_date_time is not None:
        _params["minCreatedDateTime"] = _SERIALIZER.query("min_created_date_time", min_created_date_time, "iso-8601")
    if max_created_date_time is not None:
        _params["maxCreatedDateTime"] = _SERIALIZER.query("max_created_date_time", max_created_date_time, "iso-8601")
    if min_last_modified_date_time is not None:
        _params["minLastModifiedDateTime"] = _SERIALIZER.query(
            "min_last_modified_date_time", min_last_modified_date_time, "iso-8601"
        )
    if max_last_modified_date_time is not None:
        _params["maxLastModifiedDateTime"] = _SERIALIZER.query(
            "max_last_modified_date_time", max_last_modified_date_time, "iso-8601"
        )
    if skip_token is not None:
        _params["skipToken"] = _SERIALIZER.query("skip_token", skip_token, "str")
    _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")

    # Construct headers
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="GET", url=_url, params=_params, headers=_headers, **kwargs)


def build_oauth_tokens_get_o_auth_connection_link_request(**kwargs: Any) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    content_type = kwargs.pop("content_type", _headers.pop("Content-Type", None))  # type: Optional[str]
    api_version = kwargs.pop("api_version", _params.pop("api-version", "2022-11-01-preview"))  # type: str
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/oauth/tokens/:connect"

    # Construct parameters
    _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")

    # Construct headers
    if content_type is not None:
        _headers["Content-Type"] = _SERIALIZER.header("content_type", content_type, "str")
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="POST", url=_url, params=_params, headers=_headers, **kwargs)


def build_oauth_tokens_get_cascade_delete_job_details_request(job_id: str, **kwargs: Any) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    api_version = kwargs.pop("api_version", _params.pop("api-version", "2022-11-01-preview"))  # type: str
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/oauth/tokens/remove/{jobId}"
    path_format_arguments = {
        "jobId": _SERIALIZER.url("job_id", job_id, "str"),
    }

    _url = _format_url_section(_url, **path_format_arguments)

    # Construct parameters
    _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")

    # Construct headers
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="GET", url=_url, params=_params, headers=_headers, **kwargs)


def build_oauth_tokens_create_cascade_delete_job_request(
    job_id: str, *, party_id: str, oauth_provider_id: str, **kwargs: Any
) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    api_version = kwargs.pop("api_version", _params.pop("api-version", "2022-11-01-preview"))  # type: str
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/oauth/tokens/remove/{jobId}"
    path_format_arguments = {
        "jobId": _SERIALIZER.url("job_id", job_id, "str"),
    }

    _url = _format_url_section(_url, **path_format_arguments)

    # Construct parameters
    _params["partyId"] = _SERIALIZER.query("party_id", party_id, "str")
    _params["oauthProviderId"] = _SERIALIZER.query("oauth_provider_id", oauth_provider_id, "str")
    _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")

    # Construct headers
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="PUT", url=_url, params=_params, headers=_headers, **kwargs)


def build_parties_list_request(
    *,
    ids: Optional[List[str]] = None,
    names: Optional[List[str]] = None,
    property_filters: Optional[List[str]] = None,
    statuses: Optional[List[str]] = None,
    min_created_date_time: Optional[datetime.datetime] = None,
    max_created_date_time: Optional[datetime.datetime] = None,
    min_last_modified_date_time: Optional[datetime.datetime] = None,
    max_last_modified_date_time: Optional[datetime.datetime] = None,
    skip_token: Optional[str] = None,
    **kwargs: Any
) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    api_version = kwargs.pop("api_version", _params.pop("api-version", "2022-11-01-preview"))  # type: str
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/parties"

    # Construct parameters
    if ids is not None:
        _params["ids"] = [_SERIALIZER.query("ids", q, "str") if q is not None else "" for q in ids]
    if names is not None:
        _params["names"] = [_SERIALIZER.query("names", q, "str") if q is not None else "" for q in names]
    if property_filters is not None:
        _params["propertyFilters"] = [
            _SERIALIZER.query("property_filters", q, "str") if q is not None else "" for q in property_filters
        ]
    if statuses is not None:
        _params["statuses"] = [_SERIALIZER.query("statuses", q, "str") if q is not None else "" for q in statuses]
    if min_created_date_time is not None:
        _params["minCreatedDateTime"] = _SERIALIZER.query("min_created_date_time", min_created_date_time, "iso-8601")
    if max_created_date_time is not None:
        _params["maxCreatedDateTime"] = _SERIALIZER.query("max_created_date_time", max_created_date_time, "iso-8601")
    if min_last_modified_date_time is not None:
        _params["minLastModifiedDateTime"] = _SERIALIZER.query(
            "min_last_modified_date_time", min_last_modified_date_time, "iso-8601"
        )
    if max_last_modified_date_time is not None:
        _params["maxLastModifiedDateTime"] = _SERIALIZER.query(
            "max_last_modified_date_time", max_last_modified_date_time, "iso-8601"
        )
    if skip_token is not None:
        _params["skipToken"] = _SERIALIZER.query("skip_token", skip_token, "str")
    _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")

    # Construct headers
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="GET", url=_url, params=_params, headers=_headers, **kwargs)


def build_parties_get_request(party_id: str, **kwargs: Any) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    api_version = kwargs.pop("api_version", _params.pop("api-version", "2022-11-01-preview"))  # type: str
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/parties/{partyId}"
    path_format_arguments = {
        "partyId": _SERIALIZER.url("party_id", party_id, "str"),
    }

    _url = _format_url_section(_url, **path_format_arguments)

    # Construct parameters
    _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")

    # Construct headers
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="GET", url=_url, params=_params, headers=_headers, **kwargs)


def build_parties_create_or_update_request(party_id: str, **kwargs: Any) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    content_type = kwargs.pop("content_type", _headers.pop("Content-Type", None))  # type: Optional[str]
    api_version = kwargs.pop("api_version", _params.pop("api-version", "2022-11-01-preview"))  # type: str
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/parties/{partyId}"
    path_format_arguments = {
        "partyId": _SERIALIZER.url("party_id", party_id, "str"),
    }

    _url = _format_url_section(_url, **path_format_arguments)

    # Construct parameters
    _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")

    # Construct headers
    if content_type is not None:
        _headers["Content-Type"] = _SERIALIZER.header("content_type", content_type, "str")
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="PATCH", url=_url, params=_params, headers=_headers, **kwargs)


def build_parties_delete_request(party_id: str, **kwargs: Any) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    api_version = kwargs.pop("api_version", _params.pop("api-version", "2022-11-01-preview"))  # type: str
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/parties/{partyId}"
    path_format_arguments = {
        "partyId": _SERIALIZER.url("party_id", party_id, "str"),
    }

    _url = _format_url_section(_url, **path_format_arguments)

    # Construct parameters
    _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")

    # Construct headers
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="DELETE", url=_url, params=_params, headers=_headers, **kwargs)


def build_parties_get_cascade_delete_job_details_request(job_id: str, **kwargs: Any) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    api_version = kwargs.pop("api_version", _params.pop("api-version", "2022-11-01-preview"))  # type: str
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/parties/cascade-delete/{jobId}"
    path_format_arguments = {
        "jobId": _SERIALIZER.url("job_id", job_id, "str"),
    }

    _url = _format_url_section(_url, **path_format_arguments)

    # Construct parameters
    _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")

    # Construct headers
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="GET", url=_url, params=_params, headers=_headers, **kwargs)


def build_parties_create_cascade_delete_job_request(job_id: str, *, party_id: str, **kwargs: Any) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    api_version = kwargs.pop("api_version", _params.pop("api-version", "2022-11-01-preview"))  # type: str
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/parties/cascade-delete/{jobId}"
    path_format_arguments = {
        "jobId": _SERIALIZER.url("job_id", job_id, "str"),
    }

    _url = _format_url_section(_url, **path_format_arguments)

    # Construct parameters
    _params["partyId"] = _SERIALIZER.query("party_id", party_id, "str")
    _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")

    # Construct headers
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="PUT", url=_url, params=_params, headers=_headers, **kwargs)


def build_planting_data_list_by_party_id_request(
    party_id: str,
    *,
    min_avg_planting_rate: Optional[float] = None,
    max_avg_planting_rate: Optional[float] = None,
    min_total_material: Optional[float] = None,
    max_total_material: Optional[float] = None,
    min_avg_material: Optional[float] = None,
    max_avg_material: Optional[float] = None,
    sources: Optional[List[str]] = None,
    associated_boundary_ids: Optional[List[str]] = None,
    min_operation_start_date_time: Optional[datetime.datetime] = None,
    max_operation_start_date_time: Optional[datetime.datetime] = None,
    min_operation_end_date_time: Optional[datetime.datetime] = None,
    max_operation_end_date_time: Optional[datetime.datetime] = None,
    min_operation_modified_date_time: Optional[datetime.datetime] = None,
    max_operation_modified_date_time: Optional[datetime.datetime] = None,
    min_area: Optional[float] = None,
    max_area: Optional[float] = None,
    ids: Optional[List[str]] = None,
    names: Optional[List[str]] = None,
    property_filters: Optional[List[str]] = None,
    statuses: Optional[List[str]] = None,
    min_created_date_time: Optional[datetime.datetime] = None,
    max_created_date_time: Optional[datetime.datetime] = None,
    min_last_modified_date_time: Optional[datetime.datetime] = None,
    max_last_modified_date_time: Optional[datetime.datetime] = None,
    skip_token: Optional[str] = None,
    **kwargs: Any
) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    api_version = kwargs.pop("api_version", _params.pop("api-version", "2022-11-01-preview"))  # type: str
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/parties/{partyId}/planting-data"
    path_format_arguments = {
        "partyId": _SERIALIZER.url("party_id", party_id, "str"),
    }

    _url = _format_url_section(_url, **path_format_arguments)

    # Construct parameters
    if min_avg_planting_rate is not None:
        _params["minAvgPlantingRate"] = _SERIALIZER.query("min_avg_planting_rate", min_avg_planting_rate, "float")
    if max_avg_planting_rate is not None:
        _params["maxAvgPlantingRate"] = _SERIALIZER.query("max_avg_planting_rate", max_avg_planting_rate, "float")
    if min_total_material is not None:
        _params["minTotalMaterial"] = _SERIALIZER.query("min_total_material", min_total_material, "float")
    if max_total_material is not None:
        _params["maxTotalMaterial"] = _SERIALIZER.query("max_total_material", max_total_material, "float")
    if min_avg_material is not None:
        _params["minAvgMaterial"] = _SERIALIZER.query("min_avg_material", min_avg_material, "float")
    if max_avg_material is not None:
        _params["maxAvgMaterial"] = _SERIALIZER.query("max_avg_material", max_avg_material, "float")
    if sources is not None:
        _params["sources"] = [_SERIALIZER.query("sources", q, "str") if q is not None else "" for q in sources]
    if associated_boundary_ids is not None:
        _params["associatedBoundaryIds"] = [
            _SERIALIZER.query("associated_boundary_ids", q, "str") if q is not None else ""
            for q in associated_boundary_ids
        ]
    if min_operation_start_date_time is not None:
        _params["minOperationStartDateTime"] = _SERIALIZER.query(
            "min_operation_start_date_time", min_operation_start_date_time, "iso-8601"
        )
    if max_operation_start_date_time is not None:
        _params["maxOperationStartDateTime"] = _SERIALIZER.query(
            "max_operation_start_date_time", max_operation_start_date_time, "iso-8601"
        )
    if min_operation_end_date_time is not None:
        _params["minOperationEndDateTime"] = _SERIALIZER.query(
            "min_operation_end_date_time", min_operation_end_date_time, "iso-8601"
        )
    if max_operation_end_date_time is not None:
        _params["maxOperationEndDateTime"] = _SERIALIZER.query(
            "max_operation_end_date_time", max_operation_end_date_time, "iso-8601"
        )
    if min_operation_modified_date_time is not None:
        _params["minOperationModifiedDateTime"] = _SERIALIZER.query(
            "min_operation_modified_date_time", min_operation_modified_date_time, "iso-8601"
        )
    if max_operation_modified_date_time is not None:
        _params["maxOperationModifiedDateTime"] = _SERIALIZER.query(
            "max_operation_modified_date_time", max_operation_modified_date_time, "iso-8601"
        )
    if min_area is not None:
        _params["minArea"] = _SERIALIZER.query("min_area", min_area, "float")
    if max_area is not None:
        _params["maxArea"] = _SERIALIZER.query("max_area", max_area, "float")
    if ids is not None:
        _params["ids"] = [_SERIALIZER.query("ids", q, "str") if q is not None else "" for q in ids]
    if names is not None:
        _params["names"] = [_SERIALIZER.query("names", q, "str") if q is not None else "" for q in names]
    if property_filters is not None:
        _params["propertyFilters"] = [
            _SERIALIZER.query("property_filters", q, "str") if q is not None else "" for q in property_filters
        ]
    if statuses is not None:
        _params["statuses"] = [_SERIALIZER.query("statuses", q, "str") if q is not None else "" for q in statuses]
    if min_created_date_time is not None:
        _params["minCreatedDateTime"] = _SERIALIZER.query("min_created_date_time", min_created_date_time, "iso-8601")
    if max_created_date_time is not None:
        _params["maxCreatedDateTime"] = _SERIALIZER.query("max_created_date_time", max_created_date_time, "iso-8601")
    if min_last_modified_date_time is not None:
        _params["minLastModifiedDateTime"] = _SERIALIZER.query(
            "min_last_modified_date_time", min_last_modified_date_time, "iso-8601"
        )
    if max_last_modified_date_time is not None:
        _params["maxLastModifiedDateTime"] = _SERIALIZER.query(
            "max_last_modified_date_time", max_last_modified_date_time, "iso-8601"
        )
    if skip_token is not None:
        _params["skipToken"] = _SERIALIZER.query("skip_token", skip_token, "str")
    _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")

    # Construct headers
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="GET", url=_url, params=_params, headers=_headers, **kwargs)


def build_planting_data_get_request(party_id: str, planting_data_id: str, **kwargs: Any) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    api_version = kwargs.pop("api_version", _params.pop("api-version", "2022-11-01-preview"))  # type: str
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/parties/{partyId}/planting-data/{plantingDataId}"
    path_format_arguments = {
        "partyId": _SERIALIZER.url("party_id", party_id, "str"),
        "plantingDataId": _SERIALIZER.url("planting_data_id", planting_data_id, "str"),
    }

    _url = _format_url_section(_url, **path_format_arguments)

    # Construct parameters
    _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")

    # Construct headers
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="GET", url=_url, params=_params, headers=_headers, **kwargs)


def build_planting_data_create_or_update_request(party_id: str, planting_data_id: str, **kwargs: Any) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    content_type = kwargs.pop("content_type", _headers.pop("Content-Type", None))  # type: Optional[str]
    api_version = kwargs.pop("api_version", _params.pop("api-version", "2022-11-01-preview"))  # type: str
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/parties/{partyId}/planting-data/{plantingDataId}"
    path_format_arguments = {
        "partyId": _SERIALIZER.url("party_id", party_id, "str"),
        "plantingDataId": _SERIALIZER.url("planting_data_id", planting_data_id, "str"),
    }

    _url = _format_url_section(_url, **path_format_arguments)

    # Construct parameters
    _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")

    # Construct headers
    if content_type is not None:
        _headers["Content-Type"] = _SERIALIZER.header("content_type", content_type, "str")
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="PATCH", url=_url, params=_params, headers=_headers, **kwargs)


def build_planting_data_delete_request(party_id: str, planting_data_id: str, **kwargs: Any) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    api_version = kwargs.pop("api_version", _params.pop("api-version", "2022-11-01-preview"))  # type: str
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/parties/{partyId}/planting-data/{plantingDataId}"
    path_format_arguments = {
        "partyId": _SERIALIZER.url("party_id", party_id, "str"),
        "plantingDataId": _SERIALIZER.url("planting_data_id", planting_data_id, "str"),
    }

    _url = _format_url_section(_url, **path_format_arguments)

    # Construct parameters
    _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")

    # Construct headers
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="DELETE", url=_url, params=_params, headers=_headers, **kwargs)


def build_planting_data_list_request(
    *,
    min_avg_planting_rate: Optional[float] = None,
    max_avg_planting_rate: Optional[float] = None,
    min_total_material: Optional[float] = None,
    max_total_material: Optional[float] = None,
    min_avg_material: Optional[float] = None,
    max_avg_material: Optional[float] = None,
    sources: Optional[List[str]] = None,
    associated_boundary_ids: Optional[List[str]] = None,
    min_operation_start_date_time: Optional[datetime.datetime] = None,
    max_operation_start_date_time: Optional[datetime.datetime] = None,
    min_operation_end_date_time: Optional[datetime.datetime] = None,
    max_operation_end_date_time: Optional[datetime.datetime] = None,
    min_operation_modified_date_time: Optional[datetime.datetime] = None,
    max_operation_modified_date_time: Optional[datetime.datetime] = None,
    min_area: Optional[float] = None,
    max_area: Optional[float] = None,
    ids: Optional[List[str]] = None,
    names: Optional[List[str]] = None,
    property_filters: Optional[List[str]] = None,
    statuses: Optional[List[str]] = None,
    min_created_date_time: Optional[datetime.datetime] = None,
    max_created_date_time: Optional[datetime.datetime] = None,
    min_last_modified_date_time: Optional[datetime.datetime] = None,
    max_last_modified_date_time: Optional[datetime.datetime] = None,
    skip_token: Optional[str] = None,
    **kwargs: Any
) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    api_version = kwargs.pop("api_version", _params.pop("api-version", "2022-11-01-preview"))  # type: str
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/planting-data"

    # Construct parameters
    if min_avg_planting_rate is not None:
        _params["minAvgPlantingRate"] = _SERIALIZER.query("min_avg_planting_rate", min_avg_planting_rate, "float")
    if max_avg_planting_rate is not None:
        _params["maxAvgPlantingRate"] = _SERIALIZER.query("max_avg_planting_rate", max_avg_planting_rate, "float")
    if min_total_material is not None:
        _params["minTotalMaterial"] = _SERIALIZER.query("min_total_material", min_total_material, "float")
    if max_total_material is not None:
        _params["maxTotalMaterial"] = _SERIALIZER.query("max_total_material", max_total_material, "float")
    if min_avg_material is not None:
        _params["minAvgMaterial"] = _SERIALIZER.query("min_avg_material", min_avg_material, "float")
    if max_avg_material is not None:
        _params["maxAvgMaterial"] = _SERIALIZER.query("max_avg_material", max_avg_material, "float")
    if sources is not None:
        _params["sources"] = [_SERIALIZER.query("sources", q, "str") if q is not None else "" for q in sources]
    if associated_boundary_ids is not None:
        _params["associatedBoundaryIds"] = [
            _SERIALIZER.query("associated_boundary_ids", q, "str") if q is not None else ""
            for q in associated_boundary_ids
        ]
    if min_operation_start_date_time is not None:
        _params["minOperationStartDateTime"] = _SERIALIZER.query(
            "min_operation_start_date_time", min_operation_start_date_time, "iso-8601"
        )
    if max_operation_start_date_time is not None:
        _params["maxOperationStartDateTime"] = _SERIALIZER.query(
            "max_operation_start_date_time", max_operation_start_date_time, "iso-8601"
        )
    if min_operation_end_date_time is not None:
        _params["minOperationEndDateTime"] = _SERIALIZER.query(
            "min_operation_end_date_time", min_operation_end_date_time, "iso-8601"
        )
    if max_operation_end_date_time is not None:
        _params["maxOperationEndDateTime"] = _SERIALIZER.query(
            "max_operation_end_date_time", max_operation_end_date_time, "iso-8601"
        )
    if min_operation_modified_date_time is not None:
        _params["minOperationModifiedDateTime"] = _SERIALIZER.query(
            "min_operation_modified_date_time", min_operation_modified_date_time, "iso-8601"
        )
    if max_operation_modified_date_time is not None:
        _params["maxOperationModifiedDateTime"] = _SERIALIZER.query(
            "max_operation_modified_date_time", max_operation_modified_date_time, "iso-8601"
        )
    if min_area is not None:
        _params["minArea"] = _SERIALIZER.query("min_area", min_area, "float")
    if max_area is not None:
        _params["maxArea"] = _SERIALIZER.query("max_area", max_area, "float")
    if ids is not None:
        _params["ids"] = [_SERIALIZER.query("ids", q, "str") if q is not None else "" for q in ids]
    if names is not None:
        _params["names"] = [_SERIALIZER.query("names", q, "str") if q is not None else "" for q in names]
    if property_filters is not None:
        _params["propertyFilters"] = [
            _SERIALIZER.query("property_filters", q, "str") if q is not None else "" for q in property_filters
        ]
    if statuses is not None:
        _params["statuses"] = [_SERIALIZER.query("statuses", q, "str") if q is not None else "" for q in statuses]
    if min_created_date_time is not None:
        _params["minCreatedDateTime"] = _SERIALIZER.query("min_created_date_time", min_created_date_time, "iso-8601")
    if max_created_date_time is not None:
        _params["maxCreatedDateTime"] = _SERIALIZER.query("max_created_date_time", max_created_date_time, "iso-8601")
    if min_last_modified_date_time is not None:
        _params["minLastModifiedDateTime"] = _SERIALIZER.query(
            "min_last_modified_date_time", min_last_modified_date_time, "iso-8601"
        )
    if max_last_modified_date_time is not None:
        _params["maxLastModifiedDateTime"] = _SERIALIZER.query(
            "max_last_modified_date_time", max_last_modified_date_time, "iso-8601"
        )
    if skip_token is not None:
        _params["skipToken"] = _SERIALIZER.query("skip_token", skip_token, "str")
    _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")

    # Construct headers
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="GET", url=_url, params=_params, headers=_headers, **kwargs)


def build_planting_data_create_cascade_delete_job_request(
    job_id: str, *, party_id: str, planting_data_id: str, **kwargs: Any
) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    api_version = kwargs.pop("api_version", _params.pop("api-version", "2022-11-01-preview"))  # type: str
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/planting-data/cascade-delete/{jobId}"
    path_format_arguments = {
        "jobId": _SERIALIZER.url("job_id", job_id, "str"),
    }

    _url = _format_url_section(_url, **path_format_arguments)

    # Construct parameters
    _params["partyId"] = _SERIALIZER.query("party_id", party_id, "str")
    _params["plantingDataId"] = _SERIALIZER.query("planting_data_id", planting_data_id, "str")
    _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")

    # Construct headers
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="PUT", url=_url, params=_params, headers=_headers, **kwargs)


def build_planting_data_get_cascade_delete_job_details_request(job_id: str, **kwargs: Any) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    api_version = kwargs.pop("api_version", _params.pop("api-version", "2022-11-01-preview"))  # type: str
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/planting-data/cascade-delete/{jobId}"
    path_format_arguments = {
        "jobId": _SERIALIZER.url("job_id", job_id, "str"),
    }

    _url = _format_url_section(_url, **path_format_arguments)

    # Construct parameters
    _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")

    # Construct headers
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="GET", url=_url, params=_params, headers=_headers, **kwargs)


def build_plant_tissue_analyses_list_by_party_id_request(
    party_id: str,
    *,
    season_ids: Optional[List[str]] = None,
    crop_ids: Optional[List[str]] = None,
    crop_products_ids: Optional[List[str]] = None,
    field_ids: Optional[List[str]] = None,
    ids: Optional[List[str]] = None,
    names: Optional[List[str]] = None,
    property_filters: Optional[List[str]] = None,
    statuses: Optional[List[str]] = None,
    min_created_date_time: Optional[datetime.datetime] = None,
    max_created_date_time: Optional[datetime.datetime] = None,
    min_last_modified_date_time: Optional[datetime.datetime] = None,
    max_last_modified_date_time: Optional[datetime.datetime] = None,
    skip_token: Optional[str] = None,
    **kwargs: Any
) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    api_version = kwargs.pop("api_version", _params.pop("api-version", "2022-11-01-preview"))  # type: str
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/parties/{partyId}/plant-tissue-analyses"
    path_format_arguments = {
        "partyId": _SERIALIZER.url("party_id", party_id, "str"),
    }

    _url = _format_url_section(_url, **path_format_arguments)

    # Construct parameters
    if season_ids is not None:
        _params["seasonIds"] = [_SERIALIZER.query("season_ids", q, "str") if q is not None else "" for q in season_ids]
    if crop_ids is not None:
        _params["cropIds"] = [_SERIALIZER.query("crop_ids", q, "str") if q is not None else "" for q in crop_ids]
    if crop_products_ids is not None:
        _params["cropProductsIds"] = [
            _SERIALIZER.query("crop_products_ids", q, "str") if q is not None else "" for q in crop_products_ids
        ]
    if field_ids is not None:
        _params["fieldIds"] = [_SERIALIZER.query("field_ids", q, "str") if q is not None else "" for q in field_ids]
    if ids is not None:
        _params["ids"] = [_SERIALIZER.query("ids", q, "str") if q is not None else "" for q in ids]
    if names is not None:
        _params["names"] = [_SERIALIZER.query("names", q, "str") if q is not None else "" for q in names]
    if property_filters is not None:
        _params["propertyFilters"] = [
            _SERIALIZER.query("property_filters", q, "str") if q is not None else "" for q in property_filters
        ]
    if statuses is not None:
        _params["statuses"] = [_SERIALIZER.query("statuses", q, "str") if q is not None else "" for q in statuses]
    if min_created_date_time is not None:
        _params["minCreatedDateTime"] = _SERIALIZER.query("min_created_date_time", min_created_date_time, "iso-8601")
    if max_created_date_time is not None:
        _params["maxCreatedDateTime"] = _SERIALIZER.query("max_created_date_time", max_created_date_time, "iso-8601")
    if min_last_modified_date_time is not None:
        _params["minLastModifiedDateTime"] = _SERIALIZER.query(
            "min_last_modified_date_time", min_last_modified_date_time, "iso-8601"
        )
    if max_last_modified_date_time is not None:
        _params["maxLastModifiedDateTime"] = _SERIALIZER.query(
            "max_last_modified_date_time", max_last_modified_date_time, "iso-8601"
        )
    if skip_token is not None:
        _params["skipToken"] = _SERIALIZER.query("skip_token", skip_token, "str")
    _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")

    # Construct headers
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="GET", url=_url, params=_params, headers=_headers, **kwargs)


def build_plant_tissue_analyses_get_request(party_id: str, plant_tissue_analysis_id: str, **kwargs: Any) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    api_version = kwargs.pop("api_version", _params.pop("api-version", "2022-11-01-preview"))  # type: str
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/parties/{partyId}/plant-tissue-analyses/{plantTissueAnalysisId}"
    path_format_arguments = {
        "partyId": _SERIALIZER.url("party_id", party_id, "str"),
        "plantTissueAnalysisId": _SERIALIZER.url("plant_tissue_analysis_id", plant_tissue_analysis_id, "str"),
    }

    _url = _format_url_section(_url, **path_format_arguments)

    # Construct parameters
    _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")

    # Construct headers
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="GET", url=_url, params=_params, headers=_headers, **kwargs)


def build_plant_tissue_analyses_create_or_update_request(
    party_id: str, plant_tissue_analysis_id: str, **kwargs: Any
) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    content_type = kwargs.pop("content_type", _headers.pop("Content-Type", None))  # type: Optional[str]
    api_version = kwargs.pop("api_version", _params.pop("api-version", "2022-11-01-preview"))  # type: str
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/parties/{partyId}/plant-tissue-analyses/{plantTissueAnalysisId}"
    path_format_arguments = {
        "partyId": _SERIALIZER.url("party_id", party_id, "str"),
        "plantTissueAnalysisId": _SERIALIZER.url("plant_tissue_analysis_id", plant_tissue_analysis_id, "str"),
    }

    _url = _format_url_section(_url, **path_format_arguments)

    # Construct parameters
    _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")

    # Construct headers
    if content_type is not None:
        _headers["Content-Type"] = _SERIALIZER.header("content_type", content_type, "str")
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="PATCH", url=_url, params=_params, headers=_headers, **kwargs)


def build_plant_tissue_analyses_delete_request(
    party_id: str, plant_tissue_analysis_id: str, **kwargs: Any
) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    api_version = kwargs.pop("api_version", _params.pop("api-version", "2022-11-01-preview"))  # type: str
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/parties/{partyId}/plant-tissue-analyses/{plantTissueAnalysisId}"
    path_format_arguments = {
        "partyId": _SERIALIZER.url("party_id", party_id, "str"),
        "plantTissueAnalysisId": _SERIALIZER.url("plant_tissue_analysis_id", plant_tissue_analysis_id, "str"),
    }

    _url = _format_url_section(_url, **path_format_arguments)

    # Construct parameters
    _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")

    # Construct headers
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="DELETE", url=_url, params=_params, headers=_headers, **kwargs)


def build_plant_tissue_analyses_list_request(
    *,
    season_ids: Optional[List[str]] = None,
    crop_ids: Optional[List[str]] = None,
    crop_products_ids: Optional[List[str]] = None,
    field_ids: Optional[List[str]] = None,
    ids: Optional[List[str]] = None,
    names: Optional[List[str]] = None,
    property_filters: Optional[List[str]] = None,
    statuses: Optional[List[str]] = None,
    min_created_date_time: Optional[datetime.datetime] = None,
    max_created_date_time: Optional[datetime.datetime] = None,
    min_last_modified_date_time: Optional[datetime.datetime] = None,
    max_last_modified_date_time: Optional[datetime.datetime] = None,
    skip_token: Optional[str] = None,
    **kwargs: Any
) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    api_version = kwargs.pop("api_version", _params.pop("api-version", "2022-11-01-preview"))  # type: str
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/plant-tissue-analyses"

    # Construct parameters
    if season_ids is not None:
        _params["seasonIds"] = [_SERIALIZER.query("season_ids", q, "str") if q is not None else "" for q in season_ids]
    if crop_ids is not None:
        _params["cropIds"] = [_SERIALIZER.query("crop_ids", q, "str") if q is not None else "" for q in crop_ids]
    if crop_products_ids is not None:
        _params["cropProductsIds"] = [
            _SERIALIZER.query("crop_products_ids", q, "str") if q is not None else "" for q in crop_products_ids
        ]
    if field_ids is not None:
        _params["fieldIds"] = [_SERIALIZER.query("field_ids", q, "str") if q is not None else "" for q in field_ids]
    if ids is not None:
        _params["ids"] = [_SERIALIZER.query("ids", q, "str") if q is not None else "" for q in ids]
    if names is not None:
        _params["names"] = [_SERIALIZER.query("names", q, "str") if q is not None else "" for q in names]
    if property_filters is not None:
        _params["propertyFilters"] = [
            _SERIALIZER.query("property_filters", q, "str") if q is not None else "" for q in property_filters
        ]
    if statuses is not None:
        _params["statuses"] = [_SERIALIZER.query("statuses", q, "str") if q is not None else "" for q in statuses]
    if min_created_date_time is not None:
        _params["minCreatedDateTime"] = _SERIALIZER.query("min_created_date_time", min_created_date_time, "iso-8601")
    if max_created_date_time is not None:
        _params["maxCreatedDateTime"] = _SERIALIZER.query("max_created_date_time", max_created_date_time, "iso-8601")
    if min_last_modified_date_time is not None:
        _params["minLastModifiedDateTime"] = _SERIALIZER.query(
            "min_last_modified_date_time", min_last_modified_date_time, "iso-8601"
        )
    if max_last_modified_date_time is not None:
        _params["maxLastModifiedDateTime"] = _SERIALIZER.query(
            "max_last_modified_date_time", max_last_modified_date_time, "iso-8601"
        )
    if skip_token is not None:
        _params["skipToken"] = _SERIALIZER.query("skip_token", skip_token, "str")
    _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")

    # Construct headers
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="GET", url=_url, params=_params, headers=_headers, **kwargs)


def build_plant_tissue_analyses_create_cascade_delete_job_request(
    job_id: str, *, party_id: str, plant_tissue_analysis_id: str, **kwargs: Any
) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    api_version = kwargs.pop("api_version", _params.pop("api-version", "2022-11-01-preview"))  # type: str
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/plant-tissue-analyses/cascade-delete/{jobId}"
    path_format_arguments = {
        "jobId": _SERIALIZER.url("job_id", job_id, "str"),
    }

    _url = _format_url_section(_url, **path_format_arguments)

    # Construct parameters
    _params["partyId"] = _SERIALIZER.query("party_id", party_id, "str")
    _params["plantTissueAnalysisId"] = _SERIALIZER.query("plant_tissue_analysis_id", plant_tissue_analysis_id, "str")
    _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")

    # Construct headers
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="PUT", url=_url, params=_params, headers=_headers, **kwargs)


def build_plant_tissue_analyses_get_cascade_delete_job_details_request(job_id: str, **kwargs: Any) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    api_version = kwargs.pop("api_version", _params.pop("api-version", "2022-11-01-preview"))  # type: str
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/plant-tissue-analyses/cascade-delete/{jobId}"
    path_format_arguments = {
        "jobId": _SERIALIZER.url("job_id", job_id, "str"),
    }

    _url = _format_url_section(_url, **path_format_arguments)

    # Construct parameters
    _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")

    # Construct headers
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="GET", url=_url, params=_params, headers=_headers, **kwargs)


def build_prescription_maps_list_by_party_id_request(
    party_id: str,
    *,
    types: Optional[List[str]] = None,
    crop_ids: Optional[List[str]] = None,
    season_ids: Optional[List[str]] = None,
    field_ids: Optional[List[str]] = None,
    sources: Optional[List[str]] = None,
    ids: Optional[List[str]] = None,
    names: Optional[List[str]] = None,
    property_filters: Optional[List[str]] = None,
    statuses: Optional[List[str]] = None,
    min_created_date_time: Optional[datetime.datetime] = None,
    max_created_date_time: Optional[datetime.datetime] = None,
    min_last_modified_date_time: Optional[datetime.datetime] = None,
    max_last_modified_date_time: Optional[datetime.datetime] = None,
    skip_token: Optional[str] = None,
    **kwargs: Any
) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    api_version = kwargs.pop("api_version", _params.pop("api-version", "2022-11-01-preview"))  # type: str
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/parties/{partyId}/prescription-maps"
    path_format_arguments = {
        "partyId": _SERIALIZER.url("party_id", party_id, "str"),
    }

    _url = _format_url_section(_url, **path_format_arguments)

    # Construct parameters
    if types is not None:
        _params["types"] = [_SERIALIZER.query("types", q, "str") if q is not None else "" for q in types]
    if crop_ids is not None:
        _params["cropIds"] = [_SERIALIZER.query("crop_ids", q, "str") if q is not None else "" for q in crop_ids]
    if season_ids is not None:
        _params["seasonIds"] = [_SERIALIZER.query("season_ids", q, "str") if q is not None else "" for q in season_ids]
    if field_ids is not None:
        _params["fieldIds"] = [_SERIALIZER.query("field_ids", q, "str") if q is not None else "" for q in field_ids]
    if sources is not None:
        _params["sources"] = [_SERIALIZER.query("sources", q, "str") if q is not None else "" for q in sources]
    if ids is not None:
        _params["ids"] = [_SERIALIZER.query("ids", q, "str") if q is not None else "" for q in ids]
    if names is not None:
        _params["names"] = [_SERIALIZER.query("names", q, "str") if q is not None else "" for q in names]
    if property_filters is not None:
        _params["propertyFilters"] = [
            _SERIALIZER.query("property_filters", q, "str") if q is not None else "" for q in property_filters
        ]
    if statuses is not None:
        _params["statuses"] = [_SERIALIZER.query("statuses", q, "str") if q is not None else "" for q in statuses]
    if min_created_date_time is not None:
        _params["minCreatedDateTime"] = _SERIALIZER.query("min_created_date_time", min_created_date_time, "iso-8601")
    if max_created_date_time is not None:
        _params["maxCreatedDateTime"] = _SERIALIZER.query("max_created_date_time", max_created_date_time, "iso-8601")
    if min_last_modified_date_time is not None:
        _params["minLastModifiedDateTime"] = _SERIALIZER.query(
            "min_last_modified_date_time", min_last_modified_date_time, "iso-8601"
        )
    if max_last_modified_date_time is not None:
        _params["maxLastModifiedDateTime"] = _SERIALIZER.query(
            "max_last_modified_date_time", max_last_modified_date_time, "iso-8601"
        )
    if skip_token is not None:
        _params["skipToken"] = _SERIALIZER.query("skip_token", skip_token, "str")
    _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")

    # Construct headers
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="GET", url=_url, params=_params, headers=_headers, **kwargs)


def build_prescription_maps_get_request(party_id: str, prescription_map_id: str, **kwargs: Any) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    api_version = kwargs.pop("api_version", _params.pop("api-version", "2022-11-01-preview"))  # type: str
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/parties/{partyId}/prescription-maps/{prescriptionMapId}"
    path_format_arguments = {
        "partyId": _SERIALIZER.url("party_id", party_id, "str"),
        "prescriptionMapId": _SERIALIZER.url("prescription_map_id", prescription_map_id, "str"),
    }

    _url = _format_url_section(_url, **path_format_arguments)

    # Construct parameters
    _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")

    # Construct headers
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="GET", url=_url, params=_params, headers=_headers, **kwargs)


def build_prescription_maps_create_or_update_request(
    party_id: str, prescription_map_id: str, **kwargs: Any
) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    content_type = kwargs.pop("content_type", _headers.pop("Content-Type", None))  # type: Optional[str]
    api_version = kwargs.pop("api_version", _params.pop("api-version", "2022-11-01-preview"))  # type: str
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/parties/{partyId}/prescription-maps/{prescriptionMapId}"
    path_format_arguments = {
        "partyId": _SERIALIZER.url("party_id", party_id, "str"),
        "prescriptionMapId": _SERIALIZER.url("prescription_map_id", prescription_map_id, "str"),
    }

    _url = _format_url_section(_url, **path_format_arguments)

    # Construct parameters
    _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")

    # Construct headers
    if content_type is not None:
        _headers["Content-Type"] = _SERIALIZER.header("content_type", content_type, "str")
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="PATCH", url=_url, params=_params, headers=_headers, **kwargs)


def build_prescription_maps_delete_request(party_id: str, prescription_map_id: str, **kwargs: Any) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    api_version = kwargs.pop("api_version", _params.pop("api-version", "2022-11-01-preview"))  # type: str
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/parties/{partyId}/prescription-maps/{prescriptionMapId}"
    path_format_arguments = {
        "partyId": _SERIALIZER.url("party_id", party_id, "str"),
        "prescriptionMapId": _SERIALIZER.url("prescription_map_id", prescription_map_id, "str"),
    }

    _url = _format_url_section(_url, **path_format_arguments)

    # Construct parameters
    _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")

    # Construct headers
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="DELETE", url=_url, params=_params, headers=_headers, **kwargs)


def build_prescription_maps_list_request(
    *,
    types: Optional[List[str]] = None,
    crop_ids: Optional[List[str]] = None,
    season_ids: Optional[List[str]] = None,
    field_ids: Optional[List[str]] = None,
    sources: Optional[List[str]] = None,
    ids: Optional[List[str]] = None,
    names: Optional[List[str]] = None,
    property_filters: Optional[List[str]] = None,
    statuses: Optional[List[str]] = None,
    min_created_date_time: Optional[datetime.datetime] = None,
    max_created_date_time: Optional[datetime.datetime] = None,
    min_last_modified_date_time: Optional[datetime.datetime] = None,
    max_last_modified_date_time: Optional[datetime.datetime] = None,
    skip_token: Optional[str] = None,
    **kwargs: Any
) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    api_version = kwargs.pop("api_version", _params.pop("api-version", "2022-11-01-preview"))  # type: str
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/prescription-maps"

    # Construct parameters
    if types is not None:
        _params["types"] = [_SERIALIZER.query("types", q, "str") if q is not None else "" for q in types]
    if crop_ids is not None:
        _params["cropIds"] = [_SERIALIZER.query("crop_ids", q, "str") if q is not None else "" for q in crop_ids]
    if season_ids is not None:
        _params["seasonIds"] = [_SERIALIZER.query("season_ids", q, "str") if q is not None else "" for q in season_ids]
    if field_ids is not None:
        _params["fieldIds"] = [_SERIALIZER.query("field_ids", q, "str") if q is not None else "" for q in field_ids]
    if sources is not None:
        _params["sources"] = [_SERIALIZER.query("sources", q, "str") if q is not None else "" for q in sources]
    if ids is not None:
        _params["ids"] = [_SERIALIZER.query("ids", q, "str") if q is not None else "" for q in ids]
    if names is not None:
        _params["names"] = [_SERIALIZER.query("names", q, "str") if q is not None else "" for q in names]
    if property_filters is not None:
        _params["propertyFilters"] = [
            _SERIALIZER.query("property_filters", q, "str") if q is not None else "" for q in property_filters
        ]
    if statuses is not None:
        _params["statuses"] = [_SERIALIZER.query("statuses", q, "str") if q is not None else "" for q in statuses]
    if min_created_date_time is not None:
        _params["minCreatedDateTime"] = _SERIALIZER.query("min_created_date_time", min_created_date_time, "iso-8601")
    if max_created_date_time is not None:
        _params["maxCreatedDateTime"] = _SERIALIZER.query("max_created_date_time", max_created_date_time, "iso-8601")
    if min_last_modified_date_time is not None:
        _params["minLastModifiedDateTime"] = _SERIALIZER.query(
            "min_last_modified_date_time", min_last_modified_date_time, "iso-8601"
        )
    if max_last_modified_date_time is not None:
        _params["maxLastModifiedDateTime"] = _SERIALIZER.query(
            "max_last_modified_date_time", max_last_modified_date_time, "iso-8601"
        )
    if skip_token is not None:
        _params["skipToken"] = _SERIALIZER.query("skip_token", skip_token, "str")
    _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")

    # Construct headers
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="GET", url=_url, params=_params, headers=_headers, **kwargs)


def build_prescription_maps_get_cascade_delete_job_details_request(job_id: str, **kwargs: Any) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    api_version = kwargs.pop("api_version", _params.pop("api-version", "2022-11-01-preview"))  # type: str
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/prescription-maps/cascade-delete/{jobId}"
    path_format_arguments = {
        "jobId": _SERIALIZER.url("job_id", job_id, "str"),
    }

    _url = _format_url_section(_url, **path_format_arguments)

    # Construct parameters
    _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")

    # Construct headers
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="GET", url=_url, params=_params, headers=_headers, **kwargs)


def build_prescription_maps_create_cascade_delete_job_request(
    job_id: str, *, party_id: str, prescription_map_id: str, **kwargs: Any
) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    api_version = kwargs.pop("api_version", _params.pop("api-version", "2022-11-01-preview"))  # type: str
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/prescription-maps/cascade-delete/{jobId}"
    path_format_arguments = {
        "jobId": _SERIALIZER.url("job_id", job_id, "str"),
    }

    _url = _format_url_section(_url, **path_format_arguments)

    # Construct parameters
    _params["partyId"] = _SERIALIZER.query("party_id", party_id, "str")
    _params["prescriptionMapId"] = _SERIALIZER.query("prescription_map_id", prescription_map_id, "str")
    _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")

    # Construct headers
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="PUT", url=_url, params=_params, headers=_headers, **kwargs)


def build_prescriptions_list_by_party_id_request(
    party_id: str,
    *,
    prescription_map_ids: Optional[List[str]] = None,
    types: Optional[List[str]] = None,
    product_codes: Optional[List[str]] = None,
    product_names: Optional[List[str]] = None,
    sources: Optional[List[str]] = None,
    ids: Optional[List[str]] = None,
    names: Optional[List[str]] = None,
    property_filters: Optional[List[str]] = None,
    statuses: Optional[List[str]] = None,
    min_created_date_time: Optional[datetime.datetime] = None,
    max_created_date_time: Optional[datetime.datetime] = None,
    min_last_modified_date_time: Optional[datetime.datetime] = None,
    max_last_modified_date_time: Optional[datetime.datetime] = None,
    skip_token: Optional[str] = None,
    **kwargs: Any
) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    api_version = kwargs.pop("api_version", _params.pop("api-version", "2022-11-01-preview"))  # type: str
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/parties/{partyId}/prescriptions"
    path_format_arguments = {
        "partyId": _SERIALIZER.url("party_id", party_id, "str"),
    }

    _url = _format_url_section(_url, **path_format_arguments)

    # Construct parameters
    if prescription_map_ids is not None:
        _params["prescriptionMapIds"] = [
            _SERIALIZER.query("prescription_map_ids", q, "str") if q is not None else "" for q in prescription_map_ids
        ]
    if types is not None:
        _params["types"] = [_SERIALIZER.query("types", q, "str") if q is not None else "" for q in types]
    if product_codes is not None:
        _params["productCodes"] = [
            _SERIALIZER.query("product_codes", q, "str") if q is not None else "" for q in product_codes
        ]
    if product_names is not None:
        _params["productNames"] = [
            _SERIALIZER.query("product_names", q, "str") if q is not None else "" for q in product_names
        ]
    if sources is not None:
        _params["sources"] = [_SERIALIZER.query("sources", q, "str") if q is not None else "" for q in sources]
    if ids is not None:
        _params["ids"] = [_SERIALIZER.query("ids", q, "str") if q is not None else "" for q in ids]
    if names is not None:
        _params["names"] = [_SERIALIZER.query("names", q, "str") if q is not None else "" for q in names]
    if property_filters is not None:
        _params["propertyFilters"] = [
            _SERIALIZER.query("property_filters", q, "str") if q is not None else "" for q in property_filters
        ]
    if statuses is not None:
        _params["statuses"] = [_SERIALIZER.query("statuses", q, "str") if q is not None else "" for q in statuses]
    if min_created_date_time is not None:
        _params["minCreatedDateTime"] = _SERIALIZER.query("min_created_date_time", min_created_date_time, "iso-8601")
    if max_created_date_time is not None:
        _params["maxCreatedDateTime"] = _SERIALIZER.query("max_created_date_time", max_created_date_time, "iso-8601")
    if min_last_modified_date_time is not None:
        _params["minLastModifiedDateTime"] = _SERIALIZER.query(
            "min_last_modified_date_time", min_last_modified_date_time, "iso-8601"
        )
    if max_last_modified_date_time is not None:
        _params["maxLastModifiedDateTime"] = _SERIALIZER.query(
            "max_last_modified_date_time", max_last_modified_date_time, "iso-8601"
        )
    if skip_token is not None:
        _params["skipToken"] = _SERIALIZER.query("skip_token", skip_token, "str")
    _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")

    # Construct headers
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="GET", url=_url, params=_params, headers=_headers, **kwargs)


def build_prescriptions_get_request(party_id: str, prescription_id: str, **kwargs: Any) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    api_version = kwargs.pop("api_version", _params.pop("api-version", "2022-11-01-preview"))  # type: str
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/parties/{partyId}/prescriptions/{prescriptionId}"
    path_format_arguments = {
        "partyId": _SERIALIZER.url("party_id", party_id, "str"),
        "prescriptionId": _SERIALIZER.url("prescription_id", prescription_id, "str"),
    }

    _url = _format_url_section(_url, **path_format_arguments)

    # Construct parameters
    _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")

    # Construct headers
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="GET", url=_url, params=_params, headers=_headers, **kwargs)


def build_prescriptions_create_or_update_request(party_id: str, prescription_id: str, **kwargs: Any) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    content_type = kwargs.pop("content_type", _headers.pop("Content-Type", None))  # type: Optional[str]
    api_version = kwargs.pop("api_version", _params.pop("api-version", "2022-11-01-preview"))  # type: str
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/parties/{partyId}/prescriptions/{prescriptionId}"
    path_format_arguments = {
        "partyId": _SERIALIZER.url("party_id", party_id, "str"),
        "prescriptionId": _SERIALIZER.url("prescription_id", prescription_id, "str"),
    }

    _url = _format_url_section(_url, **path_format_arguments)

    # Construct parameters
    _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")

    # Construct headers
    if content_type is not None:
        _headers["Content-Type"] = _SERIALIZER.header("content_type", content_type, "str")
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="PATCH", url=_url, params=_params, headers=_headers, **kwargs)


def build_prescriptions_delete_request(party_id: str, prescription_id: str, **kwargs: Any) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    api_version = kwargs.pop("api_version", _params.pop("api-version", "2022-11-01-preview"))  # type: str
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/parties/{partyId}/prescriptions/{prescriptionId}"
    path_format_arguments = {
        "partyId": _SERIALIZER.url("party_id", party_id, "str"),
        "prescriptionId": _SERIALIZER.url("prescription_id", prescription_id, "str"),
    }

    _url = _format_url_section(_url, **path_format_arguments)

    # Construct parameters
    _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")

    # Construct headers
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="DELETE", url=_url, params=_params, headers=_headers, **kwargs)


def build_prescriptions_list_request(
    *,
    prescription_map_ids: Optional[List[str]] = None,
    types: Optional[List[str]] = None,
    product_codes: Optional[List[str]] = None,
    product_names: Optional[List[str]] = None,
    sources: Optional[List[str]] = None,
    ids: Optional[List[str]] = None,
    names: Optional[List[str]] = None,
    property_filters: Optional[List[str]] = None,
    statuses: Optional[List[str]] = None,
    min_created_date_time: Optional[datetime.datetime] = None,
    max_created_date_time: Optional[datetime.datetime] = None,
    min_last_modified_date_time: Optional[datetime.datetime] = None,
    max_last_modified_date_time: Optional[datetime.datetime] = None,
    skip_token: Optional[str] = None,
    **kwargs: Any
) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    api_version = kwargs.pop("api_version", _params.pop("api-version", "2022-11-01-preview"))  # type: str
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/prescriptions"

    # Construct parameters
    if prescription_map_ids is not None:
        _params["prescriptionMapIds"] = [
            _SERIALIZER.query("prescription_map_ids", q, "str") if q is not None else "" for q in prescription_map_ids
        ]
    if types is not None:
        _params["types"] = [_SERIALIZER.query("types", q, "str") if q is not None else "" for q in types]
    if product_codes is not None:
        _params["productCodes"] = [
            _SERIALIZER.query("product_codes", q, "str") if q is not None else "" for q in product_codes
        ]
    if product_names is not None:
        _params["productNames"] = [
            _SERIALIZER.query("product_names", q, "str") if q is not None else "" for q in product_names
        ]
    if sources is not None:
        _params["sources"] = [_SERIALIZER.query("sources", q, "str") if q is not None else "" for q in sources]
    if ids is not None:
        _params["ids"] = [_SERIALIZER.query("ids", q, "str") if q is not None else "" for q in ids]
    if names is not None:
        _params["names"] = [_SERIALIZER.query("names", q, "str") if q is not None else "" for q in names]
    if property_filters is not None:
        _params["propertyFilters"] = [
            _SERIALIZER.query("property_filters", q, "str") if q is not None else "" for q in property_filters
        ]
    if statuses is not None:
        _params["statuses"] = [_SERIALIZER.query("statuses", q, "str") if q is not None else "" for q in statuses]
    if min_created_date_time is not None:
        _params["minCreatedDateTime"] = _SERIALIZER.query("min_created_date_time", min_created_date_time, "iso-8601")
    if max_created_date_time is not None:
        _params["maxCreatedDateTime"] = _SERIALIZER.query("max_created_date_time", max_created_date_time, "iso-8601")
    if min_last_modified_date_time is not None:
        _params["minLastModifiedDateTime"] = _SERIALIZER.query(
            "min_last_modified_date_time", min_last_modified_date_time, "iso-8601"
        )
    if max_last_modified_date_time is not None:
        _params["maxLastModifiedDateTime"] = _SERIALIZER.query(
            "max_last_modified_date_time", max_last_modified_date_time, "iso-8601"
        )
    if skip_token is not None:
        _params["skipToken"] = _SERIALIZER.query("skip_token", skip_token, "str")
    _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")

    # Construct headers
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="GET", url=_url, params=_params, headers=_headers, **kwargs)


def build_prescriptions_get_cascade_delete_job_details_request(job_id: str, **kwargs: Any) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    api_version = kwargs.pop("api_version", _params.pop("api-version", "2022-11-01-preview"))  # type: str
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/prescriptions/cascade-delete/{jobId}"
    path_format_arguments = {
        "jobId": _SERIALIZER.url("job_id", job_id, "str"),
    }

    _url = _format_url_section(_url, **path_format_arguments)

    # Construct parameters
    _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")

    # Construct headers
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="GET", url=_url, params=_params, headers=_headers, **kwargs)


def build_prescriptions_create_cascade_delete_job_request(
    job_id: str, *, party_id: str, prescription_id: str, **kwargs: Any
) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    api_version = kwargs.pop("api_version", _params.pop("api-version", "2022-11-01-preview"))  # type: str
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/prescriptions/cascade-delete/{jobId}"
    path_format_arguments = {
        "jobId": _SERIALIZER.url("job_id", job_id, "str"),
    }

    _url = _format_url_section(_url, **path_format_arguments)

    # Construct parameters
    _params["partyId"] = _SERIALIZER.query("party_id", party_id, "str")
    _params["prescriptionId"] = _SERIALIZER.query("prescription_id", prescription_id, "str")
    _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")

    # Construct headers
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="PUT", url=_url, params=_params, headers=_headers, **kwargs)


def build_scenes_list_request(
    *,
    provider: str,
    party_id: str,
    boundary_id: str,
    source: str,
    start_date_time: Optional[datetime.datetime] = None,
    end_date_time: Optional[datetime.datetime] = None,
    max_cloud_coverage_percentage: float = 100,
    max_dark_pixel_coverage_percentage: float = 100,
    image_names: Optional[List[str]] = None,
    image_resolutions: Optional[List[float]] = None,
    image_formats: Optional[List[str]] = None,
    skip_token: Optional[str] = None,
    **kwargs: Any
) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    api_version = kwargs.pop("api_version", _params.pop("api-version", "2022-11-01-preview"))  # type: str
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/scenes"

    # Construct parameters
    _params["provider"] = _SERIALIZER.query("provider", provider, "str")
    _params["partyId"] = _SERIALIZER.query("party_id", party_id, "str")
    _params["boundaryId"] = _SERIALIZER.query("boundary_id", boundary_id, "str")
    _params["source"] = _SERIALIZER.query("source", source, "str")
    if start_date_time is not None:
        _params["startDateTime"] = _SERIALIZER.query("start_date_time", start_date_time, "iso-8601")
    if end_date_time is not None:
        _params["endDateTime"] = _SERIALIZER.query("end_date_time", end_date_time, "iso-8601")
    if max_cloud_coverage_percentage is not None:
        _params["maxCloudCoveragePercentage"] = _SERIALIZER.query(
            "max_cloud_coverage_percentage", max_cloud_coverage_percentage, "float", maximum=100, minimum=0
        )
    if max_dark_pixel_coverage_percentage is not None:
        _params["maxDarkPixelCoveragePercentage"] = _SERIALIZER.query(
            "max_dark_pixel_coverage_percentage", max_dark_pixel_coverage_percentage, "float", maximum=100, minimum=0
        )
    if image_names is not None:
        _params["imageNames"] = [
            _SERIALIZER.query("image_names", q, "str") if q is not None else "" for q in image_names
        ]
    if image_resolutions is not None:
        _params["imageResolutions"] = [
            _SERIALIZER.query("image_resolutions", q, "float") if q is not None else "" for q in image_resolutions
        ]
    if image_formats is not None:
        _params["imageFormats"] = [
            _SERIALIZER.query("image_formats", q, "str") if q is not None else "" for q in image_formats
        ]
    if skip_token is not None:
        _params["skipToken"] = _SERIALIZER.query("skip_token", skip_token, "str")
    _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")

    # Construct headers
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="GET", url=_url, params=_params, headers=_headers, **kwargs)


def build_scenes_download_request(*, file_path: str, **kwargs: Any) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    api_version = kwargs.pop("api_version", _params.pop("api-version", "2022-11-01-preview"))  # type: str
    accept = _headers.pop("Accept", "application/json, application/octet-stream")

    # Construct URL
    _url = "/scenes/downloadFiles"

    # Construct parameters
    _params["filePath"] = _SERIALIZER.query("file_path", file_path, "str")
    _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")

    # Construct headers
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="GET", url=_url, params=_params, headers=_headers, **kwargs)


def build_scenes_create_satellite_data_ingestion_job_request(job_id: str, **kwargs: Any) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    content_type = kwargs.pop("content_type", _headers.pop("Content-Type", None))  # type: Optional[str]
    api_version = kwargs.pop("api_version", _params.pop("api-version", "2022-11-01-preview"))  # type: str
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/scenes/satellite/ingest-data/{jobId}"
    path_format_arguments = {
        "jobId": _SERIALIZER.url("job_id", job_id, "str"),
    }

    _url = _format_url_section(_url, **path_format_arguments)

    # Construct parameters
    _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")

    # Construct headers
    if content_type is not None:
        _headers["Content-Type"] = _SERIALIZER.header("content_type", content_type, "str")
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="PUT", url=_url, params=_params, headers=_headers, **kwargs)


def build_scenes_get_satellite_data_ingestion_job_details_request(job_id: str, **kwargs: Any) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    api_version = kwargs.pop("api_version", _params.pop("api-version", "2022-11-01-preview"))  # type: str
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/scenes/satellite/ingest-data/{jobId}"
    path_format_arguments = {
        "jobId": _SERIALIZER.url("job_id", job_id, "str"),
    }

    _url = _format_url_section(_url, **path_format_arguments)

    # Construct parameters
    _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")

    # Construct headers
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="GET", url=_url, params=_params, headers=_headers, **kwargs)


def build_scenes_search_features_request(
    collection_id: str, *, maxpagesize: int = 10, skip: Optional[int] = None, **kwargs: Any
) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    content_type = kwargs.pop("content_type", _headers.pop("Content-Type", None))  # type: Optional[str]
    api_version = kwargs.pop("api_version", _params.pop("api-version", "2022-11-01-preview"))  # type: str
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/scenes/stac-collections/{collectionId}:search"
    path_format_arguments = {
        "collectionId": _SERIALIZER.url("collection_id", collection_id, "str"),
    }

    _url = _format_url_section(_url, **path_format_arguments)

    # Construct parameters
    if maxpagesize is not None:
        _params["maxpagesize"] = _SERIALIZER.query("maxpagesize", maxpagesize, "int", maximum=100, minimum=1)
    if skip is not None:
        _params["skip"] = _SERIALIZER.query("skip", skip, "int", maximum=2147483647, minimum=1)
    _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")

    # Construct headers
    if content_type is not None:
        _headers["Content-Type"] = _SERIALIZER.header("content_type", content_type, "str")
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="POST", url=_url, params=_params, headers=_headers, **kwargs)


def build_scenes_get_stac_feature_request(collection_id: str, feature_id: str, **kwargs: Any) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    api_version = kwargs.pop("api_version", _params.pop("api-version", "2022-11-01-preview"))  # type: str
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/scenes/stac-collections/{collectionId}/features/{featureId}"
    path_format_arguments = {
        "collectionId": _SERIALIZER.url("collection_id", collection_id, "str"),
        "featureId": _SERIALIZER.url("feature_id", feature_id, "str"),
    }

    _url = _format_url_section(_url, **path_format_arguments)

    # Construct parameters
    _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")

    # Construct headers
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="GET", url=_url, params=_params, headers=_headers, **kwargs)


def build_seasonal_fields_list_by_party_id_request(
    party_id: str,
    *,
    farm_ids: Optional[List[str]] = None,
    field_ids: Optional[List[str]] = None,
    season_ids: Optional[List[str]] = None,
    crop_product_ids: Optional[List[str]] = None,
    crop_ids: Optional[List[str]] = None,
    ids: Optional[List[str]] = None,
    names: Optional[List[str]] = None,
    property_filters: Optional[List[str]] = None,
    statuses: Optional[List[str]] = None,
    min_created_date_time: Optional[datetime.datetime] = None,
    max_created_date_time: Optional[datetime.datetime] = None,
    min_last_modified_date_time: Optional[datetime.datetime] = None,
    max_last_modified_date_time: Optional[datetime.datetime] = None,
    skip_token: Optional[str] = None,
    **kwargs: Any
) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    api_version = kwargs.pop("api_version", _params.pop("api-version", "2022-11-01-preview"))  # type: str
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/parties/{partyId}/seasonal-fields"
    path_format_arguments = {
        "partyId": _SERIALIZER.url("party_id", party_id, "str"),
    }

    _url = _format_url_section(_url, **path_format_arguments)

    # Construct parameters
    if farm_ids is not None:
        _params["farmIds"] = [_SERIALIZER.query("farm_ids", q, "str") if q is not None else "" for q in farm_ids]
    if field_ids is not None:
        _params["fieldIds"] = [_SERIALIZER.query("field_ids", q, "str") if q is not None else "" for q in field_ids]
    if season_ids is not None:
        _params["seasonIds"] = [_SERIALIZER.query("season_ids", q, "str") if q is not None else "" for q in season_ids]
    if crop_product_ids is not None:
        _params["cropProductIds"] = [
            _SERIALIZER.query("crop_product_ids", q, "str") if q is not None else "" for q in crop_product_ids
        ]
    if crop_ids is not None:
        _params["cropIds"] = [_SERIALIZER.query("crop_ids", q, "str") if q is not None else "" for q in crop_ids]
    if ids is not None:
        _params["ids"] = [_SERIALIZER.query("ids", q, "str") if q is not None else "" for q in ids]
    if names is not None:
        _params["names"] = [_SERIALIZER.query("names", q, "str") if q is not None else "" for q in names]
    if property_filters is not None:
        _params["propertyFilters"] = [
            _SERIALIZER.query("property_filters", q, "str") if q is not None else "" for q in property_filters
        ]
    if statuses is not None:
        _params["statuses"] = [_SERIALIZER.query("statuses", q, "str") if q is not None else "" for q in statuses]
    if min_created_date_time is not None:
        _params["minCreatedDateTime"] = _SERIALIZER.query("min_created_date_time", min_created_date_time, "iso-8601")
    if max_created_date_time is not None:
        _params["maxCreatedDateTime"] = _SERIALIZER.query("max_created_date_time", max_created_date_time, "iso-8601")
    if min_last_modified_date_time is not None:
        _params["minLastModifiedDateTime"] = _SERIALIZER.query(
            "min_last_modified_date_time", min_last_modified_date_time, "iso-8601"
        )
    if max_last_modified_date_time is not None:
        _params["maxLastModifiedDateTime"] = _SERIALIZER.query(
            "max_last_modified_date_time", max_last_modified_date_time, "iso-8601"
        )
    if skip_token is not None:
        _params["skipToken"] = _SERIALIZER.query("skip_token", skip_token, "str")
    _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")

    # Construct headers
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="GET", url=_url, params=_params, headers=_headers, **kwargs)


def build_seasonal_fields_get_request(party_id: str, seasonal_field_id: str, **kwargs: Any) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    api_version = kwargs.pop("api_version", _params.pop("api-version", "2022-11-01-preview"))  # type: str
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/parties/{partyId}/seasonal-fields/{seasonalFieldId}"
    path_format_arguments = {
        "partyId": _SERIALIZER.url("party_id", party_id, "str"),
        "seasonalFieldId": _SERIALIZER.url("seasonal_field_id", seasonal_field_id, "str"),
    }

    _url = _format_url_section(_url, **path_format_arguments)

    # Construct parameters
    _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")

    # Construct headers
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="GET", url=_url, params=_params, headers=_headers, **kwargs)


def build_seasonal_fields_create_or_update_request(party_id: str, seasonal_field_id: str, **kwargs: Any) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    content_type = kwargs.pop("content_type", _headers.pop("Content-Type", None))  # type: Optional[str]
    api_version = kwargs.pop("api_version", _params.pop("api-version", "2022-11-01-preview"))  # type: str
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/parties/{partyId}/seasonal-fields/{seasonalFieldId}"
    path_format_arguments = {
        "partyId": _SERIALIZER.url("party_id", party_id, "str"),
        "seasonalFieldId": _SERIALIZER.url("seasonal_field_id", seasonal_field_id, "str"),
    }

    _url = _format_url_section(_url, **path_format_arguments)

    # Construct parameters
    _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")

    # Construct headers
    if content_type is not None:
        _headers["Content-Type"] = _SERIALIZER.header("content_type", content_type, "str")
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="PATCH", url=_url, params=_params, headers=_headers, **kwargs)


def build_seasonal_fields_delete_request(party_id: str, seasonal_field_id: str, **kwargs: Any) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    api_version = kwargs.pop("api_version", _params.pop("api-version", "2022-11-01-preview"))  # type: str
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/parties/{partyId}/seasonal-fields/{seasonalFieldId}"
    path_format_arguments = {
        "partyId": _SERIALIZER.url("party_id", party_id, "str"),
        "seasonalFieldId": _SERIALIZER.url("seasonal_field_id", seasonal_field_id, "str"),
    }

    _url = _format_url_section(_url, **path_format_arguments)

    # Construct parameters
    _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")

    # Construct headers
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="DELETE", url=_url, params=_params, headers=_headers, **kwargs)


def build_seasonal_fields_list_request(
    *,
    farm_ids: Optional[List[str]] = None,
    field_ids: Optional[List[str]] = None,
    season_ids: Optional[List[str]] = None,
    crop_product_ids: Optional[List[str]] = None,
    crop_ids: Optional[List[str]] = None,
    ids: Optional[List[str]] = None,
    names: Optional[List[str]] = None,
    property_filters: Optional[List[str]] = None,
    statuses: Optional[List[str]] = None,
    min_created_date_time: Optional[datetime.datetime] = None,
    max_created_date_time: Optional[datetime.datetime] = None,
    min_last_modified_date_time: Optional[datetime.datetime] = None,
    max_last_modified_date_time: Optional[datetime.datetime] = None,
    skip_token: Optional[str] = None,
    **kwargs: Any
) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    api_version = kwargs.pop("api_version", _params.pop("api-version", "2022-11-01-preview"))  # type: str
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/seasonal-fields"

    # Construct parameters
    if farm_ids is not None:
        _params["farmIds"] = [_SERIALIZER.query("farm_ids", q, "str") if q is not None else "" for q in farm_ids]
    if field_ids is not None:
        _params["fieldIds"] = [_SERIALIZER.query("field_ids", q, "str") if q is not None else "" for q in field_ids]
    if season_ids is not None:
        _params["seasonIds"] = [_SERIALIZER.query("season_ids", q, "str") if q is not None else "" for q in season_ids]
    if crop_product_ids is not None:
        _params["cropProductIds"] = [
            _SERIALIZER.query("crop_product_ids", q, "str") if q is not None else "" for q in crop_product_ids
        ]
    if crop_ids is not None:
        _params["cropIds"] = [_SERIALIZER.query("crop_ids", q, "str") if q is not None else "" for q in crop_ids]
    if ids is not None:
        _params["ids"] = [_SERIALIZER.query("ids", q, "str") if q is not None else "" for q in ids]
    if names is not None:
        _params["names"] = [_SERIALIZER.query("names", q, "str") if q is not None else "" for q in names]
    if property_filters is not None:
        _params["propertyFilters"] = [
            _SERIALIZER.query("property_filters", q, "str") if q is not None else "" for q in property_filters
        ]
    if statuses is not None:
        _params["statuses"] = [_SERIALIZER.query("statuses", q, "str") if q is not None else "" for q in statuses]
    if min_created_date_time is not None:
        _params["minCreatedDateTime"] = _SERIALIZER.query("min_created_date_time", min_created_date_time, "iso-8601")
    if max_created_date_time is not None:
        _params["maxCreatedDateTime"] = _SERIALIZER.query("max_created_date_time", max_created_date_time, "iso-8601")
    if min_last_modified_date_time is not None:
        _params["minLastModifiedDateTime"] = _SERIALIZER.query(
            "min_last_modified_date_time", min_last_modified_date_time, "iso-8601"
        )
    if max_last_modified_date_time is not None:
        _params["maxLastModifiedDateTime"] = _SERIALIZER.query(
            "max_last_modified_date_time", max_last_modified_date_time, "iso-8601"
        )
    if skip_token is not None:
        _params["skipToken"] = _SERIALIZER.query("skip_token", skip_token, "str")
    _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")

    # Construct headers
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="GET", url=_url, params=_params, headers=_headers, **kwargs)


def build_seasonal_fields_get_cascade_delete_job_details_request(job_id: str, **kwargs: Any) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    api_version = kwargs.pop("api_version", _params.pop("api-version", "2022-11-01-preview"))  # type: str
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/seasonal-fields/cascade-delete/{jobId}"
    path_format_arguments = {
        "jobId": _SERIALIZER.url("job_id", job_id, "str"),
    }

    _url = _format_url_section(_url, **path_format_arguments)

    # Construct parameters
    _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")

    # Construct headers
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="GET", url=_url, params=_params, headers=_headers, **kwargs)


def build_seasonal_fields_create_cascade_delete_job_request(
    job_id: str, *, party_id: str, seasonal_field_id: str, **kwargs: Any
) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    api_version = kwargs.pop("api_version", _params.pop("api-version", "2022-11-01-preview"))  # type: str
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/seasonal-fields/cascade-delete/{jobId}"
    path_format_arguments = {
        "jobId": _SERIALIZER.url("job_id", job_id, "str"),
    }

    _url = _format_url_section(_url, **path_format_arguments)

    # Construct parameters
    _params["partyId"] = _SERIALIZER.query("party_id", party_id, "str")
    _params["seasonalFieldId"] = _SERIALIZER.query("seasonal_field_id", seasonal_field_id, "str")
    _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")

    # Construct headers
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="PUT", url=_url, params=_params, headers=_headers, **kwargs)


def build_seasons_list_request(
    *,
    min_start_date_time: Optional[datetime.datetime] = None,
    max_start_date_time: Optional[datetime.datetime] = None,
    min_end_date_time: Optional[datetime.datetime] = None,
    max_end_date_time: Optional[datetime.datetime] = None,
    years: Optional[List[int]] = None,
    ids: Optional[List[str]] = None,
    names: Optional[List[str]] = None,
    property_filters: Optional[List[str]] = None,
    statuses: Optional[List[str]] = None,
    min_created_date_time: Optional[datetime.datetime] = None,
    max_created_date_time: Optional[datetime.datetime] = None,
    min_last_modified_date_time: Optional[datetime.datetime] = None,
    max_last_modified_date_time: Optional[datetime.datetime] = None,
    skip_token: Optional[str] = None,
    **kwargs: Any
) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    api_version = kwargs.pop("api_version", _params.pop("api-version", "2022-11-01-preview"))  # type: str
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/seasons"

    # Construct parameters
    if min_start_date_time is not None:
        _params["minStartDateTime"] = _SERIALIZER.query("min_start_date_time", min_start_date_time, "iso-8601")
    if max_start_date_time is not None:
        _params["maxStartDateTime"] = _SERIALIZER.query("max_start_date_time", max_start_date_time, "iso-8601")
    if min_end_date_time is not None:
        _params["minEndDateTime"] = _SERIALIZER.query("min_end_date_time", min_end_date_time, "iso-8601")
    if max_end_date_time is not None:
        _params["maxEndDateTime"] = _SERIALIZER.query("max_end_date_time", max_end_date_time, "iso-8601")
    if years is not None:
        _params["years"] = [_SERIALIZER.query("years", q, "int") if q is not None else "" for q in years]
    if ids is not None:
        _params["ids"] = [_SERIALIZER.query("ids", q, "str") if q is not None else "" for q in ids]
    if names is not None:
        _params["names"] = [_SERIALIZER.query("names", q, "str") if q is not None else "" for q in names]
    if property_filters is not None:
        _params["propertyFilters"] = [
            _SERIALIZER.query("property_filters", q, "str") if q is not None else "" for q in property_filters
        ]
    if statuses is not None:
        _params["statuses"] = [_SERIALIZER.query("statuses", q, "str") if q is not None else "" for q in statuses]
    if min_created_date_time is not None:
        _params["minCreatedDateTime"] = _SERIALIZER.query("min_created_date_time", min_created_date_time, "iso-8601")
    if max_created_date_time is not None:
        _params["maxCreatedDateTime"] = _SERIALIZER.query("max_created_date_time", max_created_date_time, "iso-8601")
    if min_last_modified_date_time is not None:
        _params["minLastModifiedDateTime"] = _SERIALIZER.query(
            "min_last_modified_date_time", min_last_modified_date_time, "iso-8601"
        )
    if max_last_modified_date_time is not None:
        _params["maxLastModifiedDateTime"] = _SERIALIZER.query(
            "max_last_modified_date_time", max_last_modified_date_time, "iso-8601"
        )
    if skip_token is not None:
        _params["skipToken"] = _SERIALIZER.query("skip_token", skip_token, "str")
    _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")

    # Construct headers
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="GET", url=_url, params=_params, headers=_headers, **kwargs)


def build_seasons_get_request(season_id: str, **kwargs: Any) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    api_version = kwargs.pop("api_version", _params.pop("api-version", "2022-11-01-preview"))  # type: str
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/seasons/{seasonId}"
    path_format_arguments = {
        "seasonId": _SERIALIZER.url("season_id", season_id, "str"),
    }

    _url = _format_url_section(_url, **path_format_arguments)

    # Construct parameters
    _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")

    # Construct headers
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="GET", url=_url, params=_params, headers=_headers, **kwargs)


def build_seasons_create_or_update_request(season_id: str, **kwargs: Any) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    content_type = kwargs.pop("content_type", _headers.pop("Content-Type", None))  # type: Optional[str]
    api_version = kwargs.pop("api_version", _params.pop("api-version", "2022-11-01-preview"))  # type: str
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/seasons/{seasonId}"
    path_format_arguments = {
        "seasonId": _SERIALIZER.url("season_id", season_id, "str"),
    }

    _url = _format_url_section(_url, **path_format_arguments)

    # Construct parameters
    _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")

    # Construct headers
    if content_type is not None:
        _headers["Content-Type"] = _SERIALIZER.header("content_type", content_type, "str")
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="PATCH", url=_url, params=_params, headers=_headers, **kwargs)


def build_seasons_delete_request(season_id: str, **kwargs: Any) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    api_version = kwargs.pop("api_version", _params.pop("api-version", "2022-11-01-preview"))  # type: str
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/seasons/{seasonId}"
    path_format_arguments = {
        "seasonId": _SERIALIZER.url("season_id", season_id, "str"),
    }

    _url = _format_url_section(_url, **path_format_arguments)

    # Construct parameters
    _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")

    # Construct headers
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="DELETE", url=_url, params=_params, headers=_headers, **kwargs)


def build_sensor_data_models_list_request(
    sensor_partner_id: str,
    *,
    ids: Optional[List[str]] = None,
    names: Optional[List[str]] = None,
    property_filters: Optional[List[str]] = None,
    statuses: Optional[List[str]] = None,
    min_created_date_time: Optional[datetime.datetime] = None,
    max_created_date_time: Optional[datetime.datetime] = None,
    min_last_modified_date_time: Optional[datetime.datetime] = None,
    max_last_modified_date_time: Optional[datetime.datetime] = None,
    skip_token: Optional[str] = None,
    **kwargs: Any
) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    api_version = kwargs.pop("api_version", _params.pop("api-version", "2022-11-01-preview"))  # type: str
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/sensor-partners/{sensorPartnerId}/sensor-data-models"
    path_format_arguments = {
        "sensorPartnerId": _SERIALIZER.url("sensor_partner_id", sensor_partner_id, "str"),
    }

    _url = _format_url_section(_url, **path_format_arguments)

    # Construct parameters
    if ids is not None:
        _params["ids"] = [_SERIALIZER.query("ids", q, "str") if q is not None else "" for q in ids]
    if names is not None:
        _params["names"] = [_SERIALIZER.query("names", q, "str") if q is not None else "" for q in names]
    if property_filters is not None:
        _params["propertyFilters"] = [
            _SERIALIZER.query("property_filters", q, "str") if q is not None else "" for q in property_filters
        ]
    if statuses is not None:
        _params["statuses"] = [_SERIALIZER.query("statuses", q, "str") if q is not None else "" for q in statuses]
    if min_created_date_time is not None:
        _params["minCreatedDateTime"] = _SERIALIZER.query("min_created_date_time", min_created_date_time, "iso-8601")
    if max_created_date_time is not None:
        _params["maxCreatedDateTime"] = _SERIALIZER.query("max_created_date_time", max_created_date_time, "iso-8601")
    if min_last_modified_date_time is not None:
        _params["minLastModifiedDateTime"] = _SERIALIZER.query(
            "min_last_modified_date_time", min_last_modified_date_time, "iso-8601"
        )
    if max_last_modified_date_time is not None:
        _params["maxLastModifiedDateTime"] = _SERIALIZER.query(
            "max_last_modified_date_time", max_last_modified_date_time, "iso-8601"
        )
    if skip_token is not None:
        _params["skipToken"] = _SERIALIZER.query("skip_token", skip_token, "str")
    _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")

    # Construct headers
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="GET", url=_url, params=_params, headers=_headers, **kwargs)


def build_sensor_data_models_create_or_update_request(
    sensor_partner_id: str, sensor_data_model_id: str, **kwargs: Any
) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    content_type = kwargs.pop("content_type", _headers.pop("Content-Type", None))  # type: Optional[str]
    api_version = kwargs.pop("api_version", _params.pop("api-version", "2022-11-01-preview"))  # type: str
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/sensor-partners/{sensorPartnerId}/sensor-data-models/{sensorDataModelId}"
    path_format_arguments = {
        "sensorPartnerId": _SERIALIZER.url("sensor_partner_id", sensor_partner_id, "str"),
        "sensorDataModelId": _SERIALIZER.url("sensor_data_model_id", sensor_data_model_id, "str"),
    }

    _url = _format_url_section(_url, **path_format_arguments)

    # Construct parameters
    _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")

    # Construct headers
    if content_type is not None:
        _headers["Content-Type"] = _SERIALIZER.header("content_type", content_type, "str")
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="PATCH", url=_url, params=_params, headers=_headers, **kwargs)


def build_sensor_data_models_get_request(
    sensor_partner_id: str, sensor_data_model_id: str, **kwargs: Any
) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    api_version = kwargs.pop("api_version", _params.pop("api-version", "2022-11-01-preview"))  # type: str
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/sensor-partners/{sensorPartnerId}/sensor-data-models/{sensorDataModelId}"
    path_format_arguments = {
        "sensorPartnerId": _SERIALIZER.url("sensor_partner_id", sensor_partner_id, "str"),
        "sensorDataModelId": _SERIALIZER.url("sensor_data_model_id", sensor_data_model_id, "str"),
    }

    _url = _format_url_section(_url, **path_format_arguments)

    # Construct parameters
    _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")

    # Construct headers
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="GET", url=_url, params=_params, headers=_headers, **kwargs)


def build_sensor_data_models_delete_request(
    sensor_partner_id: str, sensor_data_model_id: str, **kwargs: Any
) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    api_version = kwargs.pop("api_version", _params.pop("api-version", "2022-11-01-preview"))  # type: str
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/sensor-partners/{sensorPartnerId}/sensor-data-models/{sensorDataModelId}"
    path_format_arguments = {
        "sensorPartnerId": _SERIALIZER.url("sensor_partner_id", sensor_partner_id, "str"),
        "sensorDataModelId": _SERIALIZER.url("sensor_data_model_id", sensor_data_model_id, "str"),
    }

    _url = _format_url_section(_url, **path_format_arguments)

    # Construct parameters
    _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")

    # Construct headers
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="DELETE", url=_url, params=_params, headers=_headers, **kwargs)


def build_sensor_events_list_request(
    *,
    sensor_id: str,
    sensor_partner_id: str,
    start_date_time: Optional[datetime.datetime] = None,
    end_date_time: Optional[datetime.datetime] = None,
    exclude_duplicate_events: bool = True,
    **kwargs: Any
) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    api_version = kwargs.pop("api_version", _params.pop("api-version", "2022-11-01-preview"))  # type: str
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/sensor-events"

    # Construct parameters
    _params["sensorId"] = _SERIALIZER.query("sensor_id", sensor_id, "str")
    _params["sensorPartnerId"] = _SERIALIZER.query("sensor_partner_id", sensor_partner_id, "str")
    if start_date_time is not None:
        _params["startDateTime"] = _SERIALIZER.query("start_date_time", start_date_time, "iso-8601")
    if end_date_time is not None:
        _params["endDateTime"] = _SERIALIZER.query("end_date_time", end_date_time, "iso-8601")
    if exclude_duplicate_events is not None:
        _params["excludeDuplicateEvents"] = _SERIALIZER.query(
            "exclude_duplicate_events", exclude_duplicate_events, "bool"
        )
    _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")

    # Construct headers
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="GET", url=_url, params=_params, headers=_headers, **kwargs)


def build_sensor_mappings_list_request(
    *,
    sensor_ids: Optional[List[str]] = None,
    sensor_partner_ids: Optional[List[str]] = None,
    party_ids: Optional[List[str]] = None,
    boundary_ids: Optional[List[str]] = None,
    ids: Optional[List[str]] = None,
    names: Optional[List[str]] = None,
    property_filters: Optional[List[str]] = None,
    statuses: Optional[List[str]] = None,
    min_created_date_time: Optional[datetime.datetime] = None,
    max_created_date_time: Optional[datetime.datetime] = None,
    min_last_modified_date_time: Optional[datetime.datetime] = None,
    max_last_modified_date_time: Optional[datetime.datetime] = None,
    skip_token: Optional[str] = None,
    **kwargs: Any
) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    api_version = kwargs.pop("api_version", _params.pop("api-version", "2022-11-01-preview"))  # type: str
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/sensor-mappings"

    # Construct parameters
    if sensor_ids is not None:
        _params["sensorIds"] = [_SERIALIZER.query("sensor_ids", q, "str") if q is not None else "" for q in sensor_ids]
    if sensor_partner_ids is not None:
        _params["sensorPartnerIds"] = [
            _SERIALIZER.query("sensor_partner_ids", q, "str") if q is not None else "" for q in sensor_partner_ids
        ]
    if party_ids is not None:
        _params["partyIds"] = [_SERIALIZER.query("party_ids", q, "str") if q is not None else "" for q in party_ids]
    if boundary_ids is not None:
        _params["boundaryIds"] = [
            _SERIALIZER.query("boundary_ids", q, "str") if q is not None else "" for q in boundary_ids
        ]
    if ids is not None:
        _params["ids"] = [_SERIALIZER.query("ids", q, "str") if q is not None else "" for q in ids]
    if names is not None:
        _params["names"] = [_SERIALIZER.query("names", q, "str") if q is not None else "" for q in names]
    if property_filters is not None:
        _params["propertyFilters"] = [
            _SERIALIZER.query("property_filters", q, "str") if q is not None else "" for q in property_filters
        ]
    if statuses is not None:
        _params["statuses"] = [_SERIALIZER.query("statuses", q, "str") if q is not None else "" for q in statuses]
    if min_created_date_time is not None:
        _params["minCreatedDateTime"] = _SERIALIZER.query("min_created_date_time", min_created_date_time, "iso-8601")
    if max_created_date_time is not None:
        _params["maxCreatedDateTime"] = _SERIALIZER.query("max_created_date_time", max_created_date_time, "iso-8601")
    if min_last_modified_date_time is not None:
        _params["minLastModifiedDateTime"] = _SERIALIZER.query(
            "min_last_modified_date_time", min_last_modified_date_time, "iso-8601"
        )
    if max_last_modified_date_time is not None:
        _params["maxLastModifiedDateTime"] = _SERIALIZER.query(
            "max_last_modified_date_time", max_last_modified_date_time, "iso-8601"
        )
    if skip_token is not None:
        _params["skipToken"] = _SERIALIZER.query("skip_token", skip_token, "str")
    _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")

    # Construct headers
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="GET", url=_url, params=_params, headers=_headers, **kwargs)


def build_sensor_mappings_create_or_update_request(sensor_mapping_id: str, **kwargs: Any) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    content_type = kwargs.pop("content_type", _headers.pop("Content-Type", None))  # type: Optional[str]
    api_version = kwargs.pop("api_version", _params.pop("api-version", "2022-11-01-preview"))  # type: str
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/sensor-mappings/{sensorMappingId}"
    path_format_arguments = {
        "sensorMappingId": _SERIALIZER.url("sensor_mapping_id", sensor_mapping_id, "str"),
    }

    _url = _format_url_section(_url, **path_format_arguments)

    # Construct parameters
    _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")

    # Construct headers
    if content_type is not None:
        _headers["Content-Type"] = _SERIALIZER.header("content_type", content_type, "str")
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="PATCH", url=_url, params=_params, headers=_headers, **kwargs)


def build_sensor_mappings_get_request(sensor_mapping_id: str, **kwargs: Any) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    api_version = kwargs.pop("api_version", _params.pop("api-version", "2022-11-01-preview"))  # type: str
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/sensor-mappings/{sensorMappingId}"
    path_format_arguments = {
        "sensorMappingId": _SERIALIZER.url("sensor_mapping_id", sensor_mapping_id, "str"),
    }

    _url = _format_url_section(_url, **path_format_arguments)

    # Construct parameters
    _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")

    # Construct headers
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="GET", url=_url, params=_params, headers=_headers, **kwargs)


def build_sensor_mappings_delete_request(sensor_mapping_id: str, **kwargs: Any) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    api_version = kwargs.pop("api_version", _params.pop("api-version", "2022-11-01-preview"))  # type: str
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/sensor-mappings/{sensorMappingId}"
    path_format_arguments = {
        "sensorMappingId": _SERIALIZER.url("sensor_mapping_id", sensor_mapping_id, "str"),
    }

    _url = _format_url_section(_url, **path_format_arguments)

    # Construct parameters
    _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")

    # Construct headers
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="DELETE", url=_url, params=_params, headers=_headers, **kwargs)


def build_sensor_partner_integrations_list_request(
    sensor_partner_id: str,
    *,
    integration_ids: Optional[List[str]] = None,
    party_ids: Optional[List[str]] = None,
    ids: Optional[List[str]] = None,
    names: Optional[List[str]] = None,
    property_filters: Optional[List[str]] = None,
    statuses: Optional[List[str]] = None,
    min_created_date_time: Optional[datetime.datetime] = None,
    max_created_date_time: Optional[datetime.datetime] = None,
    min_last_modified_date_time: Optional[datetime.datetime] = None,
    max_last_modified_date_time: Optional[datetime.datetime] = None,
    skip_token: Optional[str] = None,
    **kwargs: Any
) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    api_version = kwargs.pop("api_version", _params.pop("api-version", "2022-11-01-preview"))  # type: str
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/sensor-partners/{sensorPartnerId}/integrations"
    path_format_arguments = {
        "sensorPartnerId": _SERIALIZER.url("sensor_partner_id", sensor_partner_id, "str"),
    }

    _url = _format_url_section(_url, **path_format_arguments)

    # Construct parameters
    if integration_ids is not None:
        _params["integrationIds"] = [
            _SERIALIZER.query("integration_ids", q, "str") if q is not None else "" for q in integration_ids
        ]
    if party_ids is not None:
        _params["partyIds"] = [_SERIALIZER.query("party_ids", q, "str") if q is not None else "" for q in party_ids]
    if ids is not None:
        _params["ids"] = [_SERIALIZER.query("ids", q, "str") if q is not None else "" for q in ids]
    if names is not None:
        _params["names"] = [_SERIALIZER.query("names", q, "str") if q is not None else "" for q in names]
    if property_filters is not None:
        _params["propertyFilters"] = [
            _SERIALIZER.query("property_filters", q, "str") if q is not None else "" for q in property_filters
        ]
    if statuses is not None:
        _params["statuses"] = [_SERIALIZER.query("statuses", q, "str") if q is not None else "" for q in statuses]
    if min_created_date_time is not None:
        _params["minCreatedDateTime"] = _SERIALIZER.query("min_created_date_time", min_created_date_time, "iso-8601")
    if max_created_date_time is not None:
        _params["maxCreatedDateTime"] = _SERIALIZER.query("max_created_date_time", max_created_date_time, "iso-8601")
    if min_last_modified_date_time is not None:
        _params["minLastModifiedDateTime"] = _SERIALIZER.query(
            "min_last_modified_date_time", min_last_modified_date_time, "iso-8601"
        )
    if max_last_modified_date_time is not None:
        _params["maxLastModifiedDateTime"] = _SERIALIZER.query(
            "max_last_modified_date_time", max_last_modified_date_time, "iso-8601"
        )
    if skip_token is not None:
        _params["skipToken"] = _SERIALIZER.query("skip_token", skip_token, "str")
    _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")

    # Construct headers
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="GET", url=_url, params=_params, headers=_headers, **kwargs)


def build_sensor_partner_integrations_create_or_update_request(
    sensor_partner_id: str, integration_id: str, **kwargs: Any
) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    content_type = kwargs.pop("content_type", _headers.pop("Content-Type", None))  # type: Optional[str]
    api_version = kwargs.pop("api_version", _params.pop("api-version", "2022-11-01-preview"))  # type: str
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/sensor-partners/{sensorPartnerId}/integrations/{integrationId}"
    path_format_arguments = {
        "sensorPartnerId": _SERIALIZER.url("sensor_partner_id", sensor_partner_id, "str"),
        "integrationId": _SERIALIZER.url("integration_id", integration_id, "str"),
    }

    _url = _format_url_section(_url, **path_format_arguments)

    # Construct parameters
    _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")

    # Construct headers
    if content_type is not None:
        _headers["Content-Type"] = _SERIALIZER.header("content_type", content_type, "str")
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="PATCH", url=_url, params=_params, headers=_headers, **kwargs)


def build_sensor_partner_integrations_get_request(
    sensor_partner_id: str, integration_id: str, **kwargs: Any
) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    api_version = kwargs.pop("api_version", _params.pop("api-version", "2022-11-01-preview"))  # type: str
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/sensor-partners/{sensorPartnerId}/integrations/{integrationId}"
    path_format_arguments = {
        "sensorPartnerId": _SERIALIZER.url("sensor_partner_id", sensor_partner_id, "str"),
        "integrationId": _SERIALIZER.url("integration_id", integration_id, "str"),
    }

    _url = _format_url_section(_url, **path_format_arguments)

    # Construct parameters
    _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")

    # Construct headers
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="GET", url=_url, params=_params, headers=_headers, **kwargs)


def build_sensor_partner_integrations_delete_request(
    sensor_partner_id: str, integration_id: str, **kwargs: Any
) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    api_version = kwargs.pop("api_version", _params.pop("api-version", "2022-11-01-preview"))  # type: str
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/sensor-partners/{sensorPartnerId}/integrations/{integrationId}"
    path_format_arguments = {
        "sensorPartnerId": _SERIALIZER.url("sensor_partner_id", sensor_partner_id, "str"),
        "integrationId": _SERIALIZER.url("integration_id", integration_id, "str"),
    }

    _url = _format_url_section(_url, **path_format_arguments)

    # Construct parameters
    _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")

    # Construct headers
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="DELETE", url=_url, params=_params, headers=_headers, **kwargs)


def build_sensor_partner_integrations_check_consent_request(
    sensor_partner_id: str, integration_id: str, *, key: str, **kwargs: Any
) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    api_version = kwargs.pop("api_version", _params.pop("api-version", "2022-11-01-preview"))  # type: str
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/sensor-partners/{sensorPartnerId}/integrations/{integrationId}/:check-consent"
    path_format_arguments = {
        "sensorPartnerId": _SERIALIZER.url("sensor_partner_id", sensor_partner_id, "str"),
        "integrationId": _SERIALIZER.url("integration_id", integration_id, "str"),
    }

    _url = _format_url_section(_url, **path_format_arguments)

    # Construct parameters
    _params["key"] = _SERIALIZER.query("key", key, "str")
    _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")

    # Construct headers
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="POST", url=_url, params=_params, headers=_headers, **kwargs)


def build_sensor_partner_integrations_generate_consent_link_request(
    sensor_partner_id: str, integration_id: str, **kwargs: Any
) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    api_version = kwargs.pop("api_version", _params.pop("api-version", "2022-11-01-preview"))  # type: str
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/sensor-partners/{sensorPartnerId}/integrations/{integrationId}/:generate-consent-link"
    path_format_arguments = {
        "sensorPartnerId": _SERIALIZER.url("sensor_partner_id", sensor_partner_id, "str"),
        "integrationId": _SERIALIZER.url("integration_id", integration_id, "str"),
    }

    _url = _format_url_section(_url, **path_format_arguments)

    # Construct parameters
    _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")

    # Construct headers
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="POST", url=_url, params=_params, headers=_headers, **kwargs)


def build_sensors_list_request(
    sensor_partner_id: str,
    *,
    sensor_data_model_ids: Optional[List[str]] = None,
    sensor_mapping_ids: Optional[List[str]] = None,
    device_ids: Optional[List[str]] = None,
    ids: Optional[List[str]] = None,
    names: Optional[List[str]] = None,
    property_filters: Optional[List[str]] = None,
    statuses: Optional[List[str]] = None,
    min_created_date_time: Optional[datetime.datetime] = None,
    max_created_date_time: Optional[datetime.datetime] = None,
    min_last_modified_date_time: Optional[datetime.datetime] = None,
    max_last_modified_date_time: Optional[datetime.datetime] = None,
    skip_token: Optional[str] = None,
    **kwargs: Any
) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    api_version = kwargs.pop("api_version", _params.pop("api-version", "2022-11-01-preview"))  # type: str
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/sensor-partners/{sensorPartnerId}/sensors"
    path_format_arguments = {
        "sensorPartnerId": _SERIALIZER.url("sensor_partner_id", sensor_partner_id, "str"),
    }

    _url = _format_url_section(_url, **path_format_arguments)

    # Construct parameters
    if sensor_data_model_ids is not None:
        _params["sensorDataModelIds"] = [
            _SERIALIZER.query("sensor_data_model_ids", q, "str") if q is not None else "" for q in sensor_data_model_ids
        ]
    if sensor_mapping_ids is not None:
        _params["sensorMappingIds"] = [
            _SERIALIZER.query("sensor_mapping_ids", q, "str") if q is not None else "" for q in sensor_mapping_ids
        ]
    if device_ids is not None:
        _params["deviceIds"] = [_SERIALIZER.query("device_ids", q, "str") if q is not None else "" for q in device_ids]
    if ids is not None:
        _params["ids"] = [_SERIALIZER.query("ids", q, "str") if q is not None else "" for q in ids]
    if names is not None:
        _params["names"] = [_SERIALIZER.query("names", q, "str") if q is not None else "" for q in names]
    if property_filters is not None:
        _params["propertyFilters"] = [
            _SERIALIZER.query("property_filters", q, "str") if q is not None else "" for q in property_filters
        ]
    if statuses is not None:
        _params["statuses"] = [_SERIALIZER.query("statuses", q, "str") if q is not None else "" for q in statuses]
    if min_created_date_time is not None:
        _params["minCreatedDateTime"] = _SERIALIZER.query("min_created_date_time", min_created_date_time, "iso-8601")
    if max_created_date_time is not None:
        _params["maxCreatedDateTime"] = _SERIALIZER.query("max_created_date_time", max_created_date_time, "iso-8601")
    if min_last_modified_date_time is not None:
        _params["minLastModifiedDateTime"] = _SERIALIZER.query(
            "min_last_modified_date_time", min_last_modified_date_time, "iso-8601"
        )
    if max_last_modified_date_time is not None:
        _params["maxLastModifiedDateTime"] = _SERIALIZER.query(
            "max_last_modified_date_time", max_last_modified_date_time, "iso-8601"
        )
    if skip_token is not None:
        _params["skipToken"] = _SERIALIZER.query("skip_token", skip_token, "str")
    _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")

    # Construct headers
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="GET", url=_url, params=_params, headers=_headers, **kwargs)


def build_sensors_create_or_update_request(sensor_partner_id: str, sensor_id: str, **kwargs: Any) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    content_type = kwargs.pop("content_type", _headers.pop("Content-Type", None))  # type: Optional[str]
    api_version = kwargs.pop("api_version", _params.pop("api-version", "2022-11-01-preview"))  # type: str
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/sensor-partners/{sensorPartnerId}/sensors/{sensorId}"
    path_format_arguments = {
        "sensorPartnerId": _SERIALIZER.url("sensor_partner_id", sensor_partner_id, "str"),
        "sensorId": _SERIALIZER.url("sensor_id", sensor_id, "str"),
    }

    _url = _format_url_section(_url, **path_format_arguments)

    # Construct parameters
    _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")

    # Construct headers
    if content_type is not None:
        _headers["Content-Type"] = _SERIALIZER.header("content_type", content_type, "str")
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="PATCH", url=_url, params=_params, headers=_headers, **kwargs)


def build_sensors_get_request(sensor_partner_id: str, sensor_id: str, **kwargs: Any) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    api_version = kwargs.pop("api_version", _params.pop("api-version", "2022-11-01-preview"))  # type: str
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/sensor-partners/{sensorPartnerId}/sensors/{sensorId}"
    path_format_arguments = {
        "sensorPartnerId": _SERIALIZER.url("sensor_partner_id", sensor_partner_id, "str"),
        "sensorId": _SERIALIZER.url("sensor_id", sensor_id, "str"),
    }

    _url = _format_url_section(_url, **path_format_arguments)

    # Construct parameters
    _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")

    # Construct headers
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="GET", url=_url, params=_params, headers=_headers, **kwargs)


def build_sensors_delete_request(sensor_partner_id: str, sensor_id: str, **kwargs: Any) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    api_version = kwargs.pop("api_version", _params.pop("api-version", "2022-11-01-preview"))  # type: str
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/sensor-partners/{sensorPartnerId}/sensors/{sensorId}"
    path_format_arguments = {
        "sensorPartnerId": _SERIALIZER.url("sensor_partner_id", sensor_partner_id, "str"),
        "sensorId": _SERIALIZER.url("sensor_id", sensor_id, "str"),
    }

    _url = _format_url_section(_url, **path_format_arguments)

    # Construct parameters
    _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")

    # Construct headers
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="DELETE", url=_url, params=_params, headers=_headers, **kwargs)


def build_sensors_get_connection_string_request(sensor_partner_id: str, sensor_id: str, **kwargs: Any) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    api_version = kwargs.pop("api_version", _params.pop("api-version", "2022-11-01-preview"))  # type: str
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/sensor-partners/{sensorPartnerId}/sensors/{sensorId}/connection-strings"
    path_format_arguments = {
        "sensorPartnerId": _SERIALIZER.url("sensor_partner_id", sensor_partner_id, "str"),
        "sensorId": _SERIALIZER.url("sensor_id", sensor_id, "str"),
    }

    _url = _format_url_section(_url, **path_format_arguments)

    # Construct parameters
    _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")

    # Construct headers
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="GET", url=_url, params=_params, headers=_headers, **kwargs)


def build_sensors_renew_connection_string_request(sensor_partner_id: str, sensor_id: str, **kwargs: Any) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    content_type = kwargs.pop("content_type", _headers.pop("Content-Type", None))  # type: Optional[str]
    api_version = kwargs.pop("api_version", _params.pop("api-version", "2022-11-01-preview"))  # type: str
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/sensor-partners/{sensorPartnerId}/sensors/{sensorId}/connection-strings/:renew"
    path_format_arguments = {
        "sensorPartnerId": _SERIALIZER.url("sensor_partner_id", sensor_partner_id, "str"),
        "sensorId": _SERIALIZER.url("sensor_id", sensor_id, "str"),
    }

    _url = _format_url_section(_url, **path_format_arguments)

    # Construct parameters
    _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")

    # Construct headers
    if content_type is not None:
        _headers["Content-Type"] = _SERIALIZER.header("content_type", content_type, "str")
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="POST", url=_url, params=_params, headers=_headers, **kwargs)


def build_solution_inference_cancel_request(solution_id: str, **kwargs: Any) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    content_type = kwargs.pop("content_type", _headers.pop("Content-Type", None))  # type: Optional[str]
    api_version = kwargs.pop("api_version", _params.pop("api-version", "2022-11-01-preview"))  # type: str
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/solutions/{solutionId}:cancel"
    path_format_arguments = {
        "solutionId": _SERIALIZER.url("solution_id", solution_id, "str", pattern=r"^[a-zA-Z]{3,50}[.][a-zA-Z]{3,100}$"),
    }

    _url = _format_url_section(_url, **path_format_arguments)

    # Construct parameters
    _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")

    # Construct headers
    if content_type is not None:
        _headers["Content-Type"] = _SERIALIZER.header("content_type", content_type, "str")
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="POST", url=_url, params=_params, headers=_headers, **kwargs)


def build_solution_inference_create_or_update_request(solution_id: str, **kwargs: Any) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    content_type = kwargs.pop("content_type", _headers.pop("Content-Type", None))  # type: Optional[str]
    api_version = kwargs.pop("api_version", _params.pop("api-version", "2022-11-01-preview"))  # type: str
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/solutions/{solutionId}:create"
    path_format_arguments = {
        "solutionId": _SERIALIZER.url("solution_id", solution_id, "str", pattern=r"^[a-zA-Z]{3,50}[.][a-zA-Z]{3,100}$"),
    }

    _url = _format_url_section(_url, **path_format_arguments)

    # Construct parameters
    _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")

    # Construct headers
    if content_type is not None:
        _headers["Content-Type"] = _SERIALIZER.header("content_type", content_type, "str")
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="POST", url=_url, params=_params, headers=_headers, **kwargs)


def build_solution_inference_fetch_request(solution_id: str, **kwargs: Any) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    content_type = kwargs.pop("content_type", _headers.pop("Content-Type", None))  # type: Optional[str]
    api_version = kwargs.pop("api_version", _params.pop("api-version", "2022-11-01-preview"))  # type: str
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/solutions/{solutionId}:fetch"
    path_format_arguments = {
        "solutionId": _SERIALIZER.url("solution_id", solution_id, "str", pattern=r"^[a-zA-Z]{3,50}[.][a-zA-Z]{3,100}$"),
    }

    _url = _format_url_section(_url, **path_format_arguments)

    # Construct parameters
    _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")

    # Construct headers
    if content_type is not None:
        _headers["Content-Type"] = _SERIALIZER.header("content_type", content_type, "str")
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="POST", url=_url, params=_params, headers=_headers, **kwargs)


def build_tillage_data_list_by_party_id_request(
    party_id: str,
    *,
    min_tillage_depth: Optional[float] = None,
    max_tillage_depth: Optional[float] = None,
    min_tillage_pressure: Optional[float] = None,
    max_tillage_pressure: Optional[float] = None,
    sources: Optional[List[str]] = None,
    associated_boundary_ids: Optional[List[str]] = None,
    min_operation_start_date_time: Optional[datetime.datetime] = None,
    max_operation_start_date_time: Optional[datetime.datetime] = None,
    min_operation_end_date_time: Optional[datetime.datetime] = None,
    max_operation_end_date_time: Optional[datetime.datetime] = None,
    min_operation_modified_date_time: Optional[datetime.datetime] = None,
    max_operation_modified_date_time: Optional[datetime.datetime] = None,
    min_area: Optional[float] = None,
    max_area: Optional[float] = None,
    ids: Optional[List[str]] = None,
    names: Optional[List[str]] = None,
    property_filters: Optional[List[str]] = None,
    statuses: Optional[List[str]] = None,
    min_created_date_time: Optional[datetime.datetime] = None,
    max_created_date_time: Optional[datetime.datetime] = None,
    min_last_modified_date_time: Optional[datetime.datetime] = None,
    max_last_modified_date_time: Optional[datetime.datetime] = None,
    skip_token: Optional[str] = None,
    **kwargs: Any
) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    api_version = kwargs.pop("api_version", _params.pop("api-version", "2022-11-01-preview"))  # type: str
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/parties/{partyId}/tillage-data"
    path_format_arguments = {
        "partyId": _SERIALIZER.url("party_id", party_id, "str"),
    }

    _url = _format_url_section(_url, **path_format_arguments)

    # Construct parameters
    if min_tillage_depth is not None:
        _params["minTillageDepth"] = _SERIALIZER.query("min_tillage_depth", min_tillage_depth, "float")
    if max_tillage_depth is not None:
        _params["maxTillageDepth"] = _SERIALIZER.query("max_tillage_depth", max_tillage_depth, "float")
    if min_tillage_pressure is not None:
        _params["minTillagePressure"] = _SERIALIZER.query("min_tillage_pressure", min_tillage_pressure, "float")
    if max_tillage_pressure is not None:
        _params["maxTillagePressure"] = _SERIALIZER.query("max_tillage_pressure", max_tillage_pressure, "float")
    if sources is not None:
        _params["sources"] = [_SERIALIZER.query("sources", q, "str") if q is not None else "" for q in sources]
    if associated_boundary_ids is not None:
        _params["associatedBoundaryIds"] = [
            _SERIALIZER.query("associated_boundary_ids", q, "str") if q is not None else ""
            for q in associated_boundary_ids
        ]
    if min_operation_start_date_time is not None:
        _params["minOperationStartDateTime"] = _SERIALIZER.query(
            "min_operation_start_date_time", min_operation_start_date_time, "iso-8601"
        )
    if max_operation_start_date_time is not None:
        _params["maxOperationStartDateTime"] = _SERIALIZER.query(
            "max_operation_start_date_time", max_operation_start_date_time, "iso-8601"
        )
    if min_operation_end_date_time is not None:
        _params["minOperationEndDateTime"] = _SERIALIZER.query(
            "min_operation_end_date_time", min_operation_end_date_time, "iso-8601"
        )
    if max_operation_end_date_time is not None:
        _params["maxOperationEndDateTime"] = _SERIALIZER.query(
            "max_operation_end_date_time", max_operation_end_date_time, "iso-8601"
        )
    if min_operation_modified_date_time is not None:
        _params["minOperationModifiedDateTime"] = _SERIALIZER.query(
            "min_operation_modified_date_time", min_operation_modified_date_time, "iso-8601"
        )
    if max_operation_modified_date_time is not None:
        _params["maxOperationModifiedDateTime"] = _SERIALIZER.query(
            "max_operation_modified_date_time", max_operation_modified_date_time, "iso-8601"
        )
    if min_area is not None:
        _params["minArea"] = _SERIALIZER.query("min_area", min_area, "float")
    if max_area is not None:
        _params["maxArea"] = _SERIALIZER.query("max_area", max_area, "float")
    if ids is not None:
        _params["ids"] = [_SERIALIZER.query("ids", q, "str") if q is not None else "" for q in ids]
    if names is not None:
        _params["names"] = [_SERIALIZER.query("names", q, "str") if q is not None else "" for q in names]
    if property_filters is not None:
        _params["propertyFilters"] = [
            _SERIALIZER.query("property_filters", q, "str") if q is not None else "" for q in property_filters
        ]
    if statuses is not None:
        _params["statuses"] = [_SERIALIZER.query("statuses", q, "str") if q is not None else "" for q in statuses]
    if min_created_date_time is not None:
        _params["minCreatedDateTime"] = _SERIALIZER.query("min_created_date_time", min_created_date_time, "iso-8601")
    if max_created_date_time is not None:
        _params["maxCreatedDateTime"] = _SERIALIZER.query("max_created_date_time", max_created_date_time, "iso-8601")
    if min_last_modified_date_time is not None:
        _params["minLastModifiedDateTime"] = _SERIALIZER.query(
            "min_last_modified_date_time", min_last_modified_date_time, "iso-8601"
        )
    if max_last_modified_date_time is not None:
        _params["maxLastModifiedDateTime"] = _SERIALIZER.query(
            "max_last_modified_date_time", max_last_modified_date_time, "iso-8601"
        )
    if skip_token is not None:
        _params["skipToken"] = _SERIALIZER.query("skip_token", skip_token, "str")
    _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")

    # Construct headers
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="GET", url=_url, params=_params, headers=_headers, **kwargs)


def build_tillage_data_get_request(party_id: str, tillage_data_id: str, **kwargs: Any) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    api_version = kwargs.pop("api_version", _params.pop("api-version", "2022-11-01-preview"))  # type: str
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/parties/{partyId}/tillage-data/{tillageDataId}"
    path_format_arguments = {
        "partyId": _SERIALIZER.url("party_id", party_id, "str"),
        "tillageDataId": _SERIALIZER.url("tillage_data_id", tillage_data_id, "str"),
    }

    _url = _format_url_section(_url, **path_format_arguments)

    # Construct parameters
    _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")

    # Construct headers
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="GET", url=_url, params=_params, headers=_headers, **kwargs)


def build_tillage_data_create_or_update_request(party_id: str, tillage_data_id: str, **kwargs: Any) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    content_type = kwargs.pop("content_type", _headers.pop("Content-Type", None))  # type: Optional[str]
    api_version = kwargs.pop("api_version", _params.pop("api-version", "2022-11-01-preview"))  # type: str
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/parties/{partyId}/tillage-data/{tillageDataId}"
    path_format_arguments = {
        "partyId": _SERIALIZER.url("party_id", party_id, "str"),
        "tillageDataId": _SERIALIZER.url("tillage_data_id", tillage_data_id, "str"),
    }

    _url = _format_url_section(_url, **path_format_arguments)

    # Construct parameters
    _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")

    # Construct headers
    if content_type is not None:
        _headers["Content-Type"] = _SERIALIZER.header("content_type", content_type, "str")
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="PATCH", url=_url, params=_params, headers=_headers, **kwargs)


def build_tillage_data_delete_request(party_id: str, tillage_data_id: str, **kwargs: Any) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    api_version = kwargs.pop("api_version", _params.pop("api-version", "2022-11-01-preview"))  # type: str
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/parties/{partyId}/tillage-data/{tillageDataId}"
    path_format_arguments = {
        "partyId": _SERIALIZER.url("party_id", party_id, "str"),
        "tillageDataId": _SERIALIZER.url("tillage_data_id", tillage_data_id, "str"),
    }

    _url = _format_url_section(_url, **path_format_arguments)

    # Construct parameters
    _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")

    # Construct headers
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="DELETE", url=_url, params=_params, headers=_headers, **kwargs)


def build_tillage_data_list_request(
    *,
    min_tillage_depth: Optional[float] = None,
    max_tillage_depth: Optional[float] = None,
    min_tillage_pressure: Optional[float] = None,
    max_tillage_pressure: Optional[float] = None,
    sources: Optional[List[str]] = None,
    associated_boundary_ids: Optional[List[str]] = None,
    min_operation_start_date_time: Optional[datetime.datetime] = None,
    max_operation_start_date_time: Optional[datetime.datetime] = None,
    min_operation_end_date_time: Optional[datetime.datetime] = None,
    max_operation_end_date_time: Optional[datetime.datetime] = None,
    min_operation_modified_date_time: Optional[datetime.datetime] = None,
    max_operation_modified_date_time: Optional[datetime.datetime] = None,
    min_area: Optional[float] = None,
    max_area: Optional[float] = None,
    ids: Optional[List[str]] = None,
    names: Optional[List[str]] = None,
    property_filters: Optional[List[str]] = None,
    statuses: Optional[List[str]] = None,
    min_created_date_time: Optional[datetime.datetime] = None,
    max_created_date_time: Optional[datetime.datetime] = None,
    min_last_modified_date_time: Optional[datetime.datetime] = None,
    max_last_modified_date_time: Optional[datetime.datetime] = None,
    skip_token: Optional[str] = None,
    **kwargs: Any
) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    api_version = kwargs.pop("api_version", _params.pop("api-version", "2022-11-01-preview"))  # type: str
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/tillage-data"

    # Construct parameters
    if min_tillage_depth is not None:
        _params["minTillageDepth"] = _SERIALIZER.query("min_tillage_depth", min_tillage_depth, "float")
    if max_tillage_depth is not None:
        _params["maxTillageDepth"] = _SERIALIZER.query("max_tillage_depth", max_tillage_depth, "float")
    if min_tillage_pressure is not None:
        _params["minTillagePressure"] = _SERIALIZER.query("min_tillage_pressure", min_tillage_pressure, "float")
    if max_tillage_pressure is not None:
        _params["maxTillagePressure"] = _SERIALIZER.query("max_tillage_pressure", max_tillage_pressure, "float")
    if sources is not None:
        _params["sources"] = [_SERIALIZER.query("sources", q, "str") if q is not None else "" for q in sources]
    if associated_boundary_ids is not None:
        _params["associatedBoundaryIds"] = [
            _SERIALIZER.query("associated_boundary_ids", q, "str") if q is not None else ""
            for q in associated_boundary_ids
        ]
    if min_operation_start_date_time is not None:
        _params["minOperationStartDateTime"] = _SERIALIZER.query(
            "min_operation_start_date_time", min_operation_start_date_time, "iso-8601"
        )
    if max_operation_start_date_time is not None:
        _params["maxOperationStartDateTime"] = _SERIALIZER.query(
            "max_operation_start_date_time", max_operation_start_date_time, "iso-8601"
        )
    if min_operation_end_date_time is not None:
        _params["minOperationEndDateTime"] = _SERIALIZER.query(
            "min_operation_end_date_time", min_operation_end_date_time, "iso-8601"
        )
    if max_operation_end_date_time is not None:
        _params["maxOperationEndDateTime"] = _SERIALIZER.query(
            "max_operation_end_date_time", max_operation_end_date_time, "iso-8601"
        )
    if min_operation_modified_date_time is not None:
        _params["minOperationModifiedDateTime"] = _SERIALIZER.query(
            "min_operation_modified_date_time", min_operation_modified_date_time, "iso-8601"
        )
    if max_operation_modified_date_time is not None:
        _params["maxOperationModifiedDateTime"] = _SERIALIZER.query(
            "max_operation_modified_date_time", max_operation_modified_date_time, "iso-8601"
        )
    if min_area is not None:
        _params["minArea"] = _SERIALIZER.query("min_area", min_area, "float")
    if max_area is not None:
        _params["maxArea"] = _SERIALIZER.query("max_area", max_area, "float")
    if ids is not None:
        _params["ids"] = [_SERIALIZER.query("ids", q, "str") if q is not None else "" for q in ids]
    if names is not None:
        _params["names"] = [_SERIALIZER.query("names", q, "str") if q is not None else "" for q in names]
    if property_filters is not None:
        _params["propertyFilters"] = [
            _SERIALIZER.query("property_filters", q, "str") if q is not None else "" for q in property_filters
        ]
    if statuses is not None:
        _params["statuses"] = [_SERIALIZER.query("statuses", q, "str") if q is not None else "" for q in statuses]
    if min_created_date_time is not None:
        _params["minCreatedDateTime"] = _SERIALIZER.query("min_created_date_time", min_created_date_time, "iso-8601")
    if max_created_date_time is not None:
        _params["maxCreatedDateTime"] = _SERIALIZER.query("max_created_date_time", max_created_date_time, "iso-8601")
    if min_last_modified_date_time is not None:
        _params["minLastModifiedDateTime"] = _SERIALIZER.query(
            "min_last_modified_date_time", min_last_modified_date_time, "iso-8601"
        )
    if max_last_modified_date_time is not None:
        _params["maxLastModifiedDateTime"] = _SERIALIZER.query(
            "max_last_modified_date_time", max_last_modified_date_time, "iso-8601"
        )
    if skip_token is not None:
        _params["skipToken"] = _SERIALIZER.query("skip_token", skip_token, "str")
    _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")

    # Construct headers
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="GET", url=_url, params=_params, headers=_headers, **kwargs)


def build_tillage_data_create_cascade_delete_job_request(
    job_id: str, *, party_id: str, tillage_data_id: str, **kwargs: Any
) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    api_version = kwargs.pop("api_version", _params.pop("api-version", "2022-11-01-preview"))  # type: str
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/tillage-data/cascade-delete/{jobId}"
    path_format_arguments = {
        "jobId": _SERIALIZER.url("job_id", job_id, "str"),
    }

    _url = _format_url_section(_url, **path_format_arguments)

    # Construct parameters
    _params["partyId"] = _SERIALIZER.query("party_id", party_id, "str")
    _params["tillageDataId"] = _SERIALIZER.query("tillage_data_id", tillage_data_id, "str")
    _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")

    # Construct headers
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="PUT", url=_url, params=_params, headers=_headers, **kwargs)


def build_tillage_data_get_cascade_delete_job_details_request(job_id: str, **kwargs: Any) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    api_version = kwargs.pop("api_version", _params.pop("api-version", "2022-11-01-preview"))  # type: str
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/tillage-data/cascade-delete/{jobId}"
    path_format_arguments = {
        "jobId": _SERIALIZER.url("job_id", job_id, "str"),
    }

    _url = _format_url_section(_url, **path_format_arguments)

    # Construct parameters
    _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")

    # Construct headers
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="GET", url=_url, params=_params, headers=_headers, **kwargs)


def build_weather_list_request(
    *,
    party_id: str,
    boundary_id: str,
    extension_id: str,
    weather_data_type: str,
    granularity: str,
    start_date_time: Optional[datetime.datetime] = None,
    end_date_time: Optional[datetime.datetime] = None,
    skip_token: Optional[str] = None,
    **kwargs: Any
) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    api_version = kwargs.pop("api_version", _params.pop("api-version", "2022-11-01-preview"))  # type: str
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/weather"

    # Construct parameters
    _params["partyId"] = _SERIALIZER.query("party_id", party_id, "str")
    _params["boundaryId"] = _SERIALIZER.query("boundary_id", boundary_id, "str")
    _params["extensionId"] = _SERIALIZER.query(
        "extension_id", extension_id, "str", pattern=r"^[a-zA-Z]{3,50}[.][a-zA-Z]{3,100}$"
    )
    _params["weatherDataType"] = _SERIALIZER.query("weather_data_type", weather_data_type, "str", max_length=50)
    _params["granularity"] = _SERIALIZER.query("granularity", granularity, "str", max_length=50)
    if start_date_time is not None:
        _params["startDateTime"] = _SERIALIZER.query("start_date_time", start_date_time, "iso-8601")
    if end_date_time is not None:
        _params["endDateTime"] = _SERIALIZER.query("end_date_time", end_date_time, "iso-8601")
    if skip_token is not None:
        _params["skipToken"] = _SERIALIZER.query("skip_token", skip_token, "str")
    _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")

    # Construct headers
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="GET", url=_url, params=_params, headers=_headers, **kwargs)


def build_weather_get_data_delete_job_details_request(job_id: str, **kwargs: Any) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    api_version = kwargs.pop("api_version", _params.pop("api-version", "2022-11-01-preview"))  # type: str
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/weather/delete-data/{jobId}"
    path_format_arguments = {
        "jobId": _SERIALIZER.url("job_id", job_id, "str"),
    }

    _url = _format_url_section(_url, **path_format_arguments)

    # Construct parameters
    _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")

    # Construct headers
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="GET", url=_url, params=_params, headers=_headers, **kwargs)


def build_weather_create_data_delete_job_request(job_id: str, **kwargs: Any) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    content_type = kwargs.pop("content_type", _headers.pop("Content-Type", None))  # type: Optional[str]
    api_version = kwargs.pop("api_version", _params.pop("api-version", "2022-11-01-preview"))  # type: str
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/weather/delete-data/{jobId}"
    path_format_arguments = {
        "jobId": _SERIALIZER.url("job_id", job_id, "str"),
    }

    _url = _format_url_section(_url, **path_format_arguments)

    # Construct parameters
    _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")

    # Construct headers
    if content_type is not None:
        _headers["Content-Type"] = _SERIALIZER.header("content_type", content_type, "str")
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="PUT", url=_url, params=_params, headers=_headers, **kwargs)


def build_weather_get_data_ingestion_job_details_request(job_id: str, **kwargs: Any) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    api_version = kwargs.pop("api_version", _params.pop("api-version", "2022-11-01-preview"))  # type: str
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/weather/ingest-data/{jobId}"
    path_format_arguments = {
        "jobId": _SERIALIZER.url("job_id", job_id, "str"),
    }

    _url = _format_url_section(_url, **path_format_arguments)

    # Construct parameters
    _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")

    # Construct headers
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="GET", url=_url, params=_params, headers=_headers, **kwargs)


def build_weather_create_data_ingestion_job_request(job_id: str, **kwargs: Any) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    content_type = kwargs.pop("content_type", _headers.pop("Content-Type", None))  # type: Optional[str]
    api_version = kwargs.pop("api_version", _params.pop("api-version", "2022-11-01-preview"))  # type: str
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/weather/ingest-data/{jobId}"
    path_format_arguments = {
        "jobId": _SERIALIZER.url("job_id", job_id, "str"),
    }

    _url = _format_url_section(_url, **path_format_arguments)

    # Construct parameters
    _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")

    # Construct headers
    if content_type is not None:
        _headers["Content-Type"] = _SERIALIZER.header("content_type", content_type, "str")
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="PUT", url=_url, params=_params, headers=_headers, **kwargs)


def build_weather_data_get_request(**kwargs: Any) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    content_type = kwargs.pop("content_type", _headers.pop("Content-Type", None))  # type: Optional[str]
    api_version = kwargs.pop("api_version", _params.pop("api-version", "2022-11-01-preview"))  # type: str
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/weather-data/:fetch"

    # Construct parameters
    _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")

    # Construct headers
    if content_type is not None:
        _headers["Content-Type"] = _SERIALIZER.header("content_type", content_type, "str")
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="POST", url=_url, params=_params, headers=_headers, **kwargs)


def build_zones_list_by_party_id_request(
    party_id: str,
    *,
    types: Optional[List[str]] = None,
    management_zone_ids: Optional[List[str]] = None,
    sources: Optional[List[str]] = None,
    ids: Optional[List[str]] = None,
    names: Optional[List[str]] = None,
    property_filters: Optional[List[str]] = None,
    statuses: Optional[List[str]] = None,
    min_created_date_time: Optional[datetime.datetime] = None,
    max_created_date_time: Optional[datetime.datetime] = None,
    min_last_modified_date_time: Optional[datetime.datetime] = None,
    max_last_modified_date_time: Optional[datetime.datetime] = None,
    skip_token: Optional[str] = None,
    **kwargs: Any
) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    api_version = kwargs.pop("api_version", _params.pop("api-version", "2022-11-01-preview"))  # type: str
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/parties/{partyId}/zones"
    path_format_arguments = {
        "partyId": _SERIALIZER.url("party_id", party_id, "str"),
    }

    _url = _format_url_section(_url, **path_format_arguments)

    # Construct parameters
    if types is not None:
        _params["types"] = [_SERIALIZER.query("types", q, "str") if q is not None else "" for q in types]
    if management_zone_ids is not None:
        _params["managementZoneIds"] = [
            _SERIALIZER.query("management_zone_ids", q, "str") if q is not None else "" for q in management_zone_ids
        ]
    if sources is not None:
        _params["sources"] = [_SERIALIZER.query("sources", q, "str") if q is not None else "" for q in sources]
    if ids is not None:
        _params["ids"] = [_SERIALIZER.query("ids", q, "str") if q is not None else "" for q in ids]
    if names is not None:
        _params["names"] = [_SERIALIZER.query("names", q, "str") if q is not None else "" for q in names]
    if property_filters is not None:
        _params["propertyFilters"] = [
            _SERIALIZER.query("property_filters", q, "str") if q is not None else "" for q in property_filters
        ]
    if statuses is not None:
        _params["statuses"] = [_SERIALIZER.query("statuses", q, "str") if q is not None else "" for q in statuses]
    if min_created_date_time is not None:
        _params["minCreatedDateTime"] = _SERIALIZER.query("min_created_date_time", min_created_date_time, "iso-8601")
    if max_created_date_time is not None:
        _params["maxCreatedDateTime"] = _SERIALIZER.query("max_created_date_time", max_created_date_time, "iso-8601")
    if min_last_modified_date_time is not None:
        _params["minLastModifiedDateTime"] = _SERIALIZER.query(
            "min_last_modified_date_time", min_last_modified_date_time, "iso-8601"
        )
    if max_last_modified_date_time is not None:
        _params["maxLastModifiedDateTime"] = _SERIALIZER.query(
            "max_last_modified_date_time", max_last_modified_date_time, "iso-8601"
        )
    if skip_token is not None:
        _params["skipToken"] = _SERIALIZER.query("skip_token", skip_token, "str")
    _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")

    # Construct headers
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="GET", url=_url, params=_params, headers=_headers, **kwargs)


def build_zones_get_request(party_id: str, zone_id: str, **kwargs: Any) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    api_version = kwargs.pop("api_version", _params.pop("api-version", "2022-11-01-preview"))  # type: str
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/parties/{partyId}/zones/{zoneId}"
    path_format_arguments = {
        "partyId": _SERIALIZER.url("party_id", party_id, "str"),
        "zoneId": _SERIALIZER.url("zone_id", zone_id, "str"),
    }

    _url = _format_url_section(_url, **path_format_arguments)

    # Construct parameters
    _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")

    # Construct headers
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="GET", url=_url, params=_params, headers=_headers, **kwargs)


def build_zones_create_or_update_request(party_id: str, zone_id: str, **kwargs: Any) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    content_type = kwargs.pop("content_type", _headers.pop("Content-Type", None))  # type: Optional[str]
    api_version = kwargs.pop("api_version", _params.pop("api-version", "2022-11-01-preview"))  # type: str
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/parties/{partyId}/zones/{zoneId}"
    path_format_arguments = {
        "partyId": _SERIALIZER.url("party_id", party_id, "str"),
        "zoneId": _SERIALIZER.url("zone_id", zone_id, "str"),
    }

    _url = _format_url_section(_url, **path_format_arguments)

    # Construct parameters
    _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")

    # Construct headers
    if content_type is not None:
        _headers["Content-Type"] = _SERIALIZER.header("content_type", content_type, "str")
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="PATCH", url=_url, params=_params, headers=_headers, **kwargs)


def build_zones_delete_request(party_id: str, zone_id: str, **kwargs: Any) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    api_version = kwargs.pop("api_version", _params.pop("api-version", "2022-11-01-preview"))  # type: str
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/parties/{partyId}/zones/{zoneId}"
    path_format_arguments = {
        "partyId": _SERIALIZER.url("party_id", party_id, "str"),
        "zoneId": _SERIALIZER.url("zone_id", zone_id, "str"),
    }

    _url = _format_url_section(_url, **path_format_arguments)

    # Construct parameters
    _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")

    # Construct headers
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="DELETE", url=_url, params=_params, headers=_headers, **kwargs)


def build_zones_list_request(
    *,
    types: Optional[List[str]] = None,
    management_zone_ids: Optional[List[str]] = None,
    sources: Optional[List[str]] = None,
    ids: Optional[List[str]] = None,
    names: Optional[List[str]] = None,
    property_filters: Optional[List[str]] = None,
    statuses: Optional[List[str]] = None,
    min_created_date_time: Optional[datetime.datetime] = None,
    max_created_date_time: Optional[datetime.datetime] = None,
    min_last_modified_date_time: Optional[datetime.datetime] = None,
    max_last_modified_date_time: Optional[datetime.datetime] = None,
    skip_token: Optional[str] = None,
    **kwargs: Any
) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    api_version = kwargs.pop("api_version", _params.pop("api-version", "2022-11-01-preview"))  # type: str
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/zones"

    # Construct parameters
    if types is not None:
        _params["types"] = [_SERIALIZER.query("types", q, "str") if q is not None else "" for q in types]
    if management_zone_ids is not None:
        _params["managementZoneIds"] = [
            _SERIALIZER.query("management_zone_ids", q, "str") if q is not None else "" for q in management_zone_ids
        ]
    if sources is not None:
        _params["sources"] = [_SERIALIZER.query("sources", q, "str") if q is not None else "" for q in sources]
    if ids is not None:
        _params["ids"] = [_SERIALIZER.query("ids", q, "str") if q is not None else "" for q in ids]
    if names is not None:
        _params["names"] = [_SERIALIZER.query("names", q, "str") if q is not None else "" for q in names]
    if property_filters is not None:
        _params["propertyFilters"] = [
            _SERIALIZER.query("property_filters", q, "str") if q is not None else "" for q in property_filters
        ]
    if statuses is not None:
        _params["statuses"] = [_SERIALIZER.query("statuses", q, "str") if q is not None else "" for q in statuses]
    if min_created_date_time is not None:
        _params["minCreatedDateTime"] = _SERIALIZER.query("min_created_date_time", min_created_date_time, "iso-8601")
    if max_created_date_time is not None:
        _params["maxCreatedDateTime"] = _SERIALIZER.query("max_created_date_time", max_created_date_time, "iso-8601")
    if min_last_modified_date_time is not None:
        _params["minLastModifiedDateTime"] = _SERIALIZER.query(
            "min_last_modified_date_time", min_last_modified_date_time, "iso-8601"
        )
    if max_last_modified_date_time is not None:
        _params["maxLastModifiedDateTime"] = _SERIALIZER.query(
            "max_last_modified_date_time", max_last_modified_date_time, "iso-8601"
        )
    if skip_token is not None:
        _params["skipToken"] = _SERIALIZER.query("skip_token", skip_token, "str")
    _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")

    # Construct headers
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="GET", url=_url, params=_params, headers=_headers, **kwargs)


def build_zones_get_cascade_delete_job_details_request(job_id: str, **kwargs: Any) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    api_version = kwargs.pop("api_version", _params.pop("api-version", "2022-11-01-preview"))  # type: str
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/zones/cascade-delete/{jobId}"
    path_format_arguments = {
        "jobId": _SERIALIZER.url("job_id", job_id, "str"),
    }

    _url = _format_url_section(_url, **path_format_arguments)

    # Construct parameters
    _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")

    # Construct headers
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="GET", url=_url, params=_params, headers=_headers, **kwargs)


def build_zones_create_cascade_delete_job_request(
    job_id: str, *, party_id: str, zone_id: str, **kwargs: Any
) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    api_version = kwargs.pop("api_version", _params.pop("api-version", "2022-11-01-preview"))  # type: str
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/zones/cascade-delete/{jobId}"
    path_format_arguments = {
        "jobId": _SERIALIZER.url("job_id", job_id, "str"),
    }

    _url = _format_url_section(_url, **path_format_arguments)

    # Construct parameters
    _params["partyId"] = _SERIALIZER.query("party_id", party_id, "str")
    _params["zoneId"] = _SERIALIZER.query("zone_id", zone_id, "str")
    _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")

    # Construct headers
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="PUT", url=_url, params=_params, headers=_headers, **kwargs)


class ApplicationDataOperations:
    """
    .. warning::
        **DO NOT** instantiate this class directly.

        Instead, you should access the following operations through
        :class:`~azure.agrifood.farming.FarmBeatsClient`'s
        :attr:`application_data` attribute.
    """

    def __init__(self, *args, **kwargs):
        input_args = list(args)
        self._client = input_args.pop(0) if input_args else kwargs.pop("client")
        self._config = input_args.pop(0) if input_args else kwargs.pop("config")
        self._serialize = input_args.pop(0) if input_args else kwargs.pop("serializer")
        self._deserialize = input_args.pop(0) if input_args else kwargs.pop("deserializer")

    @distributed_trace
    def list(
        self,
        *,
        min_avg_material: Optional[float] = None,
        max_avg_material: Optional[float] = None,
        min_total_material: Optional[float] = None,
        max_total_material: Optional[float] = None,
        sources: Optional[List[str]] = None,
        associated_boundary_ids: Optional[List[str]] = None,
        min_operation_start_date_time: Optional[datetime.datetime] = None,
        max_operation_start_date_time: Optional[datetime.datetime] = None,
        min_operation_end_date_time: Optional[datetime.datetime] = None,
        max_operation_end_date_time: Optional[datetime.datetime] = None,
        min_operation_modified_date_time: Optional[datetime.datetime] = None,
        max_operation_modified_date_time: Optional[datetime.datetime] = None,
        min_area: Optional[float] = None,
        max_area: Optional[float] = None,
        ids: Optional[List[str]] = None,
        names: Optional[List[str]] = None,
        property_filters: Optional[List[str]] = None,
        statuses: Optional[List[str]] = None,
        min_created_date_time: Optional[datetime.datetime] = None,
        max_created_date_time: Optional[datetime.datetime] = None,
        min_last_modified_date_time: Optional[datetime.datetime] = None,
        max_last_modified_date_time: Optional[datetime.datetime] = None,
        skip_token: Optional[str] = None,
        **kwargs: Any
    ) -> Iterable[JSON]:
        """Returns a paginated list of application data resources across all parties.

        :keyword min_avg_material: Minimum average amount of material applied during the application
         (inclusive). Default value is None.
        :paramtype min_avg_material: float
        :keyword max_avg_material: Maximum average amount of material applied during the application
         (inclusive). Default value is None.
        :paramtype max_avg_material: float
        :keyword min_total_material: Minimum total amount of material applied during the application
         (inclusive). Default value is None.
        :paramtype min_total_material: float
        :keyword max_total_material: Maximum total amount of material applied during the application
         (inclusive). Default value is None.
        :paramtype max_total_material: float
        :keyword sources: Sources of the operation data. Default value is None.
        :paramtype sources: list[str]
        :keyword associated_boundary_ids: Boundary IDs associated with operation data. Default value is
         None.
        :paramtype associated_boundary_ids: list[str]
        :keyword min_operation_start_date_time: Minimum start date-time of the operation data, sample
         format: yyyy-MM-ddTHH:mm:ssZ (inclusive). Default value is None.
        :paramtype min_operation_start_date_time: ~datetime.datetime
        :keyword max_operation_start_date_time: Maximum start date-time of the operation data, sample
         format: yyyy-MM-ddTHH:mm:ssZ (inclusive). Default value is None.
        :paramtype max_operation_start_date_time: ~datetime.datetime
        :keyword min_operation_end_date_time: Minimum end date-time of the operation data, sample
         format: yyyy-MM-ddTHH:mm:ssZ (inclusive). Default value is None.
        :paramtype min_operation_end_date_time: ~datetime.datetime
        :keyword max_operation_end_date_time: Maximum end date-time of the operation data, sample
         format: yyyy-MM-ddTHH:mm:ssZ (inclusive). Default value is None.
        :paramtype max_operation_end_date_time: ~datetime.datetime
        :keyword min_operation_modified_date_time: Minimum modified date-time of the operation data,
         sample format: yyyy-MM-ddTHH:mm:ssZ (inclusive). Default value is None.
        :paramtype min_operation_modified_date_time: ~datetime.datetime
        :keyword max_operation_modified_date_time: Maximum modified date-time of the operation data,
         sample format: yyyy-MM-ddTHH:mm:ssZ (inclusive). Default value is None.
        :paramtype max_operation_modified_date_time: ~datetime.datetime
        :keyword min_area: Minimum area for which operation was applied (inclusive). Default value is
         None.
        :paramtype min_area: float
        :keyword max_area: Maximum area for which operation was applied (inclusive). Default value is
         None.
        :paramtype max_area: float
        :keyword ids: Ids of the resource. Default value is None.
        :paramtype ids: list[str]
        :keyword names: Names of the resource. Default value is None.
        :paramtype names: list[str]
        :keyword property_filters: Filters on key-value pairs within the Properties object.
         eg. "{testKey} eq {testValue}". Default value is None.
        :paramtype property_filters: list[str]
        :keyword statuses: Statuses of the resource. Default value is None.
        :paramtype statuses: list[str]
        :keyword min_created_date_time: Minimum creation date of resource (inclusive). Default value is
         None.
        :paramtype min_created_date_time: ~datetime.datetime
        :keyword max_created_date_time: Maximum creation date of resource (inclusive). Default value is
         None.
        :paramtype max_created_date_time: ~datetime.datetime
        :keyword min_last_modified_date_time: Minimum last modified date of resource (inclusive).
         Default value is None.
        :paramtype min_last_modified_date_time: ~datetime.datetime
        :keyword max_last_modified_date_time: Maximum last modified date of resource (inclusive).
         Default value is None.
        :paramtype max_last_modified_date_time: ~datetime.datetime
        :keyword skip_token: Skip token for getting next set of results. Default value is None.
        :paramtype skip_token: str
        :return: An iterator like instance of JSON object
        :rtype: ~azure.core.paging.ItemPaged[JSON]
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "applicationProductDetails": [
                        {
                            "avgMaterial": {
                                "unit": "str",  # Optional. Data unit.
                                "value": 0.0  # Optional. Data value.
                            },
                            "isCarrier": False,  # Optional. Default value is False. A
                              flag indicating whether product is a carrier for a tank mix.
                            "productName": "str",  # Optional. Name of the product
                              applied.
                            "totalMaterial": {
                                "unit": "str",  # Optional. Data unit.
                                "value": 0.0  # Optional. Data value.
                            }
                        }
                    ],
                    "area": {
                        "unit": "str",  # Optional. Data unit.
                        "value": 0.0  # Optional. Data value.
                    },
                    "associatedBoundaryId": "str",  # Optional. Optional boundary ID of the field
                      for which operation was applied.
                    "attachmentsLink": "str",  # Optional. Link for attachments.
                    "avgMaterial": {
                        "unit": "str",  # Optional. Data unit.
                        "value": 0.0  # Optional. Data value.
                    },
                    "createdBy": "str",  # Optional. Created by user/tenant id.
                    "createdDateTime": "2020-02-20 00:00:00",  # Optional. Date-time when
                      resource was created, sample format: yyyy-MM-ddTHH:mm:ssZ.
                    "description": "str",  # Optional. Textual description of the resource.
                    "eTag": "str",  # Optional. The ETag value to implement optimistic
                      concurrency.
                    "id": "str",  # Optional. Unique resource ID.
                    "modifiedBy": "str",  # Optional. Modified by user/tenant id.
                    "modifiedDateTime": "2020-02-20 00:00:00",  # Optional. Date-time when
                      resource was last modified, sample format: yyyy-MM-ddTHH:mm:ssZ.
                    "name": "str",  # Optional. Name to identify resource.
                    "operationEndDateTime": "2020-02-20 00:00:00",  # Optional. End date-time of
                      the operation data, sample format: yyyy-MM-ddTHH:mm:ssZ.
                    "operationModifiedDateTime": "2020-02-20 00:00:00",  # Optional. Modified
                      date-time of the operation data, sample format: yyyy-MM-ddTHH:mm:ssZ."nNote: this
                      will be specified by the source provider itself.
                    "operationStartDateTime": "2020-02-20 00:00:00",  # Optional. Start date-time
                      of the operation data, sample format: yyyy-MM-ddTHH:mm:ssZ.
                    "partyId": "str",  # Optional. Party ID which belongs to the operation data.
                    "properties": {
                        "str": {}  # Optional. A collection of key value pairs that belongs
                          to the resource."nEach pair must not have a key greater than 50
                          characters"nand must not have a value greater than 150 characters."nNote: A
                          maximum of 25 key value pairs can be provided for a resource and only
                          string,"nnumeral and datetime (yyyy-MM-ddTHH:mm:ssZ) values are supported.
                    },
                    "source": "str",  # Optional. Source of the resource.
                    "status": "str",  # Optional. Status of the resource.
                    "totalMaterial": {
                        "unit": "str",  # Optional. Data unit.
                        "value": 0.0  # Optional. Data value.
                    }
                }
        """
        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls = kwargs.pop("cls", None)  # type: ClsType[JSON]

        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        def prepare_request(next_link=None):
            if not next_link:

                request = build_application_data_list_request(
                    min_avg_material=min_avg_material,
                    max_avg_material=max_avg_material,
                    min_total_material=min_total_material,
                    max_total_material=max_total_material,
                    sources=sources,
                    associated_boundary_ids=associated_boundary_ids,
                    min_operation_start_date_time=min_operation_start_date_time,
                    max_operation_start_date_time=max_operation_start_date_time,
                    min_operation_end_date_time=min_operation_end_date_time,
                    max_operation_end_date_time=max_operation_end_date_time,
                    min_operation_modified_date_time=min_operation_modified_date_time,
                    max_operation_modified_date_time=max_operation_modified_date_time,
                    min_area=min_area,
                    max_area=max_area,
                    ids=ids,
                    names=names,
                    property_filters=property_filters,
                    statuses=statuses,
                    min_created_date_time=min_created_date_time,
                    max_created_date_time=max_created_date_time,
                    min_last_modified_date_time=min_last_modified_date_time,
                    max_last_modified_date_time=max_last_modified_date_time,
                    skip_token=skip_token,
                    api_version=self._config.api_version,
                    headers=_headers,
                    params=_params,
                )
                request.url = self._client.format_url(request.url)  # type: ignore

            else:
                # make call to next link with the client's api-version
                _parsed_next_link = urlparse(next_link)
                _next_request_params = case_insensitive_dict(parse_qs(_parsed_next_link.query))
                _next_request_params["api-version"] = self._config.api_version
                request = HttpRequest("GET", urljoin(next_link, _parsed_next_link.path), params=_next_request_params)
                request.url = self._client.format_url(request.url)  # type: ignore

            return request

        def extract_data(pipeline_response):
            deserialized = pipeline_response.http_response.json()
            list_of_elem = deserialized["value"]
            if cls:
                list_of_elem = cls(list_of_elem)
            return deserialized.get("nextLink", None), iter(list_of_elem)

        def get_next(next_link=None):
            request = prepare_request(next_link)

            pipeline_response = self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
                request, stream=False, **kwargs
            )
            response = pipeline_response.http_response

            if response.status_code not in [200]:
                map_error(status_code=response.status_code, response=response, error_map=error_map)
                raise HttpResponseError(response=response)

            return pipeline_response

        return ItemPaged(get_next, extract_data)

    def _create_cascade_delete_job_initial(
        self, job_id: str, *, party_id: str, application_data_id: str, **kwargs: Any
    ) -> JSON:
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls = kwargs.pop("cls", None)  # type: ClsType[JSON]

        request = build_application_data_create_cascade_delete_job_request(
            job_id=job_id,
            party_id=party_id,
            application_data_id=application_data_id,
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        request.url = self._client.format_url(request.url)  # type: ignore

        pipeline_response = self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
            request, stream=False, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [202]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if response.content:
            deserialized = response.json()
        else:
            deserialized = None

        if cls:
            return cls(pipeline_response, cast(JSON, deserialized), {})

        return cast(JSON, deserialized)

    @distributed_trace
    def begin_create_cascade_delete_job(
        self, job_id: str, *, party_id: str, application_data_id: str, **kwargs: Any
    ) -> LROPoller[JSON]:
        """Create cascade delete job for application data resource.

        :param job_id: Job Id supplied by end user. Required.
        :type job_id: str
        :keyword party_id: Id of the party. Required.
        :paramtype party_id: str
        :keyword application_data_id: Id of the application data. Required.
        :paramtype application_data_id: str
        :keyword str continuation_token: A continuation token to restart a poller from a saved state.
        :keyword polling: By default, your polling method will be LROBasePolling. Pass in False for
         this operation to not poll, or pass in your own initialized polling object for a personal
         polling strategy.
        :paramtype polling: bool or ~azure.core.polling.PollingMethod
        :keyword int polling_interval: Default waiting time between two polls for LRO operations if no
         Retry-After header is present.
        :return: An instance of LROPoller that returns JSON object
        :rtype: ~azure.core.polling.LROPoller[JSON]
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 202
                response == {
                    "partyId": "str",  # Party Id. Required.
                    "resourceId": "str",  # The id of the resource. Required.
                    "resourceType": "str",  # The type of the resource. Required.
                    "createdDateTime": "2020-02-20 00:00:00",  # Optional. Job created at
                      dateTime. Sample format: yyyy-MM-ddTHH:mm:ssZ.
                    "durationInSeconds": 0.0,  # Optional. Duration of the job in seconds.
                    "endTime": "2020-02-20 00:00:00",  # Optional. Job end time when available.
                      Sample format: yyyy-MM-ddTHH:mm:ssZ.
                    "errorCode": "str",  # Optional. Error Code when job failed.
                    "id": "str",  # Optional. Unique job id.
                    "lastActionDateTime": "2020-02-20 00:00:00",  # Optional. Job was last acted
                      upon at dateTime. Sample format: yyyy-MM-ddTHH:mm:ssZ.
                    "message": "str",  # Optional. Status message to capture more details of the
                      job.
                    "startTime": "2020-02-20 00:00:00",  # Optional. Job start time when
                      available. Sample format: yyyy-MM-ddTHH:mm:ssZ.
                    "status": "str"  # Optional. Status of the job."nPossible values: 'Waiting',
                      'Running', 'Succeeded', 'Failed', 'Cancelled'. Known values are: "Waiting",
                      "Running", "Succeeded", "Failed", and "Cancelled".
                }
        """
        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls = kwargs.pop("cls", None)  # type: ClsType[JSON]
        polling = kwargs.pop("polling", True)  # type: Union[bool, PollingMethod]
        lro_delay = kwargs.pop("polling_interval", self._config.polling_interval)
        cont_token = kwargs.pop("continuation_token", None)  # type: Optional[str]
        if cont_token is None:
            raw_result = self._create_cascade_delete_job_initial(  # type: ignore
                job_id=job_id,
                party_id=party_id,
                application_data_id=application_data_id,
                cls=lambda x, y, z: x,
                headers=_headers,
                params=_params,
                **kwargs
            )
        kwargs.pop("error_map", None)

        def get_long_running_output(pipeline_response):
            response = pipeline_response.http_response
            if response.content:
                deserialized = response.json()
            else:
                deserialized = None
            if cls:
                return cls(pipeline_response, deserialized, {})
            return deserialized

        if polling is True:
            polling_method = cast(
                PollingMethod, LROBasePolling(lro_delay, lro_options={"final-state-via": "location"}, **kwargs)
            )  # type: PollingMethod
        elif polling is False:
            polling_method = cast(PollingMethod, NoPolling())
        else:
            polling_method = polling
        if cont_token:
            return LROPoller.from_continuation_token(
                polling_method=polling_method,
                continuation_token=cont_token,
                client=self._client,
                deserialization_callback=get_long_running_output,
            )
        return LROPoller(self._client, raw_result, get_long_running_output, polling_method)

    @distributed_trace
    def get_cascade_delete_job_details(self, job_id: str, **kwargs: Any) -> JSON:
        """Get cascade delete job for application data resource.

        :param job_id: Id of the job. Required.
        :type job_id: str
        :return: JSON object
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "partyId": "str",  # Party Id. Required.
                    "resourceId": "str",  # The id of the resource. Required.
                    "resourceType": "str",  # The type of the resource. Required.
                    "createdDateTime": "2020-02-20 00:00:00",  # Optional. Job created at
                      dateTime. Sample format: yyyy-MM-ddTHH:mm:ssZ.
                    "durationInSeconds": 0.0,  # Optional. Duration of the job in seconds.
                    "endTime": "2020-02-20 00:00:00",  # Optional. Job end time when available.
                      Sample format: yyyy-MM-ddTHH:mm:ssZ.
                    "errorCode": "str",  # Optional. Error Code when job failed.
                    "id": "str",  # Optional. Unique job id.
                    "lastActionDateTime": "2020-02-20 00:00:00",  # Optional. Job was last acted
                      upon at dateTime. Sample format: yyyy-MM-ddTHH:mm:ssZ.
                    "message": "str",  # Optional. Status message to capture more details of the
                      job.
                    "startTime": "2020-02-20 00:00:00",  # Optional. Job start time when
                      available. Sample format: yyyy-MM-ddTHH:mm:ssZ.
                    "status": "str"  # Optional. Status of the job."nPossible values: 'Waiting',
                      'Running', 'Succeeded', 'Failed', 'Cancelled'. Known values are: "Waiting",
                      "Running", "Succeeded", "Failed", and "Cancelled".
                }
        """
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls = kwargs.pop("cls", None)  # type: ClsType[JSON]

        request = build_application_data_get_cascade_delete_job_details_request(
            job_id=job_id,
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        request.url = self._client.format_url(request.url)  # type: ignore

        pipeline_response = self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
            request, stream=False, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if response.content:
            deserialized = response.json()
        else:
            deserialized = None

        if cls:
            return cls(pipeline_response, cast(JSON, deserialized), {})

        return cast(JSON, deserialized)

    @distributed_trace
    def list_by_party_id(
        self,
        party_id: str,
        *,
        min_avg_material: Optional[float] = None,
        max_avg_material: Optional[float] = None,
        min_total_material: Optional[float] = None,
        max_total_material: Optional[float] = None,
        sources: Optional[List[str]] = None,
        associated_boundary_ids: Optional[List[str]] = None,
        min_operation_start_date_time: Optional[datetime.datetime] = None,
        max_operation_start_date_time: Optional[datetime.datetime] = None,
        min_operation_end_date_time: Optional[datetime.datetime] = None,
        max_operation_end_date_time: Optional[datetime.datetime] = None,
        min_operation_modified_date_time: Optional[datetime.datetime] = None,
        max_operation_modified_date_time: Optional[datetime.datetime] = None,
        min_area: Optional[float] = None,
        max_area: Optional[float] = None,
        ids: Optional[List[str]] = None,
        names: Optional[List[str]] = None,
        property_filters: Optional[List[str]] = None,
        statuses: Optional[List[str]] = None,
        min_created_date_time: Optional[datetime.datetime] = None,
        max_created_date_time: Optional[datetime.datetime] = None,
        min_last_modified_date_time: Optional[datetime.datetime] = None,
        max_last_modified_date_time: Optional[datetime.datetime] = None,
        skip_token: Optional[str] = None,
        **kwargs: Any
    ) -> Iterable[JSON]:
        """Returns a paginated list of application data resources under a particular party.

        :param party_id: ID of the associated party. Required.
        :type party_id: str
        :keyword min_avg_material: Minimum average amount of material applied during the application
         (inclusive). Default value is None.
        :paramtype min_avg_material: float
        :keyword max_avg_material: Maximum average amount of material applied during the application
         (inclusive). Default value is None.
        :paramtype max_avg_material: float
        :keyword min_total_material: Minimum total amount of material applied during the application
         (inclusive). Default value is None.
        :paramtype min_total_material: float
        :keyword max_total_material: Maximum total amount of material applied during the application
         (inclusive). Default value is None.
        :paramtype max_total_material: float
        :keyword sources: Sources of the operation data. Default value is None.
        :paramtype sources: list[str]
        :keyword associated_boundary_ids: Boundary IDs associated with operation data. Default value is
         None.
        :paramtype associated_boundary_ids: list[str]
        :keyword min_operation_start_date_time: Minimum start date-time of the operation data, sample
         format: yyyy-MM-ddTHH:mm:ssZ (inclusive). Default value is None.
        :paramtype min_operation_start_date_time: ~datetime.datetime
        :keyword max_operation_start_date_time: Maximum start date-time of the operation data, sample
         format: yyyy-MM-ddTHH:mm:ssZ (inclusive). Default value is None.
        :paramtype max_operation_start_date_time: ~datetime.datetime
        :keyword min_operation_end_date_time: Minimum end date-time of the operation data, sample
         format: yyyy-MM-ddTHH:mm:ssZ (inclusive). Default value is None.
        :paramtype min_operation_end_date_time: ~datetime.datetime
        :keyword max_operation_end_date_time: Maximum end date-time of the operation data, sample
         format: yyyy-MM-ddTHH:mm:ssZ (inclusive). Default value is None.
        :paramtype max_operation_end_date_time: ~datetime.datetime
        :keyword min_operation_modified_date_time: Minimum modified date-time of the operation data,
         sample format: yyyy-MM-ddTHH:mm:ssZ (inclusive). Default value is None.
        :paramtype min_operation_modified_date_time: ~datetime.datetime
        :keyword max_operation_modified_date_time: Maximum modified date-time of the operation data,
         sample format: yyyy-MM-ddTHH:mm:ssZ (inclusive). Default value is None.
        :paramtype max_operation_modified_date_time: ~datetime.datetime
        :keyword min_area: Minimum area for which operation was applied (inclusive). Default value is
         None.
        :paramtype min_area: float
        :keyword max_area: Maximum area for which operation was applied (inclusive). Default value is
         None.
        :paramtype max_area: float
        :keyword ids: Ids of the resource. Default value is None.
        :paramtype ids: list[str]
        :keyword names: Names of the resource. Default value is None.
        :paramtype names: list[str]
        :keyword property_filters: Filters on key-value pairs within the Properties object.
         eg. "{testKey} eq {testValue}". Default value is None.
        :paramtype property_filters: list[str]
        :keyword statuses: Statuses of the resource. Default value is None.
        :paramtype statuses: list[str]
        :keyword min_created_date_time: Minimum creation date of resource (inclusive). Default value is
         None.
        :paramtype min_created_date_time: ~datetime.datetime
        :keyword max_created_date_time: Maximum creation date of resource (inclusive). Default value is
         None.
        :paramtype max_created_date_time: ~datetime.datetime
        :keyword min_last_modified_date_time: Minimum last modified date of resource (inclusive).
         Default value is None.
        :paramtype min_last_modified_date_time: ~datetime.datetime
        :keyword max_last_modified_date_time: Maximum last modified date of resource (inclusive).
         Default value is None.
        :paramtype max_last_modified_date_time: ~datetime.datetime
        :keyword skip_token: Skip token for getting next set of results. Default value is None.
        :paramtype skip_token: str
        :return: An iterator like instance of JSON object
        :rtype: ~azure.core.paging.ItemPaged[JSON]
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "applicationProductDetails": [
                        {
                            "avgMaterial": {
                                "unit": "str",  # Optional. Data unit.
                                "value": 0.0  # Optional. Data value.
                            },
                            "isCarrier": False,  # Optional. Default value is False. A
                              flag indicating whether product is a carrier for a tank mix.
                            "productName": "str",  # Optional. Name of the product
                              applied.
                            "totalMaterial": {
                                "unit": "str",  # Optional. Data unit.
                                "value": 0.0  # Optional. Data value.
                            }
                        }
                    ],
                    "area": {
                        "unit": "str",  # Optional. Data unit.
                        "value": 0.0  # Optional. Data value.
                    },
                    "associatedBoundaryId": "str",  # Optional. Optional boundary ID of the field
                      for which operation was applied.
                    "attachmentsLink": "str",  # Optional. Link for attachments.
                    "avgMaterial": {
                        "unit": "str",  # Optional. Data unit.
                        "value": 0.0  # Optional. Data value.
                    },
                    "createdBy": "str",  # Optional. Created by user/tenant id.
                    "createdDateTime": "2020-02-20 00:00:00",  # Optional. Date-time when
                      resource was created, sample format: yyyy-MM-ddTHH:mm:ssZ.
                    "description": "str",  # Optional. Textual description of the resource.
                    "eTag": "str",  # Optional. The ETag value to implement optimistic
                      concurrency.
                    "id": "str",  # Optional. Unique resource ID.
                    "modifiedBy": "str",  # Optional. Modified by user/tenant id.
                    "modifiedDateTime": "2020-02-20 00:00:00",  # Optional. Date-time when
                      resource was last modified, sample format: yyyy-MM-ddTHH:mm:ssZ.
                    "name": "str",  # Optional. Name to identify resource.
                    "operationEndDateTime": "2020-02-20 00:00:00",  # Optional. End date-time of
                      the operation data, sample format: yyyy-MM-ddTHH:mm:ssZ.
                    "operationModifiedDateTime": "2020-02-20 00:00:00",  # Optional. Modified
                      date-time of the operation data, sample format: yyyy-MM-ddTHH:mm:ssZ."nNote: this
                      will be specified by the source provider itself.
                    "operationStartDateTime": "2020-02-20 00:00:00",  # Optional. Start date-time
                      of the operation data, sample format: yyyy-MM-ddTHH:mm:ssZ.
                    "partyId": "str",  # Optional. Party ID which belongs to the operation data.
                    "properties": {
                        "str": {}  # Optional. A collection of key value pairs that belongs
                          to the resource."nEach pair must not have a key greater than 50
                          characters"nand must not have a value greater than 150 characters."nNote: A
                          maximum of 25 key value pairs can be provided for a resource and only
                          string,"nnumeral and datetime (yyyy-MM-ddTHH:mm:ssZ) values are supported.
                    },
                    "source": "str",  # Optional. Source of the resource.
                    "status": "str",  # Optional. Status of the resource.
                    "totalMaterial": {
                        "unit": "str",  # Optional. Data unit.
                        "value": 0.0  # Optional. Data value.
                    }
                }
        """
        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls = kwargs.pop("cls", None)  # type: ClsType[JSON]

        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        def prepare_request(next_link=None):
            if not next_link:

                request = build_application_data_list_by_party_id_request(
                    party_id=party_id,
                    min_avg_material=min_avg_material,
                    max_avg_material=max_avg_material,
                    min_total_material=min_total_material,
                    max_total_material=max_total_material,
                    sources=sources,
                    associated_boundary_ids=associated_boundary_ids,
                    min_operation_start_date_time=min_operation_start_date_time,
                    max_operation_start_date_time=max_operation_start_date_time,
                    min_operation_end_date_time=min_operation_end_date_time,
                    max_operation_end_date_time=max_operation_end_date_time,
                    min_operation_modified_date_time=min_operation_modified_date_time,
                    max_operation_modified_date_time=max_operation_modified_date_time,
                    min_area=min_area,
                    max_area=max_area,
                    ids=ids,
                    names=names,
                    property_filters=property_filters,
                    statuses=statuses,
                    min_created_date_time=min_created_date_time,
                    max_created_date_time=max_created_date_time,
                    min_last_modified_date_time=min_last_modified_date_time,
                    max_last_modified_date_time=max_last_modified_date_time,
                    skip_token=skip_token,
                    api_version=self._config.api_version,
                    headers=_headers,
                    params=_params,
                )
                request.url = self._client.format_url(request.url)  # type: ignore

            else:
                # make call to next link with the client's api-version
                _parsed_next_link = urlparse(next_link)
                _next_request_params = case_insensitive_dict(parse_qs(_parsed_next_link.query))
                _next_request_params["api-version"] = self._config.api_version
                request = HttpRequest("GET", urljoin(next_link, _parsed_next_link.path), params=_next_request_params)
                request.url = self._client.format_url(request.url)  # type: ignore

            return request

        def extract_data(pipeline_response):
            deserialized = pipeline_response.http_response.json()
            list_of_elem = deserialized["value"]
            if cls:
                list_of_elem = cls(list_of_elem)
            return deserialized.get("nextLink", None), iter(list_of_elem)

        def get_next(next_link=None):
            request = prepare_request(next_link)

            pipeline_response = self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
                request, stream=False, **kwargs
            )
            response = pipeline_response.http_response

            if response.status_code not in [200]:
                map_error(status_code=response.status_code, response=response, error_map=error_map)
                raise HttpResponseError(response=response)

            return pipeline_response

        return ItemPaged(get_next, extract_data)

    @distributed_trace
    def get(self, party_id: str, application_data_id: str, **kwargs: Any) -> JSON:
        """Get a specified application data resource under a particular party.

        :param party_id: ID of the associated party resource. Required.
        :type party_id: str
        :param application_data_id: ID of the application data resource. Required.
        :type application_data_id: str
        :return: JSON object
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "applicationProductDetails": [
                        {
                            "avgMaterial": {
                                "unit": "str",  # Optional. Data unit.
                                "value": 0.0  # Optional. Data value.
                            },
                            "isCarrier": False,  # Optional. Default value is False. A
                              flag indicating whether product is a carrier for a tank mix.
                            "productName": "str",  # Optional. Name of the product
                              applied.
                            "totalMaterial": {
                                "unit": "str",  # Optional. Data unit.
                                "value": 0.0  # Optional. Data value.
                            }
                        }
                    ],
                    "area": {
                        "unit": "str",  # Optional. Data unit.
                        "value": 0.0  # Optional. Data value.
                    },
                    "associatedBoundaryId": "str",  # Optional. Optional boundary ID of the field
                      for which operation was applied.
                    "attachmentsLink": "str",  # Optional. Link for attachments.
                    "avgMaterial": {
                        "unit": "str",  # Optional. Data unit.
                        "value": 0.0  # Optional. Data value.
                    },
                    "createdBy": "str",  # Optional. Created by user/tenant id.
                    "createdDateTime": "2020-02-20 00:00:00",  # Optional. Date-time when
                      resource was created, sample format: yyyy-MM-ddTHH:mm:ssZ.
                    "description": "str",  # Optional. Textual description of the resource.
                    "eTag": "str",  # Optional. The ETag value to implement optimistic
                      concurrency.
                    "id": "str",  # Optional. Unique resource ID.
                    "modifiedBy": "str",  # Optional. Modified by user/tenant id.
                    "modifiedDateTime": "2020-02-20 00:00:00",  # Optional. Date-time when
                      resource was last modified, sample format: yyyy-MM-ddTHH:mm:ssZ.
                    "name": "str",  # Optional. Name to identify resource.
                    "operationEndDateTime": "2020-02-20 00:00:00",  # Optional. End date-time of
                      the operation data, sample format: yyyy-MM-ddTHH:mm:ssZ.
                    "operationModifiedDateTime": "2020-02-20 00:00:00",  # Optional. Modified
                      date-time of the operation data, sample format: yyyy-MM-ddTHH:mm:ssZ."nNote: this
                      will be specified by the source provider itself.
                    "operationStartDateTime": "2020-02-20 00:00:00",  # Optional. Start date-time
                      of the operation data, sample format: yyyy-MM-ddTHH:mm:ssZ.
                    "partyId": "str",  # Optional. Party ID which belongs to the operation data.
                    "properties": {
                        "str": {}  # Optional. A collection of key value pairs that belongs
                          to the resource."nEach pair must not have a key greater than 50
                          characters"nand must not have a value greater than 150 characters."nNote: A
                          maximum of 25 key value pairs can be provided for a resource and only
                          string,"nnumeral and datetime (yyyy-MM-ddTHH:mm:ssZ) values are supported.
                    },
                    "source": "str",  # Optional. Source of the resource.
                    "status": "str",  # Optional. Status of the resource.
                    "totalMaterial": {
                        "unit": "str",  # Optional. Data unit.
                        "value": 0.0  # Optional. Data value.
                    }
                }
        """
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls = kwargs.pop("cls", None)  # type: ClsType[JSON]

        request = build_application_data_get_request(
            party_id=party_id,
            application_data_id=application_data_id,
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        request.url = self._client.format_url(request.url)  # type: ignore

        pipeline_response = self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
            request, stream=False, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if response.content:
            deserialized = response.json()
        else:
            deserialized = None

        if cls:
            return cls(pipeline_response, cast(JSON, deserialized), {})

        return cast(JSON, deserialized)

    @overload
    def create_or_update(
        self,
        party_id: str,
        application_data_id: str,
        application_data: JSON,
        *,
        content_type: str = "application/merge-patch+json",
        **kwargs: Any
    ) -> JSON:
        """Creates or updates an application data resource under a particular party.

        :param party_id: ID of the associated party. Required.
        :type party_id: str
        :param application_data_id: ID of the application data resource. Required.
        :type application_data_id: str
        :param application_data: Application data resource payload to create or update. Required.
        :type application_data: JSON
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/merge-patch+json".
        :paramtype content_type: str
        :return: JSON object
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                application_data = {
                    "applicationProductDetails": [
                        {
                            "avgMaterial": {
                                "unit": "str",  # Optional. Data unit.
                                "value": 0.0  # Optional. Data value.
                            },
                            "isCarrier": False,  # Optional. Default value is False. A
                              flag indicating whether product is a carrier for a tank mix.
                            "productName": "str",  # Optional. Name of the product
                              applied.
                            "totalMaterial": {
                                "unit": "str",  # Optional. Data unit.
                                "value": 0.0  # Optional. Data value.
                            }
                        }
                    ],
                    "area": {
                        "unit": "str",  # Optional. Data unit.
                        "value": 0.0  # Optional. Data value.
                    },
                    "associatedBoundaryId": "str",  # Optional. Optional boundary ID of the field
                      for which operation was applied.
                    "attachmentsLink": "str",  # Optional. Link for attachments.
                    "avgMaterial": {
                        "unit": "str",  # Optional. Data unit.
                        "value": 0.0  # Optional. Data value.
                    },
                    "createdBy": "str",  # Optional. Created by user/tenant id.
                    "createdDateTime": "2020-02-20 00:00:00",  # Optional. Date-time when
                      resource was created, sample format: yyyy-MM-ddTHH:mm:ssZ.
                    "description": "str",  # Optional. Textual description of the resource.
                    "eTag": "str",  # Optional. The ETag value to implement optimistic
                      concurrency.
                    "id": "str",  # Optional. Unique resource ID.
                    "modifiedBy": "str",  # Optional. Modified by user/tenant id.
                    "modifiedDateTime": "2020-02-20 00:00:00",  # Optional. Date-time when
                      resource was last modified, sample format: yyyy-MM-ddTHH:mm:ssZ.
                    "name": "str",  # Optional. Name to identify resource.
                    "operationEndDateTime": "2020-02-20 00:00:00",  # Optional. End date-time of
                      the operation data, sample format: yyyy-MM-ddTHH:mm:ssZ.
                    "operationModifiedDateTime": "2020-02-20 00:00:00",  # Optional. Modified
                      date-time of the operation data, sample format: yyyy-MM-ddTHH:mm:ssZ."nNote: this
                      will be specified by the source provider itself.
                    "operationStartDateTime": "2020-02-20 00:00:00",  # Optional. Start date-time
                      of the operation data, sample format: yyyy-MM-ddTHH:mm:ssZ.
                    "partyId": "str",  # Optional. Party ID which belongs to the operation data.
                    "properties": {
                        "str": {}  # Optional. A collection of key value pairs that belongs
                          to the resource."nEach pair must not have a key greater than 50
                          characters"nand must not have a value greater than 150 characters."nNote: A
                          maximum of 25 key value pairs can be provided for a resource and only
                          string,"nnumeral and datetime (yyyy-MM-ddTHH:mm:ssZ) values are supported.
                    },
                    "source": "str",  # Optional. Source of the resource.
                    "status": "str",  # Optional. Status of the resource.
                    "totalMaterial": {
                        "unit": "str",  # Optional. Data unit.
                        "value": 0.0  # Optional. Data value.
                    }
                }

                # response body for status code(s): 200, 201
                response == {
                    "applicationProductDetails": [
                        {
                            "avgMaterial": {
                                "unit": "str",  # Optional. Data unit.
                                "value": 0.0  # Optional. Data value.
                            },
                            "isCarrier": False,  # Optional. Default value is False. A
                              flag indicating whether product is a carrier for a tank mix.
                            "productName": "str",  # Optional. Name of the product
                              applied.
                            "totalMaterial": {
                                "unit": "str",  # Optional. Data unit.
                                "value": 0.0  # Optional. Data value.
                            }
                        }
                    ],
                    "area": {
                        "unit": "str",  # Optional. Data unit.
                        "value": 0.0  # Optional. Data value.
                    },
                    "associatedBoundaryId": "str",  # Optional. Optional boundary ID of the field
                      for which operation was applied.
                    "attachmentsLink": "str",  # Optional. Link for attachments.
                    "avgMaterial": {
                        "unit": "str",  # Optional. Data unit.
                        "value": 0.0  # Optional. Data value.
                    },
                    "createdBy": "str",  # Optional. Created by user/tenant id.
                    "createdDateTime": "2020-02-20 00:00:00",  # Optional. Date-time when
                      resource was created, sample format: yyyy-MM-ddTHH:mm:ssZ.
                    "description": "str",  # Optional. Textual description of the resource.
                    "eTag": "str",  # Optional. The ETag value to implement optimistic
                      concurrency.
                    "id": "str",  # Optional. Unique resource ID.
                    "modifiedBy": "str",  # Optional. Modified by user/tenant id.
                    "modifiedDateTime": "2020-02-20 00:00:00",  # Optional. Date-time when
                      resource was last modified, sample format: yyyy-MM-ddTHH:mm:ssZ.
                    "name": "str",  # Optional. Name to identify resource.
                    "operationEndDateTime": "2020-02-20 00:00:00",  # Optional. End date-time of
                      the operation data, sample format: yyyy-MM-ddTHH:mm:ssZ.
                    "operationModifiedDateTime": "2020-02-20 00:00:00",  # Optional. Modified
                      date-time of the operation data, sample format: yyyy-MM-ddTHH:mm:ssZ."nNote: this
                      will be specified by the source provider itself.
                    "operationStartDateTime": "2020-02-20 00:00:00",  # Optional. Start date-time
                      of the operation data, sample format: yyyy-MM-ddTHH:mm:ssZ.
                    "partyId": "str",  # Optional. Party ID which belongs to the operation data.
                    "properties": {
                        "str": {}  # Optional. A collection of key value pairs that belongs
                          to the resource."nEach pair must not have a key greater than 50
                          characters"nand must not have a value greater than 150 characters."nNote: A
                          maximum of 25 key value pairs can be provided for a resource and only
                          string,"nnumeral and datetime (yyyy-MM-ddTHH:mm:ssZ) values are supported.
                    },
                    "source": "str",  # Optional. Source of the resource.
                    "status": "str",  # Optional. Status of the resource.
                    "totalMaterial": {
                        "unit": "str",  # Optional. Data unit.
                        "value": 0.0  # Optional. Data value.
                    }
                }
        """

    @overload
    def create_or_update(
        self,
        party_id: str,
        application_data_id: str,
        application_data: IO,
        *,
        content_type: str = "application/merge-patch+json",
        **kwargs: Any
    ) -> JSON:
        """Creates or updates an application data resource under a particular party.

        :param party_id: ID of the associated party. Required.
        :type party_id: str
        :param application_data_id: ID of the application data resource. Required.
        :type application_data_id: str
        :param application_data: Application data resource payload to create or update. Required.
        :type application_data: IO
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Default value is "application/merge-patch+json".
        :paramtype content_type: str
        :return: JSON object
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200, 201
                response == {
                    "applicationProductDetails": [
                        {
                            "avgMaterial": {
                                "unit": "str",  # Optional. Data unit.
                                "value": 0.0  # Optional. Data value.
                            },
                            "isCarrier": False,  # Optional. Default value is False. A
                              flag indicating whether product is a carrier for a tank mix.
                            "productName": "str",  # Optional. Name of the product
                              applied.
                            "totalMaterial": {
                                "unit": "str",  # Optional. Data unit.
                                "value": 0.0  # Optional. Data value.
                            }
                        }
                    ],
                    "area": {
                        "unit": "str",  # Optional. Data unit.
                        "value": 0.0  # Optional. Data value.
                    },
                    "associatedBoundaryId": "str",  # Optional. Optional boundary ID of the field
                      for which operation was applied.
                    "attachmentsLink": "str",  # Optional. Link for attachments.
                    "avgMaterial": {
                        "unit": "str",  # Optional. Data unit.
                        "value": 0.0  # Optional. Data value.
                    },
                    "createdBy": "str",  # Optional. Created by user/tenant id.
                    "createdDateTime": "2020-02-20 00:00:00",  # Optional. Date-time when
                      resource was created, sample format: yyyy-MM-ddTHH:mm:ssZ.
                    "description": "str",  # Optional. Textual description of the resource.
                    "eTag": "str",  # Optional. The ETag value to implement optimistic
                      concurrency.
                    "id": "str",  # Optional. Unique resource ID.
                    "modifiedBy": "str",  # Optional. Modified by user/tenant id.
                    "modifiedDateTime": "2020-02-20 00:00:00",  # Optional. Date-time when
                      resource was last modified, sample format: yyyy-MM-ddTHH:mm:ssZ.
                    "name": "str",  # Optional. Name to identify resource.
                    "operationEndDateTime": "2020-02-20 00:00:00",  # Optional. End date-time of
                      the operation data, sample format: yyyy-MM-ddTHH:mm:ssZ.
                    "operationModifiedDateTime": "2020-02-20 00:00:00",  # Optional. Modified
                      date-time of the operation data, sample format: yyyy-MM-ddTHH:mm:ssZ."nNote: this
                      will be specified by the source provider itself.
                    "operationStartDateTime": "2020-02-20 00:00:00",  # Optional. Start date-time
                      of the operation data, sample format: yyyy-MM-ddTHH:mm:ssZ.
                    "partyId": "str",  # Optional. Party ID which belongs to the operation data.
                    "properties": {
                        "str": {}  # Optional. A collection of key value pairs that belongs
                          to the resource."nEach pair must not have a key greater than 50
                          characters"nand must not have a value greater than 150 characters."nNote: A
                          maximum of 25 key value pairs can be provided for a resource and only
                          string,"nnumeral and datetime (yyyy-MM-ddTHH:mm:ssZ) values are supported.
                    },
                    "source": "str",  # Optional. Source of the resource.
                    "status": "str",  # Optional. Status of the resource.
                    "totalMaterial": {
                        "unit": "str",  # Optional. Data unit.
                        "value": 0.0  # Optional. Data value.
                    }
                }
        """

    @distributed_trace
    def create_or_update(
        self, party_id: str, application_data_id: str, application_data: Union[JSON, IO], **kwargs: Any
    ) -> JSON:
        """Creates or updates an application data resource under a particular party.

        :param party_id: ID of the associated party. Required.
        :type party_id: str
        :param application_data_id: ID of the application data resource. Required.
        :type application_data_id: str
        :param application_data: Application data resource payload to create or update. Is either a
         model type or a IO type. Required.
        :type application_data: JSON or IO
        :keyword content_type: Body Parameter content-type. Known values are:
         'application/merge-patch+json'. Default value is None.
        :paramtype content_type: str
        :return: JSON object
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200, 201
                response == {
                    "applicationProductDetails": [
                        {
                            "avgMaterial": {
                                "unit": "str",  # Optional. Data unit.
                                "value": 0.0  # Optional. Data value.
                            },
                            "isCarrier": False,  # Optional. Default value is False. A
                              flag indicating whether product is a carrier for a tank mix.
                            "productName": "str",  # Optional. Name of the product
                              applied.
                            "totalMaterial": {
                                "unit": "str",  # Optional. Data unit.
                                "value": 0.0  # Optional. Data value.
                            }
                        }
                    ],
                    "area": {
                        "unit": "str",  # Optional. Data unit.
                        "value": 0.0  # Optional. Data value.
                    },
                    "associatedBoundaryId": "str",  # Optional. Optional boundary ID of the field
                      for which operation was applied.
                    "attachmentsLink": "str",  # Optional. Link for attachments.
                    "avgMaterial": {
                        "unit": "str",  # Optional. Data unit.
                        "value": 0.0  # Optional. Data value.
                    },
                    "createdBy": "str",  # Optional. Created by user/tenant id.
                    "createdDateTime": "2020-02-20 00:00:00",  # Optional. Date-time when
                      resource was created, sample format: yyyy-MM-ddTHH:mm:ssZ.
                    "description": "str",  # Optional. Textual description of the resource.
                    "eTag": "str",  # Optional. The ETag value to implement optimistic
                      concurrency.
                    "id": "str",  # Optional. Unique resource ID.
                    "modifiedBy": "str",  # Optional. Modified by user/tenant id.
                    "modifiedDateTime": "2020-02-20 00:00:00",  # Optional. Date-time when
                      resource was last modified, sample format: yyyy-MM-ddTHH:mm:ssZ.
                    "name": "str",  # Optional. Name to identify resource.
                    "operationEndDateTime": "2020-02-20 00:00:00",  # Optional. End date-time of
                      the operation data, sample format: yyyy-MM-ddTHH:mm:ssZ.
                    "operationModifiedDateTime": "2020-02-20 00:00:00",  # Optional. Modified
                      date-time of the operation data, sample format: yyyy-MM-ddTHH:mm:ssZ."nNote: this
                      will be specified by the source provider itself.
                    "operationStartDateTime": "2020-02-20 00:00:00",  # Optional. Start date-time
                      of the operation data, sample format: yyyy-MM-ddTHH:mm:ssZ.
                    "partyId": "str",  # Optional. Party ID which belongs to the operation data.
                    "properties": {
                        "str": {}  # Optional. A collection of key value pairs that belongs
                          to the resource."nEach pair must not have a key greater than 50
                          characters"nand must not have a value greater than 150 characters."nNote: A
                          maximum of 25 key value pairs can be provided for a resource and only
                          string,"nnumeral and datetime (yyyy-MM-ddTHH:mm:ssZ) values are supported.
                    },
                    "source": "str",  # Optional. Source of the resource.
                    "status": "str",  # Optional. Status of the resource.
                    "totalMaterial": {
                        "unit": "str",  # Optional. Data unit.
                        "value": 0.0  # Optional. Data value.
                    }
                }
        """
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type = kwargs.pop("content_type", _headers.pop("Content-Type", None))  # type: Optional[str]
        cls = kwargs.pop("cls", None)  # type: ClsType[JSON]

        content_type = content_type or "application/merge-patch+json"
        _json = None
        _content = None
        if isinstance(application_data, (IO, bytes)):
            _content = application_data
        else:
            _json = application_data

        request = build_application_data_create_or_update_request(
            party_id=party_id,
            application_data_id=application_data_id,
            content_type=content_type,
            api_version=self._config.api_version,
            json=_json,
            content=_content,
            headers=_headers,
            params=_params,
        )
        request.url = self._client.format_url(request.url)  # type: ignore

        pipeline_response = self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
            request, stream=False, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200, 201]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if response.status_code == 200:
            if response.content:
                deserialized = response.json()
            else:
                deserialized = None

        if response.status_code == 201:
            if response.content:
                deserialized = response.json()
            else:
                deserialized = None

        if cls:
            return cls(pipeline_response, cast(JSON, deserialized), {})

        return cast(JSON, deserialized)

    @distributed_trace
    def delete(  # pylint: disable=inconsistent-return-statements
        self, party_id: str, application_data_id: str, **kwargs: Any
    ) -> None:
        """Deletes a specified application data resource under a particular party.

        :param party_id: ID of the associated party resource. Required.
        :type party_id: str
        :param application_data_id: ID of the application data. Required.
        :type application_data_id: str
        :return: None
        :rtype: None
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls = kwargs.pop("cls", None)  # type: ClsType[None]

        request = build_application_data_delete_request(
            party_id=party_id,
            application_data_id=application_data_id,
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        request.url = self._client.format_url(request.url)  # type: ignore

        pipeline_response = self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
            request, stream=False, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [204]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if cls:
            return cls(pipeline_response, None, {})


class AttachmentsOperations:
    """
    .. warning::
        **DO NOT** instantiate this class directly.

        Instead, you should access the following operations through
        :class:`~azure.agrifood.farming.FarmBeatsClient`'s
        :attr:`attachments` attribute.
    """

    def __init__(self, *args, **kwargs):
        input_args = list(args)
        self._client = input_args.pop(0) if input_args else kwargs.pop("client")
        self._config = input_args.pop(0) if input_args else kwargs.pop("config")
        self._serialize = input_args.pop(0) if input_args else kwargs.pop("serializer")
        self._deserialize = input_args.pop(0) if input_args else kwargs.pop("deserializer")
        raise_if_not_implemented(
            self.__class__,
            [
                "create_or_update",
            ],
        )

    @distributed_trace
    def list_by_party_id(
        self,
        party_id: str,
        *,
        resource_ids: Optional[List[str]] = None,
        resource_types: Optional[List[str]] = None,
        ids: Optional[List[str]] = None,
        names: Optional[List[str]] = None,
        property_filters: Optional[List[str]] = None,
        statuses: Optional[List[str]] = None,
        min_created_date_time: Optional[datetime.datetime] = None,
        max_created_date_time: Optional[datetime.datetime] = None,
        min_last_modified_date_time: Optional[datetime.datetime] = None,
        max_last_modified_date_time: Optional[datetime.datetime] = None,
        skip_token: Optional[str] = None,
        **kwargs: Any
    ) -> Iterable[JSON]:
        """Returns a paginated list of attachment resources under a particular party.

        :param party_id: Id of the associated party. Required.
        :type party_id: str
        :keyword resource_ids: Resource Ids of the resource. Default value is None.
        :paramtype resource_ids: list[str]
        :keyword resource_types: Resource Types of the resource.
         i.e. Party, Farm, Field, SeasonalField, Boundary, ApplicationData, HarvestData, TillageData,
         PlantingData, PlantTissueAnalysis. Default value is None.
        :paramtype resource_types: list[str]
        :keyword ids: Ids of the resource. Default value is None.
        :paramtype ids: list[str]
        :keyword names: Names of the resource. Default value is None.
        :paramtype names: list[str]
        :keyword property_filters: Filters on key-value pairs within the Properties object.
         eg. "{testKey} eq {testValue}". Default value is None.
        :paramtype property_filters: list[str]
        :keyword statuses: Statuses of the resource. Default value is None.
        :paramtype statuses: list[str]
        :keyword min_created_date_time: Minimum creation date of resource (inclusive). Default value is
         None.
        :paramtype min_created_date_time: ~datetime.datetime
        :keyword max_created_date_time: Maximum creation date of resource (inclusive). Default value is
         None.
        :paramtype max_created_date_time: ~datetime.datetime
        :keyword min_last_modified_date_time: Minimum last modified date of resource (inclusive).
         Default value is None.
        :paramtype min_last_modified_date_time: ~datetime.datetime
        :keyword max_last_modified_date_time: Maximum last modified date of resource (inclusive).
         Default value is None.
        :paramtype max_last_modified_date_time: ~datetime.datetime
        :keyword skip_token: Skip token for getting next set of results. Default value is None.
        :paramtype skip_token: str
        :return: An iterator like instance of JSON object
        :rtype: ~azure.core.paging.ItemPaged[JSON]
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "createdBy": "str",  # Optional. Created by user/tenant id.
                    "createdDateTime": "2020-02-20 00:00:00",  # Optional. Date when resource was
                      created.
                    "description": "str",  # Optional. Textual description of resource.
                    "eTag": "str",  # Optional. The ETag value to implement optimistic
                      concurrency.
                    "id": "str",  # Optional. Unique id.
                    "modifiedBy": "str",  # Optional. Modified by user/tenant id.
                    "modifiedDateTime": "2020-02-20 00:00:00",  # Optional. Date when resource
                      was last modified.
                    "name": "str",  # Optional. Name to identify resource.
                    "originalFileName": "str",  # Optional. Original File Name for this
                      attachment.
                    "partyId": "str",  # Optional. PartyId id for this attachment.
                    "resourceId": "str",  # Optional. Associated Resource id for this attachment.
                    "resourceType": "str",  # Optional. Associated Resource type for this
                      attachment. Known values are: "Party", "Farm", "Field", "SeasonalField",
                      "Boundary", "ApplicationData", "HarvestData", "TillageData", "PlantingData", and
                      "PlantTissueAnalysis".
                    "source": "str",  # Optional. Source of the resource.
                    "status": "str"  # Optional. Status of the resource.
                }
        """
        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls = kwargs.pop("cls", None)  # type: ClsType[JSON]

        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        def prepare_request(next_link=None):
            if not next_link:

                request = build_attachments_list_by_party_id_request(
                    party_id=party_id,
                    resource_ids=resource_ids,
                    resource_types=resource_types,
                    ids=ids,
                    names=names,
                    property_filters=property_filters,
                    statuses=statuses,
                    min_created_date_time=min_created_date_time,
                    max_created_date_time=max_created_date_time,
                    min_last_modified_date_time=min_last_modified_date_time,
                    max_last_modified_date_time=max_last_modified_date_time,
                    skip_token=skip_token,
                    api_version=self._config.api_version,
                    headers=_headers,
                    params=_params,
                )
                request.url = self._client.format_url(request.url)  # type: ignore

            else:
                # make call to next link with the client's api-version
                _parsed_next_link = urlparse(next_link)
                _next_request_params = case_insensitive_dict(parse_qs(_parsed_next_link.query))
                _next_request_params["api-version"] = self._config.api_version
                request = HttpRequest("GET", urljoin(next_link, _parsed_next_link.path), params=_next_request_params)
                request.url = self._client.format_url(request.url)  # type: ignore

            return request

        def extract_data(pipeline_response):
            deserialized = pipeline_response.http_response.json()
            list_of_elem = deserialized["value"]
            if cls:
                list_of_elem = cls(list_of_elem)
            return deserialized.get("nextLink", None), iter(list_of_elem)

        def get_next(next_link=None):
            request = prepare_request(next_link)

            pipeline_response = self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
                request, stream=False, **kwargs
            )
            response = pipeline_response.http_response

            if response.status_code not in [200]:
                map_error(status_code=response.status_code, response=response, error_map=error_map)
                raise HttpResponseError(response=response)

            return pipeline_response

        return ItemPaged(get_next, extract_data)

    @distributed_trace
    def get(self, party_id: str, attachment_id: str, **kwargs: Any) -> JSON:
        """Gets a specified attachment resource under a particular party.

        :param party_id: Id of the associated party. Required.
        :type party_id: str
        :param attachment_id: Id of the attachment. Required.
        :type attachment_id: str
        :return: JSON object
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "createdBy": "str",  # Optional. Created by user/tenant id.
                    "createdDateTime": "2020-02-20 00:00:00",  # Optional. Date when resource was
                      created.
                    "description": "str",  # Optional. Textual description of resource.
                    "eTag": "str",  # Optional. The ETag value to implement optimistic
                      concurrency.
                    "id": "str",  # Optional. Unique id.
                    "modifiedBy": "str",  # Optional. Modified by user/tenant id.
                    "modifiedDateTime": "2020-02-20 00:00:00",  # Optional. Date when resource
                      was last modified.
                    "name": "str",  # Optional. Name to identify resource.
                    "originalFileName": "str",  # Optional. Original File Name for this
                      attachment.
                    "partyId": "str",  # Optional. PartyId id for this attachment.
                    "resourceId": "str",  # Optional. Associated Resource id for this attachment.
                    "resourceType": "str",  # Optional. Associated Resource type for this
                      attachment. Known values are: "Party", "Farm", "Field", "SeasonalField",
                      "Boundary", "ApplicationData", "HarvestData", "TillageData", "PlantingData", and
                      "PlantTissueAnalysis".
                    "source": "str",  # Optional. Source of the resource.
                    "status": "str"  # Optional. Status of the resource.
                }
        """
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls = kwargs.pop("cls", None)  # type: ClsType[JSON]

        request = build_attachments_get_request(
            party_id=party_id,
            attachment_id=attachment_id,
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        request.url = self._client.format_url(request.url)  # type: ignore

        pipeline_response = self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
            request, stream=False, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if response.content:
            deserialized = response.json()
        else:
            deserialized = None

        if cls:
            return cls(pipeline_response, cast(JSON, deserialized), {})

        return cast(JSON, deserialized)

    @distributed_trace
    def delete(  # pylint: disable=inconsistent-return-statements
        self, party_id: str, attachment_id: str, **kwargs: Any
    ) -> None:
        """Deletes a specified attachment resource under a particular party.

        :param party_id: Id of the party. Required.
        :type party_id: str
        :param attachment_id: Id of the attachment. Required.
        :type attachment_id: str
        :return: None
        :rtype: None
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls = kwargs.pop("cls", None)  # type: ClsType[None]

        request = build_attachments_delete_request(
            party_id=party_id,
            attachment_id=attachment_id,
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        request.url = self._client.format_url(request.url)  # type: ignore

        pipeline_response = self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
            request, stream=False, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [204]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if cls:
            return cls(pipeline_response, None, {})

    @distributed_trace
    def download(self, party_id: str, attachment_id: str, **kwargs: Any) -> Iterator[bytes]:
        """Downloads and returns attachment as response for the given input filePath.

        :param party_id: Id of the associated party. Required.
        :type party_id: str
        :param attachment_id: Id of attachment to be downloaded. Required.
        :type attachment_id: str
        :return: Iterator of the response bytes
        :rtype: Iterator[bytes]
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls = kwargs.pop("cls", None)  # type: ClsType[Iterator[bytes]]

        request = build_attachments_download_request(
            party_id=party_id,
            attachment_id=attachment_id,
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        request.url = self._client.format_url(request.url)  # type: ignore

        pipeline_response = self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
            request, stream=True, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        deserialized = response.iter_bytes()

        if cls:
            return cls(pipeline_response, cast(Iterator[bytes], deserialized), {})

        return cast(Iterator[bytes], deserialized)


class BoundariesOperations:
    """
    .. warning::
        **DO NOT** instantiate this class directly.

        Instead, you should access the following operations through
        :class:`~azure.agrifood.farming.FarmBeatsClient`'s
        :attr:`boundaries` attribute.
    """

    def __init__(self, *args, **kwargs):
        input_args = list(args)
        self._client = input_args.pop(0) if input_args else kwargs.pop("client")
        self._config = input_args.pop(0) if input_args else kwargs.pop("config")
        self._serialize = input_args.pop(0) if input_args else kwargs.pop("serializer")
        self._deserialize = input_args.pop(0) if input_args else kwargs.pop("deserializer")

    @distributed_trace
    def list(
        self,
        *,
        parent_type: Optional[str] = None,
        type: Optional[str] = None,
        parent_ids: Optional[List[str]] = None,
        min_area: Optional[float] = None,
        max_area: Optional[float] = None,
        ids: Optional[List[str]] = None,
        names: Optional[List[str]] = None,
        property_filters: Optional[List[str]] = None,
        statuses: Optional[List[str]] = None,
        min_created_date_time: Optional[datetime.datetime] = None,
        max_created_date_time: Optional[datetime.datetime] = None,
        min_last_modified_date_time: Optional[datetime.datetime] = None,
        max_last_modified_date_time: Optional[datetime.datetime] = None,
        skip_token: Optional[str] = None,
        **kwargs: Any
    ) -> Iterable[JSON]:
        """Returns a paginated list of boundary resources across all parties.

        :keyword parent_type: Type of the parent it belongs to. Default value is None.
        :paramtype parent_type: str
        :keyword type: Type it belongs to. Default value is None.
        :paramtype type: str
        :keyword parent_ids: Parent Ids of the resource. Default value is None.
        :paramtype parent_ids: list[str]
        :keyword min_area: Minimum area of the boundary (inclusive). Default value is None.
        :paramtype min_area: float
        :keyword max_area: Maximum acreage of the boundary (inclusive). Default value is None.
        :paramtype max_area: float
        :keyword ids: Ids of the resource. Default value is None.
        :paramtype ids: list[str]
        :keyword names: Names of the resource. Default value is None.
        :paramtype names: list[str]
        :keyword property_filters: Filters on key-value pairs within the Properties object.
         eg. "{testKey} eq {testValue}". Default value is None.
        :paramtype property_filters: list[str]
        :keyword statuses: Statuses of the resource. Default value is None.
        :paramtype statuses: list[str]
        :keyword min_created_date_time: Minimum creation date of resource (inclusive). Default value is
         None.
        :paramtype min_created_date_time: ~datetime.datetime
        :keyword max_created_date_time: Maximum creation date of resource (inclusive). Default value is
         None.
        :paramtype max_created_date_time: ~datetime.datetime
        :keyword min_last_modified_date_time: Minimum last modified date of resource (inclusive).
         Default value is None.
        :paramtype min_last_modified_date_time: ~datetime.datetime
        :keyword max_last_modified_date_time: Maximum last modified date of resource (inclusive).
         Default value is None.
        :paramtype max_last_modified_date_time: ~datetime.datetime
        :keyword skip_token: Skip token for getting next set of results. Default value is None.
        :paramtype skip_token: str
        :return: An iterator like instance of JSON object
        :rtype: ~azure.core.paging.ItemPaged[JSON]
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "area": {
                        "unit": "str",  # Optional. Data unit.
                        "value": 0.0  # Optional. Data value.
                    },
                    "createdBy": "str",  # Optional. Created by user/tenant id.
                    "createdDateTime": "2020-02-20 00:00:00",  # Optional. Date-time when
                      resource was created, sample format: yyyy-MM-ddTHH:mm:ssZ.
                    "description": "str",  # Optional. Textual description of the resource.
                    "eTag": "str",  # Optional. The ETag value to implement optimistic
                      concurrency.
                    "id": "str",  # Optional. Unique resource ID.
                    "modifiedBy": "str",  # Optional. Modified by user/tenant id.
                    "modifiedDateTime": "2020-02-20 00:00:00",  # Optional. Date-time when
                      resource was last modified, sample format: yyyy-MM-ddTHH:mm:ssZ.
                    "name": "str",  # Optional. Name to identify resource.
                    "parentId": "str",  # Optional. Id of the parent it belongs to.
                    "parentType": "str",  # Optional. Type of the parent it belongs to. Known
                      values are: "Field", "SeasonalField", "Zone", "Prescription",
                      "PlantTissueAnalysis", "ApplicationData", "PlantingData", "TillageData", and
                      "HarvestData".
                    "partyId": "str",  # Optional. Party Id.
                    "properties": {
                        "str": {}  # Optional. A collection of key value pairs that belongs
                          to the resource."nEach pair must not have a key greater than 50
                          characters"nand must not have a value greater than 150 characters."nNote: A
                          maximum of 25 key value pairs can be provided for a resource and only
                          string,"nnumeral and datetime (yyyy-MM-ddTHH:mm:ssZ) values are supported.
                    },
                    "source": "str",  # Optional. Source of the resource.
                    "status": "str",  # Optional. Status of the resource.
                    "type": "str"  # Optional. Type it belongs to.
                }
        """
        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls = kwargs.pop("cls", None)  # type: ClsType[JSON]

        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        def prepare_request(next_link=None):
            if not next_link:

                request = build_boundaries_list_request(
                    parent_type=parent_type,
                    type=type,
                    parent_ids=parent_ids,
                    min_area=min_area,
                    max_area=max_area,
                    ids=ids,
                    names=names,
                    property_filters=property_filters,
                    statuses=statuses,
                    min_created_date_time=min_created_date_time,
                    max_created_date_time=max_created_date_time,
                    min_last_modified_date_time=min_last_modified_date_time,
                    max_last_modified_date_time=max_last_modified_date_time,
                    skip_token=skip_token,
                    api_version=self._config.api_version,
                    headers=_headers,
                    params=_params,
                )
                request.url = self._client.format_url(request.url)  # type: ignore

            else:
                # make call to next link with the client's api-version
                _parsed_next_link = urlparse(next_link)
                _next_request_params = case_insensitive_dict(parse_qs(_parsed_next_link.query))
                _next_request_params["api-version"] = self._config.api_version
                request = HttpRequest("GET", urljoin(next_link, _parsed_next_link.path), params=_next_request_params)
                request.url = self._client.format_url(request.url)  # type: ignore

            return request

        def extract_data(pipeline_response):
            deserialized = pipeline_response.http_response.json()
            list_of_elem = deserialized["value"]
            if cls:
                list_of_elem = cls(list_of_elem)
            return deserialized.get("nextLink", None), iter(list_of_elem)

        def get_next(next_link=None):
            request = prepare_request(next_link)

            pipeline_response = self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
                request, stream=False, **kwargs
            )
            response = pipeline_response.http_response

            if response.status_code not in [200]:
                map_error(status_code=response.status_code, response=response, error_map=error_map)
                raise HttpResponseError(response=response)

            return pipeline_response

        return ItemPaged(get_next, extract_data)

    @overload
    def search(
        self, search_boundary_query: JSON, *, content_type: str = "application/json", **kwargs: Any
    ) -> Iterable[JSON]:
        """Search for boundaries across all parties by fields and intersecting geometry.

        :param search_boundary_query: Query filters. Required.
        :type search_boundary_query: JSON
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: An iterator like instance of JSON object
        :rtype: ~azure.core.paging.ItemPaged[JSON]
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # The input is polymorphic. The following are possible polymorphic inputs based off
                  discriminator "type":

                # JSON input template for discriminator value "MultiPolygon":
                geo_json_object = {
                    "coordinates": [
                        [
                            [
                                [
                                    0.0  # Gets or sets Coordinates of GeoJSON
                                      Object."nIt must be an array of polygons, each polygon contains
                                      list of linear rings."nFor Polygons with more than one of these
                                      rings, the first MUST be the exterior ring,"nand any others MUST
                                      be interior rings. Required.
                                ]
                            ]
                        ]
                    ],
                    "type": "MultiPolygon"
                }

                # JSON input template for discriminator value "Point":
                geo_json_object = {
                    "coordinates": [
                        0.0  # Gets or sets the coordinate of this point."nIt must be an
                          array of 2 or 3 elements for a 2D or 3D system. Required.
                    ],
                    "type": "Point"
                }

                # JSON input template for discriminator value "Polygon":
                geo_json_object = {
                    "coordinates": [
                        [
                            [
                                0.0  # Gets or sets type of the GeoJSON Object."nIt
                                  must be an array of linear ring coordinate arrays."nFor Polygons with
                                  more than one of these rings, the first MUST be the exterior
                                  ring,"nand any others MUST be interior rings. Required.
                            ]
                        ]
                    ],
                    "type": "Polygon"
                }

                # JSON input template you can fill out and use as your body input.
                search_boundary_query = {
                    "ids": [
                        "str"  # Optional. Ids of the resource.
                    ],
                    "intersectsWithGeometry": geo_json_object,
                    "maxArea": 0.0,  # Optional. Maximum acreage of the boundary (inclusive).
                    "maxCreatedDateTime": "2020-02-20 00:00:00",  # Optional. Maximum creation
                      date of resource (inclusive).
                    "maxLastModifiedDateTime": "2020-02-20 00:00:00",  # Optional. Maximum last
                      modified date of resource (inclusive).
                    "maxPageSize": 50,  # Optional. Default value is 50. Maximum number of items
                      needed (inclusive)."nMinimum = 10, Maximum = 1000, Default value = 50.
                    "minArea": 0.0,  # Optional. Minimum acreage of the boundary (inclusive).
                    "minCreatedDateTime": "2020-02-20 00:00:00",  # Optional. Minimum creation
                      date of resource (inclusive).
                    "minLastModifiedDateTime": "2020-02-20 00:00:00",  # Optional. Minimum last
                      modified date of resource (inclusive).
                    "names": [
                        "str"  # Optional. Names of the resource.
                    ],
                    "parentIds": [
                        "str"  # Optional. Parent Ids of the resource.
                    ],
                    "parentType": "str",  # Optional. Type of the parent it belongs to. Known
                      values are: "Field", "SeasonalField", "Zone", "Prescription",
                      "PlantTissueAnalysis", "ApplicationData", "PlantingData", "TillageData", and
                      "HarvestData".
                    "propertyFilters": [
                        "str"  # Optional. Filters on key-value pairs within the Properties
                          object."ne.g. "{testKey} eq {testValue}".
                    ],
                    "skipToken": "str",  # Optional. Skip token for getting next set of results.
                    "statuses": [
                        "str"  # Optional. Statuses of the resource.
                    ],
                    "type": "str"  # Optional. Type it belongs to.
                }

                # response body for status code(s): 200
                response == {
                    "area": {
                        "unit": "str",  # Optional. Data unit.
                        "value": 0.0  # Optional. Data value.
                    },
                    "createdBy": "str",  # Optional. Created by user/tenant id.
                    "createdDateTime": "2020-02-20 00:00:00",  # Optional. Date-time when
                      resource was created, sample format: yyyy-MM-ddTHH:mm:ssZ.
                    "description": "str",  # Optional. Textual description of the resource.
                    "eTag": "str",  # Optional. The ETag value to implement optimistic
                      concurrency.
                    "id": "str",  # Optional. Unique resource ID.
                    "modifiedBy": "str",  # Optional. Modified by user/tenant id.
                    "modifiedDateTime": "2020-02-20 00:00:00",  # Optional. Date-time when
                      resource was last modified, sample format: yyyy-MM-ddTHH:mm:ssZ.
                    "name": "str",  # Optional. Name to identify resource.
                    "parentId": "str",  # Optional. Id of the parent it belongs to.
                    "parentType": "str",  # Optional. Type of the parent it belongs to. Known
                      values are: "Field", "SeasonalField", "Zone", "Prescription",
                      "PlantTissueAnalysis", "ApplicationData", "PlantingData", "TillageData", and
                      "HarvestData".
                    "partyId": "str",  # Optional. Party Id.
                    "properties": {
                        "str": {}  # Optional. A collection of key value pairs that belongs
                          to the resource."nEach pair must not have a key greater than 50
                          characters"nand must not have a value greater than 150 characters."nNote: A
                          maximum of 25 key value pairs can be provided for a resource and only
                          string,"nnumeral and datetime (yyyy-MM-ddTHH:mm:ssZ) values are supported.
                    },
                    "source": "str",  # Optional. Source of the resource.
                    "status": "str",  # Optional. Status of the resource.
                    "type": "str"  # Optional. Type it belongs to.
                }
        """

    @overload
    def search(
        self, search_boundary_query: IO, *, content_type: str = "application/json", **kwargs: Any
    ) -> Iterable[JSON]:
        """Search for boundaries across all parties by fields and intersecting geometry.

        :param search_boundary_query: Query filters. Required.
        :type search_boundary_query: IO
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: An iterator like instance of JSON object
        :rtype: ~azure.core.paging.ItemPaged[JSON]
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "area": {
                        "unit": "str",  # Optional. Data unit.
                        "value": 0.0  # Optional. Data value.
                    },
                    "createdBy": "str",  # Optional. Created by user/tenant id.
                    "createdDateTime": "2020-02-20 00:00:00",  # Optional. Date-time when
                      resource was created, sample format: yyyy-MM-ddTHH:mm:ssZ.
                    "description": "str",  # Optional. Textual description of the resource.
                    "eTag": "str",  # Optional. The ETag value to implement optimistic
                      concurrency.
                    "id": "str",  # Optional. Unique resource ID.
                    "modifiedBy": "str",  # Optional. Modified by user/tenant id.
                    "modifiedDateTime": "2020-02-20 00:00:00",  # Optional. Date-time when
                      resource was last modified, sample format: yyyy-MM-ddTHH:mm:ssZ.
                    "name": "str",  # Optional. Name to identify resource.
                    "parentId": "str",  # Optional. Id of the parent it belongs to.
                    "parentType": "str",  # Optional. Type of the parent it belongs to. Known
                      values are: "Field", "SeasonalField", "Zone", "Prescription",
                      "PlantTissueAnalysis", "ApplicationData", "PlantingData", "TillageData", and
                      "HarvestData".
                    "partyId": "str",  # Optional. Party Id.
                    "properties": {
                        "str": {}  # Optional. A collection of key value pairs that belongs
                          to the resource."nEach pair must not have a key greater than 50
                          characters"nand must not have a value greater than 150 characters."nNote: A
                          maximum of 25 key value pairs can be provided for a resource and only
                          string,"nnumeral and datetime (yyyy-MM-ddTHH:mm:ssZ) values are supported.
                    },
                    "source": "str",  # Optional. Source of the resource.
                    "status": "str",  # Optional. Status of the resource.
                    "type": "str"  # Optional. Type it belongs to.
                }
        """

    @distributed_trace
    def search(self, search_boundary_query: Union[JSON, IO], **kwargs: Any) -> Iterable[JSON]:
        """Search for boundaries across all parties by fields and intersecting geometry.

        :param search_boundary_query: Query filters. Is either a model type or a IO type. Required.
        :type search_boundary_query: JSON or IO
        :keyword content_type: Body Parameter content-type. Known values are: 'application/json'.
         Default value is None.
        :paramtype content_type: str
        :return: An iterator like instance of JSON object
        :rtype: ~azure.core.paging.ItemPaged[JSON]
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "area": {
                        "unit": "str",  # Optional. Data unit.
                        "value": 0.0  # Optional. Data value.
                    },
                    "createdBy": "str",  # Optional. Created by user/tenant id.
                    "createdDateTime": "2020-02-20 00:00:00",  # Optional. Date-time when
                      resource was created, sample format: yyyy-MM-ddTHH:mm:ssZ.
                    "description": "str",  # Optional. Textual description of the resource.
                    "eTag": "str",  # Optional. The ETag value to implement optimistic
                      concurrency.
                    "id": "str",  # Optional. Unique resource ID.
                    "modifiedBy": "str",  # Optional. Modified by user/tenant id.
                    "modifiedDateTime": "2020-02-20 00:00:00",  # Optional. Date-time when
                      resource was last modified, sample format: yyyy-MM-ddTHH:mm:ssZ.
                    "name": "str",  # Optional. Name to identify resource.
                    "parentId": "str",  # Optional. Id of the parent it belongs to.
                    "parentType": "str",  # Optional. Type of the parent it belongs to. Known
                      values are: "Field", "SeasonalField", "Zone", "Prescription",
                      "PlantTissueAnalysis", "ApplicationData", "PlantingData", "TillageData", and
                      "HarvestData".
                    "partyId": "str",  # Optional. Party Id.
                    "properties": {
                        "str": {}  # Optional. A collection of key value pairs that belongs
                          to the resource."nEach pair must not have a key greater than 50
                          characters"nand must not have a value greater than 150 characters."nNote: A
                          maximum of 25 key value pairs can be provided for a resource and only
                          string,"nnumeral and datetime (yyyy-MM-ddTHH:mm:ssZ) values are supported.
                    },
                    "source": "str",  # Optional. Source of the resource.
                    "status": "str",  # Optional. Status of the resource.
                    "type": "str"  # Optional. Type it belongs to.
                }
        """
        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type = kwargs.pop("content_type", _headers.pop("Content-Type", None))  # type: Optional[str]
        cls = kwargs.pop("cls", None)  # type: ClsType[JSON]

        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})
        content_type = content_type or "application/json"
        _json = None
        _content = None
        if isinstance(search_boundary_query, (IO, bytes)):
            _content = search_boundary_query
        else:
            _json = search_boundary_query

        def prepare_request(next_link=None):
            if not next_link:

                request = build_boundaries_search_request(
                    content_type=content_type,
                    api_version=self._config.api_version,
                    json=_json,
                    content=_content,
                    headers=_headers,
                    params=_params,
                )
                request.url = self._client.format_url(request.url)  # type: ignore

            else:
                # make call to next link with the client's api-version
                _parsed_next_link = urlparse(next_link)
                _next_request_params = case_insensitive_dict(parse_qs(_parsed_next_link.query))
                _next_request_params["api-version"] = self._config.api_version
                request = HttpRequest("GET", urljoin(next_link, _parsed_next_link.path), params=_next_request_params)
                request.url = self._client.format_url(request.url)  # type: ignore

            return request

        def extract_data(pipeline_response):
            deserialized = pipeline_response.http_response.json()
            list_of_elem = deserialized["value"]
            if cls:
                list_of_elem = cls(list_of_elem)
            return deserialized.get("nextLink", None), iter(list_of_elem)

        def get_next(next_link=None):
            request = prepare_request(next_link)

            pipeline_response = self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
                request, stream=False, **kwargs
            )
            response = pipeline_response.http_response

            if response.status_code not in [200]:
                map_error(status_code=response.status_code, response=response, error_map=error_map)
                raise HttpResponseError(response=response)

            return pipeline_response

        return ItemPaged(get_next, extract_data)

    def _create_cascade_delete_job_initial(
        self, job_id: str, *, party_id: str, boundary_id: str, **kwargs: Any
    ) -> JSON:
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls = kwargs.pop("cls", None)  # type: ClsType[JSON]

        request = build_boundaries_create_cascade_delete_job_request(
            job_id=job_id,
            party_id=party_id,
            boundary_id=boundary_id,
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        request.url = self._client.format_url(request.url)  # type: ignore

        pipeline_response = self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
            request, stream=False, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [202]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if response.content:
            deserialized = response.json()
        else:
            deserialized = None

        if cls:
            return cls(pipeline_response, cast(JSON, deserialized), {})

        return cast(JSON, deserialized)

    @distributed_trace
    def begin_create_cascade_delete_job(
        self, job_id: str, *, party_id: str, boundary_id: str, **kwargs: Any
    ) -> LROPoller[JSON]:
        """Create a cascade delete job for specified boundary.

        :param job_id: Job ID supplied by end user. Required.
        :type job_id: str
        :keyword party_id: ID of the associated party. Required.
        :paramtype party_id: str
        :keyword boundary_id: ID of the boundary to be deleted. Required.
        :paramtype boundary_id: str
        :keyword str continuation_token: A continuation token to restart a poller from a saved state.
        :keyword polling: By default, your polling method will be LROBasePolling. Pass in False for
         this operation to not poll, or pass in your own initialized polling object for a personal
         polling strategy.
        :paramtype polling: bool or ~azure.core.polling.PollingMethod
        :keyword int polling_interval: Default waiting time between two polls for LRO operations if no
         Retry-After header is present.
        :return: An instance of LROPoller that returns JSON object
        :rtype: ~azure.core.polling.LROPoller[JSON]
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 202
                response == {
                    "partyId": "str",  # Party Id. Required.
                    "resourceId": "str",  # The id of the resource. Required.
                    "resourceType": "str",  # The type of the resource. Required.
                    "createdDateTime": "2020-02-20 00:00:00",  # Optional. Job created at
                      dateTime. Sample format: yyyy-MM-ddTHH:mm:ssZ.
                    "durationInSeconds": 0.0,  # Optional. Duration of the job in seconds.
                    "endTime": "2020-02-20 00:00:00",  # Optional. Job end time when available.
                      Sample format: yyyy-MM-ddTHH:mm:ssZ.
                    "errorCode": "str",  # Optional. Error Code when job failed.
                    "id": "str",  # Optional. Unique job id.
                    "lastActionDateTime": "2020-02-20 00:00:00",  # Optional. Job was last acted
                      upon at dateTime. Sample format: yyyy-MM-ddTHH:mm:ssZ.
                    "message": "str",  # Optional. Status message to capture more details of the
                      job.
                    "startTime": "2020-02-20 00:00:00",  # Optional. Job start time when
                      available. Sample format: yyyy-MM-ddTHH:mm:ssZ.
                    "status": "str"  # Optional. Status of the job."nPossible values: 'Waiting',
                      'Running', 'Succeeded', 'Failed', 'Cancelled'. Known values are: "Waiting",
                      "Running", "Succeeded", "Failed", and "Cancelled".
                }
        """
        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls = kwargs.pop("cls", None)  # type: ClsType[JSON]
        polling = kwargs.pop("polling", True)  # type: Union[bool, PollingMethod]
        lro_delay = kwargs.pop("polling_interval", self._config.polling_interval)
        cont_token = kwargs.pop("continuation_token", None)  # type: Optional[str]
        if cont_token is None:
            raw_result = self._create_cascade_delete_job_initial(  # type: ignore
                job_id=job_id,
                party_id=party_id,
                boundary_id=boundary_id,
                cls=lambda x, y, z: x,
                headers=_headers,
                params=_params,
                **kwargs
            )
        kwargs.pop("error_map", None)

        def get_long_running_output(pipeline_response):
            response = pipeline_response.http_response
            if response.content:
                deserialized = response.json()
            else:
                deserialized = None
            if cls:
                return cls(pipeline_response, deserialized, {})
            return deserialized

        if polling is True:
            polling_method = cast(
                PollingMethod, LROBasePolling(lro_delay, lro_options={"final-state-via": "location"}, **kwargs)
            )  # type: PollingMethod
        elif polling is False:
            polling_method = cast(PollingMethod, NoPolling())
        else:
            polling_method = polling
        if cont_token:
            return LROPoller.from_continuation_token(
                polling_method=polling_method,
                continuation_token=cont_token,
                client=self._client,
                deserialization_callback=get_long_running_output,
            )
        return LROPoller(self._client, raw_result, get_long_running_output, polling_method)

    @distributed_trace
    def get_cascade_delete_job_details(self, job_id: str, **kwargs: Any) -> JSON:
        """Get cascade delete job for specified boundary.

        :param job_id: Id of the job. Required.
        :type job_id: str
        :return: JSON object
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "partyId": "str",  # Party Id. Required.
                    "resourceId": "str",  # The id of the resource. Required.
                    "resourceType": "str",  # The type of the resource. Required.
                    "createdDateTime": "2020-02-20 00:00:00",  # Optional. Job created at
                      dateTime. Sample format: yyyy-MM-ddTHH:mm:ssZ.
                    "durationInSeconds": 0.0,  # Optional. Duration of the job in seconds.
                    "endTime": "2020-02-20 00:00:00",  # Optional. Job end time when available.
                      Sample format: yyyy-MM-ddTHH:mm:ssZ.
                    "errorCode": "str",  # Optional. Error Code when job failed.
                    "id": "str",  # Optional. Unique job id.
                    "lastActionDateTime": "2020-02-20 00:00:00",  # Optional. Job was last acted
                      upon at dateTime. Sample format: yyyy-MM-ddTHH:mm:ssZ.
                    "message": "str",  # Optional. Status message to capture more details of the
                      job.
                    "startTime": "2020-02-20 00:00:00",  # Optional. Job start time when
                      available. Sample format: yyyy-MM-ddTHH:mm:ssZ.
                    "status": "str"  # Optional. Status of the job."nPossible values: 'Waiting',
                      'Running', 'Succeeded', 'Failed', 'Cancelled'. Known values are: "Waiting",
                      "Running", "Succeeded", "Failed", and "Cancelled".
                }
        """
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls = kwargs.pop("cls", None)  # type: ClsType[JSON]

        request = build_boundaries_get_cascade_delete_job_details_request(
            job_id=job_id,
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        request.url = self._client.format_url(request.url)  # type: ignore

        pipeline_response = self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
            request, stream=False, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if response.content:
            deserialized = response.json()
        else:
            deserialized = None

        if cls:
            return cls(pipeline_response, cast(JSON, deserialized), {})

        return cast(JSON, deserialized)

    @distributed_trace
    def list_by_party_id(
        self,
        party_id: str,
        *,
        parent_type: Optional[str] = None,
        type: Optional[str] = None,
        parent_ids: Optional[List[str]] = None,
        min_area: Optional[float] = None,
        max_area: Optional[float] = None,
        ids: Optional[List[str]] = None,
        names: Optional[List[str]] = None,
        property_filters: Optional[List[str]] = None,
        statuses: Optional[List[str]] = None,
        min_created_date_time: Optional[datetime.datetime] = None,
        max_created_date_time: Optional[datetime.datetime] = None,
        min_last_modified_date_time: Optional[datetime.datetime] = None,
        max_last_modified_date_time: Optional[datetime.datetime] = None,
        skip_token: Optional[str] = None,
        **kwargs: Any
    ) -> Iterable[JSON]:
        """Returns a paginated list of boundary resources under a particular party.

        :param party_id: Id of the associated party. Required.
        :type party_id: str
        :keyword parent_type: Type of the parent it belongs to. Default value is None.
        :paramtype parent_type: str
        :keyword type: Type it belongs to. Default value is None.
        :paramtype type: str
        :keyword parent_ids: Parent Ids of the resource. Default value is None.
        :paramtype parent_ids: list[str]
        :keyword min_area: Minimum area of the boundary (inclusive). Default value is None.
        :paramtype min_area: float
        :keyword max_area: Maximum acreage of the boundary (inclusive). Default value is None.
        :paramtype max_area: float
        :keyword ids: Ids of the resource. Default value is None.
        :paramtype ids: list[str]
        :keyword names: Names of the resource. Default value is None.
        :paramtype names: list[str]
        :keyword property_filters: Filters on key-value pairs within the Properties object.
         eg. "{testKey} eq {testValue}". Default value is None.
        :paramtype property_filters: list[str]
        :keyword statuses: Statuses of the resource. Default value is None.
        :paramtype statuses: list[str]
        :keyword min_created_date_time: Minimum creation date of resource (inclusive). Default value is
         None.
        :paramtype min_created_date_time: ~datetime.datetime
        :keyword max_created_date_time: Maximum creation date of resource (inclusive). Default value is
         None.
        :paramtype max_created_date_time: ~datetime.datetime
        :keyword min_last_modified_date_time: Minimum last modified date of resource (inclusive).
         Default value is None.
        :paramtype min_last_modified_date_time: ~datetime.datetime
        :keyword max_last_modified_date_time: Maximum last modified date of resource (inclusive).
         Default value is None.
        :paramtype max_last_modified_date_time: ~datetime.datetime
        :keyword skip_token: Skip token for getting next set of results. Default value is None.
        :paramtype skip_token: str
        :return: An iterator like instance of JSON object
        :rtype: ~azure.core.paging.ItemPaged[JSON]
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "area": {
                        "unit": "str",  # Optional. Data unit.
                        "value": 0.0  # Optional. Data value.
                    },
                    "createdBy": "str",  # Optional. Created by user/tenant id.
                    "createdDateTime": "2020-02-20 00:00:00",  # Optional. Date-time when
                      resource was created, sample format: yyyy-MM-ddTHH:mm:ssZ.
                    "description": "str",  # Optional. Textual description of the resource.
                    "eTag": "str",  # Optional. The ETag value to implement optimistic
                      concurrency.
                    "id": "str",  # Optional. Unique resource ID.
                    "modifiedBy": "str",  # Optional. Modified by user/tenant id.
                    "modifiedDateTime": "2020-02-20 00:00:00",  # Optional. Date-time when
                      resource was last modified, sample format: yyyy-MM-ddTHH:mm:ssZ.
                    "name": "str",  # Optional. Name to identify resource.
                    "parentId": "str",  # Optional. Id of the parent it belongs to.
                    "parentType": "str",  # Optional. Type of the parent it belongs to. Known
                      values are: "Field", "SeasonalField", "Zone", "Prescription",
                      "PlantTissueAnalysis", "ApplicationData", "PlantingData", "TillageData", and
                      "HarvestData".
                    "partyId": "str",  # Optional. Party Id.
                    "properties": {
                        "str": {}  # Optional. A collection of key value pairs that belongs
                          to the resource."nEach pair must not have a key greater than 50
                          characters"nand must not have a value greater than 150 characters."nNote: A
                          maximum of 25 key value pairs can be provided for a resource and only
                          string,"nnumeral and datetime (yyyy-MM-ddTHH:mm:ssZ) values are supported.
                    },
                    "source": "str",  # Optional. Source of the resource.
                    "status": "str",  # Optional. Status of the resource.
                    "type": "str"  # Optional. Type it belongs to.
                }
        """
        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls = kwargs.pop("cls", None)  # type: ClsType[JSON]

        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        def prepare_request(next_link=None):
            if not next_link:

                request = build_boundaries_list_by_party_id_request(
                    party_id=party_id,
                    parent_type=parent_type,
                    type=type,
                    parent_ids=parent_ids,
                    min_area=min_area,
                    max_area=max_area,
                    ids=ids,
                    names=names,
                    property_filters=property_filters,
                    statuses=statuses,
                    min_created_date_time=min_created_date_time,
                    max_created_date_time=max_created_date_time,
                    min_last_modified_date_time=min_last_modified_date_time,
                    max_last_modified_date_time=max_last_modified_date_time,
                    skip_token=skip_token,
                    api_version=self._config.api_version,
                    headers=_headers,
                    params=_params,
                )
                request.url = self._client.format_url(request.url)  # type: ignore

            else:
                # make call to next link with the client's api-version
                _parsed_next_link = urlparse(next_link)
                _next_request_params = case_insensitive_dict(parse_qs(_parsed_next_link.query))
                _next_request_params["api-version"] = self._config.api_version
                request = HttpRequest("GET", urljoin(next_link, _parsed_next_link.path), params=_next_request_params)
                request.url = self._client.format_url(request.url)  # type: ignore

            return request

        def extract_data(pipeline_response):
            deserialized = pipeline_response.http_response.json()
            list_of_elem = deserialized["value"]
            if cls:
                list_of_elem = cls(list_of_elem)
            return deserialized.get("nextLink", None), iter(list_of_elem)

        def get_next(next_link=None):
            request = prepare_request(next_link)

            pipeline_response = self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
                request, stream=False, **kwargs
            )
            response = pipeline_response.http_response

            if response.status_code not in [200]:
                map_error(status_code=response.status_code, response=response, error_map=error_map)
                raise HttpResponseError(response=response)

            return pipeline_response

        return ItemPaged(get_next, extract_data)

    @overload
    def search_by_party_id(
        self, party_id: str, search_boundary_query: JSON, *, content_type: str = "application/json", **kwargs: Any
    ) -> Iterable[JSON]:
        """Search for boundaries by fields and intersecting geometry.

        :param party_id: Id of the party. Required.
        :type party_id: str
        :param search_boundary_query: Query filters. Required.
        :type search_boundary_query: JSON
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: An iterator like instance of JSON object
        :rtype: ~azure.core.paging.ItemPaged[JSON]
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # The input is polymorphic. The following are possible polymorphic inputs based off
                  discriminator "type":

                # JSON input template for discriminator value "MultiPolygon":
                geo_json_object = {
                    "coordinates": [
                        [
                            [
                                [
                                    0.0  # Gets or sets Coordinates of GeoJSON
                                      Object."nIt must be an array of polygons, each polygon contains
                                      list of linear rings."nFor Polygons with more than one of these
                                      rings, the first MUST be the exterior ring,"nand any others MUST
                                      be interior rings. Required.
                                ]
                            ]
                        ]
                    ],
                    "type": "MultiPolygon"
                }

                # JSON input template for discriminator value "Point":
                geo_json_object = {
                    "coordinates": [
                        0.0  # Gets or sets the coordinate of this point."nIt must be an
                          array of 2 or 3 elements for a 2D or 3D system. Required.
                    ],
                    "type": "Point"
                }

                # JSON input template for discriminator value "Polygon":
                geo_json_object = {
                    "coordinates": [
                        [
                            [
                                0.0  # Gets or sets type of the GeoJSON Object."nIt
                                  must be an array of linear ring coordinate arrays."nFor Polygons with
                                  more than one of these rings, the first MUST be the exterior
                                  ring,"nand any others MUST be interior rings. Required.
                            ]
                        ]
                    ],
                    "type": "Polygon"
                }

                # JSON input template you can fill out and use as your body input.
                search_boundary_query = {
                    "ids": [
                        "str"  # Optional. Ids of the resource.
                    ],
                    "intersectsWithGeometry": geo_json_object,
                    "maxArea": 0.0,  # Optional. Maximum acreage of the boundary (inclusive).
                    "maxCreatedDateTime": "2020-02-20 00:00:00",  # Optional. Maximum creation
                      date of resource (inclusive).
                    "maxLastModifiedDateTime": "2020-02-20 00:00:00",  # Optional. Maximum last
                      modified date of resource (inclusive).
                    "maxPageSize": 50,  # Optional. Default value is 50. Maximum number of items
                      needed (inclusive)."nMinimum = 10, Maximum = 1000, Default value = 50.
                    "minArea": 0.0,  # Optional. Minimum acreage of the boundary (inclusive).
                    "minCreatedDateTime": "2020-02-20 00:00:00",  # Optional. Minimum creation
                      date of resource (inclusive).
                    "minLastModifiedDateTime": "2020-02-20 00:00:00",  # Optional. Minimum last
                      modified date of resource (inclusive).
                    "names": [
                        "str"  # Optional. Names of the resource.
                    ],
                    "parentIds": [
                        "str"  # Optional. Parent Ids of the resource.
                    ],
                    "parentType": "str",  # Optional. Type of the parent it belongs to. Known
                      values are: "Field", "SeasonalField", "Zone", "Prescription",
                      "PlantTissueAnalysis", "ApplicationData", "PlantingData", "TillageData", and
                      "HarvestData".
                    "propertyFilters": [
                        "str"  # Optional. Filters on key-value pairs within the Properties
                          object."ne.g. "{testKey} eq {testValue}".
                    ],
                    "skipToken": "str",  # Optional. Skip token for getting next set of results.
                    "statuses": [
                        "str"  # Optional. Statuses of the resource.
                    ],
                    "type": "str"  # Optional. Type it belongs to.
                }

                # response body for status code(s): 200
                response == {
                    "area": {
                        "unit": "str",  # Optional. Data unit.
                        "value": 0.0  # Optional. Data value.
                    },
                    "createdBy": "str",  # Optional. Created by user/tenant id.
                    "createdDateTime": "2020-02-20 00:00:00",  # Optional. Date-time when
                      resource was created, sample format: yyyy-MM-ddTHH:mm:ssZ.
                    "description": "str",  # Optional. Textual description of the resource.
                    "eTag": "str",  # Optional. The ETag value to implement optimistic
                      concurrency.
                    "id": "str",  # Optional. Unique resource ID.
                    "modifiedBy": "str",  # Optional. Modified by user/tenant id.
                    "modifiedDateTime": "2020-02-20 00:00:00",  # Optional. Date-time when
                      resource was last modified, sample format: yyyy-MM-ddTHH:mm:ssZ.
                    "name": "str",  # Optional. Name to identify resource.
                    "parentId": "str",  # Optional. Id of the parent it belongs to.
                    "parentType": "str",  # Optional. Type of the parent it belongs to. Known
                      values are: "Field", "SeasonalField", "Zone", "Prescription",
                      "PlantTissueAnalysis", "ApplicationData", "PlantingData", "TillageData", and
                      "HarvestData".
                    "partyId": "str",  # Optional. Party Id.
                    "properties": {
                        "str": {}  # Optional. A collection of key value pairs that belongs
                          to the resource."nEach pair must not have a key greater than 50
                          characters"nand must not have a value greater than 150 characters."nNote: A
                          maximum of 25 key value pairs can be provided for a resource and only
                          string,"nnumeral and datetime (yyyy-MM-ddTHH:mm:ssZ) values are supported.
                    },
                    "source": "str",  # Optional. Source of the resource.
                    "status": "str",  # Optional. Status of the resource.
                    "type": "str"  # Optional. Type it belongs to.
                }
        """

    @overload
    def search_by_party_id(
        self, party_id: str, search_boundary_query: IO, *, content_type: str = "application/json", **kwargs: Any
    ) -> Iterable[JSON]:
        """Search for boundaries by fields and intersecting geometry.

        :param party_id: Id of the party. Required.
        :type party_id: str
        :param search_boundary_query: Query filters. Required.
        :type search_boundary_query: IO
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: An iterator like instance of JSON object
        :rtype: ~azure.core.paging.ItemPaged[JSON]
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "area": {
                        "unit": "str",  # Optional. Data unit.
                        "value": 0.0  # Optional. Data value.
                    },
                    "createdBy": "str",  # Optional. Created by user/tenant id.
                    "createdDateTime": "2020-02-20 00:00:00",  # Optional. Date-time when
                      resource was created, sample format: yyyy-MM-ddTHH:mm:ssZ.
                    "description": "str",  # Optional. Textual description of the resource.
                    "eTag": "str",  # Optional. The ETag value to implement optimistic
                      concurrency.
                    "id": "str",  # Optional. Unique resource ID.
                    "modifiedBy": "str",  # Optional. Modified by user/tenant id.
                    "modifiedDateTime": "2020-02-20 00:00:00",  # Optional. Date-time when
                      resource was last modified, sample format: yyyy-MM-ddTHH:mm:ssZ.
                    "name": "str",  # Optional. Name to identify resource.
                    "parentId": "str",  # Optional. Id of the parent it belongs to.
                    "parentType": "str",  # Optional. Type of the parent it belongs to. Known
                      values are: "Field", "SeasonalField", "Zone", "Prescription",
                      "PlantTissueAnalysis", "ApplicationData", "PlantingData", "TillageData", and
                      "HarvestData".
                    "partyId": "str",  # Optional. Party Id.
                    "properties": {
                        "str": {}  # Optional. A collection of key value pairs that belongs
                          to the resource."nEach pair must not have a key greater than 50
                          characters"nand must not have a value greater than 150 characters."nNote: A
                          maximum of 25 key value pairs can be provided for a resource and only
                          string,"nnumeral and datetime (yyyy-MM-ddTHH:mm:ssZ) values are supported.
                    },
                    "source": "str",  # Optional. Source of the resource.
                    "status": "str",  # Optional. Status of the resource.
                    "type": "str"  # Optional. Type it belongs to.
                }
        """

    @distributed_trace
    def search_by_party_id(
        self, party_id: str, search_boundary_query: Union[JSON, IO], **kwargs: Any
    ) -> Iterable[JSON]:
        """Search for boundaries by fields and intersecting geometry.

        :param party_id: Id of the party. Required.
        :type party_id: str
        :param search_boundary_query: Query filters. Is either a model type or a IO type. Required.
        :type search_boundary_query: JSON or IO
        :keyword content_type: Body Parameter content-type. Known values are: 'application/json'.
         Default value is None.
        :paramtype content_type: str
        :return: An iterator like instance of JSON object
        :rtype: ~azure.core.paging.ItemPaged[JSON]
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "area": {
                        "unit": "str",  # Optional. Data unit.
                        "value": 0.0  # Optional. Data value.
                    },
                    "createdBy": "str",  # Optional. Created by user/tenant id.
                    "createdDateTime": "2020-02-20 00:00:00",  # Optional. Date-time when
                      resource was created, sample format: yyyy-MM-ddTHH:mm:ssZ.
                    "description": "str",  # Optional. Textual description of the resource.
                    "eTag": "str",  # Optional. The ETag value to implement optimistic
                      concurrency.
                    "id": "str",  # Optional. Unique resource ID.
                    "modifiedBy": "str",  # Optional. Modified by user/tenant id.
                    "modifiedDateTime": "2020-02-20 00:00:00",  # Optional. Date-time when
                      resource was last modified, sample format: yyyy-MM-ddTHH:mm:ssZ.
                    "name": "str",  # Optional. Name to identify resource.
                    "parentId": "str",  # Optional. Id of the parent it belongs to.
                    "parentType": "str",  # Optional. Type of the parent it belongs to. Known
                      values are: "Field", "SeasonalField", "Zone", "Prescription",
                      "PlantTissueAnalysis", "ApplicationData", "PlantingData", "TillageData", and
                      "HarvestData".
                    "partyId": "str",  # Optional. Party Id.
                    "properties": {
                        "str": {}  # Optional. A collection of key value pairs that belongs
                          to the resource."nEach pair must not have a key greater than 50
                          characters"nand must not have a value greater than 150 characters."nNote: A
                          maximum of 25 key value pairs can be provided for a resource and only
                          string,"nnumeral and datetime (yyyy-MM-ddTHH:mm:ssZ) values are supported.
                    },
                    "source": "str",  # Optional. Source of the resource.
                    "status": "str",  # Optional. Status of the resource.
                    "type": "str"  # Optional. Type it belongs to.
                }
        """
        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type = kwargs.pop("content_type", _headers.pop("Content-Type", None))  # type: Optional[str]
        cls = kwargs.pop("cls", None)  # type: ClsType[JSON]

        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})
        content_type = content_type or "application/json"
        _json = None
        _content = None
        if isinstance(search_boundary_query, (IO, bytes)):
            _content = search_boundary_query
        else:
            _json = search_boundary_query

        def prepare_request(next_link=None):
            if not next_link:

                request = build_boundaries_search_by_party_id_request(
                    party_id=party_id,
                    content_type=content_type,
                    api_version=self._config.api_version,
                    json=_json,
                    content=_content,
                    headers=_headers,
                    params=_params,
                )
                request.url = self._client.format_url(request.url)  # type: ignore

            else:
                # make call to next link with the client's api-version
                _parsed_next_link = urlparse(next_link)
                _next_request_params = case_insensitive_dict(parse_qs(_parsed_next_link.query))
                _next_request_params["api-version"] = self._config.api_version
                request = HttpRequest("GET", urljoin(next_link, _parsed_next_link.path), params=_next_request_params)
                request.url = self._client.format_url(request.url)  # type: ignore

            return request

        def extract_data(pipeline_response):
            deserialized = pipeline_response.http_response.json()
            list_of_elem = deserialized["value"]
            if cls:
                list_of_elem = cls(list_of_elem)
            return deserialized.get("nextLink", None), iter(list_of_elem)

        def get_next(next_link=None):
            request = prepare_request(next_link)

            pipeline_response = self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
                request, stream=False, **kwargs
            )
            response = pipeline_response.http_response

            if response.status_code not in [200]:
                map_error(status_code=response.status_code, response=response, error_map=error_map)
                raise HttpResponseError(response=response)

            return pipeline_response

        return ItemPaged(get_next, extract_data)

    @overload
    def create_or_update(
        self,
        party_id: str,
        boundary_id: str,
        boundary: JSON,
        *,
        content_type: str = "application/merge-patch+json",
        **kwargs: Any
    ) -> JSON:
        """Creates or updates a boundary resource.

        :param party_id: Id of the party resource. Required.
        :type party_id: str
        :param boundary_id: Id of the boundary resource. Required.
        :type boundary_id: str
        :param boundary: Boundary resource payload to create or update. Required.
        :type boundary: JSON
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/merge-patch+json".
        :paramtype content_type: str
        :return: JSON object
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # The input is polymorphic. The following are possible polymorphic inputs based off
                  discriminator "type":

                # JSON input template for discriminator value "MultiPolygon":
                geo_json_object = {
                    "coordinates": [
                        [
                            [
                                [
                                    0.0  # Gets or sets Coordinates of GeoJSON
                                      Object."nIt must be an array of polygons, each polygon contains
                                      list of linear rings."nFor Polygons with more than one of these
                                      rings, the first MUST be the exterior ring,"nand any others MUST
                                      be interior rings. Required.
                                ]
                            ]
                        ]
                    ],
                    "type": "MultiPolygon"
                }

                # JSON input template for discriminator value "Point":
                geo_json_object = {
                    "coordinates": [
                        0.0  # Gets or sets the coordinate of this point."nIt must be an
                          array of 2 or 3 elements for a 2D or 3D system. Required.
                    ],
                    "type": "Point"
                }

                # JSON input template for discriminator value "Polygon":
                geo_json_object = {
                    "coordinates": [
                        [
                            [
                                0.0  # Gets or sets type of the GeoJSON Object."nIt
                                  must be an array of linear ring coordinate arrays."nFor Polygons with
                                  more than one of these rings, the first MUST be the exterior
                                  ring,"nand any others MUST be interior rings. Required.
                            ]
                        ]
                    ],
                    "type": "Polygon"
                }

                # JSON input template you can fill out and use as your body input.
                boundary = {
                    "area": {
                        "unit": "str",  # Optional. Data unit.
                        "value": 0.0  # Optional. Data value.
                    },
                    "bbox": geo_json_object,
                    "centroid": geo_json_object,
                    "createdBy": "str",  # Optional. Created by user/tenant id.
                    "createdDateTime": "2020-02-20 00:00:00",  # Optional. Date-time when
                      resource was created, sample format: yyyy-MM-ddTHH:mm:ssZ.
                    "crs": "str",  # Optional. Coordinate  Reference System.
                    "description": "str",  # Optional. Textual description of the resource.
                    "eTag": "str",  # Optional. The ETag value to implement optimistic
                      concurrency.
                    "geometry": geo_json_object,
                    "id": "str",  # Optional. Unique resource ID.
                    "modifiedBy": "str",  # Optional. Modified by user/tenant id.
                    "modifiedDateTime": "2020-02-20 00:00:00",  # Optional. Date-time when
                      resource was last modified, sample format: yyyy-MM-ddTHH:mm:ssZ.
                    "name": "str",  # Optional. Name to identify resource.
                    "parentId": "str",  # Optional. Id of the parent it belongs to.
                    "parentType": "str",  # Optional. Type of the parent it belongs to."ni.e.
                      Field, SeasonalField, Zone, Prescription, PlantTissueAnalysis, ApplicationData,
                      HarvestData, TillageData, PlantingData. Known values are: "Field",
                      "SeasonalField", "Zone", "Prescription", "PlantTissueAnalysis",
                      "ApplicationData", "PlantingData", "TillageData", and "HarvestData".
                    "partyId": "str",  # Optional. Party Id.
                    "properties": {
                        "str": {}  # Optional. A collection of key value pairs that belongs
                          to the resource."nEach pair must not have a key greater than 50
                          characters"nand must not have a value greater than 150 characters."nNote: A
                          maximum of 25 key value pairs can be provided for a resource and only
                          string,"nnumeral and datetime (yyyy-MM-ddTHH:mm:ssZ) values are supported.
                    },
                    "source": "str",  # Optional. Source of the resource.
                    "status": "str",  # Optional. Status of the resource.
                    "type": "str"  # Optional. Indicates the type of boundary belonging to a
                      parent.
                }
                # The response is polymorphic. The following are possible polymorphic responses based
                  off discriminator "type":

                # JSON input template for discriminator value "MultiPolygon":
                geo_json_object = {
                    "coordinates": [
                        [
                            [
                                [
                                    0.0  # Gets or sets Coordinates of GeoJSON
                                      Object."nIt must be an array of polygons, each polygon contains
                                      list of linear rings."nFor Polygons with more than one of these
                                      rings, the first MUST be the exterior ring,"nand any others MUST
                                      be interior rings. Required.
                                ]
                            ]
                        ]
                    ],
                    "type": "MultiPolygon"
                }

                # JSON input template for discriminator value "Point":
                geo_json_object = {
                    "coordinates": [
                        0.0  # Gets or sets the coordinate of this point."nIt must be an
                          array of 2 or 3 elements for a 2D or 3D system. Required.
                    ],
                    "type": "Point"
                }

                # JSON input template for discriminator value "Polygon":
                geo_json_object = {
                    "coordinates": [
                        [
                            [
                                0.0  # Gets or sets type of the GeoJSON Object."nIt
                                  must be an array of linear ring coordinate arrays."nFor Polygons with
                                  more than one of these rings, the first MUST be the exterior
                                  ring,"nand any others MUST be interior rings. Required.
                            ]
                        ]
                    ],
                    "type": "Polygon"
                }
                # The response is polymorphic. The following are possible polymorphic responses based
                  off discriminator "type":

                # JSON input template for discriminator value "MultiPolygon":
                geo_json_object = {
                    "coordinates": [
                        [
                            [
                                [
                                    0.0  # Gets or sets Coordinates of GeoJSON
                                      Object."nIt must be an array of polygons, each polygon contains
                                      list of linear rings."nFor Polygons with more than one of these
                                      rings, the first MUST be the exterior ring,"nand any others MUST
                                      be interior rings. Required.
                                ]
                            ]
                        ]
                    ],
                    "type": "MultiPolygon"
                }

                # JSON input template for discriminator value "Point":
                geo_json_object = {
                    "coordinates": [
                        0.0  # Gets or sets the coordinate of this point."nIt must be an
                          array of 2 or 3 elements for a 2D or 3D system. Required.
                    ],
                    "type": "Point"
                }

                # JSON input template for discriminator value "Polygon":
                geo_json_object = {
                    "coordinates": [
                        [
                            [
                                0.0  # Gets or sets type of the GeoJSON Object."nIt
                                  must be an array of linear ring coordinate arrays."nFor Polygons with
                                  more than one of these rings, the first MUST be the exterior
                                  ring,"nand any others MUST be interior rings. Required.
                            ]
                        ]
                    ],
                    "type": "Polygon"
                }

                # response body for status code(s): 200, 201
                response == {
                    "area": {
                        "unit": "str",  # Optional. Data unit.
                        "value": 0.0  # Optional. Data value.
                    },
                    "bbox": geo_json_object,
                    "centroid": geo_json_object,
                    "createdBy": "str",  # Optional. Created by user/tenant id.
                    "createdDateTime": "2020-02-20 00:00:00",  # Optional. Date-time when
                      resource was created, sample format: yyyy-MM-ddTHH:mm:ssZ.
                    "crs": "str",  # Optional. Coordinate  Reference System.
                    "description": "str",  # Optional. Textual description of the resource.
                    "eTag": "str",  # Optional. The ETag value to implement optimistic
                      concurrency.
                    "geometry": geo_json_object,
                    "id": "str",  # Optional. Unique resource ID.
                    "modifiedBy": "str",  # Optional. Modified by user/tenant id.
                    "modifiedDateTime": "2020-02-20 00:00:00",  # Optional. Date-time when
                      resource was last modified, sample format: yyyy-MM-ddTHH:mm:ssZ.
                    "name": "str",  # Optional. Name to identify resource.
                    "parentId": "str",  # Optional. Id of the parent it belongs to.
                    "parentType": "str",  # Optional. Type of the parent it belongs to."ni.e.
                      Field, SeasonalField, Zone, Prescription, PlantTissueAnalysis, ApplicationData,
                      HarvestData, TillageData, PlantingData. Known values are: "Field",
                      "SeasonalField", "Zone", "Prescription", "PlantTissueAnalysis",
                      "ApplicationData", "PlantingData", "TillageData", and "HarvestData".
                    "partyId": "str",  # Optional. Party Id.
                    "properties": {
                        "str": {}  # Optional. A collection of key value pairs that belongs
                          to the resource."nEach pair must not have a key greater than 50
                          characters"nand must not have a value greater than 150 characters."nNote: A
                          maximum of 25 key value pairs can be provided for a resource and only
                          string,"nnumeral and datetime (yyyy-MM-ddTHH:mm:ssZ) values are supported.
                    },
                    "source": "str",  # Optional. Source of the resource.
                    "status": "str",  # Optional. Status of the resource.
                    "type": "str"  # Optional. Indicates the type of boundary belonging to a
                      parent.
                }
        """

    @overload
    def create_or_update(
        self,
        party_id: str,
        boundary_id: str,
        boundary: IO,
        *,
        content_type: str = "application/merge-patch+json",
        **kwargs: Any
    ) -> JSON:
        """Creates or updates a boundary resource.

        :param party_id: Id of the party resource. Required.
        :type party_id: str
        :param boundary_id: Id of the boundary resource. Required.
        :type boundary_id: str
        :param boundary: Boundary resource payload to create or update. Required.
        :type boundary: IO
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Default value is "application/merge-patch+json".
        :paramtype content_type: str
        :return: JSON object
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python
                # The response is polymorphic. The following are possible polymorphic responses based
                  off discriminator "type":

                # JSON input template for discriminator value "MultiPolygon":
                geo_json_object = {
                    "coordinates": [
                        [
                            [
                                [
                                    0.0  # Gets or sets Coordinates of GeoJSON
                                      Object."nIt must be an array of polygons, each polygon contains
                                      list of linear rings."nFor Polygons with more than one of these
                                      rings, the first MUST be the exterior ring,"nand any others MUST
                                      be interior rings. Required.
                                ]
                            ]
                        ]
                    ],
                    "type": "MultiPolygon"
                }

                # JSON input template for discriminator value "Point":
                geo_json_object = {
                    "coordinates": [
                        0.0  # Gets or sets the coordinate of this point."nIt must be an
                          array of 2 or 3 elements for a 2D or 3D system. Required.
                    ],
                    "type": "Point"
                }

                # JSON input template for discriminator value "Polygon":
                geo_json_object = {
                    "coordinates": [
                        [
                            [
                                0.0  # Gets or sets type of the GeoJSON Object."nIt
                                  must be an array of linear ring coordinate arrays."nFor Polygons with
                                  more than one of these rings, the first MUST be the exterior
                                  ring,"nand any others MUST be interior rings. Required.
                            ]
                        ]
                    ],
                    "type": "Polygon"
                }
                # The response is polymorphic. The following are possible polymorphic responses based
                  off discriminator "type":

                # JSON input template for discriminator value "MultiPolygon":
                geo_json_object = {
                    "coordinates": [
                        [
                            [
                                [
                                    0.0  # Gets or sets Coordinates of GeoJSON
                                      Object."nIt must be an array of polygons, each polygon contains
                                      list of linear rings."nFor Polygons with more than one of these
                                      rings, the first MUST be the exterior ring,"nand any others MUST
                                      be interior rings. Required.
                                ]
                            ]
                        ]
                    ],
                    "type": "MultiPolygon"
                }

                # JSON input template for discriminator value "Point":
                geo_json_object = {
                    "coordinates": [
                        0.0  # Gets or sets the coordinate of this point."nIt must be an
                          array of 2 or 3 elements for a 2D or 3D system. Required.
                    ],
                    "type": "Point"
                }

                # JSON input template for discriminator value "Polygon":
                geo_json_object = {
                    "coordinates": [
                        [
                            [
                                0.0  # Gets or sets type of the GeoJSON Object."nIt
                                  must be an array of linear ring coordinate arrays."nFor Polygons with
                                  more than one of these rings, the first MUST be the exterior
                                  ring,"nand any others MUST be interior rings. Required.
                            ]
                        ]
                    ],
                    "type": "Polygon"
                }

                # response body for status code(s): 200, 201
                response == {
                    "area": {
                        "unit": "str",  # Optional. Data unit.
                        "value": 0.0  # Optional. Data value.
                    },
                    "bbox": geo_json_object,
                    "centroid": geo_json_object,
                    "createdBy": "str",  # Optional. Created by user/tenant id.
                    "createdDateTime": "2020-02-20 00:00:00",  # Optional. Date-time when
                      resource was created, sample format: yyyy-MM-ddTHH:mm:ssZ.
                    "crs": "str",  # Optional. Coordinate  Reference System.
                    "description": "str",  # Optional. Textual description of the resource.
                    "eTag": "str",  # Optional. The ETag value to implement optimistic
                      concurrency.
                    "geometry": geo_json_object,
                    "id": "str",  # Optional. Unique resource ID.
                    "modifiedBy": "str",  # Optional. Modified by user/tenant id.
                    "modifiedDateTime": "2020-02-20 00:00:00",  # Optional. Date-time when
                      resource was last modified, sample format: yyyy-MM-ddTHH:mm:ssZ.
                    "name": "str",  # Optional. Name to identify resource.
                    "parentId": "str",  # Optional. Id of the parent it belongs to.
                    "parentType": "str",  # Optional. Type of the parent it belongs to."ni.e.
                      Field, SeasonalField, Zone, Prescription, PlantTissueAnalysis, ApplicationData,
                      HarvestData, TillageData, PlantingData. Known values are: "Field",
                      "SeasonalField", "Zone", "Prescription", "PlantTissueAnalysis",
                      "ApplicationData", "PlantingData", "TillageData", and "HarvestData".
                    "partyId": "str",  # Optional. Party Id.
                    "properties": {
                        "str": {}  # Optional. A collection of key value pairs that belongs
                          to the resource."nEach pair must not have a key greater than 50
                          characters"nand must not have a value greater than 150 characters."nNote: A
                          maximum of 25 key value pairs can be provided for a resource and only
                          string,"nnumeral and datetime (yyyy-MM-ddTHH:mm:ssZ) values are supported.
                    },
                    "source": "str",  # Optional. Source of the resource.
                    "status": "str",  # Optional. Status of the resource.
                    "type": "str"  # Optional. Indicates the type of boundary belonging to a
                      parent.
                }
        """

    @distributed_trace
    def create_or_update(self, party_id: str, boundary_id: str, boundary: Union[JSON, IO], **kwargs: Any) -> JSON:
        """Creates or updates a boundary resource.

        :param party_id: Id of the party resource. Required.
        :type party_id: str
        :param boundary_id: Id of the boundary resource. Required.
        :type boundary_id: str
        :param boundary: Boundary resource payload to create or update. Is either a model type or a IO
         type. Required.
        :type boundary: JSON or IO
        :keyword content_type: Body Parameter content-type. Known values are:
         'application/merge-patch+json'. Default value is None.
        :paramtype content_type: str
        :return: JSON object
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python
                # The response is polymorphic. The following are possible polymorphic responses based
                  off discriminator "type":

                # JSON input template for discriminator value "MultiPolygon":
                geo_json_object = {
                    "coordinates": [
                        [
                            [
                                [
                                    0.0  # Gets or sets Coordinates of GeoJSON
                                      Object."nIt must be an array of polygons, each polygon contains
                                      list of linear rings."nFor Polygons with more than one of these
                                      rings, the first MUST be the exterior ring,"nand any others MUST
                                      be interior rings. Required.
                                ]
                            ]
                        ]
                    ],
                    "type": "MultiPolygon"
                }

                # JSON input template for discriminator value "Point":
                geo_json_object = {
                    "coordinates": [
                        0.0  # Gets or sets the coordinate of this point."nIt must be an
                          array of 2 or 3 elements for a 2D or 3D system. Required.
                    ],
                    "type": "Point"
                }

                # JSON input template for discriminator value "Polygon":
                geo_json_object = {
                    "coordinates": [
                        [
                            [
                                0.0  # Gets or sets type of the GeoJSON Object."nIt
                                  must be an array of linear ring coordinate arrays."nFor Polygons with
                                  more than one of these rings, the first MUST be the exterior
                                  ring,"nand any others MUST be interior rings. Required.
                            ]
                        ]
                    ],
                    "type": "Polygon"
                }
                # The response is polymorphic. The following are possible polymorphic responses based
                  off discriminator "type":

                # JSON input template for discriminator value "MultiPolygon":
                geo_json_object = {
                    "coordinates": [
                        [
                            [
                                [
                                    0.0  # Gets or sets Coordinates of GeoJSON
                                      Object."nIt must be an array of polygons, each polygon contains
                                      list of linear rings."nFor Polygons with more than one of these
                                      rings, the first MUST be the exterior ring,"nand any others MUST
                                      be interior rings. Required.
                                ]
                            ]
                        ]
                    ],
                    "type": "MultiPolygon"
                }

                # JSON input template for discriminator value "Point":
                geo_json_object = {
                    "coordinates": [
                        0.0  # Gets or sets the coordinate of this point."nIt must be an
                          array of 2 or 3 elements for a 2D or 3D system. Required.
                    ],
                    "type": "Point"
                }

                # JSON input template for discriminator value "Polygon":
                geo_json_object = {
                    "coordinates": [
                        [
                            [
                                0.0  # Gets or sets type of the GeoJSON Object."nIt
                                  must be an array of linear ring coordinate arrays."nFor Polygons with
                                  more than one of these rings, the first MUST be the exterior
                                  ring,"nand any others MUST be interior rings. Required.
                            ]
                        ]
                    ],
                    "type": "Polygon"
                }

                # response body for status code(s): 200, 201
                response == {
                    "area": {
                        "unit": "str",  # Optional. Data unit.
                        "value": 0.0  # Optional. Data value.
                    },
                    "bbox": geo_json_object,
                    "centroid": geo_json_object,
                    "createdBy": "str",  # Optional. Created by user/tenant id.
                    "createdDateTime": "2020-02-20 00:00:00",  # Optional. Date-time when
                      resource was created, sample format: yyyy-MM-ddTHH:mm:ssZ.
                    "crs": "str",  # Optional. Coordinate  Reference System.
                    "description": "str",  # Optional. Textual description of the resource.
                    "eTag": "str",  # Optional. The ETag value to implement optimistic
                      concurrency.
                    "geometry": geo_json_object,
                    "id": "str",  # Optional. Unique resource ID.
                    "modifiedBy": "str",  # Optional. Modified by user/tenant id.
                    "modifiedDateTime": "2020-02-20 00:00:00",  # Optional. Date-time when
                      resource was last modified, sample format: yyyy-MM-ddTHH:mm:ssZ.
                    "name": "str",  # Optional. Name to identify resource.
                    "parentId": "str",  # Optional. Id of the parent it belongs to.
                    "parentType": "str",  # Optional. Type of the parent it belongs to."ni.e.
                      Field, SeasonalField, Zone, Prescription, PlantTissueAnalysis, ApplicationData,
                      HarvestData, TillageData, PlantingData. Known values are: "Field",
                      "SeasonalField", "Zone", "Prescription", "PlantTissueAnalysis",
                      "ApplicationData", "PlantingData", "TillageData", and "HarvestData".
                    "partyId": "str",  # Optional. Party Id.
                    "properties": {
                        "str": {}  # Optional. A collection of key value pairs that belongs
                          to the resource."nEach pair must not have a key greater than 50
                          characters"nand must not have a value greater than 150 characters."nNote: A
                          maximum of 25 key value pairs can be provided for a resource and only
                          string,"nnumeral and datetime (yyyy-MM-ddTHH:mm:ssZ) values are supported.
                    },
                    "source": "str",  # Optional. Source of the resource.
                    "status": "str",  # Optional. Status of the resource.
                    "type": "str"  # Optional. Indicates the type of boundary belonging to a
                      parent.
                }
        """
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type = kwargs.pop("content_type", _headers.pop("Content-Type", None))  # type: Optional[str]
        cls = kwargs.pop("cls", None)  # type: ClsType[JSON]

        content_type = content_type or "application/merge-patch+json"
        _json = None
        _content = None
        if isinstance(boundary, (IO, bytes)):
            _content = boundary
        else:
            _json = boundary

        request = build_boundaries_create_or_update_request(
            party_id=party_id,
            boundary_id=boundary_id,
            content_type=content_type,
            api_version=self._config.api_version,
            json=_json,
            content=_content,
            headers=_headers,
            params=_params,
        )
        request.url = self._client.format_url(request.url)  # type: ignore

        pipeline_response = self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
            request, stream=False, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200, 201]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if response.status_code == 200:
            if response.content:
                deserialized = response.json()
            else:
                deserialized = None

        if response.status_code == 201:
            if response.content:
                deserialized = response.json()
            else:
                deserialized = None

        if cls:
            return cls(pipeline_response, cast(JSON, deserialized), {})

        return cast(JSON, deserialized)

    @distributed_trace
    def get(self, party_id: str, boundary_id: str, **kwargs: Any) -> JSON:
        """Gets a specified boundary resource under a particular party.

        :param party_id: Id of the associated party. Required.
        :type party_id: str
        :param boundary_id: Id of the boundary. Required.
        :type boundary_id: str
        :return: JSON object
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python
                # The response is polymorphic. The following are possible polymorphic responses based
                  off discriminator "type":

                # JSON input template for discriminator value "MultiPolygon":
                geo_json_object = {
                    "coordinates": [
                        [
                            [
                                [
                                    0.0  # Gets or sets Coordinates of GeoJSON
                                      Object."nIt must be an array of polygons, each polygon contains
                                      list of linear rings."nFor Polygons with more than one of these
                                      rings, the first MUST be the exterior ring,"nand any others MUST
                                      be interior rings. Required.
                                ]
                            ]
                        ]
                    ],
                    "type": "MultiPolygon"
                }

                # JSON input template for discriminator value "Point":
                geo_json_object = {
                    "coordinates": [
                        0.0  # Gets or sets the coordinate of this point."nIt must be an
                          array of 2 or 3 elements for a 2D or 3D system. Required.
                    ],
                    "type": "Point"
                }

                # JSON input template for discriminator value "Polygon":
                geo_json_object = {
                    "coordinates": [
                        [
                            [
                                0.0  # Gets or sets type of the GeoJSON Object."nIt
                                  must be an array of linear ring coordinate arrays."nFor Polygons with
                                  more than one of these rings, the first MUST be the exterior
                                  ring,"nand any others MUST be interior rings. Required.
                            ]
                        ]
                    ],
                    "type": "Polygon"
                }

                # response body for status code(s): 200
                response == {
                    "area": {
                        "unit": "str",  # Optional. Data unit.
                        "value": 0.0  # Optional. Data value.
                    },
                    "bbox": geo_json_object,
                    "centroid": geo_json_object,
                    "createdBy": "str",  # Optional. Created by user/tenant id.
                    "createdDateTime": "2020-02-20 00:00:00",  # Optional. Date-time when
                      resource was created, sample format: yyyy-MM-ddTHH:mm:ssZ.
                    "crs": "str",  # Optional. Coordinate  Reference System.
                    "description": "str",  # Optional. Textual description of the resource.
                    "eTag": "str",  # Optional. The ETag value to implement optimistic
                      concurrency.
                    "geometry": geo_json_object,
                    "id": "str",  # Optional. Unique resource ID.
                    "modifiedBy": "str",  # Optional. Modified by user/tenant id.
                    "modifiedDateTime": "2020-02-20 00:00:00",  # Optional. Date-time when
                      resource was last modified, sample format: yyyy-MM-ddTHH:mm:ssZ.
                    "name": "str",  # Optional. Name to identify resource.
                    "parentId": "str",  # Optional. Id of the parent it belongs to.
                    "parentType": "str",  # Optional. Type of the parent it belongs to."ni.e.
                      Field, SeasonalField, Zone, Prescription, PlantTissueAnalysis, ApplicationData,
                      HarvestData, TillageData, PlantingData. Known values are: "Field",
                      "SeasonalField", "Zone", "Prescription", "PlantTissueAnalysis",
                      "ApplicationData", "PlantingData", "TillageData", and "HarvestData".
                    "partyId": "str",  # Optional. Party Id.
                    "properties": {
                        "str": {}  # Optional. A collection of key value pairs that belongs
                          to the resource."nEach pair must not have a key greater than 50
                          characters"nand must not have a value greater than 150 characters."nNote: A
                          maximum of 25 key value pairs can be provided for a resource and only
                          string,"nnumeral and datetime (yyyy-MM-ddTHH:mm:ssZ) values are supported.
                    },
                    "source": "str",  # Optional. Source of the resource.
                    "status": "str",  # Optional. Status of the resource.
                    "type": "str"  # Optional. Indicates the type of boundary belonging to a
                      parent.
                }
        """
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls = kwargs.pop("cls", None)  # type: ClsType[JSON]

        request = build_boundaries_get_request(
            party_id=party_id,
            boundary_id=boundary_id,
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        request.url = self._client.format_url(request.url)  # type: ignore

        pipeline_response = self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
            request, stream=False, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if response.content:
            deserialized = response.json()
        else:
            deserialized = None

        if cls:
            return cls(pipeline_response, cast(JSON, deserialized), {})

        return cast(JSON, deserialized)

    @distributed_trace
    def delete(  # pylint: disable=inconsistent-return-statements
        self, party_id: str, boundary_id: str, **kwargs: Any
    ) -> None:
        """Deletes a specified boundary resource under a particular party.

        :param party_id: Id of the party. Required.
        :type party_id: str
        :param boundary_id: Id of the boundary. Required.
        :type boundary_id: str
        :return: None
        :rtype: None
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls = kwargs.pop("cls", None)  # type: ClsType[None]

        request = build_boundaries_delete_request(
            party_id=party_id,
            boundary_id=boundary_id,
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        request.url = self._client.format_url(request.url)  # type: ignore

        pipeline_response = self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
            request, stream=False, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [204]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if cls:
            return cls(pipeline_response, None, {})

    @distributed_trace
    def get_overlap(
        self, party_id: str, boundary_id: str, *, other_party_id: str, other_boundary_id: str, **kwargs: Any
    ) -> JSON:
        """Returns overlapping area between two boundary Ids.

        :param party_id: Id of the party. Required.
        :type party_id: str
        :param boundary_id: Id of the boundary. Required.
        :type boundary_id: str
        :keyword other_party_id: PartyId of the other field. Required.
        :paramtype other_party_id: str
        :keyword other_boundary_id: Id of the other boundary. Required.
        :paramtype other_boundary_id: str
        :return: JSON object
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "boundaryArea": 0.0,  # Optional. Acreage of Main boundary.
                    "intersectingArea": 0.0,  # Optional. Acreage of intersecting boundary.
                    "otherBoundaryArea": 0.0  # Optional. Acreage of other boundary.
                }
        """
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls = kwargs.pop("cls", None)  # type: ClsType[JSON]

        request = build_boundaries_get_overlap_request(
            party_id=party_id,
            boundary_id=boundary_id,
            other_party_id=other_party_id,
            other_boundary_id=other_boundary_id,
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        request.url = self._client.format_url(request.url)  # type: ignore

        pipeline_response = self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
            request, stream=False, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if response.content:
            deserialized = response.json()
        else:
            deserialized = None

        if cls:
            return cls(pipeline_response, cast(JSON, deserialized), {})

        return cast(JSON, deserialized)


class CropProductsOperations:
    """
    .. warning::
        **DO NOT** instantiate this class directly.

        Instead, you should access the following operations through
        :class:`~azure.agrifood.farming.FarmBeatsClient`'s
        :attr:`crop_products` attribute.
    """

    def __init__(self, *args, **kwargs):
        input_args = list(args)
        self._client = input_args.pop(0) if input_args else kwargs.pop("client")
        self._config = input_args.pop(0) if input_args else kwargs.pop("config")
        self._serialize = input_args.pop(0) if input_args else kwargs.pop("serializer")
        self._deserialize = input_args.pop(0) if input_args else kwargs.pop("deserializer")

    @distributed_trace
    def list(
        self,
        *,
        crop_ids: Optional[List[str]] = None,
        brands: Optional[List[str]] = None,
        products: Optional[List[str]] = None,
        traits: Optional[List[str]] = None,
        ids: Optional[List[str]] = None,
        names: Optional[List[str]] = None,
        property_filters: Optional[List[str]] = None,
        statuses: Optional[List[str]] = None,
        min_created_date_time: Optional[datetime.datetime] = None,
        max_created_date_time: Optional[datetime.datetime] = None,
        min_last_modified_date_time: Optional[datetime.datetime] = None,
        max_last_modified_date_time: Optional[datetime.datetime] = None,
        skip_token: Optional[str] = None,
        **kwargs: Any
    ) -> Iterable[JSON]:
        """Returns a paginated list of crop product resources.

        :keyword crop_ids: CropIds of the resource. Default value is None.
        :paramtype crop_ids: list[str]
        :keyword brands: Brands of the resource. Default value is None.
        :paramtype brands: list[str]
        :keyword products: Products of the resource. Default value is None.
        :paramtype products: list[str]
        :keyword traits: Traits of the resource. Default value is None.
        :paramtype traits: list[str]
        :keyword ids: Ids of the resource. Default value is None.
        :paramtype ids: list[str]
        :keyword names: Names of the resource. Default value is None.
        :paramtype names: list[str]
        :keyword property_filters: Filters on key-value pairs within the Properties object.
         eg. "{testKey} eq {testValue}". Default value is None.
        :paramtype property_filters: list[str]
        :keyword statuses: Statuses of the resource. Default value is None.
        :paramtype statuses: list[str]
        :keyword min_created_date_time: Minimum creation date of resource (inclusive). Default value is
         None.
        :paramtype min_created_date_time: ~datetime.datetime
        :keyword max_created_date_time: Maximum creation date of resource (inclusive). Default value is
         None.
        :paramtype max_created_date_time: ~datetime.datetime
        :keyword min_last_modified_date_time: Minimum last modified date of resource (inclusive).
         Default value is None.
        :paramtype min_last_modified_date_time: ~datetime.datetime
        :keyword max_last_modified_date_time: Maximum last modified date of resource (inclusive).
         Default value is None.
        :paramtype max_last_modified_date_time: ~datetime.datetime
        :keyword skip_token: Skip token for getting next set of results. Default value is None.
        :paramtype skip_token: str
        :return: An iterator like instance of JSON object
        :rtype: ~azure.core.paging.ItemPaged[JSON]
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "brand": "str",  # Optional. CropProduct Brand.
                    "createdBy": "str",  # Optional. Created by user/tenant id.
                    "createdDateTime": "2020-02-20 00:00:00",  # Optional. Date-time when
                      resource was created, sample format: yyyy-MM-ddTHH:mm:ssZ.
                    "cropIds": [
                        "str"  # Optional. Ids of the crops it belongs to."nNote: A maximum
                          of 25 crops can be associated with a cropProduct.
                    ],
                    "description": "str",  # Optional. Textual description of the resource.
                    "eTag": "str",  # Optional. The ETag value to implement optimistic
                      concurrency.
                    "id": "str",  # Optional. Unique resource ID.
                    "modifiedBy": "str",  # Optional. Modified by user/tenant id.
                    "modifiedDateTime": "2020-02-20 00:00:00",  # Optional. Date-time when
                      resource was last modified, sample format: yyyy-MM-ddTHH:mm:ssZ.
                    "name": "str",  # Optional. Name to identify resource.
                    "product": "str",  # Optional. CropProduct product.
                    "properties": {
                        "str": {}  # Optional. A collection of key value pairs that belongs
                          to the resource."nEach pair must not have a key greater than 50
                          characters"nand must not have a value greater than 150 characters."nNote: A
                          maximum of 25 key value pairs can be provided for a resource and only
                          string,"nnumeral and datetime (yyyy-MM-ddTHH:mm:ssZ) values are supported.
                    },
                    "relativeMaturity": {
                        "unit": "str",  # Optional. Data unit.
                        "value": 0.0  # Optional. Data value.
                    },
                    "source": "str",  # Optional. Source of the resource.
                    "status": "str",  # Optional. Status of the resource.
                    "trait": "str",  # Optional. CropProduct trait.
                    "treatments": [
                        "str"  # Optional. CropProduct treatments.
                    ]
                }
        """
        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls = kwargs.pop("cls", None)  # type: ClsType[JSON]

        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        def prepare_request(next_link=None):
            if not next_link:

                request = build_crop_products_list_request(
                    crop_ids=crop_ids,
                    brands=brands,
                    products=products,
                    traits=traits,
                    ids=ids,
                    names=names,
                    property_filters=property_filters,
                    statuses=statuses,
                    min_created_date_time=min_created_date_time,
                    max_created_date_time=max_created_date_time,
                    min_last_modified_date_time=min_last_modified_date_time,
                    max_last_modified_date_time=max_last_modified_date_time,
                    skip_token=skip_token,
                    api_version=self._config.api_version,
                    headers=_headers,
                    params=_params,
                )
                request.url = self._client.format_url(request.url)  # type: ignore

            else:
                # make call to next link with the client's api-version
                _parsed_next_link = urlparse(next_link)
                _next_request_params = case_insensitive_dict(parse_qs(_parsed_next_link.query))
                _next_request_params["api-version"] = self._config.api_version
                request = HttpRequest("GET", urljoin(next_link, _parsed_next_link.path), params=_next_request_params)
                request.url = self._client.format_url(request.url)  # type: ignore

            return request

        def extract_data(pipeline_response):
            deserialized = pipeline_response.http_response.json()
            list_of_elem = deserialized["value"]
            if cls:
                list_of_elem = cls(list_of_elem)
            return deserialized.get("nextLink", None), iter(list_of_elem)

        def get_next(next_link=None):
            request = prepare_request(next_link)

            pipeline_response = self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
                request, stream=False, **kwargs
            )
            response = pipeline_response.http_response

            if response.status_code not in [200]:
                map_error(status_code=response.status_code, response=response, error_map=error_map)
                raise HttpResponseError(response=response)

            return pipeline_response

        return ItemPaged(get_next, extract_data)

    @distributed_trace
    def get(self, crop_product_id: str, **kwargs: Any) -> JSON:
        """Gets a specified crop Product resource.

        :param crop_product_id: Id of the crop Product. Required.
        :type crop_product_id: str
        :return: JSON object
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "brand": "str",  # Optional. CropProduct Brand.
                    "createdBy": "str",  # Optional. Created by user/tenant id.
                    "createdDateTime": "2020-02-20 00:00:00",  # Optional. Date-time when
                      resource was created, sample format: yyyy-MM-ddTHH:mm:ssZ.
                    "cropIds": [
                        "str"  # Optional. Ids of the crops it belongs to."nNote: A maximum
                          of 25 crops can be associated with a cropProduct.
                    ],
                    "description": "str",  # Optional. Textual description of the resource.
                    "eTag": "str",  # Optional. The ETag value to implement optimistic
                      concurrency.
                    "id": "str",  # Optional. Unique resource ID.
                    "modifiedBy": "str",  # Optional. Modified by user/tenant id.
                    "modifiedDateTime": "2020-02-20 00:00:00",  # Optional. Date-time when
                      resource was last modified, sample format: yyyy-MM-ddTHH:mm:ssZ.
                    "name": "str",  # Optional. Name to identify resource.
                    "product": "str",  # Optional. CropProduct product.
                    "properties": {
                        "str": {}  # Optional. A collection of key value pairs that belongs
                          to the resource."nEach pair must not have a key greater than 50
                          characters"nand must not have a value greater than 150 characters."nNote: A
                          maximum of 25 key value pairs can be provided for a resource and only
                          string,"nnumeral and datetime (yyyy-MM-ddTHH:mm:ssZ) values are supported.
                    },
                    "relativeMaturity": {
                        "unit": "str",  # Optional. Data unit.
                        "value": 0.0  # Optional. Data value.
                    },
                    "source": "str",  # Optional. Source of the resource.
                    "status": "str",  # Optional. Status of the resource.
                    "trait": "str",  # Optional. CropProduct trait.
                    "treatments": [
                        "str"  # Optional. CropProduct treatments.
                    ]
                }
        """
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls = kwargs.pop("cls", None)  # type: ClsType[JSON]

        request = build_crop_products_get_request(
            crop_product_id=crop_product_id,
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        request.url = self._client.format_url(request.url)  # type: ignore

        pipeline_response = self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
            request, stream=False, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if response.content:
            deserialized = response.json()
        else:
            deserialized = None

        if cls:
            return cls(pipeline_response, cast(JSON, deserialized), {})

        return cast(JSON, deserialized)

    @overload
    def create_or_update(
        self,
        crop_product_id: str,
        crop_product: JSON,
        *,
        content_type: str = "application/merge-patch+json",
        **kwargs: Any
    ) -> JSON:
        """Creates or updates a crop Product resource.

        :param crop_product_id: Id of the crop Product resource. Required.
        :type crop_product_id: str
        :param crop_product: Crop Product resource payload to create or update. Required.
        :type crop_product: JSON
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/merge-patch+json".
        :paramtype content_type: str
        :return: JSON object
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                crop_product = {
                    "brand": "str",  # Optional. CropProduct Brand.
                    "createdBy": "str",  # Optional. Created by user/tenant id.
                    "createdDateTime": "2020-02-20 00:00:00",  # Optional. Date-time when
                      resource was created, sample format: yyyy-MM-ddTHH:mm:ssZ.
                    "cropIds": [
                        "str"  # Optional. Ids of the crops it belongs to."nNote: A maximum
                          of 25 crops can be associated with a cropProduct.
                    ],
                    "description": "str",  # Optional. Textual description of the resource.
                    "eTag": "str",  # Optional. The ETag value to implement optimistic
                      concurrency.
                    "id": "str",  # Optional. Unique resource ID.
                    "modifiedBy": "str",  # Optional. Modified by user/tenant id.
                    "modifiedDateTime": "2020-02-20 00:00:00",  # Optional. Date-time when
                      resource was last modified, sample format: yyyy-MM-ddTHH:mm:ssZ.
                    "name": "str",  # Optional. Name to identify resource.
                    "product": "str",  # Optional. CropProduct product.
                    "properties": {
                        "str": {}  # Optional. A collection of key value pairs that belongs
                          to the resource."nEach pair must not have a key greater than 50
                          characters"nand must not have a value greater than 150 characters."nNote: A
                          maximum of 25 key value pairs can be provided for a resource and only
                          string,"nnumeral and datetime (yyyy-MM-ddTHH:mm:ssZ) values are supported.
                    },
                    "relativeMaturity": {
                        "unit": "str",  # Optional. Data unit.
                        "value": 0.0  # Optional. Data value.
                    },
                    "source": "str",  # Optional. Source of the resource.
                    "status": "str",  # Optional. Status of the resource.
                    "trait": "str",  # Optional. CropProduct trait.
                    "treatments": [
                        "str"  # Optional. CropProduct treatments.
                    ]
                }

                # response body for status code(s): 200, 201
                response == {
                    "brand": "str",  # Optional. CropProduct Brand.
                    "createdBy": "str",  # Optional. Created by user/tenant id.
                    "createdDateTime": "2020-02-20 00:00:00",  # Optional. Date-time when
                      resource was created, sample format: yyyy-MM-ddTHH:mm:ssZ.
                    "cropIds": [
                        "str"  # Optional. Ids of the crops it belongs to."nNote: A maximum
                          of 25 crops can be associated with a cropProduct.
                    ],
                    "description": "str",  # Optional. Textual description of the resource.
                    "eTag": "str",  # Optional. The ETag value to implement optimistic
                      concurrency.
                    "id": "str",  # Optional. Unique resource ID.
                    "modifiedBy": "str",  # Optional. Modified by user/tenant id.
                    "modifiedDateTime": "2020-02-20 00:00:00",  # Optional. Date-time when
                      resource was last modified, sample format: yyyy-MM-ddTHH:mm:ssZ.
                    "name": "str",  # Optional. Name to identify resource.
                    "product": "str",  # Optional. CropProduct product.
                    "properties": {
                        "str": {}  # Optional. A collection of key value pairs that belongs
                          to the resource."nEach pair must not have a key greater than 50
                          characters"nand must not have a value greater than 150 characters."nNote: A
                          maximum of 25 key value pairs can be provided for a resource and only
                          string,"nnumeral and datetime (yyyy-MM-ddTHH:mm:ssZ) values are supported.
                    },
                    "relativeMaturity": {
                        "unit": "str",  # Optional. Data unit.
                        "value": 0.0  # Optional. Data value.
                    },
                    "source": "str",  # Optional. Source of the resource.
                    "status": "str",  # Optional. Status of the resource.
                    "trait": "str",  # Optional. CropProduct trait.
                    "treatments": [
                        "str"  # Optional. CropProduct treatments.
                    ]
                }
        """

    @overload
    def create_or_update(
        self,
        crop_product_id: str,
        crop_product: IO,
        *,
        content_type: str = "application/merge-patch+json",
        **kwargs: Any
    ) -> JSON:
        """Creates or updates a crop Product resource.

        :param crop_product_id: Id of the crop Product resource. Required.
        :type crop_product_id: str
        :param crop_product: Crop Product resource payload to create or update. Required.
        :type crop_product: IO
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Default value is "application/merge-patch+json".
        :paramtype content_type: str
        :return: JSON object
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200, 201
                response == {
                    "brand": "str",  # Optional. CropProduct Brand.
                    "createdBy": "str",  # Optional. Created by user/tenant id.
                    "createdDateTime": "2020-02-20 00:00:00",  # Optional. Date-time when
                      resource was created, sample format: yyyy-MM-ddTHH:mm:ssZ.
                    "cropIds": [
                        "str"  # Optional. Ids of the crops it belongs to."nNote: A maximum
                          of 25 crops can be associated with a cropProduct.
                    ],
                    "description": "str",  # Optional. Textual description of the resource.
                    "eTag": "str",  # Optional. The ETag value to implement optimistic
                      concurrency.
                    "id": "str",  # Optional. Unique resource ID.
                    "modifiedBy": "str",  # Optional. Modified by user/tenant id.
                    "modifiedDateTime": "2020-02-20 00:00:00",  # Optional. Date-time when
                      resource was last modified, sample format: yyyy-MM-ddTHH:mm:ssZ.
                    "name": "str",  # Optional. Name to identify resource.
                    "product": "str",  # Optional. CropProduct product.
                    "properties": {
                        "str": {}  # Optional. A collection of key value pairs that belongs
                          to the resource."nEach pair must not have a key greater than 50
                          characters"nand must not have a value greater than 150 characters."nNote: A
                          maximum of 25 key value pairs can be provided for a resource and only
                          string,"nnumeral and datetime (yyyy-MM-ddTHH:mm:ssZ) values are supported.
                    },
                    "relativeMaturity": {
                        "unit": "str",  # Optional. Data unit.
                        "value": 0.0  # Optional. Data value.
                    },
                    "source": "str",  # Optional. Source of the resource.
                    "status": "str",  # Optional. Status of the resource.
                    "trait": "str",  # Optional. CropProduct trait.
                    "treatments": [
                        "str"  # Optional. CropProduct treatments.
                    ]
                }
        """

    @distributed_trace
    def create_or_update(self, crop_product_id: str, crop_product: Union[JSON, IO], **kwargs: Any) -> JSON:
        """Creates or updates a crop Product resource.

        :param crop_product_id: Id of the crop Product resource. Required.
        :type crop_product_id: str
        :param crop_product: Crop Product resource payload to create or update. Is either a model type
         or a IO type. Required.
        :type crop_product: JSON or IO
        :keyword content_type: Body Parameter content-type. Known values are:
         'application/merge-patch+json'. Default value is None.
        :paramtype content_type: str
        :return: JSON object
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200, 201
                response == {
                    "brand": "str",  # Optional. CropProduct Brand.
                    "createdBy": "str",  # Optional. Created by user/tenant id.
                    "createdDateTime": "2020-02-20 00:00:00",  # Optional. Date-time when
                      resource was created, sample format: yyyy-MM-ddTHH:mm:ssZ.
                    "cropIds": [
                        "str"  # Optional. Ids of the crops it belongs to."nNote: A maximum
                          of 25 crops can be associated with a cropProduct.
                    ],
                    "description": "str",  # Optional. Textual description of the resource.
                    "eTag": "str",  # Optional. The ETag value to implement optimistic
                      concurrency.
                    "id": "str",  # Optional. Unique resource ID.
                    "modifiedBy": "str",  # Optional. Modified by user/tenant id.
                    "modifiedDateTime": "2020-02-20 00:00:00",  # Optional. Date-time when
                      resource was last modified, sample format: yyyy-MM-ddTHH:mm:ssZ.
                    "name": "str",  # Optional. Name to identify resource.
                    "product": "str",  # Optional. CropProduct product.
                    "properties": {
                        "str": {}  # Optional. A collection of key value pairs that belongs
                          to the resource."nEach pair must not have a key greater than 50
                          characters"nand must not have a value greater than 150 characters."nNote: A
                          maximum of 25 key value pairs can be provided for a resource and only
                          string,"nnumeral and datetime (yyyy-MM-ddTHH:mm:ssZ) values are supported.
                    },
                    "relativeMaturity": {
                        "unit": "str",  # Optional. Data unit.
                        "value": 0.0  # Optional. Data value.
                    },
                    "source": "str",  # Optional. Source of the resource.
                    "status": "str",  # Optional. Status of the resource.
                    "trait": "str",  # Optional. CropProduct trait.
                    "treatments": [
                        "str"  # Optional. CropProduct treatments.
                    ]
                }
        """
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type = kwargs.pop("content_type", _headers.pop("Content-Type", None))  # type: Optional[str]
        cls = kwargs.pop("cls", None)  # type: ClsType[JSON]

        content_type = content_type or "application/merge-patch+json"
        _json = None
        _content = None
        if isinstance(crop_product, (IO, bytes)):
            _content = crop_product
        else:
            _json = crop_product

        request = build_crop_products_create_or_update_request(
            crop_product_id=crop_product_id,
            content_type=content_type,
            api_version=self._config.api_version,
            json=_json,
            content=_content,
            headers=_headers,
            params=_params,
        )
        request.url = self._client.format_url(request.url)  # type: ignore

        pipeline_response = self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
            request, stream=False, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200, 201]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if response.status_code == 200:
            if response.content:
                deserialized = response.json()
            else:
                deserialized = None

        if response.status_code == 201:
            if response.content:
                deserialized = response.json()
            else:
                deserialized = None

        if cls:
            return cls(pipeline_response, cast(JSON, deserialized), {})

        return cast(JSON, deserialized)

    @distributed_trace
    def delete(self, crop_product_id: str, **kwargs: Any) -> None:  # pylint: disable=inconsistent-return-statements
        """Deletes a specified crop Product resource.

        :param crop_product_id: Id of the crop Product. Required.
        :type crop_product_id: str
        :return: None
        :rtype: None
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls = kwargs.pop("cls", None)  # type: ClsType[None]

        request = build_crop_products_delete_request(
            crop_product_id=crop_product_id,
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        request.url = self._client.format_url(request.url)  # type: ignore

        pipeline_response = self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
            request, stream=False, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [204]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if cls:
            return cls(pipeline_response, None, {})


class CropsOperations:
    """
    .. warning::
        **DO NOT** instantiate this class directly.

        Instead, you should access the following operations through
        :class:`~azure.agrifood.farming.FarmBeatsClient`'s
        :attr:`crops` attribute.
    """

    def __init__(self, *args, **kwargs):
        input_args = list(args)
        self._client = input_args.pop(0) if input_args else kwargs.pop("client")
        self._config = input_args.pop(0) if input_args else kwargs.pop("config")
        self._serialize = input_args.pop(0) if input_args else kwargs.pop("serializer")
        self._deserialize = input_args.pop(0) if input_args else kwargs.pop("deserializer")

    @distributed_trace
    def list(
        self,
        *,
        phenotypes: Optional[List[str]] = None,
        breeding_methods: Optional[List[str]] = None,
        ids: Optional[List[str]] = None,
        names: Optional[List[str]] = None,
        property_filters: Optional[List[str]] = None,
        statuses: Optional[List[str]] = None,
        min_created_date_time: Optional[datetime.datetime] = None,
        max_created_date_time: Optional[datetime.datetime] = None,
        min_last_modified_date_time: Optional[datetime.datetime] = None,
        max_last_modified_date_time: Optional[datetime.datetime] = None,
        skip_token: Optional[str] = None,
        **kwargs: Any
    ) -> Iterable[JSON]:
        """Returns a paginated list of crop resources.

        :keyword phenotypes: Crop phenotypes of the resource. Default value is None.
        :paramtype phenotypes: list[str]
        :keyword breeding_methods: Breeding method of the resource. Default value is None.
        :paramtype breeding_methods: list[str]
        :keyword ids: Ids of the resource. Default value is None.
        :paramtype ids: list[str]
        :keyword names: Names of the resource. Default value is None.
        :paramtype names: list[str]
        :keyword property_filters: Filters on key-value pairs within the Properties object.
         eg. "{testKey} eq {testValue}". Default value is None.
        :paramtype property_filters: list[str]
        :keyword statuses: Statuses of the resource. Default value is None.
        :paramtype statuses: list[str]
        :keyword min_created_date_time: Minimum creation date of resource (inclusive). Default value is
         None.
        :paramtype min_created_date_time: ~datetime.datetime
        :keyword max_created_date_time: Maximum creation date of resource (inclusive). Default value is
         None.
        :paramtype max_created_date_time: ~datetime.datetime
        :keyword min_last_modified_date_time: Minimum last modified date of resource (inclusive).
         Default value is None.
        :paramtype min_last_modified_date_time: ~datetime.datetime
        :keyword max_last_modified_date_time: Maximum last modified date of resource (inclusive).
         Default value is None.
        :paramtype max_last_modified_date_time: ~datetime.datetime
        :keyword skip_token: Skip token for getting next set of results. Default value is None.
        :paramtype skip_token: str
        :return: An iterator like instance of JSON object
        :rtype: ~azure.core.paging.ItemPaged[JSON]
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "breedingMethod": "str",  # Optional. Breeding Method. Known values are:
                      "VARIETY", "HYBRID", and "UNKNOWN".
                    "createdBy": "str",  # Optional. Created by user/tenant id.
                    "createdDateTime": "2020-02-20 00:00:00",  # Optional. Date-time when
                      resource was created, sample format: yyyy-MM-ddTHH:mm:ssZ.
                    "description": "str",  # Optional. Textual description of the resource.
                    "eTag": "str",  # Optional. The ETag value to implement optimistic
                      concurrency.
                    "id": "str",  # Optional. Unique resource ID.
                    "measurements": {
                        "str": {
                            "unit": "str",  # Optional. Data unit.
                            "value": 0.0  # Optional. Data value.
                        }
                    },
                    "modifiedBy": "str",  # Optional. Modified by user/tenant id.
                    "modifiedDateTime": "2020-02-20 00:00:00",  # Optional. Date-time when
                      resource was last modified, sample format: yyyy-MM-ddTHH:mm:ssZ.
                    "name": "str",  # Optional. Name to identify resource.
                    "phenotype": "str",  # Optional. Crop phenotype.
                    "properties": {
                        "str": {}  # Optional. A collection of key value pairs that belongs
                          to the resource."nEach pair must not have a key greater than 50
                          characters"nand must not have a value greater than 150 characters."nNote: A
                          maximum of 25 key value pairs can be provided for a resource and only
                          string,"nnumeral and datetime (yyyy-MM-ddTHH:mm:ssZ) values are supported.
                    },
                    "source": "str",  # Optional. Source of the resource.
                    "status": "str"  # Optional. Status of the resource.
                }
        """
        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls = kwargs.pop("cls", None)  # type: ClsType[JSON]

        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        def prepare_request(next_link=None):
            if not next_link:

                request = build_crops_list_request(
                    phenotypes=phenotypes,
                    breeding_methods=breeding_methods,
                    ids=ids,
                    names=names,
                    property_filters=property_filters,
                    statuses=statuses,
                    min_created_date_time=min_created_date_time,
                    max_created_date_time=max_created_date_time,
                    min_last_modified_date_time=min_last_modified_date_time,
                    max_last_modified_date_time=max_last_modified_date_time,
                    skip_token=skip_token,
                    api_version=self._config.api_version,
                    headers=_headers,
                    params=_params,
                )
                request.url = self._client.format_url(request.url)  # type: ignore

            else:
                # make call to next link with the client's api-version
                _parsed_next_link = urlparse(next_link)
                _next_request_params = case_insensitive_dict(parse_qs(_parsed_next_link.query))
                _next_request_params["api-version"] = self._config.api_version
                request = HttpRequest("GET", urljoin(next_link, _parsed_next_link.path), params=_next_request_params)
                request.url = self._client.format_url(request.url)  # type: ignore

            return request

        def extract_data(pipeline_response):
            deserialized = pipeline_response.http_response.json()
            list_of_elem = deserialized["value"]
            if cls:
                list_of_elem = cls(list_of_elem)
            return deserialized.get("nextLink", None), iter(list_of_elem)

        def get_next(next_link=None):
            request = prepare_request(next_link)

            pipeline_response = self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
                request, stream=False, **kwargs
            )
            response = pipeline_response.http_response

            if response.status_code not in [200]:
                map_error(status_code=response.status_code, response=response, error_map=error_map)
                raise HttpResponseError(response=response)

            return pipeline_response

        return ItemPaged(get_next, extract_data)

    @distributed_trace
    def get(self, crop_id: str, **kwargs: Any) -> JSON:
        """Gets a specified crop resource.

        :param crop_id: Id of the crop. Required.
        :type crop_id: str
        :return: JSON object
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "breedingMethod": "str",  # Optional. Breeding Method. Known values are:
                      "VARIETY", "HYBRID", and "UNKNOWN".
                    "createdBy": "str",  # Optional. Created by user/tenant id.
                    "createdDateTime": "2020-02-20 00:00:00",  # Optional. Date-time when
                      resource was created, sample format: yyyy-MM-ddTHH:mm:ssZ.
                    "description": "str",  # Optional. Textual description of the resource.
                    "eTag": "str",  # Optional. The ETag value to implement optimistic
                      concurrency.
                    "id": "str",  # Optional. Unique resource ID.
                    "measurements": {
                        "str": {
                            "unit": "str",  # Optional. Data unit.
                            "value": 0.0  # Optional. Data value.
                        }
                    },
                    "modifiedBy": "str",  # Optional. Modified by user/tenant id.
                    "modifiedDateTime": "2020-02-20 00:00:00",  # Optional. Date-time when
                      resource was last modified, sample format: yyyy-MM-ddTHH:mm:ssZ.
                    "name": "str",  # Optional. Name to identify resource.
                    "phenotype": "str",  # Optional. Crop phenotype.
                    "properties": {
                        "str": {}  # Optional. A collection of key value pairs that belongs
                          to the resource."nEach pair must not have a key greater than 50
                          characters"nand must not have a value greater than 150 characters."nNote: A
                          maximum of 25 key value pairs can be provided for a resource and only
                          string,"nnumeral and datetime (yyyy-MM-ddTHH:mm:ssZ) values are supported.
                    },
                    "source": "str",  # Optional. Source of the resource.
                    "status": "str"  # Optional. Status of the resource.
                }
        """
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls = kwargs.pop("cls", None)  # type: ClsType[JSON]

        request = build_crops_get_request(
            crop_id=crop_id,
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        request.url = self._client.format_url(request.url)  # type: ignore

        pipeline_response = self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
            request, stream=False, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if response.content:
            deserialized = response.json()
        else:
            deserialized = None

        if cls:
            return cls(pipeline_response, cast(JSON, deserialized), {})

        return cast(JSON, deserialized)

    @overload
    def create_or_update(
        self, crop_id: str, crop: JSON, *, content_type: str = "application/merge-patch+json", **kwargs: Any
    ) -> JSON:
        """Creates or updates a crop resource.

        :param crop_id: Id of the crop resource. Required.
        :type crop_id: str
        :param crop: Crop resource payload to create or update. Required.
        :type crop: JSON
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/merge-patch+json".
        :paramtype content_type: str
        :return: JSON object
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                crop = {
                    "breedingMethod": "str",  # Optional. Breeding Method. Known values are:
                      "VARIETY", "HYBRID", and "UNKNOWN".
                    "createdBy": "str",  # Optional. Created by user/tenant id.
                    "createdDateTime": "2020-02-20 00:00:00",  # Optional. Date-time when
                      resource was created, sample format: yyyy-MM-ddTHH:mm:ssZ.
                    "description": "str",  # Optional. Textual description of the resource.
                    "eTag": "str",  # Optional. The ETag value to implement optimistic
                      concurrency.
                    "id": "str",  # Optional. Unique resource ID.
                    "measurements": {
                        "str": {
                            "unit": "str",  # Optional. Data unit.
                            "value": 0.0  # Optional. Data value.
                        }
                    },
                    "modifiedBy": "str",  # Optional. Modified by user/tenant id.
                    "modifiedDateTime": "2020-02-20 00:00:00",  # Optional. Date-time when
                      resource was last modified, sample format: yyyy-MM-ddTHH:mm:ssZ.
                    "name": "str",  # Optional. Name to identify resource.
                    "phenotype": "str",  # Optional. Crop phenotype.
                    "properties": {
                        "str": {}  # Optional. A collection of key value pairs that belongs
                          to the resource."nEach pair must not have a key greater than 50
                          characters"nand must not have a value greater than 150 characters."nNote: A
                          maximum of 25 key value pairs can be provided for a resource and only
                          string,"nnumeral and datetime (yyyy-MM-ddTHH:mm:ssZ) values are supported.
                    },
                    "source": "str",  # Optional. Source of the resource.
                    "status": "str"  # Optional. Status of the resource.
                }

                # response body for status code(s): 200, 201
                response == {
                    "breedingMethod": "str",  # Optional. Breeding Method. Known values are:
                      "VARIETY", "HYBRID", and "UNKNOWN".
                    "createdBy": "str",  # Optional. Created by user/tenant id.
                    "createdDateTime": "2020-02-20 00:00:00",  # Optional. Date-time when
                      resource was created, sample format: yyyy-MM-ddTHH:mm:ssZ.
                    "description": "str",  # Optional. Textual description of the resource.
                    "eTag": "str",  # Optional. The ETag value to implement optimistic
                      concurrency.
                    "id": "str",  # Optional. Unique resource ID.
                    "measurements": {
                        "str": {
                            "unit": "str",  # Optional. Data unit.
                            "value": 0.0  # Optional. Data value.
                        }
                    },
                    "modifiedBy": "str",  # Optional. Modified by user/tenant id.
                    "modifiedDateTime": "2020-02-20 00:00:00",  # Optional. Date-time when
                      resource was last modified, sample format: yyyy-MM-ddTHH:mm:ssZ.
                    "name": "str",  # Optional. Name to identify resource.
                    "phenotype": "str",  # Optional. Crop phenotype.
                    "properties": {
                        "str": {}  # Optional. A collection of key value pairs that belongs
                          to the resource."nEach pair must not have a key greater than 50
                          characters"nand must not have a value greater than 150 characters."nNote: A
                          maximum of 25 key value pairs can be provided for a resource and only
                          string,"nnumeral and datetime (yyyy-MM-ddTHH:mm:ssZ) values are supported.
                    },
                    "source": "str",  # Optional. Source of the resource.
                    "status": "str"  # Optional. Status of the resource.
                }
        """

    @overload
    def create_or_update(
        self, crop_id: str, crop: IO, *, content_type: str = "application/merge-patch+json", **kwargs: Any
    ) -> JSON:
        """Creates or updates a crop resource.

        :param crop_id: Id of the crop resource. Required.
        :type crop_id: str
        :param crop: Crop resource payload to create or update. Required.
        :type crop: IO
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Default value is "application/merge-patch+json".
        :paramtype content_type: str
        :return: JSON object
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200, 201
                response == {
                    "breedingMethod": "str",  # Optional. Breeding Method. Known values are:
                      "VARIETY", "HYBRID", and "UNKNOWN".
                    "createdBy": "str",  # Optional. Created by user/tenant id.
                    "createdDateTime": "2020-02-20 00:00:00",  # Optional. Date-time when
                      resource was created, sample format: yyyy-MM-ddTHH:mm:ssZ.
                    "description": "str",  # Optional. Textual description of the resource.
                    "eTag": "str",  # Optional. The ETag value to implement optimistic
                      concurrency.
                    "id": "str",  # Optional. Unique resource ID.
                    "measurements": {
                        "str": {
                            "unit": "str",  # Optional. Data unit.
                            "value": 0.0  # Optional. Data value.
                        }
                    },
                    "modifiedBy": "str",  # Optional. Modified by user/tenant id.
                    "modifiedDateTime": "2020-02-20 00:00:00",  # Optional. Date-time when
                      resource was last modified, sample format: yyyy-MM-ddTHH:mm:ssZ.
                    "name": "str",  # Optional. Name to identify resource.
                    "phenotype": "str",  # Optional. Crop phenotype.
                    "properties": {
                        "str": {}  # Optional. A collection of key value pairs that belongs
                          to the resource."nEach pair must not have a key greater than 50
                          characters"nand must not have a value greater than 150 characters."nNote: A
                          maximum of 25 key value pairs can be provided for a resource and only
                          string,"nnumeral and datetime (yyyy-MM-ddTHH:mm:ssZ) values are supported.
                    },
                    "source": "str",  # Optional. Source of the resource.
                    "status": "str"  # Optional. Status of the resource.
                }
        """

    @distributed_trace
    def create_or_update(self, crop_id: str, crop: Union[JSON, IO], **kwargs: Any) -> JSON:
        """Creates or updates a crop resource.

        :param crop_id: Id of the crop resource. Required.
        :type crop_id: str
        :param crop: Crop resource payload to create or update. Is either a model type or a IO type.
         Required.
        :type crop: JSON or IO
        :keyword content_type: Body Parameter content-type. Known values are:
         'application/merge-patch+json'. Default value is None.
        :paramtype content_type: str
        :return: JSON object
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200, 201
                response == {
                    "breedingMethod": "str",  # Optional. Breeding Method. Known values are:
                      "VARIETY", "HYBRID", and "UNKNOWN".
                    "createdBy": "str",  # Optional. Created by user/tenant id.
                    "createdDateTime": "2020-02-20 00:00:00",  # Optional. Date-time when
                      resource was created, sample format: yyyy-MM-ddTHH:mm:ssZ.
                    "description": "str",  # Optional. Textual description of the resource.
                    "eTag": "str",  # Optional. The ETag value to implement optimistic
                      concurrency.
                    "id": "str",  # Optional. Unique resource ID.
                    "measurements": {
                        "str": {
                            "unit": "str",  # Optional. Data unit.
                            "value": 0.0  # Optional. Data value.
                        }
                    },
                    "modifiedBy": "str",  # Optional. Modified by user/tenant id.
                    "modifiedDateTime": "2020-02-20 00:00:00",  # Optional. Date-time when
                      resource was last modified, sample format: yyyy-MM-ddTHH:mm:ssZ.
                    "name": "str",  # Optional. Name to identify resource.
                    "phenotype": "str",  # Optional. Crop phenotype.
                    "properties": {
                        "str": {}  # Optional. A collection of key value pairs that belongs
                          to the resource."nEach pair must not have a key greater than 50
                          characters"nand must not have a value greater than 150 characters."nNote: A
                          maximum of 25 key value pairs can be provided for a resource and only
                          string,"nnumeral and datetime (yyyy-MM-ddTHH:mm:ssZ) values are supported.
                    },
                    "source": "str",  # Optional. Source of the resource.
                    "status": "str"  # Optional. Status of the resource.
                }
        """
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type = kwargs.pop("content_type", _headers.pop("Content-Type", None))  # type: Optional[str]
        cls = kwargs.pop("cls", None)  # type: ClsType[JSON]

        content_type = content_type or "application/merge-patch+json"
        _json = None
        _content = None
        if isinstance(crop, (IO, bytes)):
            _content = crop
        else:
            _json = crop

        request = build_crops_create_or_update_request(
            crop_id=crop_id,
            content_type=content_type,
            api_version=self._config.api_version,
            json=_json,
            content=_content,
            headers=_headers,
            params=_params,
        )
        request.url = self._client.format_url(request.url)  # type: ignore

        pipeline_response = self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
            request, stream=False, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200, 201]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if response.status_code == 200:
            if response.content:
                deserialized = response.json()
            else:
                deserialized = None

        if response.status_code == 201:
            if response.content:
                deserialized = response.json()
            else:
                deserialized = None

        if cls:
            return cls(pipeline_response, cast(JSON, deserialized), {})

        return cast(JSON, deserialized)

    @distributed_trace
    def delete(self, crop_id: str, **kwargs: Any) -> None:  # pylint: disable=inconsistent-return-statements
        """Deletes Crop for given crop id.

        :param crop_id: Id of crop to be deleted. Required.
        :type crop_id: str
        :return: None
        :rtype: None
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls = kwargs.pop("cls", None)  # type: ClsType[None]

        request = build_crops_delete_request(
            crop_id=crop_id,
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        request.url = self._client.format_url(request.url)  # type: ignore

        pipeline_response = self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
            request, stream=False, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [204]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if cls:
            return cls(pipeline_response, None, {})


class DeviceDataModelsOperations:
    """
    .. warning::
        **DO NOT** instantiate this class directly.

        Instead, you should access the following operations through
        :class:`~azure.agrifood.farming.FarmBeatsClient`'s
        :attr:`device_data_models` attribute.
    """

    def __init__(self, *args, **kwargs):
        input_args = list(args)
        self._client = input_args.pop(0) if input_args else kwargs.pop("client")
        self._config = input_args.pop(0) if input_args else kwargs.pop("config")
        self._serialize = input_args.pop(0) if input_args else kwargs.pop("serializer")
        self._deserialize = input_args.pop(0) if input_args else kwargs.pop("deserializer")

    @distributed_trace
    def list(
        self,
        sensor_partner_id: str,
        *,
        ids: Optional[List[str]] = None,
        names: Optional[List[str]] = None,
        property_filters: Optional[List[str]] = None,
        statuses: Optional[List[str]] = None,
        min_created_date_time: Optional[datetime.datetime] = None,
        max_created_date_time: Optional[datetime.datetime] = None,
        min_last_modified_date_time: Optional[datetime.datetime] = None,
        max_last_modified_date_time: Optional[datetime.datetime] = None,
        skip_token: Optional[str] = None,
        **kwargs: Any
    ) -> Iterable[JSON]:
        """Returns a paginated list of device data model resources.

        :param sensor_partner_id: Id of the associated sensor partner. Required.
        :type sensor_partner_id: str
        :keyword ids: Ids of the resource. Default value is None.
        :paramtype ids: list[str]
        :keyword names: Names of the resource. Default value is None.
        :paramtype names: list[str]
        :keyword property_filters: Filters on key-value pairs within the Properties object.
         eg. "{testKey} eq {testValue}". Default value is None.
        :paramtype property_filters: list[str]
        :keyword statuses: Statuses of the resource. Default value is None.
        :paramtype statuses: list[str]
        :keyword min_created_date_time: Minimum creation date of resource (inclusive). Default value is
         None.
        :paramtype min_created_date_time: ~datetime.datetime
        :keyword max_created_date_time: Maximum creation date of resource (inclusive). Default value is
         None.
        :paramtype max_created_date_time: ~datetime.datetime
        :keyword min_last_modified_date_time: Minimum last modified date of resource (inclusive).
         Default value is None.
        :paramtype min_last_modified_date_time: ~datetime.datetime
        :keyword max_last_modified_date_time: Maximum last modified date of resource (inclusive).
         Default value is None.
        :paramtype max_last_modified_date_time: ~datetime.datetime
        :keyword skip_token: Skip token for getting next set of results. Default value is None.
        :paramtype skip_token: str
        :return: An iterator like instance of JSON object
        :rtype: ~azure.core.paging.ItemPaged[JSON]
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "createdBy": "str",  # Optional. Created by user/tenant id.
                    "createdDateTime": "2020-02-20 00:00:00",  # Optional. Date-time when
                      resource was created, sample format: yyyy-MM-ddTHH:mm:ssZ.
                    "description": "str",  # Optional. Textual description of the resource.
                    "eTag": "str",  # Optional. The ETag value to implement optimistic
                      concurrency.
                    "id": "str",  # Optional. Id of the resource.
                    "manufacturer": "str",  # Optional. Device manufacturer.
                    "modifiedBy": "str",  # Optional. Modified by user/tenant id.
                    "modifiedDateTime": "2020-02-20 00:00:00",  # Optional. Date-time when
                      resource was last modified, sample format: yyyy-MM-ddTHH:mm:ssZ.
                    "name": "str",  # Optional. Name to identify resource.
                    "ports": [
                        {
                            "name": "str",  # Optional. Name of the port.
                            "type": "str"  # Optional. Type of port digital/analog.
                        }
                    ],
                    "productCode": "str",  # Optional. Device productCode.
                    "properties": {
                        "str": {}  # Optional. A collection of key value pairs that belongs
                          to the resource."nEach pair must not have a key greater than 50
                          characters"nand must not have a value greater than 150 characters."nNote: A
                          maximum of 25 key value pairs can be provided for a resource and"nonly
                          string, numeral and datetime (yyyy-MM-ddTHH:mm:ssZ) values are supported.
                    },
                    "sensorPartnerId": "str",  # Optional. Id of the associated sensor partner.
                    "status": "str",  # Optional. Status of the resource.
                    "type": "str"  # Optional. Type of device.
                }
        """
        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls = kwargs.pop("cls", None)  # type: ClsType[JSON]

        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        def prepare_request(next_link=None):
            if not next_link:

                request = build_device_data_models_list_request(
                    sensor_partner_id=sensor_partner_id,
                    ids=ids,
                    names=names,
                    property_filters=property_filters,
                    statuses=statuses,
                    min_created_date_time=min_created_date_time,
                    max_created_date_time=max_created_date_time,
                    min_last_modified_date_time=min_last_modified_date_time,
                    max_last_modified_date_time=max_last_modified_date_time,
                    skip_token=skip_token,
                    api_version=self._config.api_version,
                    headers=_headers,
                    params=_params,
                )
                request.url = self._client.format_url(request.url)  # type: ignore

            else:
                # make call to next link with the client's api-version
                _parsed_next_link = urlparse(next_link)
                _next_request_params = case_insensitive_dict(parse_qs(_parsed_next_link.query))
                _next_request_params["api-version"] = self._config.api_version
                request = HttpRequest("GET", urljoin(next_link, _parsed_next_link.path), params=_next_request_params)
                request.url = self._client.format_url(request.url)  # type: ignore

            return request

        def extract_data(pipeline_response):
            deserialized = pipeline_response.http_response.json()
            list_of_elem = deserialized["value"]
            if cls:
                list_of_elem = cls(list_of_elem)
            return deserialized.get("nextLink", None), iter(list_of_elem)

        def get_next(next_link=None):
            request = prepare_request(next_link)

            pipeline_response = self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
                request, stream=False, **kwargs
            )
            response = pipeline_response.http_response

            if response.status_code not in [200]:
                map_error(status_code=response.status_code, response=response, error_map=error_map)
                raise HttpResponseError(response=response)

            return pipeline_response

        return ItemPaged(get_next, extract_data)

    @overload
    def create_or_update(
        self,
        sensor_partner_id: str,
        device_data_model_id: str,
        device_data_model_object: JSON,
        *,
        content_type: str = "application/merge-patch+json",
        **kwargs: Any
    ) -> JSON:
        """Create a device data model entity.

        :param sensor_partner_id: Id of the sensor partner. Required.
        :type sensor_partner_id: str
        :param device_data_model_id: Id of the device data model. Required.
        :type device_data_model_id: str
        :param device_data_model_object: Device data model object details. Required.
        :type device_data_model_object: JSON
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/merge-patch+json".
        :paramtype content_type: str
        :return: JSON object
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                device_data_model_object = {
                    "createdBy": "str",  # Optional. Created by user/tenant id.
                    "createdDateTime": "2020-02-20 00:00:00",  # Optional. Date-time when
                      resource was created, sample format: yyyy-MM-ddTHH:mm:ssZ.
                    "description": "str",  # Optional. Textual description of the resource.
                    "eTag": "str",  # Optional. The ETag value to implement optimistic
                      concurrency.
                    "id": "str",  # Optional. Id of the resource.
                    "manufacturer": "str",  # Optional. Device manufacturer.
                    "modifiedBy": "str",  # Optional. Modified by user/tenant id.
                    "modifiedDateTime": "2020-02-20 00:00:00",  # Optional. Date-time when
                      resource was last modified, sample format: yyyy-MM-ddTHH:mm:ssZ.
                    "name": "str",  # Optional. Name to identify resource.
                    "ports": [
                        {
                            "name": "str",  # Optional. Name of the port.
                            "type": "str"  # Optional. Type of port digital/analog.
                        }
                    ],
                    "productCode": "str",  # Optional. Device productCode.
                    "properties": {
                        "str": {}  # Optional. A collection of key value pairs that belongs
                          to the resource."nEach pair must not have a key greater than 50
                          characters"nand must not have a value greater than 150 characters."nNote: A
                          maximum of 25 key value pairs can be provided for a resource and"nonly
                          string, numeral and datetime (yyyy-MM-ddTHH:mm:ssZ) values are supported.
                    },
                    "sensorPartnerId": "str",  # Optional. Id of the associated sensor partner.
                    "status": "str",  # Optional. Status of the resource.
                    "type": "str"  # Optional. Type of device.
                }

                # response body for status code(s): 200, 201
                response == {
                    "createdBy": "str",  # Optional. Created by user/tenant id.
                    "createdDateTime": "2020-02-20 00:00:00",  # Optional. Date-time when
                      resource was created, sample format: yyyy-MM-ddTHH:mm:ssZ.
                    "description": "str",  # Optional. Textual description of the resource.
                    "eTag": "str",  # Optional. The ETag value to implement optimistic
                      concurrency.
                    "id": "str",  # Optional. Id of the resource.
                    "manufacturer": "str",  # Optional. Device manufacturer.
                    "modifiedBy": "str",  # Optional. Modified by user/tenant id.
                    "modifiedDateTime": "2020-02-20 00:00:00",  # Optional. Date-time when
                      resource was last modified, sample format: yyyy-MM-ddTHH:mm:ssZ.
                    "name": "str",  # Optional. Name to identify resource.
                    "ports": [
                        {
                            "name": "str",  # Optional. Name of the port.
                            "type": "str"  # Optional. Type of port digital/analog.
                        }
                    ],
                    "productCode": "str",  # Optional. Device productCode.
                    "properties": {
                        "str": {}  # Optional. A collection of key value pairs that belongs
                          to the resource."nEach pair must not have a key greater than 50
                          characters"nand must not have a value greater than 150 characters."nNote: A
                          maximum of 25 key value pairs can be provided for a resource and"nonly
                          string, numeral and datetime (yyyy-MM-ddTHH:mm:ssZ) values are supported.
                    },
                    "sensorPartnerId": "str",  # Optional. Id of the associated sensor partner.
                    "status": "str",  # Optional. Status of the resource.
                    "type": "str"  # Optional. Type of device.
                }
        """

    @overload
    def create_or_update(
        self,
        sensor_partner_id: str,
        device_data_model_id: str,
        device_data_model_object: IO,
        *,
        content_type: str = "application/merge-patch+json",
        **kwargs: Any
    ) -> JSON:
        """Create a device data model entity.

        :param sensor_partner_id: Id of the sensor partner. Required.
        :type sensor_partner_id: str
        :param device_data_model_id: Id of the device data model. Required.
        :type device_data_model_id: str
        :param device_data_model_object: Device data model object details. Required.
        :type device_data_model_object: IO
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Default value is "application/merge-patch+json".
        :paramtype content_type: str
        :return: JSON object
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200, 201
                response == {
                    "createdBy": "str",  # Optional. Created by user/tenant id.
                    "createdDateTime": "2020-02-20 00:00:00",  # Optional. Date-time when
                      resource was created, sample format: yyyy-MM-ddTHH:mm:ssZ.
                    "description": "str",  # Optional. Textual description of the resource.
                    "eTag": "str",  # Optional. The ETag value to implement optimistic
                      concurrency.
                    "id": "str",  # Optional. Id of the resource.
                    "manufacturer": "str",  # Optional. Device manufacturer.
                    "modifiedBy": "str",  # Optional. Modified by user/tenant id.
                    "modifiedDateTime": "2020-02-20 00:00:00",  # Optional. Date-time when
                      resource was last modified, sample format: yyyy-MM-ddTHH:mm:ssZ.
                    "name": "str",  # Optional. Name to identify resource.
                    "ports": [
                        {
                            "name": "str",  # Optional. Name of the port.
                            "type": "str"  # Optional. Type of port digital/analog.
                        }
                    ],
                    "productCode": "str",  # Optional. Device productCode.
                    "properties": {
                        "str": {}  # Optional. A collection of key value pairs that belongs
                          to the resource."nEach pair must not have a key greater than 50
                          characters"nand must not have a value greater than 150 characters."nNote: A
                          maximum of 25 key value pairs can be provided for a resource and"nonly
                          string, numeral and datetime (yyyy-MM-ddTHH:mm:ssZ) values are supported.
                    },
                    "sensorPartnerId": "str",  # Optional. Id of the associated sensor partner.
                    "status": "str",  # Optional. Status of the resource.
                    "type": "str"  # Optional. Type of device.
                }
        """

    @distributed_trace
    def create_or_update(
        self,
        sensor_partner_id: str,
        device_data_model_id: str,
        device_data_model_object: Union[JSON, IO],
        **kwargs: Any
    ) -> JSON:
        """Create a device data model entity.

        :param sensor_partner_id: Id of the sensor partner. Required.
        :type sensor_partner_id: str
        :param device_data_model_id: Id of the device data model. Required.
        :type device_data_model_id: str
        :param device_data_model_object: Device data model object details. Is either a model type or a
         IO type. Required.
        :type device_data_model_object: JSON or IO
        :keyword content_type: Body Parameter content-type. Known values are:
         'application/merge-patch+json'. Default value is None.
        :paramtype content_type: str
        :return: JSON object
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200, 201
                response == {
                    "createdBy": "str",  # Optional. Created by user/tenant id.
                    "createdDateTime": "2020-02-20 00:00:00",  # Optional. Date-time when
                      resource was created, sample format: yyyy-MM-ddTHH:mm:ssZ.
                    "description": "str",  # Optional. Textual description of the resource.
                    "eTag": "str",  # Optional. The ETag value to implement optimistic
                      concurrency.
                    "id": "str",  # Optional. Id of the resource.
                    "manufacturer": "str",  # Optional. Device manufacturer.
                    "modifiedBy": "str",  # Optional. Modified by user/tenant id.
                    "modifiedDateTime": "2020-02-20 00:00:00",  # Optional. Date-time when
                      resource was last modified, sample format: yyyy-MM-ddTHH:mm:ssZ.
                    "name": "str",  # Optional. Name to identify resource.
                    "ports": [
                        {
                            "name": "str",  # Optional. Name of the port.
                            "type": "str"  # Optional. Type of port digital/analog.
                        }
                    ],
                    "productCode": "str",  # Optional. Device productCode.
                    "properties": {
                        "str": {}  # Optional. A collection of key value pairs that belongs
                          to the resource."nEach pair must not have a key greater than 50
                          characters"nand must not have a value greater than 150 characters."nNote: A
                          maximum of 25 key value pairs can be provided for a resource and"nonly
                          string, numeral and datetime (yyyy-MM-ddTHH:mm:ssZ) values are supported.
                    },
                    "sensorPartnerId": "str",  # Optional. Id of the associated sensor partner.
                    "status": "str",  # Optional. Status of the resource.
                    "type": "str"  # Optional. Type of device.
                }
        """
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type = kwargs.pop("content_type", _headers.pop("Content-Type", None))  # type: Optional[str]
        cls = kwargs.pop("cls", None)  # type: ClsType[JSON]

        content_type = content_type or "application/merge-patch+json"
        _json = None
        _content = None
        if isinstance(device_data_model_object, (IO, bytes)):
            _content = device_data_model_object
        else:
            _json = device_data_model_object

        request = build_device_data_models_create_or_update_request(
            sensor_partner_id=sensor_partner_id,
            device_data_model_id=device_data_model_id,
            content_type=content_type,
            api_version=self._config.api_version,
            json=_json,
            content=_content,
            headers=_headers,
            params=_params,
        )
        request.url = self._client.format_url(request.url)  # type: ignore

        pipeline_response = self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
            request, stream=False, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200, 201]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if response.status_code == 200:
            if response.content:
                deserialized = response.json()
            else:
                deserialized = None

        if response.status_code == 201:
            if response.content:
                deserialized = response.json()
            else:
                deserialized = None

        if cls:
            return cls(pipeline_response, cast(JSON, deserialized), {})

        return cast(JSON, deserialized)

    @distributed_trace
    def get(self, sensor_partner_id: str, device_data_model_id: str, **kwargs: Any) -> JSON:
        """Gets a device data model entity.

        :param sensor_partner_id: Id of the sensor partner. Required.
        :type sensor_partner_id: str
        :param device_data_model_id: Id of the device data model resource. Required.
        :type device_data_model_id: str
        :return: JSON object
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "createdBy": "str",  # Optional. Created by user/tenant id.
                    "createdDateTime": "2020-02-20 00:00:00",  # Optional. Date-time when
                      resource was created, sample format: yyyy-MM-ddTHH:mm:ssZ.
                    "description": "str",  # Optional. Textual description of the resource.
                    "eTag": "str",  # Optional. The ETag value to implement optimistic
                      concurrency.
                    "id": "str",  # Optional. Id of the resource.
                    "manufacturer": "str",  # Optional. Device manufacturer.
                    "modifiedBy": "str",  # Optional. Modified by user/tenant id.
                    "modifiedDateTime": "2020-02-20 00:00:00",  # Optional. Date-time when
                      resource was last modified, sample format: yyyy-MM-ddTHH:mm:ssZ.
                    "name": "str",  # Optional. Name to identify resource.
                    "ports": [
                        {
                            "name": "str",  # Optional. Name of the port.
                            "type": "str"  # Optional. Type of port digital/analog.
                        }
                    ],
                    "productCode": "str",  # Optional. Device productCode.
                    "properties": {
                        "str": {}  # Optional. A collection of key value pairs that belongs
                          to the resource."nEach pair must not have a key greater than 50
                          characters"nand must not have a value greater than 150 characters."nNote: A
                          maximum of 25 key value pairs can be provided for a resource and"nonly
                          string, numeral and datetime (yyyy-MM-ddTHH:mm:ssZ) values are supported.
                    },
                    "sensorPartnerId": "str",  # Optional. Id of the associated sensor partner.
                    "status": "str",  # Optional. Status of the resource.
                    "type": "str"  # Optional. Type of device.
                }
        """
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls = kwargs.pop("cls", None)  # type: ClsType[JSON]

        request = build_device_data_models_get_request(
            sensor_partner_id=sensor_partner_id,
            device_data_model_id=device_data_model_id,
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        request.url = self._client.format_url(request.url)  # type: ignore

        pipeline_response = self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
            request, stream=False, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if response.content:
            deserialized = response.json()
        else:
            deserialized = None

        if cls:
            return cls(pipeline_response, cast(JSON, deserialized), {})

        return cast(JSON, deserialized)

    @distributed_trace
    def delete(  # pylint: disable=inconsistent-return-statements
        self, sensor_partner_id: str, device_data_model_id: str, **kwargs: Any
    ) -> None:
        """Deletes a device data model entity.

        :param sensor_partner_id: Id of the sensor partner. Required.
        :type sensor_partner_id: str
        :param device_data_model_id: Id of the device data model resource. Required.
        :type device_data_model_id: str
        :return: None
        :rtype: None
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls = kwargs.pop("cls", None)  # type: ClsType[None]

        request = build_device_data_models_delete_request(
            sensor_partner_id=sensor_partner_id,
            device_data_model_id=device_data_model_id,
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        request.url = self._client.format_url(request.url)  # type: ignore

        pipeline_response = self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
            request, stream=False, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [204]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if cls:
            return cls(pipeline_response, None, {})


class DevicesOperations:
    """
    .. warning::
        **DO NOT** instantiate this class directly.

        Instead, you should access the following operations through
        :class:`~azure.agrifood.farming.FarmBeatsClient`'s
        :attr:`devices` attribute.
    """

    def __init__(self, *args, **kwargs):
        input_args = list(args)
        self._client = input_args.pop(0) if input_args else kwargs.pop("client")
        self._config = input_args.pop(0) if input_args else kwargs.pop("config")
        self._serialize = input_args.pop(0) if input_args else kwargs.pop("serializer")
        self._deserialize = input_args.pop(0) if input_args else kwargs.pop("deserializer")

    @distributed_trace
    def list(
        self,
        sensor_partner_id: str,
        *,
        parent_device_ids: Optional[List[str]] = None,
        device_data_model_ids: Optional[List[str]] = None,
        ids: Optional[List[str]] = None,
        names: Optional[List[str]] = None,
        property_filters: Optional[List[str]] = None,
        statuses: Optional[List[str]] = None,
        min_created_date_time: Optional[datetime.datetime] = None,
        max_created_date_time: Optional[datetime.datetime] = None,
        min_last_modified_date_time: Optional[datetime.datetime] = None,
        max_last_modified_date_time: Optional[datetime.datetime] = None,
        skip_token: Optional[str] = None,
        **kwargs: Any
    ) -> Iterable[JSON]:
        """Returns a paginated list of device resources.

        :param sensor_partner_id: Id of the associated sensor partner. Required.
        :type sensor_partner_id: str
        :keyword parent_device_ids: Id's of the parent devices. Default value is None.
        :paramtype parent_device_ids: list[str]
        :keyword device_data_model_ids: Id's of the device data models. Default value is None.
        :paramtype device_data_model_ids: list[str]
        :keyword ids: Ids of the resource. Default value is None.
        :paramtype ids: list[str]
        :keyword names: Names of the resource. Default value is None.
        :paramtype names: list[str]
        :keyword property_filters: Filters on key-value pairs within the Properties object.
         eg. "{testKey} eq {testValue}". Default value is None.
        :paramtype property_filters: list[str]
        :keyword statuses: Statuses of the resource. Default value is None.
        :paramtype statuses: list[str]
        :keyword min_created_date_time: Minimum creation date of resource (inclusive). Default value is
         None.
        :paramtype min_created_date_time: ~datetime.datetime
        :keyword max_created_date_time: Maximum creation date of resource (inclusive). Default value is
         None.
        :paramtype max_created_date_time: ~datetime.datetime
        :keyword min_last_modified_date_time: Minimum last modified date of resource (inclusive).
         Default value is None.
        :paramtype min_last_modified_date_time: ~datetime.datetime
        :keyword max_last_modified_date_time: Maximum last modified date of resource (inclusive).
         Default value is None.
        :paramtype max_last_modified_date_time: ~datetime.datetime
        :keyword skip_token: Skip token for getting next set of results. Default value is None.
        :paramtype skip_token: str
        :return: An iterator like instance of JSON object
        :rtype: ~azure.core.paging.ItemPaged[JSON]
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "createdBy": "str",  # Optional. Created by user/tenant id.
                    "createdDateTime": "2020-02-20 00:00:00",  # Optional. Date-time when
                      resource was created, sample format: yyyy-MM-ddTHH:mm:ssZ.
                    "description": "str",  # Optional. Textual description of the resource.
                    "deviceDataModelId": "str",  # Optional. Id of the associated device data
                      model.
                    "eTag": "str",  # Optional. The ETag value to implement optimistic
                      concurrency.
                    "hardwareId": "str",  # Optional. Device hardwareId.
                    "id": "str",  # Optional. Id of the resource.
                    "integrationId": "str",  # Optional. Integration id for the device.
                    "location": {
                        "latitude": 0.0,  # Latitude of the location. Required.
                        "longitude": 0.0  # Longitude of the location. Required.
                    },
                    "modifiedBy": "str",  # Optional. Modified by user/tenant id.
                    "modifiedDateTime": "2020-02-20 00:00:00",  # Optional. Date-time when
                      resource was last modified, sample format: yyyy-MM-ddTHH:mm:ssZ.
                    "name": "str",  # Optional. Name to identify resource.
                    "parentDeviceId": "str",  # Optional. Parent device Id for this device.
                    "properties": {
                        "str": {}  # Optional. A collection of key value pairs that belongs
                          to the resource."nEach pair must not have a key greater than 50
                          characters"nand must not have a value greater than 150 characters."nNote: A
                          maximum of 25 key value pairs can be provided for a resource and"nonly
                          string, numeral and datetime (yyyy-MM-ddTHH:mm:ssZ) values are supported.
                    },
                    "reportingIntervalInSeconds": 0,  # Optional. Interval at which the device
                      sends data in seconds.
                    "sensorPartnerId": "str",  # Optional. Id of the associated sensor partner.
                    "status": "str",  # Optional. Status of the resource.
                    "type": "str"  # Optional. Type of device.
                }
        """
        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls = kwargs.pop("cls", None)  # type: ClsType[JSON]

        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        def prepare_request(next_link=None):
            if not next_link:

                request = build_devices_list_request(
                    sensor_partner_id=sensor_partner_id,
                    parent_device_ids=parent_device_ids,
                    device_data_model_ids=device_data_model_ids,
                    ids=ids,
                    names=names,
                    property_filters=property_filters,
                    statuses=statuses,
                    min_created_date_time=min_created_date_time,
                    max_created_date_time=max_created_date_time,
                    min_last_modified_date_time=min_last_modified_date_time,
                    max_last_modified_date_time=max_last_modified_date_time,
                    skip_token=skip_token,
                    api_version=self._config.api_version,
                    headers=_headers,
                    params=_params,
                )
                request.url = self._client.format_url(request.url)  # type: ignore

            else:
                # make call to next link with the client's api-version
                _parsed_next_link = urlparse(next_link)
                _next_request_params = case_insensitive_dict(parse_qs(_parsed_next_link.query))
                _next_request_params["api-version"] = self._config.api_version
                request = HttpRequest("GET", urljoin(next_link, _parsed_next_link.path), params=_next_request_params)
                request.url = self._client.format_url(request.url)  # type: ignore

            return request

        def extract_data(pipeline_response):
            deserialized = pipeline_response.http_response.json()
            list_of_elem = deserialized["value"]
            if cls:
                list_of_elem = cls(list_of_elem)
            return deserialized.get("nextLink", None), iter(list_of_elem)

        def get_next(next_link=None):
            request = prepare_request(next_link)

            pipeline_response = self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
                request, stream=False, **kwargs
            )
            response = pipeline_response.http_response

            if response.status_code not in [200]:
                map_error(status_code=response.status_code, response=response, error_map=error_map)
                raise HttpResponseError(response=response)

            return pipeline_response

        return ItemPaged(get_next, extract_data)

    @overload
    def create_or_update(
        self,
        sensor_partner_id: str,
        device_id: str,
        device_details: JSON,
        *,
        content_type: str = "application/merge-patch+json",
        **kwargs: Any
    ) -> JSON:
        """Create a device entity.

        :param sensor_partner_id: Id of the sensor partner. Required.
        :type sensor_partner_id: str
        :param device_id: Id of the device resource. Required.
        :type device_id: str
        :param device_details: Device object details. Required.
        :type device_details: JSON
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/merge-patch+json".
        :paramtype content_type: str
        :return: JSON object
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                device_details = {
                    "createdBy": "str",  # Optional. Created by user/tenant id.
                    "createdDateTime": "2020-02-20 00:00:00",  # Optional. Date-time when
                      resource was created, sample format: yyyy-MM-ddTHH:mm:ssZ.
                    "description": "str",  # Optional. Textual description of the resource.
                    "deviceDataModelId": "str",  # Optional. Id of the associated device data
                      model.
                    "eTag": "str",  # Optional. The ETag value to implement optimistic
                      concurrency.
                    "hardwareId": "str",  # Optional. Device hardwareId.
                    "id": "str",  # Optional. Id of the resource.
                    "integrationId": "str",  # Optional. Integration id for the device.
                    "location": {
                        "latitude": 0.0,  # Latitude of the location. Required.
                        "longitude": 0.0  # Longitude of the location. Required.
                    },
                    "modifiedBy": "str",  # Optional. Modified by user/tenant id.
                    "modifiedDateTime": "2020-02-20 00:00:00",  # Optional. Date-time when
                      resource was last modified, sample format: yyyy-MM-ddTHH:mm:ssZ.
                    "name": "str",  # Optional. Name to identify resource.
                    "parentDeviceId": "str",  # Optional. Parent device Id for this device.
                    "properties": {
                        "str": {}  # Optional. A collection of key value pairs that belongs
                          to the resource."nEach pair must not have a key greater than 50
                          characters"nand must not have a value greater than 150 characters."nNote: A
                          maximum of 25 key value pairs can be provided for a resource and"nonly
                          string, numeral and datetime (yyyy-MM-ddTHH:mm:ssZ) values are supported.
                    },
                    "reportingIntervalInSeconds": 0,  # Optional. Interval at which the device
                      sends data in seconds.
                    "sensorPartnerId": "str",  # Optional. Id of the associated sensor partner.
                    "status": "str",  # Optional. Status of the resource.
                    "type": "str"  # Optional. Type of device.
                }

                # response body for status code(s): 200, 201
                response == {
                    "createdBy": "str",  # Optional. Created by user/tenant id.
                    "createdDateTime": "2020-02-20 00:00:00",  # Optional. Date-time when
                      resource was created, sample format: yyyy-MM-ddTHH:mm:ssZ.
                    "description": "str",  # Optional. Textual description of the resource.
                    "deviceDataModelId": "str",  # Optional. Id of the associated device data
                      model.
                    "eTag": "str",  # Optional. The ETag value to implement optimistic
                      concurrency.
                    "hardwareId": "str",  # Optional. Device hardwareId.
                    "id": "str",  # Optional. Id of the resource.
                    "integrationId": "str",  # Optional. Integration id for the device.
                    "location": {
                        "latitude": 0.0,  # Latitude of the location. Required.
                        "longitude": 0.0  # Longitude of the location. Required.
                    },
                    "modifiedBy": "str",  # Optional. Modified by user/tenant id.
                    "modifiedDateTime": "2020-02-20 00:00:00",  # Optional. Date-time when
                      resource was last modified, sample format: yyyy-MM-ddTHH:mm:ssZ.
                    "name": "str",  # Optional. Name to identify resource.
                    "parentDeviceId": "str",  # Optional. Parent device Id for this device.
                    "properties": {
                        "str": {}  # Optional. A collection of key value pairs that belongs
                          to the resource."nEach pair must not have a key greater than 50
                          characters"nand must not have a value greater than 150 characters."nNote: A
                          maximum of 25 key value pairs can be provided for a resource and"nonly
                          string, numeral and datetime (yyyy-MM-ddTHH:mm:ssZ) values are supported.
                    },
                    "reportingIntervalInSeconds": 0,  # Optional. Interval at which the device
                      sends data in seconds.
                    "sensorPartnerId": "str",  # Optional. Id of the associated sensor partner.
                    "status": "str",  # Optional. Status of the resource.
                    "type": "str"  # Optional. Type of device.
                }
        """

    @overload
    def create_or_update(
        self,
        sensor_partner_id: str,
        device_id: str,
        device_details: IO,
        *,
        content_type: str = "application/merge-patch+json",
        **kwargs: Any
    ) -> JSON:
        """Create a device entity.

        :param sensor_partner_id: Id of the sensor partner. Required.
        :type sensor_partner_id: str
        :param device_id: Id of the device resource. Required.
        :type device_id: str
        :param device_details: Device object details. Required.
        :type device_details: IO
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Default value is "application/merge-patch+json".
        :paramtype content_type: str
        :return: JSON object
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200, 201
                response == {
                    "createdBy": "str",  # Optional. Created by user/tenant id.
                    "createdDateTime": "2020-02-20 00:00:00",  # Optional. Date-time when
                      resource was created, sample format: yyyy-MM-ddTHH:mm:ssZ.
                    "description": "str",  # Optional. Textual description of the resource.
                    "deviceDataModelId": "str",  # Optional. Id of the associated device data
                      model.
                    "eTag": "str",  # Optional. The ETag value to implement optimistic
                      concurrency.
                    "hardwareId": "str",  # Optional. Device hardwareId.
                    "id": "str",  # Optional. Id of the resource.
                    "integrationId": "str",  # Optional. Integration id for the device.
                    "location": {
                        "latitude": 0.0,  # Latitude of the location. Required.
                        "longitude": 0.0  # Longitude of the location. Required.
                    },
                    "modifiedBy": "str",  # Optional. Modified by user/tenant id.
                    "modifiedDateTime": "2020-02-20 00:00:00",  # Optional. Date-time when
                      resource was last modified, sample format: yyyy-MM-ddTHH:mm:ssZ.
                    "name": "str",  # Optional. Name to identify resource.
                    "parentDeviceId": "str",  # Optional. Parent device Id for this device.
                    "properties": {
                        "str": {}  # Optional. A collection of key value pairs that belongs
                          to the resource."nEach pair must not have a key greater than 50
                          characters"nand must not have a value greater than 150 characters."nNote: A
                          maximum of 25 key value pairs can be provided for a resource and"nonly
                          string, numeral and datetime (yyyy-MM-ddTHH:mm:ssZ) values are supported.
                    },
                    "reportingIntervalInSeconds": 0,  # Optional. Interval at which the device
                      sends data in seconds.
                    "sensorPartnerId": "str",  # Optional. Id of the associated sensor partner.
                    "status": "str",  # Optional. Status of the resource.
                    "type": "str"  # Optional. Type of device.
                }
        """

    @distributed_trace
    def create_or_update(
        self, sensor_partner_id: str, device_id: str, device_details: Union[JSON, IO], **kwargs: Any
    ) -> JSON:
        """Create a device entity.

        :param sensor_partner_id: Id of the sensor partner. Required.
        :type sensor_partner_id: str
        :param device_id: Id of the device resource. Required.
        :type device_id: str
        :param device_details: Device object details. Is either a model type or a IO type. Required.
        :type device_details: JSON or IO
        :keyword content_type: Body Parameter content-type. Known values are:
         'application/merge-patch+json'. Default value is None.
        :paramtype content_type: str
        :return: JSON object
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200, 201
                response == {
                    "createdBy": "str",  # Optional. Created by user/tenant id.
                    "createdDateTime": "2020-02-20 00:00:00",  # Optional. Date-time when
                      resource was created, sample format: yyyy-MM-ddTHH:mm:ssZ.
                    "description": "str",  # Optional. Textual description of the resource.
                    "deviceDataModelId": "str",  # Optional. Id of the associated device data
                      model.
                    "eTag": "str",  # Optional. The ETag value to implement optimistic
                      concurrency.
                    "hardwareId": "str",  # Optional. Device hardwareId.
                    "id": "str",  # Optional. Id of the resource.
                    "integrationId": "str",  # Optional. Integration id for the device.
                    "location": {
                        "latitude": 0.0,  # Latitude of the location. Required.
                        "longitude": 0.0  # Longitude of the location. Required.
                    },
                    "modifiedBy": "str",  # Optional. Modified by user/tenant id.
                    "modifiedDateTime": "2020-02-20 00:00:00",  # Optional. Date-time when
                      resource was last modified, sample format: yyyy-MM-ddTHH:mm:ssZ.
                    "name": "str",  # Optional. Name to identify resource.
                    "parentDeviceId": "str",  # Optional. Parent device Id for this device.
                    "properties": {
                        "str": {}  # Optional. A collection of key value pairs that belongs
                          to the resource."nEach pair must not have a key greater than 50
                          characters"nand must not have a value greater than 150 characters."nNote: A
                          maximum of 25 key value pairs can be provided for a resource and"nonly
                          string, numeral and datetime (yyyy-MM-ddTHH:mm:ssZ) values are supported.
                    },
                    "reportingIntervalInSeconds": 0,  # Optional. Interval at which the device
                      sends data in seconds.
                    "sensorPartnerId": "str",  # Optional. Id of the associated sensor partner.
                    "status": "str",  # Optional. Status of the resource.
                    "type": "str"  # Optional. Type of device.
                }
        """
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type = kwargs.pop("content_type", _headers.pop("Content-Type", None))  # type: Optional[str]
        cls = kwargs.pop("cls", None)  # type: ClsType[JSON]

        content_type = content_type or "application/merge-patch+json"
        _json = None
        _content = None
        if isinstance(device_details, (IO, bytes)):
            _content = device_details
        else:
            _json = device_details

        request = build_devices_create_or_update_request(
            sensor_partner_id=sensor_partner_id,
            device_id=device_id,
            content_type=content_type,
            api_version=self._config.api_version,
            json=_json,
            content=_content,
            headers=_headers,
            params=_params,
        )
        request.url = self._client.format_url(request.url)  # type: ignore

        pipeline_response = self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
            request, stream=False, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200, 201]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if response.status_code == 200:
            if response.content:
                deserialized = response.json()
            else:
                deserialized = None

        if response.status_code == 201:
            if response.content:
                deserialized = response.json()
            else:
                deserialized = None

        if cls:
            return cls(pipeline_response, cast(JSON, deserialized), {})

        return cast(JSON, deserialized)

    @distributed_trace
    def get(self, sensor_partner_id: str, device_id: str, **kwargs: Any) -> JSON:
        """Gets a device entity.

        :param sensor_partner_id: Id of the sensor partner. Required.
        :type sensor_partner_id: str
        :param device_id: Id of the device resource. Required.
        :type device_id: str
        :return: JSON object
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "createdBy": "str",  # Optional. Created by user/tenant id.
                    "createdDateTime": "2020-02-20 00:00:00",  # Optional. Date-time when
                      resource was created, sample format: yyyy-MM-ddTHH:mm:ssZ.
                    "description": "str",  # Optional. Textual description of the resource.
                    "deviceDataModelId": "str",  # Optional. Id of the associated device data
                      model.
                    "eTag": "str",  # Optional. The ETag value to implement optimistic
                      concurrency.
                    "hardwareId": "str",  # Optional. Device hardwareId.
                    "id": "str",  # Optional. Id of the resource.
                    "integrationId": "str",  # Optional. Integration id for the device.
                    "location": {
                        "latitude": 0.0,  # Latitude of the location. Required.
                        "longitude": 0.0  # Longitude of the location. Required.
                    },
                    "modifiedBy": "str",  # Optional. Modified by user/tenant id.
                    "modifiedDateTime": "2020-02-20 00:00:00",  # Optional. Date-time when
                      resource was last modified, sample format: yyyy-MM-ddTHH:mm:ssZ.
                    "name": "str",  # Optional. Name to identify resource.
                    "parentDeviceId": "str",  # Optional. Parent device Id for this device.
                    "properties": {
                        "str": {}  # Optional. A collection of key value pairs that belongs
                          to the resource."nEach pair must not have a key greater than 50
                          characters"nand must not have a value greater than 150 characters."nNote: A
                          maximum of 25 key value pairs can be provided for a resource and"nonly
                          string, numeral and datetime (yyyy-MM-ddTHH:mm:ssZ) values are supported.
                    },
                    "reportingIntervalInSeconds": 0,  # Optional. Interval at which the device
                      sends data in seconds.
                    "sensorPartnerId": "str",  # Optional. Id of the associated sensor partner.
                    "status": "str",  # Optional. Status of the resource.
                    "type": "str"  # Optional. Type of device.
                }
        """
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls = kwargs.pop("cls", None)  # type: ClsType[JSON]

        request = build_devices_get_request(
            sensor_partner_id=sensor_partner_id,
            device_id=device_id,
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        request.url = self._client.format_url(request.url)  # type: ignore

        pipeline_response = self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
            request, stream=False, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if response.content:
            deserialized = response.json()
        else:
            deserialized = None

        if cls:
            return cls(pipeline_response, cast(JSON, deserialized), {})

        return cast(JSON, deserialized)

    @distributed_trace
    def delete(  # pylint: disable=inconsistent-return-statements
        self, sensor_partner_id: str, device_id: str, **kwargs: Any
    ) -> None:
        """Deletes a device entity.

        :param sensor_partner_id: Id of the sensor partner. Required.
        :type sensor_partner_id: str
        :param device_id: Id of the device resource. Required.
        :type device_id: str
        :return: None
        :rtype: None
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls = kwargs.pop("cls", None)  # type: ClsType[None]

        request = build_devices_delete_request(
            sensor_partner_id=sensor_partner_id,
            device_id=device_id,
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        request.url = self._client.format_url(request.url)  # type: ignore

        pipeline_response = self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
            request, stream=False, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [204]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if cls:
            return cls(pipeline_response, None, {})


class FarmOperationsOperations:
    """
    .. warning::
        **DO NOT** instantiate this class directly.

        Instead, you should access the following operations through
        :class:`~azure.agrifood.farming.FarmBeatsClient`'s
        :attr:`farm_operations` attribute.
    """

    def __init__(self, *args, **kwargs):
        input_args = list(args)
        self._client = input_args.pop(0) if input_args else kwargs.pop("client")
        self._config = input_args.pop(0) if input_args else kwargs.pop("config")
        self._serialize = input_args.pop(0) if input_args else kwargs.pop("serializer")
        self._deserialize = input_args.pop(0) if input_args else kwargs.pop("deserializer")

    def _create_data_ingestion_job_initial(self, job_id: str, job: Union[JSON, IO], **kwargs: Any) -> JSON:
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type = kwargs.pop("content_type", _headers.pop("Content-Type", None))  # type: Optional[str]
        cls = kwargs.pop("cls", None)  # type: ClsType[JSON]

        content_type = content_type or "application/json"
        _json = None
        _content = None
        if isinstance(job, (IO, bytes)):
            _content = job
        else:
            _json = job

        request = build_farm_operations_create_data_ingestion_job_request(
            job_id=job_id,
            content_type=content_type,
            api_version=self._config.api_version,
            json=_json,
            content=_content,
            headers=_headers,
            params=_params,
        )
        request.url = self._client.format_url(request.url)  # type: ignore

        pipeline_response = self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
            request, stream=False, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [202]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if response.content:
            deserialized = response.json()
        else:
            deserialized = None

        if cls:
            return cls(pipeline_response, cast(JSON, deserialized), {})

        return cast(JSON, deserialized)

    @overload
    def begin_create_data_ingestion_job(
        self, job_id: str, job: JSON, *, content_type: str = "application/json", **kwargs: Any
    ) -> LROPoller[JSON]:
        """Create a farm operation data ingestion job.

        :param job_id: Job Id supplied by user. Required.
        :type job_id: str
        :param job: Job parameters supplied by user. Required.
        :type job: JSON
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :keyword str continuation_token: A continuation token to restart a poller from a saved state.
        :keyword polling: By default, your polling method will be LROBasePolling. Pass in False for
         this operation to not poll, or pass in your own initialized polling object for a personal
         polling strategy.
        :paramtype polling: bool or ~azure.core.polling.PollingMethod
        :keyword int polling_interval: Default waiting time between two polls for LRO operations if no
         Retry-After header is present.
        :return: An instance of LROPoller that returns JSON object
        :rtype: ~azure.core.polling.LROPoller[JSON]
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                job = {
                    "authProviderId": "str",  # Authentication provider Id. Required.
                    "partyId": "str",  # Party Id. Required.
                    "startYear": 0,  # Start Year (Minimum = 2000, Maximum = CurrentYear).
                      Required.
                    "createdBy": "str",  # Optional. Created by user/tenant id.
                    "createdDateTime": "2020-02-20 00:00:00",  # Optional. Job created at
                      dateTime. Sample format: yyyy-MM-ddTHH:mm:ssZ.
                    "description": "str",  # Optional. Textual description of the resource.
                    "durationInSeconds": 0.0,  # Optional. Duration of the job in seconds.
                    "endTime": "2020-02-20 00:00:00",  # Optional. Job end time when available.
                      Sample format: yyyy-MM-ddTHH:mm:ssZ.
                    "errorCode": "str",  # Optional. Error Code when job failed.
                    "id": "str",  # Optional. Unique job id.
                    "isIncremental": False,  # Optional. Default value is False. Use this to pull
                      only the incremental changes from the last run.
                    "lastActionDateTime": "2020-02-20 00:00:00",  # Optional. Job was last acted
                      upon at dateTime. Sample format: yyyy-MM-ddTHH:mm:ssZ.
                    "message": "str",  # Optional. Status message to capture more details of the
                      job.
                    "modifiedBy": "str",  # Optional. Modified by user/tenant id.
                    "name": "str",  # Optional. Name to identify resource.
                    "operations": [
                        "str"  # Optional. List of operation types for which data needs to be
                          downloaded. Available values: AllOperations, Application, Planting, Harvest,
                          Tillage.
                    ],
                    "properties": {
                        "str": {}  # Optional. A collection of key value pairs that belongs
                          to the resource."nEach pair must not have a key greater than 50
                          characters"nand must not have a value greater than 150 characters."nNote: A
                          maximum of 25 key value pairs can be provided for a resource and only
                          string,"nnumeral and datetime (yyyy-MM-ddTHH:mm:ssZ) values are supported.
                    },
                    "startTime": "2020-02-20 00:00:00",  # Optional. Job start time when
                      available. Sample format: yyyy-MM-ddTHH:mm:ssZ.
                    "status": "str"  # Optional. Status of the job."nPossible values: 'Waiting',
                      'Running', 'Succeeded', 'Failed', 'Cancelled'.
                }

                # response body for status code(s): 202
                response == {
                    "authProviderId": "str",  # Authentication provider Id. Required.
                    "partyId": "str",  # Party Id. Required.
                    "startYear": 0,  # Start Year (Minimum = 2000, Maximum = CurrentYear).
                      Required.
                    "createdBy": "str",  # Optional. Created by user/tenant id.
                    "createdDateTime": "2020-02-20 00:00:00",  # Optional. Job created at
                      dateTime. Sample format: yyyy-MM-ddTHH:mm:ssZ.
                    "description": "str",  # Optional. Textual description of the resource.
                    "durationInSeconds": 0.0,  # Optional. Duration of the job in seconds.
                    "endTime": "2020-02-20 00:00:00",  # Optional. Job end time when available.
                      Sample format: yyyy-MM-ddTHH:mm:ssZ.
                    "errorCode": "str",  # Optional. Error Code when job failed.
                    "id": "str",  # Optional. Unique job id.
                    "isIncremental": False,  # Optional. Default value is False. Use this to pull
                      only the incremental changes from the last run.
                    "lastActionDateTime": "2020-02-20 00:00:00",  # Optional. Job was last acted
                      upon at dateTime. Sample format: yyyy-MM-ddTHH:mm:ssZ.
                    "message": "str",  # Optional. Status message to capture more details of the
                      job.
                    "modifiedBy": "str",  # Optional. Modified by user/tenant id.
                    "name": "str",  # Optional. Name to identify resource.
                    "operations": [
                        "str"  # Optional. List of operation types for which data needs to be
                          downloaded. Available values: AllOperations, Application, Planting, Harvest,
                          Tillage.
                    ],
                    "properties": {
                        "str": {}  # Optional. A collection of key value pairs that belongs
                          to the resource."nEach pair must not have a key greater than 50
                          characters"nand must not have a value greater than 150 characters."nNote: A
                          maximum of 25 key value pairs can be provided for a resource and only
                          string,"nnumeral and datetime (yyyy-MM-ddTHH:mm:ssZ) values are supported.
                    },
                    "startTime": "2020-02-20 00:00:00",  # Optional. Job start time when
                      available. Sample format: yyyy-MM-ddTHH:mm:ssZ.
                    "status": "str"  # Optional. Status of the job."nPossible values: 'Waiting',
                      'Running', 'Succeeded', 'Failed', 'Cancelled'.
                }
        """

    @overload
    def begin_create_data_ingestion_job(
        self, job_id: str, job: IO, *, content_type: str = "application/json", **kwargs: Any
    ) -> LROPoller[JSON]:
        """Create a farm operation data ingestion job.

        :param job_id: Job Id supplied by user. Required.
        :type job_id: str
        :param job: Job parameters supplied by user. Required.
        :type job: IO
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Default value is "application/json".
        :paramtype content_type: str
        :keyword str continuation_token: A continuation token to restart a poller from a saved state.
        :keyword polling: By default, your polling method will be LROBasePolling. Pass in False for
         this operation to not poll, or pass in your own initialized polling object for a personal
         polling strategy.
        :paramtype polling: bool or ~azure.core.polling.PollingMethod
        :keyword int polling_interval: Default waiting time between two polls for LRO operations if no
         Retry-After header is present.
        :return: An instance of LROPoller that returns JSON object
        :rtype: ~azure.core.polling.LROPoller[JSON]
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 202
                response == {
                    "authProviderId": "str",  # Authentication provider Id. Required.
                    "partyId": "str",  # Party Id. Required.
                    "startYear": 0,  # Start Year (Minimum = 2000, Maximum = CurrentYear).
                      Required.
                    "createdBy": "str",  # Optional. Created by user/tenant id.
                    "createdDateTime": "2020-02-20 00:00:00",  # Optional. Job created at
                      dateTime. Sample format: yyyy-MM-ddTHH:mm:ssZ.
                    "description": "str",  # Optional. Textual description of the resource.
                    "durationInSeconds": 0.0,  # Optional. Duration of the job in seconds.
                    "endTime": "2020-02-20 00:00:00",  # Optional. Job end time when available.
                      Sample format: yyyy-MM-ddTHH:mm:ssZ.
                    "errorCode": "str",  # Optional. Error Code when job failed.
                    "id": "str",  # Optional. Unique job id.
                    "isIncremental": False,  # Optional. Default value is False. Use this to pull
                      only the incremental changes from the last run.
                    "lastActionDateTime": "2020-02-20 00:00:00",  # Optional. Job was last acted
                      upon at dateTime. Sample format: yyyy-MM-ddTHH:mm:ssZ.
                    "message": "str",  # Optional. Status message to capture more details of the
                      job.
                    "modifiedBy": "str",  # Optional. Modified by user/tenant id.
                    "name": "str",  # Optional. Name to identify resource.
                    "operations": [
                        "str"  # Optional. List of operation types for which data needs to be
                          downloaded. Available values: AllOperations, Application, Planting, Harvest,
                          Tillage.
                    ],
                    "properties": {
                        "str": {}  # Optional. A collection of key value pairs that belongs
                          to the resource."nEach pair must not have a key greater than 50
                          characters"nand must not have a value greater than 150 characters."nNote: A
                          maximum of 25 key value pairs can be provided for a resource and only
                          string,"nnumeral and datetime (yyyy-MM-ddTHH:mm:ssZ) values are supported.
                    },
                    "startTime": "2020-02-20 00:00:00",  # Optional. Job start time when
                      available. Sample format: yyyy-MM-ddTHH:mm:ssZ.
                    "status": "str"  # Optional. Status of the job."nPossible values: 'Waiting',
                      'Running', 'Succeeded', 'Failed', 'Cancelled'.
                }
        """

    @distributed_trace
    def begin_create_data_ingestion_job(self, job_id: str, job: Union[JSON, IO], **kwargs: Any) -> LROPoller[JSON]:
        """Create a farm operation data ingestion job.

        :param job_id: Job Id supplied by user. Required.
        :type job_id: str
        :param job: Job parameters supplied by user. Is either a model type or a IO type. Required.
        :type job: JSON or IO
        :keyword content_type: Body Parameter content-type. Known values are: 'application/json'.
         Default value is None.
        :paramtype content_type: str
        :keyword str continuation_token: A continuation token to restart a poller from a saved state.
        :keyword polling: By default, your polling method will be LROBasePolling. Pass in False for
         this operation to not poll, or pass in your own initialized polling object for a personal
         polling strategy.
        :paramtype polling: bool or ~azure.core.polling.PollingMethod
        :keyword int polling_interval: Default waiting time between two polls for LRO operations if no
         Retry-After header is present.
        :return: An instance of LROPoller that returns JSON object
        :rtype: ~azure.core.polling.LROPoller[JSON]
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 202
                response == {
                    "authProviderId": "str",  # Authentication provider Id. Required.
                    "partyId": "str",  # Party Id. Required.
                    "startYear": 0,  # Start Year (Minimum = 2000, Maximum = CurrentYear).
                      Required.
                    "createdBy": "str",  # Optional. Created by user/tenant id.
                    "createdDateTime": "2020-02-20 00:00:00",  # Optional. Job created at
                      dateTime. Sample format: yyyy-MM-ddTHH:mm:ssZ.
                    "description": "str",  # Optional. Textual description of the resource.
                    "durationInSeconds": 0.0,  # Optional. Duration of the job in seconds.
                    "endTime": "2020-02-20 00:00:00",  # Optional. Job end time when available.
                      Sample format: yyyy-MM-ddTHH:mm:ssZ.
                    "errorCode": "str",  # Optional. Error Code when job failed.
                    "id": "str",  # Optional. Unique job id.
                    "isIncremental": False,  # Optional. Default value is False. Use this to pull
                      only the incremental changes from the last run.
                    "lastActionDateTime": "2020-02-20 00:00:00",  # Optional. Job was last acted
                      upon at dateTime. Sample format: yyyy-MM-ddTHH:mm:ssZ.
                    "message": "str",  # Optional. Status message to capture more details of the
                      job.
                    "modifiedBy": "str",  # Optional. Modified by user/tenant id.
                    "name": "str",  # Optional. Name to identify resource.
                    "operations": [
                        "str"  # Optional. List of operation types for which data needs to be
                          downloaded. Available values: AllOperations, Application, Planting, Harvest,
                          Tillage.
                    ],
                    "properties": {
                        "str": {}  # Optional. A collection of key value pairs that belongs
                          to the resource."nEach pair must not have a key greater than 50
                          characters"nand must not have a value greater than 150 characters."nNote: A
                          maximum of 25 key value pairs can be provided for a resource and only
                          string,"nnumeral and datetime (yyyy-MM-ddTHH:mm:ssZ) values are supported.
                    },
                    "startTime": "2020-02-20 00:00:00",  # Optional. Job start time when
                      available. Sample format: yyyy-MM-ddTHH:mm:ssZ.
                    "status": "str"  # Optional. Status of the job."nPossible values: 'Waiting',
                      'Running', 'Succeeded', 'Failed', 'Cancelled'.
                }
        """
        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type = kwargs.pop("content_type", _headers.pop("Content-Type", None))  # type: Optional[str]
        cls = kwargs.pop("cls", None)  # type: ClsType[JSON]
        polling = kwargs.pop("polling", True)  # type: Union[bool, PollingMethod]
        lro_delay = kwargs.pop("polling_interval", self._config.polling_interval)
        cont_token = kwargs.pop("continuation_token", None)  # type: Optional[str]
        if cont_token is None:
            raw_result = self._create_data_ingestion_job_initial(  # type: ignore
                job_id=job_id,
                job=job,
                content_type=content_type,
                cls=lambda x, y, z: x,
                headers=_headers,
                params=_params,
                **kwargs
            )
        kwargs.pop("error_map", None)

        def get_long_running_output(pipeline_response):
            response = pipeline_response.http_response
            if response.content:
                deserialized = response.json()
            else:
                deserialized = None
            if cls:
                return cls(pipeline_response, deserialized, {})
            return deserialized

        if polling is True:
            polling_method = cast(
                PollingMethod, LROBasePolling(lro_delay, lro_options={"final-state-via": "location"}, **kwargs)
            )  # type: PollingMethod
        elif polling is False:
            polling_method = cast(PollingMethod, NoPolling())
        else:
            polling_method = polling
        if cont_token:
            return LROPoller.from_continuation_token(
                polling_method=polling_method,
                continuation_token=cont_token,
                client=self._client,
                deserialization_callback=get_long_running_output,
            )
        return LROPoller(self._client, raw_result, get_long_running_output, polling_method)

    @distributed_trace
    def get_data_ingestion_job_details(self, job_id: str, **kwargs: Any) -> JSON:
        """Get a farm operation data ingestion job.

        :param job_id: Id of the job. Required.
        :type job_id: str
        :return: JSON object
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "authProviderId": "str",  # Authentication provider Id. Required.
                    "partyId": "str",  # Party Id. Required.
                    "startYear": 0,  # Start Year (Minimum = 2000, Maximum = CurrentYear).
                      Required.
                    "createdBy": "str",  # Optional. Created by user/tenant id.
                    "createdDateTime": "2020-02-20 00:00:00",  # Optional. Job created at
                      dateTime. Sample format: yyyy-MM-ddTHH:mm:ssZ.
                    "description": "str",  # Optional. Textual description of the resource.
                    "durationInSeconds": 0.0,  # Optional. Duration of the job in seconds.
                    "endTime": "2020-02-20 00:00:00",  # Optional. Job end time when available.
                      Sample format: yyyy-MM-ddTHH:mm:ssZ.
                    "errorCode": "str",  # Optional. Error Code when job failed.
                    "id": "str",  # Optional. Unique job id.
                    "isIncremental": False,  # Optional. Default value is False. Use this to pull
                      only the incremental changes from the last run.
                    "lastActionDateTime": "2020-02-20 00:00:00",  # Optional. Job was last acted
                      upon at dateTime. Sample format: yyyy-MM-ddTHH:mm:ssZ.
                    "message": "str",  # Optional. Status message to capture more details of the
                      job.
                    "modifiedBy": "str",  # Optional. Modified by user/tenant id.
                    "name": "str",  # Optional. Name to identify resource.
                    "operations": [
                        "str"  # Optional. List of operation types for which data needs to be
                          downloaded. Available values: AllOperations, Application, Planting, Harvest,
                          Tillage.
                    ],
                    "properties": {
                        "str": {}  # Optional. A collection of key value pairs that belongs
                          to the resource."nEach pair must not have a key greater than 50
                          characters"nand must not have a value greater than 150 characters."nNote: A
                          maximum of 25 key value pairs can be provided for a resource and only
                          string,"nnumeral and datetime (yyyy-MM-ddTHH:mm:ssZ) values are supported.
                    },
                    "startTime": "2020-02-20 00:00:00",  # Optional. Job start time when
                      available. Sample format: yyyy-MM-ddTHH:mm:ssZ.
                    "status": "str"  # Optional. Status of the job."nPossible values: 'Waiting',
                      'Running', 'Succeeded', 'Failed', 'Cancelled'.
                }
        """
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls = kwargs.pop("cls", None)  # type: ClsType[JSON]

        request = build_farm_operations_get_data_ingestion_job_details_request(
            job_id=job_id,
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        request.url = self._client.format_url(request.url)  # type: ignore

        pipeline_response = self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
            request, stream=False, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if response.content:
            deserialized = response.json()
        else:
            deserialized = None

        if cls:
            return cls(pipeline_response, cast(JSON, deserialized), {})

        return cast(JSON, deserialized)


class FarmsOperations:
    """
    .. warning::
        **DO NOT** instantiate this class directly.

        Instead, you should access the following operations through
        :class:`~azure.agrifood.farming.FarmBeatsClient`'s
        :attr:`farms` attribute.
    """

    def __init__(self, *args, **kwargs):
        input_args = list(args)
        self._client = input_args.pop(0) if input_args else kwargs.pop("client")
        self._config = input_args.pop(0) if input_args else kwargs.pop("config")
        self._serialize = input_args.pop(0) if input_args else kwargs.pop("serializer")
        self._deserialize = input_args.pop(0) if input_args else kwargs.pop("deserializer")

    @distributed_trace
    def list(
        self,
        *,
        ids: Optional[List[str]] = None,
        names: Optional[List[str]] = None,
        property_filters: Optional[List[str]] = None,
        statuses: Optional[List[str]] = None,
        min_created_date_time: Optional[datetime.datetime] = None,
        max_created_date_time: Optional[datetime.datetime] = None,
        min_last_modified_date_time: Optional[datetime.datetime] = None,
        max_last_modified_date_time: Optional[datetime.datetime] = None,
        skip_token: Optional[str] = None,
        **kwargs: Any
    ) -> Iterable[JSON]:
        """Returns a paginated list of farm resources across all parties.

        :keyword ids: Ids of the resource. Default value is None.
        :paramtype ids: list[str]
        :keyword names: Names of the resource. Default value is None.
        :paramtype names: list[str]
        :keyword property_filters: Filters on key-value pairs within the Properties object.
         eg. "{testKey} eq {testValue}". Default value is None.
        :paramtype property_filters: list[str]
        :keyword statuses: Statuses of the resource. Default value is None.
        :paramtype statuses: list[str]
        :keyword min_created_date_time: Minimum creation date of resource (inclusive). Default value is
         None.
        :paramtype min_created_date_time: ~datetime.datetime
        :keyword max_created_date_time: Maximum creation date of resource (inclusive). Default value is
         None.
        :paramtype max_created_date_time: ~datetime.datetime
        :keyword min_last_modified_date_time: Minimum last modified date of resource (inclusive).
         Default value is None.
        :paramtype min_last_modified_date_time: ~datetime.datetime
        :keyword max_last_modified_date_time: Maximum last modified date of resource (inclusive).
         Default value is None.
        :paramtype max_last_modified_date_time: ~datetime.datetime
        :keyword skip_token: Skip token for getting next set of results. Default value is None.
        :paramtype skip_token: str
        :return: An iterator like instance of JSON object
        :rtype: ~azure.core.paging.ItemPaged[JSON]
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "createdBy": "str",  # Optional. Created by user/tenant id.
                    "createdDateTime": "2020-02-20 00:00:00",  # Optional. Date-time when
                      resource was created, sample format: yyyy-MM-ddTHH:mm:ssZ.
                    "description": "str",  # Optional. Textual description of the resource.
                    "eTag": "str",  # Optional. The ETag value to implement optimistic
                      concurrency.
                    "id": "str",  # Optional. Unique resource ID.
                    "modifiedBy": "str",  # Optional. Modified by user/tenant id.
                    "modifiedDateTime": "2020-02-20 00:00:00",  # Optional. Date-time when
                      resource was last modified, sample format: yyyy-MM-ddTHH:mm:ssZ.
                    "name": "str",  # Optional. Name to identify resource.
                    "partyId": "str",  # Optional. Party Id.
                    "properties": {
                        "str": {}  # Optional. A collection of key value pairs that belongs
                          to the resource."nEach pair must not have a key greater than 50
                          characters"nand must not have a value greater than 150 characters."nNote: A
                          maximum of 25 key value pairs can be provided for a resource and only
                          string,"nnumeral and datetime (yyyy-MM-ddTHH:mm:ssZ) values are supported.
                    },
                    "source": "str",  # Optional. Source of the resource.
                    "status": "str"  # Optional. Status of the resource.
                }
        """
        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls = kwargs.pop("cls", None)  # type: ClsType[JSON]

        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        def prepare_request(next_link=None):
            if not next_link:

                request = build_farms_list_request(
                    ids=ids,
                    names=names,
                    property_filters=property_filters,
                    statuses=statuses,
                    min_created_date_time=min_created_date_time,
                    max_created_date_time=max_created_date_time,
                    min_last_modified_date_time=min_last_modified_date_time,
                    max_last_modified_date_time=max_last_modified_date_time,
                    skip_token=skip_token,
                    api_version=self._config.api_version,
                    headers=_headers,
                    params=_params,
                )
                request.url = self._client.format_url(request.url)  # type: ignore

            else:
                # make call to next link with the client's api-version
                _parsed_next_link = urlparse(next_link)
                _next_request_params = case_insensitive_dict(parse_qs(_parsed_next_link.query))
                _next_request_params["api-version"] = self._config.api_version
                request = HttpRequest("GET", urljoin(next_link, _parsed_next_link.path), params=_next_request_params)
                request.url = self._client.format_url(request.url)  # type: ignore

            return request

        def extract_data(pipeline_response):
            deserialized = pipeline_response.http_response.json()
            list_of_elem = deserialized["value"]
            if cls:
                list_of_elem = cls(list_of_elem)
            return deserialized.get("nextLink", None), iter(list_of_elem)

        def get_next(next_link=None):
            request = prepare_request(next_link)

            pipeline_response = self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
                request, stream=False, **kwargs
            )
            response = pipeline_response.http_response

            if response.status_code not in [200]:
                map_error(status_code=response.status_code, response=response, error_map=error_map)
                raise HttpResponseError(response=response)

            return pipeline_response

        return ItemPaged(get_next, extract_data)

    def _create_cascade_delete_job_initial(self, job_id: str, *, party_id: str, farm_id: str, **kwargs: Any) -> JSON:
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls = kwargs.pop("cls", None)  # type: ClsType[JSON]

        request = build_farms_create_cascade_delete_job_request(
            job_id=job_id,
            party_id=party_id,
            farm_id=farm_id,
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        request.url = self._client.format_url(request.url)  # type: ignore

        pipeline_response = self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
            request, stream=False, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [202]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if response.content:
            deserialized = response.json()
        else:
            deserialized = None

        if cls:
            return cls(pipeline_response, cast(JSON, deserialized), {})

        return cast(JSON, deserialized)

    @distributed_trace
    def begin_create_cascade_delete_job(
        self, job_id: str, *, party_id: str, farm_id: str, **kwargs: Any
    ) -> LROPoller[JSON]:
        """Create a cascade delete job for specified farm.

        :param job_id: Job ID supplied by end user. Required.
        :type job_id: str
        :keyword party_id: ID of the associated party. Required.
        :paramtype party_id: str
        :keyword farm_id: ID of the farm to be deleted. Required.
        :paramtype farm_id: str
        :keyword str continuation_token: A continuation token to restart a poller from a saved state.
        :keyword polling: By default, your polling method will be LROBasePolling. Pass in False for
         this operation to not poll, or pass in your own initialized polling object for a personal
         polling strategy.
        :paramtype polling: bool or ~azure.core.polling.PollingMethod
        :keyword int polling_interval: Default waiting time between two polls for LRO operations if no
         Retry-After header is present.
        :return: An instance of LROPoller that returns JSON object
        :rtype: ~azure.core.polling.LROPoller[JSON]
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 202
                response == {
                    "partyId": "str",  # Party Id. Required.
                    "resourceId": "str",  # The id of the resource. Required.
                    "resourceType": "str",  # The type of the resource. Required.
                    "createdDateTime": "2020-02-20 00:00:00",  # Optional. Job created at
                      dateTime. Sample format: yyyy-MM-ddTHH:mm:ssZ.
                    "durationInSeconds": 0.0,  # Optional. Duration of the job in seconds.
                    "endTime": "2020-02-20 00:00:00",  # Optional. Job end time when available.
                      Sample format: yyyy-MM-ddTHH:mm:ssZ.
                    "errorCode": "str",  # Optional. Error Code when job failed.
                    "id": "str",  # Optional. Unique job id.
                    "lastActionDateTime": "2020-02-20 00:00:00",  # Optional. Job was last acted
                      upon at dateTime. Sample format: yyyy-MM-ddTHH:mm:ssZ.
                    "message": "str",  # Optional. Status message to capture more details of the
                      job.
                    "startTime": "2020-02-20 00:00:00",  # Optional. Job start time when
                      available. Sample format: yyyy-MM-ddTHH:mm:ssZ.
                    "status": "str"  # Optional. Status of the job."nPossible values: 'Waiting',
                      'Running', 'Succeeded', 'Failed', 'Cancelled'. Known values are: "Waiting",
                      "Running", "Succeeded", "Failed", and "Cancelled".
                }
        """
        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls = kwargs.pop("cls", None)  # type: ClsType[JSON]
        polling = kwargs.pop("polling", True)  # type: Union[bool, PollingMethod]
        lro_delay = kwargs.pop("polling_interval", self._config.polling_interval)
        cont_token = kwargs.pop("continuation_token", None)  # type: Optional[str]
        if cont_token is None:
            raw_result = self._create_cascade_delete_job_initial(  # type: ignore
                job_id=job_id,
                party_id=party_id,
                farm_id=farm_id,
                cls=lambda x, y, z: x,
                headers=_headers,
                params=_params,
                **kwargs
            )
        kwargs.pop("error_map", None)

        def get_long_running_output(pipeline_response):
            response = pipeline_response.http_response
            if response.content:
                deserialized = response.json()
            else:
                deserialized = None
            if cls:
                return cls(pipeline_response, deserialized, {})
            return deserialized

        if polling is True:
            polling_method = cast(
                PollingMethod, LROBasePolling(lro_delay, lro_options={"final-state-via": "location"}, **kwargs)
            )  # type: PollingMethod
        elif polling is False:
            polling_method = cast(PollingMethod, NoPolling())
        else:
            polling_method = polling
        if cont_token:
            return LROPoller.from_continuation_token(
                polling_method=polling_method,
                continuation_token=cont_token,
                client=self._client,
                deserialization_callback=get_long_running_output,
            )
        return LROPoller(self._client, raw_result, get_long_running_output, polling_method)

    @distributed_trace
    def get_cascade_delete_job_details(self, job_id: str, **kwargs: Any) -> JSON:
        """Get a cascade delete job for specified farm.

        :param job_id: Id of the job. Required.
        :type job_id: str
        :return: JSON object
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "partyId": "str",  # Party Id. Required.
                    "resourceId": "str",  # The id of the resource. Required.
                    "resourceType": "str",  # The type of the resource. Required.
                    "createdDateTime": "2020-02-20 00:00:00",  # Optional. Job created at
                      dateTime. Sample format: yyyy-MM-ddTHH:mm:ssZ.
                    "durationInSeconds": 0.0,  # Optional. Duration of the job in seconds.
                    "endTime": "2020-02-20 00:00:00",  # Optional. Job end time when available.
                      Sample format: yyyy-MM-ddTHH:mm:ssZ.
                    "errorCode": "str",  # Optional. Error Code when job failed.
                    "id": "str",  # Optional. Unique job id.
                    "lastActionDateTime": "2020-02-20 00:00:00",  # Optional. Job was last acted
                      upon at dateTime. Sample format: yyyy-MM-ddTHH:mm:ssZ.
                    "message": "str",  # Optional. Status message to capture more details of the
                      job.
                    "startTime": "2020-02-20 00:00:00",  # Optional. Job start time when
                      available. Sample format: yyyy-MM-ddTHH:mm:ssZ.
                    "status": "str"  # Optional. Status of the job."nPossible values: 'Waiting',
                      'Running', 'Succeeded', 'Failed', 'Cancelled'. Known values are: "Waiting",
                      "Running", "Succeeded", "Failed", and "Cancelled".
                }
        """
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls = kwargs.pop("cls", None)  # type: ClsType[JSON]

        request = build_farms_get_cascade_delete_job_details_request(
            job_id=job_id,
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        request.url = self._client.format_url(request.url)  # type: ignore

        pipeline_response = self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
            request, stream=False, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if response.content:
            deserialized = response.json()
        else:
            deserialized = None

        if cls:
            return cls(pipeline_response, cast(JSON, deserialized), {})

        return cast(JSON, deserialized)

    @distributed_trace
    def list_by_party_id(
        self,
        party_id: str,
        *,
        ids: Optional[List[str]] = None,
        names: Optional[List[str]] = None,
        property_filters: Optional[List[str]] = None,
        statuses: Optional[List[str]] = None,
        min_created_date_time: Optional[datetime.datetime] = None,
        max_created_date_time: Optional[datetime.datetime] = None,
        min_last_modified_date_time: Optional[datetime.datetime] = None,
        max_last_modified_date_time: Optional[datetime.datetime] = None,
        skip_token: Optional[str] = None,
        **kwargs: Any
    ) -> Iterable[JSON]:
        """Returns a paginated list of farm resources under a particular party.

        :param party_id: Id of the associated party. Required.
        :type party_id: str
        :keyword ids: Ids of the resource. Default value is None.
        :paramtype ids: list[str]
        :keyword names: Names of the resource. Default value is None.
        :paramtype names: list[str]
        :keyword property_filters: Filters on key-value pairs within the Properties object.
         eg. "{testKey} eq {testValue}". Default value is None.
        :paramtype property_filters: list[str]
        :keyword statuses: Statuses of the resource. Default value is None.
        :paramtype statuses: list[str]
        :keyword min_created_date_time: Minimum creation date of resource (inclusive). Default value is
         None.
        :paramtype min_created_date_time: ~datetime.datetime
        :keyword max_created_date_time: Maximum creation date of resource (inclusive). Default value is
         None.
        :paramtype max_created_date_time: ~datetime.datetime
        :keyword min_last_modified_date_time: Minimum last modified date of resource (inclusive).
         Default value is None.
        :paramtype min_last_modified_date_time: ~datetime.datetime
        :keyword max_last_modified_date_time: Maximum last modified date of resource (inclusive).
         Default value is None.
        :paramtype max_last_modified_date_time: ~datetime.datetime
        :keyword skip_token: Skip token for getting next set of results. Default value is None.
        :paramtype skip_token: str
        :return: An iterator like instance of JSON object
        :rtype: ~azure.core.paging.ItemPaged[JSON]
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "createdBy": "str",  # Optional. Created by user/tenant id.
                    "createdDateTime": "2020-02-20 00:00:00",  # Optional. Date-time when
                      resource was created, sample format: yyyy-MM-ddTHH:mm:ssZ.
                    "description": "str",  # Optional. Textual description of the resource.
                    "eTag": "str",  # Optional. The ETag value to implement optimistic
                      concurrency.
                    "id": "str",  # Optional. Unique resource ID.
                    "modifiedBy": "str",  # Optional. Modified by user/tenant id.
                    "modifiedDateTime": "2020-02-20 00:00:00",  # Optional. Date-time when
                      resource was last modified, sample format: yyyy-MM-ddTHH:mm:ssZ.
                    "name": "str",  # Optional. Name to identify resource.
                    "partyId": "str",  # Optional. Party Id.
                    "properties": {
                        "str": {}  # Optional. A collection of key value pairs that belongs
                          to the resource."nEach pair must not have a key greater than 50
                          characters"nand must not have a value greater than 150 characters."nNote: A
                          maximum of 25 key value pairs can be provided for a resource and only
                          string,"nnumeral and datetime (yyyy-MM-ddTHH:mm:ssZ) values are supported.
                    },
                    "source": "str",  # Optional. Source of the resource.
                    "status": "str"  # Optional. Status of the resource.
                }
        """
        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls = kwargs.pop("cls", None)  # type: ClsType[JSON]

        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        def prepare_request(next_link=None):
            if not next_link:

                request = build_farms_list_by_party_id_request(
                    party_id=party_id,
                    ids=ids,
                    names=names,
                    property_filters=property_filters,
                    statuses=statuses,
                    min_created_date_time=min_created_date_time,
                    max_created_date_time=max_created_date_time,
                    min_last_modified_date_time=min_last_modified_date_time,
                    max_last_modified_date_time=max_last_modified_date_time,
                    skip_token=skip_token,
                    api_version=self._config.api_version,
                    headers=_headers,
                    params=_params,
                )
                request.url = self._client.format_url(request.url)  # type: ignore

            else:
                # make call to next link with the client's api-version
                _parsed_next_link = urlparse(next_link)
                _next_request_params = case_insensitive_dict(parse_qs(_parsed_next_link.query))
                _next_request_params["api-version"] = self._config.api_version
                request = HttpRequest("GET", urljoin(next_link, _parsed_next_link.path), params=_next_request_params)
                request.url = self._client.format_url(request.url)  # type: ignore

            return request

        def extract_data(pipeline_response):
            deserialized = pipeline_response.http_response.json()
            list_of_elem = deserialized["value"]
            if cls:
                list_of_elem = cls(list_of_elem)
            return deserialized.get("nextLink", None), iter(list_of_elem)

        def get_next(next_link=None):
            request = prepare_request(next_link)

            pipeline_response = self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
                request, stream=False, **kwargs
            )
            response = pipeline_response.http_response

            if response.status_code not in [200]:
                map_error(status_code=response.status_code, response=response, error_map=error_map)
                raise HttpResponseError(response=response)

            return pipeline_response

        return ItemPaged(get_next, extract_data)

    @distributed_trace
    def get(self, party_id: str, farm_id: str, **kwargs: Any) -> JSON:
        """Gets a specified farm resource under a particular party.

        :param party_id: ID of the associated party resource. Required.
        :type party_id: str
        :param farm_id: ID of the farm resource. Required.
        :type farm_id: str
        :return: JSON object
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "createdBy": "str",  # Optional. Created by user/tenant id.
                    "createdDateTime": "2020-02-20 00:00:00",  # Optional. Date-time when
                      resource was created, sample format: yyyy-MM-ddTHH:mm:ssZ.
                    "description": "str",  # Optional. Textual description of the resource.
                    "eTag": "str",  # Optional. The ETag value to implement optimistic
                      concurrency.
                    "id": "str",  # Optional. Unique resource ID.
                    "modifiedBy": "str",  # Optional. Modified by user/tenant id.
                    "modifiedDateTime": "2020-02-20 00:00:00",  # Optional. Date-time when
                      resource was last modified, sample format: yyyy-MM-ddTHH:mm:ssZ.
                    "name": "str",  # Optional. Name to identify resource.
                    "partyId": "str",  # Optional. Party Id.
                    "properties": {
                        "str": {}  # Optional. A collection of key value pairs that belongs
                          to the resource."nEach pair must not have a key greater than 50
                          characters"nand must not have a value greater than 150 characters."nNote: A
                          maximum of 25 key value pairs can be provided for a resource and only
                          string,"nnumeral and datetime (yyyy-MM-ddTHH:mm:ssZ) values are supported.
                    },
                    "source": "str",  # Optional. Source of the resource.
                    "status": "str"  # Optional. Status of the resource.
                }
        """
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls = kwargs.pop("cls", None)  # type: ClsType[JSON]

        request = build_farms_get_request(
            party_id=party_id,
            farm_id=farm_id,
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        request.url = self._client.format_url(request.url)  # type: ignore

        pipeline_response = self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
            request, stream=False, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if response.content:
            deserialized = response.json()
        else:
            deserialized = None

        if cls:
            return cls(pipeline_response, cast(JSON, deserialized), {})

        return cast(JSON, deserialized)

    @overload
    def create_or_update(
        self,
        party_id: str,
        farm_id: str,
        farm: JSON,
        *,
        content_type: str = "application/merge-patch+json",
        **kwargs: Any
    ) -> JSON:
        """Creates or updates a farm resource under a particular party.

        :param party_id: Id of the associated party resource. Required.
        :type party_id: str
        :param farm_id: Id of the farm resource. Required.
        :type farm_id: str
        :param farm: Farm resource payload to create or update. Required.
        :type farm: JSON
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/merge-patch+json".
        :paramtype content_type: str
        :return: JSON object
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                farm = {
                    "createdBy": "str",  # Optional. Created by user/tenant id.
                    "createdDateTime": "2020-02-20 00:00:00",  # Optional. Date-time when
                      resource was created, sample format: yyyy-MM-ddTHH:mm:ssZ.
                    "description": "str",  # Optional. Textual description of the resource.
                    "eTag": "str",  # Optional. The ETag value to implement optimistic
                      concurrency.
                    "id": "str",  # Optional. Unique resource ID.
                    "modifiedBy": "str",  # Optional. Modified by user/tenant id.
                    "modifiedDateTime": "2020-02-20 00:00:00",  # Optional. Date-time when
                      resource was last modified, sample format: yyyy-MM-ddTHH:mm:ssZ.
                    "name": "str",  # Optional. Name to identify resource.
                    "partyId": "str",  # Optional. Party Id.
                    "properties": {
                        "str": {}  # Optional. A collection of key value pairs that belongs
                          to the resource."nEach pair must not have a key greater than 50
                          characters"nand must not have a value greater than 150 characters."nNote: A
                          maximum of 25 key value pairs can be provided for a resource and only
                          string,"nnumeral and datetime (yyyy-MM-ddTHH:mm:ssZ) values are supported.
                    },
                    "source": "str",  # Optional. Source of the resource.
                    "status": "str"  # Optional. Status of the resource.
                }

                # response body for status code(s): 200, 201
                response == {
                    "createdBy": "str",  # Optional. Created by user/tenant id.
                    "createdDateTime": "2020-02-20 00:00:00",  # Optional. Date-time when
                      resource was created, sample format: yyyy-MM-ddTHH:mm:ssZ.
                    "description": "str",  # Optional. Textual description of the resource.
                    "eTag": "str",  # Optional. The ETag value to implement optimistic
                      concurrency.
                    "id": "str",  # Optional. Unique resource ID.
                    "modifiedBy": "str",  # Optional. Modified by user/tenant id.
                    "modifiedDateTime": "2020-02-20 00:00:00",  # Optional. Date-time when
                      resource was last modified, sample format: yyyy-MM-ddTHH:mm:ssZ.
                    "name": "str",  # Optional. Name to identify resource.
                    "partyId": "str",  # Optional. Party Id.
                    "properties": {
                        "str": {}  # Optional. A collection of key value pairs that belongs
                          to the resource."nEach pair must not have a key greater than 50
                          characters"nand must not have a value greater than 150 characters."nNote: A
                          maximum of 25 key value pairs can be provided for a resource and only
                          string,"nnumeral and datetime (yyyy-MM-ddTHH:mm:ssZ) values are supported.
                    },
                    "source": "str",  # Optional. Source of the resource.
                    "status": "str"  # Optional. Status of the resource.
                }
        """

    @overload
    def create_or_update(
        self,
        party_id: str,
        farm_id: str,
        farm: IO,
        *,
        content_type: str = "application/merge-patch+json",
        **kwargs: Any
    ) -> JSON:
        """Creates or updates a farm resource under a particular party.

        :param party_id: Id of the associated party resource. Required.
        :type party_id: str
        :param farm_id: Id of the farm resource. Required.
        :type farm_id: str
        :param farm: Farm resource payload to create or update. Required.
        :type farm: IO
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Default value is "application/merge-patch+json".
        :paramtype content_type: str
        :return: JSON object
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200, 201
                response == {
                    "createdBy": "str",  # Optional. Created by user/tenant id.
                    "createdDateTime": "2020-02-20 00:00:00",  # Optional. Date-time when
                      resource was created, sample format: yyyy-MM-ddTHH:mm:ssZ.
                    "description": "str",  # Optional. Textual description of the resource.
                    "eTag": "str",  # Optional. The ETag value to implement optimistic
                      concurrency.
                    "id": "str",  # Optional. Unique resource ID.
                    "modifiedBy": "str",  # Optional. Modified by user/tenant id.
                    "modifiedDateTime": "2020-02-20 00:00:00",  # Optional. Date-time when
                      resource was last modified, sample format: yyyy-MM-ddTHH:mm:ssZ.
                    "name": "str",  # Optional. Name to identify resource.
                    "partyId": "str",  # Optional. Party Id.
                    "properties": {
                        "str": {}  # Optional. A collection of key value pairs that belongs
                          to the resource."nEach pair must not have a key greater than 50
                          characters"nand must not have a value greater than 150 characters."nNote: A
                          maximum of 25 key value pairs can be provided for a resource and only
                          string,"nnumeral and datetime (yyyy-MM-ddTHH:mm:ssZ) values are supported.
                    },
                    "source": "str",  # Optional. Source of the resource.
                    "status": "str"  # Optional. Status of the resource.
                }
        """

    @distributed_trace
    def create_or_update(self, party_id: str, farm_id: str, farm: Union[JSON, IO], **kwargs: Any) -> JSON:
        """Creates or updates a farm resource under a particular party.

        :param party_id: Id of the associated party resource. Required.
        :type party_id: str
        :param farm_id: Id of the farm resource. Required.
        :type farm_id: str
        :param farm: Farm resource payload to create or update. Is either a model type or a IO type.
         Required.
        :type farm: JSON or IO
        :keyword content_type: Body Parameter content-type. Known values are:
         'application/merge-patch+json'. Default value is None.
        :paramtype content_type: str
        :return: JSON object
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200, 201
                response == {
                    "createdBy": "str",  # Optional. Created by user/tenant id.
                    "createdDateTime": "2020-02-20 00:00:00",  # Optional. Date-time when
                      resource was created, sample format: yyyy-MM-ddTHH:mm:ssZ.
                    "description": "str",  # Optional. Textual description of the resource.
                    "eTag": "str",  # Optional. The ETag value to implement optimistic
                      concurrency.
                    "id": "str",  # Optional. Unique resource ID.
                    "modifiedBy": "str",  # Optional. Modified by user/tenant id.
                    "modifiedDateTime": "2020-02-20 00:00:00",  # Optional. Date-time when
                      resource was last modified, sample format: yyyy-MM-ddTHH:mm:ssZ.
                    "name": "str",  # Optional. Name to identify resource.
                    "partyId": "str",  # Optional. Party Id.
                    "properties": {
                        "str": {}  # Optional. A collection of key value pairs that belongs
                          to the resource."nEach pair must not have a key greater than 50
                          characters"nand must not have a value greater than 150 characters."nNote: A
                          maximum of 25 key value pairs can be provided for a resource and only
                          string,"nnumeral and datetime (yyyy-MM-ddTHH:mm:ssZ) values are supported.
                    },
                    "source": "str",  # Optional. Source of the resource.
                    "status": "str"  # Optional. Status of the resource.
                }
        """
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type = kwargs.pop("content_type", _headers.pop("Content-Type", None))  # type: Optional[str]
        cls = kwargs.pop("cls", None)  # type: ClsType[JSON]

        content_type = content_type or "application/merge-patch+json"
        _json = None
        _content = None
        if isinstance(farm, (IO, bytes)):
            _content = farm
        else:
            _json = farm

        request = build_farms_create_or_update_request(
            party_id=party_id,
            farm_id=farm_id,
            content_type=content_type,
            api_version=self._config.api_version,
            json=_json,
            content=_content,
            headers=_headers,
            params=_params,
        )
        request.url = self._client.format_url(request.url)  # type: ignore

        pipeline_response = self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
            request, stream=False, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200, 201]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if response.status_code == 200:
            if response.content:
                deserialized = response.json()
            else:
                deserialized = None

        if response.status_code == 201:
            if response.content:
                deserialized = response.json()
            else:
                deserialized = None

        if cls:
            return cls(pipeline_response, cast(JSON, deserialized), {})

        return cast(JSON, deserialized)

    @distributed_trace
    def delete(  # pylint: disable=inconsistent-return-statements
        self, party_id: str, farm_id: str, **kwargs: Any
    ) -> None:
        """Deletes a specified farm resource under a particular party.

        :param party_id: Id of the party. Required.
        :type party_id: str
        :param farm_id: Id of the farm. Required.
        :type farm_id: str
        :return: None
        :rtype: None
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls = kwargs.pop("cls", None)  # type: ClsType[None]

        request = build_farms_delete_request(
            party_id=party_id,
            farm_id=farm_id,
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        request.url = self._client.format_url(request.url)  # type: ignore

        pipeline_response = self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
            request, stream=False, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [204]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if cls:
            return cls(pipeline_response, None, {})


class FieldsOperations:
    """
    .. warning::
        **DO NOT** instantiate this class directly.

        Instead, you should access the following operations through
        :class:`~azure.agrifood.farming.FarmBeatsClient`'s
        :attr:`fields` attribute.
    """

    def __init__(self, *args, **kwargs):
        input_args = list(args)
        self._client = input_args.pop(0) if input_args else kwargs.pop("client")
        self._config = input_args.pop(0) if input_args else kwargs.pop("config")
        self._serialize = input_args.pop(0) if input_args else kwargs.pop("serializer")
        self._deserialize = input_args.pop(0) if input_args else kwargs.pop("deserializer")

    @distributed_trace
    def list(
        self,
        *,
        farm_ids: Optional[List[str]] = None,
        ids: Optional[List[str]] = None,
        names: Optional[List[str]] = None,
        property_filters: Optional[List[str]] = None,
        statuses: Optional[List[str]] = None,
        min_created_date_time: Optional[datetime.datetime] = None,
        max_created_date_time: Optional[datetime.datetime] = None,
        min_last_modified_date_time: Optional[datetime.datetime] = None,
        max_last_modified_date_time: Optional[datetime.datetime] = None,
        skip_token: Optional[str] = None,
        **kwargs: Any
    ) -> Iterable[JSON]:
        """Returns a paginated list of field resources across all parties.

        :keyword farm_ids: Farm Ids of the resource. Default value is None.
        :paramtype farm_ids: list[str]
        :keyword ids: Ids of the resource. Default value is None.
        :paramtype ids: list[str]
        :keyword names: Names of the resource. Default value is None.
        :paramtype names: list[str]
        :keyword property_filters: Filters on key-value pairs within the Properties object.
         eg. "{testKey} eq {testValue}". Default value is None.
        :paramtype property_filters: list[str]
        :keyword statuses: Statuses of the resource. Default value is None.
        :paramtype statuses: list[str]
        :keyword min_created_date_time: Minimum creation date of resource (inclusive). Default value is
         None.
        :paramtype min_created_date_time: ~datetime.datetime
        :keyword max_created_date_time: Maximum creation date of resource (inclusive). Default value is
         None.
        :paramtype max_created_date_time: ~datetime.datetime
        :keyword min_last_modified_date_time: Minimum last modified date of resource (inclusive).
         Default value is None.
        :paramtype min_last_modified_date_time: ~datetime.datetime
        :keyword max_last_modified_date_time: Maximum last modified date of resource (inclusive).
         Default value is None.
        :paramtype max_last_modified_date_time: ~datetime.datetime
        :keyword skip_token: Skip token for getting next set of results. Default value is None.
        :paramtype skip_token: str
        :return: An iterator like instance of JSON object
        :rtype: ~azure.core.paging.ItemPaged[JSON]
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "createdBy": "str",  # Optional. Created by user/tenant id.
                    "createdDateTime": "2020-02-20 00:00:00",  # Optional. Date-time when
                      resource was created, sample format: yyyy-MM-ddTHH:mm:ssZ.
                    "description": "str",  # Optional. Textual description of the resource.
                    "eTag": "str",  # Optional. The ETag value to implement optimistic
                      concurrency.
                    "farmId": "str",  # Optional. Id of the associated Farm.
                    "id": "str",  # Optional. Unique resource ID.
                    "modifiedBy": "str",  # Optional. Modified by user/tenant id.
                    "modifiedDateTime": "2020-02-20 00:00:00",  # Optional. Date-time when
                      resource was last modified, sample format: yyyy-MM-ddTHH:mm:ssZ.
                    "name": "str",  # Optional. Name to identify resource.
                    "partyId": "str",  # Optional. Party Id.
                    "properties": {
                        "str": {}  # Optional. A collection of key value pairs that belongs
                          to the resource."nEach pair must not have a key greater than 50
                          characters"nand must not have a value greater than 150 characters."nNote: A
                          maximum of 25 key value pairs can be provided for a resource and only
                          string,"nnumeral and datetime (yyyy-MM-ddTHH:mm:ssZ) values are supported.
                    },
                    "source": "str",  # Optional. Source of the resource.
                    "status": "str"  # Optional. Status of the resource.
                }
        """
        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls = kwargs.pop("cls", None)  # type: ClsType[JSON]

        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        def prepare_request(next_link=None):
            if not next_link:

                request = build_fields_list_request(
                    farm_ids=farm_ids,
                    ids=ids,
                    names=names,
                    property_filters=property_filters,
                    statuses=statuses,
                    min_created_date_time=min_created_date_time,
                    max_created_date_time=max_created_date_time,
                    min_last_modified_date_time=min_last_modified_date_time,
                    max_last_modified_date_time=max_last_modified_date_time,
                    skip_token=skip_token,
                    api_version=self._config.api_version,
                    headers=_headers,
                    params=_params,
                )
                request.url = self._client.format_url(request.url)  # type: ignore

            else:
                # make call to next link with the client's api-version
                _parsed_next_link = urlparse(next_link)
                _next_request_params = case_insensitive_dict(parse_qs(_parsed_next_link.query))
                _next_request_params["api-version"] = self._config.api_version
                request = HttpRequest("GET", urljoin(next_link, _parsed_next_link.path), params=_next_request_params)
                request.url = self._client.format_url(request.url)  # type: ignore

            return request

        def extract_data(pipeline_response):
            deserialized = pipeline_response.http_response.json()
            list_of_elem = deserialized["value"]
            if cls:
                list_of_elem = cls(list_of_elem)
            return deserialized.get("nextLink", None), iter(list_of_elem)

        def get_next(next_link=None):
            request = prepare_request(next_link)

            pipeline_response = self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
                request, stream=False, **kwargs
            )
            response = pipeline_response.http_response

            if response.status_code not in [200]:
                map_error(status_code=response.status_code, response=response, error_map=error_map)
                raise HttpResponseError(response=response)

            return pipeline_response

        return ItemPaged(get_next, extract_data)

    @distributed_trace
    def get_cascade_delete_job_details(self, job_id: str, **kwargs: Any) -> JSON:
        """Get a cascade delete job for specified field.

        :param job_id: Id of the job. Required.
        :type job_id: str
        :return: JSON object
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "partyId": "str",  # Party Id. Required.
                    "resourceId": "str",  # The id of the resource. Required.
                    "resourceType": "str",  # The type of the resource. Required.
                    "createdDateTime": "2020-02-20 00:00:00",  # Optional. Job created at
                      dateTime. Sample format: yyyy-MM-ddTHH:mm:ssZ.
                    "durationInSeconds": 0.0,  # Optional. Duration of the job in seconds.
                    "endTime": "2020-02-20 00:00:00",  # Optional. Job end time when available.
                      Sample format: yyyy-MM-ddTHH:mm:ssZ.
                    "errorCode": "str",  # Optional. Error Code when job failed.
                    "id": "str",  # Optional. Unique job id.
                    "lastActionDateTime": "2020-02-20 00:00:00",  # Optional. Job was last acted
                      upon at dateTime. Sample format: yyyy-MM-ddTHH:mm:ssZ.
                    "message": "str",  # Optional. Status message to capture more details of the
                      job.
                    "startTime": "2020-02-20 00:00:00",  # Optional. Job start time when
                      available. Sample format: yyyy-MM-ddTHH:mm:ssZ.
                    "status": "str"  # Optional. Status of the job."nPossible values: 'Waiting',
                      'Running', 'Succeeded', 'Failed', 'Cancelled'. Known values are: "Waiting",
                      "Running", "Succeeded", "Failed", and "Cancelled".
                }
        """
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls = kwargs.pop("cls", None)  # type: ClsType[JSON]

        request = build_fields_get_cascade_delete_job_details_request(
            job_id=job_id,
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        request.url = self._client.format_url(request.url)  # type: ignore

        pipeline_response = self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
            request, stream=False, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if response.content:
            deserialized = response.json()
        else:
            deserialized = None

        if cls:
            return cls(pipeline_response, cast(JSON, deserialized), {})

        return cast(JSON, deserialized)

    def _create_cascade_delete_job_initial(self, job_id: str, *, party_id: str, field_id: str, **kwargs: Any) -> JSON:
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls = kwargs.pop("cls", None)  # type: ClsType[JSON]

        request = build_fields_create_cascade_delete_job_request(
            job_id=job_id,
            party_id=party_id,
            field_id=field_id,
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        request.url = self._client.format_url(request.url)  # type: ignore

        pipeline_response = self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
            request, stream=False, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [202]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if response.content:
            deserialized = response.json()
        else:
            deserialized = None

        if cls:
            return cls(pipeline_response, cast(JSON, deserialized), {})

        return cast(JSON, deserialized)

    @distributed_trace
    def begin_create_cascade_delete_job(
        self, job_id: str, *, party_id: str, field_id: str, **kwargs: Any
    ) -> LROPoller[JSON]:
        """Create a cascade delete job for specified field.

        :param job_id: Job ID supplied by end user. Required.
        :type job_id: str
        :keyword party_id: ID of the associated party. Required.
        :paramtype party_id: str
        :keyword field_id: ID of the field to be deleted. Required.
        :paramtype field_id: str
        :keyword str continuation_token: A continuation token to restart a poller from a saved state.
        :keyword polling: By default, your polling method will be LROBasePolling. Pass in False for
         this operation to not poll, or pass in your own initialized polling object for a personal
         polling strategy.
        :paramtype polling: bool or ~azure.core.polling.PollingMethod
        :keyword int polling_interval: Default waiting time between two polls for LRO operations if no
         Retry-After header is present.
        :return: An instance of LROPoller that returns JSON object
        :rtype: ~azure.core.polling.LROPoller[JSON]
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 202
                response == {
                    "partyId": "str",  # Party Id. Required.
                    "resourceId": "str",  # The id of the resource. Required.
                    "resourceType": "str",  # The type of the resource. Required.
                    "createdDateTime": "2020-02-20 00:00:00",  # Optional. Job created at
                      dateTime. Sample format: yyyy-MM-ddTHH:mm:ssZ.
                    "durationInSeconds": 0.0,  # Optional. Duration of the job in seconds.
                    "endTime": "2020-02-20 00:00:00",  # Optional. Job end time when available.
                      Sample format: yyyy-MM-ddTHH:mm:ssZ.
                    "errorCode": "str",  # Optional. Error Code when job failed.
                    "id": "str",  # Optional. Unique job id.
                    "lastActionDateTime": "2020-02-20 00:00:00",  # Optional. Job was last acted
                      upon at dateTime. Sample format: yyyy-MM-ddTHH:mm:ssZ.
                    "message": "str",  # Optional. Status message to capture more details of the
                      job.
                    "startTime": "2020-02-20 00:00:00",  # Optional. Job start time when
                      available. Sample format: yyyy-MM-ddTHH:mm:ssZ.
                    "status": "str"  # Optional. Status of the job."nPossible values: 'Waiting',
                      'Running', 'Succeeded', 'Failed', 'Cancelled'. Known values are: "Waiting",
                      "Running", "Succeeded", "Failed", and "Cancelled".
                }
        """
        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls = kwargs.pop("cls", None)  # type: ClsType[JSON]
        polling = kwargs.pop("polling", True)  # type: Union[bool, PollingMethod]
        lro_delay = kwargs.pop("polling_interval", self._config.polling_interval)
        cont_token = kwargs.pop("continuation_token", None)  # type: Optional[str]
        if cont_token is None:
            raw_result = self._create_cascade_delete_job_initial(  # type: ignore
                job_id=job_id,
                party_id=party_id,
                field_id=field_id,
                cls=lambda x, y, z: x,
                headers=_headers,
                params=_params,
                **kwargs
            )
        kwargs.pop("error_map", None)

        def get_long_running_output(pipeline_response):
            response = pipeline_response.http_response
            if response.content:
                deserialized = response.json()
            else:
                deserialized = None
            if cls:
                return cls(pipeline_response, deserialized, {})
            return deserialized

        if polling is True:
            polling_method = cast(
                PollingMethod, LROBasePolling(lro_delay, lro_options={"final-state-via": "location"}, **kwargs)
            )  # type: PollingMethod
        elif polling is False:
            polling_method = cast(PollingMethod, NoPolling())
        else:
            polling_method = polling
        if cont_token:
            return LROPoller.from_continuation_token(
                polling_method=polling_method,
                continuation_token=cont_token,
                client=self._client,
                deserialization_callback=get_long_running_output,
            )
        return LROPoller(self._client, raw_result, get_long_running_output, polling_method)

    @distributed_trace
    def list_by_party_id(
        self,
        party_id: str,
        *,
        farm_ids: Optional[List[str]] = None,
        ids: Optional[List[str]] = None,
        names: Optional[List[str]] = None,
        property_filters: Optional[List[str]] = None,
        statuses: Optional[List[str]] = None,
        min_created_date_time: Optional[datetime.datetime] = None,
        max_created_date_time: Optional[datetime.datetime] = None,
        min_last_modified_date_time: Optional[datetime.datetime] = None,
        max_last_modified_date_time: Optional[datetime.datetime] = None,
        skip_token: Optional[str] = None,
        **kwargs: Any
    ) -> Iterable[JSON]:
        """Returns a paginated list of field resources under a particular party.

        :param party_id: Id of the associated party. Required.
        :type party_id: str
        :keyword farm_ids: Farm Ids of the resource. Default value is None.
        :paramtype farm_ids: list[str]
        :keyword ids: Ids of the resource. Default value is None.
        :paramtype ids: list[str]
        :keyword names: Names of the resource. Default value is None.
        :paramtype names: list[str]
        :keyword property_filters: Filters on key-value pairs within the Properties object.
         eg. "{testKey} eq {testValue}". Default value is None.
        :paramtype property_filters: list[str]
        :keyword statuses: Statuses of the resource. Default value is None.
        :paramtype statuses: list[str]
        :keyword min_created_date_time: Minimum creation date of resource (inclusive). Default value is
         None.
        :paramtype min_created_date_time: ~datetime.datetime
        :keyword max_created_date_time: Maximum creation date of resource (inclusive). Default value is
         None.
        :paramtype max_created_date_time: ~datetime.datetime
        :keyword min_last_modified_date_time: Minimum last modified date of resource (inclusive).
         Default value is None.
        :paramtype min_last_modified_date_time: ~datetime.datetime
        :keyword max_last_modified_date_time: Maximum last modified date of resource (inclusive).
         Default value is None.
        :paramtype max_last_modified_date_time: ~datetime.datetime
        :keyword skip_token: Skip token for getting next set of results. Default value is None.
        :paramtype skip_token: str
        :return: An iterator like instance of JSON object
        :rtype: ~azure.core.paging.ItemPaged[JSON]
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "createdBy": "str",  # Optional. Created by user/tenant id.
                    "createdDateTime": "2020-02-20 00:00:00",  # Optional. Date-time when
                      resource was created, sample format: yyyy-MM-ddTHH:mm:ssZ.
                    "description": "str",  # Optional. Textual description of the resource.
                    "eTag": "str",  # Optional. The ETag value to implement optimistic
                      concurrency.
                    "farmId": "str",  # Optional. Id of the associated Farm.
                    "id": "str",  # Optional. Unique resource ID.
                    "modifiedBy": "str",  # Optional. Modified by user/tenant id.
                    "modifiedDateTime": "2020-02-20 00:00:00",  # Optional. Date-time when
                      resource was last modified, sample format: yyyy-MM-ddTHH:mm:ssZ.
                    "name": "str",  # Optional. Name to identify resource.
                    "partyId": "str",  # Optional. Party Id.
                    "properties": {
                        "str": {}  # Optional. A collection of key value pairs that belongs
                          to the resource."nEach pair must not have a key greater than 50
                          characters"nand must not have a value greater than 150 characters."nNote: A
                          maximum of 25 key value pairs can be provided for a resource and only
                          string,"nnumeral and datetime (yyyy-MM-ddTHH:mm:ssZ) values are supported.
                    },
                    "source": "str",  # Optional. Source of the resource.
                    "status": "str"  # Optional. Status of the resource.
                }
        """
        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls = kwargs.pop("cls", None)  # type: ClsType[JSON]

        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        def prepare_request(next_link=None):
            if not next_link:

                request = build_fields_list_by_party_id_request(
                    party_id=party_id,
                    farm_ids=farm_ids,
                    ids=ids,
                    names=names,
                    property_filters=property_filters,
                    statuses=statuses,
                    min_created_date_time=min_created_date_time,
                    max_created_date_time=max_created_date_time,
                    min_last_modified_date_time=min_last_modified_date_time,
                    max_last_modified_date_time=max_last_modified_date_time,
                    skip_token=skip_token,
                    api_version=self._config.api_version,
                    headers=_headers,
                    params=_params,
                )
                request.url = self._client.format_url(request.url)  # type: ignore

            else:
                # make call to next link with the client's api-version
                _parsed_next_link = urlparse(next_link)
                _next_request_params = case_insensitive_dict(parse_qs(_parsed_next_link.query))
                _next_request_params["api-version"] = self._config.api_version
                request = HttpRequest("GET", urljoin(next_link, _parsed_next_link.path), params=_next_request_params)
                request.url = self._client.format_url(request.url)  # type: ignore

            return request

        def extract_data(pipeline_response):
            deserialized = pipeline_response.http_response.json()
            list_of_elem = deserialized["value"]
            if cls:
                list_of_elem = cls(list_of_elem)
            return deserialized.get("nextLink", None), iter(list_of_elem)

        def get_next(next_link=None):
            request = prepare_request(next_link)

            pipeline_response = self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
                request, stream=False, **kwargs
            )
            response = pipeline_response.http_response

            if response.status_code not in [200]:
                map_error(status_code=response.status_code, response=response, error_map=error_map)
                raise HttpResponseError(response=response)

            return pipeline_response

        return ItemPaged(get_next, extract_data)

    @distributed_trace
    def get(self, party_id: str, field_id: str, **kwargs: Any) -> JSON:
        """Gets a specified field resource under a particular party.

        :param party_id: Id of the associated party. Required.
        :type party_id: str
        :param field_id: Id of the field. Required.
        :type field_id: str
        :return: JSON object
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "createdBy": "str",  # Optional. Created by user/tenant id.
                    "createdDateTime": "2020-02-20 00:00:00",  # Optional. Date-time when
                      resource was created, sample format: yyyy-MM-ddTHH:mm:ssZ.
                    "description": "str",  # Optional. Textual description of the resource.
                    "eTag": "str",  # Optional. The ETag value to implement optimistic
                      concurrency.
                    "farmId": "str",  # Optional. Id of the associated Farm.
                    "id": "str",  # Optional. Unique resource ID.
                    "modifiedBy": "str",  # Optional. Modified by user/tenant id.
                    "modifiedDateTime": "2020-02-20 00:00:00",  # Optional. Date-time when
                      resource was last modified, sample format: yyyy-MM-ddTHH:mm:ssZ.
                    "name": "str",  # Optional. Name to identify resource.
                    "partyId": "str",  # Optional. Party Id.
                    "properties": {
                        "str": {}  # Optional. A collection of key value pairs that belongs
                          to the resource."nEach pair must not have a key greater than 50
                          characters"nand must not have a value greater than 150 characters."nNote: A
                          maximum of 25 key value pairs can be provided for a resource and only
                          string,"nnumeral and datetime (yyyy-MM-ddTHH:mm:ssZ) values are supported.
                    },
                    "source": "str",  # Optional. Source of the resource.
                    "status": "str"  # Optional. Status of the resource.
                }
        """
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls = kwargs.pop("cls", None)  # type: ClsType[JSON]

        request = build_fields_get_request(
            party_id=party_id,
            field_id=field_id,
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        request.url = self._client.format_url(request.url)  # type: ignore

        pipeline_response = self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
            request, stream=False, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if response.content:
            deserialized = response.json()
        else:
            deserialized = None

        if cls:
            return cls(pipeline_response, cast(JSON, deserialized), {})

        return cast(JSON, deserialized)

    @overload
    def create_or_update(
        self,
        party_id: str,
        field_id: str,
        field: JSON,
        *,
        content_type: str = "application/merge-patch+json",
        **kwargs: Any
    ) -> JSON:
        """Creates or Updates a field resource under a particular party.

        :param party_id: Id of the associated party resource. Required.
        :type party_id: str
        :param field_id: Id of the field resource. Required.
        :type field_id: str
        :param field: Field resource payload to create or update. Required.
        :type field: JSON
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/merge-patch+json".
        :paramtype content_type: str
        :return: JSON object
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                field = {
                    "createdBy": "str",  # Optional. Created by user/tenant id.
                    "createdDateTime": "2020-02-20 00:00:00",  # Optional. Date-time when
                      resource was created, sample format: yyyy-MM-ddTHH:mm:ssZ.
                    "description": "str",  # Optional. Textual description of the resource.
                    "eTag": "str",  # Optional. The ETag value to implement optimistic
                      concurrency.
                    "farmId": "str",  # Optional. Id of the associated Farm.
                    "id": "str",  # Optional. Unique resource ID.
                    "modifiedBy": "str",  # Optional. Modified by user/tenant id.
                    "modifiedDateTime": "2020-02-20 00:00:00",  # Optional. Date-time when
                      resource was last modified, sample format: yyyy-MM-ddTHH:mm:ssZ.
                    "name": "str",  # Optional. Name to identify resource.
                    "partyId": "str",  # Optional. Party Id.
                    "properties": {
                        "str": {}  # Optional. A collection of key value pairs that belongs
                          to the resource."nEach pair must not have a key greater than 50
                          characters"nand must not have a value greater than 150 characters."nNote: A
                          maximum of 25 key value pairs can be provided for a resource and only
                          string,"nnumeral and datetime (yyyy-MM-ddTHH:mm:ssZ) values are supported.
                    },
                    "source": "str",  # Optional. Source of the resource.
                    "status": "str"  # Optional. Status of the resource.
                }

                # response body for status code(s): 200, 201
                response == {
                    "createdBy": "str",  # Optional. Created by user/tenant id.
                    "createdDateTime": "2020-02-20 00:00:00",  # Optional. Date-time when
                      resource was created, sample format: yyyy-MM-ddTHH:mm:ssZ.
                    "description": "str",  # Optional. Textual description of the resource.
                    "eTag": "str",  # Optional. The ETag value to implement optimistic
                      concurrency.
                    "farmId": "str",  # Optional. Id of the associated Farm.
                    "id": "str",  # Optional. Unique resource ID.
                    "modifiedBy": "str",  # Optional. Modified by user/tenant id.
                    "modifiedDateTime": "2020-02-20 00:00:00",  # Optional. Date-time when
                      resource was last modified, sample format: yyyy-MM-ddTHH:mm:ssZ.
                    "name": "str",  # Optional. Name to identify resource.
                    "partyId": "str",  # Optional. Party Id.
                    "properties": {
                        "str": {}  # Optional. A collection of key value pairs that belongs
                          to the resource."nEach pair must not have a key greater than 50
                          characters"nand must not have a value greater than 150 characters."nNote: A
                          maximum of 25 key value pairs can be provided for a resource and only
                          string,"nnumeral and datetime (yyyy-MM-ddTHH:mm:ssZ) values are supported.
                    },
                    "source": "str",  # Optional. Source of the resource.
                    "status": "str"  # Optional. Status of the resource.
                }
        """

    @overload
    def create_or_update(
        self,
        party_id: str,
        field_id: str,
        field: IO,
        *,
        content_type: str = "application/merge-patch+json",
        **kwargs: Any
    ) -> JSON:
        """Creates or Updates a field resource under a particular party.

        :param party_id: Id of the associated party resource. Required.
        :type party_id: str
        :param field_id: Id of the field resource. Required.
        :type field_id: str
        :param field: Field resource payload to create or update. Required.
        :type field: IO
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Default value is "application/merge-patch+json".
        :paramtype content_type: str
        :return: JSON object
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200, 201
                response == {
                    "createdBy": "str",  # Optional. Created by user/tenant id.
                    "createdDateTime": "2020-02-20 00:00:00",  # Optional. Date-time when
                      resource was created, sample format: yyyy-MM-ddTHH:mm:ssZ.
                    "description": "str",  # Optional. Textual description of the resource.
                    "eTag": "str",  # Optional. The ETag value to implement optimistic
                      concurrency.
                    "farmId": "str",  # Optional. Id of the associated Farm.
                    "id": "str",  # Optional. Unique resource ID.
                    "modifiedBy": "str",  # Optional. Modified by user/tenant id.
                    "modifiedDateTime": "2020-02-20 00:00:00",  # Optional. Date-time when
                      resource was last modified, sample format: yyyy-MM-ddTHH:mm:ssZ.
                    "name": "str",  # Optional. Name to identify resource.
                    "partyId": "str",  # Optional. Party Id.
                    "properties": {
                        "str": {}  # Optional. A collection of key value pairs that belongs
                          to the resource."nEach pair must not have a key greater than 50
                          characters"nand must not have a value greater than 150 characters."nNote: A
                          maximum of 25 key value pairs can be provided for a resource and only
                          string,"nnumeral and datetime (yyyy-MM-ddTHH:mm:ssZ) values are supported.
                    },
                    "source": "str",  # Optional. Source of the resource.
                    "status": "str"  # Optional. Status of the resource.
                }
        """

    @distributed_trace
    def create_or_update(self, party_id: str, field_id: str, field: Union[JSON, IO], **kwargs: Any) -> JSON:
        """Creates or Updates a field resource under a particular party.

        :param party_id: Id of the associated party resource. Required.
        :type party_id: str
        :param field_id: Id of the field resource. Required.
        :type field_id: str
        :param field: Field resource payload to create or update. Is either a model type or a IO type.
         Required.
        :type field: JSON or IO
        :keyword content_type: Body Parameter content-type. Known values are:
         'application/merge-patch+json'. Default value is None.
        :paramtype content_type: str
        :return: JSON object
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200, 201
                response == {
                    "createdBy": "str",  # Optional. Created by user/tenant id.
                    "createdDateTime": "2020-02-20 00:00:00",  # Optional. Date-time when
                      resource was created, sample format: yyyy-MM-ddTHH:mm:ssZ.
                    "description": "str",  # Optional. Textual description of the resource.
                    "eTag": "str",  # Optional. The ETag value to implement optimistic
                      concurrency.
                    "farmId": "str",  # Optional. Id of the associated Farm.
                    "id": "str",  # Optional. Unique resource ID.
                    "modifiedBy": "str",  # Optional. Modified by user/tenant id.
                    "modifiedDateTime": "2020-02-20 00:00:00",  # Optional. Date-time when
                      resource was last modified, sample format: yyyy-MM-ddTHH:mm:ssZ.
                    "name": "str",  # Optional. Name to identify resource.
                    "partyId": "str",  # Optional. Party Id.
                    "properties": {
                        "str": {}  # Optional. A collection of key value pairs that belongs
                          to the resource."nEach pair must not have a key greater than 50
                          characters"nand must not have a value greater than 150 characters."nNote: A
                          maximum of 25 key value pairs can be provided for a resource and only
                          string,"nnumeral and datetime (yyyy-MM-ddTHH:mm:ssZ) values are supported.
                    },
                    "source": "str",  # Optional. Source of the resource.
                    "status": "str"  # Optional. Status of the resource.
                }
        """
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type = kwargs.pop("content_type", _headers.pop("Content-Type", None))  # type: Optional[str]
        cls = kwargs.pop("cls", None)  # type: ClsType[JSON]

        content_type = content_type or "application/merge-patch+json"
        _json = None
        _content = None
        if isinstance(field, (IO, bytes)):
            _content = field
        else:
            _json = field

        request = build_fields_create_or_update_request(
            party_id=party_id,
            field_id=field_id,
            content_type=content_type,
            api_version=self._config.api_version,
            json=_json,
            content=_content,
            headers=_headers,
            params=_params,
        )
        request.url = self._client.format_url(request.url)  # type: ignore

        pipeline_response = self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
            request, stream=False, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200, 201]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if response.status_code == 200:
            if response.content:
                deserialized = response.json()
            else:
                deserialized = None

        if response.status_code == 201:
            if response.content:
                deserialized = response.json()
            else:
                deserialized = None

        if cls:
            return cls(pipeline_response, cast(JSON, deserialized), {})

        return cast(JSON, deserialized)

    @distributed_trace
    def delete(  # pylint: disable=inconsistent-return-statements
        self, party_id: str, field_id: str, **kwargs: Any
    ) -> None:
        """Deletes a specified field resource under a particular party.

        :param party_id: Id of the party. Required.
        :type party_id: str
        :param field_id: Id of the field. Required.
        :type field_id: str
        :return: None
        :rtype: None
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls = kwargs.pop("cls", None)  # type: ClsType[None]

        request = build_fields_delete_request(
            party_id=party_id,
            field_id=field_id,
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        request.url = self._client.format_url(request.url)  # type: ignore

        pipeline_response = self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
            request, stream=False, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [204]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if cls:
            return cls(pipeline_response, None, {})


class HarvestDataOperations:
    """
    .. warning::
        **DO NOT** instantiate this class directly.

        Instead, you should access the following operations through
        :class:`~azure.agrifood.farming.FarmBeatsClient`'s
        :attr:`harvest_data` attribute.
    """

    def __init__(self, *args, **kwargs):
        input_args = list(args)
        self._client = input_args.pop(0) if input_args else kwargs.pop("client")
        self._config = input_args.pop(0) if input_args else kwargs.pop("config")
        self._serialize = input_args.pop(0) if input_args else kwargs.pop("serializer")
        self._deserialize = input_args.pop(0) if input_args else kwargs.pop("deserializer")

    @distributed_trace
    def list(
        self,
        *,
        min_total_yield: Optional[float] = None,
        max_total_yield: Optional[float] = None,
        min_avg_yield: Optional[float] = None,
        max_avg_yield: Optional[float] = None,
        min_total_wet_mass: Optional[float] = None,
        max_total_wet_mass: Optional[float] = None,
        min_avg_wet_mass: Optional[float] = None,
        max_avg_wet_mass: Optional[float] = None,
        min_avg_moisture: Optional[float] = None,
        max_avg_moisture: Optional[float] = None,
        min_avg_speed: Optional[float] = None,
        max_avg_speed: Optional[float] = None,
        sources: Optional[List[str]] = None,
        associated_boundary_ids: Optional[List[str]] = None,
        min_operation_start_date_time: Optional[datetime.datetime] = None,
        max_operation_start_date_time: Optional[datetime.datetime] = None,
        min_operation_end_date_time: Optional[datetime.datetime] = None,
        max_operation_end_date_time: Optional[datetime.datetime] = None,
        min_operation_modified_date_time: Optional[datetime.datetime] = None,
        max_operation_modified_date_time: Optional[datetime.datetime] = None,
        min_area: Optional[float] = None,
        max_area: Optional[float] = None,
        ids: Optional[List[str]] = None,
        names: Optional[List[str]] = None,
        property_filters: Optional[List[str]] = None,
        statuses: Optional[List[str]] = None,
        min_created_date_time: Optional[datetime.datetime] = None,
        max_created_date_time: Optional[datetime.datetime] = None,
        min_last_modified_date_time: Optional[datetime.datetime] = None,
        max_last_modified_date_time: Optional[datetime.datetime] = None,
        skip_token: Optional[str] = None,
        **kwargs: Any
    ) -> Iterable[JSON]:
        """Returns a paginated list of harvest data resources across all parties.

        :keyword min_total_yield: Minimum Yield value(inclusive). Default value is None.
        :paramtype min_total_yield: float
        :keyword max_total_yield: Maximum Yield value (inclusive). Default value is None.
        :paramtype max_total_yield: float
        :keyword min_avg_yield: Minimum AvgYield value(inclusive). Default value is None.
        :paramtype min_avg_yield: float
        :keyword max_avg_yield: Maximum AvgYield value (inclusive). Default value is None.
        :paramtype max_avg_yield: float
        :keyword min_total_wet_mass: Minimum Total WetMass value(inclusive). Default value is None.
        :paramtype min_total_wet_mass: float
        :keyword max_total_wet_mass: Maximum Total WetMass value (inclusive). Default value is None.
        :paramtype max_total_wet_mass: float
        :keyword min_avg_wet_mass: Minimum AvgWetMass value(inclusive). Default value is None.
        :paramtype min_avg_wet_mass: float
        :keyword max_avg_wet_mass: Maximum AvgWetMass value (inclusive). Default value is None.
        :paramtype max_avg_wet_mass: float
        :keyword min_avg_moisture: Minimum AvgMoisture value(inclusive). Default value is None.
        :paramtype min_avg_moisture: float
        :keyword max_avg_moisture: Maximum AvgMoisture value (inclusive). Default value is None.
        :paramtype max_avg_moisture: float
        :keyword min_avg_speed: Minimum AvgSpeed value(inclusive). Default value is None.
        :paramtype min_avg_speed: float
        :keyword max_avg_speed: Maximum AvgSpeed value (inclusive). Default value is None.
        :paramtype max_avg_speed: float
        :keyword sources: Sources of the operation data. Default value is None.
        :paramtype sources: list[str]
        :keyword associated_boundary_ids: Boundary IDs associated with operation data. Default value is
         None.
        :paramtype associated_boundary_ids: list[str]
        :keyword min_operation_start_date_time: Minimum start date-time of the operation data, sample
         format: yyyy-MM-ddTHH:mm:ssZ (inclusive). Default value is None.
        :paramtype min_operation_start_date_time: ~datetime.datetime
        :keyword max_operation_start_date_time: Maximum start date-time of the operation data, sample
         format: yyyy-MM-ddTHH:mm:ssZ (inclusive). Default value is None.
        :paramtype max_operation_start_date_time: ~datetime.datetime
        :keyword min_operation_end_date_time: Minimum end date-time of the operation data, sample
         format: yyyy-MM-ddTHH:mm:ssZ (inclusive). Default value is None.
        :paramtype min_operation_end_date_time: ~datetime.datetime
        :keyword max_operation_end_date_time: Maximum end date-time of the operation data, sample
         format: yyyy-MM-ddTHH:mm:ssZ (inclusive). Default value is None.
        :paramtype max_operation_end_date_time: ~datetime.datetime
        :keyword min_operation_modified_date_time: Minimum modified date-time of the operation data,
         sample format: yyyy-MM-ddTHH:mm:ssZ (inclusive). Default value is None.
        :paramtype min_operation_modified_date_time: ~datetime.datetime
        :keyword max_operation_modified_date_time: Maximum modified date-time of the operation data,
         sample format: yyyy-MM-ddTHH:mm:ssZ (inclusive). Default value is None.
        :paramtype max_operation_modified_date_time: ~datetime.datetime
        :keyword min_area: Minimum area for which operation was applied (inclusive). Default value is
         None.
        :paramtype min_area: float
        :keyword max_area: Maximum area for which operation was applied (inclusive). Default value is
         None.
        :paramtype max_area: float
        :keyword ids: Ids of the resource. Default value is None.
        :paramtype ids: list[str]
        :keyword names: Names of the resource. Default value is None.
        :paramtype names: list[str]
        :keyword property_filters: Filters on key-value pairs within the Properties object.
         eg. "{testKey} eq {testValue}". Default value is None.
        :paramtype property_filters: list[str]
        :keyword statuses: Statuses of the resource. Default value is None.
        :paramtype statuses: list[str]
        :keyword min_created_date_time: Minimum creation date of resource (inclusive). Default value is
         None.
        :paramtype min_created_date_time: ~datetime.datetime
        :keyword max_created_date_time: Maximum creation date of resource (inclusive). Default value is
         None.
        :paramtype max_created_date_time: ~datetime.datetime
        :keyword min_last_modified_date_time: Minimum last modified date of resource (inclusive).
         Default value is None.
        :paramtype min_last_modified_date_time: ~datetime.datetime
        :keyword max_last_modified_date_time: Maximum last modified date of resource (inclusive).
         Default value is None.
        :paramtype max_last_modified_date_time: ~datetime.datetime
        :keyword skip_token: Skip token for getting next set of results. Default value is None.
        :paramtype skip_token: str
        :return: An iterator like instance of JSON object
        :rtype: ~azure.core.paging.ItemPaged[JSON]
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "area": {
                        "unit": "str",  # Optional. Data unit.
                        "value": 0.0  # Optional. Data value.
                    },
                    "associatedBoundaryId": "str",  # Optional. Optional boundary ID of the field
                      for which operation was applied.
                    "attachmentsLink": "str",  # Optional. Link for attachments.
                    "avgMoisture": {
                        "unit": "str",  # Optional. Data unit.
                        "value": 0.0  # Optional. Data value.
                    },
                    "avgSpeed": {
                        "unit": "str",  # Optional. Data unit.
                        "value": 0.0  # Optional. Data value.
                    },
                    "avgWetMass": {
                        "unit": "str",  # Optional. Data unit.
                        "value": 0.0  # Optional. Data value.
                    },
                    "avgYield": {
                        "unit": "str",  # Optional. Data unit.
                        "value": 0.0  # Optional. Data value.
                    },
                    "createdBy": "str",  # Optional. Created by user/tenant id.
                    "createdDateTime": "2020-02-20 00:00:00",  # Optional. Date-time when
                      resource was created, sample format: yyyy-MM-ddTHH:mm:ssZ.
                    "description": "str",  # Optional. Textual description of the resource.
                    "eTag": "str",  # Optional. The ETag value to implement optimistic
                      concurrency.
                    "harvestProductDetails": [
                        {
                            "area": {
                                "unit": "str",  # Optional. Data unit.
                                "value": 0.0  # Optional. Data value.
                            },
                            "avgMoisture": {
                                "unit": "str",  # Optional. Data unit.
                                "value": 0.0  # Optional. Data value.
                            },
                            "avgWetMass": {
                                "unit": "str",  # Optional. Data unit.
                                "value": 0.0  # Optional. Data value.
                            },
                            "avgYield": {
                                "unit": "str",  # Optional. Data unit.
                                "value": 0.0  # Optional. Data value.
                            },
                            "productName": "str",  # Optional. Name of the product.
                            "totalWetMass": {
                                "unit": "str",  # Optional. Data unit.
                                "value": 0.0  # Optional. Data value.
                            },
                            "totalYield": {
                                "unit": "str",  # Optional. Data unit.
                                "value": 0.0  # Optional. Data value.
                            }
                        }
                    ],
                    "id": "str",  # Optional. Unique resource ID.
                    "modifiedBy": "str",  # Optional. Modified by user/tenant id.
                    "modifiedDateTime": "2020-02-20 00:00:00",  # Optional. Date-time when
                      resource was last modified, sample format: yyyy-MM-ddTHH:mm:ssZ.
                    "name": "str",  # Optional. Name to identify resource.
                    "operationEndDateTime": "2020-02-20 00:00:00",  # Optional. End date-time of
                      the operation data, sample format: yyyy-MM-ddTHH:mm:ssZ.
                    "operationModifiedDateTime": "2020-02-20 00:00:00",  # Optional. Modified
                      date-time of the operation data, sample format: yyyy-MM-ddTHH:mm:ssZ."nNote: this
                      will be specified by the source provider itself.
                    "operationStartDateTime": "2020-02-20 00:00:00",  # Optional. Start date-time
                      of the operation data, sample format: yyyy-MM-ddTHH:mm:ssZ.
                    "partyId": "str",  # Optional. Party ID which belongs to the operation data.
                    "properties": {
                        "str": {}  # Optional. A collection of key value pairs that belongs
                          to the resource."nEach pair must not have a key greater than 50
                          characters"nand must not have a value greater than 150 characters."nNote: A
                          maximum of 25 key value pairs can be provided for a resource and only
                          string,"nnumeral and datetime (yyyy-MM-ddTHH:mm:ssZ) values are supported.
                    },
                    "source": "str",  # Optional. Source of the resource.
                    "status": "str",  # Optional. Status of the resource.
                    "totalWetMass": {
                        "unit": "str",  # Optional. Data unit.
                        "value": 0.0  # Optional. Data value.
                    },
                    "totalYield": {
                        "unit": "str",  # Optional. Data unit.
                        "value": 0.0  # Optional. Data value.
                    }
                }
        """
        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls = kwargs.pop("cls", None)  # type: ClsType[JSON]

        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        def prepare_request(next_link=None):
            if not next_link:

                request = build_harvest_data_list_request(
                    min_total_yield=min_total_yield,
                    max_total_yield=max_total_yield,
                    min_avg_yield=min_avg_yield,
                    max_avg_yield=max_avg_yield,
                    min_total_wet_mass=min_total_wet_mass,
                    max_total_wet_mass=max_total_wet_mass,
                    min_avg_wet_mass=min_avg_wet_mass,
                    max_avg_wet_mass=max_avg_wet_mass,
                    min_avg_moisture=min_avg_moisture,
                    max_avg_moisture=max_avg_moisture,
                    min_avg_speed=min_avg_speed,
                    max_avg_speed=max_avg_speed,
                    sources=sources,
                    associated_boundary_ids=associated_boundary_ids,
                    min_operation_start_date_time=min_operation_start_date_time,
                    max_operation_start_date_time=max_operation_start_date_time,
                    min_operation_end_date_time=min_operation_end_date_time,
                    max_operation_end_date_time=max_operation_end_date_time,
                    min_operation_modified_date_time=min_operation_modified_date_time,
                    max_operation_modified_date_time=max_operation_modified_date_time,
                    min_area=min_area,
                    max_area=max_area,
                    ids=ids,
                    names=names,
                    property_filters=property_filters,
                    statuses=statuses,
                    min_created_date_time=min_created_date_time,
                    max_created_date_time=max_created_date_time,
                    min_last_modified_date_time=min_last_modified_date_time,
                    max_last_modified_date_time=max_last_modified_date_time,
                    skip_token=skip_token,
                    api_version=self._config.api_version,
                    headers=_headers,
                    params=_params,
                )
                request.url = self._client.format_url(request.url)  # type: ignore

            else:
                # make call to next link with the client's api-version
                _parsed_next_link = urlparse(next_link)
                _next_request_params = case_insensitive_dict(parse_qs(_parsed_next_link.query))
                _next_request_params["api-version"] = self._config.api_version
                request = HttpRequest("GET", urljoin(next_link, _parsed_next_link.path), params=_next_request_params)
                request.url = self._client.format_url(request.url)  # type: ignore

            return request

        def extract_data(pipeline_response):
            deserialized = pipeline_response.http_response.json()
            list_of_elem = deserialized["value"]
            if cls:
                list_of_elem = cls(list_of_elem)
            return deserialized.get("nextLink", None), iter(list_of_elem)

        def get_next(next_link=None):
            request = prepare_request(next_link)

            pipeline_response = self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
                request, stream=False, **kwargs
            )
            response = pipeline_response.http_response

            if response.status_code not in [200]:
                map_error(status_code=response.status_code, response=response, error_map=error_map)
                raise HttpResponseError(response=response)

            return pipeline_response

        return ItemPaged(get_next, extract_data)

    def _create_cascade_delete_job_initial(
        self, job_id: str, *, party_id: str, harvest_data_id: str, **kwargs: Any
    ) -> JSON:
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls = kwargs.pop("cls", None)  # type: ClsType[JSON]

        request = build_harvest_data_create_cascade_delete_job_request(
            job_id=job_id,
            party_id=party_id,
            harvest_data_id=harvest_data_id,
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        request.url = self._client.format_url(request.url)  # type: ignore

        pipeline_response = self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
            request, stream=False, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [202]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if response.content:
            deserialized = response.json()
        else:
            deserialized = None

        if cls:
            return cls(pipeline_response, cast(JSON, deserialized), {})

        return cast(JSON, deserialized)

    @distributed_trace
    def begin_create_cascade_delete_job(
        self, job_id: str, *, party_id: str, harvest_data_id: str, **kwargs: Any
    ) -> LROPoller[JSON]:
        """Create cascade delete job for harvest data resource.

        :param job_id: Job Id supplied by end user. Required.
        :type job_id: str
        :keyword party_id: Id of the party. Required.
        :paramtype party_id: str
        :keyword harvest_data_id: Id of the harvest data. Required.
        :paramtype harvest_data_id: str
        :keyword str continuation_token: A continuation token to restart a poller from a saved state.
        :keyword polling: By default, your polling method will be LROBasePolling. Pass in False for
         this operation to not poll, or pass in your own initialized polling object for a personal
         polling strategy.
        :paramtype polling: bool or ~azure.core.polling.PollingMethod
        :keyword int polling_interval: Default waiting time between two polls for LRO operations if no
         Retry-After header is present.
        :return: An instance of LROPoller that returns JSON object
        :rtype: ~azure.core.polling.LROPoller[JSON]
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 202
                response == {
                    "partyId": "str",  # Party Id. Required.
                    "resourceId": "str",  # The id of the resource. Required.
                    "resourceType": "str",  # The type of the resource. Required.
                    "createdDateTime": "2020-02-20 00:00:00",  # Optional. Job created at
                      dateTime. Sample format: yyyy-MM-ddTHH:mm:ssZ.
                    "durationInSeconds": 0.0,  # Optional. Duration of the job in seconds.
                    "endTime": "2020-02-20 00:00:00",  # Optional. Job end time when available.
                      Sample format: yyyy-MM-ddTHH:mm:ssZ.
                    "errorCode": "str",  # Optional. Error Code when job failed.
                    "id": "str",  # Optional. Unique job id.
                    "lastActionDateTime": "2020-02-20 00:00:00",  # Optional. Job was last acted
                      upon at dateTime. Sample format: yyyy-MM-ddTHH:mm:ssZ.
                    "message": "str",  # Optional. Status message to capture more details of the
                      job.
                    "startTime": "2020-02-20 00:00:00",  # Optional. Job start time when
                      available. Sample format: yyyy-MM-ddTHH:mm:ssZ.
                    "status": "str"  # Optional. Status of the job."nPossible values: 'Waiting',
                      'Running', 'Succeeded', 'Failed', 'Cancelled'. Known values are: "Waiting",
                      "Running", "Succeeded", "Failed", and "Cancelled".
                }
        """
        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls = kwargs.pop("cls", None)  # type: ClsType[JSON]
        polling = kwargs.pop("polling", True)  # type: Union[bool, PollingMethod]
        lro_delay = kwargs.pop("polling_interval", self._config.polling_interval)
        cont_token = kwargs.pop("continuation_token", None)  # type: Optional[str]
        if cont_token is None:
            raw_result = self._create_cascade_delete_job_initial(  # type: ignore
                job_id=job_id,
                party_id=party_id,
                harvest_data_id=harvest_data_id,
                cls=lambda x, y, z: x,
                headers=_headers,
                params=_params,
                **kwargs
            )
        kwargs.pop("error_map", None)

        def get_long_running_output(pipeline_response):
            response = pipeline_response.http_response
            if response.content:
                deserialized = response.json()
            else:
                deserialized = None
            if cls:
                return cls(pipeline_response, deserialized, {})
            return deserialized

        if polling is True:
            polling_method = cast(
                PollingMethod, LROBasePolling(lro_delay, lro_options={"final-state-via": "location"}, **kwargs)
            )  # type: PollingMethod
        elif polling is False:
            polling_method = cast(PollingMethod, NoPolling())
        else:
            polling_method = polling
        if cont_token:
            return LROPoller.from_continuation_token(
                polling_method=polling_method,
                continuation_token=cont_token,
                client=self._client,
                deserialization_callback=get_long_running_output,
            )
        return LROPoller(self._client, raw_result, get_long_running_output, polling_method)

    @distributed_trace
    def get_cascade_delete_job_details(self, job_id: str, **kwargs: Any) -> JSON:
        """Get cascade delete job for harvest data resource.

        :param job_id: Id of the job. Required.
        :type job_id: str
        :return: JSON object
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "partyId": "str",  # Party Id. Required.
                    "resourceId": "str",  # The id of the resource. Required.
                    "resourceType": "str",  # The type of the resource. Required.
                    "createdDateTime": "2020-02-20 00:00:00",  # Optional. Job created at
                      dateTime. Sample format: yyyy-MM-ddTHH:mm:ssZ.
                    "durationInSeconds": 0.0,  # Optional. Duration of the job in seconds.
                    "endTime": "2020-02-20 00:00:00",  # Optional. Job end time when available.
                      Sample format: yyyy-MM-ddTHH:mm:ssZ.
                    "errorCode": "str",  # Optional. Error Code when job failed.
                    "id": "str",  # Optional. Unique job id.
                    "lastActionDateTime": "2020-02-20 00:00:00",  # Optional. Job was last acted
                      upon at dateTime. Sample format: yyyy-MM-ddTHH:mm:ssZ.
                    "message": "str",  # Optional. Status message to capture more details of the
                      job.
                    "startTime": "2020-02-20 00:00:00",  # Optional. Job start time when
                      available. Sample format: yyyy-MM-ddTHH:mm:ssZ.
                    "status": "str"  # Optional. Status of the job."nPossible values: 'Waiting',
                      'Running', 'Succeeded', 'Failed', 'Cancelled'. Known values are: "Waiting",
                      "Running", "Succeeded", "Failed", and "Cancelled".
                }
        """
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls = kwargs.pop("cls", None)  # type: ClsType[JSON]

        request = build_harvest_data_get_cascade_delete_job_details_request(
            job_id=job_id,
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        request.url = self._client.format_url(request.url)  # type: ignore

        pipeline_response = self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
            request, stream=False, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if response.content:
            deserialized = response.json()
        else:
            deserialized = None

        if cls:
            return cls(pipeline_response, cast(JSON, deserialized), {})

        return cast(JSON, deserialized)

    @distributed_trace
    def list_by_party_id(
        self,
        party_id: str,
        *,
        min_total_yield: Optional[float] = None,
        max_total_yield: Optional[float] = None,
        min_avg_yield: Optional[float] = None,
        max_avg_yield: Optional[float] = None,
        min_total_wet_mass: Optional[float] = None,
        max_total_wet_mass: Optional[float] = None,
        min_avg_wet_mass: Optional[float] = None,
        max_avg_wet_mass: Optional[float] = None,
        min_avg_moisture: Optional[float] = None,
        max_avg_moisture: Optional[float] = None,
        min_avg_speed: Optional[float] = None,
        max_avg_speed: Optional[float] = None,
        sources: Optional[List[str]] = None,
        associated_boundary_ids: Optional[List[str]] = None,
        min_operation_start_date_time: Optional[datetime.datetime] = None,
        max_operation_start_date_time: Optional[datetime.datetime] = None,
        min_operation_end_date_time: Optional[datetime.datetime] = None,
        max_operation_end_date_time: Optional[datetime.datetime] = None,
        min_operation_modified_date_time: Optional[datetime.datetime] = None,
        max_operation_modified_date_time: Optional[datetime.datetime] = None,
        min_area: Optional[float] = None,
        max_area: Optional[float] = None,
        ids: Optional[List[str]] = None,
        names: Optional[List[str]] = None,
        property_filters: Optional[List[str]] = None,
        statuses: Optional[List[str]] = None,
        min_created_date_time: Optional[datetime.datetime] = None,
        max_created_date_time: Optional[datetime.datetime] = None,
        min_last_modified_date_time: Optional[datetime.datetime] = None,
        max_last_modified_date_time: Optional[datetime.datetime] = None,
        skip_token: Optional[str] = None,
        **kwargs: Any
    ) -> Iterable[JSON]:
        """Returns a paginated list of harvest data resources under a particular farm.

        :param party_id: ID of the associated party. Required.
        :type party_id: str
        :keyword min_total_yield: Minimum Yield value(inclusive). Default value is None.
        :paramtype min_total_yield: float
        :keyword max_total_yield: Maximum Yield value (inclusive). Default value is None.
        :paramtype max_total_yield: float
        :keyword min_avg_yield: Minimum AvgYield value(inclusive). Default value is None.
        :paramtype min_avg_yield: float
        :keyword max_avg_yield: Maximum AvgYield value (inclusive). Default value is None.
        :paramtype max_avg_yield: float
        :keyword min_total_wet_mass: Minimum Total WetMass value(inclusive). Default value is None.
        :paramtype min_total_wet_mass: float
        :keyword max_total_wet_mass: Maximum Total WetMass value (inclusive). Default value is None.
        :paramtype max_total_wet_mass: float
        :keyword min_avg_wet_mass: Minimum AvgWetMass value(inclusive). Default value is None.
        :paramtype min_avg_wet_mass: float
        :keyword max_avg_wet_mass: Maximum AvgWetMass value (inclusive). Default value is None.
        :paramtype max_avg_wet_mass: float
        :keyword min_avg_moisture: Minimum AvgMoisture value(inclusive). Default value is None.
        :paramtype min_avg_moisture: float
        :keyword max_avg_moisture: Maximum AvgMoisture value (inclusive). Default value is None.
        :paramtype max_avg_moisture: float
        :keyword min_avg_speed: Minimum AvgSpeed value(inclusive). Default value is None.
        :paramtype min_avg_speed: float
        :keyword max_avg_speed: Maximum AvgSpeed value (inclusive). Default value is None.
        :paramtype max_avg_speed: float
        :keyword sources: Sources of the operation data. Default value is None.
        :paramtype sources: list[str]
        :keyword associated_boundary_ids: Boundary IDs associated with operation data. Default value is
         None.
        :paramtype associated_boundary_ids: list[str]
        :keyword min_operation_start_date_time: Minimum start date-time of the operation data, sample
         format: yyyy-MM-ddTHH:mm:ssZ (inclusive). Default value is None.
        :paramtype min_operation_start_date_time: ~datetime.datetime
        :keyword max_operation_start_date_time: Maximum start date-time of the operation data, sample
         format: yyyy-MM-ddTHH:mm:ssZ (inclusive). Default value is None.
        :paramtype max_operation_start_date_time: ~datetime.datetime
        :keyword min_operation_end_date_time: Minimum end date-time of the operation data, sample
         format: yyyy-MM-ddTHH:mm:ssZ (inclusive). Default value is None.
        :paramtype min_operation_end_date_time: ~datetime.datetime
        :keyword max_operation_end_date_time: Maximum end date-time of the operation data, sample
         format: yyyy-MM-ddTHH:mm:ssZ (inclusive). Default value is None.
        :paramtype max_operation_end_date_time: ~datetime.datetime
        :keyword min_operation_modified_date_time: Minimum modified date-time of the operation data,
         sample format: yyyy-MM-ddTHH:mm:ssZ (inclusive). Default value is None.
        :paramtype min_operation_modified_date_time: ~datetime.datetime
        :keyword max_operation_modified_date_time: Maximum modified date-time of the operation data,
         sample format: yyyy-MM-ddTHH:mm:ssZ (inclusive). Default value is None.
        :paramtype max_operation_modified_date_time: ~datetime.datetime
        :keyword min_area: Minimum area for which operation was applied (inclusive). Default value is
         None.
        :paramtype min_area: float
        :keyword max_area: Maximum area for which operation was applied (inclusive). Default value is
         None.
        :paramtype max_area: float
        :keyword ids: Ids of the resource. Default value is None.
        :paramtype ids: list[str]
        :keyword names: Names of the resource. Default value is None.
        :paramtype names: list[str]
        :keyword property_filters: Filters on key-value pairs within the Properties object.
         eg. "{testKey} eq {testValue}". Default value is None.
        :paramtype property_filters: list[str]
        :keyword statuses: Statuses of the resource. Default value is None.
        :paramtype statuses: list[str]
        :keyword min_created_date_time: Minimum creation date of resource (inclusive). Default value is
         None.
        :paramtype min_created_date_time: ~datetime.datetime
        :keyword max_created_date_time: Maximum creation date of resource (inclusive). Default value is
         None.
        :paramtype max_created_date_time: ~datetime.datetime
        :keyword min_last_modified_date_time: Minimum last modified date of resource (inclusive).
         Default value is None.
        :paramtype min_last_modified_date_time: ~datetime.datetime
        :keyword max_last_modified_date_time: Maximum last modified date of resource (inclusive).
         Default value is None.
        :paramtype max_last_modified_date_time: ~datetime.datetime
        :keyword skip_token: Skip token for getting next set of results. Default value is None.
        :paramtype skip_token: str
        :return: An iterator like instance of JSON object
        :rtype: ~azure.core.paging.ItemPaged[JSON]
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "area": {
                        "unit": "str",  # Optional. Data unit.
                        "value": 0.0  # Optional. Data value.
                    },
                    "associatedBoundaryId": "str",  # Optional. Optional boundary ID of the field
                      for which operation was applied.
                    "attachmentsLink": "str",  # Optional. Link for attachments.
                    "avgMoisture": {
                        "unit": "str",  # Optional. Data unit.
                        "value": 0.0  # Optional. Data value.
                    },
                    "avgSpeed": {
                        "unit": "str",  # Optional. Data unit.
                        "value": 0.0  # Optional. Data value.
                    },
                    "avgWetMass": {
                        "unit": "str",  # Optional. Data unit.
                        "value": 0.0  # Optional. Data value.
                    },
                    "avgYield": {
                        "unit": "str",  # Optional. Data unit.
                        "value": 0.0  # Optional. Data value.
                    },
                    "createdBy": "str",  # Optional. Created by user/tenant id.
                    "createdDateTime": "2020-02-20 00:00:00",  # Optional. Date-time when
                      resource was created, sample format: yyyy-MM-ddTHH:mm:ssZ.
                    "description": "str",  # Optional. Textual description of the resource.
                    "eTag": "str",  # Optional. The ETag value to implement optimistic
                      concurrency.
                    "harvestProductDetails": [
                        {
                            "area": {
                                "unit": "str",  # Optional. Data unit.
                                "value": 0.0  # Optional. Data value.
                            },
                            "avgMoisture": {
                                "unit": "str",  # Optional. Data unit.
                                "value": 0.0  # Optional. Data value.
                            },
                            "avgWetMass": {
                                "unit": "str",  # Optional. Data unit.
                                "value": 0.0  # Optional. Data value.
                            },
                            "avgYield": {
                                "unit": "str",  # Optional. Data unit.
                                "value": 0.0  # Optional. Data value.
                            },
                            "productName": "str",  # Optional. Name of the product.
                            "totalWetMass": {
                                "unit": "str",  # Optional. Data unit.
                                "value": 0.0  # Optional. Data value.
                            },
                            "totalYield": {
                                "unit": "str",  # Optional. Data unit.
                                "value": 0.0  # Optional. Data value.
                            }
                        }
                    ],
                    "id": "str",  # Optional. Unique resource ID.
                    "modifiedBy": "str",  # Optional. Modified by user/tenant id.
                    "modifiedDateTime": "2020-02-20 00:00:00",  # Optional. Date-time when
                      resource was last modified, sample format: yyyy-MM-ddTHH:mm:ssZ.
                    "name": "str",  # Optional. Name to identify resource.
                    "operationEndDateTime": "2020-02-20 00:00:00",  # Optional. End date-time of
                      the operation data, sample format: yyyy-MM-ddTHH:mm:ssZ.
                    "operationModifiedDateTime": "2020-02-20 00:00:00",  # Optional. Modified
                      date-time of the operation data, sample format: yyyy-MM-ddTHH:mm:ssZ."nNote: this
                      will be specified by the source provider itself.
                    "operationStartDateTime": "2020-02-20 00:00:00",  # Optional. Start date-time
                      of the operation data, sample format: yyyy-MM-ddTHH:mm:ssZ.
                    "partyId": "str",  # Optional. Party ID which belongs to the operation data.
                    "properties": {
                        "str": {}  # Optional. A collection of key value pairs that belongs
                          to the resource."nEach pair must not have a key greater than 50
                          characters"nand must not have a value greater than 150 characters."nNote: A
                          maximum of 25 key value pairs can be provided for a resource and only
                          string,"nnumeral and datetime (yyyy-MM-ddTHH:mm:ssZ) values are supported.
                    },
                    "source": "str",  # Optional. Source of the resource.
                    "status": "str",  # Optional. Status of the resource.
                    "totalWetMass": {
                        "unit": "str",  # Optional. Data unit.
                        "value": 0.0  # Optional. Data value.
                    },
                    "totalYield": {
                        "unit": "str",  # Optional. Data unit.
                        "value": 0.0  # Optional. Data value.
                    }
                }
        """
        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls = kwargs.pop("cls", None)  # type: ClsType[JSON]

        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        def prepare_request(next_link=None):
            if not next_link:

                request = build_harvest_data_list_by_party_id_request(
                    party_id=party_id,
                    min_total_yield=min_total_yield,
                    max_total_yield=max_total_yield,
                    min_avg_yield=min_avg_yield,
                    max_avg_yield=max_avg_yield,
                    min_total_wet_mass=min_total_wet_mass,
                    max_total_wet_mass=max_total_wet_mass,
                    min_avg_wet_mass=min_avg_wet_mass,
                    max_avg_wet_mass=max_avg_wet_mass,
                    min_avg_moisture=min_avg_moisture,
                    max_avg_moisture=max_avg_moisture,
                    min_avg_speed=min_avg_speed,
                    max_avg_speed=max_avg_speed,
                    sources=sources,
                    associated_boundary_ids=associated_boundary_ids,
                    min_operation_start_date_time=min_operation_start_date_time,
                    max_operation_start_date_time=max_operation_start_date_time,
                    min_operation_end_date_time=min_operation_end_date_time,
                    max_operation_end_date_time=max_operation_end_date_time,
                    min_operation_modified_date_time=min_operation_modified_date_time,
                    max_operation_modified_date_time=max_operation_modified_date_time,
                    min_area=min_area,
                    max_area=max_area,
                    ids=ids,
                    names=names,
                    property_filters=property_filters,
                    statuses=statuses,
                    min_created_date_time=min_created_date_time,
                    max_created_date_time=max_created_date_time,
                    min_last_modified_date_time=min_last_modified_date_time,
                    max_last_modified_date_time=max_last_modified_date_time,
                    skip_token=skip_token,
                    api_version=self._config.api_version,
                    headers=_headers,
                    params=_params,
                )
                request.url = self._client.format_url(request.url)  # type: ignore

            else:
                # make call to next link with the client's api-version
                _parsed_next_link = urlparse(next_link)
                _next_request_params = case_insensitive_dict(parse_qs(_parsed_next_link.query))
                _next_request_params["api-version"] = self._config.api_version
                request = HttpRequest("GET", urljoin(next_link, _parsed_next_link.path), params=_next_request_params)
                request.url = self._client.format_url(request.url)  # type: ignore

            return request

        def extract_data(pipeline_response):
            deserialized = pipeline_response.http_response.json()
            list_of_elem = deserialized["value"]
            if cls:
                list_of_elem = cls(list_of_elem)
            return deserialized.get("nextLink", None), iter(list_of_elem)

        def get_next(next_link=None):
            request = prepare_request(next_link)

            pipeline_response = self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
                request, stream=False, **kwargs
            )
            response = pipeline_response.http_response

            if response.status_code not in [200]:
                map_error(status_code=response.status_code, response=response, error_map=error_map)
                raise HttpResponseError(response=response)

            return pipeline_response

        return ItemPaged(get_next, extract_data)

    @distributed_trace
    def get(self, party_id: str, harvest_data_id: str, **kwargs: Any) -> JSON:
        """Get a specified harvest data resource under a particular party.

        :param party_id: ID of the associated party resource. Required.
        :type party_id: str
        :param harvest_data_id: ID of the harvest data resource. Required.
        :type harvest_data_id: str
        :return: JSON object
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "area": {
                        "unit": "str",  # Optional. Data unit.
                        "value": 0.0  # Optional. Data value.
                    },
                    "associatedBoundaryId": "str",  # Optional. Optional boundary ID of the field
                      for which operation was applied.
                    "attachmentsLink": "str",  # Optional. Link for attachments.
                    "avgMoisture": {
                        "unit": "str",  # Optional. Data unit.
                        "value": 0.0  # Optional. Data value.
                    },
                    "avgSpeed": {
                        "unit": "str",  # Optional. Data unit.
                        "value": 0.0  # Optional. Data value.
                    },
                    "avgWetMass": {
                        "unit": "str",  # Optional. Data unit.
                        "value": 0.0  # Optional. Data value.
                    },
                    "avgYield": {
                        "unit": "str",  # Optional. Data unit.
                        "value": 0.0  # Optional. Data value.
                    },
                    "createdBy": "str",  # Optional. Created by user/tenant id.
                    "createdDateTime": "2020-02-20 00:00:00",  # Optional. Date-time when
                      resource was created, sample format: yyyy-MM-ddTHH:mm:ssZ.
                    "description": "str",  # Optional. Textual description of the resource.
                    "eTag": "str",  # Optional. The ETag value to implement optimistic
                      concurrency.
                    "harvestProductDetails": [
                        {
                            "area": {
                                "unit": "str",  # Optional. Data unit.
                                "value": 0.0  # Optional. Data value.
                            },
                            "avgMoisture": {
                                "unit": "str",  # Optional. Data unit.
                                "value": 0.0  # Optional. Data value.
                            },
                            "avgWetMass": {
                                "unit": "str",  # Optional. Data unit.
                                "value": 0.0  # Optional. Data value.
                            },
                            "avgYield": {
                                "unit": "str",  # Optional. Data unit.
                                "value": 0.0  # Optional. Data value.
                            },
                            "productName": "str",  # Optional. Name of the product.
                            "totalWetMass": {
                                "unit": "str",  # Optional. Data unit.
                                "value": 0.0  # Optional. Data value.
                            },
                            "totalYield": {
                                "unit": "str",  # Optional. Data unit.
                                "value": 0.0  # Optional. Data value.
                            }
                        }
                    ],
                    "id": "str",  # Optional. Unique resource ID.
                    "modifiedBy": "str",  # Optional. Modified by user/tenant id.
                    "modifiedDateTime": "2020-02-20 00:00:00",  # Optional. Date-time when
                      resource was last modified, sample format: yyyy-MM-ddTHH:mm:ssZ.
                    "name": "str",  # Optional. Name to identify resource.
                    "operationEndDateTime": "2020-02-20 00:00:00",  # Optional. End date-time of
                      the operation data, sample format: yyyy-MM-ddTHH:mm:ssZ.
                    "operationModifiedDateTime": "2020-02-20 00:00:00",  # Optional. Modified
                      date-time of the operation data, sample format: yyyy-MM-ddTHH:mm:ssZ."nNote: this
                      will be specified by the source provider itself.
                    "operationStartDateTime": "2020-02-20 00:00:00",  # Optional. Start date-time
                      of the operation data, sample format: yyyy-MM-ddTHH:mm:ssZ.
                    "partyId": "str",  # Optional. Party ID which belongs to the operation data.
                    "properties": {
                        "str": {}  # Optional. A collection of key value pairs that belongs
                          to the resource."nEach pair must not have a key greater than 50
                          characters"nand must not have a value greater than 150 characters."nNote: A
                          maximum of 25 key value pairs can be provided for a resource and only
                          string,"nnumeral and datetime (yyyy-MM-ddTHH:mm:ssZ) values are supported.
                    },
                    "source": "str",  # Optional. Source of the resource.
                    "status": "str",  # Optional. Status of the resource.
                    "totalWetMass": {
                        "unit": "str",  # Optional. Data unit.
                        "value": 0.0  # Optional. Data value.
                    },
                    "totalYield": {
                        "unit": "str",  # Optional. Data unit.
                        "value": 0.0  # Optional. Data value.
                    }
                }
        """
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls = kwargs.pop("cls", None)  # type: ClsType[JSON]

        request = build_harvest_data_get_request(
            party_id=party_id,
            harvest_data_id=harvest_data_id,
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        request.url = self._client.format_url(request.url)  # type: ignore

        pipeline_response = self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
            request, stream=False, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if response.content:
            deserialized = response.json()
        else:
            deserialized = None

        if cls:
            return cls(pipeline_response, cast(JSON, deserialized), {})

        return cast(JSON, deserialized)

    @overload
    def create_or_update(
        self,
        party_id: str,
        harvest_data_id: str,
        harvest_data: JSON,
        *,
        content_type: str = "application/merge-patch+json",
        **kwargs: Any
    ) -> JSON:
        """Creates or updates harvest data resource under a particular party.

        :param party_id: ID of the party. Required.
        :type party_id: str
        :param harvest_data_id: ID of the harvest data resource. Required.
        :type harvest_data_id: str
        :param harvest_data: Harvest data resource payload to create or update. Required.
        :type harvest_data: JSON
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/merge-patch+json".
        :paramtype content_type: str
        :return: JSON object
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                harvest_data = {
                    "area": {
                        "unit": "str",  # Optional. Data unit.
                        "value": 0.0  # Optional. Data value.
                    },
                    "associatedBoundaryId": "str",  # Optional. Optional boundary ID of the field
                      for which operation was applied.
                    "attachmentsLink": "str",  # Optional. Link for attachments.
                    "avgMoisture": {
                        "unit": "str",  # Optional. Data unit.
                        "value": 0.0  # Optional. Data value.
                    },
                    "avgSpeed": {
                        "unit": "str",  # Optional. Data unit.
                        "value": 0.0  # Optional. Data value.
                    },
                    "avgWetMass": {
                        "unit": "str",  # Optional. Data unit.
                        "value": 0.0  # Optional. Data value.
                    },
                    "avgYield": {
                        "unit": "str",  # Optional. Data unit.
                        "value": 0.0  # Optional. Data value.
                    },
                    "createdBy": "str",  # Optional. Created by user/tenant id.
                    "createdDateTime": "2020-02-20 00:00:00",  # Optional. Date-time when
                      resource was created, sample format: yyyy-MM-ddTHH:mm:ssZ.
                    "description": "str",  # Optional. Textual description of the resource.
                    "eTag": "str",  # Optional. The ETag value to implement optimistic
                      concurrency.
                    "harvestProductDetails": [
                        {
                            "area": {
                                "unit": "str",  # Optional. Data unit.
                                "value": 0.0  # Optional. Data value.
                            },
                            "avgMoisture": {
                                "unit": "str",  # Optional. Data unit.
                                "value": 0.0  # Optional. Data value.
                            },
                            "avgWetMass": {
                                "unit": "str",  # Optional. Data unit.
                                "value": 0.0  # Optional. Data value.
                            },
                            "avgYield": {
                                "unit": "str",  # Optional. Data unit.
                                "value": 0.0  # Optional. Data value.
                            },
                            "productName": "str",  # Optional. Name of the product.
                            "totalWetMass": {
                                "unit": "str",  # Optional. Data unit.
                                "value": 0.0  # Optional. Data value.
                            },
                            "totalYield": {
                                "unit": "str",  # Optional. Data unit.
                                "value": 0.0  # Optional. Data value.
                            }
                        }
                    ],
                    "id": "str",  # Optional. Unique resource ID.
                    "modifiedBy": "str",  # Optional. Modified by user/tenant id.
                    "modifiedDateTime": "2020-02-20 00:00:00",  # Optional. Date-time when
                      resource was last modified, sample format: yyyy-MM-ddTHH:mm:ssZ.
                    "name": "str",  # Optional. Name to identify resource.
                    "operationEndDateTime": "2020-02-20 00:00:00",  # Optional. End date-time of
                      the operation data, sample format: yyyy-MM-ddTHH:mm:ssZ.
                    "operationModifiedDateTime": "2020-02-20 00:00:00",  # Optional. Modified
                      date-time of the operation data, sample format: yyyy-MM-ddTHH:mm:ssZ."nNote: this
                      will be specified by the source provider itself.
                    "operationStartDateTime": "2020-02-20 00:00:00",  # Optional. Start date-time
                      of the operation data, sample format: yyyy-MM-ddTHH:mm:ssZ.
                    "partyId": "str",  # Optional. Party ID which belongs to the operation data.
                    "properties": {
                        "str": {}  # Optional. A collection of key value pairs that belongs
                          to the resource."nEach pair must not have a key greater than 50
                          characters"nand must not have a value greater than 150 characters."nNote: A
                          maximum of 25 key value pairs can be provided for a resource and only
                          string,"nnumeral and datetime (yyyy-MM-ddTHH:mm:ssZ) values are supported.
                    },
                    "source": "str",  # Optional. Source of the resource.
                    "status": "str",  # Optional. Status of the resource.
                    "totalWetMass": {
                        "unit": "str",  # Optional. Data unit.
                        "value": 0.0  # Optional. Data value.
                    },
                    "totalYield": {
                        "unit": "str",  # Optional. Data unit.
                        "value": 0.0  # Optional. Data value.
                    }
                }

                # response body for status code(s): 200, 201
                response == {
                    "area": {
                        "unit": "str",  # Optional. Data unit.
                        "value": 0.0  # Optional. Data value.
                    },
                    "associatedBoundaryId": "str",  # Optional. Optional boundary ID of the field
                      for which operation was applied.
                    "attachmentsLink": "str",  # Optional. Link for attachments.
                    "avgMoisture": {
                        "unit": "str",  # Optional. Data unit.
                        "value": 0.0  # Optional. Data value.
                    },
                    "avgSpeed": {
                        "unit": "str",  # Optional. Data unit.
                        "value": 0.0  # Optional. Data value.
                    },
                    "avgWetMass": {
                        "unit": "str",  # Optional. Data unit.
                        "value": 0.0  # Optional. Data value.
                    },
                    "avgYield": {
                        "unit": "str",  # Optional. Data unit.
                        "value": 0.0  # Optional. Data value.
                    },
                    "createdBy": "str",  # Optional. Created by user/tenant id.
                    "createdDateTime": "2020-02-20 00:00:00",  # Optional. Date-time when
                      resource was created, sample format: yyyy-MM-ddTHH:mm:ssZ.
                    "description": "str",  # Optional. Textual description of the resource.
                    "eTag": "str",  # Optional. The ETag value to implement optimistic
                      concurrency.
                    "harvestProductDetails": [
                        {
                            "area": {
                                "unit": "str",  # Optional. Data unit.
                                "value": 0.0  # Optional. Data value.
                            },
                            "avgMoisture": {
                                "unit": "str",  # Optional. Data unit.
                                "value": 0.0  # Optional. Data value.
                            },
                            "avgWetMass": {
                                "unit": "str",  # Optional. Data unit.
                                "value": 0.0  # Optional. Data value.
                            },
                            "avgYield": {
                                "unit": "str",  # Optional. Data unit.
                                "value": 0.0  # Optional. Data value.
                            },
                            "productName": "str",  # Optional. Name of the product.
                            "totalWetMass": {
                                "unit": "str",  # Optional. Data unit.
                                "value": 0.0  # Optional. Data value.
                            },
                            "totalYield": {
                                "unit": "str",  # Optional. Data unit.
                                "value": 0.0  # Optional. Data value.
                            }
                        }
                    ],
                    "id": "str",  # Optional. Unique resource ID.
                    "modifiedBy": "str",  # Optional. Modified by user/tenant id.
                    "modifiedDateTime": "2020-02-20 00:00:00",  # Optional. Date-time when
                      resource was last modified, sample format: yyyy-MM-ddTHH:mm:ssZ.
                    "name": "str",  # Optional. Name to identify resource.
                    "operationEndDateTime": "2020-02-20 00:00:00",  # Optional. End date-time of
                      the operation data, sample format: yyyy-MM-ddTHH:mm:ssZ.
                    "operationModifiedDateTime": "2020-02-20 00:00:00",  # Optional. Modified
                      date-time of the operation data, sample format: yyyy-MM-ddTHH:mm:ssZ."nNote: this
                      will be specified by the source provider itself.
                    "operationStartDateTime": "2020-02-20 00:00:00",  # Optional. Start date-time
                      of the operation data, sample format: yyyy-MM-ddTHH:mm:ssZ.
                    "partyId": "str",  # Optional. Party ID which belongs to the operation data.
                    "properties": {
                        "str": {}  # Optional. A collection of key value pairs that belongs
                          to the resource."nEach pair must not have a key greater than 50
                          characters"nand must not have a value greater than 150 characters."nNote: A
                          maximum of 25 key value pairs can be provided for a resource and only
                          string,"nnumeral and datetime (yyyy-MM-ddTHH:mm:ssZ) values are supported.
                    },
                    "source": "str",  # Optional. Source of the resource.
                    "status": "str",  # Optional. Status of the resource.
                    "totalWetMass": {
                        "unit": "str",  # Optional. Data unit.
                        "value": 0.0  # Optional. Data value.
                    },
                    "totalYield": {
                        "unit": "str",  # Optional. Data unit.
                        "value": 0.0  # Optional. Data value.
                    }
                }
        """

    @overload
    def create_or_update(
        self,
        party_id: str,
        harvest_data_id: str,
        harvest_data: IO,
        *,
        content_type: str = "application/merge-patch+json",
        **kwargs: Any
    ) -> JSON:
        """Creates or updates harvest data resource under a particular party.

        :param party_id: ID of the party. Required.
        :type party_id: str
        :param harvest_data_id: ID of the harvest data resource. Required.
        :type harvest_data_id: str
        :param harvest_data: Harvest data resource payload to create or update. Required.
        :type harvest_data: IO
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Default value is "application/merge-patch+json".
        :paramtype content_type: str
        :return: JSON object
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200, 201
                response == {
                    "area": {
                        "unit": "str",  # Optional. Data unit.
                        "value": 0.0  # Optional. Data value.
                    },
                    "associatedBoundaryId": "str",  # Optional. Optional boundary ID of the field
                      for which operation was applied.
                    "attachmentsLink": "str",  # Optional. Link for attachments.
                    "avgMoisture": {
                        "unit": "str",  # Optional. Data unit.
                        "value": 0.0  # Optional. Data value.
                    },
                    "avgSpeed": {
                        "unit": "str",  # Optional. Data unit.
                        "value": 0.0  # Optional. Data value.
                    },
                    "avgWetMass": {
                        "unit": "str",  # Optional. Data unit.
                        "value": 0.0  # Optional. Data value.
                    },
                    "avgYield": {
                        "unit": "str",  # Optional. Data unit.
                        "value": 0.0  # Optional. Data value.
                    },
                    "createdBy": "str",  # Optional. Created by user/tenant id.
                    "createdDateTime": "2020-02-20 00:00:00",  # Optional. Date-time when
                      resource was created, sample format: yyyy-MM-ddTHH:mm:ssZ.
                    "description": "str",  # Optional. Textual description of the resource.
                    "eTag": "str",  # Optional. The ETag value to implement optimistic
                      concurrency.
                    "harvestProductDetails": [
                        {
                            "area": {
                                "unit": "str",  # Optional. Data unit.
                                "value": 0.0  # Optional. Data value.
                            },
                            "avgMoisture": {
                                "unit": "str",  # Optional. Data unit.
                                "value": 0.0  # Optional. Data value.
                            },
                            "avgWetMass": {
                                "unit": "str",  # Optional. Data unit.
                                "value": 0.0  # Optional. Data value.
                            },
                            "avgYield": {
                                "unit": "str",  # Optional. Data unit.
                                "value": 0.0  # Optional. Data value.
                            },
                            "productName": "str",  # Optional. Name of the product.
                            "totalWetMass": {
                                "unit": "str",  # Optional. Data unit.
                                "value": 0.0  # Optional. Data value.
                            },
                            "totalYield": {
                                "unit": "str",  # Optional. Data unit.
                                "value": 0.0  # Optional. Data value.
                            }
                        }
                    ],
                    "id": "str",  # Optional. Unique resource ID.
                    "modifiedBy": "str",  # Optional. Modified by user/tenant id.
                    "modifiedDateTime": "2020-02-20 00:00:00",  # Optional. Date-time when
                      resource was last modified, sample format: yyyy-MM-ddTHH:mm:ssZ.
                    "name": "str",  # Optional. Name to identify resource.
                    "operationEndDateTime": "2020-02-20 00:00:00",  # Optional. End date-time of
                      the operation data, sample format: yyyy-MM-ddTHH:mm:ssZ.
                    "operationModifiedDateTime": "2020-02-20 00:00:00",  # Optional. Modified
                      date-time of the operation data, sample format: yyyy-MM-ddTHH:mm:ssZ."nNote: this
                      will be specified by the source provider itself.
                    "operationStartDateTime": "2020-02-20 00:00:00",  # Optional. Start date-time
                      of the operation data, sample format: yyyy-MM-ddTHH:mm:ssZ.
                    "partyId": "str",  # Optional. Party ID which belongs to the operation data.
                    "properties": {
                        "str": {}  # Optional. A collection of key value pairs that belongs
                          to the resource."nEach pair must not have a key greater than 50
                          characters"nand must not have a value greater than 150 characters."nNote: A
                          maximum of 25 key value pairs can be provided for a resource and only
                          string,"nnumeral and datetime (yyyy-MM-ddTHH:mm:ssZ) values are supported.
                    },
                    "source": "str",  # Optional. Source of the resource.
                    "status": "str",  # Optional. Status of the resource.
                    "totalWetMass": {
                        "unit": "str",  # Optional. Data unit.
                        "value": 0.0  # Optional. Data value.
                    },
                    "totalYield": {
                        "unit": "str",  # Optional. Data unit.
                        "value": 0.0  # Optional. Data value.
                    }
                }
        """

    @distributed_trace
    def create_or_update(
        self, party_id: str, harvest_data_id: str, harvest_data: Union[JSON, IO], **kwargs: Any
    ) -> JSON:
        """Creates or updates harvest data resource under a particular party.

        :param party_id: ID of the party. Required.
        :type party_id: str
        :param harvest_data_id: ID of the harvest data resource. Required.
        :type harvest_data_id: str
        :param harvest_data: Harvest data resource payload to create or update. Is either a model type
         or a IO type. Required.
        :type harvest_data: JSON or IO
        :keyword content_type: Body Parameter content-type. Known values are:
         'application/merge-patch+json'. Default value is None.
        :paramtype content_type: str
        :return: JSON object
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200, 201
                response == {
                    "area": {
                        "unit": "str",  # Optional. Data unit.
                        "value": 0.0  # Optional. Data value.
                    },
                    "associatedBoundaryId": "str",  # Optional. Optional boundary ID of the field
                      for which operation was applied.
                    "attachmentsLink": "str",  # Optional. Link for attachments.
                    "avgMoisture": {
                        "unit": "str",  # Optional. Data unit.
                        "value": 0.0  # Optional. Data value.
                    },
                    "avgSpeed": {
                        "unit": "str",  # Optional. Data unit.
                        "value": 0.0  # Optional. Data value.
                    },
                    "avgWetMass": {
                        "unit": "str",  # Optional. Data unit.
                        "value": 0.0  # Optional. Data value.
                    },
                    "avgYield": {
                        "unit": "str",  # Optional. Data unit.
                        "value": 0.0  # Optional. Data value.
                    },
                    "createdBy": "str",  # Optional. Created by user/tenant id.
                    "createdDateTime": "2020-02-20 00:00:00",  # Optional. Date-time when
                      resource was created, sample format: yyyy-MM-ddTHH:mm:ssZ.
                    "description": "str",  # Optional. Textual description of the resource.
                    "eTag": "str",  # Optional. The ETag value to implement optimistic
                      concurrency.
                    "harvestProductDetails": [
                        {
                            "area": {
                                "unit": "str",  # Optional. Data unit.
                                "value": 0.0  # Optional. Data value.
                            },
                            "avgMoisture": {
                                "unit": "str",  # Optional. Data unit.
                                "value": 0.0  # Optional. Data value.
                            },
                            "avgWetMass": {
                                "unit": "str",  # Optional. Data unit.
                                "value": 0.0  # Optional. Data value.
                            },
                            "avgYield": {
                                "unit": "str",  # Optional. Data unit.
                                "value": 0.0  # Optional. Data value.
                            },
                            "productName": "str",  # Optional. Name of the product.
                            "totalWetMass": {
                                "unit": "str",  # Optional. Data unit.
                                "value": 0.0  # Optional. Data value.
                            },
                            "totalYield": {
                                "unit": "str",  # Optional. Data unit.
                                "value": 0.0  # Optional. Data value.
                            }
                        }
                    ],
                    "id": "str",  # Optional. Unique resource ID.
                    "modifiedBy": "str",  # Optional. Modified by user/tenant id.
                    "modifiedDateTime": "2020-02-20 00:00:00",  # Optional. Date-time when
                      resource was last modified, sample format: yyyy-MM-ddTHH:mm:ssZ.
                    "name": "str",  # Optional. Name to identify resource.
                    "operationEndDateTime": "2020-02-20 00:00:00",  # Optional. End date-time of
                      the operation data, sample format: yyyy-MM-ddTHH:mm:ssZ.
                    "operationModifiedDateTime": "2020-02-20 00:00:00",  # Optional. Modified
                      date-time of the operation data, sample format: yyyy-MM-ddTHH:mm:ssZ."nNote: this
                      will be specified by the source provider itself.
                    "operationStartDateTime": "2020-02-20 00:00:00",  # Optional. Start date-time
                      of the operation data, sample format: yyyy-MM-ddTHH:mm:ssZ.
                    "partyId": "str",  # Optional. Party ID which belongs to the operation data.
                    "properties": {
                        "str": {}  # Optional. A collection of key value pairs that belongs
                          to the resource."nEach pair must not have a key greater than 50
                          characters"nand must not have a value greater than 150 characters."nNote: A
                          maximum of 25 key value pairs can be provided for a resource and only
                          string,"nnumeral and datetime (yyyy-MM-ddTHH:mm:ssZ) values are supported.
                    },
                    "source": "str",  # Optional. Source of the resource.
                    "status": "str",  # Optional. Status of the resource.
                    "totalWetMass": {
                        "unit": "str",  # Optional. Data unit.
                        "value": 0.0  # Optional. Data value.
                    },
                    "totalYield": {
                        "unit": "str",  # Optional. Data unit.
                        "value": 0.0  # Optional. Data value.
                    }
                }
        """
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type = kwargs.pop("content_type", _headers.pop("Content-Type", None))  # type: Optional[str]
        cls = kwargs.pop("cls", None)  # type: ClsType[JSON]

        content_type = content_type or "application/merge-patch+json"
        _json = None
        _content = None
        if isinstance(harvest_data, (IO, bytes)):
            _content = harvest_data
        else:
            _json = harvest_data

        request = build_harvest_data_create_or_update_request(
            party_id=party_id,
            harvest_data_id=harvest_data_id,
            content_type=content_type,
            api_version=self._config.api_version,
            json=_json,
            content=_content,
            headers=_headers,
            params=_params,
        )
        request.url = self._client.format_url(request.url)  # type: ignore

        pipeline_response = self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
            request, stream=False, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200, 201]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if response.status_code == 200:
            if response.content:
                deserialized = response.json()
            else:
                deserialized = None

        if response.status_code == 201:
            if response.content:
                deserialized = response.json()
            else:
                deserialized = None

        if cls:
            return cls(pipeline_response, cast(JSON, deserialized), {})

        return cast(JSON, deserialized)

    @distributed_trace
    def delete(  # pylint: disable=inconsistent-return-statements
        self, party_id: str, harvest_data_id: str, **kwargs: Any
    ) -> None:
        """Deletes a specified harvest data resource under a particular party.

        :param party_id: ID of the associated party resource. Required.
        :type party_id: str
        :param harvest_data_id: ID of the harvest data. Required.
        :type harvest_data_id: str
        :return: None
        :rtype: None
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls = kwargs.pop("cls", None)  # type: ClsType[None]

        request = build_harvest_data_delete_request(
            party_id=party_id,
            harvest_data_id=harvest_data_id,
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        request.url = self._client.format_url(request.url)  # type: ignore

        pipeline_response = self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
            request, stream=False, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [204]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if cls:
            return cls(pipeline_response, None, {})


class ImageProcessingOperations:
    """
    .. warning::
        **DO NOT** instantiate this class directly.

        Instead, you should access the following operations through
        :class:`~azure.agrifood.farming.FarmBeatsClient`'s
        :attr:`image_processing` attribute.
    """

    def __init__(self, *args, **kwargs):
        input_args = list(args)
        self._client = input_args.pop(0) if input_args else kwargs.pop("client")
        self._config = input_args.pop(0) if input_args else kwargs.pop("config")
        self._serialize = input_args.pop(0) if input_args else kwargs.pop("serializer")
        self._deserialize = input_args.pop(0) if input_args else kwargs.pop("deserializer")

    def _create_rasterize_job_initial(self, job_id: str, job: Union[JSON, IO], **kwargs: Any) -> JSON:
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type = kwargs.pop("content_type", _headers.pop("Content-Type", None))  # type: Optional[str]
        cls = kwargs.pop("cls", None)  # type: ClsType[JSON]

        content_type = content_type or "application/json"
        _json = None
        _content = None
        if isinstance(job, (IO, bytes)):
            _content = job
        else:
            _json = job

        request = build_image_processing_create_rasterize_job_request(
            job_id=job_id,
            content_type=content_type,
            api_version=self._config.api_version,
            json=_json,
            content=_content,
            headers=_headers,
            params=_params,
        )
        request.url = self._client.format_url(request.url)  # type: ignore

        pipeline_response = self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
            request, stream=False, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [202]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if response.content:
            deserialized = response.json()
        else:
            deserialized = None

        if cls:
            return cls(pipeline_response, cast(JSON, deserialized), {})

        return cast(JSON, deserialized)

    @overload
    def begin_create_rasterize_job(
        self, job_id: str, job: JSON, *, content_type: str = "application/json", **kwargs: Any
    ) -> LROPoller[JSON]:
        """Create a ImageProcessing Rasterize job.

        :param job_id: JobId provided by user. Required.
        :type job_id: str
        :param job: Job parameters supplied by user. Required.
        :type job: JSON
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :keyword str continuation_token: A continuation token to restart a poller from a saved state.
        :keyword polling: By default, your polling method will be LROBasePolling. Pass in False for
         this operation to not poll, or pass in your own initialized polling object for a personal
         polling strategy.
        :paramtype polling: bool or ~azure.core.polling.PollingMethod
        :keyword int polling_interval: Default waiting time between two polls for LRO operations if no
         Retry-After header is present.
        :return: An instance of LROPoller that returns JSON object
        :rtype: ~azure.core.polling.LROPoller[JSON]
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                job = {
                    "partyId": "str",  # Party Id. Required.
                    "shapefileAttachmentId": "str",  # Shapefile attachment Id. Required.
                    "shapefileColumnNames": [
                        "str"  # List of shapefile column names to create raster attachments.
                          Required.
                    ],
                    "createdBy": "str",  # Optional. Created by user/tenant id.
                    "createdDateTime": "2020-02-20 00:00:00",  # Optional. Job created at
                      dateTime. Sample format: yyyy-MM-ddTHH:mm:ssZ.
                    "description": "str",  # Optional. Textual description of the resource.
                    "durationInSeconds": 0.0,  # Optional. Duration of the job in seconds.
                    "endTime": "2020-02-20 00:00:00",  # Optional. Job end time when available.
                      Sample format: yyyy-MM-ddTHH:mm:ssZ.
                    "errorCode": "str",  # Optional. Error Code when job failed.
                    "id": "str",  # Optional. Unique job id.
                    "lastActionDateTime": "2020-02-20 00:00:00",  # Optional. Job was last acted
                      upon at dateTime. Sample format: yyyy-MM-ddTHH:mm:ssZ.
                    "message": "str",  # Optional. Status message to capture more details of the
                      job.
                    "modifiedBy": "str",  # Optional. Modified by user/tenant id.
                    "name": "str",  # Optional. Name to identify resource.
                    "properties": {
                        "str": {}  # Optional. A collection of key value pairs that belongs
                          to the resource."nEach pair must not have a key greater than 50
                          characters"nand must not have a value greater than 150 characters."nNote: A
                          maximum of 25 key value pairs can be provided for a resource and only
                          string,"nnumeral and datetime (yyyy-MM-ddTHH:mm:ssZ) values are supported.
                    },
                    "startTime": "2020-02-20 00:00:00",  # Optional. Job start time when
                      available. Sample format: yyyy-MM-ddTHH:mm:ssZ.
                    "status": "str"  # Optional. Status of the job."nPossible values: 'Waiting',
                      'Running', 'Succeeded', 'Failed', 'Cancelled'.
                }

                # response body for status code(s): 202
                response == {
                    "partyId": "str",  # Party Id. Required.
                    "shapefileAttachmentId": "str",  # Shapefile attachment Id. Required.
                    "shapefileColumnNames": [
                        "str"  # List of shapefile column names to create raster attachments.
                          Required.
                    ],
                    "createdBy": "str",  # Optional. Created by user/tenant id.
                    "createdDateTime": "2020-02-20 00:00:00",  # Optional. Job created at
                      dateTime. Sample format: yyyy-MM-ddTHH:mm:ssZ.
                    "description": "str",  # Optional. Textual description of the resource.
                    "durationInSeconds": 0.0,  # Optional. Duration of the job in seconds.
                    "endTime": "2020-02-20 00:00:00",  # Optional. Job end time when available.
                      Sample format: yyyy-MM-ddTHH:mm:ssZ.
                    "errorCode": "str",  # Optional. Error Code when job failed.
                    "id": "str",  # Optional. Unique job id.
                    "lastActionDateTime": "2020-02-20 00:00:00",  # Optional. Job was last acted
                      upon at dateTime. Sample format: yyyy-MM-ddTHH:mm:ssZ.
                    "message": "str",  # Optional. Status message to capture more details of the
                      job.
                    "modifiedBy": "str",  # Optional. Modified by user/tenant id.
                    "name": "str",  # Optional. Name to identify resource.
                    "properties": {
                        "str": {}  # Optional. A collection of key value pairs that belongs
                          to the resource."nEach pair must not have a key greater than 50
                          characters"nand must not have a value greater than 150 characters."nNote: A
                          maximum of 25 key value pairs can be provided for a resource and only
                          string,"nnumeral and datetime (yyyy-MM-ddTHH:mm:ssZ) values are supported.
                    },
                    "startTime": "2020-02-20 00:00:00",  # Optional. Job start time when
                      available. Sample format: yyyy-MM-ddTHH:mm:ssZ.
                    "status": "str"  # Optional. Status of the job."nPossible values: 'Waiting',
                      'Running', 'Succeeded', 'Failed', 'Cancelled'.
                }
        """

    @overload
    def begin_create_rasterize_job(
        self, job_id: str, job: IO, *, content_type: str = "application/json", **kwargs: Any
    ) -> LROPoller[JSON]:
        """Create a ImageProcessing Rasterize job.

        :param job_id: JobId provided by user. Required.
        :type job_id: str
        :param job: Job parameters supplied by user. Required.
        :type job: IO
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Default value is "application/json".
        :paramtype content_type: str
        :keyword str continuation_token: A continuation token to restart a poller from a saved state.
        :keyword polling: By default, your polling method will be LROBasePolling. Pass in False for
         this operation to not poll, or pass in your own initialized polling object for a personal
         polling strategy.
        :paramtype polling: bool or ~azure.core.polling.PollingMethod
        :keyword int polling_interval: Default waiting time between two polls for LRO operations if no
         Retry-After header is present.
        :return: An instance of LROPoller that returns JSON object
        :rtype: ~azure.core.polling.LROPoller[JSON]
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 202
                response == {
                    "partyId": "str",  # Party Id. Required.
                    "shapefileAttachmentId": "str",  # Shapefile attachment Id. Required.
                    "shapefileColumnNames": [
                        "str"  # List of shapefile column names to create raster attachments.
                          Required.
                    ],
                    "createdBy": "str",  # Optional. Created by user/tenant id.
                    "createdDateTime": "2020-02-20 00:00:00",  # Optional. Job created at
                      dateTime. Sample format: yyyy-MM-ddTHH:mm:ssZ.
                    "description": "str",  # Optional. Textual description of the resource.
                    "durationInSeconds": 0.0,  # Optional. Duration of the job in seconds.
                    "endTime": "2020-02-20 00:00:00",  # Optional. Job end time when available.
                      Sample format: yyyy-MM-ddTHH:mm:ssZ.
                    "errorCode": "str",  # Optional. Error Code when job failed.
                    "id": "str",  # Optional. Unique job id.
                    "lastActionDateTime": "2020-02-20 00:00:00",  # Optional. Job was last acted
                      upon at dateTime. Sample format: yyyy-MM-ddTHH:mm:ssZ.
                    "message": "str",  # Optional. Status message to capture more details of the
                      job.
                    "modifiedBy": "str",  # Optional. Modified by user/tenant id.
                    "name": "str",  # Optional. Name to identify resource.
                    "properties": {
                        "str": {}  # Optional. A collection of key value pairs that belongs
                          to the resource."nEach pair must not have a key greater than 50
                          characters"nand must not have a value greater than 150 characters."nNote: A
                          maximum of 25 key value pairs can be provided for a resource and only
                          string,"nnumeral and datetime (yyyy-MM-ddTHH:mm:ssZ) values are supported.
                    },
                    "startTime": "2020-02-20 00:00:00",  # Optional. Job start time when
                      available. Sample format: yyyy-MM-ddTHH:mm:ssZ.
                    "status": "str"  # Optional. Status of the job."nPossible values: 'Waiting',
                      'Running', 'Succeeded', 'Failed', 'Cancelled'.
                }
        """

    @distributed_trace
    def begin_create_rasterize_job(self, job_id: str, job: Union[JSON, IO], **kwargs: Any) -> LROPoller[JSON]:
        """Create a ImageProcessing Rasterize job.

        :param job_id: JobId provided by user. Required.
        :type job_id: str
        :param job: Job parameters supplied by user. Is either a model type or a IO type. Required.
        :type job: JSON or IO
        :keyword content_type: Body Parameter content-type. Known values are: 'application/json'.
         Default value is None.
        :paramtype content_type: str
        :keyword str continuation_token: A continuation token to restart a poller from a saved state.
        :keyword polling: By default, your polling method will be LROBasePolling. Pass in False for
         this operation to not poll, or pass in your own initialized polling object for a personal
         polling strategy.
        :paramtype polling: bool or ~azure.core.polling.PollingMethod
        :keyword int polling_interval: Default waiting time between two polls for LRO operations if no
         Retry-After header is present.
        :return: An instance of LROPoller that returns JSON object
        :rtype: ~azure.core.polling.LROPoller[JSON]
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 202
                response == {
                    "partyId": "str",  # Party Id. Required.
                    "shapefileAttachmentId": "str",  # Shapefile attachment Id. Required.
                    "shapefileColumnNames": [
                        "str"  # List of shapefile column names to create raster attachments.
                          Required.
                    ],
                    "createdBy": "str",  # Optional. Created by user/tenant id.
                    "createdDateTime": "2020-02-20 00:00:00",  # Optional. Job created at
                      dateTime. Sample format: yyyy-MM-ddTHH:mm:ssZ.
                    "description": "str",  # Optional. Textual description of the resource.
                    "durationInSeconds": 0.0,  # Optional. Duration of the job in seconds.
                    "endTime": "2020-02-20 00:00:00",  # Optional. Job end time when available.
                      Sample format: yyyy-MM-ddTHH:mm:ssZ.
                    "errorCode": "str",  # Optional. Error Code when job failed.
                    "id": "str",  # Optional. Unique job id.
                    "lastActionDateTime": "2020-02-20 00:00:00",  # Optional. Job was last acted
                      upon at dateTime. Sample format: yyyy-MM-ddTHH:mm:ssZ.
                    "message": "str",  # Optional. Status message to capture more details of the
                      job.
                    "modifiedBy": "str",  # Optional. Modified by user/tenant id.
                    "name": "str",  # Optional. Name to identify resource.
                    "properties": {
                        "str": {}  # Optional. A collection of key value pairs that belongs
                          to the resource."nEach pair must not have a key greater than 50
                          characters"nand must not have a value greater than 150 characters."nNote: A
                          maximum of 25 key value pairs can be provided for a resource and only
                          string,"nnumeral and datetime (yyyy-MM-ddTHH:mm:ssZ) values are supported.
                    },
                    "startTime": "2020-02-20 00:00:00",  # Optional. Job start time when
                      available. Sample format: yyyy-MM-ddTHH:mm:ssZ.
                    "status": "str"  # Optional. Status of the job."nPossible values: 'Waiting',
                      'Running', 'Succeeded', 'Failed', 'Cancelled'.
                }
        """
        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type = kwargs.pop("content_type", _headers.pop("Content-Type", None))  # type: Optional[str]
        cls = kwargs.pop("cls", None)  # type: ClsType[JSON]
        polling = kwargs.pop("polling", True)  # type: Union[bool, PollingMethod]
        lro_delay = kwargs.pop("polling_interval", self._config.polling_interval)
        cont_token = kwargs.pop("continuation_token", None)  # type: Optional[str]
        if cont_token is None:
            raw_result = self._create_rasterize_job_initial(  # type: ignore
                job_id=job_id,
                job=job,
                content_type=content_type,
                cls=lambda x, y, z: x,
                headers=_headers,
                params=_params,
                **kwargs
            )
        kwargs.pop("error_map", None)

        def get_long_running_output(pipeline_response):
            response = pipeline_response.http_response
            if response.content:
                deserialized = response.json()
            else:
                deserialized = None
            if cls:
                return cls(pipeline_response, deserialized, {})
            return deserialized

        if polling is True:
            polling_method = cast(
                PollingMethod, LROBasePolling(lro_delay, lro_options={"final-state-via": "location"}, **kwargs)
            )  # type: PollingMethod
        elif polling is False:
            polling_method = cast(PollingMethod, NoPolling())
        else:
            polling_method = polling
        if cont_token:
            return LROPoller.from_continuation_token(
                polling_method=polling_method,
                continuation_token=cont_token,
                client=self._client,
                deserialization_callback=get_long_running_output,
            )
        return LROPoller(self._client, raw_result, get_long_running_output, polling_method)

    @distributed_trace
    def get_rasterize_job(self, job_id: str, **kwargs: Any) -> JSON:
        """Get ImageProcessing Rasterize job's details.

        :param job_id: Id of the job. Required.
        :type job_id: str
        :return: JSON object
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "partyId": "str",  # Party Id. Required.
                    "shapefileAttachmentId": "str",  # Shapefile attachment Id. Required.
                    "shapefileColumnNames": [
                        "str"  # List of shapefile column names to create raster attachments.
                          Required.
                    ],
                    "createdBy": "str",  # Optional. Created by user/tenant id.
                    "createdDateTime": "2020-02-20 00:00:00",  # Optional. Job created at
                      dateTime. Sample format: yyyy-MM-ddTHH:mm:ssZ.
                    "description": "str",  # Optional. Textual description of the resource.
                    "durationInSeconds": 0.0,  # Optional. Duration of the job in seconds.
                    "endTime": "2020-02-20 00:00:00",  # Optional. Job end time when available.
                      Sample format: yyyy-MM-ddTHH:mm:ssZ.
                    "errorCode": "str",  # Optional. Error Code when job failed.
                    "id": "str",  # Optional. Unique job id.
                    "lastActionDateTime": "2020-02-20 00:00:00",  # Optional. Job was last acted
                      upon at dateTime. Sample format: yyyy-MM-ddTHH:mm:ssZ.
                    "message": "str",  # Optional. Status message to capture more details of the
                      job.
                    "modifiedBy": "str",  # Optional. Modified by user/tenant id.
                    "name": "str",  # Optional. Name to identify resource.
                    "properties": {
                        "str": {}  # Optional. A collection of key value pairs that belongs
                          to the resource."nEach pair must not have a key greater than 50
                          characters"nand must not have a value greater than 150 characters."nNote: A
                          maximum of 25 key value pairs can be provided for a resource and only
                          string,"nnumeral and datetime (yyyy-MM-ddTHH:mm:ssZ) values are supported.
                    },
                    "startTime": "2020-02-20 00:00:00",  # Optional. Job start time when
                      available. Sample format: yyyy-MM-ddTHH:mm:ssZ.
                    "status": "str"  # Optional. Status of the job."nPossible values: 'Waiting',
                      'Running', 'Succeeded', 'Failed', 'Cancelled'.
                }
        """
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls = kwargs.pop("cls", None)  # type: ClsType[JSON]

        request = build_image_processing_get_rasterize_job_request(
            job_id=job_id,
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        request.url = self._client.format_url(request.url)  # type: ignore

        pipeline_response = self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
            request, stream=False, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if response.content:
            deserialized = response.json()
        else:
            deserialized = None

        if cls:
            return cls(pipeline_response, cast(JSON, deserialized), {})

        return cast(JSON, deserialized)


class InsightAttachmentsOperations:
    """
    .. warning::
        **DO NOT** instantiate this class directly.

        Instead, you should access the following operations through
        :class:`~azure.agrifood.farming.FarmBeatsClient`'s
        :attr:`insight_attachments` attribute.
    """

    def __init__(self, *args, **kwargs):
        input_args = list(args)
        self._client = input_args.pop(0) if input_args else kwargs.pop("client")
        self._config = input_args.pop(0) if input_args else kwargs.pop("config")
        self._serialize = input_args.pop(0) if input_args else kwargs.pop("serializer")
        self._deserialize = input_args.pop(0) if input_args else kwargs.pop("deserializer")
        raise_if_not_implemented(
            self.__class__,
            [
                "create_or_update",
            ],
        )

    @distributed_trace
    def list_by_party_id_model_id_and_resource(
        self,
        party_id: str,
        model_id: str,
        resource_type: str,
        resource_id: str,
        *,
        insight_ids: Optional[List[str]] = None,
        ids: Optional[List[str]] = None,
        names: Optional[List[str]] = None,
        property_filters: Optional[List[str]] = None,
        statuses: Optional[List[str]] = None,
        min_created_date_time: Optional[datetime.datetime] = None,
        max_created_date_time: Optional[datetime.datetime] = None,
        min_last_modified_date_time: Optional[datetime.datetime] = None,
        max_last_modified_date_time: Optional[datetime.datetime] = None,
        skip_token: Optional[str] = None,
        **kwargs: Any
    ) -> Iterable[JSON]:
        """Returns a paginated list of insight resources.

        :param party_id: Id of the associated party. Required.
        :type party_id: str
        :param model_id: Id of the associated model. Required.
        :type model_id: str
        :param resource_type: Resource type associated with the record. Required.
        :type resource_type: str
        :param resource_id: Id of the associated resource. Required.
        :type resource_id: str
        :keyword insight_ids: List of insight IDs. Default value is None.
        :paramtype insight_ids: list[str]
        :keyword ids: Ids of the resource. Default value is None.
        :paramtype ids: list[str]
        :keyword names: Names of the resource. Default value is None.
        :paramtype names: list[str]
        :keyword property_filters: Filters on key-value pairs within the Properties object.
         eg. "{testKey} eq {testValue}". Default value is None.
        :paramtype property_filters: list[str]
        :keyword statuses: Statuses of the resource. Default value is None.
        :paramtype statuses: list[str]
        :keyword min_created_date_time: Minimum creation date of resource (inclusive). Default value is
         None.
        :paramtype min_created_date_time: ~datetime.datetime
        :keyword max_created_date_time: Maximum creation date of resource (inclusive). Default value is
         None.
        :paramtype max_created_date_time: ~datetime.datetime
        :keyword min_last_modified_date_time: Minimum last modified date of resource (inclusive).
         Default value is None.
        :paramtype min_last_modified_date_time: ~datetime.datetime
        :keyword max_last_modified_date_time: Maximum last modified date of resource (inclusive).
         Default value is None.
        :paramtype max_last_modified_date_time: ~datetime.datetime
        :keyword skip_token: Skip token for getting next set of results. Default value is None.
        :paramtype skip_token: str
        :return: An iterator like instance of JSON object
        :rtype: ~azure.core.paging.ItemPaged[JSON]
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "insightId": "str",  # InsightID for this InsightAttachment. Required.
                    "createdBy": "str",  # Optional. Created by user/tenant id.
                    "createdDateTime": "2020-02-20 00:00:00",  # Optional. Date when resource was
                      created.
                    "description": "str",  # Optional. Textual description of resource.
                    "eTag": "str",  # Optional. The ETag value to implement optimistic
                      concurrency.
                    "id": "str",  # Optional. Unique id.
                    "modelId": "str",  # Optional. ModelID for this InsightAttachment.
                    "modifiedBy": "str",  # Optional. Modified by user/tenant id.
                    "modifiedDateTime": "2020-02-20 00:00:00",  # Optional. Date when resource
                      was last modified.
                    "name": "str",  # Optional. Name to identify resource.
                    "originalFileName": "str",  # Optional. Original File Name for this
                      attachment.
                    "partyId": "str",  # Optional. PartyId id for this attachment.
                    "resourceId": "str",  # Optional. Associated Resource id for this attachment.
                    "resourceType": "str",  # Optional. Associated Resource type for this
                      attachment. Known values are: "Party", "Farm", "Field", "SeasonalField", and
                      "Boundary".
                    "source": "str",  # Optional. Source of the resource.
                    "status": "str"  # Optional. Status of the resource.
                }
        """
        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls = kwargs.pop("cls", None)  # type: ClsType[JSON]

        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        def prepare_request(next_link=None):
            if not next_link:

                request = build_insight_attachments_list_by_party_id_model_id_and_resource_request(
                    party_id=party_id,
                    model_id=model_id,
                    resource_type=resource_type,
                    resource_id=resource_id,
                    insight_ids=insight_ids,
                    ids=ids,
                    names=names,
                    property_filters=property_filters,
                    statuses=statuses,
                    min_created_date_time=min_created_date_time,
                    max_created_date_time=max_created_date_time,
                    min_last_modified_date_time=min_last_modified_date_time,
                    max_last_modified_date_time=max_last_modified_date_time,
                    skip_token=skip_token,
                    api_version=self._config.api_version,
                    headers=_headers,
                    params=_params,
                )
                request.url = self._client.format_url(request.url)  # type: ignore

            else:
                # make call to next link with the client's api-version
                _parsed_next_link = urlparse(next_link)
                _next_request_params = case_insensitive_dict(parse_qs(_parsed_next_link.query))
                _next_request_params["api-version"] = self._config.api_version
                request = HttpRequest("GET", urljoin(next_link, _parsed_next_link.path), params=_next_request_params)
                request.url = self._client.format_url(request.url)  # type: ignore

            return request

        def extract_data(pipeline_response):
            deserialized = pipeline_response.http_response.json()
            list_of_elem = deserialized["value"]
            if cls:
                list_of_elem = cls(list_of_elem)
            return deserialized.get("nextLink", None), iter(list_of_elem)

        def get_next(next_link=None):
            request = prepare_request(next_link)

            pipeline_response = self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
                request, stream=False, **kwargs
            )
            response = pipeline_response.http_response

            if response.status_code not in [200]:
                map_error(status_code=response.status_code, response=response, error_map=error_map)
                raise HttpResponseError(response=response)

            return pipeline_response

        return ItemPaged(get_next, extract_data)

    @distributed_trace
    def get(
        self,
        party_id: str,
        model_id: str,
        resource_type: str,
        resource_id: str,
        insight_attachment_id: str,
        **kwargs: Any
    ) -> JSON:
        """Gets a specified insight resource under a particular party.

        :param party_id: Id of the associated party. Required.
        :type party_id: str
        :param model_id: Id of the associated model.
         It can be either 'BiomassModelId', 'SensorPlacementModelId', 'SoilMoistureModelId' or any
         solution id. Required.
        :type model_id: str
        :param resource_type: Resource type associated with the record. Required.
        :type resource_type: str
        :param resource_id: Id of the associated resource. Required.
        :type resource_id: str
        :param insight_attachment_id: Id of the insight attachment resource. Required.
        :type insight_attachment_id: str
        :return: JSON object
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "insightId": "str",  # InsightID for this InsightAttachment. Required.
                    "createdBy": "str",  # Optional. Created by user/tenant id.
                    "createdDateTime": "2020-02-20 00:00:00",  # Optional. Date when resource was
                      created.
                    "description": "str",  # Optional. Textual description of resource.
                    "eTag": "str",  # Optional. The ETag value to implement optimistic
                      concurrency.
                    "id": "str",  # Optional. Unique id.
                    "modelId": "str",  # Optional. ModelID for this InsightAttachment.
                    "modifiedBy": "str",  # Optional. Modified by user/tenant id.
                    "modifiedDateTime": "2020-02-20 00:00:00",  # Optional. Date when resource
                      was last modified.
                    "name": "str",  # Optional. Name to identify resource.
                    "originalFileName": "str",  # Optional. Original File Name for this
                      attachment.
                    "partyId": "str",  # Optional. PartyId id for this attachment.
                    "resourceId": "str",  # Optional. Associated Resource id for this attachment.
                    "resourceType": "str",  # Optional. Associated Resource type for this
                      attachment. Known values are: "Party", "Farm", "Field", "SeasonalField", and
                      "Boundary".
                    "source": "str",  # Optional. Source of the resource.
                    "status": "str"  # Optional. Status of the resource.
                }
        """
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls = kwargs.pop("cls", None)  # type: ClsType[JSON]

        request = build_insight_attachments_get_request(
            party_id=party_id,
            model_id=model_id,
            resource_type=resource_type,
            resource_id=resource_id,
            insight_attachment_id=insight_attachment_id,
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        request.url = self._client.format_url(request.url)  # type: ignore

        pipeline_response = self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
            request, stream=False, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if response.content:
            deserialized = response.json()
        else:
            deserialized = None

        if cls:
            return cls(pipeline_response, cast(JSON, deserialized), {})

        return cast(JSON, deserialized)

    @distributed_trace
    def delete(  # pylint: disable=inconsistent-return-statements
        self,
        party_id: str,
        model_id: str,
        resource_type: str,
        resource_id: str,
        insight_attachment_id: str,
        **kwargs: Any
    ) -> None:
        """Deletes a specified insight resource.

        :param party_id: Id of the associated party. Required.
        :type party_id: str
        :param model_id: Id of the associated model.
         It can be either 'BiomassModelId', 'SensorPlacementModelId', 'SoilMoistureModelId' or any
         solution id. Required.
        :type model_id: str
        :param resource_type: Resource type associated with the record. Required.
        :type resource_type: str
        :param resource_id: Id of the associated resource. Required.
        :type resource_id: str
        :param insight_attachment_id: Id of the insight attachment resource. Required.
        :type insight_attachment_id: str
        :return: None
        :rtype: None
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls = kwargs.pop("cls", None)  # type: ClsType[None]

        request = build_insight_attachments_delete_request(
            party_id=party_id,
            model_id=model_id,
            resource_type=resource_type,
            resource_id=resource_id,
            insight_attachment_id=insight_attachment_id,
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        request.url = self._client.format_url(request.url)  # type: ignore

        pipeline_response = self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
            request, stream=False, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [204]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if cls:
            return cls(pipeline_response, None, {})

    @distributed_trace
    def download(
        self,
        party_id: str,
        model_id: str,
        resource_type: str,
        resource_id: str,
        insight_attachment_id: str,
        **kwargs: Any
    ) -> Iterator[bytes]:
        """Downloads and returns insight-attachment as response for the given input filePath.

        :param party_id: Id of the associated party. Required.
        :type party_id: str
        :param model_id: Id of the associated model.
         It can be either 'BiomassModelId', 'SensorPlacementModelId', 'SoilMoistureModelId' or any
         solution id. Required.
        :type model_id: str
        :param resource_type: Resource type associated with the record. Required.
        :type resource_type: str
        :param resource_id: Id of the associated resource. Required.
        :type resource_id: str
        :param insight_attachment_id: Id of the insight attachment resource. Required.
        :type insight_attachment_id: str
        :return: Iterator of the response bytes
        :rtype: Iterator[bytes]
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls = kwargs.pop("cls", None)  # type: ClsType[Iterator[bytes]]

        request = build_insight_attachments_download_request(
            party_id=party_id,
            model_id=model_id,
            resource_type=resource_type,
            resource_id=resource_id,
            insight_attachment_id=insight_attachment_id,
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        request.url = self._client.format_url(request.url)  # type: ignore

        pipeline_response = self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
            request, stream=True, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        deserialized = response.iter_bytes()

        if cls:
            return cls(pipeline_response, cast(Iterator[bytes], deserialized), {})

        return cast(Iterator[bytes], deserialized)


class InsightsOperations:
    """
    .. warning::
        **DO NOT** instantiate this class directly.

        Instead, you should access the following operations through
        :class:`~azure.agrifood.farming.FarmBeatsClient`'s
        :attr:`insights` attribute.
    """

    def __init__(self, *args, **kwargs):
        input_args = list(args)
        self._client = input_args.pop(0) if input_args else kwargs.pop("client")
        self._config = input_args.pop(0) if input_args else kwargs.pop("config")
        self._serialize = input_args.pop(0) if input_args else kwargs.pop("serializer")
        self._deserialize = input_args.pop(0) if input_args else kwargs.pop("deserializer")

    def _create_cascade_delete_job_initial(
        self,
        job_id: str,
        *,
        party_id: str,
        model_id: str,
        resource_type: str,
        resource_id: str,
        insight_id: str,
        **kwargs: Any
    ) -> JSON:
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls = kwargs.pop("cls", None)  # type: ClsType[JSON]

        request = build_insights_create_cascade_delete_job_request(
            job_id=job_id,
            party_id=party_id,
            model_id=model_id,
            resource_type=resource_type,
            resource_id=resource_id,
            insight_id=insight_id,
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        request.url = self._client.format_url(request.url)  # type: ignore

        pipeline_response = self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
            request, stream=False, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [202]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if response.content:
            deserialized = response.json()
        else:
            deserialized = None

        if cls:
            return cls(pipeline_response, cast(JSON, deserialized), {})

        return cast(JSON, deserialized)

    @distributed_trace
    def begin_create_cascade_delete_job(
        self,
        job_id: str,
        *,
        party_id: str,
        model_id: str,
        resource_type: str,
        resource_id: str,
        insight_id: str,
        **kwargs: Any
    ) -> LROPoller[JSON]:
        """Create a cascade delete job for insights specified partyId/modelId/resourceType/resourceId.

        :param job_id: Job ID supplied by end user. Required.
        :type job_id: str
        :keyword party_id: ID of the associated party. Required.
        :paramtype party_id: str
        :keyword model_id: Id of the associated model. Required.
        :paramtype model_id: str
        :keyword resource_type: Resource Type. Required.
        :paramtype resource_type: str
        :keyword resource_id: Id of the associated resource. Required.
        :paramtype resource_id: str
        :keyword insight_id: Insight id. Required.
        :paramtype insight_id: str
        :keyword str continuation_token: A continuation token to restart a poller from a saved state.
        :keyword polling: By default, your polling method will be LROBasePolling. Pass in False for
         this operation to not poll, or pass in your own initialized polling object for a personal
         polling strategy.
        :paramtype polling: bool or ~azure.core.polling.PollingMethod
        :keyword int polling_interval: Default waiting time between two polls for LRO operations if no
         Retry-After header is present.
        :return: An instance of LROPoller that returns JSON object
        :rtype: ~azure.core.polling.LROPoller[JSON]
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 202
                response == {
                    "partyId": "str",  # Party Id. Required.
                    "resourceId": "str",  # The id of the resource. Required.
                    "resourceType": "str",  # The type of the resource. Required.
                    "createdDateTime": "2020-02-20 00:00:00",  # Optional. Job created at
                      dateTime. Sample format: yyyy-MM-ddTHH:mm:ssZ.
                    "durationInSeconds": 0.0,  # Optional. Duration of the job in seconds.
                    "endTime": "2020-02-20 00:00:00",  # Optional. Job end time when available.
                      Sample format: yyyy-MM-ddTHH:mm:ssZ.
                    "errorCode": "str",  # Optional. Error Code when job failed.
                    "id": "str",  # Optional. Unique job id.
                    "lastActionDateTime": "2020-02-20 00:00:00",  # Optional. Job was last acted
                      upon at dateTime. Sample format: yyyy-MM-ddTHH:mm:ssZ.
                    "message": "str",  # Optional. Status message to capture more details of the
                      job.
                    "startTime": "2020-02-20 00:00:00",  # Optional. Job start time when
                      available. Sample format: yyyy-MM-ddTHH:mm:ssZ.
                    "status": "str"  # Optional. Status of the job."nPossible values: 'Waiting',
                      'Running', 'Succeeded', 'Failed', 'Cancelled'. Known values are: "Waiting",
                      "Running", "Succeeded", "Failed", and "Cancelled".
                }
        """
        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls = kwargs.pop("cls", None)  # type: ClsType[JSON]
        polling = kwargs.pop("polling", True)  # type: Union[bool, PollingMethod]
        lro_delay = kwargs.pop("polling_interval", self._config.polling_interval)
        cont_token = kwargs.pop("continuation_token", None)  # type: Optional[str]
        if cont_token is None:
            raw_result = self._create_cascade_delete_job_initial(  # type: ignore
                job_id=job_id,
                party_id=party_id,
                model_id=model_id,
                resource_type=resource_type,
                resource_id=resource_id,
                insight_id=insight_id,
                cls=lambda x, y, z: x,
                headers=_headers,
                params=_params,
                **kwargs
            )
        kwargs.pop("error_map", None)

        def get_long_running_output(pipeline_response):
            response = pipeline_response.http_response
            if response.content:
                deserialized = response.json()
            else:
                deserialized = None
            if cls:
                return cls(pipeline_response, deserialized, {})
            return deserialized

        if polling is True:
            polling_method = cast(
                PollingMethod, LROBasePolling(lro_delay, lro_options={"final-state-via": "location"}, **kwargs)
            )  # type: PollingMethod
        elif polling is False:
            polling_method = cast(PollingMethod, NoPolling())
        else:
            polling_method = polling
        if cont_token:
            return LROPoller.from_continuation_token(
                polling_method=polling_method,
                continuation_token=cont_token,
                client=self._client,
                deserialization_callback=get_long_running_output,
            )
        return LROPoller(self._client, raw_result, get_long_running_output, polling_method)

    @distributed_trace
    def get_cascade_delete_job_details(self, job_id: str, **kwargs: Any) -> JSON:
        """Get a cascade delete job for specified insight.

        :param job_id: Id of the job. Required.
        :type job_id: str
        :return: JSON object
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "partyId": "str",  # Party Id. Required.
                    "resourceId": "str",  # The id of the resource. Required.
                    "resourceType": "str",  # The type of the resource. Required.
                    "createdDateTime": "2020-02-20 00:00:00",  # Optional. Job created at
                      dateTime. Sample format: yyyy-MM-ddTHH:mm:ssZ.
                    "durationInSeconds": 0.0,  # Optional. Duration of the job in seconds.
                    "endTime": "2020-02-20 00:00:00",  # Optional. Job end time when available.
                      Sample format: yyyy-MM-ddTHH:mm:ssZ.
                    "errorCode": "str",  # Optional. Error Code when job failed.
                    "id": "str",  # Optional. Unique job id.
                    "lastActionDateTime": "2020-02-20 00:00:00",  # Optional. Job was last acted
                      upon at dateTime. Sample format: yyyy-MM-ddTHH:mm:ssZ.
                    "message": "str",  # Optional. Status message to capture more details of the
                      job.
                    "startTime": "2020-02-20 00:00:00",  # Optional. Job start time when
                      available. Sample format: yyyy-MM-ddTHH:mm:ssZ.
                    "status": "str"  # Optional. Status of the job."nPossible values: 'Waiting',
                      'Running', 'Succeeded', 'Failed', 'Cancelled'. Known values are: "Waiting",
                      "Running", "Succeeded", "Failed", and "Cancelled".
                }
        """
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls = kwargs.pop("cls", None)  # type: ClsType[JSON]

        request = build_insights_get_cascade_delete_job_details_request(
            job_id=job_id,
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        request.url = self._client.format_url(request.url)  # type: ignore

        pipeline_response = self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
            request, stream=False, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if response.content:
            deserialized = response.json()
        else:
            deserialized = None

        if cls:
            return cls(pipeline_response, cast(JSON, deserialized), {})

        return cast(JSON, deserialized)

    @distributed_trace
    def list_by_party_id_model_id_and_resource(
        self,
        party_id: str,
        model_id: str,
        resource_type: str,
        resource_id: str,
        *,
        min_insight_start_date_time: Optional[datetime.datetime] = None,
        max_insight_start_date_time: Optional[datetime.datetime] = None,
        min_insight_end_date_time: Optional[datetime.datetime] = None,
        max_insight_end_date_time: Optional[datetime.datetime] = None,
        measurement_filters: Optional[List[str]] = None,
        ids: Optional[List[str]] = None,
        names: Optional[List[str]] = None,
        property_filters: Optional[List[str]] = None,
        statuses: Optional[List[str]] = None,
        min_created_date_time: Optional[datetime.datetime] = None,
        max_created_date_time: Optional[datetime.datetime] = None,
        min_last_modified_date_time: Optional[datetime.datetime] = None,
        max_last_modified_date_time: Optional[datetime.datetime] = None,
        skip_token: Optional[str] = None,
        **kwargs: Any
    ) -> Iterable[JSON]:
        """Returns a paginated list of insight resources.

        :param party_id: Id of the associated party. Required.
        :type party_id: str
        :param model_id: Id of the associated model. Required.
        :type model_id: str
        :param resource_type: Resource type associated with the record. Required.
        :type resource_type: str
        :param resource_id: Id of the associated resource. Required.
        :type resource_id: str
        :keyword min_insight_start_date_time: Minimum insightStartDateTime time of insight resources
         (inclusive), sample format: yyyy-MM-ddTHH:mm:ssZ. Default value is None.
        :paramtype min_insight_start_date_time: ~datetime.datetime
        :keyword max_insight_start_date_time: Maximum insightStartDateTime time of insight resources
         (inclusive), sample format: yyyy-MM-ddTHH:mm:ssZ. Default value is None.
        :paramtype max_insight_start_date_time: ~datetime.datetime
        :keyword min_insight_end_date_time: Minimum insightEndDateTime time of insight resources
         (inclusive), sample format: yyyy-MM-ddTHH:mm:ssZ. Default value is None.
        :paramtype min_insight_end_date_time: ~datetime.datetime
        :keyword max_insight_end_date_time: Maximum insightEndDateTime time of insight resources
         (inclusive), sample format: yyyy-MM-ddTHH:mm:ssZ. Default value is None.
        :paramtype max_insight_end_date_time: ~datetime.datetime
        :keyword measurement_filters: Filters on measureKey.unit/unitValue or measureKey.value/value
         pairs within the Measures object.
         eg. "measureKey.unit eq {testValue}" where testValue is string.
         eg. "measureKey.value eq {testValue}" where testValue = double. Default value is None.
        :paramtype measurement_filters: list[str]
        :keyword ids: Ids of the resource. Default value is None.
        :paramtype ids: list[str]
        :keyword names: Names of the resource. Default value is None.
        :paramtype names: list[str]
        :keyword property_filters: Filters on key-value pairs within the Properties object.
         eg. "{testKey} eq {testValue}". Default value is None.
        :paramtype property_filters: list[str]
        :keyword statuses: Statuses of the resource. Default value is None.
        :paramtype statuses: list[str]
        :keyword min_created_date_time: Minimum creation date of resource (inclusive). Default value is
         None.
        :paramtype min_created_date_time: ~datetime.datetime
        :keyword max_created_date_time: Maximum creation date of resource (inclusive). Default value is
         None.
        :paramtype max_created_date_time: ~datetime.datetime
        :keyword min_last_modified_date_time: Minimum last modified date of resource (inclusive).
         Default value is None.
        :paramtype min_last_modified_date_time: ~datetime.datetime
        :keyword max_last_modified_date_time: Maximum last modified date of resource (inclusive).
         Default value is None.
        :paramtype max_last_modified_date_time: ~datetime.datetime
        :keyword skip_token: Skip token for getting next set of results. Default value is None.
        :paramtype skip_token: str
        :return: An iterator like instance of JSON object
        :rtype: ~azure.core.paging.ItemPaged[JSON]
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "attachmentsLink": "str",  # Optional. Gets link for attachments.
                    "createdBy": "str",  # Optional. Created by user/tenant id.
                    "createdDateTime": "2020-02-20 00:00:00",  # Optional. Date-time when
                      resource was created, sample format: yyyy-MM-ddTHH:mm:ssZ.
                    "description": "str",  # Optional. Textual description of the resource.
                    "eTag": "str",  # Optional. The ETag value to implement optimistic
                      concurrency.
                    "id": "str",  # Optional. Id of the resource.
                    "insightEndDateTime": "2020-02-20 00:00:00",  # Optional. End date to which
                      the insight is related.
                    "insightStartDateTime": "2020-02-20 00:00:00",  # Optional. Start date to
                      which the insight is related.
                    "measurements": {
                        "str": {
                            "unit": "str",  # Optional. Data unit.
                            "value": 0.0  # Optional. Data value.
                        }
                    },
                    "modelId": "str",  # Optional. Id of the associated model.
                    "modelVersion": "str",  # Optional. Version of the associated model.
                    "modifiedBy": "str",  # Optional. Modified by user/tenant id.
                    "modifiedDateTime": "2020-02-20 00:00:00",  # Optional. Date-time when
                      resource was last modified, sample format: yyyy-MM-ddTHH:mm:ssZ.
                    "name": "str",  # Optional. Name to identify resource.
                    "partyId": "str",  # Optional. Id of the associated party.
                    "properties": {
                        "str": {}  # Optional. A collection of key value pairs that belongs
                          to the resource."nEach pair must not have a key greater than 50
                          characters"nand must not have a value greater than 150 characters."nNote: A
                          maximum of 25 key value pairs can be provided for a resource and"nonly
                          string, numeral and datetime (yyyy-MM-ddTHH:mm:ssZ) values are supported.
                    },
                    "resourceId": "str",  # Optional. Id of the associated resource.
                    "resourceType": "str",  # Optional. Resource type associated with the record.
                      Known values are: "Party", "Farm", "Field", "SeasonalField", and "Boundary".
                    "status": "str"  # Optional. Status of the resource.
                }
        """
        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls = kwargs.pop("cls", None)  # type: ClsType[JSON]

        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        def prepare_request(next_link=None):
            if not next_link:

                request = build_insights_list_by_party_id_model_id_and_resource_request(
                    party_id=party_id,
                    model_id=model_id,
                    resource_type=resource_type,
                    resource_id=resource_id,
                    min_insight_start_date_time=min_insight_start_date_time,
                    max_insight_start_date_time=max_insight_start_date_time,
                    min_insight_end_date_time=min_insight_end_date_time,
                    max_insight_end_date_time=max_insight_end_date_time,
                    measurement_filters=measurement_filters,
                    ids=ids,
                    names=names,
                    property_filters=property_filters,
                    statuses=statuses,
                    min_created_date_time=min_created_date_time,
                    max_created_date_time=max_created_date_time,
                    min_last_modified_date_time=min_last_modified_date_time,
                    max_last_modified_date_time=max_last_modified_date_time,
                    skip_token=skip_token,
                    api_version=self._config.api_version,
                    headers=_headers,
                    params=_params,
                )
                request.url = self._client.format_url(request.url)  # type: ignore

            else:
                # make call to next link with the client's api-version
                _parsed_next_link = urlparse(next_link)
                _next_request_params = case_insensitive_dict(parse_qs(_parsed_next_link.query))
                _next_request_params["api-version"] = self._config.api_version
                request = HttpRequest("GET", urljoin(next_link, _parsed_next_link.path), params=_next_request_params)
                request.url = self._client.format_url(request.url)  # type: ignore

            return request

        def extract_data(pipeline_response):
            deserialized = pipeline_response.http_response.json()
            list_of_elem = deserialized["value"]
            if cls:
                list_of_elem = cls(list_of_elem)
            return deserialized.get("nextLink", None), iter(list_of_elem)

        def get_next(next_link=None):
            request = prepare_request(next_link)

            pipeline_response = self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
                request, stream=False, **kwargs
            )
            response = pipeline_response.http_response

            if response.status_code not in [200]:
                map_error(status_code=response.status_code, response=response, error_map=error_map)
                raise HttpResponseError(response=response)

            return pipeline_response

        return ItemPaged(get_next, extract_data)

    @overload
    def create_or_update(
        self,
        party_id: str,
        model_id: str,
        resource_type: str,
        resource_id: str,
        insight_id: str,
        insight_data: JSON,
        *,
        content_type: str = "application/merge-patch+json",
        **kwargs: Any
    ) -> JSON:
        """Creates or updates insight entity.

        :param party_id: Id of the associated party. Required.
        :type party_id: str
        :param model_id: Id of the associated model.
         It can be either 'BiomassModelId', 'SensorPlacementModelId', 'SoilMoistureModelId' or any
         solution id. Required.
        :type model_id: str
        :param resource_type: Resource type associated with the record. Required.
        :type resource_type: str
        :param resource_id: Id of the associated resource. Required.
        :type resource_id: str
        :param insight_id: Id of the insight resource. Required.
        :type insight_id: str
        :param insight_data: Insight data. Required.
        :type insight_data: JSON
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/merge-patch+json".
        :paramtype content_type: str
        :return: JSON object
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                insight_data = {
                    "attachmentsLink": "str",  # Optional. Gets link for attachments.
                    "createdBy": "str",  # Optional. Created by user/tenant id.
                    "createdDateTime": "2020-02-20 00:00:00",  # Optional. Date-time when
                      resource was created, sample format: yyyy-MM-ddTHH:mm:ssZ.
                    "description": "str",  # Optional. Textual description of the resource.
                    "eTag": "str",  # Optional. The ETag value to implement optimistic
                      concurrency.
                    "id": "str",  # Optional. Id of the resource.
                    "insightEndDateTime": "2020-02-20 00:00:00",  # Optional. End date to which
                      the insight is related.
                    "insightStartDateTime": "2020-02-20 00:00:00",  # Optional. Start date to
                      which the insight is related.
                    "measurements": {
                        "str": {
                            "unit": "str",  # Optional. Data unit.
                            "value": 0.0  # Optional. Data value.
                        }
                    },
                    "modelId": "str",  # Optional. Id of the associated model.
                    "modelVersion": "str",  # Optional. Version of the associated model.
                    "modifiedBy": "str",  # Optional. Modified by user/tenant id.
                    "modifiedDateTime": "2020-02-20 00:00:00",  # Optional. Date-time when
                      resource was last modified, sample format: yyyy-MM-ddTHH:mm:ssZ.
                    "name": "str",  # Optional. Name to identify resource.
                    "partyId": "str",  # Optional. Id of the associated party.
                    "properties": {
                        "str": {}  # Optional. A collection of key value pairs that belongs
                          to the resource."nEach pair must not have a key greater than 50
                          characters"nand must not have a value greater than 150 characters."nNote: A
                          maximum of 25 key value pairs can be provided for a resource and"nonly
                          string, numeral and datetime (yyyy-MM-ddTHH:mm:ssZ) values are supported.
                    },
                    "resourceId": "str",  # Optional. Id of the associated resource.
                    "resourceType": "str",  # Optional. Resource type associated with the record.
                      Known values are: "Party", "Farm", "Field", "SeasonalField", and "Boundary".
                    "status": "str"  # Optional. Status of the resource.
                }

                # response body for status code(s): 200, 201
                response == {
                    "attachmentsLink": "str",  # Optional. Gets link for attachments.
                    "createdBy": "str",  # Optional. Created by user/tenant id.
                    "createdDateTime": "2020-02-20 00:00:00",  # Optional. Date-time when
                      resource was created, sample format: yyyy-MM-ddTHH:mm:ssZ.
                    "description": "str",  # Optional. Textual description of the resource.
                    "eTag": "str",  # Optional. The ETag value to implement optimistic
                      concurrency.
                    "id": "str",  # Optional. Id of the resource.
                    "insightEndDateTime": "2020-02-20 00:00:00",  # Optional. End date to which
                      the insight is related.
                    "insightStartDateTime": "2020-02-20 00:00:00",  # Optional. Start date to
                      which the insight is related.
                    "measurements": {
                        "str": {
                            "unit": "str",  # Optional. Data unit.
                            "value": 0.0  # Optional. Data value.
                        }
                    },
                    "modelId": "str",  # Optional. Id of the associated model.
                    "modelVersion": "str",  # Optional. Version of the associated model.
                    "modifiedBy": "str",  # Optional. Modified by user/tenant id.
                    "modifiedDateTime": "2020-02-20 00:00:00",  # Optional. Date-time when
                      resource was last modified, sample format: yyyy-MM-ddTHH:mm:ssZ.
                    "name": "str",  # Optional. Name to identify resource.
                    "partyId": "str",  # Optional. Id of the associated party.
                    "properties": {
                        "str": {}  # Optional. A collection of key value pairs that belongs
                          to the resource."nEach pair must not have a key greater than 50
                          characters"nand must not have a value greater than 150 characters."nNote: A
                          maximum of 25 key value pairs can be provided for a resource and"nonly
                          string, numeral and datetime (yyyy-MM-ddTHH:mm:ssZ) values are supported.
                    },
                    "resourceId": "str",  # Optional. Id of the associated resource.
                    "resourceType": "str",  # Optional. Resource type associated with the record.
                      Known values are: "Party", "Farm", "Field", "SeasonalField", and "Boundary".
                    "status": "str"  # Optional. Status of the resource.
                }
        """

    @overload
    def create_or_update(
        self,
        party_id: str,
        model_id: str,
        resource_type: str,
        resource_id: str,
        insight_id: str,
        insight_data: IO,
        *,
        content_type: str = "application/merge-patch+json",
        **kwargs: Any
    ) -> JSON:
        """Creates or updates insight entity.

        :param party_id: Id of the associated party. Required.
        :type party_id: str
        :param model_id: Id of the associated model.
         It can be either 'BiomassModelId', 'SensorPlacementModelId', 'SoilMoistureModelId' or any
         solution id. Required.
        :type model_id: str
        :param resource_type: Resource type associated with the record. Required.
        :type resource_type: str
        :param resource_id: Id of the associated resource. Required.
        :type resource_id: str
        :param insight_id: Id of the insight resource. Required.
        :type insight_id: str
        :param insight_data: Insight data. Required.
        :type insight_data: IO
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Default value is "application/merge-patch+json".
        :paramtype content_type: str
        :return: JSON object
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200, 201
                response == {
                    "attachmentsLink": "str",  # Optional. Gets link for attachments.
                    "createdBy": "str",  # Optional. Created by user/tenant id.
                    "createdDateTime": "2020-02-20 00:00:00",  # Optional. Date-time when
                      resource was created, sample format: yyyy-MM-ddTHH:mm:ssZ.
                    "description": "str",  # Optional. Textual description of the resource.
                    "eTag": "str",  # Optional. The ETag value to implement optimistic
                      concurrency.
                    "id": "str",  # Optional. Id of the resource.
                    "insightEndDateTime": "2020-02-20 00:00:00",  # Optional. End date to which
                      the insight is related.
                    "insightStartDateTime": "2020-02-20 00:00:00",  # Optional. Start date to
                      which the insight is related.
                    "measurements": {
                        "str": {
                            "unit": "str",  # Optional. Data unit.
                            "value": 0.0  # Optional. Data value.
                        }
                    },
                    "modelId": "str",  # Optional. Id of the associated model.
                    "modelVersion": "str",  # Optional. Version of the associated model.
                    "modifiedBy": "str",  # Optional. Modified by user/tenant id.
                    "modifiedDateTime": "2020-02-20 00:00:00",  # Optional. Date-time when
                      resource was last modified, sample format: yyyy-MM-ddTHH:mm:ssZ.
                    "name": "str",  # Optional. Name to identify resource.
                    "partyId": "str",  # Optional. Id of the associated party.
                    "properties": {
                        "str": {}  # Optional. A collection of key value pairs that belongs
                          to the resource."nEach pair must not have a key greater than 50
                          characters"nand must not have a value greater than 150 characters."nNote: A
                          maximum of 25 key value pairs can be provided for a resource and"nonly
                          string, numeral and datetime (yyyy-MM-ddTHH:mm:ssZ) values are supported.
                    },
                    "resourceId": "str",  # Optional. Id of the associated resource.
                    "resourceType": "str",  # Optional. Resource type associated with the record.
                      Known values are: "Party", "Farm", "Field", "SeasonalField", and "Boundary".
                    "status": "str"  # Optional. Status of the resource.
                }
        """

    @distributed_trace
    def create_or_update(
        self,
        party_id: str,
        model_id: str,
        resource_type: str,
        resource_id: str,
        insight_id: str,
        insight_data: Union[JSON, IO],
        **kwargs: Any
    ) -> JSON:
        """Creates or updates insight entity.

        :param party_id: Id of the associated party. Required.
        :type party_id: str
        :param model_id: Id of the associated model.
         It can be either 'BiomassModelId', 'SensorPlacementModelId', 'SoilMoistureModelId' or any
         solution id. Required.
        :type model_id: str
        :param resource_type: Resource type associated with the record. Required.
        :type resource_type: str
        :param resource_id: Id of the associated resource. Required.
        :type resource_id: str
        :param insight_id: Id of the insight resource. Required.
        :type insight_id: str
        :param insight_data: Insight data. Is either a model type or a IO type. Required.
        :type insight_data: JSON or IO
        :keyword content_type: Body Parameter content-type. Known values are:
         'application/merge-patch+json'. Default value is None.
        :paramtype content_type: str
        :return: JSON object
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200, 201
                response == {
                    "attachmentsLink": "str",  # Optional. Gets link for attachments.
                    "createdBy": "str",  # Optional. Created by user/tenant id.
                    "createdDateTime": "2020-02-20 00:00:00",  # Optional. Date-time when
                      resource was created, sample format: yyyy-MM-ddTHH:mm:ssZ.
                    "description": "str",  # Optional. Textual description of the resource.
                    "eTag": "str",  # Optional. The ETag value to implement optimistic
                      concurrency.
                    "id": "str",  # Optional. Id of the resource.
                    "insightEndDateTime": "2020-02-20 00:00:00",  # Optional. End date to which
                      the insight is related.
                    "insightStartDateTime": "2020-02-20 00:00:00",  # Optional. Start date to
                      which the insight is related.
                    "measurements": {
                        "str": {
                            "unit": "str",  # Optional. Data unit.
                            "value": 0.0  # Optional. Data value.
                        }
                    },
                    "modelId": "str",  # Optional. Id of the associated model.
                    "modelVersion": "str",  # Optional. Version of the associated model.
                    "modifiedBy": "str",  # Optional. Modified by user/tenant id.
                    "modifiedDateTime": "2020-02-20 00:00:00",  # Optional. Date-time when
                      resource was last modified, sample format: yyyy-MM-ddTHH:mm:ssZ.
                    "name": "str",  # Optional. Name to identify resource.
                    "partyId": "str",  # Optional. Id of the associated party.
                    "properties": {
                        "str": {}  # Optional. A collection of key value pairs that belongs
                          to the resource."nEach pair must not have a key greater than 50
                          characters"nand must not have a value greater than 150 characters."nNote: A
                          maximum of 25 key value pairs can be provided for a resource and"nonly
                          string, numeral and datetime (yyyy-MM-ddTHH:mm:ssZ) values are supported.
                    },
                    "resourceId": "str",  # Optional. Id of the associated resource.
                    "resourceType": "str",  # Optional. Resource type associated with the record.
                      Known values are: "Party", "Farm", "Field", "SeasonalField", and "Boundary".
                    "status": "str"  # Optional. Status of the resource.
                }
        """
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type = kwargs.pop("content_type", _headers.pop("Content-Type", None))  # type: Optional[str]
        cls = kwargs.pop("cls", None)  # type: ClsType[JSON]

        content_type = content_type or "application/merge-patch+json"
        _json = None
        _content = None
        if isinstance(insight_data, (IO, bytes)):
            _content = insight_data
        else:
            _json = insight_data

        request = build_insights_create_or_update_request(
            party_id=party_id,
            model_id=model_id,
            resource_type=resource_type,
            resource_id=resource_id,
            insight_id=insight_id,
            content_type=content_type,
            api_version=self._config.api_version,
            json=_json,
            content=_content,
            headers=_headers,
            params=_params,
        )
        request.url = self._client.format_url(request.url)  # type: ignore

        pipeline_response = self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
            request, stream=False, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200, 201]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if response.status_code == 200:
            if response.content:
                deserialized = response.json()
            else:
                deserialized = None

        if response.status_code == 201:
            if response.content:
                deserialized = response.json()
            else:
                deserialized = None

        if cls:
            return cls(pipeline_response, cast(JSON, deserialized), {})

        return cast(JSON, deserialized)

    @distributed_trace
    def get(
        self, party_id: str, model_id: str, resource_type: str, resource_id: str, insight_id: str, **kwargs: Any
    ) -> JSON:
        """Gets a specified insight resource under a particular party.

        :param party_id: Id of the associated party. Required.
        :type party_id: str
        :param model_id: Id of the associated model.
         It can be either 'BiomassModelId', 'SensorPlacementModelId', 'SoilMoistureModelId' or any
         solution id. Required.
        :type model_id: str
        :param resource_type: Resource type associated with the record. Required.
        :type resource_type: str
        :param resource_id: Id of the associated resource. Required.
        :type resource_id: str
        :param insight_id: Id of the insight resource. Required.
        :type insight_id: str
        :return: JSON object
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "attachmentsLink": "str",  # Optional. Gets link for attachments.
                    "createdBy": "str",  # Optional. Created by user/tenant id.
                    "createdDateTime": "2020-02-20 00:00:00",  # Optional. Date-time when
                      resource was created, sample format: yyyy-MM-ddTHH:mm:ssZ.
                    "description": "str",  # Optional. Textual description of the resource.
                    "eTag": "str",  # Optional. The ETag value to implement optimistic
                      concurrency.
                    "id": "str",  # Optional. Id of the resource.
                    "insightEndDateTime": "2020-02-20 00:00:00",  # Optional. End date to which
                      the insight is related.
                    "insightStartDateTime": "2020-02-20 00:00:00",  # Optional. Start date to
                      which the insight is related.
                    "measurements": {
                        "str": {
                            "unit": "str",  # Optional. Data unit.
                            "value": 0.0  # Optional. Data value.
                        }
                    },
                    "modelId": "str",  # Optional. Id of the associated model.
                    "modelVersion": "str",  # Optional. Version of the associated model.
                    "modifiedBy": "str",  # Optional. Modified by user/tenant id.
                    "modifiedDateTime": "2020-02-20 00:00:00",  # Optional. Date-time when
                      resource was last modified, sample format: yyyy-MM-ddTHH:mm:ssZ.
                    "name": "str",  # Optional. Name to identify resource.
                    "partyId": "str",  # Optional. Id of the associated party.
                    "properties": {
                        "str": {}  # Optional. A collection of key value pairs that belongs
                          to the resource."nEach pair must not have a key greater than 50
                          characters"nand must not have a value greater than 150 characters."nNote: A
                          maximum of 25 key value pairs can be provided for a resource and"nonly
                          string, numeral and datetime (yyyy-MM-ddTHH:mm:ssZ) values are supported.
                    },
                    "resourceId": "str",  # Optional. Id of the associated resource.
                    "resourceType": "str",  # Optional. Resource type associated with the record.
                      Known values are: "Party", "Farm", "Field", "SeasonalField", and "Boundary".
                    "status": "str"  # Optional. Status of the resource.
                }
        """
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls = kwargs.pop("cls", None)  # type: ClsType[JSON]

        request = build_insights_get_request(
            party_id=party_id,
            model_id=model_id,
            resource_type=resource_type,
            resource_id=resource_id,
            insight_id=insight_id,
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        request.url = self._client.format_url(request.url)  # type: ignore

        pipeline_response = self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
            request, stream=False, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if response.content:
            deserialized = response.json()
        else:
            deserialized = None

        if cls:
            return cls(pipeline_response, cast(JSON, deserialized), {})

        return cast(JSON, deserialized)

    @distributed_trace
    def delete(  # pylint: disable=inconsistent-return-statements
        self, party_id: str, model_id: str, resource_type: str, resource_id: str, insight_id: str, **kwargs: Any
    ) -> None:
        """Deletes a specified insight resource.

        :param party_id: Id of the associated party. Required.
        :type party_id: str
        :param model_id: Id of the associated model.
         It can be either 'BiomassModelId', 'SensorPlacementModelId', 'SoilMoistureModelId' or any
         solution id. Required.
        :type model_id: str
        :param resource_type: Resource type associated with the record. Required.
        :type resource_type: str
        :param resource_id: Id of the associated resource. Required.
        :type resource_id: str
        :param insight_id: Id of the insight resource. Required.
        :type insight_id: str
        :return: None
        :rtype: None
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls = kwargs.pop("cls", None)  # type: ClsType[None]

        request = build_insights_delete_request(
            party_id=party_id,
            model_id=model_id,
            resource_type=resource_type,
            resource_id=resource_id,
            insight_id=insight_id,
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        request.url = self._client.format_url(request.url)  # type: ignore

        pipeline_response = self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
            request, stream=False, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [204]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if cls:
            return cls(pipeline_response, None, {})


class ManagementZonesOperations:
    """
    .. warning::
        **DO NOT** instantiate this class directly.

        Instead, you should access the following operations through
        :class:`~azure.agrifood.farming.FarmBeatsClient`'s
        :attr:`management_zones` attribute.
    """

    def __init__(self, *args, **kwargs):
        input_args = list(args)
        self._client = input_args.pop(0) if input_args else kwargs.pop("client")
        self._config = input_args.pop(0) if input_args else kwargs.pop("config")
        self._serialize = input_args.pop(0) if input_args else kwargs.pop("serializer")
        self._deserialize = input_args.pop(0) if input_args else kwargs.pop("deserializer")

    @distributed_trace
    def list(
        self,
        *,
        types: Optional[List[str]] = None,
        crop_ids: Optional[List[str]] = None,
        season_ids: Optional[List[str]] = None,
        field_ids: Optional[List[str]] = None,
        sources: Optional[List[str]] = None,
        ids: Optional[List[str]] = None,
        names: Optional[List[str]] = None,
        property_filters: Optional[List[str]] = None,
        statuses: Optional[List[str]] = None,
        min_created_date_time: Optional[datetime.datetime] = None,
        max_created_date_time: Optional[datetime.datetime] = None,
        min_last_modified_date_time: Optional[datetime.datetime] = None,
        max_last_modified_date_time: Optional[datetime.datetime] = None,
        skip_token: Optional[str] = None,
        **kwargs: Any
    ) -> Iterable[JSON]:
        """Returns a paginated list of management zone resources across all parties.

        :keyword types: Types of the ManagementZone. Default value is None.
        :paramtype types: list[str]
        :keyword crop_ids: CropIds of the ManagementZone. Default value is None.
        :paramtype crop_ids: list[str]
        :keyword season_ids: SeasonIds of the ManagementZone. Default value is None.
        :paramtype season_ids: list[str]
        :keyword field_ids: FieldIds of the ManagementZone. Default value is None.
        :paramtype field_ids: list[str]
        :keyword sources: Sources of the ManagementZone. Default value is None.
        :paramtype sources: list[str]
        :keyword ids: Ids of the resource. Default value is None.
        :paramtype ids: list[str]
        :keyword names: Names of the resource. Default value is None.
        :paramtype names: list[str]
        :keyword property_filters: Filters on key-value pairs within the Properties object.
         eg. "{testKey} eq {testValue}". Default value is None.
        :paramtype property_filters: list[str]
        :keyword statuses: Statuses of the resource. Default value is None.
        :paramtype statuses: list[str]
        :keyword min_created_date_time: Minimum creation date of resource (inclusive). Default value is
         None.
        :paramtype min_created_date_time: ~datetime.datetime
        :keyword max_created_date_time: Maximum creation date of resource (inclusive). Default value is
         None.
        :paramtype max_created_date_time: ~datetime.datetime
        :keyword min_last_modified_date_time: Minimum last modified date of resource (inclusive).
         Default value is None.
        :paramtype min_last_modified_date_time: ~datetime.datetime
        :keyword max_last_modified_date_time: Maximum last modified date of resource (inclusive).
         Default value is None.
        :paramtype max_last_modified_date_time: ~datetime.datetime
        :keyword skip_token: Skip token for getting next set of results. Default value is None.
        :paramtype skip_token: str
        :return: An iterator like instance of JSON object
        :rtype: ~azure.core.paging.ItemPaged[JSON]
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "createdBy": "str",  # Optional. Created by user/tenant id.
                    "createdDateTime": "2020-02-20 00:00:00",  # Optional. Date-time when
                      resource was created, sample format: yyyy-MM-ddTHH:mm:ssZ.
                    "cropId": "str",  # Optional. Crop Id associated with the ManagementZone.
                    "description": "str",  # Optional. Textual description of the resource.
                    "eTag": "str",  # Optional. The ETag value to implement optimistic
                      concurrency.
                    "fieldId": "str",  # Optional. Field Id associated with the ManagementZone.
                    "id": "str",  # Optional. Unique resource ID.
                    "modifiedBy": "str",  # Optional. Modified by user/tenant id.
                    "modifiedDateTime": "2020-02-20 00:00:00",  # Optional. Date-time when
                      resource was last modified, sample format: yyyy-MM-ddTHH:mm:ssZ.
                    "name": "str",  # Optional. Name to identify resource.
                    "partyId": "str",  # Optional. Party Id associated with the ManagementZone.
                    "properties": {
                        "str": {}  # Optional. A collection of key value pairs that belongs
                          to the resource."nEach pair must not have a key greater than 50
                          characters"nand must not have a value greater than 150 characters."nNote: A
                          maximum of 25 key value pairs can be provided for a resource and only
                          string,"nnumeral and datetime (yyyy-MM-ddTHH:mm:ssZ) values are supported.
                    },
                    "seasonId": "str",  # Optional. Season Id associated with the ManagementZone.
                    "source": "str",  # Optional. Source of the resource.
                    "status": "str",  # Optional. Status of the resource.
                    "type": "str"  # Optional. Type of the ManagementZone.
                }
        """
        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls = kwargs.pop("cls", None)  # type: ClsType[JSON]

        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        def prepare_request(next_link=None):
            if not next_link:

                request = build_management_zones_list_request(
                    types=types,
                    crop_ids=crop_ids,
                    season_ids=season_ids,
                    field_ids=field_ids,
                    sources=sources,
                    ids=ids,
                    names=names,
                    property_filters=property_filters,
                    statuses=statuses,
                    min_created_date_time=min_created_date_time,
                    max_created_date_time=max_created_date_time,
                    min_last_modified_date_time=min_last_modified_date_time,
                    max_last_modified_date_time=max_last_modified_date_time,
                    skip_token=skip_token,
                    api_version=self._config.api_version,
                    headers=_headers,
                    params=_params,
                )
                request.url = self._client.format_url(request.url)  # type: ignore

            else:
                # make call to next link with the client's api-version
                _parsed_next_link = urlparse(next_link)
                _next_request_params = case_insensitive_dict(parse_qs(_parsed_next_link.query))
                _next_request_params["api-version"] = self._config.api_version
                request = HttpRequest("GET", urljoin(next_link, _parsed_next_link.path), params=_next_request_params)
                request.url = self._client.format_url(request.url)  # type: ignore

            return request

        def extract_data(pipeline_response):
            deserialized = pipeline_response.http_response.json()
            list_of_elem = deserialized["value"]
            if cls:
                list_of_elem = cls(list_of_elem)
            return deserialized.get("nextLink", None), iter(list_of_elem)

        def get_next(next_link=None):
            request = prepare_request(next_link)

            pipeline_response = self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
                request, stream=False, **kwargs
            )
            response = pipeline_response.http_response

            if response.status_code not in [200]:
                map_error(status_code=response.status_code, response=response, error_map=error_map)
                raise HttpResponseError(response=response)

            return pipeline_response

        return ItemPaged(get_next, extract_data)

    @distributed_trace
    def get_cascade_delete_job_details(self, job_id: str, **kwargs: Any) -> JSON:
        """Get a cascade delete job for specified job id.

        :param job_id: Id of the job. Required.
        :type job_id: str
        :return: JSON object
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "partyId": "str",  # Party Id. Required.
                    "resourceId": "str",  # The id of the resource. Required.
                    "resourceType": "str",  # The type of the resource. Required.
                    "createdDateTime": "2020-02-20 00:00:00",  # Optional. Job created at
                      dateTime. Sample format: yyyy-MM-ddTHH:mm:ssZ.
                    "durationInSeconds": 0.0,  # Optional. Duration of the job in seconds.
                    "endTime": "2020-02-20 00:00:00",  # Optional. Job end time when available.
                      Sample format: yyyy-MM-ddTHH:mm:ssZ.
                    "errorCode": "str",  # Optional. Error Code when job failed.
                    "id": "str",  # Optional. Unique job id.
                    "lastActionDateTime": "2020-02-20 00:00:00",  # Optional. Job was last acted
                      upon at dateTime. Sample format: yyyy-MM-ddTHH:mm:ssZ.
                    "message": "str",  # Optional. Status message to capture more details of the
                      job.
                    "startTime": "2020-02-20 00:00:00",  # Optional. Job start time when
                      available. Sample format: yyyy-MM-ddTHH:mm:ssZ.
                    "status": "str"  # Optional. Status of the job."nPossible values: 'Waiting',
                      'Running', 'Succeeded', 'Failed', 'Cancelled'. Known values are: "Waiting",
                      "Running", "Succeeded", "Failed", and "Cancelled".
                }
        """
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls = kwargs.pop("cls", None)  # type: ClsType[JSON]

        request = build_management_zones_get_cascade_delete_job_details_request(
            job_id=job_id,
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        request.url = self._client.format_url(request.url)  # type: ignore

        pipeline_response = self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
            request, stream=False, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if response.content:
            deserialized = response.json()
        else:
            deserialized = None

        if cls:
            return cls(pipeline_response, cast(JSON, deserialized), {})

        return cast(JSON, deserialized)

    def _create_cascade_delete_job_initial(
        self, job_id: str, *, party_id: str, management_zone_id: str, **kwargs: Any
    ) -> JSON:
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls = kwargs.pop("cls", None)  # type: ClsType[JSON]

        request = build_management_zones_create_cascade_delete_job_request(
            job_id=job_id,
            party_id=party_id,
            management_zone_id=management_zone_id,
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        request.url = self._client.format_url(request.url)  # type: ignore

        pipeline_response = self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
            request, stream=False, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [202]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if response.content:
            deserialized = response.json()
        else:
            deserialized = None

        if cls:
            return cls(pipeline_response, cast(JSON, deserialized), {})

        return cast(JSON, deserialized)

    @distributed_trace
    def begin_create_cascade_delete_job(
        self, job_id: str, *, party_id: str, management_zone_id: str, **kwargs: Any
    ) -> LROPoller[JSON]:
        """Create a cascade delete job for specified management zone.

        :param job_id: Job ID supplied by end user. Required.
        :type job_id: str
        :keyword party_id: ID of the associated party. Required.
        :paramtype party_id: str
        :keyword management_zone_id: ID of the management zone to be deleted. Required.
        :paramtype management_zone_id: str
        :keyword str continuation_token: A continuation token to restart a poller from a saved state.
        :keyword polling: By default, your polling method will be LROBasePolling. Pass in False for
         this operation to not poll, or pass in your own initialized polling object for a personal
         polling strategy.
        :paramtype polling: bool or ~azure.core.polling.PollingMethod
        :keyword int polling_interval: Default waiting time between two polls for LRO operations if no
         Retry-After header is present.
        :return: An instance of LROPoller that returns JSON object
        :rtype: ~azure.core.polling.LROPoller[JSON]
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 202
                response == {
                    "partyId": "str",  # Party Id. Required.
                    "resourceId": "str",  # The id of the resource. Required.
                    "resourceType": "str",  # The type of the resource. Required.
                    "createdDateTime": "2020-02-20 00:00:00",  # Optional. Job created at
                      dateTime. Sample format: yyyy-MM-ddTHH:mm:ssZ.
                    "durationInSeconds": 0.0,  # Optional. Duration of the job in seconds.
                    "endTime": "2020-02-20 00:00:00",  # Optional. Job end time when available.
                      Sample format: yyyy-MM-ddTHH:mm:ssZ.
                    "errorCode": "str",  # Optional. Error Code when job failed.
                    "id": "str",  # Optional. Unique job id.
                    "lastActionDateTime": "2020-02-20 00:00:00",  # Optional. Job was last acted
                      upon at dateTime. Sample format: yyyy-MM-ddTHH:mm:ssZ.
                    "message": "str",  # Optional. Status message to capture more details of the
                      job.
                    "startTime": "2020-02-20 00:00:00",  # Optional. Job start time when
                      available. Sample format: yyyy-MM-ddTHH:mm:ssZ.
                    "status": "str"  # Optional. Status of the job."nPossible values: 'Waiting',
                      'Running', 'Succeeded', 'Failed', 'Cancelled'. Known values are: "Waiting",
                      "Running", "Succeeded", "Failed", and "Cancelled".
                }
        """
        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls = kwargs.pop("cls", None)  # type: ClsType[JSON]
        polling = kwargs.pop("polling", True)  # type: Union[bool, PollingMethod]
        lro_delay = kwargs.pop("polling_interval", self._config.polling_interval)
        cont_token = kwargs.pop("continuation_token", None)  # type: Optional[str]
        if cont_token is None:
            raw_result = self._create_cascade_delete_job_initial(  # type: ignore
                job_id=job_id,
                party_id=party_id,
                management_zone_id=management_zone_id,
                cls=lambda x, y, z: x,
                headers=_headers,
                params=_params,
                **kwargs
            )
        kwargs.pop("error_map", None)

        def get_long_running_output(pipeline_response):
            response = pipeline_response.http_response
            if response.content:
                deserialized = response.json()
            else:
                deserialized = None
            if cls:
                return cls(pipeline_response, deserialized, {})
            return deserialized

        if polling is True:
            polling_method = cast(
                PollingMethod, LROBasePolling(lro_delay, lro_options={"final-state-via": "location"}, **kwargs)
            )  # type: PollingMethod
        elif polling is False:
            polling_method = cast(PollingMethod, NoPolling())
        else:
            polling_method = polling
        if cont_token:
            return LROPoller.from_continuation_token(
                polling_method=polling_method,
                continuation_token=cont_token,
                client=self._client,
                deserialization_callback=get_long_running_output,
            )
        return LROPoller(self._client, raw_result, get_long_running_output, polling_method)

    @distributed_trace
    def list_by_party_id(
        self,
        party_id: str,
        *,
        types: Optional[List[str]] = None,
        crop_ids: Optional[List[str]] = None,
        season_ids: Optional[List[str]] = None,
        field_ids: Optional[List[str]] = None,
        sources: Optional[List[str]] = None,
        ids: Optional[List[str]] = None,
        names: Optional[List[str]] = None,
        property_filters: Optional[List[str]] = None,
        statuses: Optional[List[str]] = None,
        min_created_date_time: Optional[datetime.datetime] = None,
        max_created_date_time: Optional[datetime.datetime] = None,
        min_last_modified_date_time: Optional[datetime.datetime] = None,
        max_last_modified_date_time: Optional[datetime.datetime] = None,
        skip_token: Optional[str] = None,
        **kwargs: Any
    ) -> Iterable[JSON]:
        """Returns a paginated list of management zone resources under a particular party.

        :param party_id: Id of the associated party. Required.
        :type party_id: str
        :keyword types: Types of the ManagementZone. Default value is None.
        :paramtype types: list[str]
        :keyword crop_ids: CropIds of the ManagementZone. Default value is None.
        :paramtype crop_ids: list[str]
        :keyword season_ids: SeasonIds of the ManagementZone. Default value is None.
        :paramtype season_ids: list[str]
        :keyword field_ids: FieldIds of the ManagementZone. Default value is None.
        :paramtype field_ids: list[str]
        :keyword sources: Sources of the ManagementZone. Default value is None.
        :paramtype sources: list[str]
        :keyword ids: Ids of the resource. Default value is None.
        :paramtype ids: list[str]
        :keyword names: Names of the resource. Default value is None.
        :paramtype names: list[str]
        :keyword property_filters: Filters on key-value pairs within the Properties object.
         eg. "{testKey} eq {testValue}". Default value is None.
        :paramtype property_filters: list[str]
        :keyword statuses: Statuses of the resource. Default value is None.
        :paramtype statuses: list[str]
        :keyword min_created_date_time: Minimum creation date of resource (inclusive). Default value is
         None.
        :paramtype min_created_date_time: ~datetime.datetime
        :keyword max_created_date_time: Maximum creation date of resource (inclusive). Default value is
         None.
        :paramtype max_created_date_time: ~datetime.datetime
        :keyword min_last_modified_date_time: Minimum last modified date of resource (inclusive).
         Default value is None.
        :paramtype min_last_modified_date_time: ~datetime.datetime
        :keyword max_last_modified_date_time: Maximum last modified date of resource (inclusive).
         Default value is None.
        :paramtype max_last_modified_date_time: ~datetime.datetime
        :keyword skip_token: Skip token for getting next set of results. Default value is None.
        :paramtype skip_token: str
        :return: An iterator like instance of JSON object
        :rtype: ~azure.core.paging.ItemPaged[JSON]
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "createdBy": "str",  # Optional. Created by user/tenant id.
                    "createdDateTime": "2020-02-20 00:00:00",  # Optional. Date-time when
                      resource was created, sample format: yyyy-MM-ddTHH:mm:ssZ.
                    "cropId": "str",  # Optional. Crop Id associated with the ManagementZone.
                    "description": "str",  # Optional. Textual description of the resource.
                    "eTag": "str",  # Optional. The ETag value to implement optimistic
                      concurrency.
                    "fieldId": "str",  # Optional. Field Id associated with the ManagementZone.
                    "id": "str",  # Optional. Unique resource ID.
                    "modifiedBy": "str",  # Optional. Modified by user/tenant id.
                    "modifiedDateTime": "2020-02-20 00:00:00",  # Optional. Date-time when
                      resource was last modified, sample format: yyyy-MM-ddTHH:mm:ssZ.
                    "name": "str",  # Optional. Name to identify resource.
                    "partyId": "str",  # Optional. Party Id associated with the ManagementZone.
                    "properties": {
                        "str": {}  # Optional. A collection of key value pairs that belongs
                          to the resource."nEach pair must not have a key greater than 50
                          characters"nand must not have a value greater than 150 characters."nNote: A
                          maximum of 25 key value pairs can be provided for a resource and only
                          string,"nnumeral and datetime (yyyy-MM-ddTHH:mm:ssZ) values are supported.
                    },
                    "seasonId": "str",  # Optional. Season Id associated with the ManagementZone.
                    "source": "str",  # Optional. Source of the resource.
                    "status": "str",  # Optional. Status of the resource.
                    "type": "str"  # Optional. Type of the ManagementZone.
                }
        """
        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls = kwargs.pop("cls", None)  # type: ClsType[JSON]

        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        def prepare_request(next_link=None):
            if not next_link:

                request = build_management_zones_list_by_party_id_request(
                    party_id=party_id,
                    types=types,
                    crop_ids=crop_ids,
                    season_ids=season_ids,
                    field_ids=field_ids,
                    sources=sources,
                    ids=ids,
                    names=names,
                    property_filters=property_filters,
                    statuses=statuses,
                    min_created_date_time=min_created_date_time,
                    max_created_date_time=max_created_date_time,
                    min_last_modified_date_time=min_last_modified_date_time,
                    max_last_modified_date_time=max_last_modified_date_time,
                    skip_token=skip_token,
                    api_version=self._config.api_version,
                    headers=_headers,
                    params=_params,
                )
                request.url = self._client.format_url(request.url)  # type: ignore

            else:
                # make call to next link with the client's api-version
                _parsed_next_link = urlparse(next_link)
                _next_request_params = case_insensitive_dict(parse_qs(_parsed_next_link.query))
                _next_request_params["api-version"] = self._config.api_version
                request = HttpRequest("GET", urljoin(next_link, _parsed_next_link.path), params=_next_request_params)
                request.url = self._client.format_url(request.url)  # type: ignore

            return request

        def extract_data(pipeline_response):
            deserialized = pipeline_response.http_response.json()
            list_of_elem = deserialized["value"]
            if cls:
                list_of_elem = cls(list_of_elem)
            return deserialized.get("nextLink", None), iter(list_of_elem)

        def get_next(next_link=None):
            request = prepare_request(next_link)

            pipeline_response = self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
                request, stream=False, **kwargs
            )
            response = pipeline_response.http_response

            if response.status_code not in [200]:
                map_error(status_code=response.status_code, response=response, error_map=error_map)
                raise HttpResponseError(response=response)

            return pipeline_response

        return ItemPaged(get_next, extract_data)

    @distributed_trace
    def get(self, party_id: str, management_zone_id: str, **kwargs: Any) -> JSON:
        """Gets a specified management zone resource under a particular party.

        :param party_id: Id of the associated party. Required.
        :type party_id: str
        :param management_zone_id: Id of the management zone. Required.
        :type management_zone_id: str
        :return: JSON object
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "createdBy": "str",  # Optional. Created by user/tenant id.
                    "createdDateTime": "2020-02-20 00:00:00",  # Optional. Date-time when
                      resource was created, sample format: yyyy-MM-ddTHH:mm:ssZ.
                    "cropId": "str",  # Optional. Crop Id associated with the ManagementZone.
                    "description": "str",  # Optional. Textual description of the resource.
                    "eTag": "str",  # Optional. The ETag value to implement optimistic
                      concurrency.
                    "fieldId": "str",  # Optional. Field Id associated with the ManagementZone.
                    "id": "str",  # Optional. Unique resource ID.
                    "modifiedBy": "str",  # Optional. Modified by user/tenant id.
                    "modifiedDateTime": "2020-02-20 00:00:00",  # Optional. Date-time when
                      resource was last modified, sample format: yyyy-MM-ddTHH:mm:ssZ.
                    "name": "str",  # Optional. Name to identify resource.
                    "partyId": "str",  # Optional. Party Id associated with the ManagementZone.
                    "properties": {
                        "str": {}  # Optional. A collection of key value pairs that belongs
                          to the resource."nEach pair must not have a key greater than 50
                          characters"nand must not have a value greater than 150 characters."nNote: A
                          maximum of 25 key value pairs can be provided for a resource and only
                          string,"nnumeral and datetime (yyyy-MM-ddTHH:mm:ssZ) values are supported.
                    },
                    "seasonId": "str",  # Optional. Season Id associated with the ManagementZone.
                    "source": "str",  # Optional. Source of the resource.
                    "status": "str",  # Optional. Status of the resource.
                    "type": "str"  # Optional. Type of the ManagementZone.
                }
        """
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls = kwargs.pop("cls", None)  # type: ClsType[JSON]

        request = build_management_zones_get_request(
            party_id=party_id,
            management_zone_id=management_zone_id,
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        request.url = self._client.format_url(request.url)  # type: ignore

        pipeline_response = self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
            request, stream=False, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if response.content:
            deserialized = response.json()
        else:
            deserialized = None

        if cls:
            return cls(pipeline_response, cast(JSON, deserialized), {})

        return cast(JSON, deserialized)

    @overload
    def create_or_update(
        self,
        party_id: str,
        management_zone_id: str,
        management_zone: JSON,
        *,
        content_type: str = "application/merge-patch+json",
        **kwargs: Any
    ) -> JSON:
        """Creates or updates a management zone resource.

        :param party_id: Id of the party resource. Required.
        :type party_id: str
        :param management_zone_id: Id of the management zone resource. Required.
        :type management_zone_id: str
        :param management_zone: ManagementZone resource payload to create or update. Required.
        :type management_zone: JSON
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/merge-patch+json".
        :paramtype content_type: str
        :return: JSON object
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                management_zone = {
                    "createdBy": "str",  # Optional. Created by user/tenant id.
                    "createdDateTime": "2020-02-20 00:00:00",  # Optional. Date-time when
                      resource was created, sample format: yyyy-MM-ddTHH:mm:ssZ.
                    "cropId": "str",  # Optional. Crop Id associated with the ManagementZone.
                    "description": "str",  # Optional. Textual description of the resource.
                    "eTag": "str",  # Optional. The ETag value to implement optimistic
                      concurrency.
                    "fieldId": "str",  # Optional. Field Id associated with the ManagementZone.
                    "id": "str",  # Optional. Unique resource ID.
                    "modifiedBy": "str",  # Optional. Modified by user/tenant id.
                    "modifiedDateTime": "2020-02-20 00:00:00",  # Optional. Date-time when
                      resource was last modified, sample format: yyyy-MM-ddTHH:mm:ssZ.
                    "name": "str",  # Optional. Name to identify resource.
                    "partyId": "str",  # Optional. Party Id associated with the ManagementZone.
                    "properties": {
                        "str": {}  # Optional. A collection of key value pairs that belongs
                          to the resource."nEach pair must not have a key greater than 50
                          characters"nand must not have a value greater than 150 characters."nNote: A
                          maximum of 25 key value pairs can be provided for a resource and only
                          string,"nnumeral and datetime (yyyy-MM-ddTHH:mm:ssZ) values are supported.
                    },
                    "seasonId": "str",  # Optional. Season Id associated with the ManagementZone.
                    "source": "str",  # Optional. Source of the resource.
                    "status": "str",  # Optional. Status of the resource.
                    "type": "str"  # Optional. Type of the ManagementZone.
                }

                # response body for status code(s): 200, 201
                response == {
                    "createdBy": "str",  # Optional. Created by user/tenant id.
                    "createdDateTime": "2020-02-20 00:00:00",  # Optional. Date-time when
                      resource was created, sample format: yyyy-MM-ddTHH:mm:ssZ.
                    "cropId": "str",  # Optional. Crop Id associated with the ManagementZone.
                    "description": "str",  # Optional. Textual description of the resource.
                    "eTag": "str",  # Optional. The ETag value to implement optimistic
                      concurrency.
                    "fieldId": "str",  # Optional. Field Id associated with the ManagementZone.
                    "id": "str",  # Optional. Unique resource ID.
                    "modifiedBy": "str",  # Optional. Modified by user/tenant id.
                    "modifiedDateTime": "2020-02-20 00:00:00",  # Optional. Date-time when
                      resource was last modified, sample format: yyyy-MM-ddTHH:mm:ssZ.
                    "name": "str",  # Optional. Name to identify resource.
                    "partyId": "str",  # Optional. Party Id associated with the ManagementZone.
                    "properties": {
                        "str": {}  # Optional. A collection of key value pairs that belongs
                          to the resource."nEach pair must not have a key greater than 50
                          characters"nand must not have a value greater than 150 characters."nNote: A
                          maximum of 25 key value pairs can be provided for a resource and only
                          string,"nnumeral and datetime (yyyy-MM-ddTHH:mm:ssZ) values are supported.
                    },
                    "seasonId": "str",  # Optional. Season Id associated with the ManagementZone.
                    "source": "str",  # Optional. Source of the resource.
                    "status": "str",  # Optional. Status of the resource.
                    "type": "str"  # Optional. Type of the ManagementZone.
                }
        """

    @overload
    def create_or_update(
        self,
        party_id: str,
        management_zone_id: str,
        management_zone: IO,
        *,
        content_type: str = "application/merge-patch+json",
        **kwargs: Any
    ) -> JSON:
        """Creates or updates a management zone resource.

        :param party_id: Id of the party resource. Required.
        :type party_id: str
        :param management_zone_id: Id of the management zone resource. Required.
        :type management_zone_id: str
        :param management_zone: ManagementZone resource payload to create or update. Required.
        :type management_zone: IO
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Default value is "application/merge-patch+json".
        :paramtype content_type: str
        :return: JSON object
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200, 201
                response == {
                    "createdBy": "str",  # Optional. Created by user/tenant id.
                    "createdDateTime": "2020-02-20 00:00:00",  # Optional. Date-time when
                      resource was created, sample format: yyyy-MM-ddTHH:mm:ssZ.
                    "cropId": "str",  # Optional. Crop Id associated with the ManagementZone.
                    "description": "str",  # Optional. Textual description of the resource.
                    "eTag": "str",  # Optional. The ETag value to implement optimistic
                      concurrency.
                    "fieldId": "str",  # Optional. Field Id associated with the ManagementZone.
                    "id": "str",  # Optional. Unique resource ID.
                    "modifiedBy": "str",  # Optional. Modified by user/tenant id.
                    "modifiedDateTime": "2020-02-20 00:00:00",  # Optional. Date-time when
                      resource was last modified, sample format: yyyy-MM-ddTHH:mm:ssZ.
                    "name": "str",  # Optional. Name to identify resource.
                    "partyId": "str",  # Optional. Party Id associated with the ManagementZone.
                    "properties": {
                        "str": {}  # Optional. A collection of key value pairs that belongs
                          to the resource."nEach pair must not have a key greater than 50
                          characters"nand must not have a value greater than 150 characters."nNote: A
                          maximum of 25 key value pairs can be provided for a resource and only
                          string,"nnumeral and datetime (yyyy-MM-ddTHH:mm:ssZ) values are supported.
                    },
                    "seasonId": "str",  # Optional. Season Id associated with the ManagementZone.
                    "source": "str",  # Optional. Source of the resource.
                    "status": "str",  # Optional. Status of the resource.
                    "type": "str"  # Optional. Type of the ManagementZone.
                }
        """

    @distributed_trace
    def create_or_update(
        self, party_id: str, management_zone_id: str, management_zone: Union[JSON, IO], **kwargs: Any
    ) -> JSON:
        """Creates or updates a management zone resource.

        :param party_id: Id of the party resource. Required.
        :type party_id: str
        :param management_zone_id: Id of the management zone resource. Required.
        :type management_zone_id: str
        :param management_zone: ManagementZone resource payload to create or update. Is either a model
         type or a IO type. Required.
        :type management_zone: JSON or IO
        :keyword content_type: Body Parameter content-type. Known values are:
         'application/merge-patch+json'. Default value is None.
        :paramtype content_type: str
        :return: JSON object
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200, 201
                response == {
                    "createdBy": "str",  # Optional. Created by user/tenant id.
                    "createdDateTime": "2020-02-20 00:00:00",  # Optional. Date-time when
                      resource was created, sample format: yyyy-MM-ddTHH:mm:ssZ.
                    "cropId": "str",  # Optional. Crop Id associated with the ManagementZone.
                    "description": "str",  # Optional. Textual description of the resource.
                    "eTag": "str",  # Optional. The ETag value to implement optimistic
                      concurrency.
                    "fieldId": "str",  # Optional. Field Id associated with the ManagementZone.
                    "id": "str",  # Optional. Unique resource ID.
                    "modifiedBy": "str",  # Optional. Modified by user/tenant id.
                    "modifiedDateTime": "2020-02-20 00:00:00",  # Optional. Date-time when
                      resource was last modified, sample format: yyyy-MM-ddTHH:mm:ssZ.
                    "name": "str",  # Optional. Name to identify resource.
                    "partyId": "str",  # Optional. Party Id associated with the ManagementZone.
                    "properties": {
                        "str": {}  # Optional. A collection of key value pairs that belongs
                          to the resource."nEach pair must not have a key greater than 50
                          characters"nand must not have a value greater than 150 characters."nNote: A
                          maximum of 25 key value pairs can be provided for a resource and only
                          string,"nnumeral and datetime (yyyy-MM-ddTHH:mm:ssZ) values are supported.
                    },
                    "seasonId": "str",  # Optional. Season Id associated with the ManagementZone.
                    "source": "str",  # Optional. Source of the resource.
                    "status": "str",  # Optional. Status of the resource.
                    "type": "str"  # Optional. Type of the ManagementZone.
                }
        """
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type = kwargs.pop("content_type", _headers.pop("Content-Type", None))  # type: Optional[str]
        cls = kwargs.pop("cls", None)  # type: ClsType[JSON]

        content_type = content_type or "application/merge-patch+json"
        _json = None
        _content = None
        if isinstance(management_zone, (IO, bytes)):
            _content = management_zone
        else:
            _json = management_zone

        request = build_management_zones_create_or_update_request(
            party_id=party_id,
            management_zone_id=management_zone_id,
            content_type=content_type,
            api_version=self._config.api_version,
            json=_json,
            content=_content,
            headers=_headers,
            params=_params,
        )
        request.url = self._client.format_url(request.url)  # type: ignore

        pipeline_response = self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
            request, stream=False, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200, 201]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if response.status_code == 200:
            if response.content:
                deserialized = response.json()
            else:
                deserialized = None

        if response.status_code == 201:
            if response.content:
                deserialized = response.json()
            else:
                deserialized = None

        if cls:
            return cls(pipeline_response, cast(JSON, deserialized), {})

        return cast(JSON, deserialized)

    @distributed_trace
    def delete(  # pylint: disable=inconsistent-return-statements
        self, party_id: str, management_zone_id: str, **kwargs: Any
    ) -> None:
        """Deletes a specified management zone resource under a particular party.

        :param party_id: Id of the party. Required.
        :type party_id: str
        :param management_zone_id: Id of the management zone. Required.
        :type management_zone_id: str
        :return: None
        :rtype: None
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls = kwargs.pop("cls", None)  # type: ClsType[None]

        request = build_management_zones_delete_request(
            party_id=party_id,
            management_zone_id=management_zone_id,
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        request.url = self._client.format_url(request.url)  # type: ignore

        pipeline_response = self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
            request, stream=False, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [204]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if cls:
            return cls(pipeline_response, None, {})


class ModelInferenceOperations:
    """
    .. warning::
        **DO NOT** instantiate this class directly.

        Instead, you should access the following operations through
        :class:`~azure.agrifood.farming.FarmBeatsClient`'s
        :attr:`model_inference` attribute.
    """

    def __init__(self, *args, **kwargs):
        input_args = list(args)
        self._client = input_args.pop(0) if input_args else kwargs.pop("client")
        self._config = input_args.pop(0) if input_args else kwargs.pop("config")
        self._serialize = input_args.pop(0) if input_args else kwargs.pop("serializer")
        self._deserialize = input_args.pop(0) if input_args else kwargs.pop("deserializer")

    def _create_biomass_model_job_initial(self, job_id: str, job: Union[JSON, IO], **kwargs: Any) -> JSON:
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type = kwargs.pop("content_type", _headers.pop("Content-Type", None))  # type: Optional[str]
        cls = kwargs.pop("cls", None)  # type: ClsType[JSON]

        content_type = content_type or "application/json"
        _json = None
        _content = None
        if isinstance(job, (IO, bytes)):
            _content = job
        else:
            _json = job

        request = build_model_inference_create_biomass_model_job_request(
            job_id=job_id,
            content_type=content_type,
            api_version=self._config.api_version,
            json=_json,
            content=_content,
            headers=_headers,
            params=_params,
        )
        request.url = self._client.format_url(request.url)  # type: ignore

        pipeline_response = self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
            request, stream=False, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [202]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if response.content:
            deserialized = response.json()
        else:
            deserialized = None

        if cls:
            return cls(pipeline_response, cast(JSON, deserialized), {})

        return cast(JSON, deserialized)

    @overload
    def begin_create_biomass_model_job(
        self, job_id: str, job: JSON, *, content_type: str = "application/json", **kwargs: Any
    ) -> LROPoller[JSON]:
        """Create a Biomass Model job.

        :param job_id: JobId provided by user. Required.
        :type job_id: str
        :param job: Job parameters supplied by user. Required.
        :type job: JSON
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :keyword str continuation_token: A continuation token to restart a poller from a saved state.
        :keyword polling: By default, your polling method will be LROBasePolling. Pass in False for
         this operation to not poll, or pass in your own initialized polling object for a personal
         polling strategy.
        :paramtype polling: bool or ~azure.core.polling.PollingMethod
        :keyword int polling_interval: Default waiting time between two polls for LRO operations if no
         Retry-After header is present.
        :return: An instance of LROPoller that returns JSON object
        :rtype: ~azure.core.polling.LROPoller[JSON]
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                job = {
                    "boundaryId": "str",  # The id of the boundary object for which biomass is
                      being calculated. Required.
                    "cropName": "str",  # Crop name for biomass model. Available Value: Corn.
                      Required. "Corn"
                    "imageFormat": "str",  # ImageFormat. Available value: TIF. Required. "TIF"
                    "imageResolution": 0.0,  # ImageResolution in meters. Available values: 10,
                      20, 60. Required.
                    "inferenceEndDateTime": "2020-02-20 00:00:00",  # End datetime till which
                      biomass will be calculated. Sample format: yyyy-MM-ddTHH:mm:ssZ. Required.
                    "modelVersion": "str",  # The version of the biomass model to be run.
                      Available Value: 1.0 . Required.
                    "partyId": "str",  # Party Id. Required.
                    "plantingStartDateTime": "2020-02-20 00:00:00",  # Planting datetime for
                      biomass calculations. Sample format: yyyy-MM-ddTHH:mm:ssZ. Required.
                    "satelliteProvider": "str",  # Provider of satellite data. Available Value:
                      Microsoft. Required. "Microsoft"
                    "satelliteSource": "str",  # Source of satellite data. Available Value:
                      Sentinel_2_L2A. Required. Known values are: "Sentinel_2_L2A" and
                      "Sentinel_2_L1C".
                    "weatherExtensionId": "str",  # ExtensionId of weather data. Available
                      values: DTN.ClearAg, DTN.ContentServices. Required.
                    "createdBy": "str",  # Optional. Created by user/tenant id.
                    "createdDateTime": "2020-02-20 00:00:00",  # Optional. Job created at
                      dateTime. Sample format: yyyy-MM-ddTHH:mm:ssZ.
                    "description": "str",  # Optional. Textual description of the resource.
                    "durationInSeconds": 0.0,  # Optional. Duration of the job in seconds.
                    "endTime": "2020-02-20 00:00:00",  # Optional. Job end time when available.
                      Sample format: yyyy-MM-ddTHH:mm:ssZ.
                    "errorCode": "str",  # Optional. Error Code when job failed.
                    "id": "str",  # Optional. Unique job id.
                    "lastActionDateTime": "2020-02-20 00:00:00",  # Optional. Job was last acted
                      upon at dateTime. Sample format: yyyy-MM-ddTHH:mm:ssZ.
                    "message": "str",  # Optional. Status message to capture more details of the
                      job.
                    "modifiedBy": "str",  # Optional. Modified by user/tenant id.
                    "name": "str",  # Optional. Name to identify resource.
                    "properties": {
                        "str": {}  # Optional. A collection of key value pairs that belongs
                          to the resource."nEach pair must not have a key greater than 50
                          characters"nand must not have a value greater than 150 characters."nNote: A
                          maximum of 25 key value pairs can be provided for a resource and only
                          string,"nnumeral and datetime (yyyy-MM-ddTHH:mm:ssZ) values are supported.
                    },
                    "startTime": "2020-02-20 00:00:00",  # Optional. Job start time when
                      available. Sample format: yyyy-MM-ddTHH:mm:ssZ.
                    "status": "str"  # Optional. Status of the job."nPossible values: 'Waiting',
                      'Running', 'Succeeded', 'Failed', 'Cancelled'.
                }

                # response body for status code(s): 202
                response == {
                    "boundaryId": "str",  # The id of the boundary object for which biomass is
                      being calculated. Required.
                    "cropName": "str",  # Crop name for biomass model. Available Value: Corn.
                      Required. "Corn"
                    "imageFormat": "str",  # ImageFormat. Available value: TIF. Required. "TIF"
                    "imageResolution": 0.0,  # ImageResolution in meters. Available values: 10,
                      20, 60. Required.
                    "inferenceEndDateTime": "2020-02-20 00:00:00",  # End datetime till which
                      biomass will be calculated. Sample format: yyyy-MM-ddTHH:mm:ssZ. Required.
                    "modelVersion": "str",  # The version of the biomass model to be run.
                      Available Value: 1.0 . Required.
                    "partyId": "str",  # Party Id. Required.
                    "plantingStartDateTime": "2020-02-20 00:00:00",  # Planting datetime for
                      biomass calculations. Sample format: yyyy-MM-ddTHH:mm:ssZ. Required.
                    "satelliteProvider": "str",  # Provider of satellite data. Available Value:
                      Microsoft. Required. "Microsoft"
                    "satelliteSource": "str",  # Source of satellite data. Available Value:
                      Sentinel_2_L2A. Required. Known values are: "Sentinel_2_L2A" and
                      "Sentinel_2_L1C".
                    "weatherExtensionId": "str",  # ExtensionId of weather data. Available
                      values: DTN.ClearAg, DTN.ContentServices. Required.
                    "createdBy": "str",  # Optional. Created by user/tenant id.
                    "createdDateTime": "2020-02-20 00:00:00",  # Optional. Job created at
                      dateTime. Sample format: yyyy-MM-ddTHH:mm:ssZ.
                    "description": "str",  # Optional. Textual description of the resource.
                    "durationInSeconds": 0.0,  # Optional. Duration of the job in seconds.
                    "endTime": "2020-02-20 00:00:00",  # Optional. Job end time when available.
                      Sample format: yyyy-MM-ddTHH:mm:ssZ.
                    "errorCode": "str",  # Optional. Error Code when job failed.
                    "id": "str",  # Optional. Unique job id.
                    "lastActionDateTime": "2020-02-20 00:00:00",  # Optional. Job was last acted
                      upon at dateTime. Sample format: yyyy-MM-ddTHH:mm:ssZ.
                    "message": "str",  # Optional. Status message to capture more details of the
                      job.
                    "modifiedBy": "str",  # Optional. Modified by user/tenant id.
                    "name": "str",  # Optional. Name to identify resource.
                    "properties": {
                        "str": {}  # Optional. A collection of key value pairs that belongs
                          to the resource."nEach pair must not have a key greater than 50
                          characters"nand must not have a value greater than 150 characters."nNote: A
                          maximum of 25 key value pairs can be provided for a resource and only
                          string,"nnumeral and datetime (yyyy-MM-ddTHH:mm:ssZ) values are supported.
                    },
                    "startTime": "2020-02-20 00:00:00",  # Optional. Job start time when
                      available. Sample format: yyyy-MM-ddTHH:mm:ssZ.
                    "status": "str"  # Optional. Status of the job."nPossible values: 'Waiting',
                      'Running', 'Succeeded', 'Failed', 'Cancelled'.
                }
        """

    @overload
    def begin_create_biomass_model_job(
        self, job_id: str, job: IO, *, content_type: str = "application/json", **kwargs: Any
    ) -> LROPoller[JSON]:
        """Create a Biomass Model job.

        :param job_id: JobId provided by user. Required.
        :type job_id: str
        :param job: Job parameters supplied by user. Required.
        :type job: IO
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Default value is "application/json".
        :paramtype content_type: str
        :keyword str continuation_token: A continuation token to restart a poller from a saved state.
        :keyword polling: By default, your polling method will be LROBasePolling. Pass in False for
         this operation to not poll, or pass in your own initialized polling object for a personal
         polling strategy.
        :paramtype polling: bool or ~azure.core.polling.PollingMethod
        :keyword int polling_interval: Default waiting time between two polls for LRO operations if no
         Retry-After header is present.
        :return: An instance of LROPoller that returns JSON object
        :rtype: ~azure.core.polling.LROPoller[JSON]
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 202
                response == {
                    "boundaryId": "str",  # The id of the boundary object for which biomass is
                      being calculated. Required.
                    "cropName": "str",  # Crop name for biomass model. Available Value: Corn.
                      Required. "Corn"
                    "imageFormat": "str",  # ImageFormat. Available value: TIF. Required. "TIF"
                    "imageResolution": 0.0,  # ImageResolution in meters. Available values: 10,
                      20, 60. Required.
                    "inferenceEndDateTime": "2020-02-20 00:00:00",  # End datetime till which
                      biomass will be calculated. Sample format: yyyy-MM-ddTHH:mm:ssZ. Required.
                    "modelVersion": "str",  # The version of the biomass model to be run.
                      Available Value: 1.0 . Required.
                    "partyId": "str",  # Party Id. Required.
                    "plantingStartDateTime": "2020-02-20 00:00:00",  # Planting datetime for
                      biomass calculations. Sample format: yyyy-MM-ddTHH:mm:ssZ. Required.
                    "satelliteProvider": "str",  # Provider of satellite data. Available Value:
                      Microsoft. Required. "Microsoft"
                    "satelliteSource": "str",  # Source of satellite data. Available Value:
                      Sentinel_2_L2A. Required. Known values are: "Sentinel_2_L2A" and
                      "Sentinel_2_L1C".
                    "weatherExtensionId": "str",  # ExtensionId of weather data. Available
                      values: DTN.ClearAg, DTN.ContentServices. Required.
                    "createdBy": "str",  # Optional. Created by user/tenant id.
                    "createdDateTime": "2020-02-20 00:00:00",  # Optional. Job created at
                      dateTime. Sample format: yyyy-MM-ddTHH:mm:ssZ.
                    "description": "str",  # Optional. Textual description of the resource.
                    "durationInSeconds": 0.0,  # Optional. Duration of the job in seconds.
                    "endTime": "2020-02-20 00:00:00",  # Optional. Job end time when available.
                      Sample format: yyyy-MM-ddTHH:mm:ssZ.
                    "errorCode": "str",  # Optional. Error Code when job failed.
                    "id": "str",  # Optional. Unique job id.
                    "lastActionDateTime": "2020-02-20 00:00:00",  # Optional. Job was last acted
                      upon at dateTime. Sample format: yyyy-MM-ddTHH:mm:ssZ.
                    "message": "str",  # Optional. Status message to capture more details of the
                      job.
                    "modifiedBy": "str",  # Optional. Modified by user/tenant id.
                    "name": "str",  # Optional. Name to identify resource.
                    "properties": {
                        "str": {}  # Optional. A collection of key value pairs that belongs
                          to the resource."nEach pair must not have a key greater than 50
                          characters"nand must not have a value greater than 150 characters."nNote: A
                          maximum of 25 key value pairs can be provided for a resource and only
                          string,"nnumeral and datetime (yyyy-MM-ddTHH:mm:ssZ) values are supported.
                    },
                    "startTime": "2020-02-20 00:00:00",  # Optional. Job start time when
                      available. Sample format: yyyy-MM-ddTHH:mm:ssZ.
                    "status": "str"  # Optional. Status of the job."nPossible values: 'Waiting',
                      'Running', 'Succeeded', 'Failed', 'Cancelled'.
                }
        """

    @distributed_trace
    def begin_create_biomass_model_job(self, job_id: str, job: Union[JSON, IO], **kwargs: Any) -> LROPoller[JSON]:
        """Create a Biomass Model job.

        :param job_id: JobId provided by user. Required.
        :type job_id: str
        :param job: Job parameters supplied by user. Is either a model type or a IO type. Required.
        :type job: JSON or IO
        :keyword content_type: Body Parameter content-type. Known values are: 'application/json'.
         Default value is None.
        :paramtype content_type: str
        :keyword str continuation_token: A continuation token to restart a poller from a saved state.
        :keyword polling: By default, your polling method will be LROBasePolling. Pass in False for
         this operation to not poll, or pass in your own initialized polling object for a personal
         polling strategy.
        :paramtype polling: bool or ~azure.core.polling.PollingMethod
        :keyword int polling_interval: Default waiting time between two polls for LRO operations if no
         Retry-After header is present.
        :return: An instance of LROPoller that returns JSON object
        :rtype: ~azure.core.polling.LROPoller[JSON]
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 202
                response == {
                    "boundaryId": "str",  # The id of the boundary object for which biomass is
                      being calculated. Required.
                    "cropName": "str",  # Crop name for biomass model. Available Value: Corn.
                      Required. "Corn"
                    "imageFormat": "str",  # ImageFormat. Available value: TIF. Required. "TIF"
                    "imageResolution": 0.0,  # ImageResolution in meters. Available values: 10,
                      20, 60. Required.
                    "inferenceEndDateTime": "2020-02-20 00:00:00",  # End datetime till which
                      biomass will be calculated. Sample format: yyyy-MM-ddTHH:mm:ssZ. Required.
                    "modelVersion": "str",  # The version of the biomass model to be run.
                      Available Value: 1.0 . Required.
                    "partyId": "str",  # Party Id. Required.
                    "plantingStartDateTime": "2020-02-20 00:00:00",  # Planting datetime for
                      biomass calculations. Sample format: yyyy-MM-ddTHH:mm:ssZ. Required.
                    "satelliteProvider": "str",  # Provider of satellite data. Available Value:
                      Microsoft. Required. "Microsoft"
                    "satelliteSource": "str",  # Source of satellite data. Available Value:
                      Sentinel_2_L2A. Required. Known values are: "Sentinel_2_L2A" and
                      "Sentinel_2_L1C".
                    "weatherExtensionId": "str",  # ExtensionId of weather data. Available
                      values: DTN.ClearAg, DTN.ContentServices. Required.
                    "createdBy": "str",  # Optional. Created by user/tenant id.
                    "createdDateTime": "2020-02-20 00:00:00",  # Optional. Job created at
                      dateTime. Sample format: yyyy-MM-ddTHH:mm:ssZ.
                    "description": "str",  # Optional. Textual description of the resource.
                    "durationInSeconds": 0.0,  # Optional. Duration of the job in seconds.
                    "endTime": "2020-02-20 00:00:00",  # Optional. Job end time when available.
                      Sample format: yyyy-MM-ddTHH:mm:ssZ.
                    "errorCode": "str",  # Optional. Error Code when job failed.
                    "id": "str",  # Optional. Unique job id.
                    "lastActionDateTime": "2020-02-20 00:00:00",  # Optional. Job was last acted
                      upon at dateTime. Sample format: yyyy-MM-ddTHH:mm:ssZ.
                    "message": "str",  # Optional. Status message to capture more details of the
                      job.
                    "modifiedBy": "str",  # Optional. Modified by user/tenant id.
                    "name": "str",  # Optional. Name to identify resource.
                    "properties": {
                        "str": {}  # Optional. A collection of key value pairs that belongs
                          to the resource."nEach pair must not have a key greater than 50
                          characters"nand must not have a value greater than 150 characters."nNote: A
                          maximum of 25 key value pairs can be provided for a resource and only
                          string,"nnumeral and datetime (yyyy-MM-ddTHH:mm:ssZ) values are supported.
                    },
                    "startTime": "2020-02-20 00:00:00",  # Optional. Job start time when
                      available. Sample format: yyyy-MM-ddTHH:mm:ssZ.
                    "status": "str"  # Optional. Status of the job."nPossible values: 'Waiting',
                      'Running', 'Succeeded', 'Failed', 'Cancelled'.
                }
        """
        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type = kwargs.pop("content_type", _headers.pop("Content-Type", None))  # type: Optional[str]
        cls = kwargs.pop("cls", None)  # type: ClsType[JSON]
        polling = kwargs.pop("polling", True)  # type: Union[bool, PollingMethod]
        lro_delay = kwargs.pop("polling_interval", self._config.polling_interval)
        cont_token = kwargs.pop("continuation_token", None)  # type: Optional[str]
        if cont_token is None:
            raw_result = self._create_biomass_model_job_initial(  # type: ignore
                job_id=job_id,
                job=job,
                content_type=content_type,
                cls=lambda x, y, z: x,
                headers=_headers,
                params=_params,
                **kwargs
            )
        kwargs.pop("error_map", None)

        def get_long_running_output(pipeline_response):
            response = pipeline_response.http_response
            if response.content:
                deserialized = response.json()
            else:
                deserialized = None
            if cls:
                return cls(pipeline_response, deserialized, {})
            return deserialized

        if polling is True:
            polling_method = cast(
                PollingMethod, LROBasePolling(lro_delay, lro_options={"final-state-via": "location"}, **kwargs)
            )  # type: PollingMethod
        elif polling is False:
            polling_method = cast(PollingMethod, NoPolling())
        else:
            polling_method = polling
        if cont_token:
            return LROPoller.from_continuation_token(
                polling_method=polling_method,
                continuation_token=cont_token,
                client=self._client,
                deserialization_callback=get_long_running_output,
            )
        return LROPoller(self._client, raw_result, get_long_running_output, polling_method)

    @distributed_trace
    def get_biomass_model_job(self, job_id: str, **kwargs: Any) -> JSON:
        """Get Biomass Model job's details.

        :param job_id: Id of the job. Required.
        :type job_id: str
        :return: JSON object
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "boundaryId": "str",  # The id of the boundary object for which biomass is
                      being calculated. Required.
                    "cropName": "str",  # Crop name for biomass model. Available Value: Corn.
                      Required. "Corn"
                    "imageFormat": "str",  # ImageFormat. Available value: TIF. Required. "TIF"
                    "imageResolution": 0.0,  # ImageResolution in meters. Available values: 10,
                      20, 60. Required.
                    "inferenceEndDateTime": "2020-02-20 00:00:00",  # End datetime till which
                      biomass will be calculated. Sample format: yyyy-MM-ddTHH:mm:ssZ. Required.
                    "modelVersion": "str",  # The version of the biomass model to be run.
                      Available Value: 1.0 . Required.
                    "partyId": "str",  # Party Id. Required.
                    "plantingStartDateTime": "2020-02-20 00:00:00",  # Planting datetime for
                      biomass calculations. Sample format: yyyy-MM-ddTHH:mm:ssZ. Required.
                    "satelliteProvider": "str",  # Provider of satellite data. Available Value:
                      Microsoft. Required. "Microsoft"
                    "satelliteSource": "str",  # Source of satellite data. Available Value:
                      Sentinel_2_L2A. Required. Known values are: "Sentinel_2_L2A" and
                      "Sentinel_2_L1C".
                    "weatherExtensionId": "str",  # ExtensionId of weather data. Available
                      values: DTN.ClearAg, DTN.ContentServices. Required.
                    "createdBy": "str",  # Optional. Created by user/tenant id.
                    "createdDateTime": "2020-02-20 00:00:00",  # Optional. Job created at
                      dateTime. Sample format: yyyy-MM-ddTHH:mm:ssZ.
                    "description": "str",  # Optional. Textual description of the resource.
                    "durationInSeconds": 0.0,  # Optional. Duration of the job in seconds.
                    "endTime": "2020-02-20 00:00:00",  # Optional. Job end time when available.
                      Sample format: yyyy-MM-ddTHH:mm:ssZ.
                    "errorCode": "str",  # Optional. Error Code when job failed.
                    "id": "str",  # Optional. Unique job id.
                    "lastActionDateTime": "2020-02-20 00:00:00",  # Optional. Job was last acted
                      upon at dateTime. Sample format: yyyy-MM-ddTHH:mm:ssZ.
                    "message": "str",  # Optional. Status message to capture more details of the
                      job.
                    "modifiedBy": "str",  # Optional. Modified by user/tenant id.
                    "name": "str",  # Optional. Name to identify resource.
                    "properties": {
                        "str": {}  # Optional. A collection of key value pairs that belongs
                          to the resource."nEach pair must not have a key greater than 50
                          characters"nand must not have a value greater than 150 characters."nNote: A
                          maximum of 25 key value pairs can be provided for a resource and only
                          string,"nnumeral and datetime (yyyy-MM-ddTHH:mm:ssZ) values are supported.
                    },
                    "startTime": "2020-02-20 00:00:00",  # Optional. Job start time when
                      available. Sample format: yyyy-MM-ddTHH:mm:ssZ.
                    "status": "str"  # Optional. Status of the job."nPossible values: 'Waiting',
                      'Running', 'Succeeded', 'Failed', 'Cancelled'.
                }
        """
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls = kwargs.pop("cls", None)  # type: ClsType[JSON]

        request = build_model_inference_get_biomass_model_job_request(
            job_id=job_id,
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        request.url = self._client.format_url(request.url)  # type: ignore

        pipeline_response = self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
            request, stream=False, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if response.content:
            deserialized = response.json()
        else:
            deserialized = None

        if cls:
            return cls(pipeline_response, cast(JSON, deserialized), {})

        return cast(JSON, deserialized)

    def _create_sensor_placement_model_job_initial(self, job_id: str, job: Union[JSON, IO], **kwargs: Any) -> JSON:
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type = kwargs.pop("content_type", _headers.pop("Content-Type", None))  # type: Optional[str]
        cls = kwargs.pop("cls", None)  # type: ClsType[JSON]

        content_type = content_type or "application/json"
        _json = None
        _content = None
        if isinstance(job, (IO, bytes)):
            _content = job
        else:
            _json = job

        request = build_model_inference_create_sensor_placement_model_job_request(
            job_id=job_id,
            content_type=content_type,
            api_version=self._config.api_version,
            json=_json,
            content=_content,
            headers=_headers,
            params=_params,
        )
        request.url = self._client.format_url(request.url)  # type: ignore

        pipeline_response = self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
            request, stream=False, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [202]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if response.content:
            deserialized = response.json()
        else:
            deserialized = None

        if cls:
            return cls(pipeline_response, cast(JSON, deserialized), {})

        return cast(JSON, deserialized)

    @overload
    def begin_create_sensor_placement_model_job(
        self, job_id: str, job: JSON, *, content_type: str = "application/json", **kwargs: Any
    ) -> LROPoller[JSON]:
        """Create a Sensor Placement Model job.

        :param job_id: JobId provided by user. Required.
        :type job_id: str
        :param job: Job parameters supplied by user. Required.
        :type job: JSON
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :keyword str continuation_token: A continuation token to restart a poller from a saved state.
        :keyword polling: By default, your polling method will be LROBasePolling. Pass in False for
         this operation to not poll, or pass in your own initialized polling object for a personal
         polling strategy.
        :paramtype polling: bool or ~azure.core.polling.PollingMethod
        :keyword int polling_interval: Default waiting time between two polls for LRO operations if no
         Retry-After header is present.
        :return: An instance of LROPoller that returns JSON object
        :rtype: ~azure.core.polling.LROPoller[JSON]
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                job = {
                    "boundaryId": "str",  # The id of the boundary object for which sensor
                      placement is being calculated. Required.
                    "inferenceEndDateTime": "2020-02-20 00:00:00",  # End datetime for satellite
                      data to be pulled. Required.
                    "inferenceStartDateTime": "2020-02-20 00:00:00",  # Start datetime for
                      satellite data to be pulled. Required.
                    "isRanked": bool,  # IsRanked, if True the sensor placements will be ranked.
                      Required.
                    "modelVersion": "str",  # The version of the sensor placement model to be
                      run. Required.
                    "partyId": "str",  # Party Id. Required.
                    "satelliteProvider": "str",  # Provider of satellite data. Available Value:
                      Microsoft. Required. "Microsoft"
                    "satelliteSource": "str",  # Source of satellite data. Available Value:
                      Sentinel_2_L2A. Required. Known values are: "Sentinel_2_L2A" and
                      "Sentinel_2_L1C".
                    "sensorType": "str",  # SensorType. The sensor placement map generated for
                      sensor type (e.g., soil moisture, soil temperature, npk). Available Value:
                      SoilMoisture. Required.
                    "createdBy": "str",  # Optional. Created by user/tenant id.
                    "createdDateTime": "2020-02-20 00:00:00",  # Optional. Job created at
                      dateTime. Sample format: yyyy-MM-ddTHH:mm:ssZ.
                    "description": "str",  # Optional. Textual description of the resource.
                    "durationInSeconds": 0.0,  # Optional. Duration of the job in seconds.
                    "endTime": "2020-02-20 00:00:00",  # Optional. Job end time when available.
                      Sample format: yyyy-MM-ddTHH:mm:ssZ.
                    "errorCode": "str",  # Optional. Error Code when job failed.
                    "id": "str",  # Optional. Unique job id.
                    "lastActionDateTime": "2020-02-20 00:00:00",  # Optional. Job was last acted
                      upon at dateTime. Sample format: yyyy-MM-ddTHH:mm:ssZ.
                    "message": "str",  # Optional. Status message to capture more details of the
                      job.
                    "modifiedBy": "str",  # Optional. Modified by user/tenant id.
                    "name": "str",  # Optional. Name to identify resource.
                    "properties": {
                        "str": {}  # Optional. A collection of key value pairs that belongs
                          to the resource."nEach pair must not have a key greater than 50
                          characters"nand must not have a value greater than 150 characters."nNote: A
                          maximum of 25 key value pairs can be provided for a resource and only
                          string,"nnumeral and datetime (yyyy-MM-ddTHH:mm:ssZ) values are supported.
                    },
                    "startTime": "2020-02-20 00:00:00",  # Optional. Job start time when
                      available. Sample format: yyyy-MM-ddTHH:mm:ssZ.
                    "status": "str"  # Optional. Status of the job."nPossible values: 'Waiting',
                      'Running', 'Succeeded', 'Failed', 'Cancelled'.
                }

                # response body for status code(s): 202
                response == {
                    "boundaryId": "str",  # The id of the boundary object for which sensor
                      placement is being calculated. Required.
                    "inferenceEndDateTime": "2020-02-20 00:00:00",  # End datetime for satellite
                      data to be pulled. Required.
                    "inferenceStartDateTime": "2020-02-20 00:00:00",  # Start datetime for
                      satellite data to be pulled. Required.
                    "isRanked": bool,  # IsRanked, if True the sensor placements will be ranked.
                      Required.
                    "modelVersion": "str",  # The version of the sensor placement model to be
                      run. Required.
                    "partyId": "str",  # Party Id. Required.
                    "satelliteProvider": "str",  # Provider of satellite data. Available Value:
                      Microsoft. Required. "Microsoft"
                    "satelliteSource": "str",  # Source of satellite data. Available Value:
                      Sentinel_2_L2A. Required. Known values are: "Sentinel_2_L2A" and
                      "Sentinel_2_L1C".
                    "sensorType": "str",  # SensorType. The sensor placement map generated for
                      sensor type (e.g., soil moisture, soil temperature, npk). Available Value:
                      SoilMoisture. Required.
                    "createdBy": "str",  # Optional. Created by user/tenant id.
                    "createdDateTime": "2020-02-20 00:00:00",  # Optional. Job created at
                      dateTime. Sample format: yyyy-MM-ddTHH:mm:ssZ.
                    "description": "str",  # Optional. Textual description of the resource.
                    "durationInSeconds": 0.0,  # Optional. Duration of the job in seconds.
                    "endTime": "2020-02-20 00:00:00",  # Optional. Job end time when available.
                      Sample format: yyyy-MM-ddTHH:mm:ssZ.
                    "errorCode": "str",  # Optional. Error Code when job failed.
                    "id": "str",  # Optional. Unique job id.
                    "lastActionDateTime": "2020-02-20 00:00:00",  # Optional. Job was last acted
                      upon at dateTime. Sample format: yyyy-MM-ddTHH:mm:ssZ.
                    "message": "str",  # Optional. Status message to capture more details of the
                      job.
                    "modifiedBy": "str",  # Optional. Modified by user/tenant id.
                    "name": "str",  # Optional. Name to identify resource.
                    "properties": {
                        "str": {}  # Optional. A collection of key value pairs that belongs
                          to the resource."nEach pair must not have a key greater than 50
                          characters"nand must not have a value greater than 150 characters."nNote: A
                          maximum of 25 key value pairs can be provided for a resource and only
                          string,"nnumeral and datetime (yyyy-MM-ddTHH:mm:ssZ) values are supported.
                    },
                    "startTime": "2020-02-20 00:00:00",  # Optional. Job start time when
                      available. Sample format: yyyy-MM-ddTHH:mm:ssZ.
                    "status": "str"  # Optional. Status of the job."nPossible values: 'Waiting',
                      'Running', 'Succeeded', 'Failed', 'Cancelled'.
                }
        """

    @overload
    def begin_create_sensor_placement_model_job(
        self, job_id: str, job: IO, *, content_type: str = "application/json", **kwargs: Any
    ) -> LROPoller[JSON]:
        """Create a Sensor Placement Model job.

        :param job_id: JobId provided by user. Required.
        :type job_id: str
        :param job: Job parameters supplied by user. Required.
        :type job: IO
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Default value is "application/json".
        :paramtype content_type: str
        :keyword str continuation_token: A continuation token to restart a poller from a saved state.
        :keyword polling: By default, your polling method will be LROBasePolling. Pass in False for
         this operation to not poll, or pass in your own initialized polling object for a personal
         polling strategy.
        :paramtype polling: bool or ~azure.core.polling.PollingMethod
        :keyword int polling_interval: Default waiting time between two polls for LRO operations if no
         Retry-After header is present.
        :return: An instance of LROPoller that returns JSON object
        :rtype: ~azure.core.polling.LROPoller[JSON]
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 202
                response == {
                    "boundaryId": "str",  # The id of the boundary object for which sensor
                      placement is being calculated. Required.
                    "inferenceEndDateTime": "2020-02-20 00:00:00",  # End datetime for satellite
                      data to be pulled. Required.
                    "inferenceStartDateTime": "2020-02-20 00:00:00",  # Start datetime for
                      satellite data to be pulled. Required.
                    "isRanked": bool,  # IsRanked, if True the sensor placements will be ranked.
                      Required.
                    "modelVersion": "str",  # The version of the sensor placement model to be
                      run. Required.
                    "partyId": "str",  # Party Id. Required.
                    "satelliteProvider": "str",  # Provider of satellite data. Available Value:
                      Microsoft. Required. "Microsoft"
                    "satelliteSource": "str",  # Source of satellite data. Available Value:
                      Sentinel_2_L2A. Required. Known values are: "Sentinel_2_L2A" and
                      "Sentinel_2_L1C".
                    "sensorType": "str",  # SensorType. The sensor placement map generated for
                      sensor type (e.g., soil moisture, soil temperature, npk). Available Value:
                      SoilMoisture. Required.
                    "createdBy": "str",  # Optional. Created by user/tenant id.
                    "createdDateTime": "2020-02-20 00:00:00",  # Optional. Job created at
                      dateTime. Sample format: yyyy-MM-ddTHH:mm:ssZ.
                    "description": "str",  # Optional. Textual description of the resource.
                    "durationInSeconds": 0.0,  # Optional. Duration of the job in seconds.
                    "endTime": "2020-02-20 00:00:00",  # Optional. Job end time when available.
                      Sample format: yyyy-MM-ddTHH:mm:ssZ.
                    "errorCode": "str",  # Optional. Error Code when job failed.
                    "id": "str",  # Optional. Unique job id.
                    "lastActionDateTime": "2020-02-20 00:00:00",  # Optional. Job was last acted
                      upon at dateTime. Sample format: yyyy-MM-ddTHH:mm:ssZ.
                    "message": "str",  # Optional. Status message to capture more details of the
                      job.
                    "modifiedBy": "str",  # Optional. Modified by user/tenant id.
                    "name": "str",  # Optional. Name to identify resource.
                    "properties": {
                        "str": {}  # Optional. A collection of key value pairs that belongs
                          to the resource."nEach pair must not have a key greater than 50
                          characters"nand must not have a value greater than 150 characters."nNote: A
                          maximum of 25 key value pairs can be provided for a resource and only
                          string,"nnumeral and datetime (yyyy-MM-ddTHH:mm:ssZ) values are supported.
                    },
                    "startTime": "2020-02-20 00:00:00",  # Optional. Job start time when
                      available. Sample format: yyyy-MM-ddTHH:mm:ssZ.
                    "status": "str"  # Optional. Status of the job."nPossible values: 'Waiting',
                      'Running', 'Succeeded', 'Failed', 'Cancelled'.
                }
        """

    @distributed_trace
    def begin_create_sensor_placement_model_job(
        self, job_id: str, job: Union[JSON, IO], **kwargs: Any
    ) -> LROPoller[JSON]:
        """Create a Sensor Placement Model job.

        :param job_id: JobId provided by user. Required.
        :type job_id: str
        :param job: Job parameters supplied by user. Is either a model type or a IO type. Required.
        :type job: JSON or IO
        :keyword content_type: Body Parameter content-type. Known values are: 'application/json'.
         Default value is None.
        :paramtype content_type: str
        :keyword str continuation_token: A continuation token to restart a poller from a saved state.
        :keyword polling: By default, your polling method will be LROBasePolling. Pass in False for
         this operation to not poll, or pass in your own initialized polling object for a personal
         polling strategy.
        :paramtype polling: bool or ~azure.core.polling.PollingMethod
        :keyword int polling_interval: Default waiting time between two polls for LRO operations if no
         Retry-After header is present.
        :return: An instance of LROPoller that returns JSON object
        :rtype: ~azure.core.polling.LROPoller[JSON]
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 202
                response == {
                    "boundaryId": "str",  # The id of the boundary object for which sensor
                      placement is being calculated. Required.
                    "inferenceEndDateTime": "2020-02-20 00:00:00",  # End datetime for satellite
                      data to be pulled. Required.
                    "inferenceStartDateTime": "2020-02-20 00:00:00",  # Start datetime for
                      satellite data to be pulled. Required.
                    "isRanked": bool,  # IsRanked, if True the sensor placements will be ranked.
                      Required.
                    "modelVersion": "str",  # The version of the sensor placement model to be
                      run. Required.
                    "partyId": "str",  # Party Id. Required.
                    "satelliteProvider": "str",  # Provider of satellite data. Available Value:
                      Microsoft. Required. "Microsoft"
                    "satelliteSource": "str",  # Source of satellite data. Available Value:
                      Sentinel_2_L2A. Required. Known values are: "Sentinel_2_L2A" and
                      "Sentinel_2_L1C".
                    "sensorType": "str",  # SensorType. The sensor placement map generated for
                      sensor type (e.g., soil moisture, soil temperature, npk). Available Value:
                      SoilMoisture. Required.
                    "createdBy": "str",  # Optional. Created by user/tenant id.
                    "createdDateTime": "2020-02-20 00:00:00",  # Optional. Job created at
                      dateTime. Sample format: yyyy-MM-ddTHH:mm:ssZ.
                    "description": "str",  # Optional. Textual description of the resource.
                    "durationInSeconds": 0.0,  # Optional. Duration of the job in seconds.
                    "endTime": "2020-02-20 00:00:00",  # Optional. Job end time when available.
                      Sample format: yyyy-MM-ddTHH:mm:ssZ.
                    "errorCode": "str",  # Optional. Error Code when job failed.
                    "id": "str",  # Optional. Unique job id.
                    "lastActionDateTime": "2020-02-20 00:00:00",  # Optional. Job was last acted
                      upon at dateTime. Sample format: yyyy-MM-ddTHH:mm:ssZ.
                    "message": "str",  # Optional. Status message to capture more details of the
                      job.
                    "modifiedBy": "str",  # Optional. Modified by user/tenant id.
                    "name": "str",  # Optional. Name to identify resource.
                    "properties": {
                        "str": {}  # Optional. A collection of key value pairs that belongs
                          to the resource."nEach pair must not have a key greater than 50
                          characters"nand must not have a value greater than 150 characters."nNote: A
                          maximum of 25 key value pairs can be provided for a resource and only
                          string,"nnumeral and datetime (yyyy-MM-ddTHH:mm:ssZ) values are supported.
                    },
                    "startTime": "2020-02-20 00:00:00",  # Optional. Job start time when
                      available. Sample format: yyyy-MM-ddTHH:mm:ssZ.
                    "status": "str"  # Optional. Status of the job."nPossible values: 'Waiting',
                      'Running', 'Succeeded', 'Failed', 'Cancelled'.
                }
        """
        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type = kwargs.pop("content_type", _headers.pop("Content-Type", None))  # type: Optional[str]
        cls = kwargs.pop("cls", None)  # type: ClsType[JSON]
        polling = kwargs.pop("polling", True)  # type: Union[bool, PollingMethod]
        lro_delay = kwargs.pop("polling_interval", self._config.polling_interval)
        cont_token = kwargs.pop("continuation_token", None)  # type: Optional[str]
        if cont_token is None:
            raw_result = self._create_sensor_placement_model_job_initial(  # type: ignore
                job_id=job_id,
                job=job,
                content_type=content_type,
                cls=lambda x, y, z: x,
                headers=_headers,
                params=_params,
                **kwargs
            )
        kwargs.pop("error_map", None)

        def get_long_running_output(pipeline_response):
            response = pipeline_response.http_response
            if response.content:
                deserialized = response.json()
            else:
                deserialized = None
            if cls:
                return cls(pipeline_response, deserialized, {})
            return deserialized

        if polling is True:
            polling_method = cast(
                PollingMethod, LROBasePolling(lro_delay, lro_options={"final-state-via": "location"}, **kwargs)
            )  # type: PollingMethod
        elif polling is False:
            polling_method = cast(PollingMethod, NoPolling())
        else:
            polling_method = polling
        if cont_token:
            return LROPoller.from_continuation_token(
                polling_method=polling_method,
                continuation_token=cont_token,
                client=self._client,
                deserialization_callback=get_long_running_output,
            )
        return LROPoller(self._client, raw_result, get_long_running_output, polling_method)

    @distributed_trace
    def get_sensor_placement_model_job(self, job_id: str, **kwargs: Any) -> JSON:
        """Get Sensor Placement Model job's details.

        :param job_id: Id of the job. Required.
        :type job_id: str
        :return: JSON object
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "boundaryId": "str",  # The id of the boundary object for which sensor
                      placement is being calculated. Required.
                    "inferenceEndDateTime": "2020-02-20 00:00:00",  # End datetime for satellite
                      data to be pulled. Required.
                    "inferenceStartDateTime": "2020-02-20 00:00:00",  # Start datetime for
                      satellite data to be pulled. Required.
                    "isRanked": bool,  # IsRanked, if True the sensor placements will be ranked.
                      Required.
                    "modelVersion": "str",  # The version of the sensor placement model to be
                      run. Required.
                    "partyId": "str",  # Party Id. Required.
                    "satelliteProvider": "str",  # Provider of satellite data. Available Value:
                      Microsoft. Required. "Microsoft"
                    "satelliteSource": "str",  # Source of satellite data. Available Value:
                      Sentinel_2_L2A. Required. Known values are: "Sentinel_2_L2A" and
                      "Sentinel_2_L1C".
                    "sensorType": "str",  # SensorType. The sensor placement map generated for
                      sensor type (e.g., soil moisture, soil temperature, npk). Available Value:
                      SoilMoisture. Required.
                    "createdBy": "str",  # Optional. Created by user/tenant id.
                    "createdDateTime": "2020-02-20 00:00:00",  # Optional. Job created at
                      dateTime. Sample format: yyyy-MM-ddTHH:mm:ssZ.
                    "description": "str",  # Optional. Textual description of the resource.
                    "durationInSeconds": 0.0,  # Optional. Duration of the job in seconds.
                    "endTime": "2020-02-20 00:00:00",  # Optional. Job end time when available.
                      Sample format: yyyy-MM-ddTHH:mm:ssZ.
                    "errorCode": "str",  # Optional. Error Code when job failed.
                    "id": "str",  # Optional. Unique job id.
                    "lastActionDateTime": "2020-02-20 00:00:00",  # Optional. Job was last acted
                      upon at dateTime. Sample format: yyyy-MM-ddTHH:mm:ssZ.
                    "message": "str",  # Optional. Status message to capture more details of the
                      job.
                    "modifiedBy": "str",  # Optional. Modified by user/tenant id.
                    "name": "str",  # Optional. Name to identify resource.
                    "properties": {
                        "str": {}  # Optional. A collection of key value pairs that belongs
                          to the resource."nEach pair must not have a key greater than 50
                          characters"nand must not have a value greater than 150 characters."nNote: A
                          maximum of 25 key value pairs can be provided for a resource and only
                          string,"nnumeral and datetime (yyyy-MM-ddTHH:mm:ssZ) values are supported.
                    },
                    "startTime": "2020-02-20 00:00:00",  # Optional. Job start time when
                      available. Sample format: yyyy-MM-ddTHH:mm:ssZ.
                    "status": "str"  # Optional. Status of the job."nPossible values: 'Waiting',
                      'Running', 'Succeeded', 'Failed', 'Cancelled'.
                }
        """
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls = kwargs.pop("cls", None)  # type: ClsType[JSON]

        request = build_model_inference_get_sensor_placement_model_job_request(
            job_id=job_id,
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        request.url = self._client.format_url(request.url)  # type: ignore

        pipeline_response = self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
            request, stream=False, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if response.content:
            deserialized = response.json()
        else:
            deserialized = None

        if cls:
            return cls(pipeline_response, cast(JSON, deserialized), {})

        return cast(JSON, deserialized)

    def _create_soil_moisture_model_job_initial(self, job_id: str, job: Union[JSON, IO], **kwargs: Any) -> JSON:
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type = kwargs.pop("content_type", _headers.pop("Content-Type", None))  # type: Optional[str]
        cls = kwargs.pop("cls", None)  # type: ClsType[JSON]

        content_type = content_type or "application/json"
        _json = None
        _content = None
        if isinstance(job, (IO, bytes)):
            _content = job
        else:
            _json = job

        request = build_model_inference_create_soil_moisture_model_job_request(
            job_id=job_id,
            content_type=content_type,
            api_version=self._config.api_version,
            json=_json,
            content=_content,
            headers=_headers,
            params=_params,
        )
        request.url = self._client.format_url(request.url)  # type: ignore

        pipeline_response = self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
            request, stream=False, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [202]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if response.content:
            deserialized = response.json()
        else:
            deserialized = None

        if cls:
            return cls(pipeline_response, cast(JSON, deserialized), {})

        return cast(JSON, deserialized)

    @overload
    def begin_create_soil_moisture_model_job(
        self, job_id: str, job: JSON, *, content_type: str = "application/json", **kwargs: Any
    ) -> LROPoller[JSON]:
        """Create a SoilMoisture Model job.

        :param job_id: JobId provided by user. Required.
        :type job_id: str
        :param job: Job parameters supplied by user. Required.
        :type job: JSON
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :keyword str continuation_token: A continuation token to restart a poller from a saved state.
        :keyword polling: By default, your polling method will be LROBasePolling. Pass in False for
         this operation to not poll, or pass in your own initialized polling object for a personal
         polling strategy.
        :paramtype polling: bool or ~azure.core.polling.PollingMethod
        :keyword int polling_interval: Default waiting time between two polls for LRO operations if no
         Retry-After header is present.
        :return: An instance of LROPoller that returns JSON object
        :rtype: ~azure.core.polling.LROPoller[JSON]
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                job = {
                    "boundaryId": "str",  # The id of the boundary object for which soil moisture
                      is being calculated. Required.
                    "imageFormat": "str",  # ImageFormat. Available value: TIF. Required. "TIF"
                    "imageResolution": 0.0,  # ImageResolution in meters. Available values: 10,
                      20, 60. Required.
                    "inferenceEndDateTime": "2020-02-20 00:00:00",  # Inference end date time for
                      soil moisture calculations. Required.
                    "inferenceStartDateTime": "2020-02-20 00:00:00",  # Inference start date time
                      for soil moisture calculations. Required.
                    "modelVersion": "str",  # The version of the soil moisture model to be run.
                      Required.
                    "partyId": "str",  # Party Id. Required.
                    "satelliteProvider": "str",  # Provider of satellite data. Available Value:
                      Microsoft. Required. "Microsoft"
                    "satelliteSource": "str",  # Source of satellite data. Available Value:
                      Sentinel_2_L2A. Required. Known values are: "Sentinel_2_L2A" and
                      "Sentinel_2_L1C".
                    "sensorDataModelId": "str",  # Sensor data model Id. Required.
                    "sensorDefinition": {
                        "maxProperty": "str",  # The measurement name for maximum measurement
                          value. Required.
                        "minProperty": "str",  # The measurement name for minimum measurement
                          value. Required.
                        "sensorMeasurement": "str"  # The measurement name for sensor measure
                          in sensorDataModel. Required.
                    },
                    "sensorPartnerId": "str",  # Sensor partner Id. Required.
                    "createdBy": "str",  # Optional. Created by user/tenant id.
                    "createdDateTime": "2020-02-20 00:00:00",  # Optional. Job created at
                      dateTime. Sample format: yyyy-MM-ddTHH:mm:ssZ.
                    "description": "str",  # Optional. Textual description of the resource.
                    "durationInSeconds": 0.0,  # Optional. Duration of the job in seconds.
                    "endTime": "2020-02-20 00:00:00",  # Optional. Job end time when available.
                      Sample format: yyyy-MM-ddTHH:mm:ssZ.
                    "errorCode": "str",  # Optional. Error Code when job failed.
                    "id": "str",  # Optional. Unique job id.
                    "lastActionDateTime": "2020-02-20 00:00:00",  # Optional. Job was last acted
                      upon at dateTime. Sample format: yyyy-MM-ddTHH:mm:ssZ.
                    "message": "str",  # Optional. Status message to capture more details of the
                      job.
                    "modifiedBy": "str",  # Optional. Modified by user/tenant id.
                    "name": "str",  # Optional. Name to identify resource.
                    "properties": {
                        "str": {}  # Optional. A collection of key value pairs that belongs
                          to the resource."nEach pair must not have a key greater than 50
                          characters"nand must not have a value greater than 150 characters."nNote: A
                          maximum of 25 key value pairs can be provided for a resource and only
                          string,"nnumeral and datetime (yyyy-MM-ddTHH:mm:ssZ) values are supported.
                    },
                    "startTime": "2020-02-20 00:00:00",  # Optional. Job start time when
                      available. Sample format: yyyy-MM-ddTHH:mm:ssZ.
                    "status": "str"  # Optional. Status of the job."nPossible values: 'Waiting',
                      'Running', 'Succeeded', 'Failed', 'Cancelled'.
                }

                # response body for status code(s): 202
                response == {
                    "boundaryId": "str",  # The id of the boundary object for which soil moisture
                      is being calculated. Required.
                    "imageFormat": "str",  # ImageFormat. Available value: TIF. Required. "TIF"
                    "imageResolution": 0.0,  # ImageResolution in meters. Available values: 10,
                      20, 60. Required.
                    "inferenceEndDateTime": "2020-02-20 00:00:00",  # Inference end date time for
                      soil moisture calculations. Required.
                    "inferenceStartDateTime": "2020-02-20 00:00:00",  # Inference start date time
                      for soil moisture calculations. Required.
                    "modelVersion": "str",  # The version of the soil moisture model to be run.
                      Required.
                    "partyId": "str",  # Party Id. Required.
                    "satelliteProvider": "str",  # Provider of satellite data. Available Value:
                      Microsoft. Required. "Microsoft"
                    "satelliteSource": "str",  # Source of satellite data. Available Value:
                      Sentinel_2_L2A. Required. Known values are: "Sentinel_2_L2A" and
                      "Sentinel_2_L1C".
                    "sensorDataModelId": "str",  # Sensor data model Id. Required.
                    "sensorDefinition": {
                        "maxProperty": "str",  # The measurement name for maximum measurement
                          value. Required.
                        "minProperty": "str",  # The measurement name for minimum measurement
                          value. Required.
                        "sensorMeasurement": "str"  # The measurement name for sensor measure
                          in sensorDataModel. Required.
                    },
                    "sensorPartnerId": "str",  # Sensor partner Id. Required.
                    "createdBy": "str",  # Optional. Created by user/tenant id.
                    "createdDateTime": "2020-02-20 00:00:00",  # Optional. Job created at
                      dateTime. Sample format: yyyy-MM-ddTHH:mm:ssZ.
                    "description": "str",  # Optional. Textual description of the resource.
                    "durationInSeconds": 0.0,  # Optional. Duration of the job in seconds.
                    "endTime": "2020-02-20 00:00:00",  # Optional. Job end time when available.
                      Sample format: yyyy-MM-ddTHH:mm:ssZ.
                    "errorCode": "str",  # Optional. Error Code when job failed.
                    "id": "str",  # Optional. Unique job id.
                    "lastActionDateTime": "2020-02-20 00:00:00",  # Optional. Job was last acted
                      upon at dateTime. Sample format: yyyy-MM-ddTHH:mm:ssZ.
                    "message": "str",  # Optional. Status message to capture more details of the
                      job.
                    "modifiedBy": "str",  # Optional. Modified by user/tenant id.
                    "name": "str",  # Optional. Name to identify resource.
                    "properties": {
                        "str": {}  # Optional. A collection of key value pairs that belongs
                          to the resource."nEach pair must not have a key greater than 50
                          characters"nand must not have a value greater than 150 characters."nNote: A
                          maximum of 25 key value pairs can be provided for a resource and only
                          string,"nnumeral and datetime (yyyy-MM-ddTHH:mm:ssZ) values are supported.
                    },
                    "startTime": "2020-02-20 00:00:00",  # Optional. Job start time when
                      available. Sample format: yyyy-MM-ddTHH:mm:ssZ.
                    "status": "str"  # Optional. Status of the job."nPossible values: 'Waiting',
                      'Running', 'Succeeded', 'Failed', 'Cancelled'.
                }
        """

    @overload
    def begin_create_soil_moisture_model_job(
        self, job_id: str, job: IO, *, content_type: str = "application/json", **kwargs: Any
    ) -> LROPoller[JSON]:
        """Create a SoilMoisture Model job.

        :param job_id: JobId provided by user. Required.
        :type job_id: str
        :param job: Job parameters supplied by user. Required.
        :type job: IO
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Default value is "application/json".
        :paramtype content_type: str
        :keyword str continuation_token: A continuation token to restart a poller from a saved state.
        :keyword polling: By default, your polling method will be LROBasePolling. Pass in False for
         this operation to not poll, or pass in your own initialized polling object for a personal
         polling strategy.
        :paramtype polling: bool or ~azure.core.polling.PollingMethod
        :keyword int polling_interval: Default waiting time between two polls for LRO operations if no
         Retry-After header is present.
        :return: An instance of LROPoller that returns JSON object
        :rtype: ~azure.core.polling.LROPoller[JSON]
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 202
                response == {
                    "boundaryId": "str",  # The id of the boundary object for which soil moisture
                      is being calculated. Required.
                    "imageFormat": "str",  # ImageFormat. Available value: TIF. Required. "TIF"
                    "imageResolution": 0.0,  # ImageResolution in meters. Available values: 10,
                      20, 60. Required.
                    "inferenceEndDateTime": "2020-02-20 00:00:00",  # Inference end date time for
                      soil moisture calculations. Required.
                    "inferenceStartDateTime": "2020-02-20 00:00:00",  # Inference start date time
                      for soil moisture calculations. Required.
                    "modelVersion": "str",  # The version of the soil moisture model to be run.
                      Required.
                    "partyId": "str",  # Party Id. Required.
                    "satelliteProvider": "str",  # Provider of satellite data. Available Value:
                      Microsoft. Required. "Microsoft"
                    "satelliteSource": "str",  # Source of satellite data. Available Value:
                      Sentinel_2_L2A. Required. Known values are: "Sentinel_2_L2A" and
                      "Sentinel_2_L1C".
                    "sensorDataModelId": "str",  # Sensor data model Id. Required.
                    "sensorDefinition": {
                        "maxProperty": "str",  # The measurement name for maximum measurement
                          value. Required.
                        "minProperty": "str",  # The measurement name for minimum measurement
                          value. Required.
                        "sensorMeasurement": "str"  # The measurement name for sensor measure
                          in sensorDataModel. Required.
                    },
                    "sensorPartnerId": "str",  # Sensor partner Id. Required.
                    "createdBy": "str",  # Optional. Created by user/tenant id.
                    "createdDateTime": "2020-02-20 00:00:00",  # Optional. Job created at
                      dateTime. Sample format: yyyy-MM-ddTHH:mm:ssZ.
                    "description": "str",  # Optional. Textual description of the resource.
                    "durationInSeconds": 0.0,  # Optional. Duration of the job in seconds.
                    "endTime": "2020-02-20 00:00:00",  # Optional. Job end time when available.
                      Sample format: yyyy-MM-ddTHH:mm:ssZ.
                    "errorCode": "str",  # Optional. Error Code when job failed.
                    "id": "str",  # Optional. Unique job id.
                    "lastActionDateTime": "2020-02-20 00:00:00",  # Optional. Job was last acted
                      upon at dateTime. Sample format: yyyy-MM-ddTHH:mm:ssZ.
                    "message": "str",  # Optional. Status message to capture more details of the
                      job.
                    "modifiedBy": "str",  # Optional. Modified by user/tenant id.
                    "name": "str",  # Optional. Name to identify resource.
                    "properties": {
                        "str": {}  # Optional. A collection of key value pairs that belongs
                          to the resource."nEach pair must not have a key greater than 50
                          characters"nand must not have a value greater than 150 characters."nNote: A
                          maximum of 25 key value pairs can be provided for a resource and only
                          string,"nnumeral and datetime (yyyy-MM-ddTHH:mm:ssZ) values are supported.
                    },
                    "startTime": "2020-02-20 00:00:00",  # Optional. Job start time when
                      available. Sample format: yyyy-MM-ddTHH:mm:ssZ.
                    "status": "str"  # Optional. Status of the job."nPossible values: 'Waiting',
                      'Running', 'Succeeded', 'Failed', 'Cancelled'.
                }
        """

    @distributed_trace
    def begin_create_soil_moisture_model_job(self, job_id: str, job: Union[JSON, IO], **kwargs: Any) -> LROPoller[JSON]:
        """Create a SoilMoisture Model job.

        :param job_id: JobId provided by user. Required.
        :type job_id: str
        :param job: Job parameters supplied by user. Is either a model type or a IO type. Required.
        :type job: JSON or IO
        :keyword content_type: Body Parameter content-type. Known values are: 'application/json'.
         Default value is None.
        :paramtype content_type: str
        :keyword str continuation_token: A continuation token to restart a poller from a saved state.
        :keyword polling: By default, your polling method will be LROBasePolling. Pass in False for
         this operation to not poll, or pass in your own initialized polling object for a personal
         polling strategy.
        :paramtype polling: bool or ~azure.core.polling.PollingMethod
        :keyword int polling_interval: Default waiting time between two polls for LRO operations if no
         Retry-After header is present.
        :return: An instance of LROPoller that returns JSON object
        :rtype: ~azure.core.polling.LROPoller[JSON]
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 202
                response == {
                    "boundaryId": "str",  # The id of the boundary object for which soil moisture
                      is being calculated. Required.
                    "imageFormat": "str",  # ImageFormat. Available value: TIF. Required. "TIF"
                    "imageResolution": 0.0,  # ImageResolution in meters. Available values: 10,
                      20, 60. Required.
                    "inferenceEndDateTime": "2020-02-20 00:00:00",  # Inference end date time for
                      soil moisture calculations. Required.
                    "inferenceStartDateTime": "2020-02-20 00:00:00",  # Inference start date time
                      for soil moisture calculations. Required.
                    "modelVersion": "str",  # The version of the soil moisture model to be run.
                      Required.
                    "partyId": "str",  # Party Id. Required.
                    "satelliteProvider": "str",  # Provider of satellite data. Available Value:
                      Microsoft. Required. "Microsoft"
                    "satelliteSource": "str",  # Source of satellite data. Available Value:
                      Sentinel_2_L2A. Required. Known values are: "Sentinel_2_L2A" and
                      "Sentinel_2_L1C".
                    "sensorDataModelId": "str",  # Sensor data model Id. Required.
                    "sensorDefinition": {
                        "maxProperty": "str",  # The measurement name for maximum measurement
                          value. Required.
                        "minProperty": "str",  # The measurement name for minimum measurement
                          value. Required.
                        "sensorMeasurement": "str"  # The measurement name for sensor measure
                          in sensorDataModel. Required.
                    },
                    "sensorPartnerId": "str",  # Sensor partner Id. Required.
                    "createdBy": "str",  # Optional. Created by user/tenant id.
                    "createdDateTime": "2020-02-20 00:00:00",  # Optional. Job created at
                      dateTime. Sample format: yyyy-MM-ddTHH:mm:ssZ.
                    "description": "str",  # Optional. Textual description of the resource.
                    "durationInSeconds": 0.0,  # Optional. Duration of the job in seconds.
                    "endTime": "2020-02-20 00:00:00",  # Optional. Job end time when available.
                      Sample format: yyyy-MM-ddTHH:mm:ssZ.
                    "errorCode": "str",  # Optional. Error Code when job failed.
                    "id": "str",  # Optional. Unique job id.
                    "lastActionDateTime": "2020-02-20 00:00:00",  # Optional. Job was last acted
                      upon at dateTime. Sample format: yyyy-MM-ddTHH:mm:ssZ.
                    "message": "str",  # Optional. Status message to capture more details of the
                      job.
                    "modifiedBy": "str",  # Optional. Modified by user/tenant id.
                    "name": "str",  # Optional. Name to identify resource.
                    "properties": {
                        "str": {}  # Optional. A collection of key value pairs that belongs
                          to the resource."nEach pair must not have a key greater than 50
                          characters"nand must not have a value greater than 150 characters."nNote: A
                          maximum of 25 key value pairs can be provided for a resource and only
                          string,"nnumeral and datetime (yyyy-MM-ddTHH:mm:ssZ) values are supported.
                    },
                    "startTime": "2020-02-20 00:00:00",  # Optional. Job start time when
                      available. Sample format: yyyy-MM-ddTHH:mm:ssZ.
                    "status": "str"  # Optional. Status of the job."nPossible values: 'Waiting',
                      'Running', 'Succeeded', 'Failed', 'Cancelled'.
                }
        """
        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type = kwargs.pop("content_type", _headers.pop("Content-Type", None))  # type: Optional[str]
        cls = kwargs.pop("cls", None)  # type: ClsType[JSON]
        polling = kwargs.pop("polling", True)  # type: Union[bool, PollingMethod]
        lro_delay = kwargs.pop("polling_interval", self._config.polling_interval)
        cont_token = kwargs.pop("continuation_token", None)  # type: Optional[str]
        if cont_token is None:
            raw_result = self._create_soil_moisture_model_job_initial(  # type: ignore
                job_id=job_id,
                job=job,
                content_type=content_type,
                cls=lambda x, y, z: x,
                headers=_headers,
                params=_params,
                **kwargs
            )
        kwargs.pop("error_map", None)

        def get_long_running_output(pipeline_response):
            response = pipeline_response.http_response
            if response.content:
                deserialized = response.json()
            else:
                deserialized = None
            if cls:
                return cls(pipeline_response, deserialized, {})
            return deserialized

        if polling is True:
            polling_method = cast(
                PollingMethod, LROBasePolling(lro_delay, lro_options={"final-state-via": "location"}, **kwargs)
            )  # type: PollingMethod
        elif polling is False:
            polling_method = cast(PollingMethod, NoPolling())
        else:
            polling_method = polling
        if cont_token:
            return LROPoller.from_continuation_token(
                polling_method=polling_method,
                continuation_token=cont_token,
                client=self._client,
                deserialization_callback=get_long_running_output,
            )
        return LROPoller(self._client, raw_result, get_long_running_output, polling_method)

    @distributed_trace
    def get_soil_moisture_model_job(self, job_id: str, **kwargs: Any) -> JSON:
        """Get SoilMoisture Model job's details.

        :param job_id: Id of the job. Required.
        :type job_id: str
        :return: JSON object
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "boundaryId": "str",  # The id of the boundary object for which soil moisture
                      is being calculated. Required.
                    "imageFormat": "str",  # ImageFormat. Available value: TIF. Required. "TIF"
                    "imageResolution": 0.0,  # ImageResolution in meters. Available values: 10,
                      20, 60. Required.
                    "inferenceEndDateTime": "2020-02-20 00:00:00",  # Inference end date time for
                      soil moisture calculations. Required.
                    "inferenceStartDateTime": "2020-02-20 00:00:00",  # Inference start date time
                      for soil moisture calculations. Required.
                    "modelVersion": "str",  # The version of the soil moisture model to be run.
                      Required.
                    "partyId": "str",  # Party Id. Required.
                    "satelliteProvider": "str",  # Provider of satellite data. Available Value:
                      Microsoft. Required. "Microsoft"
                    "satelliteSource": "str",  # Source of satellite data. Available Value:
                      Sentinel_2_L2A. Required. Known values are: "Sentinel_2_L2A" and
                      "Sentinel_2_L1C".
                    "sensorDataModelId": "str",  # Sensor data model Id. Required.
                    "sensorDefinition": {
                        "maxProperty": "str",  # The measurement name for maximum measurement
                          value. Required.
                        "minProperty": "str",  # The measurement name for minimum measurement
                          value. Required.
                        "sensorMeasurement": "str"  # The measurement name for sensor measure
                          in sensorDataModel. Required.
                    },
                    "sensorPartnerId": "str",  # Sensor partner Id. Required.
                    "createdBy": "str",  # Optional. Created by user/tenant id.
                    "createdDateTime": "2020-02-20 00:00:00",  # Optional. Job created at
                      dateTime. Sample format: yyyy-MM-ddTHH:mm:ssZ.
                    "description": "str",  # Optional. Textual description of the resource.
                    "durationInSeconds": 0.0,  # Optional. Duration of the job in seconds.
                    "endTime": "2020-02-20 00:00:00",  # Optional. Job end time when available.
                      Sample format: yyyy-MM-ddTHH:mm:ssZ.
                    "errorCode": "str",  # Optional. Error Code when job failed.
                    "id": "str",  # Optional. Unique job id.
                    "lastActionDateTime": "2020-02-20 00:00:00",  # Optional. Job was last acted
                      upon at dateTime. Sample format: yyyy-MM-ddTHH:mm:ssZ.
                    "message": "str",  # Optional. Status message to capture more details of the
                      job.
                    "modifiedBy": "str",  # Optional. Modified by user/tenant id.
                    "name": "str",  # Optional. Name to identify resource.
                    "properties": {
                        "str": {}  # Optional. A collection of key value pairs that belongs
                          to the resource."nEach pair must not have a key greater than 50
                          characters"nand must not have a value greater than 150 characters."nNote: A
                          maximum of 25 key value pairs can be provided for a resource and only
                          string,"nnumeral and datetime (yyyy-MM-ddTHH:mm:ssZ) values are supported.
                    },
                    "startTime": "2020-02-20 00:00:00",  # Optional. Job start time when
                      available. Sample format: yyyy-MM-ddTHH:mm:ssZ.
                    "status": "str"  # Optional. Status of the job."nPossible values: 'Waiting',
                      'Running', 'Succeeded', 'Failed', 'Cancelled'.
                }
        """
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls = kwargs.pop("cls", None)  # type: ClsType[JSON]

        request = build_model_inference_get_soil_moisture_model_job_request(
            job_id=job_id,
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        request.url = self._client.format_url(request.url)  # type: ignore

        pipeline_response = self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
            request, stream=False, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if response.content:
            deserialized = response.json()
        else:
            deserialized = None

        if cls:
            return cls(pipeline_response, cast(JSON, deserialized), {})

        return cast(JSON, deserialized)


class NutrientAnalysesOperations:
    """
    .. warning::
        **DO NOT** instantiate this class directly.

        Instead, you should access the following operations through
        :class:`~azure.agrifood.farming.FarmBeatsClient`'s
        :attr:`nutrient_analyses` attribute.
    """

    def __init__(self, *args, **kwargs):
        input_args = list(args)
        self._client = input_args.pop(0) if input_args else kwargs.pop("client")
        self._config = input_args.pop(0) if input_args else kwargs.pop("config")
        self._serialize = input_args.pop(0) if input_args else kwargs.pop("serializer")
        self._deserialize = input_args.pop(0) if input_args else kwargs.pop("deserializer")

    @distributed_trace
    def list(
        self,
        *,
        parent_type: Optional[str] = None,
        parent_ids: Optional[List[str]] = None,
        classifications: Optional[List[str]] = None,
        ids: Optional[List[str]] = None,
        names: Optional[List[str]] = None,
        property_filters: Optional[List[str]] = None,
        statuses: Optional[List[str]] = None,
        min_created_date_time: Optional[datetime.datetime] = None,
        max_created_date_time: Optional[datetime.datetime] = None,
        min_last_modified_date_time: Optional[datetime.datetime] = None,
        max_last_modified_date_time: Optional[datetime.datetime] = None,
        skip_token: Optional[str] = None,
        **kwargs: Any
    ) -> Iterable[JSON]:
        """Returns a paginated list of nutrient analysis resources across all parties.

        :keyword parent_type: Type of the parent it belongs to.
         i.e. PlantTissueAnalysis. Default value is None.
        :paramtype parent_type: str
        :keyword parent_ids: Parent ids of the resource. Default value is None.
        :paramtype parent_ids: list[str]
        :keyword classifications: Classifications for nutrient analyses. Default value is None.
        :paramtype classifications: list[str]
        :keyword ids: Ids of the resource. Default value is None.
        :paramtype ids: list[str]
        :keyword names: Names of the resource. Default value is None.
        :paramtype names: list[str]
        :keyword property_filters: Filters on key-value pairs within the Properties object.
         eg. "{testKey} eq {testValue}". Default value is None.
        :paramtype property_filters: list[str]
        :keyword statuses: Statuses of the resource. Default value is None.
        :paramtype statuses: list[str]
        :keyword min_created_date_time: Minimum creation date of resource (inclusive). Default value is
         None.
        :paramtype min_created_date_time: ~datetime.datetime
        :keyword max_created_date_time: Maximum creation date of resource (inclusive). Default value is
         None.
        :paramtype max_created_date_time: ~datetime.datetime
        :keyword min_last_modified_date_time: Minimum last modified date of resource (inclusive).
         Default value is None.
        :paramtype min_last_modified_date_time: ~datetime.datetime
        :keyword max_last_modified_date_time: Maximum last modified date of resource (inclusive).
         Default value is None.
        :paramtype max_last_modified_date_time: ~datetime.datetime
        :keyword skip_token: Skip token for getting next set of results. Default value is None.
        :paramtype skip_token: str
        :return: An iterator like instance of JSON object
        :rtype: ~azure.core.paging.ItemPaged[JSON]
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "classification": "str",  # Optional. Classification for this nutrient
                      analysis.
                    "createdBy": "str",  # Optional. Created by user/tenant id.
                    "createdDateTime": "2020-02-20 00:00:00",  # Optional. Date-time when
                      resource was created, sample format: yyyy-MM-ddTHH:mm:ssZ.
                    "description": "str",  # Optional. Textual description of the resource.
                    "eTag": "str",  # Optional. The ETag value to implement optimistic
                      concurrency.
                    "id": "str",  # Optional. Unique resource ID.
                    "modifiedBy": "str",  # Optional. Modified by user/tenant id.
                    "modifiedDateTime": "2020-02-20 00:00:00",  # Optional. Date-time when
                      resource was last modified, sample format: yyyy-MM-ddTHH:mm:ssZ.
                    "name": "str",  # Optional. Name to identify resource.
                    "parentId": "str",  # Optional. Parent id for this nutrient analysis.
                    "parentType": "str",  # Optional. Parent type for this nutrient
                      analysis."ni.e. PlantTissueAnalysis. "PlantTissueAnalysis"
                    "partyId": "str",  # Optional. Party id for this nutrient analysis.
                    "products": [
                        {
                            "instruction": "str",  # Optional. Instruction of the
                              resource.
                            "product": "str",  # Optional. Product of the resource.
                            "rate": "str"  # Optional. Rate of the product.
                        }
                    ],
                    "properties": {
                        "str": {}  # Optional. A collection of key value pairs that belongs
                          to the resource."nEach pair must not have a key greater than 50
                          characters"nand must not have a value greater than 150 characters."nNote: A
                          maximum of 25 key value pairs can be provided for a resource and only
                          string,"nnumeral and datetime (yyyy-MM-ddTHH:mm:ssZ) values are supported.
                    },
                    "recommendation": "str",  # Optional. Recommendation for this nutrient
                      analysis.
                    "referenceValueHigh": 0.0,  # Optional. Reference value high for this
                      nutrient analysis.
                    "referenceValueLow": 0.0,  # Optional. Reference value low for this nutrient
                      analysis.
                    "source": "str",  # Optional. Source of the resource.
                    "status": "str",  # Optional. Status of the resource.
                    "unit": "str",  # Optional. Unit for this nutrient analysis.
                    "value": 0.0  # Optional. Value for this nutrient analysis.
                }
        """
        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls = kwargs.pop("cls", None)  # type: ClsType[JSON]

        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        def prepare_request(next_link=None):
            if not next_link:

                request = build_nutrient_analyses_list_request(
                    parent_type=parent_type,
                    parent_ids=parent_ids,
                    classifications=classifications,
                    ids=ids,
                    names=names,
                    property_filters=property_filters,
                    statuses=statuses,
                    min_created_date_time=min_created_date_time,
                    max_created_date_time=max_created_date_time,
                    min_last_modified_date_time=min_last_modified_date_time,
                    max_last_modified_date_time=max_last_modified_date_time,
                    skip_token=skip_token,
                    api_version=self._config.api_version,
                    headers=_headers,
                    params=_params,
                )
                request.url = self._client.format_url(request.url)  # type: ignore

            else:
                # make call to next link with the client's api-version
                _parsed_next_link = urlparse(next_link)
                _next_request_params = case_insensitive_dict(parse_qs(_parsed_next_link.query))
                _next_request_params["api-version"] = self._config.api_version
                request = HttpRequest("GET", urljoin(next_link, _parsed_next_link.path), params=_next_request_params)
                request.url = self._client.format_url(request.url)  # type: ignore

            return request

        def extract_data(pipeline_response):
            deserialized = pipeline_response.http_response.json()
            list_of_elem = deserialized["value"]
            if cls:
                list_of_elem = cls(list_of_elem)
            return deserialized.get("nextLink", None), iter(list_of_elem)

        def get_next(next_link=None):
            request = prepare_request(next_link)

            pipeline_response = self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
                request, stream=False, **kwargs
            )
            response = pipeline_response.http_response

            if response.status_code not in [200]:
                map_error(status_code=response.status_code, response=response, error_map=error_map)
                raise HttpResponseError(response=response)

            return pipeline_response

        return ItemPaged(get_next, extract_data)

    @distributed_trace
    def list_by_party_id(
        self,
        party_id: str,
        *,
        parent_type: Optional[str] = None,
        parent_ids: Optional[List[str]] = None,
        classifications: Optional[List[str]] = None,
        ids: Optional[List[str]] = None,
        names: Optional[List[str]] = None,
        property_filters: Optional[List[str]] = None,
        statuses: Optional[List[str]] = None,
        min_created_date_time: Optional[datetime.datetime] = None,
        max_created_date_time: Optional[datetime.datetime] = None,
        min_last_modified_date_time: Optional[datetime.datetime] = None,
        max_last_modified_date_time: Optional[datetime.datetime] = None,
        skip_token: Optional[str] = None,
        **kwargs: Any
    ) -> Iterable[JSON]:
        """Returns a paginated list of nutrient analysis resources under a particular party.

        :param party_id: Id of the associated party. Required.
        :type party_id: str
        :keyword parent_type: Type of the parent it belongs to.
         i.e. PlantTissueAnalysis. Default value is None.
        :paramtype parent_type: str
        :keyword parent_ids: Parent ids of the resource. Default value is None.
        :paramtype parent_ids: list[str]
        :keyword classifications: Classifications for nutrient analyses. Default value is None.
        :paramtype classifications: list[str]
        :keyword ids: Ids of the resource. Default value is None.
        :paramtype ids: list[str]
        :keyword names: Names of the resource. Default value is None.
        :paramtype names: list[str]
        :keyword property_filters: Filters on key-value pairs within the Properties object.
         eg. "{testKey} eq {testValue}". Default value is None.
        :paramtype property_filters: list[str]
        :keyword statuses: Statuses of the resource. Default value is None.
        :paramtype statuses: list[str]
        :keyword min_created_date_time: Minimum creation date of resource (inclusive). Default value is
         None.
        :paramtype min_created_date_time: ~datetime.datetime
        :keyword max_created_date_time: Maximum creation date of resource (inclusive). Default value is
         None.
        :paramtype max_created_date_time: ~datetime.datetime
        :keyword min_last_modified_date_time: Minimum last modified date of resource (inclusive).
         Default value is None.
        :paramtype min_last_modified_date_time: ~datetime.datetime
        :keyword max_last_modified_date_time: Maximum last modified date of resource (inclusive).
         Default value is None.
        :paramtype max_last_modified_date_time: ~datetime.datetime
        :keyword skip_token: Skip token for getting next set of results. Default value is None.
        :paramtype skip_token: str
        :return: An iterator like instance of JSON object
        :rtype: ~azure.core.paging.ItemPaged[JSON]
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "classification": "str",  # Optional. Classification for this nutrient
                      analysis.
                    "createdBy": "str",  # Optional. Created by user/tenant id.
                    "createdDateTime": "2020-02-20 00:00:00",  # Optional. Date-time when
                      resource was created, sample format: yyyy-MM-ddTHH:mm:ssZ.
                    "description": "str",  # Optional. Textual description of the resource.
                    "eTag": "str",  # Optional. The ETag value to implement optimistic
                      concurrency.
                    "id": "str",  # Optional. Unique resource ID.
                    "modifiedBy": "str",  # Optional. Modified by user/tenant id.
                    "modifiedDateTime": "2020-02-20 00:00:00",  # Optional. Date-time when
                      resource was last modified, sample format: yyyy-MM-ddTHH:mm:ssZ.
                    "name": "str",  # Optional. Name to identify resource.
                    "parentId": "str",  # Optional. Parent id for this nutrient analysis.
                    "parentType": "str",  # Optional. Parent type for this nutrient
                      analysis."ni.e. PlantTissueAnalysis. "PlantTissueAnalysis"
                    "partyId": "str",  # Optional. Party id for this nutrient analysis.
                    "products": [
                        {
                            "instruction": "str",  # Optional. Instruction of the
                              resource.
                            "product": "str",  # Optional. Product of the resource.
                            "rate": "str"  # Optional. Rate of the product.
                        }
                    ],
                    "properties": {
                        "str": {}  # Optional. A collection of key value pairs that belongs
                          to the resource."nEach pair must not have a key greater than 50
                          characters"nand must not have a value greater than 150 characters."nNote: A
                          maximum of 25 key value pairs can be provided for a resource and only
                          string,"nnumeral and datetime (yyyy-MM-ddTHH:mm:ssZ) values are supported.
                    },
                    "recommendation": "str",  # Optional. Recommendation for this nutrient
                      analysis.
                    "referenceValueHigh": 0.0,  # Optional. Reference value high for this
                      nutrient analysis.
                    "referenceValueLow": 0.0,  # Optional. Reference value low for this nutrient
                      analysis.
                    "source": "str",  # Optional. Source of the resource.
                    "status": "str",  # Optional. Status of the resource.
                    "unit": "str",  # Optional. Unit for this nutrient analysis.
                    "value": 0.0  # Optional. Value for this nutrient analysis.
                }
        """
        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls = kwargs.pop("cls", None)  # type: ClsType[JSON]

        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        def prepare_request(next_link=None):
            if not next_link:

                request = build_nutrient_analyses_list_by_party_id_request(
                    party_id=party_id,
                    parent_type=parent_type,
                    parent_ids=parent_ids,
                    classifications=classifications,
                    ids=ids,
                    names=names,
                    property_filters=property_filters,
                    statuses=statuses,
                    min_created_date_time=min_created_date_time,
                    max_created_date_time=max_created_date_time,
                    min_last_modified_date_time=min_last_modified_date_time,
                    max_last_modified_date_time=max_last_modified_date_time,
                    skip_token=skip_token,
                    api_version=self._config.api_version,
                    headers=_headers,
                    params=_params,
                )
                request.url = self._client.format_url(request.url)  # type: ignore

            else:
                # make call to next link with the client's api-version
                _parsed_next_link = urlparse(next_link)
                _next_request_params = case_insensitive_dict(parse_qs(_parsed_next_link.query))
                _next_request_params["api-version"] = self._config.api_version
                request = HttpRequest("GET", urljoin(next_link, _parsed_next_link.path), params=_next_request_params)
                request.url = self._client.format_url(request.url)  # type: ignore

            return request

        def extract_data(pipeline_response):
            deserialized = pipeline_response.http_response.json()
            list_of_elem = deserialized["value"]
            if cls:
                list_of_elem = cls(list_of_elem)
            return deserialized.get("nextLink", None), iter(list_of_elem)

        def get_next(next_link=None):
            request = prepare_request(next_link)

            pipeline_response = self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
                request, stream=False, **kwargs
            )
            response = pipeline_response.http_response

            if response.status_code not in [200]:
                map_error(status_code=response.status_code, response=response, error_map=error_map)
                raise HttpResponseError(response=response)

            return pipeline_response

        return ItemPaged(get_next, extract_data)

    @distributed_trace
    def get(self, party_id: str, nutrient_analysis_id: str, **kwargs: Any) -> JSON:
        """Gets a specified nutrient analysis resource under a particular party.

        :param party_id: Id of the associated party. Required.
        :type party_id: str
        :param nutrient_analysis_id: Id of the nutrient analysis. Required.
        :type nutrient_analysis_id: str
        :return: JSON object
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "classification": "str",  # Optional. Classification for this nutrient
                      analysis.
                    "createdBy": "str",  # Optional. Created by user/tenant id.
                    "createdDateTime": "2020-02-20 00:00:00",  # Optional. Date-time when
                      resource was created, sample format: yyyy-MM-ddTHH:mm:ssZ.
                    "description": "str",  # Optional. Textual description of the resource.
                    "eTag": "str",  # Optional. The ETag value to implement optimistic
                      concurrency.
                    "id": "str",  # Optional. Unique resource ID.
                    "modifiedBy": "str",  # Optional. Modified by user/tenant id.
                    "modifiedDateTime": "2020-02-20 00:00:00",  # Optional. Date-time when
                      resource was last modified, sample format: yyyy-MM-ddTHH:mm:ssZ.
                    "name": "str",  # Optional. Name to identify resource.
                    "parentId": "str",  # Optional. Parent id for this nutrient analysis.
                    "parentType": "str",  # Optional. Parent type for this nutrient
                      analysis."ni.e. PlantTissueAnalysis. "PlantTissueAnalysis"
                    "partyId": "str",  # Optional. Party id for this nutrient analysis.
                    "products": [
                        {
                            "instruction": "str",  # Optional. Instruction of the
                              resource.
                            "product": "str",  # Optional. Product of the resource.
                            "rate": "str"  # Optional. Rate of the product.
                        }
                    ],
                    "properties": {
                        "str": {}  # Optional. A collection of key value pairs that belongs
                          to the resource."nEach pair must not have a key greater than 50
                          characters"nand must not have a value greater than 150 characters."nNote: A
                          maximum of 25 key value pairs can be provided for a resource and only
                          string,"nnumeral and datetime (yyyy-MM-ddTHH:mm:ssZ) values are supported.
                    },
                    "recommendation": "str",  # Optional. Recommendation for this nutrient
                      analysis.
                    "referenceValueHigh": 0.0,  # Optional. Reference value high for this
                      nutrient analysis.
                    "referenceValueLow": 0.0,  # Optional. Reference value low for this nutrient
                      analysis.
                    "source": "str",  # Optional. Source of the resource.
                    "status": "str",  # Optional. Status of the resource.
                    "unit": "str",  # Optional. Unit for this nutrient analysis.
                    "value": 0.0  # Optional. Value for this nutrient analysis.
                }
        """
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls = kwargs.pop("cls", None)  # type: ClsType[JSON]

        request = build_nutrient_analyses_get_request(
            party_id=party_id,
            nutrient_analysis_id=nutrient_analysis_id,
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        request.url = self._client.format_url(request.url)  # type: ignore

        pipeline_response = self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
            request, stream=False, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if response.content:
            deserialized = response.json()
        else:
            deserialized = None

        if cls:
            return cls(pipeline_response, cast(JSON, deserialized), {})

        return cast(JSON, deserialized)

    @overload
    def create_or_update(
        self,
        party_id: str,
        nutrient_analysis_id: str,
        nutrient_analysis: JSON,
        *,
        content_type: str = "application/merge-patch+json",
        **kwargs: Any
    ) -> JSON:
        """Creates or updates a nutrient analysis resource.

        :param party_id: Id of the party resource. Required.
        :type party_id: str
        :param nutrient_analysis_id: Id of the nutrient analysis resource. Required.
        :type nutrient_analysis_id: str
        :param nutrient_analysis: NutrientAnalysis resource payload to create or update. Required.
        :type nutrient_analysis: JSON
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/merge-patch+json".
        :paramtype content_type: str
        :return: JSON object
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                nutrient_analysis = {
                    "classification": "str",  # Optional. Classification for this nutrient
                      analysis.
                    "createdBy": "str",  # Optional. Created by user/tenant id.
                    "createdDateTime": "2020-02-20 00:00:00",  # Optional. Date-time when
                      resource was created, sample format: yyyy-MM-ddTHH:mm:ssZ.
                    "description": "str",  # Optional. Textual description of the resource.
                    "eTag": "str",  # Optional. The ETag value to implement optimistic
                      concurrency.
                    "id": "str",  # Optional. Unique resource ID.
                    "modifiedBy": "str",  # Optional. Modified by user/tenant id.
                    "modifiedDateTime": "2020-02-20 00:00:00",  # Optional. Date-time when
                      resource was last modified, sample format: yyyy-MM-ddTHH:mm:ssZ.
                    "name": "str",  # Optional. Name to identify resource.
                    "parentId": "str",  # Optional. Parent id for this nutrient analysis.
                    "parentType": "str",  # Optional. Parent type for this nutrient
                      analysis."ni.e. PlantTissueAnalysis. "PlantTissueAnalysis"
                    "partyId": "str",  # Optional. Party id for this nutrient analysis.
                    "products": [
                        {
                            "instruction": "str",  # Optional. Instruction of the
                              resource.
                            "product": "str",  # Optional. Product of the resource.
                            "rate": "str"  # Optional. Rate of the product.
                        }
                    ],
                    "properties": {
                        "str": {}  # Optional. A collection of key value pairs that belongs
                          to the resource."nEach pair must not have a key greater than 50
                          characters"nand must not have a value greater than 150 characters."nNote: A
                          maximum of 25 key value pairs can be provided for a resource and only
                          string,"nnumeral and datetime (yyyy-MM-ddTHH:mm:ssZ) values are supported.
                    },
                    "recommendation": "str",  # Optional. Recommendation for this nutrient
                      analysis.
                    "referenceValueHigh": 0.0,  # Optional. Reference value high for this
                      nutrient analysis.
                    "referenceValueLow": 0.0,  # Optional. Reference value low for this nutrient
                      analysis.
                    "source": "str",  # Optional. Source of the resource.
                    "status": "str",  # Optional. Status of the resource.
                    "unit": "str",  # Optional. Unit for this nutrient analysis.
                    "value": 0.0  # Optional. Value for this nutrient analysis.
                }

                # response body for status code(s): 200, 201
                response == {
                    "classification": "str",  # Optional. Classification for this nutrient
                      analysis.
                    "createdBy": "str",  # Optional. Created by user/tenant id.
                    "createdDateTime": "2020-02-20 00:00:00",  # Optional. Date-time when
                      resource was created, sample format: yyyy-MM-ddTHH:mm:ssZ.
                    "description": "str",  # Optional. Textual description of the resource.
                    "eTag": "str",  # Optional. The ETag value to implement optimistic
                      concurrency.
                    "id": "str",  # Optional. Unique resource ID.
                    "modifiedBy": "str",  # Optional. Modified by user/tenant id.
                    "modifiedDateTime": "2020-02-20 00:00:00",  # Optional. Date-time when
                      resource was last modified, sample format: yyyy-MM-ddTHH:mm:ssZ.
                    "name": "str",  # Optional. Name to identify resource.
                    "parentId": "str",  # Optional. Parent id for this nutrient analysis.
                    "parentType": "str",  # Optional. Parent type for this nutrient
                      analysis."ni.e. PlantTissueAnalysis. "PlantTissueAnalysis"
                    "partyId": "str",  # Optional. Party id for this nutrient analysis.
                    "products": [
                        {
                            "instruction": "str",  # Optional. Instruction of the
                              resource.
                            "product": "str",  # Optional. Product of the resource.
                            "rate": "str"  # Optional. Rate of the product.
                        }
                    ],
                    "properties": {
                        "str": {}  # Optional. A collection of key value pairs that belongs
                          to the resource."nEach pair must not have a key greater than 50
                          characters"nand must not have a value greater than 150 characters."nNote: A
                          maximum of 25 key value pairs can be provided for a resource and only
                          string,"nnumeral and datetime (yyyy-MM-ddTHH:mm:ssZ) values are supported.
                    },
                    "recommendation": "str",  # Optional. Recommendation for this nutrient
                      analysis.
                    "referenceValueHigh": 0.0,  # Optional. Reference value high for this
                      nutrient analysis.
                    "referenceValueLow": 0.0,  # Optional. Reference value low for this nutrient
                      analysis.
                    "source": "str",  # Optional. Source of the resource.
                    "status": "str",  # Optional. Status of the resource.
                    "unit": "str",  # Optional. Unit for this nutrient analysis.
                    "value": 0.0  # Optional. Value for this nutrient analysis.
                }
        """

    @overload
    def create_or_update(
        self,
        party_id: str,
        nutrient_analysis_id: str,
        nutrient_analysis: IO,
        *,
        content_type: str = "application/merge-patch+json",
        **kwargs: Any
    ) -> JSON:
        """Creates or updates a nutrient analysis resource.

        :param party_id: Id of the party resource. Required.
        :type party_id: str
        :param nutrient_analysis_id: Id of the nutrient analysis resource. Required.
        :type nutrient_analysis_id: str
        :param nutrient_analysis: NutrientAnalysis resource payload to create or update. Required.
        :type nutrient_analysis: IO
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Default value is "application/merge-patch+json".
        :paramtype content_type: str
        :return: JSON object
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200, 201
                response == {
                    "classification": "str",  # Optional. Classification for this nutrient
                      analysis.
                    "createdBy": "str",  # Optional. Created by user/tenant id.
                    "createdDateTime": "2020-02-20 00:00:00",  # Optional. Date-time when
                      resource was created, sample format: yyyy-MM-ddTHH:mm:ssZ.
                    "description": "str",  # Optional. Textual description of the resource.
                    "eTag": "str",  # Optional. The ETag value to implement optimistic
                      concurrency.
                    "id": "str",  # Optional. Unique resource ID.
                    "modifiedBy": "str",  # Optional. Modified by user/tenant id.
                    "modifiedDateTime": "2020-02-20 00:00:00",  # Optional. Date-time when
                      resource was last modified, sample format: yyyy-MM-ddTHH:mm:ssZ.
                    "name": "str",  # Optional. Name to identify resource.
                    "parentId": "str",  # Optional. Parent id for this nutrient analysis.
                    "parentType": "str",  # Optional. Parent type for this nutrient
                      analysis."ni.e. PlantTissueAnalysis. "PlantTissueAnalysis"
                    "partyId": "str",  # Optional. Party id for this nutrient analysis.
                    "products": [
                        {
                            "instruction": "str",  # Optional. Instruction of the
                              resource.
                            "product": "str",  # Optional. Product of the resource.
                            "rate": "str"  # Optional. Rate of the product.
                        }
                    ],
                    "properties": {
                        "str": {}  # Optional. A collection of key value pairs that belongs
                          to the resource."nEach pair must not have a key greater than 50
                          characters"nand must not have a value greater than 150 characters."nNote: A
                          maximum of 25 key value pairs can be provided for a resource and only
                          string,"nnumeral and datetime (yyyy-MM-ddTHH:mm:ssZ) values are supported.
                    },
                    "recommendation": "str",  # Optional. Recommendation for this nutrient
                      analysis.
                    "referenceValueHigh": 0.0,  # Optional. Reference value high for this
                      nutrient analysis.
                    "referenceValueLow": 0.0,  # Optional. Reference value low for this nutrient
                      analysis.
                    "source": "str",  # Optional. Source of the resource.
                    "status": "str",  # Optional. Status of the resource.
                    "unit": "str",  # Optional. Unit for this nutrient analysis.
                    "value": 0.0  # Optional. Value for this nutrient analysis.
                }
        """

    @distributed_trace
    def create_or_update(
        self, party_id: str, nutrient_analysis_id: str, nutrient_analysis: Union[JSON, IO], **kwargs: Any
    ) -> JSON:
        """Creates or updates a nutrient analysis resource.

        :param party_id: Id of the party resource. Required.
        :type party_id: str
        :param nutrient_analysis_id: Id of the nutrient analysis resource. Required.
        :type nutrient_analysis_id: str
        :param nutrient_analysis: NutrientAnalysis resource payload to create or update. Is either a
         model type or a IO type. Required.
        :type nutrient_analysis: JSON or IO
        :keyword content_type: Body Parameter content-type. Known values are:
         'application/merge-patch+json'. Default value is None.
        :paramtype content_type: str
        :return: JSON object
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200, 201
                response == {
                    "classification": "str",  # Optional. Classification for this nutrient
                      analysis.
                    "createdBy": "str",  # Optional. Created by user/tenant id.
                    "createdDateTime": "2020-02-20 00:00:00",  # Optional. Date-time when
                      resource was created, sample format: yyyy-MM-ddTHH:mm:ssZ.
                    "description": "str",  # Optional. Textual description of the resource.
                    "eTag": "str",  # Optional. The ETag value to implement optimistic
                      concurrency.
                    "id": "str",  # Optional. Unique resource ID.
                    "modifiedBy": "str",  # Optional. Modified by user/tenant id.
                    "modifiedDateTime": "2020-02-20 00:00:00",  # Optional. Date-time when
                      resource was last modified, sample format: yyyy-MM-ddTHH:mm:ssZ.
                    "name": "str",  # Optional. Name to identify resource.
                    "parentId": "str",  # Optional. Parent id for this nutrient analysis.
                    "parentType": "str",  # Optional. Parent type for this nutrient
                      analysis."ni.e. PlantTissueAnalysis. "PlantTissueAnalysis"
                    "partyId": "str",  # Optional. Party id for this nutrient analysis.
                    "products": [
                        {
                            "instruction": "str",  # Optional. Instruction of the
                              resource.
                            "product": "str",  # Optional. Product of the resource.
                            "rate": "str"  # Optional. Rate of the product.
                        }
                    ],
                    "properties": {
                        "str": {}  # Optional. A collection of key value pairs that belongs
                          to the resource."nEach pair must not have a key greater than 50
                          characters"nand must not have a value greater than 150 characters."nNote: A
                          maximum of 25 key value pairs can be provided for a resource and only
                          string,"nnumeral and datetime (yyyy-MM-ddTHH:mm:ssZ) values are supported.
                    },
                    "recommendation": "str",  # Optional. Recommendation for this nutrient
                      analysis.
                    "referenceValueHigh": 0.0,  # Optional. Reference value high for this
                      nutrient analysis.
                    "referenceValueLow": 0.0,  # Optional. Reference value low for this nutrient
                      analysis.
                    "source": "str",  # Optional. Source of the resource.
                    "status": "str",  # Optional. Status of the resource.
                    "unit": "str",  # Optional. Unit for this nutrient analysis.
                    "value": 0.0  # Optional. Value for this nutrient analysis.
                }
        """
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type = kwargs.pop("content_type", _headers.pop("Content-Type", None))  # type: Optional[str]
        cls = kwargs.pop("cls", None)  # type: ClsType[JSON]

        content_type = content_type or "application/merge-patch+json"
        _json = None
        _content = None
        if isinstance(nutrient_analysis, (IO, bytes)):
            _content = nutrient_analysis
        else:
            _json = nutrient_analysis

        request = build_nutrient_analyses_create_or_update_request(
            party_id=party_id,
            nutrient_analysis_id=nutrient_analysis_id,
            content_type=content_type,
            api_version=self._config.api_version,
            json=_json,
            content=_content,
            headers=_headers,
            params=_params,
        )
        request.url = self._client.format_url(request.url)  # type: ignore

        pipeline_response = self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
            request, stream=False, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200, 201]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if response.status_code == 200:
            if response.content:
                deserialized = response.json()
            else:
                deserialized = None

        if response.status_code == 201:
            if response.content:
                deserialized = response.json()
            else:
                deserialized = None

        if cls:
            return cls(pipeline_response, cast(JSON, deserialized), {})

        return cast(JSON, deserialized)

    @distributed_trace
    def delete(  # pylint: disable=inconsistent-return-statements
        self, party_id: str, nutrient_analysis_id: str, **kwargs: Any
    ) -> None:
        """Deletes a specified nutrient analysis resource under a particular party.

        :param party_id: Id of the party. Required.
        :type party_id: str
        :param nutrient_analysis_id: Id of the nutrient analysis. Required.
        :type nutrient_analysis_id: str
        :return: None
        :rtype: None
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls = kwargs.pop("cls", None)  # type: ClsType[None]

        request = build_nutrient_analyses_delete_request(
            party_id=party_id,
            nutrient_analysis_id=nutrient_analysis_id,
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        request.url = self._client.format_url(request.url)  # type: ignore

        pipeline_response = self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
            request, stream=False, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [204]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if cls:
            return cls(pipeline_response, None, {})


class OAuthProvidersOperations:
    """
    .. warning::
        **DO NOT** instantiate this class directly.

        Instead, you should access the following operations through
        :class:`~azure.agrifood.farming.FarmBeatsClient`'s
        :attr:`oauth_providers` attribute.
    """

    def __init__(self, *args, **kwargs):
        input_args = list(args)
        self._client = input_args.pop(0) if input_args else kwargs.pop("client")
        self._config = input_args.pop(0) if input_args else kwargs.pop("config")
        self._serialize = input_args.pop(0) if input_args else kwargs.pop("serializer")
        self._deserialize = input_args.pop(0) if input_args else kwargs.pop("deserializer")

    @distributed_trace
    def list(
        self,
        *,
        ids: Optional[List[str]] = None,
        names: Optional[List[str]] = None,
        property_filters: Optional[List[str]] = None,
        statuses: Optional[List[str]] = None,
        min_created_date_time: Optional[datetime.datetime] = None,
        max_created_date_time: Optional[datetime.datetime] = None,
        min_last_modified_date_time: Optional[datetime.datetime] = None,
        max_last_modified_date_time: Optional[datetime.datetime] = None,
        skip_token: Optional[str] = None,
        **kwargs: Any
    ) -> Iterable[JSON]:
        """Returns a paginated list of oauthProvider resources.

        :keyword ids: Ids of the resource. Default value is None.
        :paramtype ids: list[str]
        :keyword names: Names of the resource. Default value is None.
        :paramtype names: list[str]
        :keyword property_filters: Filters on key-value pairs within the Properties object.
         eg. "{testKey} eq {testValue}". Default value is None.
        :paramtype property_filters: list[str]
        :keyword statuses: Statuses of the resource. Default value is None.
        :paramtype statuses: list[str]
        :keyword min_created_date_time: Minimum creation date of resource (inclusive). Default value is
         None.
        :paramtype min_created_date_time: ~datetime.datetime
        :keyword max_created_date_time: Maximum creation date of resource (inclusive). Default value is
         None.
        :paramtype max_created_date_time: ~datetime.datetime
        :keyword min_last_modified_date_time: Minimum last modified date of resource (inclusive).
         Default value is None.
        :paramtype min_last_modified_date_time: ~datetime.datetime
        :keyword max_last_modified_date_time: Maximum last modified date of resource (inclusive).
         Default value is None.
        :paramtype max_last_modified_date_time: ~datetime.datetime
        :keyword skip_token: Skip token for getting next set of results. Default value is None.
        :paramtype skip_token: str
        :return: An iterator like instance of JSON object
        :rtype: ~azure.core.paging.ItemPaged[JSON]
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "apiKey": "str",  # Optional. OAuth Api key for given Provider."nNote:
                      currently Applicable to Climate provider. Won't be sent in response.
                    "appId": "str",  # Optional. OAuth App Id for given OAuth Provider.
                    "appSecret": "str",  # Optional. OAuth App secret for given Provider."nNote:
                      Won't be sent in response.
                    "createdBy": "str",  # Optional. Created by user/tenant id.
                    "createdDateTime": "2020-02-20 00:00:00",  # Optional. Date-time when
                      resource was created, sample format: yyyy-MM-ddTHH:mm:ssZ.
                    "description": "str",  # Optional. Textual description of the resource.
                    "eTag": "str",  # Optional. The ETag value to implement optimistic
                      concurrency.
                    "id": "str",  # Optional. Unique OAuth provider ID.
                    "isProductionApp": False,  # Optional. Default value is False. An optional
                      flag to determine if the App is ready to be used for Production scenarios in the
                      provider side or not. (Default value: false)"nNote: Currently applicable for
                      JohnDeere.
                    "modifiedBy": "str",  # Optional. Modified by user/tenant id.
                    "modifiedDateTime": "2020-02-20 00:00:00",  # Optional. Date-time when
                      resource was last modified, sample format: yyyy-MM-ddTHH:mm:ssZ.
                    "name": "str",  # Optional. Name to identify resource.
                    "properties": {
                        "str": {}  # Optional. A collection of key value pairs that belongs
                          to the resource."nEach pair must not have a key greater than 50
                          characters"nand must not have a value greater than 150 characters."nNote: A
                          maximum of 25 key value pairs can be provided for a resource and"nonly
                          string, numeral and datetime (yyyy-MM-ddTHH:mm:ssZ) values are supported.
                    }
                }
        """
        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls = kwargs.pop("cls", None)  # type: ClsType[JSON]

        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        def prepare_request(next_link=None):
            if not next_link:

                request = build_oauth_providers_list_request(
                    ids=ids,
                    names=names,
                    property_filters=property_filters,
                    statuses=statuses,
                    min_created_date_time=min_created_date_time,
                    max_created_date_time=max_created_date_time,
                    min_last_modified_date_time=min_last_modified_date_time,
                    max_last_modified_date_time=max_last_modified_date_time,
                    skip_token=skip_token,
                    api_version=self._config.api_version,
                    headers=_headers,
                    params=_params,
                )
                request.url = self._client.format_url(request.url)  # type: ignore

            else:
                # make call to next link with the client's api-version
                _parsed_next_link = urlparse(next_link)
                _next_request_params = case_insensitive_dict(parse_qs(_parsed_next_link.query))
                _next_request_params["api-version"] = self._config.api_version
                request = HttpRequest("GET", urljoin(next_link, _parsed_next_link.path), params=_next_request_params)
                request.url = self._client.format_url(request.url)  # type: ignore

            return request

        def extract_data(pipeline_response):
            deserialized = pipeline_response.http_response.json()
            list_of_elem = deserialized["value"]
            if cls:
                list_of_elem = cls(list_of_elem)
            return deserialized.get("nextLink", None), iter(list_of_elem)

        def get_next(next_link=None):
            request = prepare_request(next_link)

            pipeline_response = self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
                request, stream=False, **kwargs
            )
            response = pipeline_response.http_response

            if response.status_code not in [200]:
                map_error(status_code=response.status_code, response=response, error_map=error_map)
                raise HttpResponseError(response=response)

            return pipeline_response

        return ItemPaged(get_next, extract_data)

    @distributed_trace
    def get(self, oauth_provider_id: str, **kwargs: Any) -> JSON:
        """Get a specified oauthProvider resource.

        :param oauth_provider_id: ID of the oauthProvider resource. Required.
        :type oauth_provider_id: str
        :return: JSON object
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "apiKey": "str",  # Optional. OAuth Api key for given Provider."nNote:
                      currently Applicable to Climate provider. Won't be sent in response.
                    "appId": "str",  # Optional. OAuth App Id for given OAuth Provider.
                    "appSecret": "str",  # Optional. OAuth App secret for given Provider."nNote:
                      Won't be sent in response.
                    "createdBy": "str",  # Optional. Created by user/tenant id.
                    "createdDateTime": "2020-02-20 00:00:00",  # Optional. Date-time when
                      resource was created, sample format: yyyy-MM-ddTHH:mm:ssZ.
                    "description": "str",  # Optional. Textual description of the resource.
                    "eTag": "str",  # Optional. The ETag value to implement optimistic
                      concurrency.
                    "id": "str",  # Optional. Unique OAuth provider ID.
                    "isProductionApp": False,  # Optional. Default value is False. An optional
                      flag to determine if the App is ready to be used for Production scenarios in the
                      provider side or not. (Default value: false)"nNote: Currently applicable for
                      JohnDeere.
                    "modifiedBy": "str",  # Optional. Modified by user/tenant id.
                    "modifiedDateTime": "2020-02-20 00:00:00",  # Optional. Date-time when
                      resource was last modified, sample format: yyyy-MM-ddTHH:mm:ssZ.
                    "name": "str",  # Optional. Name to identify resource.
                    "properties": {
                        "str": {}  # Optional. A collection of key value pairs that belongs
                          to the resource."nEach pair must not have a key greater than 50
                          characters"nand must not have a value greater than 150 characters."nNote: A
                          maximum of 25 key value pairs can be provided for a resource and"nonly
                          string, numeral and datetime (yyyy-MM-ddTHH:mm:ssZ) values are supported.
                    }
                }
        """
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls = kwargs.pop("cls", None)  # type: ClsType[JSON]

        request = build_oauth_providers_get_request(
            oauth_provider_id=oauth_provider_id,
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        request.url = self._client.format_url(request.url)  # type: ignore

        pipeline_response = self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
            request, stream=False, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if response.content:
            deserialized = response.json()
        else:
            deserialized = None

        if cls:
            return cls(pipeline_response, cast(JSON, deserialized), {})

        return cast(JSON, deserialized)

    @overload
    def create_or_update(
        self,
        oauth_provider_id: str,
        oauth_provider: JSON,
        *,
        content_type: str = "application/merge-patch+json",
        **kwargs: Any
    ) -> JSON:
        """Creates or updates an oauthProvider resource.

        :param oauth_provider_id: ID of oauthProvider resource. Required.
        :type oauth_provider_id: str
        :param oauth_provider: OauthProvider resource payload to create or update. Required.
        :type oauth_provider: JSON
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/merge-patch+json".
        :paramtype content_type: str
        :return: JSON object
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                oauth_provider = {
                    "apiKey": "str",  # Optional. OAuth Api key for given Provider."nNote:
                      currently Applicable to Climate provider. Won't be sent in response.
                    "appId": "str",  # Optional. OAuth App Id for given OAuth Provider.
                    "appSecret": "str",  # Optional. OAuth App secret for given Provider."nNote:
                      Won't be sent in response.
                    "createdBy": "str",  # Optional. Created by user/tenant id.
                    "createdDateTime": "2020-02-20 00:00:00",  # Optional. Date-time when
                      resource was created, sample format: yyyy-MM-ddTHH:mm:ssZ.
                    "description": "str",  # Optional. Textual description of the resource.
                    "eTag": "str",  # Optional. The ETag value to implement optimistic
                      concurrency.
                    "id": "str",  # Optional. Unique OAuth provider ID.
                    "isProductionApp": False,  # Optional. Default value is False. An optional
                      flag to determine if the App is ready to be used for Production scenarios in the
                      provider side or not. (Default value: false)"nNote: Currently applicable for
                      JohnDeere.
                    "modifiedBy": "str",  # Optional. Modified by user/tenant id.
                    "modifiedDateTime": "2020-02-20 00:00:00",  # Optional. Date-time when
                      resource was last modified, sample format: yyyy-MM-ddTHH:mm:ssZ.
                    "name": "str",  # Optional. Name to identify resource.
                    "properties": {
                        "str": {}  # Optional. A collection of key value pairs that belongs
                          to the resource."nEach pair must not have a key greater than 50
                          characters"nand must not have a value greater than 150 characters."nNote: A
                          maximum of 25 key value pairs can be provided for a resource and"nonly
                          string, numeral and datetime (yyyy-MM-ddTHH:mm:ssZ) values are supported.
                    }
                }

                # response body for status code(s): 200, 201
                response == {
                    "apiKey": "str",  # Optional. OAuth Api key for given Provider."nNote:
                      currently Applicable to Climate provider. Won't be sent in response.
                    "appId": "str",  # Optional. OAuth App Id for given OAuth Provider.
                    "appSecret": "str",  # Optional. OAuth App secret for given Provider."nNote:
                      Won't be sent in response.
                    "createdBy": "str",  # Optional. Created by user/tenant id.
                    "createdDateTime": "2020-02-20 00:00:00",  # Optional. Date-time when
                      resource was created, sample format: yyyy-MM-ddTHH:mm:ssZ.
                    "description": "str",  # Optional. Textual description of the resource.
                    "eTag": "str",  # Optional. The ETag value to implement optimistic
                      concurrency.
                    "id": "str",  # Optional. Unique OAuth provider ID.
                    "isProductionApp": False,  # Optional. Default value is False. An optional
                      flag to determine if the App is ready to be used for Production scenarios in the
                      provider side or not. (Default value: false)"nNote: Currently applicable for
                      JohnDeere.
                    "modifiedBy": "str",  # Optional. Modified by user/tenant id.
                    "modifiedDateTime": "2020-02-20 00:00:00",  # Optional. Date-time when
                      resource was last modified, sample format: yyyy-MM-ddTHH:mm:ssZ.
                    "name": "str",  # Optional. Name to identify resource.
                    "properties": {
                        "str": {}  # Optional. A collection of key value pairs that belongs
                          to the resource."nEach pair must not have a key greater than 50
                          characters"nand must not have a value greater than 150 characters."nNote: A
                          maximum of 25 key value pairs can be provided for a resource and"nonly
                          string, numeral and datetime (yyyy-MM-ddTHH:mm:ssZ) values are supported.
                    }
                }
        """

    @overload
    def create_or_update(
        self,
        oauth_provider_id: str,
        oauth_provider: IO,
        *,
        content_type: str = "application/merge-patch+json",
        **kwargs: Any
    ) -> JSON:
        """Creates or updates an oauthProvider resource.

        :param oauth_provider_id: ID of oauthProvider resource. Required.
        :type oauth_provider_id: str
        :param oauth_provider: OauthProvider resource payload to create or update. Required.
        :type oauth_provider: IO
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Default value is "application/merge-patch+json".
        :paramtype content_type: str
        :return: JSON object
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200, 201
                response == {
                    "apiKey": "str",  # Optional. OAuth Api key for given Provider."nNote:
                      currently Applicable to Climate provider. Won't be sent in response.
                    "appId": "str",  # Optional. OAuth App Id for given OAuth Provider.
                    "appSecret": "str",  # Optional. OAuth App secret for given Provider."nNote:
                      Won't be sent in response.
                    "createdBy": "str",  # Optional. Created by user/tenant id.
                    "createdDateTime": "2020-02-20 00:00:00",  # Optional. Date-time when
                      resource was created, sample format: yyyy-MM-ddTHH:mm:ssZ.
                    "description": "str",  # Optional. Textual description of the resource.
                    "eTag": "str",  # Optional. The ETag value to implement optimistic
                      concurrency.
                    "id": "str",  # Optional. Unique OAuth provider ID.
                    "isProductionApp": False,  # Optional. Default value is False. An optional
                      flag to determine if the App is ready to be used for Production scenarios in the
                      provider side or not. (Default value: false)"nNote: Currently applicable for
                      JohnDeere.
                    "modifiedBy": "str",  # Optional. Modified by user/tenant id.
                    "modifiedDateTime": "2020-02-20 00:00:00",  # Optional. Date-time when
                      resource was last modified, sample format: yyyy-MM-ddTHH:mm:ssZ.
                    "name": "str",  # Optional. Name to identify resource.
                    "properties": {
                        "str": {}  # Optional. A collection of key value pairs that belongs
                          to the resource."nEach pair must not have a key greater than 50
                          characters"nand must not have a value greater than 150 characters."nNote: A
                          maximum of 25 key value pairs can be provided for a resource and"nonly
                          string, numeral and datetime (yyyy-MM-ddTHH:mm:ssZ) values are supported.
                    }
                }
        """

    @distributed_trace
    def create_or_update(self, oauth_provider_id: str, oauth_provider: Union[JSON, IO], **kwargs: Any) -> JSON:
        """Creates or updates an oauthProvider resource.

        :param oauth_provider_id: ID of oauthProvider resource. Required.
        :type oauth_provider_id: str
        :param oauth_provider: OauthProvider resource payload to create or update. Is either a model
         type or a IO type. Required.
        :type oauth_provider: JSON or IO
        :keyword content_type: Body Parameter content-type. Known values are:
         'application/merge-patch+json'. Default value is None.
        :paramtype content_type: str
        :return: JSON object
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200, 201
                response == {
                    "apiKey": "str",  # Optional. OAuth Api key for given Provider."nNote:
                      currently Applicable to Climate provider. Won't be sent in response.
                    "appId": "str",  # Optional. OAuth App Id for given OAuth Provider.
                    "appSecret": "str",  # Optional. OAuth App secret for given Provider."nNote:
                      Won't be sent in response.
                    "createdBy": "str",  # Optional. Created by user/tenant id.
                    "createdDateTime": "2020-02-20 00:00:00",  # Optional. Date-time when
                      resource was created, sample format: yyyy-MM-ddTHH:mm:ssZ.
                    "description": "str",  # Optional. Textual description of the resource.
                    "eTag": "str",  # Optional. The ETag value to implement optimistic
                      concurrency.
                    "id": "str",  # Optional. Unique OAuth provider ID.
                    "isProductionApp": False,  # Optional. Default value is False. An optional
                      flag to determine if the App is ready to be used for Production scenarios in the
                      provider side or not. (Default value: false)"nNote: Currently applicable for
                      JohnDeere.
                    "modifiedBy": "str",  # Optional. Modified by user/tenant id.
                    "modifiedDateTime": "2020-02-20 00:00:00",  # Optional. Date-time when
                      resource was last modified, sample format: yyyy-MM-ddTHH:mm:ssZ.
                    "name": "str",  # Optional. Name to identify resource.
                    "properties": {
                        "str": {}  # Optional. A collection of key value pairs that belongs
                          to the resource."nEach pair must not have a key greater than 50
                          characters"nand must not have a value greater than 150 characters."nNote: A
                          maximum of 25 key value pairs can be provided for a resource and"nonly
                          string, numeral and datetime (yyyy-MM-ddTHH:mm:ssZ) values are supported.
                    }
                }
        """
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type = kwargs.pop("content_type", _headers.pop("Content-Type", None))  # type: Optional[str]
        cls = kwargs.pop("cls", None)  # type: ClsType[JSON]

        content_type = content_type or "application/merge-patch+json"
        _json = None
        _content = None
        if isinstance(oauth_provider, (IO, bytes)):
            _content = oauth_provider
        else:
            _json = oauth_provider

        request = build_oauth_providers_create_or_update_request(
            oauth_provider_id=oauth_provider_id,
            content_type=content_type,
            api_version=self._config.api_version,
            json=_json,
            content=_content,
            headers=_headers,
            params=_params,
        )
        request.url = self._client.format_url(request.url)  # type: ignore

        pipeline_response = self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
            request, stream=False, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200, 201]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if response.status_code == 200:
            if response.content:
                deserialized = response.json()
            else:
                deserialized = None

        if response.status_code == 201:
            if response.content:
                deserialized = response.json()
            else:
                deserialized = None

        if cls:
            return cls(pipeline_response, cast(JSON, deserialized), {})

        return cast(JSON, deserialized)

    @distributed_trace
    def delete(self, oauth_provider_id: str, **kwargs: Any) -> None:  # pylint: disable=inconsistent-return-statements
        """Deletes an specified oauthProvider resource.

        :param oauth_provider_id: ID of oauthProvider. Required.
        :type oauth_provider_id: str
        :return: None
        :rtype: None
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls = kwargs.pop("cls", None)  # type: ClsType[None]

        request = build_oauth_providers_delete_request(
            oauth_provider_id=oauth_provider_id,
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        request.url = self._client.format_url(request.url)  # type: ignore

        pipeline_response = self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
            request, stream=False, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [204]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if cls:
            return cls(pipeline_response, None, {})

    @distributed_trace
    def get_cascade_delete_job_details(self, job_id: str, **kwargs: Any) -> JSON:
        """Get cascade delete job for oauthProvider resource.

        :param job_id: Id of the job. Required.
        :type job_id: str
        :return: JSON object
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "oauthProviderId": "str",  # The id of the oauth provider. Required.
                    "createdBy": "str",  # Optional. Created by user/tenant id.
                    "createdDateTime": "2020-02-20 00:00:00",  # Optional. Job created at
                      dateTime. Sample format: yyyy-MM-ddTHH:mm:ssZ.
                    "description": "str",  # Optional. Textual description of the resource.
                    "durationInSeconds": 0.0,  # Optional. Duration of the job in seconds.
                    "endTime": "2020-02-20 00:00:00",  # Optional. Job end time when available.
                      Sample format: yyyy-MM-ddTHH:mm:ssZ.
                    "errorCode": "str",  # Optional. Error Code when job failed.
                    "id": "str",  # Optional. Unique job id.
                    "lastActionDateTime": "2020-02-20 00:00:00",  # Optional. Job was last acted
                      upon at dateTime. Sample format: yyyy-MM-ddTHH:mm:ssZ.
                    "message": "str",  # Optional. Status message to capture more details of the
                      job.
                    "modifiedBy": "str",  # Optional. Modified by user/tenant id.
                    "name": "str",  # Optional. Name to identify resource.
                    "properties": {
                        "str": {}  # Optional. A collection of key value pairs that belongs
                          to the resource."nEach pair must not have a key greater than 50
                          characters"nand must not have a value greater than 150 characters."nNote: A
                          maximum of 25 key value pairs can be provided for a resource and only
                          string,"nnumeral and datetime (yyyy-MM-ddTHH:mm:ssZ) values are supported.
                    },
                    "startTime": "2020-02-20 00:00:00",  # Optional. Job start time when
                      available. Sample format: yyyy-MM-ddTHH:mm:ssZ.
                    "status": "str"  # Optional. Status of the job."nPossible values: 'Waiting',
                      'Running', 'Succeeded', 'Failed', 'Cancelled'.
                }
        """
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls = kwargs.pop("cls", None)  # type: ClsType[JSON]

        request = build_oauth_providers_get_cascade_delete_job_details_request(
            job_id=job_id,
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        request.url = self._client.format_url(request.url)  # type: ignore

        pipeline_response = self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
            request, stream=False, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if response.content:
            deserialized = response.json()
        else:
            deserialized = None

        if cls:
            return cls(pipeline_response, cast(JSON, deserialized), {})

        return cast(JSON, deserialized)

    def _create_cascade_delete_job_initial(self, job_id: str, *, oauth_provider_id: str, **kwargs: Any) -> JSON:
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls = kwargs.pop("cls", None)  # type: ClsType[JSON]

        request = build_oauth_providers_create_cascade_delete_job_request(
            job_id=job_id,
            oauth_provider_id=oauth_provider_id,
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        request.url = self._client.format_url(request.url)  # type: ignore

        pipeline_response = self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
            request, stream=False, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [202]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if response.content:
            deserialized = response.json()
        else:
            deserialized = None

        if cls:
            return cls(pipeline_response, cast(JSON, deserialized), {})

        return cast(JSON, deserialized)

    @distributed_trace
    def begin_create_cascade_delete_job(self, job_id: str, *, oauth_provider_id: str, **kwargs: Any) -> LROPoller[JSON]:
        """Create cascade delete job for oauthProvider resource.

        :param job_id: Job Id supplied by end user. Required.
        :type job_id: str
        :keyword oauth_provider_id: Id of the application data. Required.
        :paramtype oauth_provider_id: str
        :keyword str continuation_token: A continuation token to restart a poller from a saved state.
        :keyword polling: By default, your polling method will be LROBasePolling. Pass in False for
         this operation to not poll, or pass in your own initialized polling object for a personal
         polling strategy.
        :paramtype polling: bool or ~azure.core.polling.PollingMethod
        :keyword int polling_interval: Default waiting time between two polls for LRO operations if no
         Retry-After header is present.
        :return: An instance of LROPoller that returns JSON object
        :rtype: ~azure.core.polling.LROPoller[JSON]
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 202
                response == {
                    "oauthProviderId": "str",  # The id of the oauth provider. Required.
                    "createdBy": "str",  # Optional. Created by user/tenant id.
                    "createdDateTime": "2020-02-20 00:00:00",  # Optional. Job created at
                      dateTime. Sample format: yyyy-MM-ddTHH:mm:ssZ.
                    "description": "str",  # Optional. Textual description of the resource.
                    "durationInSeconds": 0.0,  # Optional. Duration of the job in seconds.
                    "endTime": "2020-02-20 00:00:00",  # Optional. Job end time when available.
                      Sample format: yyyy-MM-ddTHH:mm:ssZ.
                    "errorCode": "str",  # Optional. Error Code when job failed.
                    "id": "str",  # Optional. Unique job id.
                    "lastActionDateTime": "2020-02-20 00:00:00",  # Optional. Job was last acted
                      upon at dateTime. Sample format: yyyy-MM-ddTHH:mm:ssZ.
                    "message": "str",  # Optional. Status message to capture more details of the
                      job.
                    "modifiedBy": "str",  # Optional. Modified by user/tenant id.
                    "name": "str",  # Optional. Name to identify resource.
                    "properties": {
                        "str": {}  # Optional. A collection of key value pairs that belongs
                          to the resource."nEach pair must not have a key greater than 50
                          characters"nand must not have a value greater than 150 characters."nNote: A
                          maximum of 25 key value pairs can be provided for a resource and only
                          string,"nnumeral and datetime (yyyy-MM-ddTHH:mm:ssZ) values are supported.
                    },
                    "startTime": "2020-02-20 00:00:00",  # Optional. Job start time when
                      available. Sample format: yyyy-MM-ddTHH:mm:ssZ.
                    "status": "str"  # Optional. Status of the job."nPossible values: 'Waiting',
                      'Running', 'Succeeded', 'Failed', 'Cancelled'.
                }
        """
        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls = kwargs.pop("cls", None)  # type: ClsType[JSON]
        polling = kwargs.pop("polling", True)  # type: Union[bool, PollingMethod]
        lro_delay = kwargs.pop("polling_interval", self._config.polling_interval)
        cont_token = kwargs.pop("continuation_token", None)  # type: Optional[str]
        if cont_token is None:
            raw_result = self._create_cascade_delete_job_initial(  # type: ignore
                job_id=job_id,
                oauth_provider_id=oauth_provider_id,
                cls=lambda x, y, z: x,
                headers=_headers,
                params=_params,
                **kwargs
            )
        kwargs.pop("error_map", None)

        def get_long_running_output(pipeline_response):
            response = pipeline_response.http_response
            if response.content:
                deserialized = response.json()
            else:
                deserialized = None
            if cls:
                return cls(pipeline_response, deserialized, {})
            return deserialized

        if polling is True:
            polling_method = cast(
                PollingMethod, LROBasePolling(lro_delay, lro_options={"final-state-via": "location"}, **kwargs)
            )  # type: PollingMethod
        elif polling is False:
            polling_method = cast(PollingMethod, NoPolling())
        else:
            polling_method = polling
        if cont_token:
            return LROPoller.from_continuation_token(
                polling_method=polling_method,
                continuation_token=cont_token,
                client=self._client,
                deserialization_callback=get_long_running_output,
            )
        return LROPoller(self._client, raw_result, get_long_running_output, polling_method)


class OAuthTokensOperations:
    """
    .. warning::
        **DO NOT** instantiate this class directly.

        Instead, you should access the following operations through
        :class:`~azure.agrifood.farming.FarmBeatsClient`'s
        :attr:`oauth_tokens` attribute.
    """

    def __init__(self, *args, **kwargs):
        input_args = list(args)
        self._client = input_args.pop(0) if input_args else kwargs.pop("client")
        self._config = input_args.pop(0) if input_args else kwargs.pop("config")
        self._serialize = input_args.pop(0) if input_args else kwargs.pop("serializer")
        self._deserialize = input_args.pop(0) if input_args else kwargs.pop("deserializer")

    @distributed_trace
    def list(
        self,
        *,
        auth_provider_ids: Optional[List[str]] = None,
        party_ids: Optional[List[str]] = None,
        is_valid: Optional[bool] = None,
        min_created_date_time: Optional[datetime.datetime] = None,
        max_created_date_time: Optional[datetime.datetime] = None,
        min_last_modified_date_time: Optional[datetime.datetime] = None,
        max_last_modified_date_time: Optional[datetime.datetime] = None,
        skip_token: Optional[str] = None,
        **kwargs: Any
    ) -> Iterable[JSON]:
        """Returns a list of OAuthToken documents.

        :keyword auth_provider_ids: Name of AuthProvider. Default value is None.
        :paramtype auth_provider_ids: list[str]
        :keyword party_ids: List of parties. Default value is None.
        :paramtype party_ids: list[str]
        :keyword is_valid: If the token object is valid. Default value is None.
        :paramtype is_valid: bool
        :keyword min_created_date_time: Minimum creation date of resource (inclusive). Default value is
         None.
        :paramtype min_created_date_time: ~datetime.datetime
        :keyword max_created_date_time: Maximum creation date of resource (inclusive). Default value is
         None.
        :paramtype max_created_date_time: ~datetime.datetime
        :keyword min_last_modified_date_time: Minimum last modified date of resource (inclusive).
         Default value is None.
        :paramtype min_last_modified_date_time: ~datetime.datetime
        :keyword max_last_modified_date_time: Maximum last modified date of resource (inclusive).
         Default value is None.
        :paramtype max_last_modified_date_time: ~datetime.datetime
        :keyword skip_token: Skip token for getting next set of results. Default value is None.
        :paramtype skip_token: str
        :return: An iterator like instance of JSON object
        :rtype: ~azure.core.paging.ItemPaged[JSON]
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "authProviderId": "str",  # ID of the OAuth provider resource containing app
                      information. Required.
                    "partyId": "str",  # Party ID for this OAuth config. Required.
                    "createdDateTime": "2020-02-20 00:00:00",  # Optional. Date-time when
                      resource was created, sample format: yyyy-MM-ddTHH:mm:ssZ.
                    "eTag": "str",  # Optional. The ETag value to implement optimistic
                      concurrency.
                    "isValid": True,  # Optional. Default value is True. An optional flag
                      indicating whether the token is a valid or expired (Default value: true).
                    "modifiedDateTime": "2020-02-20 00:00:00"  # Optional. Date-time when
                      resource was last modified, sample format: yyyy-MM-ddTHH:mm:ssZ.
                }
        """
        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls = kwargs.pop("cls", None)  # type: ClsType[JSON]

        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        def prepare_request(next_link=None):
            if not next_link:

                request = build_oauth_tokens_list_request(
                    auth_provider_ids=auth_provider_ids,
                    party_ids=party_ids,
                    is_valid=is_valid,
                    min_created_date_time=min_created_date_time,
                    max_created_date_time=max_created_date_time,
                    min_last_modified_date_time=min_last_modified_date_time,
                    max_last_modified_date_time=max_last_modified_date_time,
                    skip_token=skip_token,
                    api_version=self._config.api_version,
                    headers=_headers,
                    params=_params,
                )
                request.url = self._client.format_url(request.url)  # type: ignore

            else:
                # make call to next link with the client's api-version
                _parsed_next_link = urlparse(next_link)
                _next_request_params = case_insensitive_dict(parse_qs(_parsed_next_link.query))
                _next_request_params["api-version"] = self._config.api_version
                request = HttpRequest("GET", urljoin(next_link, _parsed_next_link.path), params=_next_request_params)
                request.url = self._client.format_url(request.url)  # type: ignore

            return request

        def extract_data(pipeline_response):
            deserialized = pipeline_response.http_response.json()
            list_of_elem = deserialized["value"]
            if cls:
                list_of_elem = cls(list_of_elem)
            return deserialized.get("nextLink", None), iter(list_of_elem)

        def get_next(next_link=None):
            request = prepare_request(next_link)

            pipeline_response = self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
                request, stream=False, **kwargs
            )
            response = pipeline_response.http_response

            if response.status_code not in [200]:
                map_error(status_code=response.status_code, response=response, error_map=error_map)
                raise HttpResponseError(response=response)

            return pipeline_response

        return ItemPaged(get_next, extract_data)

    @overload
    def get_o_auth_connection_link(
        self, oauth_connect_request: JSON, *, content_type: str = "application/json", **kwargs: Any
    ) -> str:
        """Returns Connection link needed in the OAuth flow.

        :param oauth_connect_request: OAuth Connect Request. Required.
        :type oauth_connect_request: JSON
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: str
        :rtype: str
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                oauth_connect_request = {
                    "oAuthProviderId": "str",  # Id of the OAuthProvider. Required.
                    "partyId": "str",  # Id of the party. Required.
                    "userRedirectLink": "str",  # Link to redirect the user to, at the end of the
                      oauth flow. Required.
                    "userRedirectState": "str"  # Optional. State to provide back when
                      redirecting the user, at the end of the oauth flow.
                }
        """

    @overload
    def get_o_auth_connection_link(
        self, oauth_connect_request: IO, *, content_type: str = "application/json", **kwargs: Any
    ) -> str:
        """Returns Connection link needed in the OAuth flow.

        :param oauth_connect_request: OAuth Connect Request. Required.
        :type oauth_connect_request: IO
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: str
        :rtype: str
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @distributed_trace
    def get_o_auth_connection_link(self, oauth_connect_request: Union[JSON, IO], **kwargs: Any) -> str:
        """Returns Connection link needed in the OAuth flow.

        :param oauth_connect_request: OAuth Connect Request. Is either a model type or a IO type.
         Required.
        :type oauth_connect_request: JSON or IO
        :keyword content_type: Body Parameter content-type. Known values are: 'application/json'.
         Default value is None.
        :paramtype content_type: str
        :return: str
        :rtype: str
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type = kwargs.pop("content_type", _headers.pop("Content-Type", None))  # type: Optional[str]
        cls = kwargs.pop("cls", None)  # type: ClsType[str]

        content_type = content_type or "application/json"
        _json = None
        _content = None
        if isinstance(oauth_connect_request, (IO, bytes)):
            _content = oauth_connect_request
        else:
            _json = oauth_connect_request

        request = build_oauth_tokens_get_o_auth_connection_link_request(
            content_type=content_type,
            api_version=self._config.api_version,
            json=_json,
            content=_content,
            headers=_headers,
            params=_params,
        )
        request.url = self._client.format_url(request.url)  # type: ignore

        pipeline_response = self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
            request, stream=False, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if response.content:
            deserialized = response.json()
        else:
            deserialized = None

        if cls:
            return cls(pipeline_response, cast(str, deserialized), {})

        return cast(str, deserialized)

    @distributed_trace
    def get_cascade_delete_job_details(self, job_id: str, **kwargs: Any) -> JSON:
        """Get remove job for OAuth token.

        :param job_id: Id of the job. Required.
        :type job_id: str
        :return: JSON object
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "partyId": "str",  # Party Id. Required.
                    "resourceId": "str",  # The id of the resource. Required.
                    "resourceType": "str",  # The type of the resource. Required.
                    "createdDateTime": "2020-02-20 00:00:00",  # Optional. Job created at
                      dateTime. Sample format: yyyy-MM-ddTHH:mm:ssZ.
                    "durationInSeconds": 0.0,  # Optional. Duration of the job in seconds.
                    "endTime": "2020-02-20 00:00:00",  # Optional. Job end time when available.
                      Sample format: yyyy-MM-ddTHH:mm:ssZ.
                    "errorCode": "str",  # Optional. Error Code when job failed.
                    "id": "str",  # Optional. Unique job id.
                    "lastActionDateTime": "2020-02-20 00:00:00",  # Optional. Job was last acted
                      upon at dateTime. Sample format: yyyy-MM-ddTHH:mm:ssZ.
                    "message": "str",  # Optional. Status message to capture more details of the
                      job.
                    "startTime": "2020-02-20 00:00:00",  # Optional. Job start time when
                      available. Sample format: yyyy-MM-ddTHH:mm:ssZ.
                    "status": "str"  # Optional. Status of the job."nPossible values: 'Waiting',
                      'Running', 'Succeeded', 'Failed', 'Cancelled'. Known values are: "Waiting",
                      "Running", "Succeeded", "Failed", and "Cancelled".
                }
        """
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls = kwargs.pop("cls", None)  # type: ClsType[JSON]

        request = build_oauth_tokens_get_cascade_delete_job_details_request(
            job_id=job_id,
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        request.url = self._client.format_url(request.url)  # type: ignore

        pipeline_response = self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
            request, stream=False, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if response.content:
            deserialized = response.json()
        else:
            deserialized = None

        if cls:
            return cls(pipeline_response, cast(JSON, deserialized), {})

        return cast(JSON, deserialized)

    def _create_cascade_delete_job_initial(
        self, job_id: str, *, party_id: str, oauth_provider_id: str, **kwargs: Any
    ) -> JSON:
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls = kwargs.pop("cls", None)  # type: ClsType[JSON]

        request = build_oauth_tokens_create_cascade_delete_job_request(
            job_id=job_id,
            party_id=party_id,
            oauth_provider_id=oauth_provider_id,
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        request.url = self._client.format_url(request.url)  # type: ignore

        pipeline_response = self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
            request, stream=False, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [202]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if response.content:
            deserialized = response.json()
        else:
            deserialized = None

        if cls:
            return cls(pipeline_response, cast(JSON, deserialized), {})

        return cast(JSON, deserialized)

    @distributed_trace
    def begin_create_cascade_delete_job(
        self, job_id: str, *, party_id: str, oauth_provider_id: str, **kwargs: Any
    ) -> LROPoller[JSON]:
        """Create remove job for OAuth token.

        :param job_id: Job Id supplied by end user. Required.
        :type job_id: str
        :keyword party_id: Id of the party. Required.
        :paramtype party_id: str
        :keyword oauth_provider_id: Id of the OAuthProvider. Required.
        :paramtype oauth_provider_id: str
        :keyword str continuation_token: A continuation token to restart a poller from a saved state.
        :keyword polling: By default, your polling method will be LROBasePolling. Pass in False for
         this operation to not poll, or pass in your own initialized polling object for a personal
         polling strategy.
        :paramtype polling: bool or ~azure.core.polling.PollingMethod
        :keyword int polling_interval: Default waiting time between two polls for LRO operations if no
         Retry-After header is present.
        :return: An instance of LROPoller that returns JSON object
        :rtype: ~azure.core.polling.LROPoller[JSON]
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 202
                response == {
                    "partyId": "str",  # Party Id. Required.
                    "resourceId": "str",  # The id of the resource. Required.
                    "resourceType": "str",  # The type of the resource. Required.
                    "createdDateTime": "2020-02-20 00:00:00",  # Optional. Job created at
                      dateTime. Sample format: yyyy-MM-ddTHH:mm:ssZ.
                    "durationInSeconds": 0.0,  # Optional. Duration of the job in seconds.
                    "endTime": "2020-02-20 00:00:00",  # Optional. Job end time when available.
                      Sample format: yyyy-MM-ddTHH:mm:ssZ.
                    "errorCode": "str",  # Optional. Error Code when job failed.
                    "id": "str",  # Optional. Unique job id.
                    "lastActionDateTime": "2020-02-20 00:00:00",  # Optional. Job was last acted
                      upon at dateTime. Sample format: yyyy-MM-ddTHH:mm:ssZ.
                    "message": "str",  # Optional. Status message to capture more details of the
                      job.
                    "startTime": "2020-02-20 00:00:00",  # Optional. Job start time when
                      available. Sample format: yyyy-MM-ddTHH:mm:ssZ.
                    "status": "str"  # Optional. Status of the job."nPossible values: 'Waiting',
                      'Running', 'Succeeded', 'Failed', 'Cancelled'. Known values are: "Waiting",
                      "Running", "Succeeded", "Failed", and "Cancelled".
                }
        """
        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls = kwargs.pop("cls", None)  # type: ClsType[JSON]
        polling = kwargs.pop("polling", True)  # type: Union[bool, PollingMethod]
        lro_delay = kwargs.pop("polling_interval", self._config.polling_interval)
        cont_token = kwargs.pop("continuation_token", None)  # type: Optional[str]
        if cont_token is None:
            raw_result = self._create_cascade_delete_job_initial(  # type: ignore
                job_id=job_id,
                party_id=party_id,
                oauth_provider_id=oauth_provider_id,
                cls=lambda x, y, z: x,
                headers=_headers,
                params=_params,
                **kwargs
            )
        kwargs.pop("error_map", None)

        def get_long_running_output(pipeline_response):
            response = pipeline_response.http_response
            if response.content:
                deserialized = response.json()
            else:
                deserialized = None
            if cls:
                return cls(pipeline_response, deserialized, {})
            return deserialized

        if polling is True:
            polling_method = cast(
                PollingMethod, LROBasePolling(lro_delay, lro_options={"final-state-via": "location"}, **kwargs)
            )  # type: PollingMethod
        elif polling is False:
            polling_method = cast(PollingMethod, NoPolling())
        else:
            polling_method = polling
        if cont_token:
            return LROPoller.from_continuation_token(
                polling_method=polling_method,
                continuation_token=cont_token,
                client=self._client,
                deserialization_callback=get_long_running_output,
            )
        return LROPoller(self._client, raw_result, get_long_running_output, polling_method)


class PartiesOperations:
    """
    .. warning::
        **DO NOT** instantiate this class directly.

        Instead, you should access the following operations through
        :class:`~azure.agrifood.farming.FarmBeatsClient`'s
        :attr:`parties` attribute.
    """

    def __init__(self, *args, **kwargs):
        input_args = list(args)
        self._client = input_args.pop(0) if input_args else kwargs.pop("client")
        self._config = input_args.pop(0) if input_args else kwargs.pop("config")
        self._serialize = input_args.pop(0) if input_args else kwargs.pop("serializer")
        self._deserialize = input_args.pop(0) if input_args else kwargs.pop("deserializer")

    @distributed_trace
    def list(
        self,
        *,
        ids: Optional[List[str]] = None,
        names: Optional[List[str]] = None,
        property_filters: Optional[List[str]] = None,
        statuses: Optional[List[str]] = None,
        min_created_date_time: Optional[datetime.datetime] = None,
        max_created_date_time: Optional[datetime.datetime] = None,
        min_last_modified_date_time: Optional[datetime.datetime] = None,
        max_last_modified_date_time: Optional[datetime.datetime] = None,
        skip_token: Optional[str] = None,
        **kwargs: Any
    ) -> Iterable[JSON]:
        """Returns a paginated list of party resources.

        :keyword ids: Ids of the resource. Default value is None.
        :paramtype ids: list[str]
        :keyword names: Names of the resource. Default value is None.
        :paramtype names: list[str]
        :keyword property_filters: Filters on key-value pairs within the Properties object.
         eg. "{testKey} eq {testValue}". Default value is None.
        :paramtype property_filters: list[str]
        :keyword statuses: Statuses of the resource. Default value is None.
        :paramtype statuses: list[str]
        :keyword min_created_date_time: Minimum creation date of resource (inclusive). Default value is
         None.
        :paramtype min_created_date_time: ~datetime.datetime
        :keyword max_created_date_time: Maximum creation date of resource (inclusive). Default value is
         None.
        :paramtype max_created_date_time: ~datetime.datetime
        :keyword min_last_modified_date_time: Minimum last modified date of resource (inclusive).
         Default value is None.
        :paramtype min_last_modified_date_time: ~datetime.datetime
        :keyword max_last_modified_date_time: Maximum last modified date of resource (inclusive).
         Default value is None.
        :paramtype max_last_modified_date_time: ~datetime.datetime
        :keyword skip_token: Skip token for getting next set of results. Default value is None.
        :paramtype skip_token: str
        :return: An iterator like instance of JSON object
        :rtype: ~azure.core.paging.ItemPaged[JSON]
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "createdBy": "str",  # Optional. Created by user/tenant id.
                    "createdDateTime": "2020-02-20 00:00:00",  # Optional. Date-time when
                      resource was created, sample format: yyyy-MM-ddTHH:mm:ssZ.
                    "description": "str",  # Optional. Textual description of the resource.
                    "eTag": "str",  # Optional. The ETag value to implement optimistic
                      concurrency.
                    "id": "str",  # Optional. Unique resource ID.
                    "modifiedBy": "str",  # Optional. Modified by user/tenant id.
                    "modifiedDateTime": "2020-02-20 00:00:00",  # Optional. Date-time when
                      resource was last modified, sample format: yyyy-MM-ddTHH:mm:ssZ.
                    "name": "str",  # Optional. Name to identify resource.
                    "properties": {
                        "str": {}  # Optional. A collection of key value pairs that belongs
                          to the resource."nEach pair must not have a key greater than 50
                          characters"nand must not have a value greater than 150 characters."nNote: A
                          maximum of 25 key value pairs can be provided for a resource and only
                          string,"nnumeral and datetime (yyyy-MM-ddTHH:mm:ssZ) values are supported.
                    },
                    "source": "str",  # Optional. Source of the resource.
                    "status": "str"  # Optional. Status of the resource.
                }
        """
        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls = kwargs.pop("cls", None)  # type: ClsType[JSON]

        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        def prepare_request(next_link=None):
            if not next_link:

                request = build_parties_list_request(
                    ids=ids,
                    names=names,
                    property_filters=property_filters,
                    statuses=statuses,
                    min_created_date_time=min_created_date_time,
                    max_created_date_time=max_created_date_time,
                    min_last_modified_date_time=min_last_modified_date_time,
                    max_last_modified_date_time=max_last_modified_date_time,
                    skip_token=skip_token,
                    api_version=self._config.api_version,
                    headers=_headers,
                    params=_params,
                )
                request.url = self._client.format_url(request.url)  # type: ignore

            else:
                # make call to next link with the client's api-version
                _parsed_next_link = urlparse(next_link)
                _next_request_params = case_insensitive_dict(parse_qs(_parsed_next_link.query))
                _next_request_params["api-version"] = self._config.api_version
                request = HttpRequest("GET", urljoin(next_link, _parsed_next_link.path), params=_next_request_params)
                request.url = self._client.format_url(request.url)  # type: ignore

            return request

        def extract_data(pipeline_response):
            deserialized = pipeline_response.http_response.json()
            list_of_elem = deserialized["value"]
            if cls:
                list_of_elem = cls(list_of_elem)
            return deserialized.get("nextLink", None), iter(list_of_elem)

        def get_next(next_link=None):
            request = prepare_request(next_link)

            pipeline_response = self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
                request, stream=False, **kwargs
            )
            response = pipeline_response.http_response

            if response.status_code not in [200]:
                map_error(status_code=response.status_code, response=response, error_map=error_map)
                raise HttpResponseError(response=response)

            return pipeline_response

        return ItemPaged(get_next, extract_data)

    @distributed_trace
    def get(self, party_id: str, **kwargs: Any) -> JSON:
        """Gets a specified party resource.

        :param party_id: ID of the associated party. Required.
        :type party_id: str
        :return: JSON object
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "createdBy": "str",  # Optional. Created by user/tenant id.
                    "createdDateTime": "2020-02-20 00:00:00",  # Optional. Date-time when
                      resource was created, sample format: yyyy-MM-ddTHH:mm:ssZ.
                    "description": "str",  # Optional. Textual description of the resource.
                    "eTag": "str",  # Optional. The ETag value to implement optimistic
                      concurrency.
                    "id": "str",  # Optional. Unique resource ID.
                    "modifiedBy": "str",  # Optional. Modified by user/tenant id.
                    "modifiedDateTime": "2020-02-20 00:00:00",  # Optional. Date-time when
                      resource was last modified, sample format: yyyy-MM-ddTHH:mm:ssZ.
                    "name": "str",  # Optional. Name to identify resource.
                    "properties": {
                        "str": {}  # Optional. A collection of key value pairs that belongs
                          to the resource."nEach pair must not have a key greater than 50
                          characters"nand must not have a value greater than 150 characters."nNote: A
                          maximum of 25 key value pairs can be provided for a resource and only
                          string,"nnumeral and datetime (yyyy-MM-ddTHH:mm:ssZ) values are supported.
                    },
                    "source": "str",  # Optional. Source of the resource.
                    "status": "str"  # Optional. Status of the resource.
                }
        """
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls = kwargs.pop("cls", None)  # type: ClsType[JSON]

        request = build_parties_get_request(
            party_id=party_id,
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        request.url = self._client.format_url(request.url)  # type: ignore

        pipeline_response = self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
            request, stream=False, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if response.content:
            deserialized = response.json()
        else:
            deserialized = None

        if cls:
            return cls(pipeline_response, cast(JSON, deserialized), {})

        return cast(JSON, deserialized)

    @overload
    def create_or_update(
        self, party_id: str, party: JSON, *, content_type: str = "application/merge-patch+json", **kwargs: Any
    ) -> JSON:
        """Creates or updates a party resource.

        :param party_id: Id of the party resource. Required.
        :type party_id: str
        :param party: Party resource payload to create or update. Required.
        :type party: JSON
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/merge-patch+json".
        :paramtype content_type: str
        :return: JSON object
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                party = {
                    "createdBy": "str",  # Optional. Created by user/tenant id.
                    "createdDateTime": "2020-02-20 00:00:00",  # Optional. Date-time when
                      resource was created, sample format: yyyy-MM-ddTHH:mm:ssZ.
                    "description": "str",  # Optional. Textual description of the resource.
                    "eTag": "str",  # Optional. The ETag value to implement optimistic
                      concurrency.
                    "id": "str",  # Optional. Unique resource ID.
                    "modifiedBy": "str",  # Optional. Modified by user/tenant id.
                    "modifiedDateTime": "2020-02-20 00:00:00",  # Optional. Date-time when
                      resource was last modified, sample format: yyyy-MM-ddTHH:mm:ssZ.
                    "name": "str",  # Optional. Name to identify resource.
                    "properties": {
                        "str": {}  # Optional. A collection of key value pairs that belongs
                          to the resource."nEach pair must not have a key greater than 50
                          characters"nand must not have a value greater than 150 characters."nNote: A
                          maximum of 25 key value pairs can be provided for a resource and only
                          string,"nnumeral and datetime (yyyy-MM-ddTHH:mm:ssZ) values are supported.
                    },
                    "source": "str",  # Optional. Source of the resource.
                    "status": "str"  # Optional. Status of the resource.
                }

                # response body for status code(s): 200, 201
                response == {
                    "createdBy": "str",  # Optional. Created by user/tenant id.
                    "createdDateTime": "2020-02-20 00:00:00",  # Optional. Date-time when
                      resource was created, sample format: yyyy-MM-ddTHH:mm:ssZ.
                    "description": "str",  # Optional. Textual description of the resource.
                    "eTag": "str",  # Optional. The ETag value to implement optimistic
                      concurrency.
                    "id": "str",  # Optional. Unique resource ID.
                    "modifiedBy": "str",  # Optional. Modified by user/tenant id.
                    "modifiedDateTime": "2020-02-20 00:00:00",  # Optional. Date-time when
                      resource was last modified, sample format: yyyy-MM-ddTHH:mm:ssZ.
                    "name": "str",  # Optional. Name to identify resource.
                    "properties": {
                        "str": {}  # Optional. A collection of key value pairs that belongs
                          to the resource."nEach pair must not have a key greater than 50
                          characters"nand must not have a value greater than 150 characters."nNote: A
                          maximum of 25 key value pairs can be provided for a resource and only
                          string,"nnumeral and datetime (yyyy-MM-ddTHH:mm:ssZ) values are supported.
                    },
                    "source": "str",  # Optional. Source of the resource.
                    "status": "str"  # Optional. Status of the resource.
                }
        """

    @overload
    def create_or_update(
        self, party_id: str, party: IO, *, content_type: str = "application/merge-patch+json", **kwargs: Any
    ) -> JSON:
        """Creates or updates a party resource.

        :param party_id: Id of the party resource. Required.
        :type party_id: str
        :param party: Party resource payload to create or update. Required.
        :type party: IO
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Default value is "application/merge-patch+json".
        :paramtype content_type: str
        :return: JSON object
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200, 201
                response == {
                    "createdBy": "str",  # Optional. Created by user/tenant id.
                    "createdDateTime": "2020-02-20 00:00:00",  # Optional. Date-time when
                      resource was created, sample format: yyyy-MM-ddTHH:mm:ssZ.
                    "description": "str",  # Optional. Textual description of the resource.
                    "eTag": "str",  # Optional. The ETag value to implement optimistic
                      concurrency.
                    "id": "str",  # Optional. Unique resource ID.
                    "modifiedBy": "str",  # Optional. Modified by user/tenant id.
                    "modifiedDateTime": "2020-02-20 00:00:00",  # Optional. Date-time when
                      resource was last modified, sample format: yyyy-MM-ddTHH:mm:ssZ.
                    "name": "str",  # Optional. Name to identify resource.
                    "properties": {
                        "str": {}  # Optional. A collection of key value pairs that belongs
                          to the resource."nEach pair must not have a key greater than 50
                          characters"nand must not have a value greater than 150 characters."nNote: A
                          maximum of 25 key value pairs can be provided for a resource and only
                          string,"nnumeral and datetime (yyyy-MM-ddTHH:mm:ssZ) values are supported.
                    },
                    "source": "str",  # Optional. Source of the resource.
                    "status": "str"  # Optional. Status of the resource.
                }
        """

    @distributed_trace
    def create_or_update(self, party_id: str, party: Union[JSON, IO], **kwargs: Any) -> JSON:
        """Creates or updates a party resource.

        :param party_id: Id of the party resource. Required.
        :type party_id: str
        :param party: Party resource payload to create or update. Is either a model type or a IO type.
         Required.
        :type party: JSON or IO
        :keyword content_type: Body Parameter content-type. Known values are:
         'application/merge-patch+json'. Default value is None.
        :paramtype content_type: str
        :return: JSON object
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200, 201
                response == {
                    "createdBy": "str",  # Optional. Created by user/tenant id.
                    "createdDateTime": "2020-02-20 00:00:00",  # Optional. Date-time when
                      resource was created, sample format: yyyy-MM-ddTHH:mm:ssZ.
                    "description": "str",  # Optional. Textual description of the resource.
                    "eTag": "str",  # Optional. The ETag value to implement optimistic
                      concurrency.
                    "id": "str",  # Optional. Unique resource ID.
                    "modifiedBy": "str",  # Optional. Modified by user/tenant id.
                    "modifiedDateTime": "2020-02-20 00:00:00",  # Optional. Date-time when
                      resource was last modified, sample format: yyyy-MM-ddTHH:mm:ssZ.
                    "name": "str",  # Optional. Name to identify resource.
                    "properties": {
                        "str": {}  # Optional. A collection of key value pairs that belongs
                          to the resource."nEach pair must not have a key greater than 50
                          characters"nand must not have a value greater than 150 characters."nNote: A
                          maximum of 25 key value pairs can be provided for a resource and only
                          string,"nnumeral and datetime (yyyy-MM-ddTHH:mm:ssZ) values are supported.
                    },
                    "source": "str",  # Optional. Source of the resource.
                    "status": "str"  # Optional. Status of the resource.
                }
        """
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type = kwargs.pop("content_type", _headers.pop("Content-Type", None))  # type: Optional[str]
        cls = kwargs.pop("cls", None)  # type: ClsType[JSON]

        content_type = content_type or "application/merge-patch+json"
        _json = None
        _content = None
        if isinstance(party, (IO, bytes)):
            _content = party
        else:
            _json = party

        request = build_parties_create_or_update_request(
            party_id=party_id,
            content_type=content_type,
            api_version=self._config.api_version,
            json=_json,
            content=_content,
            headers=_headers,
            params=_params,
        )
        request.url = self._client.format_url(request.url)  # type: ignore

        pipeline_response = self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
            request, stream=False, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200, 201]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if response.status_code == 200:
            if response.content:
                deserialized = response.json()
            else:
                deserialized = None

        if response.status_code == 201:
            if response.content:
                deserialized = response.json()
            else:
                deserialized = None

        if cls:
            return cls(pipeline_response, cast(JSON, deserialized), {})

        return cast(JSON, deserialized)

    @distributed_trace
    def delete(self, party_id: str, **kwargs: Any) -> None:  # pylint: disable=inconsistent-return-statements
        """Deletes a specified party resource.

        :param party_id: Id of party to be deleted. Required.
        :type party_id: str
        :return: None
        :rtype: None
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls = kwargs.pop("cls", None)  # type: ClsType[None]

        request = build_parties_delete_request(
            party_id=party_id,
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        request.url = self._client.format_url(request.url)  # type: ignore

        pipeline_response = self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
            request, stream=False, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [204]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if cls:
            return cls(pipeline_response, None, {})

    @distributed_trace
    def get_cascade_delete_job_details(self, job_id: str, **kwargs: Any) -> JSON:
        """Get a cascade delete job for specified party.

        :param job_id: Id of the job. Required.
        :type job_id: str
        :return: JSON object
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "partyId": "str",  # Party Id. Required.
                    "resourceId": "str",  # The id of the resource. Required.
                    "resourceType": "str",  # The type of the resource. Required.
                    "createdDateTime": "2020-02-20 00:00:00",  # Optional. Job created at
                      dateTime. Sample format: yyyy-MM-ddTHH:mm:ssZ.
                    "durationInSeconds": 0.0,  # Optional. Duration of the job in seconds.
                    "endTime": "2020-02-20 00:00:00",  # Optional. Job end time when available.
                      Sample format: yyyy-MM-ddTHH:mm:ssZ.
                    "errorCode": "str",  # Optional. Error Code when job failed.
                    "id": "str",  # Optional. Unique job id.
                    "lastActionDateTime": "2020-02-20 00:00:00",  # Optional. Job was last acted
                      upon at dateTime. Sample format: yyyy-MM-ddTHH:mm:ssZ.
                    "message": "str",  # Optional. Status message to capture more details of the
                      job.
                    "startTime": "2020-02-20 00:00:00",  # Optional. Job start time when
                      available. Sample format: yyyy-MM-ddTHH:mm:ssZ.
                    "status": "str"  # Optional. Status of the job."nPossible values: 'Waiting',
                      'Running', 'Succeeded', 'Failed', 'Cancelled'. Known values are: "Waiting",
                      "Running", "Succeeded", "Failed", and "Cancelled".
                }
        """
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls = kwargs.pop("cls", None)  # type: ClsType[JSON]

        request = build_parties_get_cascade_delete_job_details_request(
            job_id=job_id,
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        request.url = self._client.format_url(request.url)  # type: ignore

        pipeline_response = self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
            request, stream=False, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if response.content:
            deserialized = response.json()
        else:
            deserialized = None

        if cls:
            return cls(pipeline_response, cast(JSON, deserialized), {})

        return cast(JSON, deserialized)

    def _create_cascade_delete_job_initial(self, job_id: str, *, party_id: str, **kwargs: Any) -> JSON:
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls = kwargs.pop("cls", None)  # type: ClsType[JSON]

        request = build_parties_create_cascade_delete_job_request(
            job_id=job_id,
            party_id=party_id,
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        request.url = self._client.format_url(request.url)  # type: ignore

        pipeline_response = self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
            request, stream=False, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [202]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if response.content:
            deserialized = response.json()
        else:
            deserialized = None

        if cls:
            return cls(pipeline_response, cast(JSON, deserialized), {})

        return cast(JSON, deserialized)

    @distributed_trace
    def begin_create_cascade_delete_job(self, job_id: str, *, party_id: str, **kwargs: Any) -> LROPoller[JSON]:
        """Create a cascade delete job for specified party.

        :param job_id: Job ID supplied by end user. Required.
        :type job_id: str
        :keyword party_id: ID of the party to be deleted. Required.
        :paramtype party_id: str
        :keyword str continuation_token: A continuation token to restart a poller from a saved state.
        :keyword polling: By default, your polling method will be LROBasePolling. Pass in False for
         this operation to not poll, or pass in your own initialized polling object for a personal
         polling strategy.
        :paramtype polling: bool or ~azure.core.polling.PollingMethod
        :keyword int polling_interval: Default waiting time between two polls for LRO operations if no
         Retry-After header is present.
        :return: An instance of LROPoller that returns JSON object
        :rtype: ~azure.core.polling.LROPoller[JSON]
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 202
                response == {
                    "partyId": "str",  # Party Id. Required.
                    "resourceId": "str",  # The id of the resource. Required.
                    "resourceType": "str",  # The type of the resource. Required.
                    "createdDateTime": "2020-02-20 00:00:00",  # Optional. Job created at
                      dateTime. Sample format: yyyy-MM-ddTHH:mm:ssZ.
                    "durationInSeconds": 0.0,  # Optional. Duration of the job in seconds.
                    "endTime": "2020-02-20 00:00:00",  # Optional. Job end time when available.
                      Sample format: yyyy-MM-ddTHH:mm:ssZ.
                    "errorCode": "str",  # Optional. Error Code when job failed.
                    "id": "str",  # Optional. Unique job id.
                    "lastActionDateTime": "2020-02-20 00:00:00",  # Optional. Job was last acted
                      upon at dateTime. Sample format: yyyy-MM-ddTHH:mm:ssZ.
                    "message": "str",  # Optional. Status message to capture more details of the
                      job.
                    "startTime": "2020-02-20 00:00:00",  # Optional. Job start time when
                      available. Sample format: yyyy-MM-ddTHH:mm:ssZ.
                    "status": "str"  # Optional. Status of the job."nPossible values: 'Waiting',
                      'Running', 'Succeeded', 'Failed', 'Cancelled'. Known values are: "Waiting",
                      "Running", "Succeeded", "Failed", and "Cancelled".
                }
        """
        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls = kwargs.pop("cls", None)  # type: ClsType[JSON]
        polling = kwargs.pop("polling", True)  # type: Union[bool, PollingMethod]
        lro_delay = kwargs.pop("polling_interval", self._config.polling_interval)
        cont_token = kwargs.pop("continuation_token", None)  # type: Optional[str]
        if cont_token is None:
            raw_result = self._create_cascade_delete_job_initial(  # type: ignore
                job_id=job_id, party_id=party_id, cls=lambda x, y, z: x, headers=_headers, params=_params, **kwargs
            )
        kwargs.pop("error_map", None)

        def get_long_running_output(pipeline_response):
            response = pipeline_response.http_response
            if response.content:
                deserialized = response.json()
            else:
                deserialized = None
            if cls:
                return cls(pipeline_response, deserialized, {})
            return deserialized

        if polling is True:
            polling_method = cast(
                PollingMethod, LROBasePolling(lro_delay, lro_options={"final-state-via": "location"}, **kwargs)
            )  # type: PollingMethod
        elif polling is False:
            polling_method = cast(PollingMethod, NoPolling())
        else:
            polling_method = polling
        if cont_token:
            return LROPoller.from_continuation_token(
                polling_method=polling_method,
                continuation_token=cont_token,
                client=self._client,
                deserialization_callback=get_long_running_output,
            )
        return LROPoller(self._client, raw_result, get_long_running_output, polling_method)


class PlantingDataOperations:
    """
    .. warning::
        **DO NOT** instantiate this class directly.

        Instead, you should access the following operations through
        :class:`~azure.agrifood.farming.FarmBeatsClient`'s
        :attr:`planting_data` attribute.
    """

    def __init__(self, *args, **kwargs):
        input_args = list(args)
        self._client = input_args.pop(0) if input_args else kwargs.pop("client")
        self._config = input_args.pop(0) if input_args else kwargs.pop("config")
        self._serialize = input_args.pop(0) if input_args else kwargs.pop("serializer")
        self._deserialize = input_args.pop(0) if input_args else kwargs.pop("deserializer")

    @distributed_trace
    def list_by_party_id(
        self,
        party_id: str,
        *,
        min_avg_planting_rate: Optional[float] = None,
        max_avg_planting_rate: Optional[float] = None,
        min_total_material: Optional[float] = None,
        max_total_material: Optional[float] = None,
        min_avg_material: Optional[float] = None,
        max_avg_material: Optional[float] = None,
        sources: Optional[List[str]] = None,
        associated_boundary_ids: Optional[List[str]] = None,
        min_operation_start_date_time: Optional[datetime.datetime] = None,
        max_operation_start_date_time: Optional[datetime.datetime] = None,
        min_operation_end_date_time: Optional[datetime.datetime] = None,
        max_operation_end_date_time: Optional[datetime.datetime] = None,
        min_operation_modified_date_time: Optional[datetime.datetime] = None,
        max_operation_modified_date_time: Optional[datetime.datetime] = None,
        min_area: Optional[float] = None,
        max_area: Optional[float] = None,
        ids: Optional[List[str]] = None,
        names: Optional[List[str]] = None,
        property_filters: Optional[List[str]] = None,
        statuses: Optional[List[str]] = None,
        min_created_date_time: Optional[datetime.datetime] = None,
        max_created_date_time: Optional[datetime.datetime] = None,
        min_last_modified_date_time: Optional[datetime.datetime] = None,
        max_last_modified_date_time: Optional[datetime.datetime] = None,
        skip_token: Optional[str] = None,
        **kwargs: Any
    ) -> Iterable[JSON]:
        """Returns a paginated list of planting data resources under a particular party.

        :param party_id: ID of the associated party. Required.
        :type party_id: str
        :keyword min_avg_planting_rate: Minimum AvgPlantingRate value(inclusive). Default value is
         None.
        :paramtype min_avg_planting_rate: float
        :keyword max_avg_planting_rate: Maximum AvgPlantingRate value (inclusive). Default value is
         None.
        :paramtype max_avg_planting_rate: float
        :keyword min_total_material: Minimum TotalMaterial value(inclusive). Default value is None.
        :paramtype min_total_material: float
        :keyword max_total_material: Maximum TotalMaterial value (inclusive). Default value is None.
        :paramtype max_total_material: float
        :keyword min_avg_material: Minimum AvgMaterial value(inclusive). Default value is None.
        :paramtype min_avg_material: float
        :keyword max_avg_material: Maximum AvgMaterial value (inclusive). Default value is None.
        :paramtype max_avg_material: float
        :keyword sources: Sources of the operation data. Default value is None.
        :paramtype sources: list[str]
        :keyword associated_boundary_ids: Boundary IDs associated with operation data. Default value is
         None.
        :paramtype associated_boundary_ids: list[str]
        :keyword min_operation_start_date_time: Minimum start date-time of the operation data, sample
         format: yyyy-MM-ddTHH:mm:ssZ (inclusive). Default value is None.
        :paramtype min_operation_start_date_time: ~datetime.datetime
        :keyword max_operation_start_date_time: Maximum start date-time of the operation data, sample
         format: yyyy-MM-ddTHH:mm:ssZ (inclusive). Default value is None.
        :paramtype max_operation_start_date_time: ~datetime.datetime
        :keyword min_operation_end_date_time: Minimum end date-time of the operation data, sample
         format: yyyy-MM-ddTHH:mm:ssZ (inclusive). Default value is None.
        :paramtype min_operation_end_date_time: ~datetime.datetime
        :keyword max_operation_end_date_time: Maximum end date-time of the operation data, sample
         format: yyyy-MM-ddTHH:mm:ssZ (inclusive). Default value is None.
        :paramtype max_operation_end_date_time: ~datetime.datetime
        :keyword min_operation_modified_date_time: Minimum modified date-time of the operation data,
         sample format: yyyy-MM-ddTHH:mm:ssZ (inclusive). Default value is None.
        :paramtype min_operation_modified_date_time: ~datetime.datetime
        :keyword max_operation_modified_date_time: Maximum modified date-time of the operation data,
         sample format: yyyy-MM-ddTHH:mm:ssZ (inclusive). Default value is None.
        :paramtype max_operation_modified_date_time: ~datetime.datetime
        :keyword min_area: Minimum area for which operation was applied (inclusive). Default value is
         None.
        :paramtype min_area: float
        :keyword max_area: Maximum area for which operation was applied (inclusive). Default value is
         None.
        :paramtype max_area: float
        :keyword ids: Ids of the resource. Default value is None.
        :paramtype ids: list[str]
        :keyword names: Names of the resource. Default value is None.
        :paramtype names: list[str]
        :keyword property_filters: Filters on key-value pairs within the Properties object.
         eg. "{testKey} eq {testValue}". Default value is None.
        :paramtype property_filters: list[str]
        :keyword statuses: Statuses of the resource. Default value is None.
        :paramtype statuses: list[str]
        :keyword min_created_date_time: Minimum creation date of resource (inclusive). Default value is
         None.
        :paramtype min_created_date_time: ~datetime.datetime
        :keyword max_created_date_time: Maximum creation date of resource (inclusive). Default value is
         None.
        :paramtype max_created_date_time: ~datetime.datetime
        :keyword min_last_modified_date_time: Minimum last modified date of resource (inclusive).
         Default value is None.
        :paramtype min_last_modified_date_time: ~datetime.datetime
        :keyword max_last_modified_date_time: Maximum last modified date of resource (inclusive).
         Default value is None.
        :paramtype max_last_modified_date_time: ~datetime.datetime
        :keyword skip_token: Skip token for getting next set of results. Default value is None.
        :paramtype skip_token: str
        :return: An iterator like instance of JSON object
        :rtype: ~azure.core.paging.ItemPaged[JSON]
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "area": {
                        "unit": "str",  # Optional. Data unit.
                        "value": 0.0  # Optional. Data value.
                    },
                    "associatedBoundaryId": "str",  # Optional. Optional boundary ID of the field
                      for which operation was applied.
                    "attachmentsLink": "str",  # Optional. Link for attachments.
                    "avgMaterial": {
                        "unit": "str",  # Optional. Data unit.
                        "value": 0.0  # Optional. Data value.
                    },
                    "avgPlantingRate": {
                        "unit": "str",  # Optional. Data unit.
                        "value": 0.0  # Optional. Data value.
                    },
                    "createdBy": "str",  # Optional. Created by user/tenant id.
                    "createdDateTime": "2020-02-20 00:00:00",  # Optional. Date-time when
                      resource was created, sample format: yyyy-MM-ddTHH:mm:ssZ.
                    "description": "str",  # Optional. Textual description of the resource.
                    "eTag": "str",  # Optional. The ETag value to implement optimistic
                      concurrency.
                    "id": "str",  # Optional. Unique resource ID.
                    "modifiedBy": "str",  # Optional. Modified by user/tenant id.
                    "modifiedDateTime": "2020-02-20 00:00:00",  # Optional. Date-time when
                      resource was last modified, sample format: yyyy-MM-ddTHH:mm:ssZ.
                    "name": "str",  # Optional. Name to identify resource.
                    "operationEndDateTime": "2020-02-20 00:00:00",  # Optional. End date-time of
                      the operation data, sample format: yyyy-MM-ddTHH:mm:ssZ.
                    "operationModifiedDateTime": "2020-02-20 00:00:00",  # Optional. Modified
                      date-time of the operation data, sample format: yyyy-MM-ddTHH:mm:ssZ."nNote: this
                      will be specified by the source provider itself.
                    "operationStartDateTime": "2020-02-20 00:00:00",  # Optional. Start date-time
                      of the operation data, sample format: yyyy-MM-ddTHH:mm:ssZ.
                    "partyId": "str",  # Optional. Party ID which belongs to the operation data.
                    "plantingProductDetails": [
                        {
                            "area": {
                                "unit": "str",  # Optional. Data unit.
                                "value": 0.0  # Optional. Data value.
                            },
                            "avgMaterial": {
                                "unit": "str",  # Optional. Data unit.
                                "value": 0.0  # Optional. Data value.
                            },
                            "productName": "str",  # Optional. Name of the product.
                            "totalMaterial": {
                                "unit": "str",  # Optional. Data unit.
                                "value": 0.0  # Optional. Data value.
                            }
                        }
                    ],
                    "properties": {
                        "str": {}  # Optional. A collection of key value pairs that belongs
                          to the resource."nEach pair must not have a key greater than 50
                          characters"nand must not have a value greater than 150 characters."nNote: A
                          maximum of 25 key value pairs can be provided for a resource and only
                          string,"nnumeral and datetime (yyyy-MM-ddTHH:mm:ssZ) values are supported.
                    },
                    "source": "str",  # Optional. Source of the resource.
                    "status": "str",  # Optional. Status of the resource.
                    "totalMaterial": {
                        "unit": "str",  # Optional. Data unit.
                        "value": 0.0  # Optional. Data value.
                    }
                }
        """
        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls = kwargs.pop("cls", None)  # type: ClsType[JSON]

        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        def prepare_request(next_link=None):
            if not next_link:

                request = build_planting_data_list_by_party_id_request(
                    party_id=party_id,
                    min_avg_planting_rate=min_avg_planting_rate,
                    max_avg_planting_rate=max_avg_planting_rate,
                    min_total_material=min_total_material,
                    max_total_material=max_total_material,
                    min_avg_material=min_avg_material,
                    max_avg_material=max_avg_material,
                    sources=sources,
                    associated_boundary_ids=associated_boundary_ids,
                    min_operation_start_date_time=min_operation_start_date_time,
                    max_operation_start_date_time=max_operation_start_date_time,
                    min_operation_end_date_time=min_operation_end_date_time,
                    max_operation_end_date_time=max_operation_end_date_time,
                    min_operation_modified_date_time=min_operation_modified_date_time,
                    max_operation_modified_date_time=max_operation_modified_date_time,
                    min_area=min_area,
                    max_area=max_area,
                    ids=ids,
                    names=names,
                    property_filters=property_filters,
                    statuses=statuses,
                    min_created_date_time=min_created_date_time,
                    max_created_date_time=max_created_date_time,
                    min_last_modified_date_time=min_last_modified_date_time,
                    max_last_modified_date_time=max_last_modified_date_time,
                    skip_token=skip_token,
                    api_version=self._config.api_version,
                    headers=_headers,
                    params=_params,
                )
                request.url = self._client.format_url(request.url)  # type: ignore

            else:
                # make call to next link with the client's api-version
                _parsed_next_link = urlparse(next_link)
                _next_request_params = case_insensitive_dict(parse_qs(_parsed_next_link.query))
                _next_request_params["api-version"] = self._config.api_version
                request = HttpRequest("GET", urljoin(next_link, _parsed_next_link.path), params=_next_request_params)
                request.url = self._client.format_url(request.url)  # type: ignore

            return request

        def extract_data(pipeline_response):
            deserialized = pipeline_response.http_response.json()
            list_of_elem = deserialized["value"]
            if cls:
                list_of_elem = cls(list_of_elem)
            return deserialized.get("nextLink", None), iter(list_of_elem)

        def get_next(next_link=None):
            request = prepare_request(next_link)

            pipeline_response = self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
                request, stream=False, **kwargs
            )
            response = pipeline_response.http_response

            if response.status_code not in [200]:
                map_error(status_code=response.status_code, response=response, error_map=error_map)
                raise HttpResponseError(response=response)

            return pipeline_response

        return ItemPaged(get_next, extract_data)

    @distributed_trace
    def get(self, party_id: str, planting_data_id: str, **kwargs: Any) -> JSON:
        """Get a specified planting data resource under a particular party.

        :param party_id: ID of the associated party resource. Required.
        :type party_id: str
        :param planting_data_id: ID of the planting data resource. Required.
        :type planting_data_id: str
        :return: JSON object
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "area": {
                        "unit": "str",  # Optional. Data unit.
                        "value": 0.0  # Optional. Data value.
                    },
                    "associatedBoundaryId": "str",  # Optional. Optional boundary ID of the field
                      for which operation was applied.
                    "attachmentsLink": "str",  # Optional. Link for attachments.
                    "avgMaterial": {
                        "unit": "str",  # Optional. Data unit.
                        "value": 0.0  # Optional. Data value.
                    },
                    "avgPlantingRate": {
                        "unit": "str",  # Optional. Data unit.
                        "value": 0.0  # Optional. Data value.
                    },
                    "createdBy": "str",  # Optional. Created by user/tenant id.
                    "createdDateTime": "2020-02-20 00:00:00",  # Optional. Date-time when
                      resource was created, sample format: yyyy-MM-ddTHH:mm:ssZ.
                    "description": "str",  # Optional. Textual description of the resource.
                    "eTag": "str",  # Optional. The ETag value to implement optimistic
                      concurrency.
                    "id": "str",  # Optional. Unique resource ID.
                    "modifiedBy": "str",  # Optional. Modified by user/tenant id.
                    "modifiedDateTime": "2020-02-20 00:00:00",  # Optional. Date-time when
                      resource was last modified, sample format: yyyy-MM-ddTHH:mm:ssZ.
                    "name": "str",  # Optional. Name to identify resource.
                    "operationEndDateTime": "2020-02-20 00:00:00",  # Optional. End date-time of
                      the operation data, sample format: yyyy-MM-ddTHH:mm:ssZ.
                    "operationModifiedDateTime": "2020-02-20 00:00:00",  # Optional. Modified
                      date-time of the operation data, sample format: yyyy-MM-ddTHH:mm:ssZ."nNote: this
                      will be specified by the source provider itself.
                    "operationStartDateTime": "2020-02-20 00:00:00",  # Optional. Start date-time
                      of the operation data, sample format: yyyy-MM-ddTHH:mm:ssZ.
                    "partyId": "str",  # Optional. Party ID which belongs to the operation data.
                    "plantingProductDetails": [
                        {
                            "area": {
                                "unit": "str",  # Optional. Data unit.
                                "value": 0.0  # Optional. Data value.
                            },
                            "avgMaterial": {
                                "unit": "str",  # Optional. Data unit.
                                "value": 0.0  # Optional. Data value.
                            },
                            "productName": "str",  # Optional. Name of the product.
                            "totalMaterial": {
                                "unit": "str",  # Optional. Data unit.
                                "value": 0.0  # Optional. Data value.
                            }
                        }
                    ],
                    "properties": {
                        "str": {}  # Optional. A collection of key value pairs that belongs
                          to the resource."nEach pair must not have a key greater than 50
                          characters"nand must not have a value greater than 150 characters."nNote: A
                          maximum of 25 key value pairs can be provided for a resource and only
                          string,"nnumeral and datetime (yyyy-MM-ddTHH:mm:ssZ) values are supported.
                    },
                    "source": "str",  # Optional. Source of the resource.
                    "status": "str",  # Optional. Status of the resource.
                    "totalMaterial": {
                        "unit": "str",  # Optional. Data unit.
                        "value": 0.0  # Optional. Data value.
                    }
                }
        """
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls = kwargs.pop("cls", None)  # type: ClsType[JSON]

        request = build_planting_data_get_request(
            party_id=party_id,
            planting_data_id=planting_data_id,
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        request.url = self._client.format_url(request.url)  # type: ignore

        pipeline_response = self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
            request, stream=False, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if response.content:
            deserialized = response.json()
        else:
            deserialized = None

        if cls:
            return cls(pipeline_response, cast(JSON, deserialized), {})

        return cast(JSON, deserialized)

    @overload
    def create_or_update(
        self,
        party_id: str,
        planting_data_id: str,
        planting_data: JSON,
        *,
        content_type: str = "application/merge-patch+json",
        **kwargs: Any
    ) -> JSON:
        """Creates or updates an planting data resource under a particular party.

        :param party_id: ID of the associated party. Required.
        :type party_id: str
        :param planting_data_id: ID of the planting data resource. Required.
        :type planting_data_id: str
        :param planting_data: Planting data resource payload to create or update. Required.
        :type planting_data: JSON
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/merge-patch+json".
        :paramtype content_type: str
        :return: JSON object
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                planting_data = {
                    "area": {
                        "unit": "str",  # Optional. Data unit.
                        "value": 0.0  # Optional. Data value.
                    },
                    "associatedBoundaryId": "str",  # Optional. Optional boundary ID of the field
                      for which operation was applied.
                    "attachmentsLink": "str",  # Optional. Link for attachments.
                    "avgMaterial": {
                        "unit": "str",  # Optional. Data unit.
                        "value": 0.0  # Optional. Data value.
                    },
                    "avgPlantingRate": {
                        "unit": "str",  # Optional. Data unit.
                        "value": 0.0  # Optional. Data value.
                    },
                    "createdBy": "str",  # Optional. Created by user/tenant id.
                    "createdDateTime": "2020-02-20 00:00:00",  # Optional. Date-time when
                      resource was created, sample format: yyyy-MM-ddTHH:mm:ssZ.
                    "description": "str",  # Optional. Textual description of the resource.
                    "eTag": "str",  # Optional. The ETag value to implement optimistic
                      concurrency.
                    "id": "str",  # Optional. Unique resource ID.
                    "modifiedBy": "str",  # Optional. Modified by user/tenant id.
                    "modifiedDateTime": "2020-02-20 00:00:00",  # Optional. Date-time when
                      resource was last modified, sample format: yyyy-MM-ddTHH:mm:ssZ.
                    "name": "str",  # Optional. Name to identify resource.
                    "operationEndDateTime": "2020-02-20 00:00:00",  # Optional. End date-time of
                      the operation data, sample format: yyyy-MM-ddTHH:mm:ssZ.
                    "operationModifiedDateTime": "2020-02-20 00:00:00",  # Optional. Modified
                      date-time of the operation data, sample format: yyyy-MM-ddTHH:mm:ssZ."nNote: this
                      will be specified by the source provider itself.
                    "operationStartDateTime": "2020-02-20 00:00:00",  # Optional. Start date-time
                      of the operation data, sample format: yyyy-MM-ddTHH:mm:ssZ.
                    "partyId": "str",  # Optional. Party ID which belongs to the operation data.
                    "plantingProductDetails": [
                        {
                            "area": {
                                "unit": "str",  # Optional. Data unit.
                                "value": 0.0  # Optional. Data value.
                            },
                            "avgMaterial": {
                                "unit": "str",  # Optional. Data unit.
                                "value": 0.0  # Optional. Data value.
                            },
                            "productName": "str",  # Optional. Name of the product.
                            "totalMaterial": {
                                "unit": "str",  # Optional. Data unit.
                                "value": 0.0  # Optional. Data value.
                            }
                        }
                    ],
                    "properties": {
                        "str": {}  # Optional. A collection of key value pairs that belongs
                          to the resource."nEach pair must not have a key greater than 50
                          characters"nand must not have a value greater than 150 characters."nNote: A
                          maximum of 25 key value pairs can be provided for a resource and only
                          string,"nnumeral and datetime (yyyy-MM-ddTHH:mm:ssZ) values are supported.
                    },
                    "source": "str",  # Optional. Source of the resource.
                    "status": "str",  # Optional. Status of the resource.
                    "totalMaterial": {
                        "unit": "str",  # Optional. Data unit.
                        "value": 0.0  # Optional. Data value.
                    }
                }

                # response body for status code(s): 200, 201
                response == {
                    "area": {
                        "unit": "str",  # Optional. Data unit.
                        "value": 0.0  # Optional. Data value.
                    },
                    "associatedBoundaryId": "str",  # Optional. Optional boundary ID of the field
                      for which operation was applied.
                    "attachmentsLink": "str",  # Optional. Link for attachments.
                    "avgMaterial": {
                        "unit": "str",  # Optional. Data unit.
                        "value": 0.0  # Optional. Data value.
                    },
                    "avgPlantingRate": {
                        "unit": "str",  # Optional. Data unit.
                        "value": 0.0  # Optional. Data value.
                    },
                    "createdBy": "str",  # Optional. Created by user/tenant id.
                    "createdDateTime": "2020-02-20 00:00:00",  # Optional. Date-time when
                      resource was created, sample format: yyyy-MM-ddTHH:mm:ssZ.
                    "description": "str",  # Optional. Textual description of the resource.
                    "eTag": "str",  # Optional. The ETag value to implement optimistic
                      concurrency.
                    "id": "str",  # Optional. Unique resource ID.
                    "modifiedBy": "str",  # Optional. Modified by user/tenant id.
                    "modifiedDateTime": "2020-02-20 00:00:00",  # Optional. Date-time when
                      resource was last modified, sample format: yyyy-MM-ddTHH:mm:ssZ.
                    "name": "str",  # Optional. Name to identify resource.
                    "operationEndDateTime": "2020-02-20 00:00:00",  # Optional. End date-time of
                      the operation data, sample format: yyyy-MM-ddTHH:mm:ssZ.
                    "operationModifiedDateTime": "2020-02-20 00:00:00",  # Optional. Modified
                      date-time of the operation data, sample format: yyyy-MM-ddTHH:mm:ssZ."nNote: this
                      will be specified by the source provider itself.
                    "operationStartDateTime": "2020-02-20 00:00:00",  # Optional. Start date-time
                      of the operation data, sample format: yyyy-MM-ddTHH:mm:ssZ.
                    "partyId": "str",  # Optional. Party ID which belongs to the operation data.
                    "plantingProductDetails": [
                        {
                            "area": {
                                "unit": "str",  # Optional. Data unit.
                                "value": 0.0  # Optional. Data value.
                            },
                            "avgMaterial": {
                                "unit": "str",  # Optional. Data unit.
                                "value": 0.0  # Optional. Data value.
                            },
                            "productName": "str",  # Optional. Name of the product.
                            "totalMaterial": {
                                "unit": "str",  # Optional. Data unit.
                                "value": 0.0  # Optional. Data value.
                            }
                        }
                    ],
                    "properties": {
                        "str": {}  # Optional. A collection of key value pairs that belongs
                          to the resource."nEach pair must not have a key greater than 50
                          characters"nand must not have a value greater than 150 characters."nNote: A
                          maximum of 25 key value pairs can be provided for a resource and only
                          string,"nnumeral and datetime (yyyy-MM-ddTHH:mm:ssZ) values are supported.
                    },
                    "source": "str",  # Optional. Source of the resource.
                    "status": "str",  # Optional. Status of the resource.
                    "totalMaterial": {
                        "unit": "str",  # Optional. Data unit.
                        "value": 0.0  # Optional. Data value.
                    }
                }
        """

    @overload
    def create_or_update(
        self,
        party_id: str,
        planting_data_id: str,
        planting_data: IO,
        *,
        content_type: str = "application/merge-patch+json",
        **kwargs: Any
    ) -> JSON:
        """Creates or updates an planting data resource under a particular party.

        :param party_id: ID of the associated party. Required.
        :type party_id: str
        :param planting_data_id: ID of the planting data resource. Required.
        :type planting_data_id: str
        :param planting_data: Planting data resource payload to create or update. Required.
        :type planting_data: IO
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Default value is "application/merge-patch+json".
        :paramtype content_type: str
        :return: JSON object
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200, 201
                response == {
                    "area": {
                        "unit": "str",  # Optional. Data unit.
                        "value": 0.0  # Optional. Data value.
                    },
                    "associatedBoundaryId": "str",  # Optional. Optional boundary ID of the field
                      for which operation was applied.
                    "attachmentsLink": "str",  # Optional. Link for attachments.
                    "avgMaterial": {
                        "unit": "str",  # Optional. Data unit.
                        "value": 0.0  # Optional. Data value.
                    },
                    "avgPlantingRate": {
                        "unit": "str",  # Optional. Data unit.
                        "value": 0.0  # Optional. Data value.
                    },
                    "createdBy": "str",  # Optional. Created by user/tenant id.
                    "createdDateTime": "2020-02-20 00:00:00",  # Optional. Date-time when
                      resource was created, sample format: yyyy-MM-ddTHH:mm:ssZ.
                    "description": "str",  # Optional. Textual description of the resource.
                    "eTag": "str",  # Optional. The ETag value to implement optimistic
                      concurrency.
                    "id": "str",  # Optional. Unique resource ID.
                    "modifiedBy": "str",  # Optional. Modified by user/tenant id.
                    "modifiedDateTime": "2020-02-20 00:00:00",  # Optional. Date-time when
                      resource was last modified, sample format: yyyy-MM-ddTHH:mm:ssZ.
                    "name": "str",  # Optional. Name to identify resource.
                    "operationEndDateTime": "2020-02-20 00:00:00",  # Optional. End date-time of
                      the operation data, sample format: yyyy-MM-ddTHH:mm:ssZ.
                    "operationModifiedDateTime": "2020-02-20 00:00:00",  # Optional. Modified
                      date-time of the operation data, sample format: yyyy-MM-ddTHH:mm:ssZ."nNote: this
                      will be specified by the source provider itself.
                    "operationStartDateTime": "2020-02-20 00:00:00",  # Optional. Start date-time
                      of the operation data, sample format: yyyy-MM-ddTHH:mm:ssZ.
                    "partyId": "str",  # Optional. Party ID which belongs to the operation data.
                    "plantingProductDetails": [
                        {
                            "area": {
                                "unit": "str",  # Optional. Data unit.
                                "value": 0.0  # Optional. Data value.
                            },
                            "avgMaterial": {
                                "unit": "str",  # Optional. Data unit.
                                "value": 0.0  # Optional. Data value.
                            },
                            "productName": "str",  # Optional. Name of the product.
                            "totalMaterial": {
                                "unit": "str",  # Optional. Data unit.
                                "value": 0.0  # Optional. Data value.
                            }
                        }
                    ],
                    "properties": {
                        "str": {}  # Optional. A collection of key value pairs that belongs
                          to the resource."nEach pair must not have a key greater than 50
                          characters"nand must not have a value greater than 150 characters."nNote: A
                          maximum of 25 key value pairs can be provided for a resource and only
                          string,"nnumeral and datetime (yyyy-MM-ddTHH:mm:ssZ) values are supported.
                    },
                    "source": "str",  # Optional. Source of the resource.
                    "status": "str",  # Optional. Status of the resource.
                    "totalMaterial": {
                        "unit": "str",  # Optional. Data unit.
                        "value": 0.0  # Optional. Data value.
                    }
                }
        """

    @distributed_trace
    def create_or_update(
        self, party_id: str, planting_data_id: str, planting_data: Union[JSON, IO], **kwargs: Any
    ) -> JSON:
        """Creates or updates an planting data resource under a particular party.

        :param party_id: ID of the associated party. Required.
        :type party_id: str
        :param planting_data_id: ID of the planting data resource. Required.
        :type planting_data_id: str
        :param planting_data: Planting data resource payload to create or update. Is either a model
         type or a IO type. Required.
        :type planting_data: JSON or IO
        :keyword content_type: Body Parameter content-type. Known values are:
         'application/merge-patch+json'. Default value is None.
        :paramtype content_type: str
        :return: JSON object
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200, 201
                response == {
                    "area": {
                        "unit": "str",  # Optional. Data unit.
                        "value": 0.0  # Optional. Data value.
                    },
                    "associatedBoundaryId": "str",  # Optional. Optional boundary ID of the field
                      for which operation was applied.
                    "attachmentsLink": "str",  # Optional. Link for attachments.
                    "avgMaterial": {
                        "unit": "str",  # Optional. Data unit.
                        "value": 0.0  # Optional. Data value.
                    },
                    "avgPlantingRate": {
                        "unit": "str",  # Optional. Data unit.
                        "value": 0.0  # Optional. Data value.
                    },
                    "createdBy": "str",  # Optional. Created by user/tenant id.
                    "createdDateTime": "2020-02-20 00:00:00",  # Optional. Date-time when
                      resource was created, sample format: yyyy-MM-ddTHH:mm:ssZ.
                    "description": "str",  # Optional. Textual description of the resource.
                    "eTag": "str",  # Optional. The ETag value to implement optimistic
                      concurrency.
                    "id": "str",  # Optional. Unique resource ID.
                    "modifiedBy": "str",  # Optional. Modified by user/tenant id.
                    "modifiedDateTime": "2020-02-20 00:00:00",  # Optional. Date-time when
                      resource was last modified, sample format: yyyy-MM-ddTHH:mm:ssZ.
                    "name": "str",  # Optional. Name to identify resource.
                    "operationEndDateTime": "2020-02-20 00:00:00",  # Optional. End date-time of
                      the operation data, sample format: yyyy-MM-ddTHH:mm:ssZ.
                    "operationModifiedDateTime": "2020-02-20 00:00:00",  # Optional. Modified
                      date-time of the operation data, sample format: yyyy-MM-ddTHH:mm:ssZ."nNote: this
                      will be specified by the source provider itself.
                    "operationStartDateTime": "2020-02-20 00:00:00",  # Optional. Start date-time
                      of the operation data, sample format: yyyy-MM-ddTHH:mm:ssZ.
                    "partyId": "str",  # Optional. Party ID which belongs to the operation data.
                    "plantingProductDetails": [
                        {
                            "area": {
                                "unit": "str",  # Optional. Data unit.
                                "value": 0.0  # Optional. Data value.
                            },
                            "avgMaterial": {
                                "unit": "str",  # Optional. Data unit.
                                "value": 0.0  # Optional. Data value.
                            },
                            "productName": "str",  # Optional. Name of the product.
                            "totalMaterial": {
                                "unit": "str",  # Optional. Data unit.
                                "value": 0.0  # Optional. Data value.
                            }
                        }
                    ],
                    "properties": {
                        "str": {}  # Optional. A collection of key value pairs that belongs
                          to the resource."nEach pair must not have a key greater than 50
                          characters"nand must not have a value greater than 150 characters."nNote: A
                          maximum of 25 key value pairs can be provided for a resource and only
                          string,"nnumeral and datetime (yyyy-MM-ddTHH:mm:ssZ) values are supported.
                    },
                    "source": "str",  # Optional. Source of the resource.
                    "status": "str",  # Optional. Status of the resource.
                    "totalMaterial": {
                        "unit": "str",  # Optional. Data unit.
                        "value": 0.0  # Optional. Data value.
                    }
                }
        """
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type = kwargs.pop("content_type", _headers.pop("Content-Type", None))  # type: Optional[str]
        cls = kwargs.pop("cls", None)  # type: ClsType[JSON]

        content_type = content_type or "application/merge-patch+json"
        _json = None
        _content = None
        if isinstance(planting_data, (IO, bytes)):
            _content = planting_data
        else:
            _json = planting_data

        request = build_planting_data_create_or_update_request(
            party_id=party_id,
            planting_data_id=planting_data_id,
            content_type=content_type,
            api_version=self._config.api_version,
            json=_json,
            content=_content,
            headers=_headers,
            params=_params,
        )
        request.url = self._client.format_url(request.url)  # type: ignore

        pipeline_response = self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
            request, stream=False, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200, 201]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if response.status_code == 200:
            if response.content:
                deserialized = response.json()
            else:
                deserialized = None

        if response.status_code == 201:
            if response.content:
                deserialized = response.json()
            else:
                deserialized = None

        if cls:
            return cls(pipeline_response, cast(JSON, deserialized), {})

        return cast(JSON, deserialized)

    @distributed_trace
    def delete(  # pylint: disable=inconsistent-return-statements
        self, party_id: str, planting_data_id: str, **kwargs: Any
    ) -> None:
        """Deletes a specified planting data resource under a particular party.

        :param party_id: ID of the associated party resource. Required.
        :type party_id: str
        :param planting_data_id: ID of the planting data. Required.
        :type planting_data_id: str
        :return: None
        :rtype: None
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls = kwargs.pop("cls", None)  # type: ClsType[None]

        request = build_planting_data_delete_request(
            party_id=party_id,
            planting_data_id=planting_data_id,
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        request.url = self._client.format_url(request.url)  # type: ignore

        pipeline_response = self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
            request, stream=False, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [204]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if cls:
            return cls(pipeline_response, None, {})

    @distributed_trace
    def list(
        self,
        *,
        min_avg_planting_rate: Optional[float] = None,
        max_avg_planting_rate: Optional[float] = None,
        min_total_material: Optional[float] = None,
        max_total_material: Optional[float] = None,
        min_avg_material: Optional[float] = None,
        max_avg_material: Optional[float] = None,
        sources: Optional[List[str]] = None,
        associated_boundary_ids: Optional[List[str]] = None,
        min_operation_start_date_time: Optional[datetime.datetime] = None,
        max_operation_start_date_time: Optional[datetime.datetime] = None,
        min_operation_end_date_time: Optional[datetime.datetime] = None,
        max_operation_end_date_time: Optional[datetime.datetime] = None,
        min_operation_modified_date_time: Optional[datetime.datetime] = None,
        max_operation_modified_date_time: Optional[datetime.datetime] = None,
        min_area: Optional[float] = None,
        max_area: Optional[float] = None,
        ids: Optional[List[str]] = None,
        names: Optional[List[str]] = None,
        property_filters: Optional[List[str]] = None,
        statuses: Optional[List[str]] = None,
        min_created_date_time: Optional[datetime.datetime] = None,
        max_created_date_time: Optional[datetime.datetime] = None,
        min_last_modified_date_time: Optional[datetime.datetime] = None,
        max_last_modified_date_time: Optional[datetime.datetime] = None,
        skip_token: Optional[str] = None,
        **kwargs: Any
    ) -> Iterable[JSON]:
        """Returns a paginated list of planting data resources across all parties.

        :keyword min_avg_planting_rate: Minimum AvgPlantingRate value(inclusive). Default value is
         None.
        :paramtype min_avg_planting_rate: float
        :keyword max_avg_planting_rate: Maximum AvgPlantingRate value (inclusive). Default value is
         None.
        :paramtype max_avg_planting_rate: float
        :keyword min_total_material: Minimum TotalMaterial value(inclusive). Default value is None.
        :paramtype min_total_material: float
        :keyword max_total_material: Maximum TotalMaterial value (inclusive). Default value is None.
        :paramtype max_total_material: float
        :keyword min_avg_material: Minimum AvgMaterial value(inclusive). Default value is None.
        :paramtype min_avg_material: float
        :keyword max_avg_material: Maximum AvgMaterial value (inclusive). Default value is None.
        :paramtype max_avg_material: float
        :keyword sources: Sources of the operation data. Default value is None.
        :paramtype sources: list[str]
        :keyword associated_boundary_ids: Boundary IDs associated with operation data. Default value is
         None.
        :paramtype associated_boundary_ids: list[str]
        :keyword min_operation_start_date_time: Minimum start date-time of the operation data, sample
         format: yyyy-MM-ddTHH:mm:ssZ (inclusive). Default value is None.
        :paramtype min_operation_start_date_time: ~datetime.datetime
        :keyword max_operation_start_date_time: Maximum start date-time of the operation data, sample
         format: yyyy-MM-ddTHH:mm:ssZ (inclusive). Default value is None.
        :paramtype max_operation_start_date_time: ~datetime.datetime
        :keyword min_operation_end_date_time: Minimum end date-time of the operation data, sample
         format: yyyy-MM-ddTHH:mm:ssZ (inclusive). Default value is None.
        :paramtype min_operation_end_date_time: ~datetime.datetime
        :keyword max_operation_end_date_time: Maximum end date-time of the operation data, sample
         format: yyyy-MM-ddTHH:mm:ssZ (inclusive). Default value is None.
        :paramtype max_operation_end_date_time: ~datetime.datetime
        :keyword min_operation_modified_date_time: Minimum modified date-time of the operation data,
         sample format: yyyy-MM-ddTHH:mm:ssZ (inclusive). Default value is None.
        :paramtype min_operation_modified_date_time: ~datetime.datetime
        :keyword max_operation_modified_date_time: Maximum modified date-time of the operation data,
         sample format: yyyy-MM-ddTHH:mm:ssZ (inclusive). Default value is None.
        :paramtype max_operation_modified_date_time: ~datetime.datetime
        :keyword min_area: Minimum area for which operation was applied (inclusive). Default value is
         None.
        :paramtype min_area: float
        :keyword max_area: Maximum area for which operation was applied (inclusive). Default value is
         None.
        :paramtype max_area: float
        :keyword ids: Ids of the resource. Default value is None.
        :paramtype ids: list[str]
        :keyword names: Names of the resource. Default value is None.
        :paramtype names: list[str]
        :keyword property_filters: Filters on key-value pairs within the Properties object.
         eg. "{testKey} eq {testValue}". Default value is None.
        :paramtype property_filters: list[str]
        :keyword statuses: Statuses of the resource. Default value is None.
        :paramtype statuses: list[str]
        :keyword min_created_date_time: Minimum creation date of resource (inclusive). Default value is
         None.
        :paramtype min_created_date_time: ~datetime.datetime
        :keyword max_created_date_time: Maximum creation date of resource (inclusive). Default value is
         None.
        :paramtype max_created_date_time: ~datetime.datetime
        :keyword min_last_modified_date_time: Minimum last modified date of resource (inclusive).
         Default value is None.
        :paramtype min_last_modified_date_time: ~datetime.datetime
        :keyword max_last_modified_date_time: Maximum last modified date of resource (inclusive).
         Default value is None.
        :paramtype max_last_modified_date_time: ~datetime.datetime
        :keyword skip_token: Skip token for getting next set of results. Default value is None.
        :paramtype skip_token: str
        :return: An iterator like instance of JSON object
        :rtype: ~azure.core.paging.ItemPaged[JSON]
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "area": {
                        "unit": "str",  # Optional. Data unit.
                        "value": 0.0  # Optional. Data value.
                    },
                    "associatedBoundaryId": "str",  # Optional. Optional boundary ID of the field
                      for which operation was applied.
                    "attachmentsLink": "str",  # Optional. Link for attachments.
                    "avgMaterial": {
                        "unit": "str",  # Optional. Data unit.
                        "value": 0.0  # Optional. Data value.
                    },
                    "avgPlantingRate": {
                        "unit": "str",  # Optional. Data unit.
                        "value": 0.0  # Optional. Data value.
                    },
                    "createdBy": "str",  # Optional. Created by user/tenant id.
                    "createdDateTime": "2020-02-20 00:00:00",  # Optional. Date-time when
                      resource was created, sample format: yyyy-MM-ddTHH:mm:ssZ.
                    "description": "str",  # Optional. Textual description of the resource.
                    "eTag": "str",  # Optional. The ETag value to implement optimistic
                      concurrency.
                    "id": "str",  # Optional. Unique resource ID.
                    "modifiedBy": "str",  # Optional. Modified by user/tenant id.
                    "modifiedDateTime": "2020-02-20 00:00:00",  # Optional. Date-time when
                      resource was last modified, sample format: yyyy-MM-ddTHH:mm:ssZ.
                    "name": "str",  # Optional. Name to identify resource.
                    "operationEndDateTime": "2020-02-20 00:00:00",  # Optional. End date-time of
                      the operation data, sample format: yyyy-MM-ddTHH:mm:ssZ.
                    "operationModifiedDateTime": "2020-02-20 00:00:00",  # Optional. Modified
                      date-time of the operation data, sample format: yyyy-MM-ddTHH:mm:ssZ."nNote: this
                      will be specified by the source provider itself.
                    "operationStartDateTime": "2020-02-20 00:00:00",  # Optional. Start date-time
                      of the operation data, sample format: yyyy-MM-ddTHH:mm:ssZ.
                    "partyId": "str",  # Optional. Party ID which belongs to the operation data.
                    "plantingProductDetails": [
                        {
                            "area": {
                                "unit": "str",  # Optional. Data unit.
                                "value": 0.0  # Optional. Data value.
                            },
                            "avgMaterial": {
                                "unit": "str",  # Optional. Data unit.
                                "value": 0.0  # Optional. Data value.
                            },
                            "productName": "str",  # Optional. Name of the product.
                            "totalMaterial": {
                                "unit": "str",  # Optional. Data unit.
                                "value": 0.0  # Optional. Data value.
                            }
                        }
                    ],
                    "properties": {
                        "str": {}  # Optional. A collection of key value pairs that belongs
                          to the resource."nEach pair must not have a key greater than 50
                          characters"nand must not have a value greater than 150 characters."nNote: A
                          maximum of 25 key value pairs can be provided for a resource and only
                          string,"nnumeral and datetime (yyyy-MM-ddTHH:mm:ssZ) values are supported.
                    },
                    "source": "str",  # Optional. Source of the resource.
                    "status": "str",  # Optional. Status of the resource.
                    "totalMaterial": {
                        "unit": "str",  # Optional. Data unit.
                        "value": 0.0  # Optional. Data value.
                    }
                }
        """
        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls = kwargs.pop("cls", None)  # type: ClsType[JSON]

        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        def prepare_request(next_link=None):
            if not next_link:

                request = build_planting_data_list_request(
                    min_avg_planting_rate=min_avg_planting_rate,
                    max_avg_planting_rate=max_avg_planting_rate,
                    min_total_material=min_total_material,
                    max_total_material=max_total_material,
                    min_avg_material=min_avg_material,
                    max_avg_material=max_avg_material,
                    sources=sources,
                    associated_boundary_ids=associated_boundary_ids,
                    min_operation_start_date_time=min_operation_start_date_time,
                    max_operation_start_date_time=max_operation_start_date_time,
                    min_operation_end_date_time=min_operation_end_date_time,
                    max_operation_end_date_time=max_operation_end_date_time,
                    min_operation_modified_date_time=min_operation_modified_date_time,
                    max_operation_modified_date_time=max_operation_modified_date_time,
                    min_area=min_area,
                    max_area=max_area,
                    ids=ids,
                    names=names,
                    property_filters=property_filters,
                    statuses=statuses,
                    min_created_date_time=min_created_date_time,
                    max_created_date_time=max_created_date_time,
                    min_last_modified_date_time=min_last_modified_date_time,
                    max_last_modified_date_time=max_last_modified_date_time,
                    skip_token=skip_token,
                    api_version=self._config.api_version,
                    headers=_headers,
                    params=_params,
                )
                request.url = self._client.format_url(request.url)  # type: ignore

            else:
                # make call to next link with the client's api-version
                _parsed_next_link = urlparse(next_link)
                _next_request_params = case_insensitive_dict(parse_qs(_parsed_next_link.query))
                _next_request_params["api-version"] = self._config.api_version
                request = HttpRequest("GET", urljoin(next_link, _parsed_next_link.path), params=_next_request_params)
                request.url = self._client.format_url(request.url)  # type: ignore

            return request

        def extract_data(pipeline_response):
            deserialized = pipeline_response.http_response.json()
            list_of_elem = deserialized["value"]
            if cls:
                list_of_elem = cls(list_of_elem)
            return deserialized.get("nextLink", None), iter(list_of_elem)

        def get_next(next_link=None):
            request = prepare_request(next_link)

            pipeline_response = self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
                request, stream=False, **kwargs
            )
            response = pipeline_response.http_response

            if response.status_code not in [200]:
                map_error(status_code=response.status_code, response=response, error_map=error_map)
                raise HttpResponseError(response=response)

            return pipeline_response

        return ItemPaged(get_next, extract_data)

    def _create_cascade_delete_job_initial(
        self, job_id: str, *, party_id: str, planting_data_id: str, **kwargs: Any
    ) -> JSON:
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls = kwargs.pop("cls", None)  # type: ClsType[JSON]

        request = build_planting_data_create_cascade_delete_job_request(
            job_id=job_id,
            party_id=party_id,
            planting_data_id=planting_data_id,
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        request.url = self._client.format_url(request.url)  # type: ignore

        pipeline_response = self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
            request, stream=False, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [202]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if response.content:
            deserialized = response.json()
        else:
            deserialized = None

        if cls:
            return cls(pipeline_response, cast(JSON, deserialized), {})

        return cast(JSON, deserialized)

    @distributed_trace
    def begin_create_cascade_delete_job(
        self, job_id: str, *, party_id: str, planting_data_id: str, **kwargs: Any
    ) -> LROPoller[JSON]:
        """Create cascade delete job for planting data resource.

        :param job_id: Job Id supplied by end user. Required.
        :type job_id: str
        :keyword party_id: Id of the party. Required.
        :paramtype party_id: str
        :keyword planting_data_id: Id of the planting data. Required.
        :paramtype planting_data_id: str
        :keyword str continuation_token: A continuation token to restart a poller from a saved state.
        :keyword polling: By default, your polling method will be LROBasePolling. Pass in False for
         this operation to not poll, or pass in your own initialized polling object for a personal
         polling strategy.
        :paramtype polling: bool or ~azure.core.polling.PollingMethod
        :keyword int polling_interval: Default waiting time between two polls for LRO operations if no
         Retry-After header is present.
        :return: An instance of LROPoller that returns JSON object
        :rtype: ~azure.core.polling.LROPoller[JSON]
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 202
                response == {
                    "partyId": "str",  # Party Id. Required.
                    "resourceId": "str",  # The id of the resource. Required.
                    "resourceType": "str",  # The type of the resource. Required.
                    "createdDateTime": "2020-02-20 00:00:00",  # Optional. Job created at
                      dateTime. Sample format: yyyy-MM-ddTHH:mm:ssZ.
                    "durationInSeconds": 0.0,  # Optional. Duration of the job in seconds.
                    "endTime": "2020-02-20 00:00:00",  # Optional. Job end time when available.
                      Sample format: yyyy-MM-ddTHH:mm:ssZ.
                    "errorCode": "str",  # Optional. Error Code when job failed.
                    "id": "str",  # Optional. Unique job id.
                    "lastActionDateTime": "2020-02-20 00:00:00",  # Optional. Job was last acted
                      upon at dateTime. Sample format: yyyy-MM-ddTHH:mm:ssZ.
                    "message": "str",  # Optional. Status message to capture more details of the
                      job.
                    "startTime": "2020-02-20 00:00:00",  # Optional. Job start time when
                      available. Sample format: yyyy-MM-ddTHH:mm:ssZ.
                    "status": "str"  # Optional. Status of the job."nPossible values: 'Waiting',
                      'Running', 'Succeeded', 'Failed', 'Cancelled'. Known values are: "Waiting",
                      "Running", "Succeeded", "Failed", and "Cancelled".
                }
        """
        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls = kwargs.pop("cls", None)  # type: ClsType[JSON]
        polling = kwargs.pop("polling", True)  # type: Union[bool, PollingMethod]
        lro_delay = kwargs.pop("polling_interval", self._config.polling_interval)
        cont_token = kwargs.pop("continuation_token", None)  # type: Optional[str]
        if cont_token is None:
            raw_result = self._create_cascade_delete_job_initial(  # type: ignore
                job_id=job_id,
                party_id=party_id,
                planting_data_id=planting_data_id,
                cls=lambda x, y, z: x,
                headers=_headers,
                params=_params,
                **kwargs
            )
        kwargs.pop("error_map", None)

        def get_long_running_output(pipeline_response):
            response = pipeline_response.http_response
            if response.content:
                deserialized = response.json()
            else:
                deserialized = None
            if cls:
                return cls(pipeline_response, deserialized, {})
            return deserialized

        if polling is True:
            polling_method = cast(
                PollingMethod, LROBasePolling(lro_delay, lro_options={"final-state-via": "location"}, **kwargs)
            )  # type: PollingMethod
        elif polling is False:
            polling_method = cast(PollingMethod, NoPolling())
        else:
            polling_method = polling
        if cont_token:
            return LROPoller.from_continuation_token(
                polling_method=polling_method,
                continuation_token=cont_token,
                client=self._client,
                deserialization_callback=get_long_running_output,
            )
        return LROPoller(self._client, raw_result, get_long_running_output, polling_method)

    @distributed_trace
    def get_cascade_delete_job_details(self, job_id: str, **kwargs: Any) -> JSON:
        """Get cascade delete job for planting data resource.

        :param job_id: Id of the job. Required.
        :type job_id: str
        :return: JSON object
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "partyId": "str",  # Party Id. Required.
                    "resourceId": "str",  # The id of the resource. Required.
                    "resourceType": "str",  # The type of the resource. Required.
                    "createdDateTime": "2020-02-20 00:00:00",  # Optional. Job created at
                      dateTime. Sample format: yyyy-MM-ddTHH:mm:ssZ.
                    "durationInSeconds": 0.0,  # Optional. Duration of the job in seconds.
                    "endTime": "2020-02-20 00:00:00",  # Optional. Job end time when available.
                      Sample format: yyyy-MM-ddTHH:mm:ssZ.
                    "errorCode": "str",  # Optional. Error Code when job failed.
                    "id": "str",  # Optional. Unique job id.
                    "lastActionDateTime": "2020-02-20 00:00:00",  # Optional. Job was last acted
                      upon at dateTime. Sample format: yyyy-MM-ddTHH:mm:ssZ.
                    "message": "str",  # Optional. Status message to capture more details of the
                      job.
                    "startTime": "2020-02-20 00:00:00",  # Optional. Job start time when
                      available. Sample format: yyyy-MM-ddTHH:mm:ssZ.
                    "status": "str"  # Optional. Status of the job."nPossible values: 'Waiting',
                      'Running', 'Succeeded', 'Failed', 'Cancelled'. Known values are: "Waiting",
                      "Running", "Succeeded", "Failed", and "Cancelled".
                }
        """
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls = kwargs.pop("cls", None)  # type: ClsType[JSON]

        request = build_planting_data_get_cascade_delete_job_details_request(
            job_id=job_id,
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        request.url = self._client.format_url(request.url)  # type: ignore

        pipeline_response = self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
            request, stream=False, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if response.content:
            deserialized = response.json()
        else:
            deserialized = None

        if cls:
            return cls(pipeline_response, cast(JSON, deserialized), {})

        return cast(JSON, deserialized)


class PlantTissueAnalysesOperations:
    """
    .. warning::
        **DO NOT** instantiate this class directly.

        Instead, you should access the following operations through
        :class:`~azure.agrifood.farming.FarmBeatsClient`'s
        :attr:`plant_tissue_analyses` attribute.
    """

    def __init__(self, *args, **kwargs):
        input_args = list(args)
        self._client = input_args.pop(0) if input_args else kwargs.pop("client")
        self._config = input_args.pop(0) if input_args else kwargs.pop("config")
        self._serialize = input_args.pop(0) if input_args else kwargs.pop("serializer")
        self._deserialize = input_args.pop(0) if input_args else kwargs.pop("deserializer")

    @distributed_trace
    def list_by_party_id(
        self,
        party_id: str,
        *,
        season_ids: Optional[List[str]] = None,
        crop_ids: Optional[List[str]] = None,
        crop_products_ids: Optional[List[str]] = None,
        field_ids: Optional[List[str]] = None,
        ids: Optional[List[str]] = None,
        names: Optional[List[str]] = None,
        property_filters: Optional[List[str]] = None,
        statuses: Optional[List[str]] = None,
        min_created_date_time: Optional[datetime.datetime] = None,
        max_created_date_time: Optional[datetime.datetime] = None,
        min_last_modified_date_time: Optional[datetime.datetime] = None,
        max_last_modified_date_time: Optional[datetime.datetime] = None,
        skip_token: Optional[str] = None,
        **kwargs: Any
    ) -> Iterable[JSON]:
        """Returns a paginated list of plant tissue analysis resources under a particular party.

        :param party_id: Id of the associated party. Required.
        :type party_id: str
        :keyword season_ids: Season ids of the plant tissue analyses. Default value is None.
        :paramtype season_ids: list[str]
        :keyword crop_ids: Crop ids of the plant tissue analyses. Default value is None.
        :paramtype crop_ids: list[str]
        :keyword crop_products_ids: Crop products ids of the plant tissue analyses. Default value is
         None.
        :paramtype crop_products_ids: list[str]
        :keyword field_ids: Field ids of the plant tissue analyses. Default value is None.
        :paramtype field_ids: list[str]
        :keyword ids: Ids of the resource. Default value is None.
        :paramtype ids: list[str]
        :keyword names: Names of the resource. Default value is None.
        :paramtype names: list[str]
        :keyword property_filters: Filters on key-value pairs within the Properties object.
         eg. "{testKey} eq {testValue}". Default value is None.
        :paramtype property_filters: list[str]
        :keyword statuses: Statuses of the resource. Default value is None.
        :paramtype statuses: list[str]
        :keyword min_created_date_time: Minimum creation date of resource (inclusive). Default value is
         None.
        :paramtype min_created_date_time: ~datetime.datetime
        :keyword max_created_date_time: Maximum creation date of resource (inclusive). Default value is
         None.
        :paramtype max_created_date_time: ~datetime.datetime
        :keyword min_last_modified_date_time: Minimum last modified date of resource (inclusive).
         Default value is None.
        :paramtype min_last_modified_date_time: ~datetime.datetime
        :keyword max_last_modified_date_time: Maximum last modified date of resource (inclusive).
         Default value is None.
        :paramtype max_last_modified_date_time: ~datetime.datetime
        :keyword skip_token: Skip token for getting next set of results. Default value is None.
        :paramtype skip_token: str
        :return: An iterator like instance of JSON object
        :rtype: ~azure.core.paging.ItemPaged[JSON]
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "attachmentsLink": "str",  # Optional. Link for attachments.
                    "createdBy": "str",  # Optional. Created by user/tenant id.
                    "createdDateTime": "2020-02-20 00:00:00",  # Optional. Date-time when
                      resource was created, sample format: yyyy-MM-ddTHH:mm:ssZ.
                    "cropId": "str",  # Optional. Id of the associated Crop.
                    "cropProductId": "str",  # Optional. Id of the associated Crop product.
                    "description": "str",  # Optional. Textual description of the resource.
                    "eTag": "str",  # Optional. The ETag value to implement optimistic
                      concurrency.
                    "fieldId": "str",  # Optional. Id of the associated Field.
                    "growthStage": "str",  # Optional. Growth stage for this plant tissue
                      analysis.
                    "id": "str",  # Optional. Unique resource ID.
                    "labDetails": {
                        "address": "str",  # Optional. Address of the resource.
                        "code": "str",  # Optional. Code of the resource.
                        "description": "str",  # Optional. Description of the resource.
                        "name": "str"  # Optional. Name of the resource.
                    },
                    "modifiedBy": "str",  # Optional. Modified by user/tenant id.
                    "modifiedDateTime": "2020-02-20 00:00:00",  # Optional. Date-time when
                      resource was last modified, sample format: yyyy-MM-ddTHH:mm:ssZ.
                    "name": "str",  # Optional. Name to identify resource.
                    "partyId": "str",  # Optional. Id of the associated Party.
                    "plantAppearance": "str",  # Optional. Plant appearance for this plant tissue
                      analysis.
                    "plantPart": "str",  # Optional. Plant part for this plant tissue analysis.
                    "plantPosition": "str",  # Optional. Plant position for this plant tissue
                      analysis.
                    "plantingDateTime": "2020-02-20 00:00:00",  # Optional. Planting datetime for
                      this plant tissue analysis.
                    "properties": {
                        "str": {}  # Optional. A collection of key value pairs that belongs
                          to the resource."nEach pair must not have a key greater than 50
                          characters"nand must not have a value greater than 150 characters."nNote: A
                          maximum of 25 key value pairs can be provided for a resource and only
                          string,"nnumeral and datetime (yyyy-MM-ddTHH:mm:ssZ) values are supported.
                    },
                    "sampleCollectionCondition": "str",  # Optional. Sample collection condition
                      for this plant tissue analysis.
                    "sampleCollectionDateTime": "2020-02-20 00:00:00",  # Optional. Sample
                      collection dateTime for this plant tissue analysis.
                    "sampleReceivedDateTime": "2020-02-20 00:00:00",  # Optional. Sample received
                      dateTime.
                    "sampleTestResultDateTime": "2020-02-20 00:00:00",  # Optional. Sample test
                      result dateTime for this plant tissue analysis.
                    "seasonId": "str",  # Optional. Id of the associated Season.
                    "source": "str",  # Optional. Source of the resource.
                    "status": "str"  # Optional. Status of the resource.
                }
        """
        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls = kwargs.pop("cls", None)  # type: ClsType[JSON]

        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        def prepare_request(next_link=None):
            if not next_link:

                request = build_plant_tissue_analyses_list_by_party_id_request(
                    party_id=party_id,
                    season_ids=season_ids,
                    crop_ids=crop_ids,
                    crop_products_ids=crop_products_ids,
                    field_ids=field_ids,
                    ids=ids,
                    names=names,
                    property_filters=property_filters,
                    statuses=statuses,
                    min_created_date_time=min_created_date_time,
                    max_created_date_time=max_created_date_time,
                    min_last_modified_date_time=min_last_modified_date_time,
                    max_last_modified_date_time=max_last_modified_date_time,
                    skip_token=skip_token,
                    api_version=self._config.api_version,
                    headers=_headers,
                    params=_params,
                )
                request.url = self._client.format_url(request.url)  # type: ignore

            else:
                # make call to next link with the client's api-version
                _parsed_next_link = urlparse(next_link)
                _next_request_params = case_insensitive_dict(parse_qs(_parsed_next_link.query))
                _next_request_params["api-version"] = self._config.api_version
                request = HttpRequest("GET", urljoin(next_link, _parsed_next_link.path), params=_next_request_params)
                request.url = self._client.format_url(request.url)  # type: ignore

            return request

        def extract_data(pipeline_response):
            deserialized = pipeline_response.http_response.json()
            list_of_elem = deserialized["value"]
            if cls:
                list_of_elem = cls(list_of_elem)
            return deserialized.get("nextLink", None), iter(list_of_elem)

        def get_next(next_link=None):
            request = prepare_request(next_link)

            pipeline_response = self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
                request, stream=False, **kwargs
            )
            response = pipeline_response.http_response

            if response.status_code not in [200]:
                map_error(status_code=response.status_code, response=response, error_map=error_map)
                raise HttpResponseError(response=response)

            return pipeline_response

        return ItemPaged(get_next, extract_data)

    @distributed_trace
    def get(self, party_id: str, plant_tissue_analysis_id: str, **kwargs: Any) -> JSON:
        """Gets a specified plant tissue analysis resource under a particular party.

        :param party_id: Id of the associated party. Required.
        :type party_id: str
        :param plant_tissue_analysis_id: Id of the plant tissue analysis. Required.
        :type plant_tissue_analysis_id: str
        :return: JSON object
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "attachmentsLink": "str",  # Optional. Link for attachments.
                    "createdBy": "str",  # Optional. Created by user/tenant id.
                    "createdDateTime": "2020-02-20 00:00:00",  # Optional. Date-time when
                      resource was created, sample format: yyyy-MM-ddTHH:mm:ssZ.
                    "cropId": "str",  # Optional. Id of the associated Crop.
                    "cropProductId": "str",  # Optional. Id of the associated Crop product.
                    "description": "str",  # Optional. Textual description of the resource.
                    "eTag": "str",  # Optional. The ETag value to implement optimistic
                      concurrency.
                    "fieldId": "str",  # Optional. Id of the associated Field.
                    "growthStage": "str",  # Optional. Growth stage for this plant tissue
                      analysis.
                    "id": "str",  # Optional. Unique resource ID.
                    "labDetails": {
                        "address": "str",  # Optional. Address of the resource.
                        "code": "str",  # Optional. Code of the resource.
                        "description": "str",  # Optional. Description of the resource.
                        "name": "str"  # Optional. Name of the resource.
                    },
                    "modifiedBy": "str",  # Optional. Modified by user/tenant id.
                    "modifiedDateTime": "2020-02-20 00:00:00",  # Optional. Date-time when
                      resource was last modified, sample format: yyyy-MM-ddTHH:mm:ssZ.
                    "name": "str",  # Optional. Name to identify resource.
                    "partyId": "str",  # Optional. Id of the associated Party.
                    "plantAppearance": "str",  # Optional. Plant appearance for this plant tissue
                      analysis.
                    "plantPart": "str",  # Optional. Plant part for this plant tissue analysis.
                    "plantPosition": "str",  # Optional. Plant position for this plant tissue
                      analysis.
                    "plantingDateTime": "2020-02-20 00:00:00",  # Optional. Planting datetime for
                      this plant tissue analysis.
                    "properties": {
                        "str": {}  # Optional. A collection of key value pairs that belongs
                          to the resource."nEach pair must not have a key greater than 50
                          characters"nand must not have a value greater than 150 characters."nNote: A
                          maximum of 25 key value pairs can be provided for a resource and only
                          string,"nnumeral and datetime (yyyy-MM-ddTHH:mm:ssZ) values are supported.
                    },
                    "sampleCollectionCondition": "str",  # Optional. Sample collection condition
                      for this plant tissue analysis.
                    "sampleCollectionDateTime": "2020-02-20 00:00:00",  # Optional. Sample
                      collection dateTime for this plant tissue analysis.
                    "sampleReceivedDateTime": "2020-02-20 00:00:00",  # Optional. Sample received
                      dateTime.
                    "sampleTestResultDateTime": "2020-02-20 00:00:00",  # Optional. Sample test
                      result dateTime for this plant tissue analysis.
                    "seasonId": "str",  # Optional. Id of the associated Season.
                    "source": "str",  # Optional. Source of the resource.
                    "status": "str"  # Optional. Status of the resource.
                }
        """
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls = kwargs.pop("cls", None)  # type: ClsType[JSON]

        request = build_plant_tissue_analyses_get_request(
            party_id=party_id,
            plant_tissue_analysis_id=plant_tissue_analysis_id,
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        request.url = self._client.format_url(request.url)  # type: ignore

        pipeline_response = self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
            request, stream=False, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if response.content:
            deserialized = response.json()
        else:
            deserialized = None

        if cls:
            return cls(pipeline_response, cast(JSON, deserialized), {})

        return cast(JSON, deserialized)

    @overload
    def create_or_update(
        self,
        party_id: str,
        plant_tissue_analysis_id: str,
        plant_tissue_analysis: JSON,
        *,
        content_type: str = "application/merge-patch+json",
        **kwargs: Any
    ) -> JSON:
        """Creates or updates a plant tissue analysis resource.

        :param party_id: Id of the party resource. Required.
        :type party_id: str
        :param plant_tissue_analysis_id: Id of the plant tissue analysis resource. Required.
        :type plant_tissue_analysis_id: str
        :param plant_tissue_analysis: PlantTissueAnalysis resource payload to create or update.
         Required.
        :type plant_tissue_analysis: JSON
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/merge-patch+json".
        :paramtype content_type: str
        :return: JSON object
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                plant_tissue_analysis = {
                    "attachmentsLink": "str",  # Optional. Link for attachments.
                    "createdBy": "str",  # Optional. Created by user/tenant id.
                    "createdDateTime": "2020-02-20 00:00:00",  # Optional. Date-time when
                      resource was created, sample format: yyyy-MM-ddTHH:mm:ssZ.
                    "cropId": "str",  # Optional. Id of the associated Crop.
                    "cropProductId": "str",  # Optional. Id of the associated Crop product.
                    "description": "str",  # Optional. Textual description of the resource.
                    "eTag": "str",  # Optional. The ETag value to implement optimistic
                      concurrency.
                    "fieldId": "str",  # Optional. Id of the associated Field.
                    "growthStage": "str",  # Optional. Growth stage for this plant tissue
                      analysis.
                    "id": "str",  # Optional. Unique resource ID.
                    "labDetails": {
                        "address": "str",  # Optional. Address of the resource.
                        "code": "str",  # Optional. Code of the resource.
                        "description": "str",  # Optional. Description of the resource.
                        "name": "str"  # Optional. Name of the resource.
                    },
                    "modifiedBy": "str",  # Optional. Modified by user/tenant id.
                    "modifiedDateTime": "2020-02-20 00:00:00",  # Optional. Date-time when
                      resource was last modified, sample format: yyyy-MM-ddTHH:mm:ssZ.
                    "name": "str",  # Optional. Name to identify resource.
                    "partyId": "str",  # Optional. Id of the associated Party.
                    "plantAppearance": "str",  # Optional. Plant appearance for this plant tissue
                      analysis.
                    "plantPart": "str",  # Optional. Plant part for this plant tissue analysis.
                    "plantPosition": "str",  # Optional. Plant position for this plant tissue
                      analysis.
                    "plantingDateTime": "2020-02-20 00:00:00",  # Optional. Planting datetime for
                      this plant tissue analysis.
                    "properties": {
                        "str": {}  # Optional. A collection of key value pairs that belongs
                          to the resource."nEach pair must not have a key greater than 50
                          characters"nand must not have a value greater than 150 characters."nNote: A
                          maximum of 25 key value pairs can be provided for a resource and only
                          string,"nnumeral and datetime (yyyy-MM-ddTHH:mm:ssZ) values are supported.
                    },
                    "sampleCollectionCondition": "str",  # Optional. Sample collection condition
                      for this plant tissue analysis.
                    "sampleCollectionDateTime": "2020-02-20 00:00:00",  # Optional. Sample
                      collection dateTime for this plant tissue analysis.
                    "sampleReceivedDateTime": "2020-02-20 00:00:00",  # Optional. Sample received
                      dateTime.
                    "sampleTestResultDateTime": "2020-02-20 00:00:00",  # Optional. Sample test
                      result dateTime for this plant tissue analysis.
                    "seasonId": "str",  # Optional. Id of the associated Season.
                    "source": "str",  # Optional. Source of the resource.
                    "status": "str"  # Optional. Status of the resource.
                }

                # response body for status code(s): 200, 201
                response == {
                    "attachmentsLink": "str",  # Optional. Link for attachments.
                    "createdBy": "str",  # Optional. Created by user/tenant id.
                    "createdDateTime": "2020-02-20 00:00:00",  # Optional. Date-time when
                      resource was created, sample format: yyyy-MM-ddTHH:mm:ssZ.
                    "cropId": "str",  # Optional. Id of the associated Crop.
                    "cropProductId": "str",  # Optional. Id of the associated Crop product.
                    "description": "str",  # Optional. Textual description of the resource.
                    "eTag": "str",  # Optional. The ETag value to implement optimistic
                      concurrency.
                    "fieldId": "str",  # Optional. Id of the associated Field.
                    "growthStage": "str",  # Optional. Growth stage for this plant tissue
                      analysis.
                    "id": "str",  # Optional. Unique resource ID.
                    "labDetails": {
                        "address": "str",  # Optional. Address of the resource.
                        "code": "str",  # Optional. Code of the resource.
                        "description": "str",  # Optional. Description of the resource.
                        "name": "str"  # Optional. Name of the resource.
                    },
                    "modifiedBy": "str",  # Optional. Modified by user/tenant id.
                    "modifiedDateTime": "2020-02-20 00:00:00",  # Optional. Date-time when
                      resource was last modified, sample format: yyyy-MM-ddTHH:mm:ssZ.
                    "name": "str",  # Optional. Name to identify resource.
                    "partyId": "str",  # Optional. Id of the associated Party.
                    "plantAppearance": "str",  # Optional. Plant appearance for this plant tissue
                      analysis.
                    "plantPart": "str",  # Optional. Plant part for this plant tissue analysis.
                    "plantPosition": "str",  # Optional. Plant position for this plant tissue
                      analysis.
                    "plantingDateTime": "2020-02-20 00:00:00",  # Optional. Planting datetime for
                      this plant tissue analysis.
                    "properties": {
                        "str": {}  # Optional. A collection of key value pairs that belongs
                          to the resource."nEach pair must not have a key greater than 50
                          characters"nand must not have a value greater than 150 characters."nNote: A
                          maximum of 25 key value pairs can be provided for a resource and only
                          string,"nnumeral and datetime (yyyy-MM-ddTHH:mm:ssZ) values are supported.
                    },
                    "sampleCollectionCondition": "str",  # Optional. Sample collection condition
                      for this plant tissue analysis.
                    "sampleCollectionDateTime": "2020-02-20 00:00:00",  # Optional. Sample
                      collection dateTime for this plant tissue analysis.
                    "sampleReceivedDateTime": "2020-02-20 00:00:00",  # Optional. Sample received
                      dateTime.
                    "sampleTestResultDateTime": "2020-02-20 00:00:00",  # Optional. Sample test
                      result dateTime for this plant tissue analysis.
                    "seasonId": "str",  # Optional. Id of the associated Season.
                    "source": "str",  # Optional. Source of the resource.
                    "status": "str"  # Optional. Status of the resource.
                }
        """

    @overload
    def create_or_update(
        self,
        party_id: str,
        plant_tissue_analysis_id: str,
        plant_tissue_analysis: IO,
        *,
        content_type: str = "application/merge-patch+json",
        **kwargs: Any
    ) -> JSON:
        """Creates or updates a plant tissue analysis resource.

        :param party_id: Id of the party resource. Required.
        :type party_id: str
        :param plant_tissue_analysis_id: Id of the plant tissue analysis resource. Required.
        :type plant_tissue_analysis_id: str
        :param plant_tissue_analysis: PlantTissueAnalysis resource payload to create or update.
         Required.
        :type plant_tissue_analysis: IO
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Default value is "application/merge-patch+json".
        :paramtype content_type: str
        :return: JSON object
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200, 201
                response == {
                    "attachmentsLink": "str",  # Optional. Link for attachments.
                    "createdBy": "str",  # Optional. Created by user/tenant id.
                    "createdDateTime": "2020-02-20 00:00:00",  # Optional. Date-time when
                      resource was created, sample format: yyyy-MM-ddTHH:mm:ssZ.
                    "cropId": "str",  # Optional. Id of the associated Crop.
                    "cropProductId": "str",  # Optional. Id of the associated Crop product.
                    "description": "str",  # Optional. Textual description of the resource.
                    "eTag": "str",  # Optional. The ETag value to implement optimistic
                      concurrency.
                    "fieldId": "str",  # Optional. Id of the associated Field.
                    "growthStage": "str",  # Optional. Growth stage for this plant tissue
                      analysis.
                    "id": "str",  # Optional. Unique resource ID.
                    "labDetails": {
                        "address": "str",  # Optional. Address of the resource.
                        "code": "str",  # Optional. Code of the resource.
                        "description": "str",  # Optional. Description of the resource.
                        "name": "str"  # Optional. Name of the resource.
                    },
                    "modifiedBy": "str",  # Optional. Modified by user/tenant id.
                    "modifiedDateTime": "2020-02-20 00:00:00",  # Optional. Date-time when
                      resource was last modified, sample format: yyyy-MM-ddTHH:mm:ssZ.
                    "name": "str",  # Optional. Name to identify resource.
                    "partyId": "str",  # Optional. Id of the associated Party.
                    "plantAppearance": "str",  # Optional. Plant appearance for this plant tissue
                      analysis.
                    "plantPart": "str",  # Optional. Plant part for this plant tissue analysis.
                    "plantPosition": "str",  # Optional. Plant position for this plant tissue
                      analysis.
                    "plantingDateTime": "2020-02-20 00:00:00",  # Optional. Planting datetime for
                      this plant tissue analysis.
                    "properties": {
                        "str": {}  # Optional. A collection of key value pairs that belongs
                          to the resource."nEach pair must not have a key greater than 50
                          characters"nand must not have a value greater than 150 characters."nNote: A
                          maximum of 25 key value pairs can be provided for a resource and only
                          string,"nnumeral and datetime (yyyy-MM-ddTHH:mm:ssZ) values are supported.
                    },
                    "sampleCollectionCondition": "str",  # Optional. Sample collection condition
                      for this plant tissue analysis.
                    "sampleCollectionDateTime": "2020-02-20 00:00:00",  # Optional. Sample
                      collection dateTime for this plant tissue analysis.
                    "sampleReceivedDateTime": "2020-02-20 00:00:00",  # Optional. Sample received
                      dateTime.
                    "sampleTestResultDateTime": "2020-02-20 00:00:00",  # Optional. Sample test
                      result dateTime for this plant tissue analysis.
                    "seasonId": "str",  # Optional. Id of the associated Season.
                    "source": "str",  # Optional. Source of the resource.
                    "status": "str"  # Optional. Status of the resource.
                }
        """

    @distributed_trace
    def create_or_update(
        self, party_id: str, plant_tissue_analysis_id: str, plant_tissue_analysis: Union[JSON, IO], **kwargs: Any
    ) -> JSON:
        """Creates or updates a plant tissue analysis resource.

        :param party_id: Id of the party resource. Required.
        :type party_id: str
        :param plant_tissue_analysis_id: Id of the plant tissue analysis resource. Required.
        :type plant_tissue_analysis_id: str
        :param plant_tissue_analysis: PlantTissueAnalysis resource payload to create or update. Is
         either a model type or a IO type. Required.
        :type plant_tissue_analysis: JSON or IO
        :keyword content_type: Body Parameter content-type. Known values are:
         'application/merge-patch+json'. Default value is None.
        :paramtype content_type: str
        :return: JSON object
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200, 201
                response == {
                    "attachmentsLink": "str",  # Optional. Link for attachments.
                    "createdBy": "str",  # Optional. Created by user/tenant id.
                    "createdDateTime": "2020-02-20 00:00:00",  # Optional. Date-time when
                      resource was created, sample format: yyyy-MM-ddTHH:mm:ssZ.
                    "cropId": "str",  # Optional. Id of the associated Crop.
                    "cropProductId": "str",  # Optional. Id of the associated Crop product.
                    "description": "str",  # Optional. Textual description of the resource.
                    "eTag": "str",  # Optional. The ETag value to implement optimistic
                      concurrency.
                    "fieldId": "str",  # Optional. Id of the associated Field.
                    "growthStage": "str",  # Optional. Growth stage for this plant tissue
                      analysis.
                    "id": "str",  # Optional. Unique resource ID.
                    "labDetails": {
                        "address": "str",  # Optional. Address of the resource.
                        "code": "str",  # Optional. Code of the resource.
                        "description": "str",  # Optional. Description of the resource.
                        "name": "str"  # Optional. Name of the resource.
                    },
                    "modifiedBy": "str",  # Optional. Modified by user/tenant id.
                    "modifiedDateTime": "2020-02-20 00:00:00",  # Optional. Date-time when
                      resource was last modified, sample format: yyyy-MM-ddTHH:mm:ssZ.
                    "name": "str",  # Optional. Name to identify resource.
                    "partyId": "str",  # Optional. Id of the associated Party.
                    "plantAppearance": "str",  # Optional. Plant appearance for this plant tissue
                      analysis.
                    "plantPart": "str",  # Optional. Plant part for this plant tissue analysis.
                    "plantPosition": "str",  # Optional. Plant position for this plant tissue
                      analysis.
                    "plantingDateTime": "2020-02-20 00:00:00",  # Optional. Planting datetime for
                      this plant tissue analysis.
                    "properties": {
                        "str": {}  # Optional. A collection of key value pairs that belongs
                          to the resource."nEach pair must not have a key greater than 50
                          characters"nand must not have a value greater than 150 characters."nNote: A
                          maximum of 25 key value pairs can be provided for a resource and only
                          string,"nnumeral and datetime (yyyy-MM-ddTHH:mm:ssZ) values are supported.
                    },
                    "sampleCollectionCondition": "str",  # Optional. Sample collection condition
                      for this plant tissue analysis.
                    "sampleCollectionDateTime": "2020-02-20 00:00:00",  # Optional. Sample
                      collection dateTime for this plant tissue analysis.
                    "sampleReceivedDateTime": "2020-02-20 00:00:00",  # Optional. Sample received
                      dateTime.
                    "sampleTestResultDateTime": "2020-02-20 00:00:00",  # Optional. Sample test
                      result dateTime for this plant tissue analysis.
                    "seasonId": "str",  # Optional. Id of the associated Season.
                    "source": "str",  # Optional. Source of the resource.
                    "status": "str"  # Optional. Status of the resource.
                }
        """
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type = kwargs.pop("content_type", _headers.pop("Content-Type", None))  # type: Optional[str]
        cls = kwargs.pop("cls", None)  # type: ClsType[JSON]

        content_type = content_type or "application/merge-patch+json"
        _json = None
        _content = None
        if isinstance(plant_tissue_analysis, (IO, bytes)):
            _content = plant_tissue_analysis
        else:
            _json = plant_tissue_analysis

        request = build_plant_tissue_analyses_create_or_update_request(
            party_id=party_id,
            plant_tissue_analysis_id=plant_tissue_analysis_id,
            content_type=content_type,
            api_version=self._config.api_version,
            json=_json,
            content=_content,
            headers=_headers,
            params=_params,
        )
        request.url = self._client.format_url(request.url)  # type: ignore

        pipeline_response = self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
            request, stream=False, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200, 201]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if response.status_code == 200:
            if response.content:
                deserialized = response.json()
            else:
                deserialized = None

        if response.status_code == 201:
            if response.content:
                deserialized = response.json()
            else:
                deserialized = None

        if cls:
            return cls(pipeline_response, cast(JSON, deserialized), {})

        return cast(JSON, deserialized)

    @distributed_trace
    def delete(  # pylint: disable=inconsistent-return-statements
        self, party_id: str, plant_tissue_analysis_id: str, **kwargs: Any
    ) -> None:
        """Deletes a specified plant tissue analysis resource under a particular party.

        :param party_id: Id of the party. Required.
        :type party_id: str
        :param plant_tissue_analysis_id: Id of the plant tissue analysis. Required.
        :type plant_tissue_analysis_id: str
        :return: None
        :rtype: None
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls = kwargs.pop("cls", None)  # type: ClsType[None]

        request = build_plant_tissue_analyses_delete_request(
            party_id=party_id,
            plant_tissue_analysis_id=plant_tissue_analysis_id,
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        request.url = self._client.format_url(request.url)  # type: ignore

        pipeline_response = self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
            request, stream=False, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [204]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if cls:
            return cls(pipeline_response, None, {})

    @distributed_trace
    def list(
        self,
        *,
        season_ids: Optional[List[str]] = None,
        crop_ids: Optional[List[str]] = None,
        crop_products_ids: Optional[List[str]] = None,
        field_ids: Optional[List[str]] = None,
        ids: Optional[List[str]] = None,
        names: Optional[List[str]] = None,
        property_filters: Optional[List[str]] = None,
        statuses: Optional[List[str]] = None,
        min_created_date_time: Optional[datetime.datetime] = None,
        max_created_date_time: Optional[datetime.datetime] = None,
        min_last_modified_date_time: Optional[datetime.datetime] = None,
        max_last_modified_date_time: Optional[datetime.datetime] = None,
        skip_token: Optional[str] = None,
        **kwargs: Any
    ) -> Iterable[JSON]:
        """Returns a paginated list of plant tissue analysis resources across all parties.

        :keyword season_ids: Season ids of the plant tissue analyses. Default value is None.
        :paramtype season_ids: list[str]
        :keyword crop_ids: Crop ids of the plant tissue analyses. Default value is None.
        :paramtype crop_ids: list[str]
        :keyword crop_products_ids: Crop products ids of the plant tissue analyses. Default value is
         None.
        :paramtype crop_products_ids: list[str]
        :keyword field_ids: Field ids of the plant tissue analyses. Default value is None.
        :paramtype field_ids: list[str]
        :keyword ids: Ids of the resource. Default value is None.
        :paramtype ids: list[str]
        :keyword names: Names of the resource. Default value is None.
        :paramtype names: list[str]
        :keyword property_filters: Filters on key-value pairs within the Properties object.
         eg. "{testKey} eq {testValue}". Default value is None.
        :paramtype property_filters: list[str]
        :keyword statuses: Statuses of the resource. Default value is None.
        :paramtype statuses: list[str]
        :keyword min_created_date_time: Minimum creation date of resource (inclusive). Default value is
         None.
        :paramtype min_created_date_time: ~datetime.datetime
        :keyword max_created_date_time: Maximum creation date of resource (inclusive). Default value is
         None.
        :paramtype max_created_date_time: ~datetime.datetime
        :keyword min_last_modified_date_time: Minimum last modified date of resource (inclusive).
         Default value is None.
        :paramtype min_last_modified_date_time: ~datetime.datetime
        :keyword max_last_modified_date_time: Maximum last modified date of resource (inclusive).
         Default value is None.
        :paramtype max_last_modified_date_time: ~datetime.datetime
        :keyword skip_token: Skip token for getting next set of results. Default value is None.
        :paramtype skip_token: str
        :return: An iterator like instance of JSON object
        :rtype: ~azure.core.paging.ItemPaged[JSON]
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "attachmentsLink": "str",  # Optional. Link for attachments.
                    "createdBy": "str",  # Optional. Created by user/tenant id.
                    "createdDateTime": "2020-02-20 00:00:00",  # Optional. Date-time when
                      resource was created, sample format: yyyy-MM-ddTHH:mm:ssZ.
                    "cropId": "str",  # Optional. Id of the associated Crop.
                    "cropProductId": "str",  # Optional. Id of the associated Crop product.
                    "description": "str",  # Optional. Textual description of the resource.
                    "eTag": "str",  # Optional. The ETag value to implement optimistic
                      concurrency.
                    "fieldId": "str",  # Optional. Id of the associated Field.
                    "growthStage": "str",  # Optional. Growth stage for this plant tissue
                      analysis.
                    "id": "str",  # Optional. Unique resource ID.
                    "labDetails": {
                        "address": "str",  # Optional. Address of the resource.
                        "code": "str",  # Optional. Code of the resource.
                        "description": "str",  # Optional. Description of the resource.
                        "name": "str"  # Optional. Name of the resource.
                    },
                    "modifiedBy": "str",  # Optional. Modified by user/tenant id.
                    "modifiedDateTime": "2020-02-20 00:00:00",  # Optional. Date-time when
                      resource was last modified, sample format: yyyy-MM-ddTHH:mm:ssZ.
                    "name": "str",  # Optional. Name to identify resource.
                    "partyId": "str",  # Optional. Id of the associated Party.
                    "plantAppearance": "str",  # Optional. Plant appearance for this plant tissue
                      analysis.
                    "plantPart": "str",  # Optional. Plant part for this plant tissue analysis.
                    "plantPosition": "str",  # Optional. Plant position for this plant tissue
                      analysis.
                    "plantingDateTime": "2020-02-20 00:00:00",  # Optional. Planting datetime for
                      this plant tissue analysis.
                    "properties": {
                        "str": {}  # Optional. A collection of key value pairs that belongs
                          to the resource."nEach pair must not have a key greater than 50
                          characters"nand must not have a value greater than 150 characters."nNote: A
                          maximum of 25 key value pairs can be provided for a resource and only
                          string,"nnumeral and datetime (yyyy-MM-ddTHH:mm:ssZ) values are supported.
                    },
                    "sampleCollectionCondition": "str",  # Optional. Sample collection condition
                      for this plant tissue analysis.
                    "sampleCollectionDateTime": "2020-02-20 00:00:00",  # Optional. Sample
                      collection dateTime for this plant tissue analysis.
                    "sampleReceivedDateTime": "2020-02-20 00:00:00",  # Optional. Sample received
                      dateTime.
                    "sampleTestResultDateTime": "2020-02-20 00:00:00",  # Optional. Sample test
                      result dateTime for this plant tissue analysis.
                    "seasonId": "str",  # Optional. Id of the associated Season.
                    "source": "str",  # Optional. Source of the resource.
                    "status": "str"  # Optional. Status of the resource.
                }
        """
        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls = kwargs.pop("cls", None)  # type: ClsType[JSON]

        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        def prepare_request(next_link=None):
            if not next_link:

                request = build_plant_tissue_analyses_list_request(
                    season_ids=season_ids,
                    crop_ids=crop_ids,
                    crop_products_ids=crop_products_ids,
                    field_ids=field_ids,
                    ids=ids,
                    names=names,
                    property_filters=property_filters,
                    statuses=statuses,
                    min_created_date_time=min_created_date_time,
                    max_created_date_time=max_created_date_time,
                    min_last_modified_date_time=min_last_modified_date_time,
                    max_last_modified_date_time=max_last_modified_date_time,
                    skip_token=skip_token,
                    api_version=self._config.api_version,
                    headers=_headers,
                    params=_params,
                )
                request.url = self._client.format_url(request.url)  # type: ignore

            else:
                # make call to next link with the client's api-version
                _parsed_next_link = urlparse(next_link)
                _next_request_params = case_insensitive_dict(parse_qs(_parsed_next_link.query))
                _next_request_params["api-version"] = self._config.api_version
                request = HttpRequest("GET", urljoin(next_link, _parsed_next_link.path), params=_next_request_params)
                request.url = self._client.format_url(request.url)  # type: ignore

            return request

        def extract_data(pipeline_response):
            deserialized = pipeline_response.http_response.json()
            list_of_elem = deserialized["value"]
            if cls:
                list_of_elem = cls(list_of_elem)
            return deserialized.get("nextLink", None), iter(list_of_elem)

        def get_next(next_link=None):
            request = prepare_request(next_link)

            pipeline_response = self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
                request, stream=False, **kwargs
            )
            response = pipeline_response.http_response

            if response.status_code not in [200]:
                map_error(status_code=response.status_code, response=response, error_map=error_map)
                raise HttpResponseError(response=response)

            return pipeline_response

        return ItemPaged(get_next, extract_data)

    def _create_cascade_delete_job_initial(
        self, job_id: str, *, party_id: str, plant_tissue_analysis_id: str, **kwargs: Any
    ) -> JSON:
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls = kwargs.pop("cls", None)  # type: ClsType[JSON]

        request = build_plant_tissue_analyses_create_cascade_delete_job_request(
            job_id=job_id,
            party_id=party_id,
            plant_tissue_analysis_id=plant_tissue_analysis_id,
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        request.url = self._client.format_url(request.url)  # type: ignore

        pipeline_response = self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
            request, stream=False, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [202]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if response.content:
            deserialized = response.json()
        else:
            deserialized = None

        if cls:
            return cls(pipeline_response, cast(JSON, deserialized), {})

        return cast(JSON, deserialized)

    @distributed_trace
    def begin_create_cascade_delete_job(
        self, job_id: str, *, party_id: str, plant_tissue_analysis_id: str, **kwargs: Any
    ) -> LROPoller[JSON]:
        """Create a cascade delete job for specified plant tissue analysis.

        :param job_id: Job ID supplied by end user. Required.
        :type job_id: str
        :keyword party_id: ID of the associated party. Required.
        :paramtype party_id: str
        :keyword plant_tissue_analysis_id: ID of the plant tissue analysis to be deleted. Required.
        :paramtype plant_tissue_analysis_id: str
        :keyword str continuation_token: A continuation token to restart a poller from a saved state.
        :keyword polling: By default, your polling method will be LROBasePolling. Pass in False for
         this operation to not poll, or pass in your own initialized polling object for a personal
         polling strategy.
        :paramtype polling: bool or ~azure.core.polling.PollingMethod
        :keyword int polling_interval: Default waiting time between two polls for LRO operations if no
         Retry-After header is present.
        :return: An instance of LROPoller that returns JSON object
        :rtype: ~azure.core.polling.LROPoller[JSON]
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 202
                response == {
                    "partyId": "str",  # Party Id. Required.
                    "resourceId": "str",  # The id of the resource. Required.
                    "resourceType": "str",  # The type of the resource. Required.
                    "createdDateTime": "2020-02-20 00:00:00",  # Optional. Job created at
                      dateTime. Sample format: yyyy-MM-ddTHH:mm:ssZ.
                    "durationInSeconds": 0.0,  # Optional. Duration of the job in seconds.
                    "endTime": "2020-02-20 00:00:00",  # Optional. Job end time when available.
                      Sample format: yyyy-MM-ddTHH:mm:ssZ.
                    "errorCode": "str",  # Optional. Error Code when job failed.
                    "id": "str",  # Optional. Unique job id.
                    "lastActionDateTime": "2020-02-20 00:00:00",  # Optional. Job was last acted
                      upon at dateTime. Sample format: yyyy-MM-ddTHH:mm:ssZ.
                    "message": "str",  # Optional. Status message to capture more details of the
                      job.
                    "startTime": "2020-02-20 00:00:00",  # Optional. Job start time when
                      available. Sample format: yyyy-MM-ddTHH:mm:ssZ.
                    "status": "str"  # Optional. Status of the job."nPossible values: 'Waiting',
                      'Running', 'Succeeded', 'Failed', 'Cancelled'. Known values are: "Waiting",
                      "Running", "Succeeded", "Failed", and "Cancelled".
                }
        """
        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls = kwargs.pop("cls", None)  # type: ClsType[JSON]
        polling = kwargs.pop("polling", True)  # type: Union[bool, PollingMethod]
        lro_delay = kwargs.pop("polling_interval", self._config.polling_interval)
        cont_token = kwargs.pop("continuation_token", None)  # type: Optional[str]
        if cont_token is None:
            raw_result = self._create_cascade_delete_job_initial(  # type: ignore
                job_id=job_id,
                party_id=party_id,
                plant_tissue_analysis_id=plant_tissue_analysis_id,
                cls=lambda x, y, z: x,
                headers=_headers,
                params=_params,
                **kwargs
            )
        kwargs.pop("error_map", None)

        def get_long_running_output(pipeline_response):
            response = pipeline_response.http_response
            if response.content:
                deserialized = response.json()
            else:
                deserialized = None
            if cls:
                return cls(pipeline_response, deserialized, {})
            return deserialized

        if polling is True:
            polling_method = cast(
                PollingMethod, LROBasePolling(lro_delay, lro_options={"final-state-via": "location"}, **kwargs)
            )  # type: PollingMethod
        elif polling is False:
            polling_method = cast(PollingMethod, NoPolling())
        else:
            polling_method = polling
        if cont_token:
            return LROPoller.from_continuation_token(
                polling_method=polling_method,
                continuation_token=cont_token,
                client=self._client,
                deserialization_callback=get_long_running_output,
            )
        return LROPoller(self._client, raw_result, get_long_running_output, polling_method)

    @distributed_trace
    def get_cascade_delete_job_details(self, job_id: str, **kwargs: Any) -> JSON:
        """Get a cascade delete job for specified plant tissue analysis.

        :param job_id: Id of the job. Required.
        :type job_id: str
        :return: JSON object
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "partyId": "str",  # Party Id. Required.
                    "resourceId": "str",  # The id of the resource. Required.
                    "resourceType": "str",  # The type of the resource. Required.
                    "createdDateTime": "2020-02-20 00:00:00",  # Optional. Job created at
                      dateTime. Sample format: yyyy-MM-ddTHH:mm:ssZ.
                    "durationInSeconds": 0.0,  # Optional. Duration of the job in seconds.
                    "endTime": "2020-02-20 00:00:00",  # Optional. Job end time when available.
                      Sample format: yyyy-MM-ddTHH:mm:ssZ.
                    "errorCode": "str",  # Optional. Error Code when job failed.
                    "id": "str",  # Optional. Unique job id.
                    "lastActionDateTime": "2020-02-20 00:00:00",  # Optional. Job was last acted
                      upon at dateTime. Sample format: yyyy-MM-ddTHH:mm:ssZ.
                    "message": "str",  # Optional. Status message to capture more details of the
                      job.
                    "startTime": "2020-02-20 00:00:00",  # Optional. Job start time when
                      available. Sample format: yyyy-MM-ddTHH:mm:ssZ.
                    "status": "str"  # Optional. Status of the job."nPossible values: 'Waiting',
                      'Running', 'Succeeded', 'Failed', 'Cancelled'. Known values are: "Waiting",
                      "Running", "Succeeded", "Failed", and "Cancelled".
                }
        """
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls = kwargs.pop("cls", None)  # type: ClsType[JSON]

        request = build_plant_tissue_analyses_get_cascade_delete_job_details_request(
            job_id=job_id,
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        request.url = self._client.format_url(request.url)  # type: ignore

        pipeline_response = self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
            request, stream=False, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if response.content:
            deserialized = response.json()
        else:
            deserialized = None

        if cls:
            return cls(pipeline_response, cast(JSON, deserialized), {})

        return cast(JSON, deserialized)


class PrescriptionMapsOperations:
    """
    .. warning::
        **DO NOT** instantiate this class directly.

        Instead, you should access the following operations through
        :class:`~azure.agrifood.farming.FarmBeatsClient`'s
        :attr:`prescription_maps` attribute.
    """

    def __init__(self, *args, **kwargs):
        input_args = list(args)
        self._client = input_args.pop(0) if input_args else kwargs.pop("client")
        self._config = input_args.pop(0) if input_args else kwargs.pop("config")
        self._serialize = input_args.pop(0) if input_args else kwargs.pop("serializer")
        self._deserialize = input_args.pop(0) if input_args else kwargs.pop("deserializer")

    @distributed_trace
    def list_by_party_id(
        self,
        party_id: str,
        *,
        types: Optional[List[str]] = None,
        crop_ids: Optional[List[str]] = None,
        season_ids: Optional[List[str]] = None,
        field_ids: Optional[List[str]] = None,
        sources: Optional[List[str]] = None,
        ids: Optional[List[str]] = None,
        names: Optional[List[str]] = None,
        property_filters: Optional[List[str]] = None,
        statuses: Optional[List[str]] = None,
        min_created_date_time: Optional[datetime.datetime] = None,
        max_created_date_time: Optional[datetime.datetime] = None,
        min_last_modified_date_time: Optional[datetime.datetime] = None,
        max_last_modified_date_time: Optional[datetime.datetime] = None,
        skip_token: Optional[str] = None,
        **kwargs: Any
    ) -> Iterable[JSON]:
        """Returns a paginated list of prescription map resources under a particular party.

        :param party_id: Id of the associated party. Required.
        :type party_id: str
        :keyword types: Types of the resource. Default value is None.
        :paramtype types: list[str]
        :keyword crop_ids: Crop Ids of the resource. Default value is None.
        :paramtype crop_ids: list[str]
        :keyword season_ids: Season Ids of the resource. Default value is None.
        :paramtype season_ids: list[str]
        :keyword field_ids: Field Ids of the resource. Default value is None.
        :paramtype field_ids: list[str]
        :keyword sources: Sources for the resource. Default value is None.
        :paramtype sources: list[str]
        :keyword ids: Ids of the resource. Default value is None.
        :paramtype ids: list[str]
        :keyword names: Names of the resource. Default value is None.
        :paramtype names: list[str]
        :keyword property_filters: Filters on key-value pairs within the Properties object.
         eg. "{testKey} eq {testValue}". Default value is None.
        :paramtype property_filters: list[str]
        :keyword statuses: Statuses of the resource. Default value is None.
        :paramtype statuses: list[str]
        :keyword min_created_date_time: Minimum creation date of resource (inclusive). Default value is
         None.
        :paramtype min_created_date_time: ~datetime.datetime
        :keyword max_created_date_time: Maximum creation date of resource (inclusive). Default value is
         None.
        :paramtype max_created_date_time: ~datetime.datetime
        :keyword min_last_modified_date_time: Minimum last modified date of resource (inclusive).
         Default value is None.
        :paramtype min_last_modified_date_time: ~datetime.datetime
        :keyword max_last_modified_date_time: Maximum last modified date of resource (inclusive).
         Default value is None.
        :paramtype max_last_modified_date_time: ~datetime.datetime
        :keyword skip_token: Skip token for getting next set of results. Default value is None.
        :paramtype skip_token: str
        :return: An iterator like instance of JSON object
        :rtype: ~azure.core.paging.ItemPaged[JSON]
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "createdBy": "str",  # Optional. Created by user/tenant id.
                    "createdDateTime": "2020-02-20 00:00:00",  # Optional. Date-time when
                      resource was created, sample format: yyyy-MM-ddTHH:mm:ssZ.
                    "cropId": "str",  # Optional. Crop Id.
                    "description": "str",  # Optional. Textual description of the resource.
                    "eTag": "str",  # Optional. The ETag value to implement optimistic
                      concurrency.
                    "fieldId": "str",  # Optional. Field Id.
                    "id": "str",  # Optional. Unique resource ID.
                    "modifiedBy": "str",  # Optional. Modified by user/tenant id.
                    "modifiedDateTime": "2020-02-20 00:00:00",  # Optional. Date-time when
                      resource was last modified, sample format: yyyy-MM-ddTHH:mm:ssZ.
                    "name": "str",  # Optional. Name to identify resource.
                    "partyId": "str",  # Optional. Party Id.
                    "properties": {
                        "str": {}  # Optional. A collection of key value pairs that belongs
                          to the resource."nEach pair must not have a key greater than 50
                          characters"nand must not have a value greater than 150 characters."nNote: A
                          maximum of 25 key value pairs can be provided for a resource and only
                          string,"nnumeral and datetime (yyyy-MM-ddTHH:mm:ssZ) values are supported.
                    },
                    "seasonId": "str",  # Optional. Season Id.
                    "source": "str",  # Optional. Source of the resource.
                    "status": "str",  # Optional. Status of the resource.
                    "type": "str"  # Optional. Prescription map type.
                }
        """
        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls = kwargs.pop("cls", None)  # type: ClsType[JSON]

        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        def prepare_request(next_link=None):
            if not next_link:

                request = build_prescription_maps_list_by_party_id_request(
                    party_id=party_id,
                    types=types,
                    crop_ids=crop_ids,
                    season_ids=season_ids,
                    field_ids=field_ids,
                    sources=sources,
                    ids=ids,
                    names=names,
                    property_filters=property_filters,
                    statuses=statuses,
                    min_created_date_time=min_created_date_time,
                    max_created_date_time=max_created_date_time,
                    min_last_modified_date_time=min_last_modified_date_time,
                    max_last_modified_date_time=max_last_modified_date_time,
                    skip_token=skip_token,
                    api_version=self._config.api_version,
                    headers=_headers,
                    params=_params,
                )
                request.url = self._client.format_url(request.url)  # type: ignore

            else:
                # make call to next link with the client's api-version
                _parsed_next_link = urlparse(next_link)
                _next_request_params = case_insensitive_dict(parse_qs(_parsed_next_link.query))
                _next_request_params["api-version"] = self._config.api_version
                request = HttpRequest("GET", urljoin(next_link, _parsed_next_link.path), params=_next_request_params)
                request.url = self._client.format_url(request.url)  # type: ignore

            return request

        def extract_data(pipeline_response):
            deserialized = pipeline_response.http_response.json()
            list_of_elem = deserialized["value"]
            if cls:
                list_of_elem = cls(list_of_elem)
            return deserialized.get("nextLink", None), iter(list_of_elem)

        def get_next(next_link=None):
            request = prepare_request(next_link)

            pipeline_response = self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
                request, stream=False, **kwargs
            )
            response = pipeline_response.http_response

            if response.status_code not in [200]:
                map_error(status_code=response.status_code, response=response, error_map=error_map)
                raise HttpResponseError(response=response)

            return pipeline_response

        return ItemPaged(get_next, extract_data)

    @distributed_trace
    def get(self, party_id: str, prescription_map_id: str, **kwargs: Any) -> JSON:
        """Gets a specified prescription map resource under a particular party.

        :param party_id: Id of the associated party. Required.
        :type party_id: str
        :param prescription_map_id: Id of the prescription map. Required.
        :type prescription_map_id: str
        :return: JSON object
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "createdBy": "str",  # Optional. Created by user/tenant id.
                    "createdDateTime": "2020-02-20 00:00:00",  # Optional. Date-time when
                      resource was created, sample format: yyyy-MM-ddTHH:mm:ssZ.
                    "cropId": "str",  # Optional. Crop Id.
                    "description": "str",  # Optional. Textual description of the resource.
                    "eTag": "str",  # Optional. The ETag value to implement optimistic
                      concurrency.
                    "fieldId": "str",  # Optional. Field Id.
                    "id": "str",  # Optional. Unique resource ID.
                    "modifiedBy": "str",  # Optional. Modified by user/tenant id.
                    "modifiedDateTime": "2020-02-20 00:00:00",  # Optional. Date-time when
                      resource was last modified, sample format: yyyy-MM-ddTHH:mm:ssZ.
                    "name": "str",  # Optional. Name to identify resource.
                    "partyId": "str",  # Optional. Party Id.
                    "properties": {
                        "str": {}  # Optional. A collection of key value pairs that belongs
                          to the resource."nEach pair must not have a key greater than 50
                          characters"nand must not have a value greater than 150 characters."nNote: A
                          maximum of 25 key value pairs can be provided for a resource and only
                          string,"nnumeral and datetime (yyyy-MM-ddTHH:mm:ssZ) values are supported.
                    },
                    "seasonId": "str",  # Optional. Season Id.
                    "source": "str",  # Optional. Source of the resource.
                    "status": "str",  # Optional. Status of the resource.
                    "type": "str"  # Optional. Prescription map type.
                }
        """
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls = kwargs.pop("cls", None)  # type: ClsType[JSON]

        request = build_prescription_maps_get_request(
            party_id=party_id,
            prescription_map_id=prescription_map_id,
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        request.url = self._client.format_url(request.url)  # type: ignore

        pipeline_response = self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
            request, stream=False, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if response.content:
            deserialized = response.json()
        else:
            deserialized = None

        if cls:
            return cls(pipeline_response, cast(JSON, deserialized), {})

        return cast(JSON, deserialized)

    @overload
    def create_or_update(
        self,
        party_id: str,
        prescription_map_id: str,
        prescription_map: JSON,
        *,
        content_type: str = "application/merge-patch+json",
        **kwargs: Any
    ) -> JSON:
        """Creates or Updates a prescription map resource under a particular party.

        :param party_id: Id of the associated party resource. Required.
        :type party_id: str
        :param prescription_map_id: Id of the prescription map resource. Required.
        :type prescription_map_id: str
        :param prescription_map: PrescriptionMap resource payload to create or update. Required.
        :type prescription_map: JSON
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/merge-patch+json".
        :paramtype content_type: str
        :return: JSON object
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                prescription_map = {
                    "createdBy": "str",  # Optional. Created by user/tenant id.
                    "createdDateTime": "2020-02-20 00:00:00",  # Optional. Date-time when
                      resource was created, sample format: yyyy-MM-ddTHH:mm:ssZ.
                    "cropId": "str",  # Optional. Crop Id.
                    "description": "str",  # Optional. Textual description of the resource.
                    "eTag": "str",  # Optional. The ETag value to implement optimistic
                      concurrency.
                    "fieldId": "str",  # Optional. Field Id.
                    "id": "str",  # Optional. Unique resource ID.
                    "modifiedBy": "str",  # Optional. Modified by user/tenant id.
                    "modifiedDateTime": "2020-02-20 00:00:00",  # Optional. Date-time when
                      resource was last modified, sample format: yyyy-MM-ddTHH:mm:ssZ.
                    "name": "str",  # Optional. Name to identify resource.
                    "partyId": "str",  # Optional. Party Id.
                    "properties": {
                        "str": {}  # Optional. A collection of key value pairs that belongs
                          to the resource."nEach pair must not have a key greater than 50
                          characters"nand must not have a value greater than 150 characters."nNote: A
                          maximum of 25 key value pairs can be provided for a resource and only
                          string,"nnumeral and datetime (yyyy-MM-ddTHH:mm:ssZ) values are supported.
                    },
                    "seasonId": "str",  # Optional. Season Id.
                    "source": "str",  # Optional. Source of the resource.
                    "status": "str",  # Optional. Status of the resource.
                    "type": "str"  # Optional. Prescription map type.
                }

                # response body for status code(s): 200, 201
                response == {
                    "createdBy": "str",  # Optional. Created by user/tenant id.
                    "createdDateTime": "2020-02-20 00:00:00",  # Optional. Date-time when
                      resource was created, sample format: yyyy-MM-ddTHH:mm:ssZ.
                    "cropId": "str",  # Optional. Crop Id.
                    "description": "str",  # Optional. Textual description of the resource.
                    "eTag": "str",  # Optional. The ETag value to implement optimistic
                      concurrency.
                    "fieldId": "str",  # Optional. Field Id.
                    "id": "str",  # Optional. Unique resource ID.
                    "modifiedBy": "str",  # Optional. Modified by user/tenant id.
                    "modifiedDateTime": "2020-02-20 00:00:00",  # Optional. Date-time when
                      resource was last modified, sample format: yyyy-MM-ddTHH:mm:ssZ.
                    "name": "str",  # Optional. Name to identify resource.
                    "partyId": "str",  # Optional. Party Id.
                    "properties": {
                        "str": {}  # Optional. A collection of key value pairs that belongs
                          to the resource."nEach pair must not have a key greater than 50
                          characters"nand must not have a value greater than 150 characters."nNote: A
                          maximum of 25 key value pairs can be provided for a resource and only
                          string,"nnumeral and datetime (yyyy-MM-ddTHH:mm:ssZ) values are supported.
                    },
                    "seasonId": "str",  # Optional. Season Id.
                    "source": "str",  # Optional. Source of the resource.
                    "status": "str",  # Optional. Status of the resource.
                    "type": "str"  # Optional. Prescription map type.
                }
        """

    @overload
    def create_or_update(
        self,
        party_id: str,
        prescription_map_id: str,
        prescription_map: IO,
        *,
        content_type: str = "application/merge-patch+json",
        **kwargs: Any
    ) -> JSON:
        """Creates or Updates a prescription map resource under a particular party.

        :param party_id: Id of the associated party resource. Required.
        :type party_id: str
        :param prescription_map_id: Id of the prescription map resource. Required.
        :type prescription_map_id: str
        :param prescription_map: PrescriptionMap resource payload to create or update. Required.
        :type prescription_map: IO
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Default value is "application/merge-patch+json".
        :paramtype content_type: str
        :return: JSON object
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200, 201
                response == {
                    "createdBy": "str",  # Optional. Created by user/tenant id.
                    "createdDateTime": "2020-02-20 00:00:00",  # Optional. Date-time when
                      resource was created, sample format: yyyy-MM-ddTHH:mm:ssZ.
                    "cropId": "str",  # Optional. Crop Id.
                    "description": "str",  # Optional. Textual description of the resource.
                    "eTag": "str",  # Optional. The ETag value to implement optimistic
                      concurrency.
                    "fieldId": "str",  # Optional. Field Id.
                    "id": "str",  # Optional. Unique resource ID.
                    "modifiedBy": "str",  # Optional. Modified by user/tenant id.
                    "modifiedDateTime": "2020-02-20 00:00:00",  # Optional. Date-time when
                      resource was last modified, sample format: yyyy-MM-ddTHH:mm:ssZ.
                    "name": "str",  # Optional. Name to identify resource.
                    "partyId": "str",  # Optional. Party Id.
                    "properties": {
                        "str": {}  # Optional. A collection of key value pairs that belongs
                          to the resource."nEach pair must not have a key greater than 50
                          characters"nand must not have a value greater than 150 characters."nNote: A
                          maximum of 25 key value pairs can be provided for a resource and only
                          string,"nnumeral and datetime (yyyy-MM-ddTHH:mm:ssZ) values are supported.
                    },
                    "seasonId": "str",  # Optional. Season Id.
                    "source": "str",  # Optional. Source of the resource.
                    "status": "str",  # Optional. Status of the resource.
                    "type": "str"  # Optional. Prescription map type.
                }
        """

    @distributed_trace
    def create_or_update(
        self, party_id: str, prescription_map_id: str, prescription_map: Union[JSON, IO], **kwargs: Any
    ) -> JSON:
        """Creates or Updates a prescription map resource under a particular party.

        :param party_id: Id of the associated party resource. Required.
        :type party_id: str
        :param prescription_map_id: Id of the prescription map resource. Required.
        :type prescription_map_id: str
        :param prescription_map: PrescriptionMap resource payload to create or update. Is either a
         model type or a IO type. Required.
        :type prescription_map: JSON or IO
        :keyword content_type: Body Parameter content-type. Known values are:
         'application/merge-patch+json'. Default value is None.
        :paramtype content_type: str
        :return: JSON object
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200, 201
                response == {
                    "createdBy": "str",  # Optional. Created by user/tenant id.
                    "createdDateTime": "2020-02-20 00:00:00",  # Optional. Date-time when
                      resource was created, sample format: yyyy-MM-ddTHH:mm:ssZ.
                    "cropId": "str",  # Optional. Crop Id.
                    "description": "str",  # Optional. Textual description of the resource.
                    "eTag": "str",  # Optional. The ETag value to implement optimistic
                      concurrency.
                    "fieldId": "str",  # Optional. Field Id.
                    "id": "str",  # Optional. Unique resource ID.
                    "modifiedBy": "str",  # Optional. Modified by user/tenant id.
                    "modifiedDateTime": "2020-02-20 00:00:00",  # Optional. Date-time when
                      resource was last modified, sample format: yyyy-MM-ddTHH:mm:ssZ.
                    "name": "str",  # Optional. Name to identify resource.
                    "partyId": "str",  # Optional. Party Id.
                    "properties": {
                        "str": {}  # Optional. A collection of key value pairs that belongs
                          to the resource."nEach pair must not have a key greater than 50
                          characters"nand must not have a value greater than 150 characters."nNote: A
                          maximum of 25 key value pairs can be provided for a resource and only
                          string,"nnumeral and datetime (yyyy-MM-ddTHH:mm:ssZ) values are supported.
                    },
                    "seasonId": "str",  # Optional. Season Id.
                    "source": "str",  # Optional. Source of the resource.
                    "status": "str",  # Optional. Status of the resource.
                    "type": "str"  # Optional. Prescription map type.
                }
        """
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type = kwargs.pop("content_type", _headers.pop("Content-Type", None))  # type: Optional[str]
        cls = kwargs.pop("cls", None)  # type: ClsType[JSON]

        content_type = content_type or "application/merge-patch+json"
        _json = None
        _content = None
        if isinstance(prescription_map, (IO, bytes)):
            _content = prescription_map
        else:
            _json = prescription_map

        request = build_prescription_maps_create_or_update_request(
            party_id=party_id,
            prescription_map_id=prescription_map_id,
            content_type=content_type,
            api_version=self._config.api_version,
            json=_json,
            content=_content,
            headers=_headers,
            params=_params,
        )
        request.url = self._client.format_url(request.url)  # type: ignore

        pipeline_response = self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
            request, stream=False, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200, 201]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if response.status_code == 200:
            if response.content:
                deserialized = response.json()
            else:
                deserialized = None

        if response.status_code == 201:
            if response.content:
                deserialized = response.json()
            else:
                deserialized = None

        if cls:
            return cls(pipeline_response, cast(JSON, deserialized), {})

        return cast(JSON, deserialized)

    @distributed_trace
    def delete(  # pylint: disable=inconsistent-return-statements
        self, party_id: str, prescription_map_id: str, **kwargs: Any
    ) -> None:
        """Deletes a specified prescription map resource under a particular party.

        :param party_id: Id of the party. Required.
        :type party_id: str
        :param prescription_map_id: Id of the prescriptionMap. Required.
        :type prescription_map_id: str
        :return: None
        :rtype: None
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls = kwargs.pop("cls", None)  # type: ClsType[None]

        request = build_prescription_maps_delete_request(
            party_id=party_id,
            prescription_map_id=prescription_map_id,
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        request.url = self._client.format_url(request.url)  # type: ignore

        pipeline_response = self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
            request, stream=False, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [204]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if cls:
            return cls(pipeline_response, None, {})

    @distributed_trace
    def list(
        self,
        *,
        types: Optional[List[str]] = None,
        crop_ids: Optional[List[str]] = None,
        season_ids: Optional[List[str]] = None,
        field_ids: Optional[List[str]] = None,
        sources: Optional[List[str]] = None,
        ids: Optional[List[str]] = None,
        names: Optional[List[str]] = None,
        property_filters: Optional[List[str]] = None,
        statuses: Optional[List[str]] = None,
        min_created_date_time: Optional[datetime.datetime] = None,
        max_created_date_time: Optional[datetime.datetime] = None,
        min_last_modified_date_time: Optional[datetime.datetime] = None,
        max_last_modified_date_time: Optional[datetime.datetime] = None,
        skip_token: Optional[str] = None,
        **kwargs: Any
    ) -> Iterable[JSON]:
        """Returns a paginated list of prescription map resources across all parties.

        :keyword types: Types of the resource. Default value is None.
        :paramtype types: list[str]
        :keyword crop_ids: Crop Ids of the resource. Default value is None.
        :paramtype crop_ids: list[str]
        :keyword season_ids: Season Ids of the resource. Default value is None.
        :paramtype season_ids: list[str]
        :keyword field_ids: Field Ids of the resource. Default value is None.
        :paramtype field_ids: list[str]
        :keyword sources: Sources for the resource. Default value is None.
        :paramtype sources: list[str]
        :keyword ids: Ids of the resource. Default value is None.
        :paramtype ids: list[str]
        :keyword names: Names of the resource. Default value is None.
        :paramtype names: list[str]
        :keyword property_filters: Filters on key-value pairs within the Properties object.
         eg. "{testKey} eq {testValue}". Default value is None.
        :paramtype property_filters: list[str]
        :keyword statuses: Statuses of the resource. Default value is None.
        :paramtype statuses: list[str]
        :keyword min_created_date_time: Minimum creation date of resource (inclusive). Default value is
         None.
        :paramtype min_created_date_time: ~datetime.datetime
        :keyword max_created_date_time: Maximum creation date of resource (inclusive). Default value is
         None.
        :paramtype max_created_date_time: ~datetime.datetime
        :keyword min_last_modified_date_time: Minimum last modified date of resource (inclusive).
         Default value is None.
        :paramtype min_last_modified_date_time: ~datetime.datetime
        :keyword max_last_modified_date_time: Maximum last modified date of resource (inclusive).
         Default value is None.
        :paramtype max_last_modified_date_time: ~datetime.datetime
        :keyword skip_token: Skip token for getting next set of results. Default value is None.
        :paramtype skip_token: str
        :return: An iterator like instance of JSON object
        :rtype: ~azure.core.paging.ItemPaged[JSON]
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "createdBy": "str",  # Optional. Created by user/tenant id.
                    "createdDateTime": "2020-02-20 00:00:00",  # Optional. Date-time when
                      resource was created, sample format: yyyy-MM-ddTHH:mm:ssZ.
                    "cropId": "str",  # Optional. Crop Id.
                    "description": "str",  # Optional. Textual description of the resource.
                    "eTag": "str",  # Optional. The ETag value to implement optimistic
                      concurrency.
                    "fieldId": "str",  # Optional. Field Id.
                    "id": "str",  # Optional. Unique resource ID.
                    "modifiedBy": "str",  # Optional. Modified by user/tenant id.
                    "modifiedDateTime": "2020-02-20 00:00:00",  # Optional. Date-time when
                      resource was last modified, sample format: yyyy-MM-ddTHH:mm:ssZ.
                    "name": "str",  # Optional. Name to identify resource.
                    "partyId": "str",  # Optional. Party Id.
                    "properties": {
                        "str": {}  # Optional. A collection of key value pairs that belongs
                          to the resource."nEach pair must not have a key greater than 50
                          characters"nand must not have a value greater than 150 characters."nNote: A
                          maximum of 25 key value pairs can be provided for a resource and only
                          string,"nnumeral and datetime (yyyy-MM-ddTHH:mm:ssZ) values are supported.
                    },
                    "seasonId": "str",  # Optional. Season Id.
                    "source": "str",  # Optional. Source of the resource.
                    "status": "str",  # Optional. Status of the resource.
                    "type": "str"  # Optional. Prescription map type.
                }
        """
        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls = kwargs.pop("cls", None)  # type: ClsType[JSON]

        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        def prepare_request(next_link=None):
            if not next_link:

                request = build_prescription_maps_list_request(
                    types=types,
                    crop_ids=crop_ids,
                    season_ids=season_ids,
                    field_ids=field_ids,
                    sources=sources,
                    ids=ids,
                    names=names,
                    property_filters=property_filters,
                    statuses=statuses,
                    min_created_date_time=min_created_date_time,
                    max_created_date_time=max_created_date_time,
                    min_last_modified_date_time=min_last_modified_date_time,
                    max_last_modified_date_time=max_last_modified_date_time,
                    skip_token=skip_token,
                    api_version=self._config.api_version,
                    headers=_headers,
                    params=_params,
                )
                request.url = self._client.format_url(request.url)  # type: ignore

            else:
                # make call to next link with the client's api-version
                _parsed_next_link = urlparse(next_link)
                _next_request_params = case_insensitive_dict(parse_qs(_parsed_next_link.query))
                _next_request_params["api-version"] = self._config.api_version
                request = HttpRequest("GET", urljoin(next_link, _parsed_next_link.path), params=_next_request_params)
                request.url = self._client.format_url(request.url)  # type: ignore

            return request

        def extract_data(pipeline_response):
            deserialized = pipeline_response.http_response.json()
            list_of_elem = deserialized["value"]
            if cls:
                list_of_elem = cls(list_of_elem)
            return deserialized.get("nextLink", None), iter(list_of_elem)

        def get_next(next_link=None):
            request = prepare_request(next_link)

            pipeline_response = self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
                request, stream=False, **kwargs
            )
            response = pipeline_response.http_response

            if response.status_code not in [200]:
                map_error(status_code=response.status_code, response=response, error_map=error_map)
                raise HttpResponseError(response=response)

            return pipeline_response

        return ItemPaged(get_next, extract_data)

    @distributed_trace
    def get_cascade_delete_job_details(self, job_id: str, **kwargs: Any) -> JSON:
        """Get a cascade delete job for specified prescription map.

        :param job_id: Id of the job. Required.
        :type job_id: str
        :return: JSON object
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "partyId": "str",  # Party Id. Required.
                    "resourceId": "str",  # The id of the resource. Required.
                    "resourceType": "str",  # The type of the resource. Required.
                    "createdDateTime": "2020-02-20 00:00:00",  # Optional. Job created at
                      dateTime. Sample format: yyyy-MM-ddTHH:mm:ssZ.
                    "durationInSeconds": 0.0,  # Optional. Duration of the job in seconds.
                    "endTime": "2020-02-20 00:00:00",  # Optional. Job end time when available.
                      Sample format: yyyy-MM-ddTHH:mm:ssZ.
                    "errorCode": "str",  # Optional. Error Code when job failed.
                    "id": "str",  # Optional. Unique job id.
                    "lastActionDateTime": "2020-02-20 00:00:00",  # Optional. Job was last acted
                      upon at dateTime. Sample format: yyyy-MM-ddTHH:mm:ssZ.
                    "message": "str",  # Optional. Status message to capture more details of the
                      job.
                    "startTime": "2020-02-20 00:00:00",  # Optional. Job start time when
                      available. Sample format: yyyy-MM-ddTHH:mm:ssZ.
                    "status": "str"  # Optional. Status of the job."nPossible values: 'Waiting',
                      'Running', 'Succeeded', 'Failed', 'Cancelled'. Known values are: "Waiting",
                      "Running", "Succeeded", "Failed", and "Cancelled".
                }
        """
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls = kwargs.pop("cls", None)  # type: ClsType[JSON]

        request = build_prescription_maps_get_cascade_delete_job_details_request(
            job_id=job_id,
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        request.url = self._client.format_url(request.url)  # type: ignore

        pipeline_response = self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
            request, stream=False, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if response.content:
            deserialized = response.json()
        else:
            deserialized = None

        if cls:
            return cls(pipeline_response, cast(JSON, deserialized), {})

        return cast(JSON, deserialized)

    def _create_cascade_delete_job_initial(
        self, job_id: str, *, party_id: str, prescription_map_id: str, **kwargs: Any
    ) -> JSON:
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls = kwargs.pop("cls", None)  # type: ClsType[JSON]

        request = build_prescription_maps_create_cascade_delete_job_request(
            job_id=job_id,
            party_id=party_id,
            prescription_map_id=prescription_map_id,
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        request.url = self._client.format_url(request.url)  # type: ignore

        pipeline_response = self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
            request, stream=False, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [202]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if response.content:
            deserialized = response.json()
        else:
            deserialized = None

        if cls:
            return cls(pipeline_response, cast(JSON, deserialized), {})

        return cast(JSON, deserialized)

    @distributed_trace
    def begin_create_cascade_delete_job(
        self, job_id: str, *, party_id: str, prescription_map_id: str, **kwargs: Any
    ) -> LROPoller[JSON]:
        """Create a cascade delete job for specified prescription map.

        :param job_id: Job ID supplied by end user. Required.
        :type job_id: str
        :keyword party_id: ID of the associated party. Required.
        :paramtype party_id: str
        :keyword prescription_map_id: ID of the prescription map to be deleted. Required.
        :paramtype prescription_map_id: str
        :keyword str continuation_token: A continuation token to restart a poller from a saved state.
        :keyword polling: By default, your polling method will be LROBasePolling. Pass in False for
         this operation to not poll, or pass in your own initialized polling object for a personal
         polling strategy.
        :paramtype polling: bool or ~azure.core.polling.PollingMethod
        :keyword int polling_interval: Default waiting time between two polls for LRO operations if no
         Retry-After header is present.
        :return: An instance of LROPoller that returns JSON object
        :rtype: ~azure.core.polling.LROPoller[JSON]
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 202
                response == {
                    "partyId": "str",  # Party Id. Required.
                    "resourceId": "str",  # The id of the resource. Required.
                    "resourceType": "str",  # The type of the resource. Required.
                    "createdDateTime": "2020-02-20 00:00:00",  # Optional. Job created at
                      dateTime. Sample format: yyyy-MM-ddTHH:mm:ssZ.
                    "durationInSeconds": 0.0,  # Optional. Duration of the job in seconds.
                    "endTime": "2020-02-20 00:00:00",  # Optional. Job end time when available.
                      Sample format: yyyy-MM-ddTHH:mm:ssZ.
                    "errorCode": "str",  # Optional. Error Code when job failed.
                    "id": "str",  # Optional. Unique job id.
                    "lastActionDateTime": "2020-02-20 00:00:00",  # Optional. Job was last acted
                      upon at dateTime. Sample format: yyyy-MM-ddTHH:mm:ssZ.
                    "message": "str",  # Optional. Status message to capture more details of the
                      job.
                    "startTime": "2020-02-20 00:00:00",  # Optional. Job start time when
                      available. Sample format: yyyy-MM-ddTHH:mm:ssZ.
                    "status": "str"  # Optional. Status of the job."nPossible values: 'Waiting',
                      'Running', 'Succeeded', 'Failed', 'Cancelled'. Known values are: "Waiting",
                      "Running", "Succeeded", "Failed", and "Cancelled".
                }
        """
        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls = kwargs.pop("cls", None)  # type: ClsType[JSON]
        polling = kwargs.pop("polling", True)  # type: Union[bool, PollingMethod]
        lro_delay = kwargs.pop("polling_interval", self._config.polling_interval)
        cont_token = kwargs.pop("continuation_token", None)  # type: Optional[str]
        if cont_token is None:
            raw_result = self._create_cascade_delete_job_initial(  # type: ignore
                job_id=job_id,
                party_id=party_id,
                prescription_map_id=prescription_map_id,
                cls=lambda x, y, z: x,
                headers=_headers,
                params=_params,
                **kwargs
            )
        kwargs.pop("error_map", None)

        def get_long_running_output(pipeline_response):
            response = pipeline_response.http_response
            if response.content:
                deserialized = response.json()
            else:
                deserialized = None
            if cls:
                return cls(pipeline_response, deserialized, {})
            return deserialized

        if polling is True:
            polling_method = cast(
                PollingMethod, LROBasePolling(lro_delay, lro_options={"final-state-via": "location"}, **kwargs)
            )  # type: PollingMethod
        elif polling is False:
            polling_method = cast(PollingMethod, NoPolling())
        else:
            polling_method = polling
        if cont_token:
            return LROPoller.from_continuation_token(
                polling_method=polling_method,
                continuation_token=cont_token,
                client=self._client,
                deserialization_callback=get_long_running_output,
            )
        return LROPoller(self._client, raw_result, get_long_running_output, polling_method)


class PrescriptionsOperations:
    """
    .. warning::
        **DO NOT** instantiate this class directly.

        Instead, you should access the following operations through
        :class:`~azure.agrifood.farming.FarmBeatsClient`'s
        :attr:`prescriptions` attribute.
    """

    def __init__(self, *args, **kwargs):
        input_args = list(args)
        self._client = input_args.pop(0) if input_args else kwargs.pop("client")
        self._config = input_args.pop(0) if input_args else kwargs.pop("config")
        self._serialize = input_args.pop(0) if input_args else kwargs.pop("serializer")
        self._deserialize = input_args.pop(0) if input_args else kwargs.pop("deserializer")

    @distributed_trace
    def list_by_party_id(
        self,
        party_id: str,
        *,
        prescription_map_ids: Optional[List[str]] = None,
        types: Optional[List[str]] = None,
        product_codes: Optional[List[str]] = None,
        product_names: Optional[List[str]] = None,
        sources: Optional[List[str]] = None,
        ids: Optional[List[str]] = None,
        names: Optional[List[str]] = None,
        property_filters: Optional[List[str]] = None,
        statuses: Optional[List[str]] = None,
        min_created_date_time: Optional[datetime.datetime] = None,
        max_created_date_time: Optional[datetime.datetime] = None,
        min_last_modified_date_time: Optional[datetime.datetime] = None,
        max_last_modified_date_time: Optional[datetime.datetime] = None,
        skip_token: Optional[str] = None,
        **kwargs: Any
    ) -> Iterable[JSON]:
        """Returns a paginated list of prescription resources under a particular party.

        :param party_id: Id of the associated party. Required.
        :type party_id: str
        :keyword prescription_map_ids: Prescription Map Ids of the resource. Default value is None.
        :paramtype prescription_map_ids: list[str]
        :keyword types: Types of the resource. Default value is None.
        :paramtype types: list[str]
        :keyword product_codes: Product Codes of the resource. Default value is None.
        :paramtype product_codes: list[str]
        :keyword product_names: Product Names of the resource. Default value is None.
        :paramtype product_names: list[str]
        :keyword sources: Sources for the resource. Default value is None.
        :paramtype sources: list[str]
        :keyword ids: Ids of the resource. Default value is None.
        :paramtype ids: list[str]
        :keyword names: Names of the resource. Default value is None.
        :paramtype names: list[str]
        :keyword property_filters: Filters on key-value pairs within the Properties object.
         eg. "{testKey} eq {testValue}". Default value is None.
        :paramtype property_filters: list[str]
        :keyword statuses: Statuses of the resource. Default value is None.
        :paramtype statuses: list[str]
        :keyword min_created_date_time: Minimum creation date of resource (inclusive). Default value is
         None.
        :paramtype min_created_date_time: ~datetime.datetime
        :keyword max_created_date_time: Maximum creation date of resource (inclusive). Default value is
         None.
        :paramtype max_created_date_time: ~datetime.datetime
        :keyword min_last_modified_date_time: Minimum last modified date of resource (inclusive).
         Default value is None.
        :paramtype min_last_modified_date_time: ~datetime.datetime
        :keyword max_last_modified_date_time: Maximum last modified date of resource (inclusive).
         Default value is None.
        :paramtype max_last_modified_date_time: ~datetime.datetime
        :keyword skip_token: Skip token for getting next set of results. Default value is None.
        :paramtype skip_token: str
        :return: An iterator like instance of JSON object
        :rtype: ~azure.core.paging.ItemPaged[JSON]
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "createdBy": "str",  # Optional. Created by user/tenant id.
                    "createdDateTime": "2020-02-20 00:00:00",  # Optional. Date-time when
                      resource was created, sample format: yyyy-MM-ddTHH:mm:ssZ.
                    "description": "str",  # Optional. Textual description of the resource.
                    "eTag": "str",  # Optional. The ETag value to implement optimistic
                      concurrency.
                    "id": "str",  # Optional. Unique resource ID.
                    "measurements": {
                        "str": {
                            "unit": "str",  # Optional. Data unit.
                            "value": 0.0  # Optional. Data value.
                        }
                    },
                    "modifiedBy": "str",  # Optional. Modified by user/tenant id.
                    "modifiedDateTime": "2020-02-20 00:00:00",  # Optional. Date-time when
                      resource was last modified, sample format: yyyy-MM-ddTHH:mm:ssZ.
                    "name": "str",  # Optional. Name to identify resource.
                    "partyId": "str",  # Optional. Party Id.
                    "prescriptionMapId": "str",  # Optional. Prescription map Id.
                    "productCode": "str",  # Optional. Product Code.
                    "productName": "str",  # Optional. Product name.
                    "properties": {
                        "str": {}  # Optional. A collection of key value pairs that belongs
                          to the resource."nEach pair must not have a key greater than 50
                          characters"nand must not have a value greater than 150 characters."nNote: A
                          maximum of 25 key value pairs can be provided for a resource and only
                          string,"nnumeral and datetime (yyyy-MM-ddTHH:mm:ssZ) values are supported.
                    },
                    "source": "str",  # Optional. Source of the resource.
                    "status": "str",  # Optional. Status of the resource.
                    "type": "str"  # Optional. Prescription type.
                }
        """
        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls = kwargs.pop("cls", None)  # type: ClsType[JSON]

        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        def prepare_request(next_link=None):
            if not next_link:

                request = build_prescriptions_list_by_party_id_request(
                    party_id=party_id,
                    prescription_map_ids=prescription_map_ids,
                    types=types,
                    product_codes=product_codes,
                    product_names=product_names,
                    sources=sources,
                    ids=ids,
                    names=names,
                    property_filters=property_filters,
                    statuses=statuses,
                    min_created_date_time=min_created_date_time,
                    max_created_date_time=max_created_date_time,
                    min_last_modified_date_time=min_last_modified_date_time,
                    max_last_modified_date_time=max_last_modified_date_time,
                    skip_token=skip_token,
                    api_version=self._config.api_version,
                    headers=_headers,
                    params=_params,
                )
                request.url = self._client.format_url(request.url)  # type: ignore

            else:
                # make call to next link with the client's api-version
                _parsed_next_link = urlparse(next_link)
                _next_request_params = case_insensitive_dict(parse_qs(_parsed_next_link.query))
                _next_request_params["api-version"] = self._config.api_version
                request = HttpRequest("GET", urljoin(next_link, _parsed_next_link.path), params=_next_request_params)
                request.url = self._client.format_url(request.url)  # type: ignore

            return request

        def extract_data(pipeline_response):
            deserialized = pipeline_response.http_response.json()
            list_of_elem = deserialized["value"]
            if cls:
                list_of_elem = cls(list_of_elem)
            return deserialized.get("nextLink", None), iter(list_of_elem)

        def get_next(next_link=None):
            request = prepare_request(next_link)

            pipeline_response = self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
                request, stream=False, **kwargs
            )
            response = pipeline_response.http_response

            if response.status_code not in [200]:
                map_error(status_code=response.status_code, response=response, error_map=error_map)
                raise HttpResponseError(response=response)

            return pipeline_response

        return ItemPaged(get_next, extract_data)

    @distributed_trace
    def get(self, party_id: str, prescription_id: str, **kwargs: Any) -> JSON:
        """Gets a specified prescription resource under a particular party.

        :param party_id: Id of the associated party. Required.
        :type party_id: str
        :param prescription_id: Id of the prescription. Required.
        :type prescription_id: str
        :return: JSON object
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "createdBy": "str",  # Optional. Created by user/tenant id.
                    "createdDateTime": "2020-02-20 00:00:00",  # Optional. Date-time when
                      resource was created, sample format: yyyy-MM-ddTHH:mm:ssZ.
                    "description": "str",  # Optional. Textual description of the resource.
                    "eTag": "str",  # Optional. The ETag value to implement optimistic
                      concurrency.
                    "id": "str",  # Optional. Unique resource ID.
                    "measurements": {
                        "str": {
                            "unit": "str",  # Optional. Data unit.
                            "value": 0.0  # Optional. Data value.
                        }
                    },
                    "modifiedBy": "str",  # Optional. Modified by user/tenant id.
                    "modifiedDateTime": "2020-02-20 00:00:00",  # Optional. Date-time when
                      resource was last modified, sample format: yyyy-MM-ddTHH:mm:ssZ.
                    "name": "str",  # Optional. Name to identify resource.
                    "partyId": "str",  # Optional. Party Id.
                    "prescriptionMapId": "str",  # Optional. Prescription map Id.
                    "productCode": "str",  # Optional. Product Code.
                    "productName": "str",  # Optional. Product name.
                    "properties": {
                        "str": {}  # Optional. A collection of key value pairs that belongs
                          to the resource."nEach pair must not have a key greater than 50
                          characters"nand must not have a value greater than 150 characters."nNote: A
                          maximum of 25 key value pairs can be provided for a resource and only
                          string,"nnumeral and datetime (yyyy-MM-ddTHH:mm:ssZ) values are supported.
                    },
                    "source": "str",  # Optional. Source of the resource.
                    "status": "str",  # Optional. Status of the resource.
                    "type": "str"  # Optional. Prescription type.
                }
        """
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls = kwargs.pop("cls", None)  # type: ClsType[JSON]

        request = build_prescriptions_get_request(
            party_id=party_id,
            prescription_id=prescription_id,
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        request.url = self._client.format_url(request.url)  # type: ignore

        pipeline_response = self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
            request, stream=False, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if response.content:
            deserialized = response.json()
        else:
            deserialized = None

        if cls:
            return cls(pipeline_response, cast(JSON, deserialized), {})

        return cast(JSON, deserialized)

    @overload
    def create_or_update(
        self,
        party_id: str,
        prescription_id: str,
        prescription: JSON,
        *,
        content_type: str = "application/merge-patch+json",
        **kwargs: Any
    ) -> JSON:
        """Creates or Updates a prescription resource under a particular party.

        :param party_id: Id of the associated party resource. Required.
        :type party_id: str
        :param prescription_id: Id of the prescription resource. Required.
        :type prescription_id: str
        :param prescription: Prescription resource payload to create or update. Required.
        :type prescription: JSON
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/merge-patch+json".
        :paramtype content_type: str
        :return: JSON object
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                prescription = {
                    "createdBy": "str",  # Optional. Created by user/tenant id.
                    "createdDateTime": "2020-02-20 00:00:00",  # Optional. Date-time when
                      resource was created, sample format: yyyy-MM-ddTHH:mm:ssZ.
                    "description": "str",  # Optional. Textual description of the resource.
                    "eTag": "str",  # Optional. The ETag value to implement optimistic
                      concurrency.
                    "id": "str",  # Optional. Unique resource ID.
                    "measurements": {
                        "str": {
                            "unit": "str",  # Optional. Data unit.
                            "value": 0.0  # Optional. Data value.
                        }
                    },
                    "modifiedBy": "str",  # Optional. Modified by user/tenant id.
                    "modifiedDateTime": "2020-02-20 00:00:00",  # Optional. Date-time when
                      resource was last modified, sample format: yyyy-MM-ddTHH:mm:ssZ.
                    "name": "str",  # Optional. Name to identify resource.
                    "partyId": "str",  # Optional. Party Id.
                    "prescriptionMapId": "str",  # Optional. Prescription map Id.
                    "productCode": "str",  # Optional. Product Code.
                    "productName": "str",  # Optional. Product name.
                    "properties": {
                        "str": {}  # Optional. A collection of key value pairs that belongs
                          to the resource."nEach pair must not have a key greater than 50
                          characters"nand must not have a value greater than 150 characters."nNote: A
                          maximum of 25 key value pairs can be provided for a resource and only
                          string,"nnumeral and datetime (yyyy-MM-ddTHH:mm:ssZ) values are supported.
                    },
                    "source": "str",  # Optional. Source of the resource.
                    "status": "str",  # Optional. Status of the resource.
                    "type": "str"  # Optional. Prescription type.
                }

                # response body for status code(s): 200, 201
                response == {
                    "createdBy": "str",  # Optional. Created by user/tenant id.
                    "createdDateTime": "2020-02-20 00:00:00",  # Optional. Date-time when
                      resource was created, sample format: yyyy-MM-ddTHH:mm:ssZ.
                    "description": "str",  # Optional. Textual description of the resource.
                    "eTag": "str",  # Optional. The ETag value to implement optimistic
                      concurrency.
                    "id": "str",  # Optional. Unique resource ID.
                    "measurements": {
                        "str": {
                            "unit": "str",  # Optional. Data unit.
                            "value": 0.0  # Optional. Data value.
                        }
                    },
                    "modifiedBy": "str",  # Optional. Modified by user/tenant id.
                    "modifiedDateTime": "2020-02-20 00:00:00",  # Optional. Date-time when
                      resource was last modified, sample format: yyyy-MM-ddTHH:mm:ssZ.
                    "name": "str",  # Optional. Name to identify resource.
                    "partyId": "str",  # Optional. Party Id.
                    "prescriptionMapId": "str",  # Optional. Prescription map Id.
                    "productCode": "str",  # Optional. Product Code.
                    "productName": "str",  # Optional. Product name.
                    "properties": {
                        "str": {}  # Optional. A collection of key value pairs that belongs
                          to the resource."nEach pair must not have a key greater than 50
                          characters"nand must not have a value greater than 150 characters."nNote: A
                          maximum of 25 key value pairs can be provided for a resource and only
                          string,"nnumeral and datetime (yyyy-MM-ddTHH:mm:ssZ) values are supported.
                    },
                    "source": "str",  # Optional. Source of the resource.
                    "status": "str",  # Optional. Status of the resource.
                    "type": "str"  # Optional. Prescription type.
                }
        """

    @overload
    def create_or_update(
        self,
        party_id: str,
        prescription_id: str,
        prescription: IO,
        *,
        content_type: str = "application/merge-patch+json",
        **kwargs: Any
    ) -> JSON:
        """Creates or Updates a prescription resource under a particular party.

        :param party_id: Id of the associated party resource. Required.
        :type party_id: str
        :param prescription_id: Id of the prescription resource. Required.
        :type prescription_id: str
        :param prescription: Prescription resource payload to create or update. Required.
        :type prescription: IO
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Default value is "application/merge-patch+json".
        :paramtype content_type: str
        :return: JSON object
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200, 201
                response == {
                    "createdBy": "str",  # Optional. Created by user/tenant id.
                    "createdDateTime": "2020-02-20 00:00:00",  # Optional. Date-time when
                      resource was created, sample format: yyyy-MM-ddTHH:mm:ssZ.
                    "description": "str",  # Optional. Textual description of the resource.
                    "eTag": "str",  # Optional. The ETag value to implement optimistic
                      concurrency.
                    "id": "str",  # Optional. Unique resource ID.
                    "measurements": {
                        "str": {
                            "unit": "str",  # Optional. Data unit.
                            "value": 0.0  # Optional. Data value.
                        }
                    },
                    "modifiedBy": "str",  # Optional. Modified by user/tenant id.
                    "modifiedDateTime": "2020-02-20 00:00:00",  # Optional. Date-time when
                      resource was last modified, sample format: yyyy-MM-ddTHH:mm:ssZ.
                    "name": "str",  # Optional. Name to identify resource.
                    "partyId": "str",  # Optional. Party Id.
                    "prescriptionMapId": "str",  # Optional. Prescription map Id.
                    "productCode": "str",  # Optional. Product Code.
                    "productName": "str",  # Optional. Product name.
                    "properties": {
                        "str": {}  # Optional. A collection of key value pairs that belongs
                          to the resource."nEach pair must not have a key greater than 50
                          characters"nand must not have a value greater than 150 characters."nNote: A
                          maximum of 25 key value pairs can be provided for a resource and only
                          string,"nnumeral and datetime (yyyy-MM-ddTHH:mm:ssZ) values are supported.
                    },
                    "source": "str",  # Optional. Source of the resource.
                    "status": "str",  # Optional. Status of the resource.
                    "type": "str"  # Optional. Prescription type.
                }
        """

    @distributed_trace
    def create_or_update(
        self, party_id: str, prescription_id: str, prescription: Union[JSON, IO], **kwargs: Any
    ) -> JSON:
        """Creates or Updates a prescription resource under a particular party.

        :param party_id: Id of the associated party resource. Required.
        :type party_id: str
        :param prescription_id: Id of the prescription resource. Required.
        :type prescription_id: str
        :param prescription: Prescription resource payload to create or update. Is either a model type
         or a IO type. Required.
        :type prescription: JSON or IO
        :keyword content_type: Body Parameter content-type. Known values are:
         'application/merge-patch+json'. Default value is None.
        :paramtype content_type: str
        :return: JSON object
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200, 201
                response == {
                    "createdBy": "str",  # Optional. Created by user/tenant id.
                    "createdDateTime": "2020-02-20 00:00:00",  # Optional. Date-time when
                      resource was created, sample format: yyyy-MM-ddTHH:mm:ssZ.
                    "description": "str",  # Optional. Textual description of the resource.
                    "eTag": "str",  # Optional. The ETag value to implement optimistic
                      concurrency.
                    "id": "str",  # Optional. Unique resource ID.
                    "measurements": {
                        "str": {
                            "unit": "str",  # Optional. Data unit.
                            "value": 0.0  # Optional. Data value.
                        }
                    },
                    "modifiedBy": "str",  # Optional. Modified by user/tenant id.
                    "modifiedDateTime": "2020-02-20 00:00:00",  # Optional. Date-time when
                      resource was last modified, sample format: yyyy-MM-ddTHH:mm:ssZ.
                    "name": "str",  # Optional. Name to identify resource.
                    "partyId": "str",  # Optional. Party Id.
                    "prescriptionMapId": "str",  # Optional. Prescription map Id.
                    "productCode": "str",  # Optional. Product Code.
                    "productName": "str",  # Optional. Product name.
                    "properties": {
                        "str": {}  # Optional. A collection of key value pairs that belongs
                          to the resource."nEach pair must not have a key greater than 50
                          characters"nand must not have a value greater than 150 characters."nNote: A
                          maximum of 25 key value pairs can be provided for a resource and only
                          string,"nnumeral and datetime (yyyy-MM-ddTHH:mm:ssZ) values are supported.
                    },
                    "source": "str",  # Optional. Source of the resource.
                    "status": "str",  # Optional. Status of the resource.
                    "type": "str"  # Optional. Prescription type.
                }
        """
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type = kwargs.pop("content_type", _headers.pop("Content-Type", None))  # type: Optional[str]
        cls = kwargs.pop("cls", None)  # type: ClsType[JSON]

        content_type = content_type or "application/merge-patch+json"
        _json = None
        _content = None
        if isinstance(prescription, (IO, bytes)):
            _content = prescription
        else:
            _json = prescription

        request = build_prescriptions_create_or_update_request(
            party_id=party_id,
            prescription_id=prescription_id,
            content_type=content_type,
            api_version=self._config.api_version,
            json=_json,
            content=_content,
            headers=_headers,
            params=_params,
        )
        request.url = self._client.format_url(request.url)  # type: ignore

        pipeline_response = self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
            request, stream=False, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200, 201]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if response.status_code == 200:
            if response.content:
                deserialized = response.json()
            else:
                deserialized = None

        if response.status_code == 201:
            if response.content:
                deserialized = response.json()
            else:
                deserialized = None

        if cls:
            return cls(pipeline_response, cast(JSON, deserialized), {})

        return cast(JSON, deserialized)

    @distributed_trace
    def delete(  # pylint: disable=inconsistent-return-statements
        self, party_id: str, prescription_id: str, **kwargs: Any
    ) -> None:
        """Deletes a specified prescription resource under a particular party.

        :param party_id: Id of the party. Required.
        :type party_id: str
        :param prescription_id: Id of the prescription. Required.
        :type prescription_id: str
        :return: None
        :rtype: None
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls = kwargs.pop("cls", None)  # type: ClsType[None]

        request = build_prescriptions_delete_request(
            party_id=party_id,
            prescription_id=prescription_id,
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        request.url = self._client.format_url(request.url)  # type: ignore

        pipeline_response = self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
            request, stream=False, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [204]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if cls:
            return cls(pipeline_response, None, {})

    @distributed_trace
    def list(
        self,
        *,
        prescription_map_ids: Optional[List[str]] = None,
        types: Optional[List[str]] = None,
        product_codes: Optional[List[str]] = None,
        product_names: Optional[List[str]] = None,
        sources: Optional[List[str]] = None,
        ids: Optional[List[str]] = None,
        names: Optional[List[str]] = None,
        property_filters: Optional[List[str]] = None,
        statuses: Optional[List[str]] = None,
        min_created_date_time: Optional[datetime.datetime] = None,
        max_created_date_time: Optional[datetime.datetime] = None,
        min_last_modified_date_time: Optional[datetime.datetime] = None,
        max_last_modified_date_time: Optional[datetime.datetime] = None,
        skip_token: Optional[str] = None,
        **kwargs: Any
    ) -> Iterable[JSON]:
        """Returns a paginated list of prescription resources across all parties.

        :keyword prescription_map_ids: Prescription Map Ids of the resource. Default value is None.
        :paramtype prescription_map_ids: list[str]
        :keyword types: Types of the resource. Default value is None.
        :paramtype types: list[str]
        :keyword product_codes: Product Codes of the resource. Default value is None.
        :paramtype product_codes: list[str]
        :keyword product_names: Product Names of the resource. Default value is None.
        :paramtype product_names: list[str]
        :keyword sources: Sources for the resource. Default value is None.
        :paramtype sources: list[str]
        :keyword ids: Ids of the resource. Default value is None.
        :paramtype ids: list[str]
        :keyword names: Names of the resource. Default value is None.
        :paramtype names: list[str]
        :keyword property_filters: Filters on key-value pairs within the Properties object.
         eg. "{testKey} eq {testValue}". Default value is None.
        :paramtype property_filters: list[str]
        :keyword statuses: Statuses of the resource. Default value is None.
        :paramtype statuses: list[str]
        :keyword min_created_date_time: Minimum creation date of resource (inclusive). Default value is
         None.
        :paramtype min_created_date_time: ~datetime.datetime
        :keyword max_created_date_time: Maximum creation date of resource (inclusive). Default value is
         None.
        :paramtype max_created_date_time: ~datetime.datetime
        :keyword min_last_modified_date_time: Minimum last modified date of resource (inclusive).
         Default value is None.
        :paramtype min_last_modified_date_time: ~datetime.datetime
        :keyword max_last_modified_date_time: Maximum last modified date of resource (inclusive).
         Default value is None.
        :paramtype max_last_modified_date_time: ~datetime.datetime
        :keyword skip_token: Skip token for getting next set of results. Default value is None.
        :paramtype skip_token: str
        :return: An iterator like instance of JSON object
        :rtype: ~azure.core.paging.ItemPaged[JSON]
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "createdBy": "str",  # Optional. Created by user/tenant id.
                    "createdDateTime": "2020-02-20 00:00:00",  # Optional. Date-time when
                      resource was created, sample format: yyyy-MM-ddTHH:mm:ssZ.
                    "description": "str",  # Optional. Textual description of the resource.
                    "eTag": "str",  # Optional. The ETag value to implement optimistic
                      concurrency.
                    "id": "str",  # Optional. Unique resource ID.
                    "measurements": {
                        "str": {
                            "unit": "str",  # Optional. Data unit.
                            "value": 0.0  # Optional. Data value.
                        }
                    },
                    "modifiedBy": "str",  # Optional. Modified by user/tenant id.
                    "modifiedDateTime": "2020-02-20 00:00:00",  # Optional. Date-time when
                      resource was last modified, sample format: yyyy-MM-ddTHH:mm:ssZ.
                    "name": "str",  # Optional. Name to identify resource.
                    "partyId": "str",  # Optional. Party Id.
                    "prescriptionMapId": "str",  # Optional. Prescription map Id.
                    "productCode": "str",  # Optional. Product Code.
                    "productName": "str",  # Optional. Product name.
                    "properties": {
                        "str": {}  # Optional. A collection of key value pairs that belongs
                          to the resource."nEach pair must not have a key greater than 50
                          characters"nand must not have a value greater than 150 characters."nNote: A
                          maximum of 25 key value pairs can be provided for a resource and only
                          string,"nnumeral and datetime (yyyy-MM-ddTHH:mm:ssZ) values are supported.
                    },
                    "source": "str",  # Optional. Source of the resource.
                    "status": "str",  # Optional. Status of the resource.
                    "type": "str"  # Optional. Prescription type.
                }
        """
        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls = kwargs.pop("cls", None)  # type: ClsType[JSON]

        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        def prepare_request(next_link=None):
            if not next_link:

                request = build_prescriptions_list_request(
                    prescription_map_ids=prescription_map_ids,
                    types=types,
                    product_codes=product_codes,
                    product_names=product_names,
                    sources=sources,
                    ids=ids,
                    names=names,
                    property_filters=property_filters,
                    statuses=statuses,
                    min_created_date_time=min_created_date_time,
                    max_created_date_time=max_created_date_time,
                    min_last_modified_date_time=min_last_modified_date_time,
                    max_last_modified_date_time=max_last_modified_date_time,
                    skip_token=skip_token,
                    api_version=self._config.api_version,
                    headers=_headers,
                    params=_params,
                )
                request.url = self._client.format_url(request.url)  # type: ignore

            else:
                # make call to next link with the client's api-version
                _parsed_next_link = urlparse(next_link)
                _next_request_params = case_insensitive_dict(parse_qs(_parsed_next_link.query))
                _next_request_params["api-version"] = self._config.api_version
                request = HttpRequest("GET", urljoin(next_link, _parsed_next_link.path), params=_next_request_params)
                request.url = self._client.format_url(request.url)  # type: ignore

            return request

        def extract_data(pipeline_response):
            deserialized = pipeline_response.http_response.json()
            list_of_elem = deserialized["value"]
            if cls:
                list_of_elem = cls(list_of_elem)
            return deserialized.get("nextLink", None), iter(list_of_elem)

        def get_next(next_link=None):
            request = prepare_request(next_link)

            pipeline_response = self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
                request, stream=False, **kwargs
            )
            response = pipeline_response.http_response

            if response.status_code not in [200]:
                map_error(status_code=response.status_code, response=response, error_map=error_map)
                raise HttpResponseError(response=response)

            return pipeline_response

        return ItemPaged(get_next, extract_data)

    @distributed_trace
    def get_cascade_delete_job_details(self, job_id: str, **kwargs: Any) -> JSON:
        """Get a cascade delete job for specified prescription.

        :param job_id: Id of the job. Required.
        :type job_id: str
        :return: JSON object
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "partyId": "str",  # Party Id. Required.
                    "resourceId": "str",  # The id of the resource. Required.
                    "resourceType": "str",  # The type of the resource. Required.
                    "createdDateTime": "2020-02-20 00:00:00",  # Optional. Job created at
                      dateTime. Sample format: yyyy-MM-ddTHH:mm:ssZ.
                    "durationInSeconds": 0.0,  # Optional. Duration of the job in seconds.
                    "endTime": "2020-02-20 00:00:00",  # Optional. Job end time when available.
                      Sample format: yyyy-MM-ddTHH:mm:ssZ.
                    "errorCode": "str",  # Optional. Error Code when job failed.
                    "id": "str",  # Optional. Unique job id.
                    "lastActionDateTime": "2020-02-20 00:00:00",  # Optional. Job was last acted
                      upon at dateTime. Sample format: yyyy-MM-ddTHH:mm:ssZ.
                    "message": "str",  # Optional. Status message to capture more details of the
                      job.
                    "startTime": "2020-02-20 00:00:00",  # Optional. Job start time when
                      available. Sample format: yyyy-MM-ddTHH:mm:ssZ.
                    "status": "str"  # Optional. Status of the job."nPossible values: 'Waiting',
                      'Running', 'Succeeded', 'Failed', 'Cancelled'. Known values are: "Waiting",
                      "Running", "Succeeded", "Failed", and "Cancelled".
                }
        """
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls = kwargs.pop("cls", None)  # type: ClsType[JSON]

        request = build_prescriptions_get_cascade_delete_job_details_request(
            job_id=job_id,
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        request.url = self._client.format_url(request.url)  # type: ignore

        pipeline_response = self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
            request, stream=False, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if response.content:
            deserialized = response.json()
        else:
            deserialized = None

        if cls:
            return cls(pipeline_response, cast(JSON, deserialized), {})

        return cast(JSON, deserialized)

    def _create_cascade_delete_job_initial(
        self, job_id: str, *, party_id: str, prescription_id: str, **kwargs: Any
    ) -> JSON:
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls = kwargs.pop("cls", None)  # type: ClsType[JSON]

        request = build_prescriptions_create_cascade_delete_job_request(
            job_id=job_id,
            party_id=party_id,
            prescription_id=prescription_id,
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        request.url = self._client.format_url(request.url)  # type: ignore

        pipeline_response = self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
            request, stream=False, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [202]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if response.content:
            deserialized = response.json()
        else:
            deserialized = None

        if cls:
            return cls(pipeline_response, cast(JSON, deserialized), {})

        return cast(JSON, deserialized)

    @distributed_trace
    def begin_create_cascade_delete_job(
        self, job_id: str, *, party_id: str, prescription_id: str, **kwargs: Any
    ) -> LROPoller[JSON]:
        """Create a cascade delete job for specified prescription.

        :param job_id: Job ID supplied by end user. Required.
        :type job_id: str
        :keyword party_id: ID of the associated party. Required.
        :paramtype party_id: str
        :keyword prescription_id: ID of the prescription to be deleted. Required.
        :paramtype prescription_id: str
        :keyword str continuation_token: A continuation token to restart a poller from a saved state.
        :keyword polling: By default, your polling method will be LROBasePolling. Pass in False for
         this operation to not poll, or pass in your own initialized polling object for a personal
         polling strategy.
        :paramtype polling: bool or ~azure.core.polling.PollingMethod
        :keyword int polling_interval: Default waiting time between two polls for LRO operations if no
         Retry-After header is present.
        :return: An instance of LROPoller that returns JSON object
        :rtype: ~azure.core.polling.LROPoller[JSON]
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 202
                response == {
                    "partyId": "str",  # Party Id. Required.
                    "resourceId": "str",  # The id of the resource. Required.
                    "resourceType": "str",  # The type of the resource. Required.
                    "createdDateTime": "2020-02-20 00:00:00",  # Optional. Job created at
                      dateTime. Sample format: yyyy-MM-ddTHH:mm:ssZ.
                    "durationInSeconds": 0.0,  # Optional. Duration of the job in seconds.
                    "endTime": "2020-02-20 00:00:00",  # Optional. Job end time when available.
                      Sample format: yyyy-MM-ddTHH:mm:ssZ.
                    "errorCode": "str",  # Optional. Error Code when job failed.
                    "id": "str",  # Optional. Unique job id.
                    "lastActionDateTime": "2020-02-20 00:00:00",  # Optional. Job was last acted
                      upon at dateTime. Sample format: yyyy-MM-ddTHH:mm:ssZ.
                    "message": "str",  # Optional. Status message to capture more details of the
                      job.
                    "startTime": "2020-02-20 00:00:00",  # Optional. Job start time when
                      available. Sample format: yyyy-MM-ddTHH:mm:ssZ.
                    "status": "str"  # Optional. Status of the job."nPossible values: 'Waiting',
                      'Running', 'Succeeded', 'Failed', 'Cancelled'. Known values are: "Waiting",
                      "Running", "Succeeded", "Failed", and "Cancelled".
                }
        """
        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls = kwargs.pop("cls", None)  # type: ClsType[JSON]
        polling = kwargs.pop("polling", True)  # type: Union[bool, PollingMethod]
        lro_delay = kwargs.pop("polling_interval", self._config.polling_interval)
        cont_token = kwargs.pop("continuation_token", None)  # type: Optional[str]
        if cont_token is None:
            raw_result = self._create_cascade_delete_job_initial(  # type: ignore
                job_id=job_id,
                party_id=party_id,
                prescription_id=prescription_id,
                cls=lambda x, y, z: x,
                headers=_headers,
                params=_params,
                **kwargs
            )
        kwargs.pop("error_map", None)

        def get_long_running_output(pipeline_response):
            response = pipeline_response.http_response
            if response.content:
                deserialized = response.json()
            else:
                deserialized = None
            if cls:
                return cls(pipeline_response, deserialized, {})
            return deserialized

        if polling is True:
            polling_method = cast(
                PollingMethod, LROBasePolling(lro_delay, lro_options={"final-state-via": "location"}, **kwargs)
            )  # type: PollingMethod
        elif polling is False:
            polling_method = cast(PollingMethod, NoPolling())
        else:
            polling_method = polling
        if cont_token:
            return LROPoller.from_continuation_token(
                polling_method=polling_method,
                continuation_token=cont_token,
                client=self._client,
                deserialization_callback=get_long_running_output,
            )
        return LROPoller(self._client, raw_result, get_long_running_output, polling_method)


class ScenesOperations:
    """
    .. warning::
        **DO NOT** instantiate this class directly.

        Instead, you should access the following operations through
        :class:`~azure.agrifood.farming.FarmBeatsClient`'s
        :attr:`scenes` attribute.
    """

    def __init__(self, *args, **kwargs):
        input_args = list(args)
        self._client = input_args.pop(0) if input_args else kwargs.pop("client")
        self._config = input_args.pop(0) if input_args else kwargs.pop("config")
        self._serialize = input_args.pop(0) if input_args else kwargs.pop("serializer")
        self._deserialize = input_args.pop(0) if input_args else kwargs.pop("deserializer")

    @distributed_trace
    def list(
        self,
        *,
        provider: str,
        party_id: str,
        boundary_id: str,
        source: str,
        start_date_time: Optional[datetime.datetime] = None,
        end_date_time: Optional[datetime.datetime] = None,
        max_cloud_coverage_percentage: float = 100,
        max_dark_pixel_coverage_percentage: float = 100,
        image_names: Optional[List[str]] = None,
        image_resolutions: Optional[List[float]] = None,
        image_formats: Optional[List[str]] = None,
        skip_token: Optional[str] = None,
        **kwargs: Any
    ) -> Iterable[JSON]:
        """Returns a paginated list of scene resources.

        :keyword provider: Provider name of scene data. Required.
        :paramtype provider: str
        :keyword party_id: PartyId. Required.
        :paramtype party_id: str
        :keyword boundary_id: BoundaryId. Required.
        :paramtype boundary_id: str
        :keyword source: Source name of scene data, Available Values: Sentinel_2_L2A, Sentinel_2_L1C.
         Required.
        :paramtype source: str
        :keyword start_date_time: Scene start UTC datetime (inclusive), sample format:
         yyyy-MM-ddThh:mm:ssZ. Default value is None.
        :paramtype start_date_time: ~datetime.datetime
        :keyword end_date_time: Scene end UTC datetime (inclusive), sample format: yyyy-MM-dThh:mm:ssZ.
         Default value is None.
        :paramtype end_date_time: ~datetime.datetime
        :keyword max_cloud_coverage_percentage: Filter scenes with cloud coverage percentage less than
         max value. Range [0 to 100.0]. Default value is 100.
        :paramtype max_cloud_coverage_percentage: float
        :keyword max_dark_pixel_coverage_percentage: Filter scenes with dark pixel coverage percentage
         less than max value. Range [0 to 100.0]. Default value is 100.
        :paramtype max_dark_pixel_coverage_percentage: float
        :keyword image_names: List of image names to be filtered. Default value is None.
        :paramtype image_names: list[str]
        :keyword image_resolutions: List of image resolutions in meters to be filtered. Default value
         is None.
        :paramtype image_resolutions: list[float]
        :keyword image_formats: List of image formats to be filtered. Default value is None.
        :paramtype image_formats: list[str]
        :keyword skip_token: Skip token for getting next set of results. Default value is None.
        :paramtype skip_token: str
        :return: An iterator like instance of JSON object
        :rtype: ~azure.core.paging.ItemPaged[JSON]
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "boundaryId": "str",  # Optional. Boundary ID which belongs to the scene.
                    "cloudCoverPercentage": 0.0,  # Optional. Cloud cover percentage of the
                      scene.
                    "darkPixelPercentage": 0.0,  # Optional. Dark pixel percentage of the scene.
                    "eTag": "str",  # Optional. The ETag value to implement optimistic
                      concurrency.
                    "id": "str",  # Optional. Unique scene resource ID.
                    "imageFiles": [
                        {
                            "name": "str",  # Name of the image file. Required.
                            "fileLink": "str",  # Optional. Link of the image file.
                            "imageFormat": "str",  # Optional. ImageFormat. Available
                              value: TIF. "TIF"
                            "resolution": 0.0  # Optional. Resolution of image file in
                              meters.
                        }
                    ],
                    "imageFormat": "str",  # Optional. ImageFormat. Available value: TIF. "TIF"
                    "ndviMedianValue": 0.0,  # Optional. Median of NDVI of the scene.
                    "partyId": "str",  # Optional. Party ID which belongs to the scene.
                    "provider": "str",  # Optional. Data provider of the scene.
                    "sceneDateTime": "2020-02-20 00:00:00",  # Optional. Date-time of the scene,
                      sample format: yyyy-MM-ddTHH:mm:ssZ.
                    "source": "str"  # Optional. Data source of the scene.
                }
        """
        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls = kwargs.pop("cls", None)  # type: ClsType[JSON]

        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        def prepare_request(next_link=None):
            if not next_link:

                request = build_scenes_list_request(
                    provider=provider,
                    party_id=party_id,
                    boundary_id=boundary_id,
                    source=source,
                    start_date_time=start_date_time,
                    end_date_time=end_date_time,
                    max_cloud_coverage_percentage=max_cloud_coverage_percentage,
                    max_dark_pixel_coverage_percentage=max_dark_pixel_coverage_percentage,
                    image_names=image_names,
                    image_resolutions=image_resolutions,
                    image_formats=image_formats,
                    skip_token=skip_token,
                    api_version=self._config.api_version,
                    headers=_headers,
                    params=_params,
                )
                request.url = self._client.format_url(request.url)  # type: ignore

            else:
                # make call to next link with the client's api-version
                _parsed_next_link = urlparse(next_link)
                _next_request_params = case_insensitive_dict(parse_qs(_parsed_next_link.query))
                _next_request_params["api-version"] = self._config.api_version
                request = HttpRequest("GET", urljoin(next_link, _parsed_next_link.path), params=_next_request_params)
                request.url = self._client.format_url(request.url)  # type: ignore

            return request

        def extract_data(pipeline_response):
            deserialized = pipeline_response.http_response.json()
            list_of_elem = deserialized["value"]
            if cls:
                list_of_elem = cls(list_of_elem)
            return deserialized.get("nextLink", None), iter(list_of_elem)

        def get_next(next_link=None):
            request = prepare_request(next_link)

            pipeline_response = self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
                request, stream=False, **kwargs
            )
            response = pipeline_response.http_response

            if response.status_code not in [200]:
                map_error(status_code=response.status_code, response=response, error_map=error_map)
                raise HttpResponseError(response=response)

            return pipeline_response

        return ItemPaged(get_next, extract_data)

    @distributed_trace
    def download(self, *, file_path: str, **kwargs: Any) -> Iterator[bytes]:
        """Downloads and returns file Stream as response for the given input filePath.

        :keyword file_path: cloud storage path of scene file. Required.
        :paramtype file_path: str
        :return: Iterator of the response bytes
        :rtype: Iterator[bytes]
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls = kwargs.pop("cls", None)  # type: ClsType[Iterator[bytes]]

        request = build_scenes_download_request(
            file_path=file_path,
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        request.url = self._client.format_url(request.url)  # type: ignore

        pipeline_response = self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
            request, stream=True, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        deserialized = response.iter_bytes()

        if cls:
            return cls(pipeline_response, cast(Iterator[bytes], deserialized), {})

        return cast(Iterator[bytes], deserialized)

    def _create_satellite_data_ingestion_job_initial(self, job_id: str, job: Union[JSON, IO], **kwargs: Any) -> JSON:
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type = kwargs.pop("content_type", _headers.pop("Content-Type", None))  # type: Optional[str]
        cls = kwargs.pop("cls", None)  # type: ClsType[JSON]

        content_type = content_type or "application/json"
        _json = None
        _content = None
        if isinstance(job, (IO, bytes)):
            _content = job
        else:
            _json = job

        request = build_scenes_create_satellite_data_ingestion_job_request(
            job_id=job_id,
            content_type=content_type,
            api_version=self._config.api_version,
            json=_json,
            content=_content,
            headers=_headers,
            params=_params,
        )
        request.url = self._client.format_url(request.url)  # type: ignore

        pipeline_response = self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
            request, stream=False, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [202]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if response.content:
            deserialized = response.json()
        else:
            deserialized = None

        if cls:
            return cls(pipeline_response, cast(JSON, deserialized), {})

        return cast(JSON, deserialized)

    @overload
    def begin_create_satellite_data_ingestion_job(
        self, job_id: str, job: JSON, *, content_type: str = "application/json", **kwargs: Any
    ) -> LROPoller[JSON]:
        """Create a satellite data ingestion job.

        :param job_id: JobId provided by user. Required.
        :type job_id: str
        :param job: Job parameters supplied by user. Required.
        :type job: JSON
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :keyword str continuation_token: A continuation token to restart a poller from a saved state.
        :keyword polling: By default, your polling method will be LROBasePolling. Pass in False for
         this operation to not poll, or pass in your own initialized polling object for a personal
         polling strategy.
        :paramtype polling: bool or ~azure.core.polling.PollingMethod
        :keyword int polling_interval: Default waiting time between two polls for LRO operations if no
         Retry-After header is present.
        :return: An instance of LROPoller that returns JSON object
        :rtype: ~azure.core.polling.LROPoller[JSON]
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                job = {
                    "boundaryId": "str",  # The id of the boundary object for which satellite
                      data is being fetched. Required.
                    "endDateTime": "2020-02-20 00:00:00",  # End Date. Required.
                    "partyId": "str",  # Party Id. Required.
                    "source": "str",  # Source of satellite data. Available Value:
                      Sentinel_2_L2A. Required. Known values are: "Sentinel_2_L2A" and
                      "Sentinel_2_L1C".
                    "startDateTime": "2020-02-20 00:00:00",  # Start Date. Required.
                    "createdBy": "str",  # Optional. Created by user/tenant id.
                    "createdDateTime": "2020-02-20 00:00:00",  # Optional. Job created at
                      dateTime. Sample format: yyyy-MM-ddTHH:mm:ssZ.
                    "data": {
                        "imageFormats": [
                            "str"  # Optional. List of ImageFormats. Available value:
                              TIF.
                        ],
                        "imageNames": [
                            "str"  # Optional. List of ImageNames.
                        ],
                        "imageResolutions": [
                            0.0  # Optional. List of ImageResolutions in meters.
                              Available values: 10, 20, 60.
                        ]
                    },
                    "description": "str",  # Optional. Textual description of the resource.
                    "durationInSeconds": 0.0,  # Optional. Duration of the job in seconds.
                    "endTime": "2020-02-20 00:00:00",  # Optional. Job end time when available.
                      Sample format: yyyy-MM-ddTHH:mm:ssZ.
                    "errorCode": "str",  # Optional. Error Code when job failed.
                    "id": "str",  # Optional. Unique job id.
                    "lastActionDateTime": "2020-02-20 00:00:00",  # Optional. Job was last acted
                      upon at dateTime. Sample format: yyyy-MM-ddTHH:mm:ssZ.
                    "message": "str",  # Optional. Status message to capture more details of the
                      job.
                    "modifiedBy": "str",  # Optional. Modified by user/tenant id.
                    "name": "str",  # Optional. Name to identify resource.
                    "properties": {
                        "str": {}  # Optional. A collection of key value pairs that belongs
                          to the resource."nEach pair must not have a key greater than 50
                          characters"nand must not have a value greater than 150 characters."nNote: A
                          maximum of 25 key value pairs can be provided for a resource and only
                          string,"nnumeral and datetime (yyyy-MM-ddTHH:mm:ssZ) values are supported.
                    },
                    "provider": "str",  # Optional. Provider of satellite data. Available Value:
                      Microsoft. "Microsoft"
                    "startTime": "2020-02-20 00:00:00",  # Optional. Job start time when
                      available. Sample format: yyyy-MM-ddTHH:mm:ssZ.
                    "status": "str"  # Optional. Status of the job."nPossible values: 'Waiting',
                      'Running', 'Succeeded', 'Failed', 'Cancelled'.
                }

                # response body for status code(s): 202
                response == {
                    "boundaryId": "str",  # The id of the boundary object for which satellite
                      data is being fetched. Required.
                    "endDateTime": "2020-02-20 00:00:00",  # End Date. Required.
                    "partyId": "str",  # Party Id. Required.
                    "source": "str",  # Source of satellite data. Available Value:
                      Sentinel_2_L2A. Required. Known values are: "Sentinel_2_L2A" and
                      "Sentinel_2_L1C".
                    "startDateTime": "2020-02-20 00:00:00",  # Start Date. Required.
                    "createdBy": "str",  # Optional. Created by user/tenant id.
                    "createdDateTime": "2020-02-20 00:00:00",  # Optional. Job created at
                      dateTime. Sample format: yyyy-MM-ddTHH:mm:ssZ.
                    "data": {
                        "imageFormats": [
                            "str"  # Optional. List of ImageFormats. Available value:
                              TIF.
                        ],
                        "imageNames": [
                            "str"  # Optional. List of ImageNames.
                        ],
                        "imageResolutions": [
                            0.0  # Optional. List of ImageResolutions in meters.
                              Available values: 10, 20, 60.
                        ]
                    },
                    "description": "str",  # Optional. Textual description of the resource.
                    "durationInSeconds": 0.0,  # Optional. Duration of the job in seconds.
                    "endTime": "2020-02-20 00:00:00",  # Optional. Job end time when available.
                      Sample format: yyyy-MM-ddTHH:mm:ssZ.
                    "errorCode": "str",  # Optional. Error Code when job failed.
                    "id": "str",  # Optional. Unique job id.
                    "lastActionDateTime": "2020-02-20 00:00:00",  # Optional. Job was last acted
                      upon at dateTime. Sample format: yyyy-MM-ddTHH:mm:ssZ.
                    "message": "str",  # Optional. Status message to capture more details of the
                      job.
                    "modifiedBy": "str",  # Optional. Modified by user/tenant id.
                    "name": "str",  # Optional. Name to identify resource.
                    "properties": {
                        "str": {}  # Optional. A collection of key value pairs that belongs
                          to the resource."nEach pair must not have a key greater than 50
                          characters"nand must not have a value greater than 150 characters."nNote: A
                          maximum of 25 key value pairs can be provided for a resource and only
                          string,"nnumeral and datetime (yyyy-MM-ddTHH:mm:ssZ) values are supported.
                    },
                    "provider": "str",  # Optional. Provider of satellite data. Available Value:
                      Microsoft. "Microsoft"
                    "startTime": "2020-02-20 00:00:00",  # Optional. Job start time when
                      available. Sample format: yyyy-MM-ddTHH:mm:ssZ.
                    "status": "str"  # Optional. Status of the job."nPossible values: 'Waiting',
                      'Running', 'Succeeded', 'Failed', 'Cancelled'.
                }
        """

    @overload
    def begin_create_satellite_data_ingestion_job(
        self, job_id: str, job: IO, *, content_type: str = "application/json", **kwargs: Any
    ) -> LROPoller[JSON]:
        """Create a satellite data ingestion job.

        :param job_id: JobId provided by user. Required.
        :type job_id: str
        :param job: Job parameters supplied by user. Required.
        :type job: IO
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Default value is "application/json".
        :paramtype content_type: str
        :keyword str continuation_token: A continuation token to restart a poller from a saved state.
        :keyword polling: By default, your polling method will be LROBasePolling. Pass in False for
         this operation to not poll, or pass in your own initialized polling object for a personal
         polling strategy.
        :paramtype polling: bool or ~azure.core.polling.PollingMethod
        :keyword int polling_interval: Default waiting time between two polls for LRO operations if no
         Retry-After header is present.
        :return: An instance of LROPoller that returns JSON object
        :rtype: ~azure.core.polling.LROPoller[JSON]
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 202
                response == {
                    "boundaryId": "str",  # The id of the boundary object for which satellite
                      data is being fetched. Required.
                    "endDateTime": "2020-02-20 00:00:00",  # End Date. Required.
                    "partyId": "str",  # Party Id. Required.
                    "source": "str",  # Source of satellite data. Available Value:
                      Sentinel_2_L2A. Required. Known values are: "Sentinel_2_L2A" and
                      "Sentinel_2_L1C".
                    "startDateTime": "2020-02-20 00:00:00",  # Start Date. Required.
                    "createdBy": "str",  # Optional. Created by user/tenant id.
                    "createdDateTime": "2020-02-20 00:00:00",  # Optional. Job created at
                      dateTime. Sample format: yyyy-MM-ddTHH:mm:ssZ.
                    "data": {
                        "imageFormats": [
                            "str"  # Optional. List of ImageFormats. Available value:
                              TIF.
                        ],
                        "imageNames": [
                            "str"  # Optional. List of ImageNames.
                        ],
                        "imageResolutions": [
                            0.0  # Optional. List of ImageResolutions in meters.
                              Available values: 10, 20, 60.
                        ]
                    },
                    "description": "str",  # Optional. Textual description of the resource.
                    "durationInSeconds": 0.0,  # Optional. Duration of the job in seconds.
                    "endTime": "2020-02-20 00:00:00",  # Optional. Job end time when available.
                      Sample format: yyyy-MM-ddTHH:mm:ssZ.
                    "errorCode": "str",  # Optional. Error Code when job failed.
                    "id": "str",  # Optional. Unique job id.
                    "lastActionDateTime": "2020-02-20 00:00:00",  # Optional. Job was last acted
                      upon at dateTime. Sample format: yyyy-MM-ddTHH:mm:ssZ.
                    "message": "str",  # Optional. Status message to capture more details of the
                      job.
                    "modifiedBy": "str",  # Optional. Modified by user/tenant id.
                    "name": "str",  # Optional. Name to identify resource.
                    "properties": {
                        "str": {}  # Optional. A collection of key value pairs that belongs
                          to the resource."nEach pair must not have a key greater than 50
                          characters"nand must not have a value greater than 150 characters."nNote: A
                          maximum of 25 key value pairs can be provided for a resource and only
                          string,"nnumeral and datetime (yyyy-MM-ddTHH:mm:ssZ) values are supported.
                    },
                    "provider": "str",  # Optional. Provider of satellite data. Available Value:
                      Microsoft. "Microsoft"
                    "startTime": "2020-02-20 00:00:00",  # Optional. Job start time when
                      available. Sample format: yyyy-MM-ddTHH:mm:ssZ.
                    "status": "str"  # Optional. Status of the job."nPossible values: 'Waiting',
                      'Running', 'Succeeded', 'Failed', 'Cancelled'.
                }
        """

    @distributed_trace
    def begin_create_satellite_data_ingestion_job(
        self, job_id: str, job: Union[JSON, IO], **kwargs: Any
    ) -> LROPoller[JSON]:
        """Create a satellite data ingestion job.

        :param job_id: JobId provided by user. Required.
        :type job_id: str
        :param job: Job parameters supplied by user. Is either a model type or a IO type. Required.
        :type job: JSON or IO
        :keyword content_type: Body Parameter content-type. Known values are: 'application/json'.
         Default value is None.
        :paramtype content_type: str
        :keyword str continuation_token: A continuation token to restart a poller from a saved state.
        :keyword polling: By default, your polling method will be LROBasePolling. Pass in False for
         this operation to not poll, or pass in your own initialized polling object for a personal
         polling strategy.
        :paramtype polling: bool or ~azure.core.polling.PollingMethod
        :keyword int polling_interval: Default waiting time between two polls for LRO operations if no
         Retry-After header is present.
        :return: An instance of LROPoller that returns JSON object
        :rtype: ~azure.core.polling.LROPoller[JSON]
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 202
                response == {
                    "boundaryId": "str",  # The id of the boundary object for which satellite
                      data is being fetched. Required.
                    "endDateTime": "2020-02-20 00:00:00",  # End Date. Required.
                    "partyId": "str",  # Party Id. Required.
                    "source": "str",  # Source of satellite data. Available Value:
                      Sentinel_2_L2A. Required. Known values are: "Sentinel_2_L2A" and
                      "Sentinel_2_L1C".
                    "startDateTime": "2020-02-20 00:00:00",  # Start Date. Required.
                    "createdBy": "str",  # Optional. Created by user/tenant id.
                    "createdDateTime": "2020-02-20 00:00:00",  # Optional. Job created at
                      dateTime. Sample format: yyyy-MM-ddTHH:mm:ssZ.
                    "data": {
                        "imageFormats": [
                            "str"  # Optional. List of ImageFormats. Available value:
                              TIF.
                        ],
                        "imageNames": [
                            "str"  # Optional. List of ImageNames.
                        ],
                        "imageResolutions": [
                            0.0  # Optional. List of ImageResolutions in meters.
                              Available values: 10, 20, 60.
                        ]
                    },
                    "description": "str",  # Optional. Textual description of the resource.
                    "durationInSeconds": 0.0,  # Optional. Duration of the job in seconds.
                    "endTime": "2020-02-20 00:00:00",  # Optional. Job end time when available.
                      Sample format: yyyy-MM-ddTHH:mm:ssZ.
                    "errorCode": "str",  # Optional. Error Code when job failed.
                    "id": "str",  # Optional. Unique job id.
                    "lastActionDateTime": "2020-02-20 00:00:00",  # Optional. Job was last acted
                      upon at dateTime. Sample format: yyyy-MM-ddTHH:mm:ssZ.
                    "message": "str",  # Optional. Status message to capture more details of the
                      job.
                    "modifiedBy": "str",  # Optional. Modified by user/tenant id.
                    "name": "str",  # Optional. Name to identify resource.
                    "properties": {
                        "str": {}  # Optional. A collection of key value pairs that belongs
                          to the resource."nEach pair must not have a key greater than 50
                          characters"nand must not have a value greater than 150 characters."nNote: A
                          maximum of 25 key value pairs can be provided for a resource and only
                          string,"nnumeral and datetime (yyyy-MM-ddTHH:mm:ssZ) values are supported.
                    },
                    "provider": "str",  # Optional. Provider of satellite data. Available Value:
                      Microsoft. "Microsoft"
                    "startTime": "2020-02-20 00:00:00",  # Optional. Job start time when
                      available. Sample format: yyyy-MM-ddTHH:mm:ssZ.
                    "status": "str"  # Optional. Status of the job."nPossible values: 'Waiting',
                      'Running', 'Succeeded', 'Failed', 'Cancelled'.
                }
        """
        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type = kwargs.pop("content_type", _headers.pop("Content-Type", None))  # type: Optional[str]
        cls = kwargs.pop("cls", None)  # type: ClsType[JSON]
        polling = kwargs.pop("polling", True)  # type: Union[bool, PollingMethod]
        lro_delay = kwargs.pop("polling_interval", self._config.polling_interval)
        cont_token = kwargs.pop("continuation_token", None)  # type: Optional[str]
        if cont_token is None:
            raw_result = self._create_satellite_data_ingestion_job_initial(  # type: ignore
                job_id=job_id,
                job=job,
                content_type=content_type,
                cls=lambda x, y, z: x,
                headers=_headers,
                params=_params,
                **kwargs
            )
        kwargs.pop("error_map", None)

        def get_long_running_output(pipeline_response):
            response = pipeline_response.http_response
            if response.content:
                deserialized = response.json()
            else:
                deserialized = None
            if cls:
                return cls(pipeline_response, deserialized, {})
            return deserialized

        if polling is True:
            polling_method = cast(
                PollingMethod, LROBasePolling(lro_delay, lro_options={"final-state-via": "location"}, **kwargs)
            )  # type: PollingMethod
        elif polling is False:
            polling_method = cast(PollingMethod, NoPolling())
        else:
            polling_method = polling
        if cont_token:
            return LROPoller.from_continuation_token(
                polling_method=polling_method,
                continuation_token=cont_token,
                client=self._client,
                deserialization_callback=get_long_running_output,
            )
        return LROPoller(self._client, raw_result, get_long_running_output, polling_method)

    @distributed_trace
    def get_satellite_data_ingestion_job_details(self, job_id: str, **kwargs: Any) -> JSON:
        """Get a satellite data ingestion job.

        :param job_id: Id of the job. Required.
        :type job_id: str
        :return: JSON object
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "boundaryId": "str",  # The id of the boundary object for which satellite
                      data is being fetched. Required.
                    "endDateTime": "2020-02-20 00:00:00",  # End Date. Required.
                    "partyId": "str",  # Party Id. Required.
                    "source": "str",  # Source of satellite data. Available Value:
                      Sentinel_2_L2A. Required. Known values are: "Sentinel_2_L2A" and
                      "Sentinel_2_L1C".
                    "startDateTime": "2020-02-20 00:00:00",  # Start Date. Required.
                    "createdBy": "str",  # Optional. Created by user/tenant id.
                    "createdDateTime": "2020-02-20 00:00:00",  # Optional. Job created at
                      dateTime. Sample format: yyyy-MM-ddTHH:mm:ssZ.
                    "data": {
                        "imageFormats": [
                            "str"  # Optional. List of ImageFormats. Available value:
                              TIF.
                        ],
                        "imageNames": [
                            "str"  # Optional. List of ImageNames.
                        ],
                        "imageResolutions": [
                            0.0  # Optional. List of ImageResolutions in meters.
                              Available values: 10, 20, 60.
                        ]
                    },
                    "description": "str",  # Optional. Textual description of the resource.
                    "durationInSeconds": 0.0,  # Optional. Duration of the job in seconds.
                    "endTime": "2020-02-20 00:00:00",  # Optional. Job end time when available.
                      Sample format: yyyy-MM-ddTHH:mm:ssZ.
                    "errorCode": "str",  # Optional. Error Code when job failed.
                    "id": "str",  # Optional. Unique job id.
                    "lastActionDateTime": "2020-02-20 00:00:00",  # Optional. Job was last acted
                      upon at dateTime. Sample format: yyyy-MM-ddTHH:mm:ssZ.
                    "message": "str",  # Optional. Status message to capture more details of the
                      job.
                    "modifiedBy": "str",  # Optional. Modified by user/tenant id.
                    "name": "str",  # Optional. Name to identify resource.
                    "properties": {
                        "str": {}  # Optional. A collection of key value pairs that belongs
                          to the resource."nEach pair must not have a key greater than 50
                          characters"nand must not have a value greater than 150 characters."nNote: A
                          maximum of 25 key value pairs can be provided for a resource and only
                          string,"nnumeral and datetime (yyyy-MM-ddTHH:mm:ssZ) values are supported.
                    },
                    "provider": "str",  # Optional. Provider of satellite data. Available Value:
                      Microsoft. "Microsoft"
                    "startTime": "2020-02-20 00:00:00",  # Optional. Job start time when
                      available. Sample format: yyyy-MM-ddTHH:mm:ssZ.
                    "status": "str"  # Optional. Status of the job."nPossible values: 'Waiting',
                      'Running', 'Succeeded', 'Failed', 'Cancelled'.
                }
        """
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls = kwargs.pop("cls", None)  # type: ClsType[JSON]

        request = build_scenes_get_satellite_data_ingestion_job_details_request(
            job_id=job_id,
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        request.url = self._client.format_url(request.url)  # type: ignore

        pipeline_response = self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
            request, stream=False, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if response.content:
            deserialized = response.json()
        else:
            deserialized = None

        if cls:
            return cls(pipeline_response, cast(JSON, deserialized), {})

        return cast(JSON, deserialized)

    @overload
    def search_features(
        self,
        collection_id: str,
        search_features_query: JSON,
        *,
        maxpagesize: int = 10,
        skip: Optional[int] = None,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> JSON:
        """Search for STAC features by collection id, bbox, intersecting geometry, start and end datetime.

        :param collection_id: Collection Id to be searched. Known values are: "Sentinel_2_L2A" and
         "Sentinel_2_L1C". Required.
        :type collection_id: str
        :param search_features_query: Query filters. Required.
        :type search_features_query: JSON
        :keyword maxpagesize: Maximum number of features needed (inclusive). Minimum = 1, Maximum =
         100, Default value = 10. Default value is 10.
        :paramtype maxpagesize: int
        :keyword skip: Skip token for getting next set of results. Default value is None.
        :paramtype skip: int
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: JSON object
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # The input is polymorphic. The following are possible polymorphic inputs based off
                  discriminator "type":

                # JSON input template for discriminator value "MultiPolygon":
                geo_json_object = {
                    "coordinates": [
                        [
                            [
                                [
                                    0.0  # Gets or sets Coordinates of GeoJSON
                                      Object."nIt must be an array of polygons, each polygon contains
                                      list of linear rings."nFor Polygons with more than one of these
                                      rings, the first MUST be the exterior ring,"nand any others MUST
                                      be interior rings. Required.
                                ]
                            ]
                        ]
                    ],
                    "type": "MultiPolygon"
                }

                # JSON input template for discriminator value "Point":
                geo_json_object = {
                    "coordinates": [
                        0.0  # Gets or sets the coordinate of this point."nIt must be an
                          array of 2 or 3 elements for a 2D or 3D system. Required.
                    ],
                    "type": "Point"
                }

                # JSON input template for discriminator value "Polygon":
                geo_json_object = {
                    "coordinates": [
                        [
                            [
                                0.0  # Gets or sets type of the GeoJSON Object."nIt
                                  must be an array of linear ring coordinate arrays."nFor Polygons with
                                  more than one of these rings, the first MUST be the exterior
                                  ring,"nand any others MUST be interior rings. Required.
                            ]
                        ]
                    ],
                    "type": "Polygon"
                }

                # JSON input template you can fill out and use as your body input.
                search_features_query = {
                    "endDateTime": "2020-02-20 00:00:00",  # End datetime of the time interval in
                      which to search for Features. Required.
                    "startDateTime": "2020-02-20 00:00:00",  # Start datetime of the time
                      interval in which to search for Features. Required.
                    "bbox": [
                        0.0  # Optional. Only features that have a geometry that intersects
                          the bounding box are selected."nThe bounding box is provided as four numbers.
                          The coordinate reference system of the values is WGS84 longitude/latitude.
                    ],
                    "featureIds": [
                        "str"  # Optional. Array of feature ids to return.
                    ],
                    "intersects": geo_json_object
                }

                # response body for status code(s): 200
                response == {
                    "features": [
                        {
                            "assets": {
                                "str": {
                                    "href": "str",  # Link to the asset object.
                                      Required.
                                    "description": "str",  # Optional. A
                                      description of the Asset providing additional details, such as
                                      how it was processed or created.
                                    "roles": [
                                        "str"  # Optional. The semantic roles
                                          of the asset, similar to the use of rel in links.
                                    ],
                                    "title": "str",  # Optional. The displayed
                                      title for clients and users.
                                    "type": "str"  # Optional. Media type of the
                                      asset.
                                }
                            },
                            "id": "str",  # Provider identifier. Globally unique ID by
                              Data provider. Required.
                            "links": [
                                {
                                    "href": "str",  # The actual link in the
                                      format of an URL. Required.
                                    "rel": "str",  # Relationship between the
                                      current document and the linked document. Required.
                                    "title": "str",  # Optional. A human readable
                                      title to be used in rendered displays of the link.
                                    "type": "str"  # Optional. Media type of the
                                      referenced entity.
                                }
                            ],
                            "properties": {},  # A dictionary of additional metadata for
                              the item. Required.
                            "stacVersion": "str",  # The STAC version the Feature
                              implements. Required.
                            "type": "str",  # Type of the GeoJSON Object. It's value is
                              always Feature. Required.
                            "bbox": [
                                0.0  # Optional. Bounding box of the feature.
                            ],
                            "collection": "str",  # Optional. The id of the STAC
                              Collection this Feature references.
                            "geometry": {},  # Optional. Defines the full footprint of
                              the asset represented by this item."nIts a GeoJSON geometry.
                            "stacExtensions": [
                                "str"  # Optional. A list of extensions the Feature
                                  implements.
                            ]
                        }
                    ],
                    "nextLink": "str"  # Optional. URL to do the POST request with same
                      filters,"nto get next set of features.
                }
        """

    @overload
    def search_features(
        self,
        collection_id: str,
        search_features_query: IO,
        *,
        maxpagesize: int = 10,
        skip: Optional[int] = None,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> JSON:
        """Search for STAC features by collection id, bbox, intersecting geometry, start and end datetime.

        :param collection_id: Collection Id to be searched. Known values are: "Sentinel_2_L2A" and
         "Sentinel_2_L1C". Required.
        :type collection_id: str
        :param search_features_query: Query filters. Required.
        :type search_features_query: IO
        :keyword maxpagesize: Maximum number of features needed (inclusive). Minimum = 1, Maximum =
         100, Default value = 10. Default value is 10.
        :paramtype maxpagesize: int
        :keyword skip: Skip token for getting next set of results. Default value is None.
        :paramtype skip: int
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: JSON object
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "features": [
                        {
                            "assets": {
                                "str": {
                                    "href": "str",  # Link to the asset object.
                                      Required.
                                    "description": "str",  # Optional. A
                                      description of the Asset providing additional details, such as
                                      how it was processed or created.
                                    "roles": [
                                        "str"  # Optional. The semantic roles
                                          of the asset, similar to the use of rel in links.
                                    ],
                                    "title": "str",  # Optional. The displayed
                                      title for clients and users.
                                    "type": "str"  # Optional. Media type of the
                                      asset.
                                }
                            },
                            "id": "str",  # Provider identifier. Globally unique ID by
                              Data provider. Required.
                            "links": [
                                {
                                    "href": "str",  # The actual link in the
                                      format of an URL. Required.
                                    "rel": "str",  # Relationship between the
                                      current document and the linked document. Required.
                                    "title": "str",  # Optional. A human readable
                                      title to be used in rendered displays of the link.
                                    "type": "str"  # Optional. Media type of the
                                      referenced entity.
                                }
                            ],
                            "properties": {},  # A dictionary of additional metadata for
                              the item. Required.
                            "stacVersion": "str",  # The STAC version the Feature
                              implements. Required.
                            "type": "str",  # Type of the GeoJSON Object. It's value is
                              always Feature. Required.
                            "bbox": [
                                0.0  # Optional. Bounding box of the feature.
                            ],
                            "collection": "str",  # Optional. The id of the STAC
                              Collection this Feature references.
                            "geometry": {},  # Optional. Defines the full footprint of
                              the asset represented by this item."nIts a GeoJSON geometry.
                            "stacExtensions": [
                                "str"  # Optional. A list of extensions the Feature
                                  implements.
                            ]
                        }
                    ],
                    "nextLink": "str"  # Optional. URL to do the POST request with same
                      filters,"nto get next set of features.
                }
        """

    @distributed_trace
    def search_features(
        self,
        collection_id: str,
        search_features_query: Union[JSON, IO],
        *,
        maxpagesize: int = 10,
        skip: Optional[int] = None,
        **kwargs: Any
    ) -> JSON:
        """Search for STAC features by collection id, bbox, intersecting geometry, start and end datetime.

        :param collection_id: Collection Id to be searched. Known values are: "Sentinel_2_L2A" and
         "Sentinel_2_L1C". Required.
        :type collection_id: str
        :param search_features_query: Query filters. Is either a model type or a IO type. Required.
        :type search_features_query: JSON or IO
        :keyword maxpagesize: Maximum number of features needed (inclusive). Minimum = 1, Maximum =
         100, Default value = 10. Default value is 10.
        :paramtype maxpagesize: int
        :keyword skip: Skip token for getting next set of results. Default value is None.
        :paramtype skip: int
        :keyword content_type: Body Parameter content-type. Known values are: 'application/json'.
         Default value is None.
        :paramtype content_type: str
        :return: JSON object
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "features": [
                        {
                            "assets": {
                                "str": {
                                    "href": "str",  # Link to the asset object.
                                      Required.
                                    "description": "str",  # Optional. A
                                      description of the Asset providing additional details, such as
                                      how it was processed or created.
                                    "roles": [
                                        "str"  # Optional. The semantic roles
                                          of the asset, similar to the use of rel in links.
                                    ],
                                    "title": "str",  # Optional. The displayed
                                      title for clients and users.
                                    "type": "str"  # Optional. Media type of the
                                      asset.
                                }
                            },
                            "id": "str",  # Provider identifier. Globally unique ID by
                              Data provider. Required.
                            "links": [
                                {
                                    "href": "str",  # The actual link in the
                                      format of an URL. Required.
                                    "rel": "str",  # Relationship between the
                                      current document and the linked document. Required.
                                    "title": "str",  # Optional. A human readable
                                      title to be used in rendered displays of the link.
                                    "type": "str"  # Optional. Media type of the
                                      referenced entity.
                                }
                            ],
                            "properties": {},  # A dictionary of additional metadata for
                              the item. Required.
                            "stacVersion": "str",  # The STAC version the Feature
                              implements. Required.
                            "type": "str",  # Type of the GeoJSON Object. It's value is
                              always Feature. Required.
                            "bbox": [
                                0.0  # Optional. Bounding box of the feature.
                            ],
                            "collection": "str",  # Optional. The id of the STAC
                              Collection this Feature references.
                            "geometry": {},  # Optional. Defines the full footprint of
                              the asset represented by this item."nIts a GeoJSON geometry.
                            "stacExtensions": [
                                "str"  # Optional. A list of extensions the Feature
                                  implements.
                            ]
                        }
                    ],
                    "nextLink": "str"  # Optional. URL to do the POST request with same
                      filters,"nto get next set of features.
                }
        """
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type = kwargs.pop("content_type", _headers.pop("Content-Type", None))  # type: Optional[str]
        cls = kwargs.pop("cls", None)  # type: ClsType[JSON]

        content_type = content_type or "application/json"
        _json = None
        _content = None
        if isinstance(search_features_query, (IO, bytes)):
            _content = search_features_query
        else:
            _json = search_features_query

        request = build_scenes_search_features_request(
            collection_id=collection_id,
            maxpagesize=maxpagesize,
            skip=skip,
            content_type=content_type,
            api_version=self._config.api_version,
            json=_json,
            content=_content,
            headers=_headers,
            params=_params,
        )
        request.url = self._client.format_url(request.url)  # type: ignore

        pipeline_response = self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
            request, stream=False, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if response.content:
            deserialized = response.json()
        else:
            deserialized = None

        if cls:
            return cls(pipeline_response, cast(JSON, deserialized), {})

        return cast(JSON, deserialized)

    @distributed_trace
    def get_stac_feature(self, collection_id: str, feature_id: str, **kwargs: Any) -> JSON:
        """Get a feature(SpatioTemporal Asset Catalog (STAC) Item) for given collection and feature id.

        :param collection_id: Collection Id to be fetched. Known values are: "Sentinel_2_L2A" and
         "Sentinel_2_L1C". Required.
        :type collection_id: str
        :param feature_id: Feature Id to be fetched. Required.
        :type feature_id: str
        :return: JSON object
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "assets": {
                        "str": {
                            "href": "str",  # Link to the asset object. Required.
                            "description": "str",  # Optional. A description of the Asset
                              providing additional details, such as how it was processed or created.
                            "roles": [
                                "str"  # Optional. The semantic roles of the asset,
                                  similar to the use of rel in links.
                            ],
                            "title": "str",  # Optional. The displayed title for clients
                              and users.
                            "type": "str"  # Optional. Media type of the asset.
                        }
                    },
                    "id": "str",  # Provider identifier. Globally unique ID by Data provider.
                      Required.
                    "links": [
                        {
                            "href": "str",  # The actual link in the format of an URL.
                              Required.
                            "rel": "str",  # Relationship between the current document
                              and the linked document. Required.
                            "title": "str",  # Optional. A human readable title to be
                              used in rendered displays of the link.
                            "type": "str"  # Optional. Media type of the referenced
                              entity.
                        }
                    ],
                    "properties": {},  # A dictionary of additional metadata for the item.
                      Required.
                    "stacVersion": "str",  # The STAC version the Feature implements. Required.
                    "type": "str",  # Type of the GeoJSON Object. It's value is always Feature.
                      Required.
                    "bbox": [
                        0.0  # Optional. Bounding box of the feature.
                    ],
                    "collection": "str",  # Optional. The id of the STAC Collection this Feature
                      references.
                    "geometry": {},  # Optional. Defines the full footprint of the asset
                      represented by this item."nIts a GeoJSON geometry.
                    "stacExtensions": [
                        "str"  # Optional. A list of extensions the Feature implements.
                    ]
                }
        """
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls = kwargs.pop("cls", None)  # type: ClsType[JSON]

        request = build_scenes_get_stac_feature_request(
            collection_id=collection_id,
            feature_id=feature_id,
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        request.url = self._client.format_url(request.url)  # type: ignore

        pipeline_response = self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
            request, stream=False, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if response.content:
            deserialized = response.json()
        else:
            deserialized = None

        if cls:
            return cls(pipeline_response, cast(JSON, deserialized), {})

        return cast(JSON, deserialized)


class SeasonalFieldsOperations:
    """
    .. warning::
        **DO NOT** instantiate this class directly.

        Instead, you should access the following operations through
        :class:`~azure.agrifood.farming.FarmBeatsClient`'s
        :attr:`seasonal_fields` attribute.
    """

    def __init__(self, *args, **kwargs):
        input_args = list(args)
        self._client = input_args.pop(0) if input_args else kwargs.pop("client")
        self._config = input_args.pop(0) if input_args else kwargs.pop("config")
        self._serialize = input_args.pop(0) if input_args else kwargs.pop("serializer")
        self._deserialize = input_args.pop(0) if input_args else kwargs.pop("deserializer")

    @distributed_trace
    def list_by_party_id(
        self,
        party_id: str,
        *,
        farm_ids: Optional[List[str]] = None,
        field_ids: Optional[List[str]] = None,
        season_ids: Optional[List[str]] = None,
        crop_product_ids: Optional[List[str]] = None,
        crop_ids: Optional[List[str]] = None,
        ids: Optional[List[str]] = None,
        names: Optional[List[str]] = None,
        property_filters: Optional[List[str]] = None,
        statuses: Optional[List[str]] = None,
        min_created_date_time: Optional[datetime.datetime] = None,
        max_created_date_time: Optional[datetime.datetime] = None,
        min_last_modified_date_time: Optional[datetime.datetime] = None,
        max_last_modified_date_time: Optional[datetime.datetime] = None,
        skip_token: Optional[str] = None,
        **kwargs: Any
    ) -> Iterable[JSON]:
        """Returns a paginated list of seasonal field resources under a particular party.

        :param party_id: Id of the associated party. Required.
        :type party_id: str
        :keyword farm_ids: Farm Ids of the resource. Default value is None.
        :paramtype farm_ids: list[str]
        :keyword field_ids: Field Ids of the resource. Default value is None.
        :paramtype field_ids: list[str]
        :keyword season_ids: Season Ids of the resource. Default value is None.
        :paramtype season_ids: list[str]
        :keyword crop_product_ids: CropProductIds of the resource. Default value is None.
        :paramtype crop_product_ids: list[str]
        :keyword crop_ids: Ids of the crop it belongs to. Default value is None.
        :paramtype crop_ids: list[str]
        :keyword ids: Ids of the resource. Default value is None.
        :paramtype ids: list[str]
        :keyword names: Names of the resource. Default value is None.
        :paramtype names: list[str]
        :keyword property_filters: Filters on key-value pairs within the Properties object.
         eg. "{testKey} eq {testValue}". Default value is None.
        :paramtype property_filters: list[str]
        :keyword statuses: Statuses of the resource. Default value is None.
        :paramtype statuses: list[str]
        :keyword min_created_date_time: Minimum creation date of resource (inclusive). Default value is
         None.
        :paramtype min_created_date_time: ~datetime.datetime
        :keyword max_created_date_time: Maximum creation date of resource (inclusive). Default value is
         None.
        :paramtype max_created_date_time: ~datetime.datetime
        :keyword min_last_modified_date_time: Minimum last modified date of resource (inclusive).
         Default value is None.
        :paramtype min_last_modified_date_time: ~datetime.datetime
        :keyword max_last_modified_date_time: Maximum last modified date of resource (inclusive).
         Default value is None.
        :paramtype max_last_modified_date_time: ~datetime.datetime
        :keyword skip_token: Skip token for getting next set of results. Default value is None.
        :paramtype skip_token: str
        :return: An iterator like instance of JSON object
        :rtype: ~azure.core.paging.ItemPaged[JSON]
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "createdBy": "str",  # Optional. Created by user/tenant id.
                    "createdDateTime": "2020-02-20 00:00:00",  # Optional. Date-time when
                      resource was created, sample format: yyyy-MM-ddTHH:mm:ssZ.
                    "cropId": "str",  # Optional. Id of the crop it belongs to.
                    "cropProductIds": [
                        "str"  # Optional. CropProduct ids.
                    ],
                    "description": "str",  # Optional. Textual description of the resource.
                    "eTag": "str",  # Optional. The ETag value to implement optimistic
                      concurrency.
                    "farmId": "str",  # Optional. Id of the associated Farm.
                    "fieldId": "str",  # Optional. Id of the associated Field.
                    "id": "str",  # Optional. Unique resource ID.
                    "modifiedBy": "str",  # Optional. Modified by user/tenant id.
                    "modifiedDateTime": "2020-02-20 00:00:00",  # Optional. Date-time when
                      resource was last modified, sample format: yyyy-MM-ddTHH:mm:ssZ.
                    "name": "str",  # Optional. Name to identify resource.
                    "partyId": "str",  # Optional. Party Id.
                    "properties": {
                        "str": {}  # Optional. A collection of key value pairs that belongs
                          to the resource."nEach pair must not have a key greater than 50
                          characters"nand must not have a value greater than 150 characters."nNote: A
                          maximum of 25 key value pairs can be provided for a resource and only
                          string,"nnumeral and datetime (yyyy-MM-ddTHH:mm:ssZ) values are supported.
                    },
                    "seasonId": "str",  # Optional. Id of the season it belongs to.
                    "source": "str",  # Optional. Source of the resource.
                    "status": "str"  # Optional. Status of the resource.
                }
        """
        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls = kwargs.pop("cls", None)  # type: ClsType[JSON]

        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        def prepare_request(next_link=None):
            if not next_link:

                request = build_seasonal_fields_list_by_party_id_request(
                    party_id=party_id,
                    farm_ids=farm_ids,
                    field_ids=field_ids,
                    season_ids=season_ids,
                    crop_product_ids=crop_product_ids,
                    crop_ids=crop_ids,
                    ids=ids,
                    names=names,
                    property_filters=property_filters,
                    statuses=statuses,
                    min_created_date_time=min_created_date_time,
                    max_created_date_time=max_created_date_time,
                    min_last_modified_date_time=min_last_modified_date_time,
                    max_last_modified_date_time=max_last_modified_date_time,
                    skip_token=skip_token,
                    api_version=self._config.api_version,
                    headers=_headers,
                    params=_params,
                )
                request.url = self._client.format_url(request.url)  # type: ignore

            else:
                # make call to next link with the client's api-version
                _parsed_next_link = urlparse(next_link)
                _next_request_params = case_insensitive_dict(parse_qs(_parsed_next_link.query))
                _next_request_params["api-version"] = self._config.api_version
                request = HttpRequest("GET", urljoin(next_link, _parsed_next_link.path), params=_next_request_params)
                request.url = self._client.format_url(request.url)  # type: ignore

            return request

        def extract_data(pipeline_response):
            deserialized = pipeline_response.http_response.json()
            list_of_elem = deserialized["value"]
            if cls:
                list_of_elem = cls(list_of_elem)
            return deserialized.get("nextLink", None), iter(list_of_elem)

        def get_next(next_link=None):
            request = prepare_request(next_link)

            pipeline_response = self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
                request, stream=False, **kwargs
            )
            response = pipeline_response.http_response

            if response.status_code not in [200]:
                map_error(status_code=response.status_code, response=response, error_map=error_map)
                raise HttpResponseError(response=response)

            return pipeline_response

        return ItemPaged(get_next, extract_data)

    @distributed_trace
    def get(self, party_id: str, seasonal_field_id: str, **kwargs: Any) -> JSON:
        """Gets a specified seasonal field resource under a particular party.

        :param party_id: Id of the associated party. Required.
        :type party_id: str
        :param seasonal_field_id: Id of the seasonal field. Required.
        :type seasonal_field_id: str
        :return: JSON object
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "createdBy": "str",  # Optional. Created by user/tenant id.
                    "createdDateTime": "2020-02-20 00:00:00",  # Optional. Date-time when
                      resource was created, sample format: yyyy-MM-ddTHH:mm:ssZ.
                    "cropId": "str",  # Optional. Id of the crop it belongs to.
                    "cropProductIds": [
                        "str"  # Optional. CropProduct ids.
                    ],
                    "description": "str",  # Optional. Textual description of the resource.
                    "eTag": "str",  # Optional. The ETag value to implement optimistic
                      concurrency.
                    "farmId": "str",  # Optional. Id of the associated Farm.
                    "fieldId": "str",  # Optional. Id of the associated Field.
                    "id": "str",  # Optional. Unique resource ID.
                    "modifiedBy": "str",  # Optional. Modified by user/tenant id.
                    "modifiedDateTime": "2020-02-20 00:00:00",  # Optional. Date-time when
                      resource was last modified, sample format: yyyy-MM-ddTHH:mm:ssZ.
                    "name": "str",  # Optional. Name to identify resource.
                    "partyId": "str",  # Optional. Party Id.
                    "properties": {
                        "str": {}  # Optional. A collection of key value pairs that belongs
                          to the resource."nEach pair must not have a key greater than 50
                          characters"nand must not have a value greater than 150 characters."nNote: A
                          maximum of 25 key value pairs can be provided for a resource and only
                          string,"nnumeral and datetime (yyyy-MM-ddTHH:mm:ssZ) values are supported.
                    },
                    "seasonId": "str",  # Optional. Id of the season it belongs to.
                    "source": "str",  # Optional. Source of the resource.
                    "status": "str"  # Optional. Status of the resource.
                }
        """
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls = kwargs.pop("cls", None)  # type: ClsType[JSON]

        request = build_seasonal_fields_get_request(
            party_id=party_id,
            seasonal_field_id=seasonal_field_id,
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        request.url = self._client.format_url(request.url)  # type: ignore

        pipeline_response = self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
            request, stream=False, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if response.content:
            deserialized = response.json()
        else:
            deserialized = None

        if cls:
            return cls(pipeline_response, cast(JSON, deserialized), {})

        return cast(JSON, deserialized)

    @overload
    def create_or_update(
        self,
        party_id: str,
        seasonal_field_id: str,
        seasonal_field: JSON,
        *,
        content_type: str = "application/merge-patch+json",
        **kwargs: Any
    ) -> JSON:
        """Creates or Updates a seasonal field resource under a particular party.

        :param party_id: Id of the associated party resource. Required.
        :type party_id: str
        :param seasonal_field_id: Id of the seasonal field resource. Required.
        :type seasonal_field_id: str
        :param seasonal_field: Seasonal field resource payload to create or update. Required.
        :type seasonal_field: JSON
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/merge-patch+json".
        :paramtype content_type: str
        :return: JSON object
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                seasonal_field = {
                    "createdBy": "str",  # Optional. Created by user/tenant id.
                    "createdDateTime": "2020-02-20 00:00:00",  # Optional. Date-time when
                      resource was created, sample format: yyyy-MM-ddTHH:mm:ssZ.
                    "cropId": "str",  # Optional. Id of the crop it belongs to.
                    "cropProductIds": [
                        "str"  # Optional. CropProduct ids.
                    ],
                    "description": "str",  # Optional. Textual description of the resource.
                    "eTag": "str",  # Optional. The ETag value to implement optimistic
                      concurrency.
                    "farmId": "str",  # Optional. Id of the associated Farm.
                    "fieldId": "str",  # Optional. Id of the associated Field.
                    "id": "str",  # Optional. Unique resource ID.
                    "modifiedBy": "str",  # Optional. Modified by user/tenant id.
                    "modifiedDateTime": "2020-02-20 00:00:00",  # Optional. Date-time when
                      resource was last modified, sample format: yyyy-MM-ddTHH:mm:ssZ.
                    "name": "str",  # Optional. Name to identify resource.
                    "partyId": "str",  # Optional. Party Id.
                    "properties": {
                        "str": {}  # Optional. A collection of key value pairs that belongs
                          to the resource."nEach pair must not have a key greater than 50
                          characters"nand must not have a value greater than 150 characters."nNote: A
                          maximum of 25 key value pairs can be provided for a resource and only
                          string,"nnumeral and datetime (yyyy-MM-ddTHH:mm:ssZ) values are supported.
                    },
                    "seasonId": "str",  # Optional. Id of the season it belongs to.
                    "source": "str",  # Optional. Source of the resource.
                    "status": "str"  # Optional. Status of the resource.
                }

                # response body for status code(s): 200, 201
                response == {
                    "createdBy": "str",  # Optional. Created by user/tenant id.
                    "createdDateTime": "2020-02-20 00:00:00",  # Optional. Date-time when
                      resource was created, sample format: yyyy-MM-ddTHH:mm:ssZ.
                    "cropId": "str",  # Optional. Id of the crop it belongs to.
                    "cropProductIds": [
                        "str"  # Optional. CropProduct ids.
                    ],
                    "description": "str",  # Optional. Textual description of the resource.
                    "eTag": "str",  # Optional. The ETag value to implement optimistic
                      concurrency.
                    "farmId": "str",  # Optional. Id of the associated Farm.
                    "fieldId": "str",  # Optional. Id of the associated Field.
                    "id": "str",  # Optional. Unique resource ID.
                    "modifiedBy": "str",  # Optional. Modified by user/tenant id.
                    "modifiedDateTime": "2020-02-20 00:00:00",  # Optional. Date-time when
                      resource was last modified, sample format: yyyy-MM-ddTHH:mm:ssZ.
                    "name": "str",  # Optional. Name to identify resource.
                    "partyId": "str",  # Optional. Party Id.
                    "properties": {
                        "str": {}  # Optional. A collection of key value pairs that belongs
                          to the resource."nEach pair must not have a key greater than 50
                          characters"nand must not have a value greater than 150 characters."nNote: A
                          maximum of 25 key value pairs can be provided for a resource and only
                          string,"nnumeral and datetime (yyyy-MM-ddTHH:mm:ssZ) values are supported.
                    },
                    "seasonId": "str",  # Optional. Id of the season it belongs to.
                    "source": "str",  # Optional. Source of the resource.
                    "status": "str"  # Optional. Status of the resource.
                }
        """

    @overload
    def create_or_update(
        self,
        party_id: str,
        seasonal_field_id: str,
        seasonal_field: IO,
        *,
        content_type: str = "application/merge-patch+json",
        **kwargs: Any
    ) -> JSON:
        """Creates or Updates a seasonal field resource under a particular party.

        :param party_id: Id of the associated party resource. Required.
        :type party_id: str
        :param seasonal_field_id: Id of the seasonal field resource. Required.
        :type seasonal_field_id: str
        :param seasonal_field: Seasonal field resource payload to create or update. Required.
        :type seasonal_field: IO
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Default value is "application/merge-patch+json".
        :paramtype content_type: str
        :return: JSON object
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200, 201
                response == {
                    "createdBy": "str",  # Optional. Created by user/tenant id.
                    "createdDateTime": "2020-02-20 00:00:00",  # Optional. Date-time when
                      resource was created, sample format: yyyy-MM-ddTHH:mm:ssZ.
                    "cropId": "str",  # Optional. Id of the crop it belongs to.
                    "cropProductIds": [
                        "str"  # Optional. CropProduct ids.
                    ],
                    "description": "str",  # Optional. Textual description of the resource.
                    "eTag": "str",  # Optional. The ETag value to implement optimistic
                      concurrency.
                    "farmId": "str",  # Optional. Id of the associated Farm.
                    "fieldId": "str",  # Optional. Id of the associated Field.
                    "id": "str",  # Optional. Unique resource ID.
                    "modifiedBy": "str",  # Optional. Modified by user/tenant id.
                    "modifiedDateTime": "2020-02-20 00:00:00",  # Optional. Date-time when
                      resource was last modified, sample format: yyyy-MM-ddTHH:mm:ssZ.
                    "name": "str",  # Optional. Name to identify resource.
                    "partyId": "str",  # Optional. Party Id.
                    "properties": {
                        "str": {}  # Optional. A collection of key value pairs that belongs
                          to the resource."nEach pair must not have a key greater than 50
                          characters"nand must not have a value greater than 150 characters."nNote: A
                          maximum of 25 key value pairs can be provided for a resource and only
                          string,"nnumeral and datetime (yyyy-MM-ddTHH:mm:ssZ) values are supported.
                    },
                    "seasonId": "str",  # Optional. Id of the season it belongs to.
                    "source": "str",  # Optional. Source of the resource.
                    "status": "str"  # Optional. Status of the resource.
                }
        """

    @distributed_trace
    def create_or_update(
        self, party_id: str, seasonal_field_id: str, seasonal_field: Union[JSON, IO], **kwargs: Any
    ) -> JSON:
        """Creates or Updates a seasonal field resource under a particular party.

        :param party_id: Id of the associated party resource. Required.
        :type party_id: str
        :param seasonal_field_id: Id of the seasonal field resource. Required.
        :type seasonal_field_id: str
        :param seasonal_field: Seasonal field resource payload to create or update. Is either a model
         type or a IO type. Required.
        :type seasonal_field: JSON or IO
        :keyword content_type: Body Parameter content-type. Known values are:
         'application/merge-patch+json'. Default value is None.
        :paramtype content_type: str
        :return: JSON object
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200, 201
                response == {
                    "createdBy": "str",  # Optional. Created by user/tenant id.
                    "createdDateTime": "2020-02-20 00:00:00",  # Optional. Date-time when
                      resource was created, sample format: yyyy-MM-ddTHH:mm:ssZ.
                    "cropId": "str",  # Optional. Id of the crop it belongs to.
                    "cropProductIds": [
                        "str"  # Optional. CropProduct ids.
                    ],
                    "description": "str",  # Optional. Textual description of the resource.
                    "eTag": "str",  # Optional. The ETag value to implement optimistic
                      concurrency.
                    "farmId": "str",  # Optional. Id of the associated Farm.
                    "fieldId": "str",  # Optional. Id of the associated Field.
                    "id": "str",  # Optional. Unique resource ID.
                    "modifiedBy": "str",  # Optional. Modified by user/tenant id.
                    "modifiedDateTime": "2020-02-20 00:00:00",  # Optional. Date-time when
                      resource was last modified, sample format: yyyy-MM-ddTHH:mm:ssZ.
                    "name": "str",  # Optional. Name to identify resource.
                    "partyId": "str",  # Optional. Party Id.
                    "properties": {
                        "str": {}  # Optional. A collection of key value pairs that belongs
                          to the resource."nEach pair must not have a key greater than 50
                          characters"nand must not have a value greater than 150 characters."nNote: A
                          maximum of 25 key value pairs can be provided for a resource and only
                          string,"nnumeral and datetime (yyyy-MM-ddTHH:mm:ssZ) values are supported.
                    },
                    "seasonId": "str",  # Optional. Id of the season it belongs to.
                    "source": "str",  # Optional. Source of the resource.
                    "status": "str"  # Optional. Status of the resource.
                }
        """
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type = kwargs.pop("content_type", _headers.pop("Content-Type", None))  # type: Optional[str]
        cls = kwargs.pop("cls", None)  # type: ClsType[JSON]

        content_type = content_type or "application/merge-patch+json"
        _json = None
        _content = None
        if isinstance(seasonal_field, (IO, bytes)):
            _content = seasonal_field
        else:
            _json = seasonal_field

        request = build_seasonal_fields_create_or_update_request(
            party_id=party_id,
            seasonal_field_id=seasonal_field_id,
            content_type=content_type,
            api_version=self._config.api_version,
            json=_json,
            content=_content,
            headers=_headers,
            params=_params,
        )
        request.url = self._client.format_url(request.url)  # type: ignore

        pipeline_response = self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
            request, stream=False, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200, 201]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if response.status_code == 200:
            if response.content:
                deserialized = response.json()
            else:
                deserialized = None

        if response.status_code == 201:
            if response.content:
                deserialized = response.json()
            else:
                deserialized = None

        if cls:
            return cls(pipeline_response, cast(JSON, deserialized), {})

        return cast(JSON, deserialized)

    @distributed_trace
    def delete(  # pylint: disable=inconsistent-return-statements
        self, party_id: str, seasonal_field_id: str, **kwargs: Any
    ) -> None:
        """Deletes a specified seasonal-field resource under a particular party.

        :param party_id: Id of the party. Required.
        :type party_id: str
        :param seasonal_field_id: Id of the seasonal field. Required.
        :type seasonal_field_id: str
        :return: None
        :rtype: None
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls = kwargs.pop("cls", None)  # type: ClsType[None]

        request = build_seasonal_fields_delete_request(
            party_id=party_id,
            seasonal_field_id=seasonal_field_id,
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        request.url = self._client.format_url(request.url)  # type: ignore

        pipeline_response = self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
            request, stream=False, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [204]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if cls:
            return cls(pipeline_response, None, {})

    @distributed_trace
    def list(
        self,
        *,
        farm_ids: Optional[List[str]] = None,
        field_ids: Optional[List[str]] = None,
        season_ids: Optional[List[str]] = None,
        crop_product_ids: Optional[List[str]] = None,
        crop_ids: Optional[List[str]] = None,
        ids: Optional[List[str]] = None,
        names: Optional[List[str]] = None,
        property_filters: Optional[List[str]] = None,
        statuses: Optional[List[str]] = None,
        min_created_date_time: Optional[datetime.datetime] = None,
        max_created_date_time: Optional[datetime.datetime] = None,
        min_last_modified_date_time: Optional[datetime.datetime] = None,
        max_last_modified_date_time: Optional[datetime.datetime] = None,
        skip_token: Optional[str] = None,
        **kwargs: Any
    ) -> Iterable[JSON]:
        """Returns a paginated list of seasonal field resources across all parties.

        :keyword farm_ids: Farm Ids of the resource. Default value is None.
        :paramtype farm_ids: list[str]
        :keyword field_ids: Field Ids of the resource. Default value is None.
        :paramtype field_ids: list[str]
        :keyword season_ids: Season Ids of the resource. Default value is None.
        :paramtype season_ids: list[str]
        :keyword crop_product_ids: CropProductIds of the resource. Default value is None.
        :paramtype crop_product_ids: list[str]
        :keyword crop_ids: Ids of the crop it belongs to. Default value is None.
        :paramtype crop_ids: list[str]
        :keyword ids: Ids of the resource. Default value is None.
        :paramtype ids: list[str]
        :keyword names: Names of the resource. Default value is None.
        :paramtype names: list[str]
        :keyword property_filters: Filters on key-value pairs within the Properties object.
         eg. "{testKey} eq {testValue}". Default value is None.
        :paramtype property_filters: list[str]
        :keyword statuses: Statuses of the resource. Default value is None.
        :paramtype statuses: list[str]
        :keyword min_created_date_time: Minimum creation date of resource (inclusive). Default value is
         None.
        :paramtype min_created_date_time: ~datetime.datetime
        :keyword max_created_date_time: Maximum creation date of resource (inclusive). Default value is
         None.
        :paramtype max_created_date_time: ~datetime.datetime
        :keyword min_last_modified_date_time: Minimum last modified date of resource (inclusive).
         Default value is None.
        :paramtype min_last_modified_date_time: ~datetime.datetime
        :keyword max_last_modified_date_time: Maximum last modified date of resource (inclusive).
         Default value is None.
        :paramtype max_last_modified_date_time: ~datetime.datetime
        :keyword skip_token: Skip token for getting next set of results. Default value is None.
        :paramtype skip_token: str
        :return: An iterator like instance of JSON object
        :rtype: ~azure.core.paging.ItemPaged[JSON]
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "createdBy": "str",  # Optional. Created by user/tenant id.
                    "createdDateTime": "2020-02-20 00:00:00",  # Optional. Date-time when
                      resource was created, sample format: yyyy-MM-ddTHH:mm:ssZ.
                    "cropId": "str",  # Optional. Id of the crop it belongs to.
                    "cropProductIds": [
                        "str"  # Optional. CropProduct ids.
                    ],
                    "description": "str",  # Optional. Textual description of the resource.
                    "eTag": "str",  # Optional. The ETag value to implement optimistic
                      concurrency.
                    "farmId": "str",  # Optional. Id of the associated Farm.
                    "fieldId": "str",  # Optional. Id of the associated Field.
                    "id": "str",  # Optional. Unique resource ID.
                    "modifiedBy": "str",  # Optional. Modified by user/tenant id.
                    "modifiedDateTime": "2020-02-20 00:00:00",  # Optional. Date-time when
                      resource was last modified, sample format: yyyy-MM-ddTHH:mm:ssZ.
                    "name": "str",  # Optional. Name to identify resource.
                    "partyId": "str",  # Optional. Party Id.
                    "properties": {
                        "str": {}  # Optional. A collection of key value pairs that belongs
                          to the resource."nEach pair must not have a key greater than 50
                          characters"nand must not have a value greater than 150 characters."nNote: A
                          maximum of 25 key value pairs can be provided for a resource and only
                          string,"nnumeral and datetime (yyyy-MM-ddTHH:mm:ssZ) values are supported.
                    },
                    "seasonId": "str",  # Optional. Id of the season it belongs to.
                    "source": "str",  # Optional. Source of the resource.
                    "status": "str"  # Optional. Status of the resource.
                }
        """
        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls = kwargs.pop("cls", None)  # type: ClsType[JSON]

        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        def prepare_request(next_link=None):
            if not next_link:

                request = build_seasonal_fields_list_request(
                    farm_ids=farm_ids,
                    field_ids=field_ids,
                    season_ids=season_ids,
                    crop_product_ids=crop_product_ids,
                    crop_ids=crop_ids,
                    ids=ids,
                    names=names,
                    property_filters=property_filters,
                    statuses=statuses,
                    min_created_date_time=min_created_date_time,
                    max_created_date_time=max_created_date_time,
                    min_last_modified_date_time=min_last_modified_date_time,
                    max_last_modified_date_time=max_last_modified_date_time,
                    skip_token=skip_token,
                    api_version=self._config.api_version,
                    headers=_headers,
                    params=_params,
                )
                request.url = self._client.format_url(request.url)  # type: ignore

            else:
                # make call to next link with the client's api-version
                _parsed_next_link = urlparse(next_link)
                _next_request_params = case_insensitive_dict(parse_qs(_parsed_next_link.query))
                _next_request_params["api-version"] = self._config.api_version
                request = HttpRequest("GET", urljoin(next_link, _parsed_next_link.path), params=_next_request_params)
                request.url = self._client.format_url(request.url)  # type: ignore

            return request

        def extract_data(pipeline_response):
            deserialized = pipeline_response.http_response.json()
            list_of_elem = deserialized["value"]
            if cls:
                list_of_elem = cls(list_of_elem)
            return deserialized.get("nextLink", None), iter(list_of_elem)

        def get_next(next_link=None):
            request = prepare_request(next_link)

            pipeline_response = self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
                request, stream=False, **kwargs
            )
            response = pipeline_response.http_response

            if response.status_code not in [200]:
                map_error(status_code=response.status_code, response=response, error_map=error_map)
                raise HttpResponseError(response=response)

            return pipeline_response

        return ItemPaged(get_next, extract_data)

    @distributed_trace
    def get_cascade_delete_job_details(self, job_id: str, **kwargs: Any) -> JSON:
        """Get cascade delete job for specified seasonal field.

        :param job_id: Id of the job. Required.
        :type job_id: str
        :return: JSON object
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "partyId": "str",  # Party Id. Required.
                    "resourceId": "str",  # The id of the resource. Required.
                    "resourceType": "str",  # The type of the resource. Required.
                    "createdDateTime": "2020-02-20 00:00:00",  # Optional. Job created at
                      dateTime. Sample format: yyyy-MM-ddTHH:mm:ssZ.
                    "durationInSeconds": 0.0,  # Optional. Duration of the job in seconds.
                    "endTime": "2020-02-20 00:00:00",  # Optional. Job end time when available.
                      Sample format: yyyy-MM-ddTHH:mm:ssZ.
                    "errorCode": "str",  # Optional. Error Code when job failed.
                    "id": "str",  # Optional. Unique job id.
                    "lastActionDateTime": "2020-02-20 00:00:00",  # Optional. Job was last acted
                      upon at dateTime. Sample format: yyyy-MM-ddTHH:mm:ssZ.
                    "message": "str",  # Optional. Status message to capture more details of the
                      job.
                    "startTime": "2020-02-20 00:00:00",  # Optional. Job start time when
                      available. Sample format: yyyy-MM-ddTHH:mm:ssZ.
                    "status": "str"  # Optional. Status of the job."nPossible values: 'Waiting',
                      'Running', 'Succeeded', 'Failed', 'Cancelled'. Known values are: "Waiting",
                      "Running", "Succeeded", "Failed", and "Cancelled".
                }
        """
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls = kwargs.pop("cls", None)  # type: ClsType[JSON]

        request = build_seasonal_fields_get_cascade_delete_job_details_request(
            job_id=job_id,
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        request.url = self._client.format_url(request.url)  # type: ignore

        pipeline_response = self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
            request, stream=False, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if response.content:
            deserialized = response.json()
        else:
            deserialized = None

        if cls:
            return cls(pipeline_response, cast(JSON, deserialized), {})

        return cast(JSON, deserialized)

    def _create_cascade_delete_job_initial(
        self, job_id: str, *, party_id: str, seasonal_field_id: str, **kwargs: Any
    ) -> JSON:
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls = kwargs.pop("cls", None)  # type: ClsType[JSON]

        request = build_seasonal_fields_create_cascade_delete_job_request(
            job_id=job_id,
            party_id=party_id,
            seasonal_field_id=seasonal_field_id,
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        request.url = self._client.format_url(request.url)  # type: ignore

        pipeline_response = self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
            request, stream=False, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [202]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if response.content:
            deserialized = response.json()
        else:
            deserialized = None

        if cls:
            return cls(pipeline_response, cast(JSON, deserialized), {})

        return cast(JSON, deserialized)

    @distributed_trace
    def begin_create_cascade_delete_job(
        self, job_id: str, *, party_id: str, seasonal_field_id: str, **kwargs: Any
    ) -> LROPoller[JSON]:
        """Create a cascade delete job for specified seasonal field.

        :param job_id: Job ID supplied by end user. Required.
        :type job_id: str
        :keyword party_id: ID of the associated party. Required.
        :paramtype party_id: str
        :keyword seasonal_field_id: ID of the seasonalField to be deleted. Required.
        :paramtype seasonal_field_id: str
        :keyword str continuation_token: A continuation token to restart a poller from a saved state.
        :keyword polling: By default, your polling method will be LROBasePolling. Pass in False for
         this operation to not poll, or pass in your own initialized polling object for a personal
         polling strategy.
        :paramtype polling: bool or ~azure.core.polling.PollingMethod
        :keyword int polling_interval: Default waiting time between two polls for LRO operations if no
         Retry-After header is present.
        :return: An instance of LROPoller that returns JSON object
        :rtype: ~azure.core.polling.LROPoller[JSON]
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 202
                response == {
                    "partyId": "str",  # Party Id. Required.
                    "resourceId": "str",  # The id of the resource. Required.
                    "resourceType": "str",  # The type of the resource. Required.
                    "createdDateTime": "2020-02-20 00:00:00",  # Optional. Job created at
                      dateTime. Sample format: yyyy-MM-ddTHH:mm:ssZ.
                    "durationInSeconds": 0.0,  # Optional. Duration of the job in seconds.
                    "endTime": "2020-02-20 00:00:00",  # Optional. Job end time when available.
                      Sample format: yyyy-MM-ddTHH:mm:ssZ.
                    "errorCode": "str",  # Optional. Error Code when job failed.
                    "id": "str",  # Optional. Unique job id.
                    "lastActionDateTime": "2020-02-20 00:00:00",  # Optional. Job was last acted
                      upon at dateTime. Sample format: yyyy-MM-ddTHH:mm:ssZ.
                    "message": "str",  # Optional. Status message to capture more details of the
                      job.
                    "startTime": "2020-02-20 00:00:00",  # Optional. Job start time when
                      available. Sample format: yyyy-MM-ddTHH:mm:ssZ.
                    "status": "str"  # Optional. Status of the job."nPossible values: 'Waiting',
                      'Running', 'Succeeded', 'Failed', 'Cancelled'. Known values are: "Waiting",
                      "Running", "Succeeded", "Failed", and "Cancelled".
                }
        """
        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls = kwargs.pop("cls", None)  # type: ClsType[JSON]
        polling = kwargs.pop("polling", True)  # type: Union[bool, PollingMethod]
        lro_delay = kwargs.pop("polling_interval", self._config.polling_interval)
        cont_token = kwargs.pop("continuation_token", None)  # type: Optional[str]
        if cont_token is None:
            raw_result = self._create_cascade_delete_job_initial(  # type: ignore
                job_id=job_id,
                party_id=party_id,
                seasonal_field_id=seasonal_field_id,
                cls=lambda x, y, z: x,
                headers=_headers,
                params=_params,
                **kwargs
            )
        kwargs.pop("error_map", None)

        def get_long_running_output(pipeline_response):
            response = pipeline_response.http_response
            if response.content:
                deserialized = response.json()
            else:
                deserialized = None
            if cls:
                return cls(pipeline_response, deserialized, {})
            return deserialized

        if polling is True:
            polling_method = cast(
                PollingMethod, LROBasePolling(lro_delay, lro_options={"final-state-via": "location"}, **kwargs)
            )  # type: PollingMethod
        elif polling is False:
            polling_method = cast(PollingMethod, NoPolling())
        else:
            polling_method = polling
        if cont_token:
            return LROPoller.from_continuation_token(
                polling_method=polling_method,
                continuation_token=cont_token,
                client=self._client,
                deserialization_callback=get_long_running_output,
            )
        return LROPoller(self._client, raw_result, get_long_running_output, polling_method)


class SeasonsOperations:
    """
    .. warning::
        **DO NOT** instantiate this class directly.

        Instead, you should access the following operations through
        :class:`~azure.agrifood.farming.FarmBeatsClient`'s
        :attr:`seasons` attribute.
    """

    def __init__(self, *args, **kwargs):
        input_args = list(args)
        self._client = input_args.pop(0) if input_args else kwargs.pop("client")
        self._config = input_args.pop(0) if input_args else kwargs.pop("config")
        self._serialize = input_args.pop(0) if input_args else kwargs.pop("serializer")
        self._deserialize = input_args.pop(0) if input_args else kwargs.pop("deserializer")

    @distributed_trace
    def list(
        self,
        *,
        min_start_date_time: Optional[datetime.datetime] = None,
        max_start_date_time: Optional[datetime.datetime] = None,
        min_end_date_time: Optional[datetime.datetime] = None,
        max_end_date_time: Optional[datetime.datetime] = None,
        years: Optional[List[int]] = None,
        ids: Optional[List[str]] = None,
        names: Optional[List[str]] = None,
        property_filters: Optional[List[str]] = None,
        statuses: Optional[List[str]] = None,
        min_created_date_time: Optional[datetime.datetime] = None,
        max_created_date_time: Optional[datetime.datetime] = None,
        min_last_modified_date_time: Optional[datetime.datetime] = None,
        max_last_modified_date_time: Optional[datetime.datetime] = None,
        skip_token: Optional[str] = None,
        **kwargs: Any
    ) -> Iterable[JSON]:
        """Returns a paginated list of season resources.

        :keyword min_start_date_time: Minimum season start datetime, sample format:
         yyyy-MM-ddTHH:mm:ssZ. Default value is None.
        :paramtype min_start_date_time: ~datetime.datetime
        :keyword max_start_date_time: Maximum season start datetime, sample format:
         yyyy-MM-ddTHH:mm:ssZ. Default value is None.
        :paramtype max_start_date_time: ~datetime.datetime
        :keyword min_end_date_time: Minimum season end datetime, sample format: yyyy-MM-ddTHH:mm:ssZ.
         Default value is None.
        :paramtype min_end_date_time: ~datetime.datetime
        :keyword max_end_date_time: Maximum season end datetime, sample format: yyyy-MM-ddTHH:mm:ssZ.
         Default value is None.
        :paramtype max_end_date_time: ~datetime.datetime
        :keyword years: Years of the resource. Default value is None.
        :paramtype years: list[int]
        :keyword ids: Ids of the resource. Default value is None.
        :paramtype ids: list[str]
        :keyword names: Names of the resource. Default value is None.
        :paramtype names: list[str]
        :keyword property_filters: Filters on key-value pairs within the Properties object.
         eg. "{testKey} eq {testValue}". Default value is None.
        :paramtype property_filters: list[str]
        :keyword statuses: Statuses of the resource. Default value is None.
        :paramtype statuses: list[str]
        :keyword min_created_date_time: Minimum creation date of resource (inclusive). Default value is
         None.
        :paramtype min_created_date_time: ~datetime.datetime
        :keyword max_created_date_time: Maximum creation date of resource (inclusive). Default value is
         None.
        :paramtype max_created_date_time: ~datetime.datetime
        :keyword min_last_modified_date_time: Minimum last modified date of resource (inclusive).
         Default value is None.
        :paramtype min_last_modified_date_time: ~datetime.datetime
        :keyword max_last_modified_date_time: Maximum last modified date of resource (inclusive).
         Default value is None.
        :paramtype max_last_modified_date_time: ~datetime.datetime
        :keyword skip_token: Skip token for getting next set of results. Default value is None.
        :paramtype skip_token: str
        :return: An iterator like instance of JSON object
        :rtype: ~azure.core.paging.ItemPaged[JSON]
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "createdBy": "str",  # Optional. Created by user/tenant id.
                    "createdDateTime": "2020-02-20 00:00:00",  # Optional. Date-time when
                      resource was created, sample format: yyyy-MM-ddTHH:mm:ssZ.
                    "description": "str",  # Optional. Textual description of the resource.
                    "eTag": "str",  # Optional. The ETag value to implement optimistic
                      concurrency.
                    "endDateTime": "2020-02-20 00:00:00",  # Optional. Season end datetime,
                      sample format: yyyy-MM-ddTHH:mm:ssZ.
                    "geographicIdentifier": "str",  # Optional. Geographic Identifier.
                    "id": "str",  # Optional. Unique resource ID.
                    "modifiedBy": "str",  # Optional. Modified by user/tenant id.
                    "modifiedDateTime": "2020-02-20 00:00:00",  # Optional. Date-time when
                      resource was last modified, sample format: yyyy-MM-ddTHH:mm:ssZ.
                    "name": "str",  # Optional. Name to identify resource.
                    "properties": {
                        "str": {}  # Optional. A collection of key value pairs that belongs
                          to the resource."nEach pair must not have a key greater than 50
                          characters"nand must not have a value greater than 150 characters."nNote: A
                          maximum of 25 key value pairs can be provided for a resource and only
                          string,"nnumeral and datetime (yyyy-MM-ddTHH:mm:ssZ) values are supported.
                    },
                    "source": "str",  # Optional. Source of the resource.
                    "startDateTime": "2020-02-20 00:00:00",  # Optional. Season start datetime,
                      sample format: yyyy-MM-ddTHH:mm:ssZ.
                    "status": "str",  # Optional. Status of the resource.
                    "year": 0  # Optional. Season year.
                }
        """
        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls = kwargs.pop("cls", None)  # type: ClsType[JSON]

        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        def prepare_request(next_link=None):
            if not next_link:

                request = build_seasons_list_request(
                    min_start_date_time=min_start_date_time,
                    max_start_date_time=max_start_date_time,
                    min_end_date_time=min_end_date_time,
                    max_end_date_time=max_end_date_time,
                    years=years,
                    ids=ids,
                    names=names,
                    property_filters=property_filters,
                    statuses=statuses,
                    min_created_date_time=min_created_date_time,
                    max_created_date_time=max_created_date_time,
                    min_last_modified_date_time=min_last_modified_date_time,
                    max_last_modified_date_time=max_last_modified_date_time,
                    skip_token=skip_token,
                    api_version=self._config.api_version,
                    headers=_headers,
                    params=_params,
                )
                request.url = self._client.format_url(request.url)  # type: ignore

            else:
                # make call to next link with the client's api-version
                _parsed_next_link = urlparse(next_link)
                _next_request_params = case_insensitive_dict(parse_qs(_parsed_next_link.query))
                _next_request_params["api-version"] = self._config.api_version
                request = HttpRequest("GET", urljoin(next_link, _parsed_next_link.path), params=_next_request_params)
                request.url = self._client.format_url(request.url)  # type: ignore

            return request

        def extract_data(pipeline_response):
            deserialized = pipeline_response.http_response.json()
            list_of_elem = deserialized["value"]
            if cls:
                list_of_elem = cls(list_of_elem)
            return deserialized.get("nextLink", None), iter(list_of_elem)

        def get_next(next_link=None):
            request = prepare_request(next_link)

            pipeline_response = self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
                request, stream=False, **kwargs
            )
            response = pipeline_response.http_response

            if response.status_code not in [200]:
                map_error(status_code=response.status_code, response=response, error_map=error_map)
                raise HttpResponseError(response=response)

            return pipeline_response

        return ItemPaged(get_next, extract_data)

    @distributed_trace
    def get(self, season_id: str, **kwargs: Any) -> JSON:
        """Gets a specified season resource.

        :param season_id: Id of the season. Required.
        :type season_id: str
        :return: JSON object
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "createdBy": "str",  # Optional. Created by user/tenant id.
                    "createdDateTime": "2020-02-20 00:00:00",  # Optional. Date-time when
                      resource was created, sample format: yyyy-MM-ddTHH:mm:ssZ.
                    "description": "str",  # Optional. Textual description of the resource.
                    "eTag": "str",  # Optional. The ETag value to implement optimistic
                      concurrency.
                    "endDateTime": "2020-02-20 00:00:00",  # Optional. Season end datetime,
                      sample format: yyyy-MM-ddTHH:mm:ssZ.
                    "geographicIdentifier": "str",  # Optional. Geographic Identifier.
                    "id": "str",  # Optional. Unique resource ID.
                    "modifiedBy": "str",  # Optional. Modified by user/tenant id.
                    "modifiedDateTime": "2020-02-20 00:00:00",  # Optional. Date-time when
                      resource was last modified, sample format: yyyy-MM-ddTHH:mm:ssZ.
                    "name": "str",  # Optional. Name to identify resource.
                    "properties": {
                        "str": {}  # Optional. A collection of key value pairs that belongs
                          to the resource."nEach pair must not have a key greater than 50
                          characters"nand must not have a value greater than 150 characters."nNote: A
                          maximum of 25 key value pairs can be provided for a resource and only
                          string,"nnumeral and datetime (yyyy-MM-ddTHH:mm:ssZ) values are supported.
                    },
                    "source": "str",  # Optional. Source of the resource.
                    "startDateTime": "2020-02-20 00:00:00",  # Optional. Season start datetime,
                      sample format: yyyy-MM-ddTHH:mm:ssZ.
                    "status": "str",  # Optional. Status of the resource.
                    "year": 0  # Optional. Season year.
                }
        """
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls = kwargs.pop("cls", None)  # type: ClsType[JSON]

        request = build_seasons_get_request(
            season_id=season_id,
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        request.url = self._client.format_url(request.url)  # type: ignore

        pipeline_response = self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
            request, stream=False, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if response.content:
            deserialized = response.json()
        else:
            deserialized = None

        if cls:
            return cls(pipeline_response, cast(JSON, deserialized), {})

        return cast(JSON, deserialized)

    @overload
    def create_or_update(
        self, season_id: str, season: JSON, *, content_type: str = "application/merge-patch+json", **kwargs: Any
    ) -> JSON:
        """Creates or updates a season resource.

        :param season_id: Id of the season resource. Required.
        :type season_id: str
        :param season: Season resource payload to create or update. Required.
        :type season: JSON
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/merge-patch+json".
        :paramtype content_type: str
        :return: JSON object
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                season = {
                    "createdBy": "str",  # Optional. Created by user/tenant id.
                    "createdDateTime": "2020-02-20 00:00:00",  # Optional. Date-time when
                      resource was created, sample format: yyyy-MM-ddTHH:mm:ssZ.
                    "description": "str",  # Optional. Textual description of the resource.
                    "eTag": "str",  # Optional. The ETag value to implement optimistic
                      concurrency.
                    "endDateTime": "2020-02-20 00:00:00",  # Optional. Season end datetime,
                      sample format: yyyy-MM-ddTHH:mm:ssZ.
                    "geographicIdentifier": "str",  # Optional. Geographic Identifier.
                    "id": "str",  # Optional. Unique resource ID.
                    "modifiedBy": "str",  # Optional. Modified by user/tenant id.
                    "modifiedDateTime": "2020-02-20 00:00:00",  # Optional. Date-time when
                      resource was last modified, sample format: yyyy-MM-ddTHH:mm:ssZ.
                    "name": "str",  # Optional. Name to identify resource.
                    "properties": {
                        "str": {}  # Optional. A collection of key value pairs that belongs
                          to the resource."nEach pair must not have a key greater than 50
                          characters"nand must not have a value greater than 150 characters."nNote: A
                          maximum of 25 key value pairs can be provided for a resource and only
                          string,"nnumeral and datetime (yyyy-MM-ddTHH:mm:ssZ) values are supported.
                    },
                    "source": "str",  # Optional. Source of the resource.
                    "startDateTime": "2020-02-20 00:00:00",  # Optional. Season start datetime,
                      sample format: yyyy-MM-ddTHH:mm:ssZ.
                    "status": "str",  # Optional. Status of the resource.
                    "year": 0  # Optional. Season year.
                }

                # response body for status code(s): 200, 201
                response == {
                    "createdBy": "str",  # Optional. Created by user/tenant id.
                    "createdDateTime": "2020-02-20 00:00:00",  # Optional. Date-time when
                      resource was created, sample format: yyyy-MM-ddTHH:mm:ssZ.
                    "description": "str",  # Optional. Textual description of the resource.
                    "eTag": "str",  # Optional. The ETag value to implement optimistic
                      concurrency.
                    "endDateTime": "2020-02-20 00:00:00",  # Optional. Season end datetime,
                      sample format: yyyy-MM-ddTHH:mm:ssZ.
                    "geographicIdentifier": "str",  # Optional. Geographic Identifier.
                    "id": "str",  # Optional. Unique resource ID.
                    "modifiedBy": "str",  # Optional. Modified by user/tenant id.
                    "modifiedDateTime": "2020-02-20 00:00:00",  # Optional. Date-time when
                      resource was last modified, sample format: yyyy-MM-ddTHH:mm:ssZ.
                    "name": "str",  # Optional. Name to identify resource.
                    "properties": {
                        "str": {}  # Optional. A collection of key value pairs that belongs
                          to the resource."nEach pair must not have a key greater than 50
                          characters"nand must not have a value greater than 150 characters."nNote: A
                          maximum of 25 key value pairs can be provided for a resource and only
                          string,"nnumeral and datetime (yyyy-MM-ddTHH:mm:ssZ) values are supported.
                    },
                    "source": "str",  # Optional. Source of the resource.
                    "startDateTime": "2020-02-20 00:00:00",  # Optional. Season start datetime,
                      sample format: yyyy-MM-ddTHH:mm:ssZ.
                    "status": "str",  # Optional. Status of the resource.
                    "year": 0  # Optional. Season year.
                }
        """

    @overload
    def create_or_update(
        self, season_id: str, season: IO, *, content_type: str = "application/merge-patch+json", **kwargs: Any
    ) -> JSON:
        """Creates or updates a season resource.

        :param season_id: Id of the season resource. Required.
        :type season_id: str
        :param season: Season resource payload to create or update. Required.
        :type season: IO
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Default value is "application/merge-patch+json".
        :paramtype content_type: str
        :return: JSON object
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200, 201
                response == {
                    "createdBy": "str",  # Optional. Created by user/tenant id.
                    "createdDateTime": "2020-02-20 00:00:00",  # Optional. Date-time when
                      resource was created, sample format: yyyy-MM-ddTHH:mm:ssZ.
                    "description": "str",  # Optional. Textual description of the resource.
                    "eTag": "str",  # Optional. The ETag value to implement optimistic
                      concurrency.
                    "endDateTime": "2020-02-20 00:00:00",  # Optional. Season end datetime,
                      sample format: yyyy-MM-ddTHH:mm:ssZ.
                    "geographicIdentifier": "str",  # Optional. Geographic Identifier.
                    "id": "str",  # Optional. Unique resource ID.
                    "modifiedBy": "str",  # Optional. Modified by user/tenant id.
                    "modifiedDateTime": "2020-02-20 00:00:00",  # Optional. Date-time when
                      resource was last modified, sample format: yyyy-MM-ddTHH:mm:ssZ.
                    "name": "str",  # Optional. Name to identify resource.
                    "properties": {
                        "str": {}  # Optional. A collection of key value pairs that belongs
                          to the resource."nEach pair must not have a key greater than 50
                          characters"nand must not have a value greater than 150 characters."nNote: A
                          maximum of 25 key value pairs can be provided for a resource and only
                          string,"nnumeral and datetime (yyyy-MM-ddTHH:mm:ssZ) values are supported.
                    },
                    "source": "str",  # Optional. Source of the resource.
                    "startDateTime": "2020-02-20 00:00:00",  # Optional. Season start datetime,
                      sample format: yyyy-MM-ddTHH:mm:ssZ.
                    "status": "str",  # Optional. Status of the resource.
                    "year": 0  # Optional. Season year.
                }
        """

    @distributed_trace
    def create_or_update(self, season_id: str, season: Union[JSON, IO], **kwargs: Any) -> JSON:
        """Creates or updates a season resource.

        :param season_id: Id of the season resource. Required.
        :type season_id: str
        :param season: Season resource payload to create or update. Is either a model type or a IO
         type. Required.
        :type season: JSON or IO
        :keyword content_type: Body Parameter content-type. Known values are:
         'application/merge-patch+json'. Default value is None.
        :paramtype content_type: str
        :return: JSON object
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200, 201
                response == {
                    "createdBy": "str",  # Optional. Created by user/tenant id.
                    "createdDateTime": "2020-02-20 00:00:00",  # Optional. Date-time when
                      resource was created, sample format: yyyy-MM-ddTHH:mm:ssZ.
                    "description": "str",  # Optional. Textual description of the resource.
                    "eTag": "str",  # Optional. The ETag value to implement optimistic
                      concurrency.
                    "endDateTime": "2020-02-20 00:00:00",  # Optional. Season end datetime,
                      sample format: yyyy-MM-ddTHH:mm:ssZ.
                    "geographicIdentifier": "str",  # Optional. Geographic Identifier.
                    "id": "str",  # Optional. Unique resource ID.
                    "modifiedBy": "str",  # Optional. Modified by user/tenant id.
                    "modifiedDateTime": "2020-02-20 00:00:00",  # Optional. Date-time when
                      resource was last modified, sample format: yyyy-MM-ddTHH:mm:ssZ.
                    "name": "str",  # Optional. Name to identify resource.
                    "properties": {
                        "str": {}  # Optional. A collection of key value pairs that belongs
                          to the resource."nEach pair must not have a key greater than 50
                          characters"nand must not have a value greater than 150 characters."nNote: A
                          maximum of 25 key value pairs can be provided for a resource and only
                          string,"nnumeral and datetime (yyyy-MM-ddTHH:mm:ssZ) values are supported.
                    },
                    "source": "str",  # Optional. Source of the resource.
                    "startDateTime": "2020-02-20 00:00:00",  # Optional. Season start datetime,
                      sample format: yyyy-MM-ddTHH:mm:ssZ.
                    "status": "str",  # Optional. Status of the resource.
                    "year": 0  # Optional. Season year.
                }
        """
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type = kwargs.pop("content_type", _headers.pop("Content-Type", None))  # type: Optional[str]
        cls = kwargs.pop("cls", None)  # type: ClsType[JSON]

        content_type = content_type or "application/merge-patch+json"
        _json = None
        _content = None
        if isinstance(season, (IO, bytes)):
            _content = season
        else:
            _json = season

        request = build_seasons_create_or_update_request(
            season_id=season_id,
            content_type=content_type,
            api_version=self._config.api_version,
            json=_json,
            content=_content,
            headers=_headers,
            params=_params,
        )
        request.url = self._client.format_url(request.url)  # type: ignore

        pipeline_response = self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
            request, stream=False, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200, 201]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if response.status_code == 200:
            if response.content:
                deserialized = response.json()
            else:
                deserialized = None

        if response.status_code == 201:
            if response.content:
                deserialized = response.json()
            else:
                deserialized = None

        if cls:
            return cls(pipeline_response, cast(JSON, deserialized), {})

        return cast(JSON, deserialized)

    @distributed_trace
    def delete(self, season_id: str, **kwargs: Any) -> None:  # pylint: disable=inconsistent-return-statements
        """Deletes a specified season resource.

        :param season_id: Id of the season. Required.
        :type season_id: str
        :return: None
        :rtype: None
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls = kwargs.pop("cls", None)  # type: ClsType[None]

        request = build_seasons_delete_request(
            season_id=season_id,
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        request.url = self._client.format_url(request.url)  # type: ignore

        pipeline_response = self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
            request, stream=False, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [204]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if cls:
            return cls(pipeline_response, None, {})


class SensorDataModelsOperations:
    """
    .. warning::
        **DO NOT** instantiate this class directly.

        Instead, you should access the following operations through
        :class:`~azure.agrifood.farming.FarmBeatsClient`'s
        :attr:`sensor_data_models` attribute.
    """

    def __init__(self, *args, **kwargs):
        input_args = list(args)
        self._client = input_args.pop(0) if input_args else kwargs.pop("client")
        self._config = input_args.pop(0) if input_args else kwargs.pop("config")
        self._serialize = input_args.pop(0) if input_args else kwargs.pop("serializer")
        self._deserialize = input_args.pop(0) if input_args else kwargs.pop("deserializer")

    @distributed_trace
    def list(
        self,
        sensor_partner_id: str,
        *,
        ids: Optional[List[str]] = None,
        names: Optional[List[str]] = None,
        property_filters: Optional[List[str]] = None,
        statuses: Optional[List[str]] = None,
        min_created_date_time: Optional[datetime.datetime] = None,
        max_created_date_time: Optional[datetime.datetime] = None,
        min_last_modified_date_time: Optional[datetime.datetime] = None,
        max_last_modified_date_time: Optional[datetime.datetime] = None,
        skip_token: Optional[str] = None,
        **kwargs: Any
    ) -> Iterable[JSON]:
        """Returns a paginated list of sensor data model resources.

        :param sensor_partner_id: Id of the associated sensor partner. Required.
        :type sensor_partner_id: str
        :keyword ids: Ids of the resource. Default value is None.
        :paramtype ids: list[str]
        :keyword names: Names of the resource. Default value is None.
        :paramtype names: list[str]
        :keyword property_filters: Filters on key-value pairs within the Properties object.
         eg. "{testKey} eq {testValue}". Default value is None.
        :paramtype property_filters: list[str]
        :keyword statuses: Statuses of the resource. Default value is None.
        :paramtype statuses: list[str]
        :keyword min_created_date_time: Minimum creation date of resource (inclusive). Default value is
         None.
        :paramtype min_created_date_time: ~datetime.datetime
        :keyword max_created_date_time: Maximum creation date of resource (inclusive). Default value is
         None.
        :paramtype max_created_date_time: ~datetime.datetime
        :keyword min_last_modified_date_time: Minimum last modified date of resource (inclusive).
         Default value is None.
        :paramtype min_last_modified_date_time: ~datetime.datetime
        :keyword max_last_modified_date_time: Maximum last modified date of resource (inclusive).
         Default value is None.
        :paramtype max_last_modified_date_time: ~datetime.datetime
        :keyword skip_token: Skip token for getting next set of results. Default value is None.
        :paramtype skip_token: str
        :return: An iterator like instance of JSON object
        :rtype: ~azure.core.paging.ItemPaged[JSON]
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "measures": {
                        "str": {
                            "dataType": "str",  # Sensor measure data type. Required.
                              Known values are: "Bool", "Double", "DateTime", "Long", and "String".
                            "description": "str",  # Optional. Description of sensor
                              measure.
                            "properties": {
                                "str": {}  # Optional. A collection of key value
                                  pairs for sensor data model."nEach pair must not have a key greater
                                  than 50 characters"nand must not have a value greater than 150
                                  characters."nNote: A maximum of 25 key value pairs can be provided
                                  for a model and"nonly string, numeral and datetime
                                  (yyyy-MM-ddTHH:mm:ssZ) values are supported.
                            },
                            "type": "str",  # Optional. Measurement type of sensor data.
                            "unit": "str"  # Optional. Unit of sensor measure.
                        }
                    },
                    "createdBy": "str",  # Optional. Created by user/tenant id.
                    "createdDateTime": "2020-02-20 00:00:00",  # Optional. Date-time when
                      resource was created, sample format: yyyy-MM-ddTHH:mm:ssZ.
                    "description": "str",  # Optional. Textual description of the resource.
                    "eTag": "str",  # Optional. The ETag value to implement optimistic
                      concurrency.
                    "id": "str",  # Optional. Id of the resource.
                    "manufacturer": "str",  # Optional. Sensor manufacturer.
                    "modifiedBy": "str",  # Optional. Modified by user/tenant id.
                    "modifiedDateTime": "2020-02-20 00:00:00",  # Optional. Date-time when
                      resource was last modified, sample format: yyyy-MM-ddTHH:mm:ssZ.
                    "name": "str",  # Optional. Name to identify resource.
                    "productCode": "str",  # Optional. Sensor productCode.
                    "properties": {
                        "str": {}  # Optional. A collection of key value pairs that belongs
                          to the resource."nEach pair must not have a key greater than 50
                          characters"nand must not have a value greater than 150 characters."nNote: A
                          maximum of 25 key value pairs can be provided for a resource and"nonly
                          string, numeral and datetime (yyyy-MM-ddTHH:mm:ssZ) values are supported.
                    },
                    "sensorPartnerId": "str",  # Optional. Id of the associated sensor partner.
                    "status": "str",  # Optional. Status of the resource.
                    "type": "str"  # Optional. Type of sensor.
                }
        """
        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls = kwargs.pop("cls", None)  # type: ClsType[JSON]

        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        def prepare_request(next_link=None):
            if not next_link:

                request = build_sensor_data_models_list_request(
                    sensor_partner_id=sensor_partner_id,
                    ids=ids,
                    names=names,
                    property_filters=property_filters,
                    statuses=statuses,
                    min_created_date_time=min_created_date_time,
                    max_created_date_time=max_created_date_time,
                    min_last_modified_date_time=min_last_modified_date_time,
                    max_last_modified_date_time=max_last_modified_date_time,
                    skip_token=skip_token,
                    api_version=self._config.api_version,
                    headers=_headers,
                    params=_params,
                )
                request.url = self._client.format_url(request.url)  # type: ignore

            else:
                # make call to next link with the client's api-version
                _parsed_next_link = urlparse(next_link)
                _next_request_params = case_insensitive_dict(parse_qs(_parsed_next_link.query))
                _next_request_params["api-version"] = self._config.api_version
                request = HttpRequest("GET", urljoin(next_link, _parsed_next_link.path), params=_next_request_params)
                request.url = self._client.format_url(request.url)  # type: ignore

            return request

        def extract_data(pipeline_response):
            deserialized = pipeline_response.http_response.json()
            list_of_elem = deserialized["value"]
            if cls:
                list_of_elem = cls(list_of_elem)
            return deserialized.get("nextLink", None), iter(list_of_elem)

        def get_next(next_link=None):
            request = prepare_request(next_link)

            pipeline_response = self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
                request, stream=False, **kwargs
            )
            response = pipeline_response.http_response

            if response.status_code not in [200]:
                map_error(status_code=response.status_code, response=response, error_map=error_map)
                raise HttpResponseError(response=response)

            return pipeline_response

        return ItemPaged(get_next, extract_data)

    @overload
    def create_or_update(
        self,
        sensor_partner_id: str,
        sensor_data_model_id: str,
        sensor_data_model_object: JSON,
        *,
        content_type: str = "application/merge-patch+json",
        **kwargs: Any
    ) -> JSON:
        """Create a sensor data model entity.

        :param sensor_partner_id: Id of the sensor partner. Required.
        :type sensor_partner_id: str
        :param sensor_data_model_id: Id of the sensor data model. Required.
        :type sensor_data_model_id: str
        :param sensor_data_model_object: Sensor data model object details. Required.
        :type sensor_data_model_object: JSON
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/merge-patch+json".
        :paramtype content_type: str
        :return: JSON object
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                sensor_data_model_object = {
                    "measures": {
                        "str": {
                            "dataType": "str",  # Sensor measure data type. Required.
                              Known values are: "Bool", "Double", "DateTime", "Long", and "String".
                            "description": "str",  # Optional. Description of sensor
                              measure.
                            "properties": {
                                "str": {}  # Optional. A collection of key value
                                  pairs for sensor data model."nEach pair must not have a key greater
                                  than 50 characters"nand must not have a value greater than 150
                                  characters."nNote: A maximum of 25 key value pairs can be provided
                                  for a model and"nonly string, numeral and datetime
                                  (yyyy-MM-ddTHH:mm:ssZ) values are supported.
                            },
                            "type": "str",  # Optional. Measurement type of sensor data.
                            "unit": "str"  # Optional. Unit of sensor measure.
                        }
                    },
                    "createdBy": "str",  # Optional. Created by user/tenant id.
                    "createdDateTime": "2020-02-20 00:00:00",  # Optional. Date-time when
                      resource was created, sample format: yyyy-MM-ddTHH:mm:ssZ.
                    "description": "str",  # Optional. Textual description of the resource.
                    "eTag": "str",  # Optional. The ETag value to implement optimistic
                      concurrency.
                    "id": "str",  # Optional. Id of the resource.
                    "manufacturer": "str",  # Optional. Sensor manufacturer.
                    "modifiedBy": "str",  # Optional. Modified by user/tenant id.
                    "modifiedDateTime": "2020-02-20 00:00:00",  # Optional. Date-time when
                      resource was last modified, sample format: yyyy-MM-ddTHH:mm:ssZ.
                    "name": "str",  # Optional. Name to identify resource.
                    "productCode": "str",  # Optional. Sensor productCode.
                    "properties": {
                        "str": {}  # Optional. A collection of key value pairs that belongs
                          to the resource."nEach pair must not have a key greater than 50
                          characters"nand must not have a value greater than 150 characters."nNote: A
                          maximum of 25 key value pairs can be provided for a resource and"nonly
                          string, numeral and datetime (yyyy-MM-ddTHH:mm:ssZ) values are supported.
                    },
                    "sensorPartnerId": "str",  # Optional. Id of the associated sensor partner.
                    "status": "str",  # Optional. Status of the resource.
                    "type": "str"  # Optional. Type of sensor.
                }

                # response body for status code(s): 200, 201
                response == {
                    "measures": {
                        "str": {
                            "dataType": "str",  # Sensor measure data type. Required.
                              Known values are: "Bool", "Double", "DateTime", "Long", and "String".
                            "description": "str",  # Optional. Description of sensor
                              measure.
                            "properties": {
                                "str": {}  # Optional. A collection of key value
                                  pairs for sensor data model."nEach pair must not have a key greater
                                  than 50 characters"nand must not have a value greater than 150
                                  characters."nNote: A maximum of 25 key value pairs can be provided
                                  for a model and"nonly string, numeral and datetime
                                  (yyyy-MM-ddTHH:mm:ssZ) values are supported.
                            },
                            "type": "str",  # Optional. Measurement type of sensor data.
                            "unit": "str"  # Optional. Unit of sensor measure.
                        }
                    },
                    "createdBy": "str",  # Optional. Created by user/tenant id.
                    "createdDateTime": "2020-02-20 00:00:00",  # Optional. Date-time when
                      resource was created, sample format: yyyy-MM-ddTHH:mm:ssZ.
                    "description": "str",  # Optional. Textual description of the resource.
                    "eTag": "str",  # Optional. The ETag value to implement optimistic
                      concurrency.
                    "id": "str",  # Optional. Id of the resource.
                    "manufacturer": "str",  # Optional. Sensor manufacturer.
                    "modifiedBy": "str",  # Optional. Modified by user/tenant id.
                    "modifiedDateTime": "2020-02-20 00:00:00",  # Optional. Date-time when
                      resource was last modified, sample format: yyyy-MM-ddTHH:mm:ssZ.
                    "name": "str",  # Optional. Name to identify resource.
                    "productCode": "str",  # Optional. Sensor productCode.
                    "properties": {
                        "str": {}  # Optional. A collection of key value pairs that belongs
                          to the resource."nEach pair must not have a key greater than 50
                          characters"nand must not have a value greater than 150 characters."nNote: A
                          maximum of 25 key value pairs can be provided for a resource and"nonly
                          string, numeral and datetime (yyyy-MM-ddTHH:mm:ssZ) values are supported.
                    },
                    "sensorPartnerId": "str",  # Optional. Id of the associated sensor partner.
                    "status": "str",  # Optional. Status of the resource.
                    "type": "str"  # Optional. Type of sensor.
                }
        """

    @overload
    def create_or_update(
        self,
        sensor_partner_id: str,
        sensor_data_model_id: str,
        sensor_data_model_object: IO,
        *,
        content_type: str = "application/merge-patch+json",
        **kwargs: Any
    ) -> JSON:
        """Create a sensor data model entity.

        :param sensor_partner_id: Id of the sensor partner. Required.
        :type sensor_partner_id: str
        :param sensor_data_model_id: Id of the sensor data model. Required.
        :type sensor_data_model_id: str
        :param sensor_data_model_object: Sensor data model object details. Required.
        :type sensor_data_model_object: IO
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Default value is "application/merge-patch+json".
        :paramtype content_type: str
        :return: JSON object
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200, 201
                response == {
                    "measures": {
                        "str": {
                            "dataType": "str",  # Sensor measure data type. Required.
                              Known values are: "Bool", "Double", "DateTime", "Long", and "String".
                            "description": "str",  # Optional. Description of sensor
                              measure.
                            "properties": {
                                "str": {}  # Optional. A collection of key value
                                  pairs for sensor data model."nEach pair must not have a key greater
                                  than 50 characters"nand must not have a value greater than 150
                                  characters."nNote: A maximum of 25 key value pairs can be provided
                                  for a model and"nonly string, numeral and datetime
                                  (yyyy-MM-ddTHH:mm:ssZ) values are supported.
                            },
                            "type": "str",  # Optional. Measurement type of sensor data.
                            "unit": "str"  # Optional. Unit of sensor measure.
                        }
                    },
                    "createdBy": "str",  # Optional. Created by user/tenant id.
                    "createdDateTime": "2020-02-20 00:00:00",  # Optional. Date-time when
                      resource was created, sample format: yyyy-MM-ddTHH:mm:ssZ.
                    "description": "str",  # Optional. Textual description of the resource.
                    "eTag": "str",  # Optional. The ETag value to implement optimistic
                      concurrency.
                    "id": "str",  # Optional. Id of the resource.
                    "manufacturer": "str",  # Optional. Sensor manufacturer.
                    "modifiedBy": "str",  # Optional. Modified by user/tenant id.
                    "modifiedDateTime": "2020-02-20 00:00:00",  # Optional. Date-time when
                      resource was last modified, sample format: yyyy-MM-ddTHH:mm:ssZ.
                    "name": "str",  # Optional. Name to identify resource.
                    "productCode": "str",  # Optional. Sensor productCode.
                    "properties": {
                        "str": {}  # Optional. A collection of key value pairs that belongs
                          to the resource."nEach pair must not have a key greater than 50
                          characters"nand must not have a value greater than 150 characters."nNote: A
                          maximum of 25 key value pairs can be provided for a resource and"nonly
                          string, numeral and datetime (yyyy-MM-ddTHH:mm:ssZ) values are supported.
                    },
                    "sensorPartnerId": "str",  # Optional. Id of the associated sensor partner.
                    "status": "str",  # Optional. Status of the resource.
                    "type": "str"  # Optional. Type of sensor.
                }
        """

    @distributed_trace
    def create_or_update(
        self,
        sensor_partner_id: str,
        sensor_data_model_id: str,
        sensor_data_model_object: Union[JSON, IO],
        **kwargs: Any
    ) -> JSON:
        """Create a sensor data model entity.

        :param sensor_partner_id: Id of the sensor partner. Required.
        :type sensor_partner_id: str
        :param sensor_data_model_id: Id of the sensor data model. Required.
        :type sensor_data_model_id: str
        :param sensor_data_model_object: Sensor data model object details. Is either a model type or a
         IO type. Required.
        :type sensor_data_model_object: JSON or IO
        :keyword content_type: Body Parameter content-type. Known values are:
         'application/merge-patch+json'. Default value is None.
        :paramtype content_type: str
        :return: JSON object
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200, 201
                response == {
                    "measures": {
                        "str": {
                            "dataType": "str",  # Sensor measure data type. Required.
                              Known values are: "Bool", "Double", "DateTime", "Long", and "String".
                            "description": "str",  # Optional. Description of sensor
                              measure.
                            "properties": {
                                "str": {}  # Optional. A collection of key value
                                  pairs for sensor data model."nEach pair must not have a key greater
                                  than 50 characters"nand must not have a value greater than 150
                                  characters."nNote: A maximum of 25 key value pairs can be provided
                                  for a model and"nonly string, numeral and datetime
                                  (yyyy-MM-ddTHH:mm:ssZ) values are supported.
                            },
                            "type": "str",  # Optional. Measurement type of sensor data.
                            "unit": "str"  # Optional. Unit of sensor measure.
                        }
                    },
                    "createdBy": "str",  # Optional. Created by user/tenant id.
                    "createdDateTime": "2020-02-20 00:00:00",  # Optional. Date-time when
                      resource was created, sample format: yyyy-MM-ddTHH:mm:ssZ.
                    "description": "str",  # Optional. Textual description of the resource.
                    "eTag": "str",  # Optional. The ETag value to implement optimistic
                      concurrency.
                    "id": "str",  # Optional. Id of the resource.
                    "manufacturer": "str",  # Optional. Sensor manufacturer.
                    "modifiedBy": "str",  # Optional. Modified by user/tenant id.
                    "modifiedDateTime": "2020-02-20 00:00:00",  # Optional. Date-time when
                      resource was last modified, sample format: yyyy-MM-ddTHH:mm:ssZ.
                    "name": "str",  # Optional. Name to identify resource.
                    "productCode": "str",  # Optional. Sensor productCode.
                    "properties": {
                        "str": {}  # Optional. A collection of key value pairs that belongs
                          to the resource."nEach pair must not have a key greater than 50
                          characters"nand must not have a value greater than 150 characters."nNote: A
                          maximum of 25 key value pairs can be provided for a resource and"nonly
                          string, numeral and datetime (yyyy-MM-ddTHH:mm:ssZ) values are supported.
                    },
                    "sensorPartnerId": "str",  # Optional. Id of the associated sensor partner.
                    "status": "str",  # Optional. Status of the resource.
                    "type": "str"  # Optional. Type of sensor.
                }
        """
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type = kwargs.pop("content_type", _headers.pop("Content-Type", None))  # type: Optional[str]
        cls = kwargs.pop("cls", None)  # type: ClsType[JSON]

        content_type = content_type or "application/merge-patch+json"
        _json = None
        _content = None
        if isinstance(sensor_data_model_object, (IO, bytes)):
            _content = sensor_data_model_object
        else:
            _json = sensor_data_model_object

        request = build_sensor_data_models_create_or_update_request(
            sensor_partner_id=sensor_partner_id,
            sensor_data_model_id=sensor_data_model_id,
            content_type=content_type,
            api_version=self._config.api_version,
            json=_json,
            content=_content,
            headers=_headers,
            params=_params,
        )
        request.url = self._client.format_url(request.url)  # type: ignore

        pipeline_response = self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
            request, stream=False, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200, 201]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if response.status_code == 200:
            if response.content:
                deserialized = response.json()
            else:
                deserialized = None

        if response.status_code == 201:
            if response.content:
                deserialized = response.json()
            else:
                deserialized = None

        if cls:
            return cls(pipeline_response, cast(JSON, deserialized), {})

        return cast(JSON, deserialized)

    @distributed_trace
    def get(self, sensor_partner_id: str, sensor_data_model_id: str, **kwargs: Any) -> JSON:
        """Gets a sensor data model entity.

        :param sensor_partner_id: Id of the sensor partner. Required.
        :type sensor_partner_id: str
        :param sensor_data_model_id: Id of the sensor data model resource. Required.
        :type sensor_data_model_id: str
        :return: JSON object
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "measures": {
                        "str": {
                            "dataType": "str",  # Sensor measure data type. Required.
                              Known values are: "Bool", "Double", "DateTime", "Long", and "String".
                            "description": "str",  # Optional. Description of sensor
                              measure.
                            "properties": {
                                "str": {}  # Optional. A collection of key value
                                  pairs for sensor data model."nEach pair must not have a key greater
                                  than 50 characters"nand must not have a value greater than 150
                                  characters."nNote: A maximum of 25 key value pairs can be provided
                                  for a model and"nonly string, numeral and datetime
                                  (yyyy-MM-ddTHH:mm:ssZ) values are supported.
                            },
                            "type": "str",  # Optional. Measurement type of sensor data.
                            "unit": "str"  # Optional. Unit of sensor measure.
                        }
                    },
                    "createdBy": "str",  # Optional. Created by user/tenant id.
                    "createdDateTime": "2020-02-20 00:00:00",  # Optional. Date-time when
                      resource was created, sample format: yyyy-MM-ddTHH:mm:ssZ.
                    "description": "str",  # Optional. Textual description of the resource.
                    "eTag": "str",  # Optional. The ETag value to implement optimistic
                      concurrency.
                    "id": "str",  # Optional. Id of the resource.
                    "manufacturer": "str",  # Optional. Sensor manufacturer.
                    "modifiedBy": "str",  # Optional. Modified by user/tenant id.
                    "modifiedDateTime": "2020-02-20 00:00:00",  # Optional. Date-time when
                      resource was last modified, sample format: yyyy-MM-ddTHH:mm:ssZ.
                    "name": "str",  # Optional. Name to identify resource.
                    "productCode": "str",  # Optional. Sensor productCode.
                    "properties": {
                        "str": {}  # Optional. A collection of key value pairs that belongs
                          to the resource."nEach pair must not have a key greater than 50
                          characters"nand must not have a value greater than 150 characters."nNote: A
                          maximum of 25 key value pairs can be provided for a resource and"nonly
                          string, numeral and datetime (yyyy-MM-ddTHH:mm:ssZ) values are supported.
                    },
                    "sensorPartnerId": "str",  # Optional. Id of the associated sensor partner.
                    "status": "str",  # Optional. Status of the resource.
                    "type": "str"  # Optional. Type of sensor.
                }
        """
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls = kwargs.pop("cls", None)  # type: ClsType[JSON]

        request = build_sensor_data_models_get_request(
            sensor_partner_id=sensor_partner_id,
            sensor_data_model_id=sensor_data_model_id,
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        request.url = self._client.format_url(request.url)  # type: ignore

        pipeline_response = self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
            request, stream=False, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if response.content:
            deserialized = response.json()
        else:
            deserialized = None

        if cls:
            return cls(pipeline_response, cast(JSON, deserialized), {})

        return cast(JSON, deserialized)

    @distributed_trace
    def delete(  # pylint: disable=inconsistent-return-statements
        self, sensor_partner_id: str, sensor_data_model_id: str, **kwargs: Any
    ) -> None:
        """Deletes a sensor data model entity.

        :param sensor_partner_id: Id of the sensor partner. Required.
        :type sensor_partner_id: str
        :param sensor_data_model_id: Id of the sensor data model resource. Required.
        :type sensor_data_model_id: str
        :return: None
        :rtype: None
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls = kwargs.pop("cls", None)  # type: ClsType[None]

        request = build_sensor_data_models_delete_request(
            sensor_partner_id=sensor_partner_id,
            sensor_data_model_id=sensor_data_model_id,
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        request.url = self._client.format_url(request.url)  # type: ignore

        pipeline_response = self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
            request, stream=False, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [204]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if cls:
            return cls(pipeline_response, None, {})


class SensorEventsOperations:
    """
    .. warning::
        **DO NOT** instantiate this class directly.

        Instead, you should access the following operations through
        :class:`~azure.agrifood.farming.FarmBeatsClient`'s
        :attr:`sensor_events` attribute.
    """

    def __init__(self, *args, **kwargs):
        input_args = list(args)
        self._client = input_args.pop(0) if input_args else kwargs.pop("client")
        self._config = input_args.pop(0) if input_args else kwargs.pop("config")
        self._serialize = input_args.pop(0) if input_args else kwargs.pop("serializer")
        self._deserialize = input_args.pop(0) if input_args else kwargs.pop("deserializer")

    @distributed_trace
    def list(
        self,
        *,
        sensor_id: str,
        sensor_partner_id: str,
        start_date_time: Optional[datetime.datetime] = None,
        end_date_time: Optional[datetime.datetime] = None,
        exclude_duplicate_events: bool = True,
        **kwargs: Any
    ) -> JSON:
        """Returns a list of sensor events data. Time span for query is limited to 90 days at a time.
        Returns last 90 days events when startDateTime and endDateTime are not provided.

        :keyword sensor_id: Id of the associated sensor. Required.
        :paramtype sensor_id: str
        :keyword sensor_partner_id: Id of the associated sensor partner. Required.
        :paramtype sensor_partner_id: str
        :keyword start_date_time: Search span start time of sensor events (inclusive), sample format:
         yyyy-MM-ddTHH:mm:ssZ.
         It is truncated upto seconds if fraction is provided. Default value is None.
        :paramtype start_date_time: ~datetime.datetime
        :keyword end_date_time: Search span end time of sensor events (inclusive), sample format:
         yyyy-MM-ddTHH:mm:ssZ.
         It is truncated upto seconds if fraction is provided. Default value is None.
        :paramtype end_date_time: ~datetime.datetime
        :keyword exclude_duplicate_events: Flag to exclude duplicate events and take the latest ones
         only (Default: true). Default value is True.
        :paramtype exclude_duplicate_events: bool
        :return: JSON object
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "value": [
                        {
                            "boundaryId": "str",  # Optional. Id of the associated
                              boundary.
                            "eventDateTime": "2020-02-20 00:00:00",  # Optional. DateTime
                              of sensor event observation.
                            "ingestionDateTime": "2020-02-20 00:00:00",  # Optional.
                              DateTime of sensor event ingestion to data store.
                            "measures": {
                                "str": {}  # Optional. Sensor measures.
                            },
                            "partyId": "str",  # Optional. Id of the associated party.
                            "sensorId": "str",  # Optional. Id of the sensor.
                            "sensorPartnerId": "str"  # Optional. Id of the sensor
                              partner.
                        }
                    ],
                    "nextLink": "str",  # Optional. Continuation link (absolute URI) to the next
                      page of results in the list.
                    "skipToken": "str"  # Optional. Token used in retrieving the next page. If
                      null, there are no additional pages.
                }
        """
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls = kwargs.pop("cls", None)  # type: ClsType[JSON]

        request = build_sensor_events_list_request(
            sensor_id=sensor_id,
            sensor_partner_id=sensor_partner_id,
            start_date_time=start_date_time,
            end_date_time=end_date_time,
            exclude_duplicate_events=exclude_duplicate_events,
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        request.url = self._client.format_url(request.url)  # type: ignore

        pipeline_response = self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
            request, stream=False, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if response.content:
            deserialized = response.json()
        else:
            deserialized = None

        if cls:
            return cls(pipeline_response, cast(JSON, deserialized), {})

        return cast(JSON, deserialized)


class SensorMappingsOperations:
    """
    .. warning::
        **DO NOT** instantiate this class directly.

        Instead, you should access the following operations through
        :class:`~azure.agrifood.farming.FarmBeatsClient`'s
        :attr:`sensor_mappings` attribute.
    """

    def __init__(self, *args, **kwargs):
        input_args = list(args)
        self._client = input_args.pop(0) if input_args else kwargs.pop("client")
        self._config = input_args.pop(0) if input_args else kwargs.pop("config")
        self._serialize = input_args.pop(0) if input_args else kwargs.pop("serializer")
        self._deserialize = input_args.pop(0) if input_args else kwargs.pop("deserializer")

    @distributed_trace
    def list(
        self,
        *,
        sensor_ids: Optional[List[str]] = None,
        sensor_partner_ids: Optional[List[str]] = None,
        party_ids: Optional[List[str]] = None,
        boundary_ids: Optional[List[str]] = None,
        ids: Optional[List[str]] = None,
        names: Optional[List[str]] = None,
        property_filters: Optional[List[str]] = None,
        statuses: Optional[List[str]] = None,
        min_created_date_time: Optional[datetime.datetime] = None,
        max_created_date_time: Optional[datetime.datetime] = None,
        min_last_modified_date_time: Optional[datetime.datetime] = None,
        max_last_modified_date_time: Optional[datetime.datetime] = None,
        skip_token: Optional[str] = None,
        **kwargs: Any
    ) -> Iterable[JSON]:
        """Returns a paginated list of sensor mapping resources.

        :keyword sensor_ids: Id of the sensors. Default value is None.
        :paramtype sensor_ids: list[str]
        :keyword sensor_partner_ids: Id of the sensor partners. Default value is None.
        :paramtype sensor_partner_ids: list[str]
        :keyword party_ids: Id of the parties. Default value is None.
        :paramtype party_ids: list[str]
        :keyword boundary_ids: Id of the boundaries. Default value is None.
        :paramtype boundary_ids: list[str]
        :keyword ids: Ids of the resource. Default value is None.
        :paramtype ids: list[str]
        :keyword names: Names of the resource. Default value is None.
        :paramtype names: list[str]
        :keyword property_filters: Filters on key-value pairs within the Properties object.
         eg. "{testKey} eq {testValue}". Default value is None.
        :paramtype property_filters: list[str]
        :keyword statuses: Statuses of the resource. Default value is None.
        :paramtype statuses: list[str]
        :keyword min_created_date_time: Minimum creation date of resource (inclusive). Default value is
         None.
        :paramtype min_created_date_time: ~datetime.datetime
        :keyword max_created_date_time: Maximum creation date of resource (inclusive). Default value is
         None.
        :paramtype max_created_date_time: ~datetime.datetime
        :keyword min_last_modified_date_time: Minimum last modified date of resource (inclusive).
         Default value is None.
        :paramtype min_last_modified_date_time: ~datetime.datetime
        :keyword max_last_modified_date_time: Maximum last modified date of resource (inclusive).
         Default value is None.
        :paramtype max_last_modified_date_time: ~datetime.datetime
        :keyword skip_token: Skip token for getting next set of results. Default value is None.
        :paramtype skip_token: str
        :return: An iterator like instance of JSON object
        :rtype: ~azure.core.paging.ItemPaged[JSON]
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "boundaryId": "str",  # Optional. Id of the associated boundary.
                    "createdBy": "str",  # Optional. Created by user/tenant id.
                    "createdDateTime": "2020-02-20 00:00:00",  # Optional. Date-time when
                      resource was created, sample format: yyyy-MM-ddTHH:mm:ssZ.
                    "description": "str",  # Optional. Textual description of the resource.
                    "eTag": "str",  # Optional. The ETag value to implement optimistic
                      concurrency.
                    "id": "str",  # Optional. Id of the resource.
                    "modifiedBy": "str",  # Optional. Modified by user/tenant id.
                    "modifiedDateTime": "2020-02-20 00:00:00",  # Optional. Date-time when
                      resource was last modified, sample format: yyyy-MM-ddTHH:mm:ssZ.
                    "name": "str",  # Optional. Name to identify resource.
                    "partyId": "str",  # Optional. Id of the associated party.
                    "properties": {
                        "str": {}  # Optional. A collection of key value pairs that belongs
                          to the resource."nEach pair must not have a key greater than 50
                          characters"nand must not have a value greater than 150 characters."nNote: A
                          maximum of 25 key value pairs can be provided for a resource and"nonly
                          string, numeral and datetime (yyyy-MM-ddTHH:mm:ssZ) values are supported.
                    },
                    "sensorId": "str",  # Optional. Id of the associated sensor.
                    "sensorPartnerId": "str",  # Optional. Id of the associated sensor partner.
                    "status": "str"  # Optional. Status of the resource.
                }
        """
        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls = kwargs.pop("cls", None)  # type: ClsType[JSON]

        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        def prepare_request(next_link=None):
            if not next_link:

                request = build_sensor_mappings_list_request(
                    sensor_ids=sensor_ids,
                    sensor_partner_ids=sensor_partner_ids,
                    party_ids=party_ids,
                    boundary_ids=boundary_ids,
                    ids=ids,
                    names=names,
                    property_filters=property_filters,
                    statuses=statuses,
                    min_created_date_time=min_created_date_time,
                    max_created_date_time=max_created_date_time,
                    min_last_modified_date_time=min_last_modified_date_time,
                    max_last_modified_date_time=max_last_modified_date_time,
                    skip_token=skip_token,
                    api_version=self._config.api_version,
                    headers=_headers,
                    params=_params,
                )
                request.url = self._client.format_url(request.url)  # type: ignore

            else:
                # make call to next link with the client's api-version
                _parsed_next_link = urlparse(next_link)
                _next_request_params = case_insensitive_dict(parse_qs(_parsed_next_link.query))
                _next_request_params["api-version"] = self._config.api_version
                request = HttpRequest("GET", urljoin(next_link, _parsed_next_link.path), params=_next_request_params)
                request.url = self._client.format_url(request.url)  # type: ignore

            return request

        def extract_data(pipeline_response):
            deserialized = pipeline_response.http_response.json()
            list_of_elem = deserialized["value"]
            if cls:
                list_of_elem = cls(list_of_elem)
            return deserialized.get("nextLink", None), iter(list_of_elem)

        def get_next(next_link=None):
            request = prepare_request(next_link)

            pipeline_response = self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
                request, stream=False, **kwargs
            )
            response = pipeline_response.http_response

            if response.status_code not in [200]:
                map_error(status_code=response.status_code, response=response, error_map=error_map)
                raise HttpResponseError(response=response)

            return pipeline_response

        return ItemPaged(get_next, extract_data)

    @overload
    def create_or_update(
        self,
        sensor_mapping_id: str,
        sensor_mapping_object: JSON,
        *,
        content_type: str = "application/merge-patch+json",
        **kwargs: Any
    ) -> JSON:
        """Create a sensor mapping entity.

        :param sensor_mapping_id: Id of the sensor mapping. Required.
        :type sensor_mapping_id: str
        :param sensor_mapping_object: Sensor mapping object details. Required.
        :type sensor_mapping_object: JSON
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/merge-patch+json".
        :paramtype content_type: str
        :return: JSON object
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                sensor_mapping_object = {
                    "boundaryId": "str",  # Optional. Id of the associated boundary.
                    "createdBy": "str",  # Optional. Created by user/tenant id.
                    "createdDateTime": "2020-02-20 00:00:00",  # Optional. Date-time when
                      resource was created, sample format: yyyy-MM-ddTHH:mm:ssZ.
                    "description": "str",  # Optional. Textual description of the resource.
                    "eTag": "str",  # Optional. The ETag value to implement optimistic
                      concurrency.
                    "id": "str",  # Optional. Id of the resource.
                    "modifiedBy": "str",  # Optional. Modified by user/tenant id.
                    "modifiedDateTime": "2020-02-20 00:00:00",  # Optional. Date-time when
                      resource was last modified, sample format: yyyy-MM-ddTHH:mm:ssZ.
                    "name": "str",  # Optional. Name to identify resource.
                    "partyId": "str",  # Optional. Id of the associated party.
                    "properties": {
                        "str": {}  # Optional. A collection of key value pairs that belongs
                          to the resource."nEach pair must not have a key greater than 50
                          characters"nand must not have a value greater than 150 characters."nNote: A
                          maximum of 25 key value pairs can be provided for a resource and"nonly
                          string, numeral and datetime (yyyy-MM-ddTHH:mm:ssZ) values are supported.
                    },
                    "sensorId": "str",  # Optional. Id of the associated sensor.
                    "sensorPartnerId": "str",  # Optional. Id of the associated sensor partner.
                    "status": "str"  # Optional. Status of the resource.
                }

                # response body for status code(s): 200, 201
                response == {
                    "boundaryId": "str",  # Optional. Id of the associated boundary.
                    "createdBy": "str",  # Optional. Created by user/tenant id.
                    "createdDateTime": "2020-02-20 00:00:00",  # Optional. Date-time when
                      resource was created, sample format: yyyy-MM-ddTHH:mm:ssZ.
                    "description": "str",  # Optional. Textual description of the resource.
                    "eTag": "str",  # Optional. The ETag value to implement optimistic
                      concurrency.
                    "id": "str",  # Optional. Id of the resource.
                    "modifiedBy": "str",  # Optional. Modified by user/tenant id.
                    "modifiedDateTime": "2020-02-20 00:00:00",  # Optional. Date-time when
                      resource was last modified, sample format: yyyy-MM-ddTHH:mm:ssZ.
                    "name": "str",  # Optional. Name to identify resource.
                    "partyId": "str",  # Optional. Id of the associated party.
                    "properties": {
                        "str": {}  # Optional. A collection of key value pairs that belongs
                          to the resource."nEach pair must not have a key greater than 50
                          characters"nand must not have a value greater than 150 characters."nNote: A
                          maximum of 25 key value pairs can be provided for a resource and"nonly
                          string, numeral and datetime (yyyy-MM-ddTHH:mm:ssZ) values are supported.
                    },
                    "sensorId": "str",  # Optional. Id of the associated sensor.
                    "sensorPartnerId": "str",  # Optional. Id of the associated sensor partner.
                    "status": "str"  # Optional. Status of the resource.
                }
        """

    @overload
    def create_or_update(
        self,
        sensor_mapping_id: str,
        sensor_mapping_object: IO,
        *,
        content_type: str = "application/merge-patch+json",
        **kwargs: Any
    ) -> JSON:
        """Create a sensor mapping entity.

        :param sensor_mapping_id: Id of the sensor mapping. Required.
        :type sensor_mapping_id: str
        :param sensor_mapping_object: Sensor mapping object details. Required.
        :type sensor_mapping_object: IO
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Default value is "application/merge-patch+json".
        :paramtype content_type: str
        :return: JSON object
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200, 201
                response == {
                    "boundaryId": "str",  # Optional. Id of the associated boundary.
                    "createdBy": "str",  # Optional. Created by user/tenant id.
                    "createdDateTime": "2020-02-20 00:00:00",  # Optional. Date-time when
                      resource was created, sample format: yyyy-MM-ddTHH:mm:ssZ.
                    "description": "str",  # Optional. Textual description of the resource.
                    "eTag": "str",  # Optional. The ETag value to implement optimistic
                      concurrency.
                    "id": "str",  # Optional. Id of the resource.
                    "modifiedBy": "str",  # Optional. Modified by user/tenant id.
                    "modifiedDateTime": "2020-02-20 00:00:00",  # Optional. Date-time when
                      resource was last modified, sample format: yyyy-MM-ddTHH:mm:ssZ.
                    "name": "str",  # Optional. Name to identify resource.
                    "partyId": "str",  # Optional. Id of the associated party.
                    "properties": {
                        "str": {}  # Optional. A collection of key value pairs that belongs
                          to the resource."nEach pair must not have a key greater than 50
                          characters"nand must not have a value greater than 150 characters."nNote: A
                          maximum of 25 key value pairs can be provided for a resource and"nonly
                          string, numeral and datetime (yyyy-MM-ddTHH:mm:ssZ) values are supported.
                    },
                    "sensorId": "str",  # Optional. Id of the associated sensor.
                    "sensorPartnerId": "str",  # Optional. Id of the associated sensor partner.
                    "status": "str"  # Optional. Status of the resource.
                }
        """

    @distributed_trace
    def create_or_update(self, sensor_mapping_id: str, sensor_mapping_object: Union[JSON, IO], **kwargs: Any) -> JSON:
        """Create a sensor mapping entity.

        :param sensor_mapping_id: Id of the sensor mapping. Required.
        :type sensor_mapping_id: str
        :param sensor_mapping_object: Sensor mapping object details. Is either a model type or a IO
         type. Required.
        :type sensor_mapping_object: JSON or IO
        :keyword content_type: Body Parameter content-type. Known values are:
         'application/merge-patch+json'. Default value is None.
        :paramtype content_type: str
        :return: JSON object
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200, 201
                response == {
                    "boundaryId": "str",  # Optional. Id of the associated boundary.
                    "createdBy": "str",  # Optional. Created by user/tenant id.
                    "createdDateTime": "2020-02-20 00:00:00",  # Optional. Date-time when
                      resource was created, sample format: yyyy-MM-ddTHH:mm:ssZ.
                    "description": "str",  # Optional. Textual description of the resource.
                    "eTag": "str",  # Optional. The ETag value to implement optimistic
                      concurrency.
                    "id": "str",  # Optional. Id of the resource.
                    "modifiedBy": "str",  # Optional. Modified by user/tenant id.
                    "modifiedDateTime": "2020-02-20 00:00:00",  # Optional. Date-time when
                      resource was last modified, sample format: yyyy-MM-ddTHH:mm:ssZ.
                    "name": "str",  # Optional. Name to identify resource.
                    "partyId": "str",  # Optional. Id of the associated party.
                    "properties": {
                        "str": {}  # Optional. A collection of key value pairs that belongs
                          to the resource."nEach pair must not have a key greater than 50
                          characters"nand must not have a value greater than 150 characters."nNote: A
                          maximum of 25 key value pairs can be provided for a resource and"nonly
                          string, numeral and datetime (yyyy-MM-ddTHH:mm:ssZ) values are supported.
                    },
                    "sensorId": "str",  # Optional. Id of the associated sensor.
                    "sensorPartnerId": "str",  # Optional. Id of the associated sensor partner.
                    "status": "str"  # Optional. Status of the resource.
                }
        """
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type = kwargs.pop("content_type", _headers.pop("Content-Type", None))  # type: Optional[str]
        cls = kwargs.pop("cls", None)  # type: ClsType[JSON]

        content_type = content_type or "application/merge-patch+json"
        _json = None
        _content = None
        if isinstance(sensor_mapping_object, (IO, bytes)):
            _content = sensor_mapping_object
        else:
            _json = sensor_mapping_object

        request = build_sensor_mappings_create_or_update_request(
            sensor_mapping_id=sensor_mapping_id,
            content_type=content_type,
            api_version=self._config.api_version,
            json=_json,
            content=_content,
            headers=_headers,
            params=_params,
        )
        request.url = self._client.format_url(request.url)  # type: ignore

        pipeline_response = self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
            request, stream=False, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200, 201]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if response.status_code == 200:
            if response.content:
                deserialized = response.json()
            else:
                deserialized = None

        if response.status_code == 201:
            if response.content:
                deserialized = response.json()
            else:
                deserialized = None

        if cls:
            return cls(pipeline_response, cast(JSON, deserialized), {})

        return cast(JSON, deserialized)

    @distributed_trace
    def get(self, sensor_mapping_id: str, **kwargs: Any) -> JSON:
        """Gets a sensor mapping entity.

        :param sensor_mapping_id: Id of the sensor mapping resource. Required.
        :type sensor_mapping_id: str
        :return: JSON object
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "boundaryId": "str",  # Optional. Id of the associated boundary.
                    "createdBy": "str",  # Optional. Created by user/tenant id.
                    "createdDateTime": "2020-02-20 00:00:00",  # Optional. Date-time when
                      resource was created, sample format: yyyy-MM-ddTHH:mm:ssZ.
                    "description": "str",  # Optional. Textual description of the resource.
                    "eTag": "str",  # Optional. The ETag value to implement optimistic
                      concurrency.
                    "id": "str",  # Optional. Id of the resource.
                    "modifiedBy": "str",  # Optional. Modified by user/tenant id.
                    "modifiedDateTime": "2020-02-20 00:00:00",  # Optional. Date-time when
                      resource was last modified, sample format: yyyy-MM-ddTHH:mm:ssZ.
                    "name": "str",  # Optional. Name to identify resource.
                    "partyId": "str",  # Optional. Id of the associated party.
                    "properties": {
                        "str": {}  # Optional. A collection of key value pairs that belongs
                          to the resource."nEach pair must not have a key greater than 50
                          characters"nand must not have a value greater than 150 characters."nNote: A
                          maximum of 25 key value pairs can be provided for a resource and"nonly
                          string, numeral and datetime (yyyy-MM-ddTHH:mm:ssZ) values are supported.
                    },
                    "sensorId": "str",  # Optional. Id of the associated sensor.
                    "sensorPartnerId": "str",  # Optional. Id of the associated sensor partner.
                    "status": "str"  # Optional. Status of the resource.
                }
        """
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls = kwargs.pop("cls", None)  # type: ClsType[JSON]

        request = build_sensor_mappings_get_request(
            sensor_mapping_id=sensor_mapping_id,
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        request.url = self._client.format_url(request.url)  # type: ignore

        pipeline_response = self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
            request, stream=False, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if response.content:
            deserialized = response.json()
        else:
            deserialized = None

        if cls:
            return cls(pipeline_response, cast(JSON, deserialized), {})

        return cast(JSON, deserialized)

    @distributed_trace
    def delete(self, sensor_mapping_id: str, **kwargs: Any) -> None:  # pylint: disable=inconsistent-return-statements
        """Deletes a sensor mapping entity.

        :param sensor_mapping_id: Id of the sensor mapping resource. Required.
        :type sensor_mapping_id: str
        :return: None
        :rtype: None
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls = kwargs.pop("cls", None)  # type: ClsType[None]

        request = build_sensor_mappings_delete_request(
            sensor_mapping_id=sensor_mapping_id,
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        request.url = self._client.format_url(request.url)  # type: ignore

        pipeline_response = self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
            request, stream=False, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [204]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if cls:
            return cls(pipeline_response, None, {})


class SensorPartnerIntegrationsOperations:
    """
    .. warning::
        **DO NOT** instantiate this class directly.

        Instead, you should access the following operations through
        :class:`~azure.agrifood.farming.FarmBeatsClient`'s
        :attr:`sensor_partner_integrations` attribute.
    """

    def __init__(self, *args, **kwargs):
        input_args = list(args)
        self._client = input_args.pop(0) if input_args else kwargs.pop("client")
        self._config = input_args.pop(0) if input_args else kwargs.pop("config")
        self._serialize = input_args.pop(0) if input_args else kwargs.pop("serializer")
        self._deserialize = input_args.pop(0) if input_args else kwargs.pop("deserializer")

    @distributed_trace
    def list(
        self,
        sensor_partner_id: str,
        *,
        integration_ids: Optional[List[str]] = None,
        party_ids: Optional[List[str]] = None,
        ids: Optional[List[str]] = None,
        names: Optional[List[str]] = None,
        property_filters: Optional[List[str]] = None,
        statuses: Optional[List[str]] = None,
        min_created_date_time: Optional[datetime.datetime] = None,
        max_created_date_time: Optional[datetime.datetime] = None,
        min_last_modified_date_time: Optional[datetime.datetime] = None,
        max_last_modified_date_time: Optional[datetime.datetime] = None,
        skip_token: Optional[str] = None,
        **kwargs: Any
    ) -> Iterable[JSON]:
        """Gets partner integration models.

        :param sensor_partner_id: Id of the associated sensor partner. Required.
        :type sensor_partner_id: str
        :keyword integration_ids: Ids of the partner integration models. Default value is None.
        :paramtype integration_ids: list[str]
        :keyword party_ids: Ids of the parties. Default value is None.
        :paramtype party_ids: list[str]
        :keyword ids: Ids of the resource. Default value is None.
        :paramtype ids: list[str]
        :keyword names: Names of the resource. Default value is None.
        :paramtype names: list[str]
        :keyword property_filters: Filters on key-value pairs within the Properties object.
         eg. "{testKey} eq {testValue}". Default value is None.
        :paramtype property_filters: list[str]
        :keyword statuses: Statuses of the resource. Default value is None.
        :paramtype statuses: list[str]
        :keyword min_created_date_time: Minimum creation date of resource (inclusive). Default value is
         None.
        :paramtype min_created_date_time: ~datetime.datetime
        :keyword max_created_date_time: Maximum creation date of resource (inclusive). Default value is
         None.
        :paramtype max_created_date_time: ~datetime.datetime
        :keyword min_last_modified_date_time: Minimum last modified date of resource (inclusive).
         Default value is None.
        :paramtype min_last_modified_date_time: ~datetime.datetime
        :keyword max_last_modified_date_time: Maximum last modified date of resource (inclusive).
         Default value is None.
        :paramtype max_last_modified_date_time: ~datetime.datetime
        :keyword skip_token: Skip token for getting next set of results. Default value is None.
        :paramtype skip_token: str
        :return: An iterator like instance of JSON object
        :rtype: ~azure.core.paging.ItemPaged[JSON]
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "createdBy": "str",  # Optional. Created by user/tenant id.
                    "createdDateTime": "2020-02-20 00:00:00",  # Optional. Date-time when
                      resource was created, sample format: yyyy-MM-ddTHH:mm:ssZ.
                    "description": "str",  # Optional. Textual description of the resource.
                    "eTag": "str",  # Optional. The ETag value to implement optimistic
                      concurrency.
                    "id": "str",  # Optional. Id of the resource.
                    "integrationId": "str",  # Optional. Id of the integration.
                    "modifiedBy": "str",  # Optional. Modified by user/tenant id.
                    "modifiedDateTime": "2020-02-20 00:00:00",  # Optional. Date-time when
                      resource was last modified, sample format: yyyy-MM-ddTHH:mm:ssZ.
                    "name": "str",  # Optional. Name to identify resource.
                    "partyId": "str",  # Optional. Id of the party.
                    "properties": {
                        "str": {}  # Optional. A collection of key value pairs that belongs
                          to the resource."nEach pair must not have a key greater than 50
                          characters"nand must not have a value greater than 150 characters."nNote: A
                          maximum of 25 key value pairs can be provided for a resource and"nonly
                          string, numeral and datetime (yyyy-MM-ddTHH:mm:ssZ) values are supported.
                    },
                    "sensorPartnerId": "str",  # Optional. Id of the associated sensor partner.
                    "status": "str"  # Optional. Status of the resource.
                }
        """
        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls = kwargs.pop("cls", None)  # type: ClsType[JSON]

        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        def prepare_request(next_link=None):
            if not next_link:

                request = build_sensor_partner_integrations_list_request(
                    sensor_partner_id=sensor_partner_id,
                    integration_ids=integration_ids,
                    party_ids=party_ids,
                    ids=ids,
                    names=names,
                    property_filters=property_filters,
                    statuses=statuses,
                    min_created_date_time=min_created_date_time,
                    max_created_date_time=max_created_date_time,
                    min_last_modified_date_time=min_last_modified_date_time,
                    max_last_modified_date_time=max_last_modified_date_time,
                    skip_token=skip_token,
                    api_version=self._config.api_version,
                    headers=_headers,
                    params=_params,
                )
                request.url = self._client.format_url(request.url)  # type: ignore

            else:
                # make call to next link with the client's api-version
                _parsed_next_link = urlparse(next_link)
                _next_request_params = case_insensitive_dict(parse_qs(_parsed_next_link.query))
                _next_request_params["api-version"] = self._config.api_version
                request = HttpRequest("GET", urljoin(next_link, _parsed_next_link.path), params=_next_request_params)
                request.url = self._client.format_url(request.url)  # type: ignore

            return request

        def extract_data(pipeline_response):
            deserialized = pipeline_response.http_response.json()
            list_of_elem = deserialized["value"]
            if cls:
                list_of_elem = cls(list_of_elem)
            return deserialized.get("nextLink", None), iter(list_of_elem)

        def get_next(next_link=None):
            request = prepare_request(next_link)

            pipeline_response = self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
                request, stream=False, **kwargs
            )
            response = pipeline_response.http_response

            if response.status_code not in [200]:
                map_error(status_code=response.status_code, response=response, error_map=error_map)
                raise HttpResponseError(response=response)

            return pipeline_response

        return ItemPaged(get_next, extract_data)

    @overload
    def create_or_update(
        self,
        sensor_partner_id: str,
        integration_id: str,
        sensor_partner_integration_model: JSON,
        *,
        content_type: str = "application/merge-patch+json",
        **kwargs: Any
    ) -> JSON:
        """Create or update an integration with a sensor partner.

        :param sensor_partner_id: Id of the sensor partner. Required.
        :type sensor_partner_id: str
        :param integration_id: Id of the integration to be created. Required.
        :type integration_id: str
        :param sensor_partner_integration_model: Partner integration model. Required.
        :type sensor_partner_integration_model: JSON
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/merge-patch+json".
        :paramtype content_type: str
        :return: JSON object
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                sensor_partner_integration_model = {
                    "createdBy": "str",  # Optional. Created by user/tenant id.
                    "createdDateTime": "2020-02-20 00:00:00",  # Optional. Date-time when
                      resource was created, sample format: yyyy-MM-ddTHH:mm:ssZ.
                    "description": "str",  # Optional. Textual description of the resource.
                    "eTag": "str",  # Optional. The ETag value to implement optimistic
                      concurrency.
                    "id": "str",  # Optional. Id of the resource.
                    "integrationId": "str",  # Optional. Id of the integration.
                    "modifiedBy": "str",  # Optional. Modified by user/tenant id.
                    "modifiedDateTime": "2020-02-20 00:00:00",  # Optional. Date-time when
                      resource was last modified, sample format: yyyy-MM-ddTHH:mm:ssZ.
                    "name": "str",  # Optional. Name to identify resource.
                    "partyId": "str",  # Optional. Id of the party.
                    "properties": {
                        "str": {}  # Optional. A collection of key value pairs that belongs
                          to the resource."nEach pair must not have a key greater than 50
                          characters"nand must not have a value greater than 150 characters."nNote: A
                          maximum of 25 key value pairs can be provided for a resource and"nonly
                          string, numeral and datetime (yyyy-MM-ddTHH:mm:ssZ) values are supported.
                    },
                    "sensorPartnerId": "str",  # Optional. Id of the associated sensor partner.
                    "status": "str"  # Optional. Status of the resource.
                }

                # response body for status code(s): 200, 201
                response == {
                    "createdBy": "str",  # Optional. Created by user/tenant id.
                    "createdDateTime": "2020-02-20 00:00:00",  # Optional. Date-time when
                      resource was created, sample format: yyyy-MM-ddTHH:mm:ssZ.
                    "description": "str",  # Optional. Textual description of the resource.
                    "eTag": "str",  # Optional. The ETag value to implement optimistic
                      concurrency.
                    "id": "str",  # Optional. Id of the resource.
                    "integrationId": "str",  # Optional. Id of the integration.
                    "modifiedBy": "str",  # Optional. Modified by user/tenant id.
                    "modifiedDateTime": "2020-02-20 00:00:00",  # Optional. Date-time when
                      resource was last modified, sample format: yyyy-MM-ddTHH:mm:ssZ.
                    "name": "str",  # Optional. Name to identify resource.
                    "partyId": "str",  # Optional. Id of the party.
                    "properties": {
                        "str": {}  # Optional. A collection of key value pairs that belongs
                          to the resource."nEach pair must not have a key greater than 50
                          characters"nand must not have a value greater than 150 characters."nNote: A
                          maximum of 25 key value pairs can be provided for a resource and"nonly
                          string, numeral and datetime (yyyy-MM-ddTHH:mm:ssZ) values are supported.
                    },
                    "sensorPartnerId": "str",  # Optional. Id of the associated sensor partner.
                    "status": "str"  # Optional. Status of the resource.
                }
        """

    @overload
    def create_or_update(
        self,
        sensor_partner_id: str,
        integration_id: str,
        sensor_partner_integration_model: IO,
        *,
        content_type: str = "application/merge-patch+json",
        **kwargs: Any
    ) -> JSON:
        """Create or update an integration with a sensor partner.

        :param sensor_partner_id: Id of the sensor partner. Required.
        :type sensor_partner_id: str
        :param integration_id: Id of the integration to be created. Required.
        :type integration_id: str
        :param sensor_partner_integration_model: Partner integration model. Required.
        :type sensor_partner_integration_model: IO
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Default value is "application/merge-patch+json".
        :paramtype content_type: str
        :return: JSON object
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200, 201
                response == {
                    "createdBy": "str",  # Optional. Created by user/tenant id.
                    "createdDateTime": "2020-02-20 00:00:00",  # Optional. Date-time when
                      resource was created, sample format: yyyy-MM-ddTHH:mm:ssZ.
                    "description": "str",  # Optional. Textual description of the resource.
                    "eTag": "str",  # Optional. The ETag value to implement optimistic
                      concurrency.
                    "id": "str",  # Optional. Id of the resource.
                    "integrationId": "str",  # Optional. Id of the integration.
                    "modifiedBy": "str",  # Optional. Modified by user/tenant id.
                    "modifiedDateTime": "2020-02-20 00:00:00",  # Optional. Date-time when
                      resource was last modified, sample format: yyyy-MM-ddTHH:mm:ssZ.
                    "name": "str",  # Optional. Name to identify resource.
                    "partyId": "str",  # Optional. Id of the party.
                    "properties": {
                        "str": {}  # Optional. A collection of key value pairs that belongs
                          to the resource."nEach pair must not have a key greater than 50
                          characters"nand must not have a value greater than 150 characters."nNote: A
                          maximum of 25 key value pairs can be provided for a resource and"nonly
                          string, numeral and datetime (yyyy-MM-ddTHH:mm:ssZ) values are supported.
                    },
                    "sensorPartnerId": "str",  # Optional. Id of the associated sensor partner.
                    "status": "str"  # Optional. Status of the resource.
                }
        """

    @distributed_trace
    def create_or_update(
        self,
        sensor_partner_id: str,
        integration_id: str,
        sensor_partner_integration_model: Union[JSON, IO],
        **kwargs: Any
    ) -> JSON:
        """Create or update an integration with a sensor partner.

        :param sensor_partner_id: Id of the sensor partner. Required.
        :type sensor_partner_id: str
        :param integration_id: Id of the integration to be created. Required.
        :type integration_id: str
        :param sensor_partner_integration_model: Partner integration model. Is either a model type or a
         IO type. Required.
        :type sensor_partner_integration_model: JSON or IO
        :keyword content_type: Body Parameter content-type. Known values are:
         'application/merge-patch+json'. Default value is None.
        :paramtype content_type: str
        :return: JSON object
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200, 201
                response == {
                    "createdBy": "str",  # Optional. Created by user/tenant id.
                    "createdDateTime": "2020-02-20 00:00:00",  # Optional. Date-time when
                      resource was created, sample format: yyyy-MM-ddTHH:mm:ssZ.
                    "description": "str",  # Optional. Textual description of the resource.
                    "eTag": "str",  # Optional. The ETag value to implement optimistic
                      concurrency.
                    "id": "str",  # Optional. Id of the resource.
                    "integrationId": "str",  # Optional. Id of the integration.
                    "modifiedBy": "str",  # Optional. Modified by user/tenant id.
                    "modifiedDateTime": "2020-02-20 00:00:00",  # Optional. Date-time when
                      resource was last modified, sample format: yyyy-MM-ddTHH:mm:ssZ.
                    "name": "str",  # Optional. Name to identify resource.
                    "partyId": "str",  # Optional. Id of the party.
                    "properties": {
                        "str": {}  # Optional. A collection of key value pairs that belongs
                          to the resource."nEach pair must not have a key greater than 50
                          characters"nand must not have a value greater than 150 characters."nNote: A
                          maximum of 25 key value pairs can be provided for a resource and"nonly
                          string, numeral and datetime (yyyy-MM-ddTHH:mm:ssZ) values are supported.
                    },
                    "sensorPartnerId": "str",  # Optional. Id of the associated sensor partner.
                    "status": "str"  # Optional. Status of the resource.
                }
        """
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type = kwargs.pop("content_type", _headers.pop("Content-Type", None))  # type: Optional[str]
        cls = kwargs.pop("cls", None)  # type: ClsType[JSON]

        content_type = content_type or "application/merge-patch+json"
        _json = None
        _content = None
        if isinstance(sensor_partner_integration_model, (IO, bytes)):
            _content = sensor_partner_integration_model
        else:
            _json = sensor_partner_integration_model

        request = build_sensor_partner_integrations_create_or_update_request(
            sensor_partner_id=sensor_partner_id,
            integration_id=integration_id,
            content_type=content_type,
            api_version=self._config.api_version,
            json=_json,
            content=_content,
            headers=_headers,
            params=_params,
        )
        request.url = self._client.format_url(request.url)  # type: ignore

        pipeline_response = self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
            request, stream=False, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200, 201]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if response.status_code == 200:
            if response.content:
                deserialized = response.json()
            else:
                deserialized = None

        if response.status_code == 201:
            if response.content:
                deserialized = response.json()
            else:
                deserialized = None

        if cls:
            return cls(pipeline_response, cast(JSON, deserialized), {})

        return cast(JSON, deserialized)

    @distributed_trace
    def get(self, sensor_partner_id: str, integration_id: str, **kwargs: Any) -> JSON:
        """Gets a partner integration model entity.

        :param sensor_partner_id: Id of the sensor partner. Required.
        :type sensor_partner_id: str
        :param integration_id: Id of the integration object. Required.
        :type integration_id: str
        :return: JSON object
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "createdBy": "str",  # Optional. Created by user/tenant id.
                    "createdDateTime": "2020-02-20 00:00:00",  # Optional. Date-time when
                      resource was created, sample format: yyyy-MM-ddTHH:mm:ssZ.
                    "description": "str",  # Optional. Textual description of the resource.
                    "eTag": "str",  # Optional. The ETag value to implement optimistic
                      concurrency.
                    "id": "str",  # Optional. Id of the resource.
                    "integrationId": "str",  # Optional. Id of the integration.
                    "modifiedBy": "str",  # Optional. Modified by user/tenant id.
                    "modifiedDateTime": "2020-02-20 00:00:00",  # Optional. Date-time when
                      resource was last modified, sample format: yyyy-MM-ddTHH:mm:ssZ.
                    "name": "str",  # Optional. Name to identify resource.
                    "partyId": "str",  # Optional. Id of the party.
                    "properties": {
                        "str": {}  # Optional. A collection of key value pairs that belongs
                          to the resource."nEach pair must not have a key greater than 50
                          characters"nand must not have a value greater than 150 characters."nNote: A
                          maximum of 25 key value pairs can be provided for a resource and"nonly
                          string, numeral and datetime (yyyy-MM-ddTHH:mm:ssZ) values are supported.
                    },
                    "sensorPartnerId": "str",  # Optional. Id of the associated sensor partner.
                    "status": "str"  # Optional. Status of the resource.
                }
        """
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls = kwargs.pop("cls", None)  # type: ClsType[JSON]

        request = build_sensor_partner_integrations_get_request(
            sensor_partner_id=sensor_partner_id,
            integration_id=integration_id,
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        request.url = self._client.format_url(request.url)  # type: ignore

        pipeline_response = self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
            request, stream=False, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if response.content:
            deserialized = response.json()
        else:
            deserialized = None

        if cls:
            return cls(pipeline_response, cast(JSON, deserialized), {})

        return cast(JSON, deserialized)

    @distributed_trace
    def delete(  # pylint: disable=inconsistent-return-statements
        self, sensor_partner_id: str, integration_id: str, **kwargs: Any
    ) -> None:
        """Deletes a partner integration model entity.

        :param sensor_partner_id: Id of the sensor partner. Required.
        :type sensor_partner_id: str
        :param integration_id: Id of the integration to be deleted. Required.
        :type integration_id: str
        :return: None
        :rtype: None
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls = kwargs.pop("cls", None)  # type: ClsType[None]

        request = build_sensor_partner_integrations_delete_request(
            sensor_partner_id=sensor_partner_id,
            integration_id=integration_id,
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        request.url = self._client.format_url(request.url)  # type: ignore

        pipeline_response = self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
            request, stream=False, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [204]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if cls:
            return cls(pipeline_response, None, {})

    @distributed_trace
    def check_consent(self, sensor_partner_id: str, integration_id: str, *, key: str, **kwargs: Any) -> JSON:
        """Checks consent for partner integration.

        :param sensor_partner_id: Id of the sensor partner. Required.
        :type sensor_partner_id: str
        :param integration_id: Id of the integration object. Required.
        :type integration_id: str
        :keyword key: Partner integration key. Required.
        :paramtype key: str
        :return: JSON object
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "consented": bool,  # Optional. Flag to determine the status of partner
                      integration consent.
                    "integrationId": "str",  # Optional. Id of the integration.
                    "sensorPartnerId": "str"  # Optional. Id of the associated sensor partner.
                }
        """
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls = kwargs.pop("cls", None)  # type: ClsType[JSON]

        request = build_sensor_partner_integrations_check_consent_request(
            sensor_partner_id=sensor_partner_id,
            integration_id=integration_id,
            key=key,
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        request.url = self._client.format_url(request.url)  # type: ignore

        pipeline_response = self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
            request, stream=False, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if response.content:
            deserialized = response.json()
        else:
            deserialized = None

        if cls:
            return cls(pipeline_response, cast(JSON, deserialized), {})

        return cast(JSON, deserialized)

    @distributed_trace
    def generate_consent_link(self, sensor_partner_id: str, integration_id: str, **kwargs: Any) -> JSON:
        """Generates partner integration consent link.

        :param sensor_partner_id: Id of the sensor partner. Required.
        :type sensor_partner_id: str
        :param integration_id: Id of the integration object. Required.
        :type integration_id: str
        :return: JSON object
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "consentExpiryDateTime": "2020-02-20 00:00:00",  # Optional. Consent expiry
                      date time, sample format: yyyy-MM-ddTHH:mm:ssZ.
                    "consentLink": "str"  # Optional. Consent link.
                }
        """
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls = kwargs.pop("cls", None)  # type: ClsType[JSON]

        request = build_sensor_partner_integrations_generate_consent_link_request(
            sensor_partner_id=sensor_partner_id,
            integration_id=integration_id,
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        request.url = self._client.format_url(request.url)  # type: ignore

        pipeline_response = self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
            request, stream=False, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if response.content:
            deserialized = response.json()
        else:
            deserialized = None

        if cls:
            return cls(pipeline_response, cast(JSON, deserialized), {})

        return cast(JSON, deserialized)


class SensorsOperations:
    """
    .. warning::
        **DO NOT** instantiate this class directly.

        Instead, you should access the following operations through
        :class:`~azure.agrifood.farming.FarmBeatsClient`'s
        :attr:`sensors` attribute.
    """

    def __init__(self, *args, **kwargs):
        input_args = list(args)
        self._client = input_args.pop(0) if input_args else kwargs.pop("client")
        self._config = input_args.pop(0) if input_args else kwargs.pop("config")
        self._serialize = input_args.pop(0) if input_args else kwargs.pop("serializer")
        self._deserialize = input_args.pop(0) if input_args else kwargs.pop("deserializer")

    @distributed_trace
    def list(
        self,
        sensor_partner_id: str,
        *,
        sensor_data_model_ids: Optional[List[str]] = None,
        sensor_mapping_ids: Optional[List[str]] = None,
        device_ids: Optional[List[str]] = None,
        ids: Optional[List[str]] = None,
        names: Optional[List[str]] = None,
        property_filters: Optional[List[str]] = None,
        statuses: Optional[List[str]] = None,
        min_created_date_time: Optional[datetime.datetime] = None,
        max_created_date_time: Optional[datetime.datetime] = None,
        min_last_modified_date_time: Optional[datetime.datetime] = None,
        max_last_modified_date_time: Optional[datetime.datetime] = None,
        skip_token: Optional[str] = None,
        **kwargs: Any
    ) -> Iterable[JSON]:
        """Returns a paginated list of sensor resources.

        :param sensor_partner_id: Id of the associated sensor partner. Required.
        :type sensor_partner_id: str
        :keyword sensor_data_model_ids: Id's of the sensor data models. Default value is None.
        :paramtype sensor_data_model_ids: list[str]
        :keyword sensor_mapping_ids: Ids of the sensor mappings. Default value is None.
        :paramtype sensor_mapping_ids: list[str]
        :keyword device_ids: Id's of the devices. Default value is None.
        :paramtype device_ids: list[str]
        :keyword ids: Ids of the resource. Default value is None.
        :paramtype ids: list[str]
        :keyword names: Names of the resource. Default value is None.
        :paramtype names: list[str]
        :keyword property_filters: Filters on key-value pairs within the Properties object.
         eg. "{testKey} eq {testValue}". Default value is None.
        :paramtype property_filters: list[str]
        :keyword statuses: Statuses of the resource. Default value is None.
        :paramtype statuses: list[str]
        :keyword min_created_date_time: Minimum creation date of resource (inclusive). Default value is
         None.
        :paramtype min_created_date_time: ~datetime.datetime
        :keyword max_created_date_time: Maximum creation date of resource (inclusive). Default value is
         None.
        :paramtype max_created_date_time: ~datetime.datetime
        :keyword min_last_modified_date_time: Minimum last modified date of resource (inclusive).
         Default value is None.
        :paramtype min_last_modified_date_time: ~datetime.datetime
        :keyword max_last_modified_date_time: Maximum last modified date of resource (inclusive).
         Default value is None.
        :paramtype max_last_modified_date_time: ~datetime.datetime
        :keyword skip_token: Skip token for getting next set of results. Default value is None.
        :paramtype skip_token: str
        :return: An iterator like instance of JSON object
        :rtype: ~azure.core.paging.ItemPaged[JSON]
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "createdBy": "str",  # Optional. Created by user/tenant id.
                    "createdDateTime": "2020-02-20 00:00:00",  # Optional. Date-time when
                      resource was created, sample format: yyyy-MM-ddTHH:mm:ssZ.
                    "depthInMeters": [
                        0.0  # Optional. Depth of each sensor measure in meters."nLike sensor
                          moisture at 2m, 4m, 6m.
                    ],
                    "description": "str",  # Optional. Textual description of the resource.
                    "deviceId": "str",  # Optional. Id of the associated device.
                    "eTag": "str",  # Optional. The ETag value to implement optimistic
                      concurrency.
                    "hardwareId": "str",  # Optional. Id of the associated hardware.
                    "id": "str",  # Optional. Id of the resource.
                    "integrationId": "str",  # Optional. Integration id for the device.
                    "location": {
                        "latitude": 0.0,  # Latitude of the location. Required.
                        "longitude": 0.0  # Longitude of the location. Required.
                    },
                    "modifiedBy": "str",  # Optional. Modified by user/tenant id.
                    "modifiedDateTime": "2020-02-20 00:00:00",  # Optional. Date-time when
                      resource was last modified, sample format: yyyy-MM-ddTHH:mm:ssZ.
                    "name": "str",  # Optional. Name to identify resource.
                    "port": {
                        "name": "str",  # Optional. Name of the port.
                        "type": "str"  # Optional. Type of port digital/analog.
                    },
                    "properties": {
                        "str": {}  # Optional. A collection of key value pairs that belongs
                          to the resource."nEach pair must not have a key greater than 50
                          characters"nand must not have a value greater than 150 characters."nNote: A
                          maximum of 25 key value pairs can be provided for a resource and"nonly
                          string, numeral and datetime (yyyy-MM-ddTHH:mm:ssZ) values are supported.
                    },
                    "sensorDataModelId": "str",  # Optional. Id of the associated sensor data
                      model.
                    "sensorPartnerId": "str",  # Optional. Id of the associated sensor partner.
                    "status": "str",  # Optional. Status of the resource.
                    "type": "str"  # Optional. Type of sensor.
                }
        """
        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls = kwargs.pop("cls", None)  # type: ClsType[JSON]

        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        def prepare_request(next_link=None):
            if not next_link:

                request = build_sensors_list_request(
                    sensor_partner_id=sensor_partner_id,
                    sensor_data_model_ids=sensor_data_model_ids,
                    sensor_mapping_ids=sensor_mapping_ids,
                    device_ids=device_ids,
                    ids=ids,
                    names=names,
                    property_filters=property_filters,
                    statuses=statuses,
                    min_created_date_time=min_created_date_time,
                    max_created_date_time=max_created_date_time,
                    min_last_modified_date_time=min_last_modified_date_time,
                    max_last_modified_date_time=max_last_modified_date_time,
                    skip_token=skip_token,
                    api_version=self._config.api_version,
                    headers=_headers,
                    params=_params,
                )
                request.url = self._client.format_url(request.url)  # type: ignore

            else:
                # make call to next link with the client's api-version
                _parsed_next_link = urlparse(next_link)
                _next_request_params = case_insensitive_dict(parse_qs(_parsed_next_link.query))
                _next_request_params["api-version"] = self._config.api_version
                request = HttpRequest("GET", urljoin(next_link, _parsed_next_link.path), params=_next_request_params)
                request.url = self._client.format_url(request.url)  # type: ignore

            return request

        def extract_data(pipeline_response):
            deserialized = pipeline_response.http_response.json()
            list_of_elem = deserialized["value"]
            if cls:
                list_of_elem = cls(list_of_elem)
            return deserialized.get("nextLink", None), iter(list_of_elem)

        def get_next(next_link=None):
            request = prepare_request(next_link)

            pipeline_response = self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
                request, stream=False, **kwargs
            )
            response = pipeline_response.http_response

            if response.status_code not in [200]:
                map_error(status_code=response.status_code, response=response, error_map=error_map)
                raise HttpResponseError(response=response)

            return pipeline_response

        return ItemPaged(get_next, extract_data)

    @overload
    def create_or_update(
        self,
        sensor_partner_id: str,
        sensor_id: str,
        sensor_details: JSON,
        *,
        content_type: str = "application/merge-patch+json",
        **kwargs: Any
    ) -> JSON:
        """Create a sensor entity.

        :param sensor_partner_id: Id of the sensor partner. Required.
        :type sensor_partner_id: str
        :param sensor_id: Id of the sensor resource. Required.
        :type sensor_id: str
        :param sensor_details: Sensor object details. Required.
        :type sensor_details: JSON
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/merge-patch+json".
        :paramtype content_type: str
        :return: JSON object
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                sensor_details = {
                    "createdBy": "str",  # Optional. Created by user/tenant id.
                    "createdDateTime": "2020-02-20 00:00:00",  # Optional. Date-time when
                      resource was created, sample format: yyyy-MM-ddTHH:mm:ssZ.
                    "depthInMeters": [
                        0.0  # Optional. Depth of each sensor measure in meters."nLike sensor
                          moisture at 2m, 4m, 6m.
                    ],
                    "description": "str",  # Optional. Textual description of the resource.
                    "deviceId": "str",  # Optional. Id of the associated device.
                    "eTag": "str",  # Optional. The ETag value to implement optimistic
                      concurrency.
                    "hardwareId": "str",  # Optional. Id of the associated hardware.
                    "id": "str",  # Optional. Id of the resource.
                    "integrationId": "str",  # Optional. Integration id for the device.
                    "location": {
                        "latitude": 0.0,  # Latitude of the location. Required.
                        "longitude": 0.0  # Longitude of the location. Required.
                    },
                    "modifiedBy": "str",  # Optional. Modified by user/tenant id.
                    "modifiedDateTime": "2020-02-20 00:00:00",  # Optional. Date-time when
                      resource was last modified, sample format: yyyy-MM-ddTHH:mm:ssZ.
                    "name": "str",  # Optional. Name to identify resource.
                    "port": {
                        "name": "str",  # Optional. Name of the port.
                        "type": "str"  # Optional. Type of port digital/analog.
                    },
                    "properties": {
                        "str": {}  # Optional. A collection of key value pairs that belongs
                          to the resource."nEach pair must not have a key greater than 50
                          characters"nand must not have a value greater than 150 characters."nNote: A
                          maximum of 25 key value pairs can be provided for a resource and"nonly
                          string, numeral and datetime (yyyy-MM-ddTHH:mm:ssZ) values are supported.
                    },
                    "sensorDataModelId": "str",  # Optional. Id of the associated sensor data
                      model.
                    "sensorPartnerId": "str",  # Optional. Id of the associated sensor partner.
                    "status": "str",  # Optional. Status of the resource.
                    "type": "str"  # Optional. Type of sensor.
                }

                # response body for status code(s): 200, 201
                response == {
                    "createdBy": "str",  # Optional. Created by user/tenant id.
                    "createdDateTime": "2020-02-20 00:00:00",  # Optional. Date-time when
                      resource was created, sample format: yyyy-MM-ddTHH:mm:ssZ.
                    "depthInMeters": [
                        0.0  # Optional. Depth of each sensor measure in meters."nLike sensor
                          moisture at 2m, 4m, 6m.
                    ],
                    "description": "str",  # Optional. Textual description of the resource.
                    "deviceId": "str",  # Optional. Id of the associated device.
                    "eTag": "str",  # Optional. The ETag value to implement optimistic
                      concurrency.
                    "hardwareId": "str",  # Optional. Id of the associated hardware.
                    "id": "str",  # Optional. Id of the resource.
                    "integrationId": "str",  # Optional. Integration id for the device.
                    "location": {
                        "latitude": 0.0,  # Latitude of the location. Required.
                        "longitude": 0.0  # Longitude of the location. Required.
                    },
                    "modifiedBy": "str",  # Optional. Modified by user/tenant id.
                    "modifiedDateTime": "2020-02-20 00:00:00",  # Optional. Date-time when
                      resource was last modified, sample format: yyyy-MM-ddTHH:mm:ssZ.
                    "name": "str",  # Optional. Name to identify resource.
                    "port": {
                        "name": "str",  # Optional. Name of the port.
                        "type": "str"  # Optional. Type of port digital/analog.
                    },
                    "properties": {
                        "str": {}  # Optional. A collection of key value pairs that belongs
                          to the resource."nEach pair must not have a key greater than 50
                          characters"nand must not have a value greater than 150 characters."nNote: A
                          maximum of 25 key value pairs can be provided for a resource and"nonly
                          string, numeral and datetime (yyyy-MM-ddTHH:mm:ssZ) values are supported.
                    },
                    "sensorDataModelId": "str",  # Optional. Id of the associated sensor data
                      model.
                    "sensorPartnerId": "str",  # Optional. Id of the associated sensor partner.
                    "status": "str",  # Optional. Status of the resource.
                    "type": "str"  # Optional. Type of sensor.
                }
        """

    @overload
    def create_or_update(
        self,
        sensor_partner_id: str,
        sensor_id: str,
        sensor_details: IO,
        *,
        content_type: str = "application/merge-patch+json",
        **kwargs: Any
    ) -> JSON:
        """Create a sensor entity.

        :param sensor_partner_id: Id of the sensor partner. Required.
        :type sensor_partner_id: str
        :param sensor_id: Id of the sensor resource. Required.
        :type sensor_id: str
        :param sensor_details: Sensor object details. Required.
        :type sensor_details: IO
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Default value is "application/merge-patch+json".
        :paramtype content_type: str
        :return: JSON object
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200, 201
                response == {
                    "createdBy": "str",  # Optional. Created by user/tenant id.
                    "createdDateTime": "2020-02-20 00:00:00",  # Optional. Date-time when
                      resource was created, sample format: yyyy-MM-ddTHH:mm:ssZ.
                    "depthInMeters": [
                        0.0  # Optional. Depth of each sensor measure in meters."nLike sensor
                          moisture at 2m, 4m, 6m.
                    ],
                    "description": "str",  # Optional. Textual description of the resource.
                    "deviceId": "str",  # Optional. Id of the associated device.
                    "eTag": "str",  # Optional. The ETag value to implement optimistic
                      concurrency.
                    "hardwareId": "str",  # Optional. Id of the associated hardware.
                    "id": "str",  # Optional. Id of the resource.
                    "integrationId": "str",  # Optional. Integration id for the device.
                    "location": {
                        "latitude": 0.0,  # Latitude of the location. Required.
                        "longitude": 0.0  # Longitude of the location. Required.
                    },
                    "modifiedBy": "str",  # Optional. Modified by user/tenant id.
                    "modifiedDateTime": "2020-02-20 00:00:00",  # Optional. Date-time when
                      resource was last modified, sample format: yyyy-MM-ddTHH:mm:ssZ.
                    "name": "str",  # Optional. Name to identify resource.
                    "port": {
                        "name": "str",  # Optional. Name of the port.
                        "type": "str"  # Optional. Type of port digital/analog.
                    },
                    "properties": {
                        "str": {}  # Optional. A collection of key value pairs that belongs
                          to the resource."nEach pair must not have a key greater than 50
                          characters"nand must not have a value greater than 150 characters."nNote: A
                          maximum of 25 key value pairs can be provided for a resource and"nonly
                          string, numeral and datetime (yyyy-MM-ddTHH:mm:ssZ) values are supported.
                    },
                    "sensorDataModelId": "str",  # Optional. Id of the associated sensor data
                      model.
                    "sensorPartnerId": "str",  # Optional. Id of the associated sensor partner.
                    "status": "str",  # Optional. Status of the resource.
                    "type": "str"  # Optional. Type of sensor.
                }
        """

    @distributed_trace
    def create_or_update(
        self, sensor_partner_id: str, sensor_id: str, sensor_details: Union[JSON, IO], **kwargs: Any
    ) -> JSON:
        """Create a sensor entity.

        :param sensor_partner_id: Id of the sensor partner. Required.
        :type sensor_partner_id: str
        :param sensor_id: Id of the sensor resource. Required.
        :type sensor_id: str
        :param sensor_details: Sensor object details. Is either a model type or a IO type. Required.
        :type sensor_details: JSON or IO
        :keyword content_type: Body Parameter content-type. Known values are:
         'application/merge-patch+json'. Default value is None.
        :paramtype content_type: str
        :return: JSON object
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200, 201
                response == {
                    "createdBy": "str",  # Optional. Created by user/tenant id.
                    "createdDateTime": "2020-02-20 00:00:00",  # Optional. Date-time when
                      resource was created, sample format: yyyy-MM-ddTHH:mm:ssZ.
                    "depthInMeters": [
                        0.0  # Optional. Depth of each sensor measure in meters."nLike sensor
                          moisture at 2m, 4m, 6m.
                    ],
                    "description": "str",  # Optional. Textual description of the resource.
                    "deviceId": "str",  # Optional. Id of the associated device.
                    "eTag": "str",  # Optional. The ETag value to implement optimistic
                      concurrency.
                    "hardwareId": "str",  # Optional. Id of the associated hardware.
                    "id": "str",  # Optional. Id of the resource.
                    "integrationId": "str",  # Optional. Integration id for the device.
                    "location": {
                        "latitude": 0.0,  # Latitude of the location. Required.
                        "longitude": 0.0  # Longitude of the location. Required.
                    },
                    "modifiedBy": "str",  # Optional. Modified by user/tenant id.
                    "modifiedDateTime": "2020-02-20 00:00:00",  # Optional. Date-time when
                      resource was last modified, sample format: yyyy-MM-ddTHH:mm:ssZ.
                    "name": "str",  # Optional. Name to identify resource.
                    "port": {
                        "name": "str",  # Optional. Name of the port.
                        "type": "str"  # Optional. Type of port digital/analog.
                    },
                    "properties": {
                        "str": {}  # Optional. A collection of key value pairs that belongs
                          to the resource."nEach pair must not have a key greater than 50
                          characters"nand must not have a value greater than 150 characters."nNote: A
                          maximum of 25 key value pairs can be provided for a resource and"nonly
                          string, numeral and datetime (yyyy-MM-ddTHH:mm:ssZ) values are supported.
                    },
                    "sensorDataModelId": "str",  # Optional. Id of the associated sensor data
                      model.
                    "sensorPartnerId": "str",  # Optional. Id of the associated sensor partner.
                    "status": "str",  # Optional. Status of the resource.
                    "type": "str"  # Optional. Type of sensor.
                }
        """
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type = kwargs.pop("content_type", _headers.pop("Content-Type", None))  # type: Optional[str]
        cls = kwargs.pop("cls", None)  # type: ClsType[JSON]

        content_type = content_type or "application/merge-patch+json"
        _json = None
        _content = None
        if isinstance(sensor_details, (IO, bytes)):
            _content = sensor_details
        else:
            _json = sensor_details

        request = build_sensors_create_or_update_request(
            sensor_partner_id=sensor_partner_id,
            sensor_id=sensor_id,
            content_type=content_type,
            api_version=self._config.api_version,
            json=_json,
            content=_content,
            headers=_headers,
            params=_params,
        )
        request.url = self._client.format_url(request.url)  # type: ignore

        pipeline_response = self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
            request, stream=False, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200, 201]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if response.status_code == 200:
            if response.content:
                deserialized = response.json()
            else:
                deserialized = None

        if response.status_code == 201:
            if response.content:
                deserialized = response.json()
            else:
                deserialized = None

        if cls:
            return cls(pipeline_response, cast(JSON, deserialized), {})

        return cast(JSON, deserialized)

    @distributed_trace
    def get(self, sensor_partner_id: str, sensor_id: str, **kwargs: Any) -> JSON:
        """Gets a sensor entity.

        :param sensor_partner_id: Id of the sensor partner. Required.
        :type sensor_partner_id: str
        :param sensor_id: Id of the sensor resource. Required.
        :type sensor_id: str
        :return: JSON object
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "createdBy": "str",  # Optional. Created by user/tenant id.
                    "createdDateTime": "2020-02-20 00:00:00",  # Optional. Date-time when
                      resource was created, sample format: yyyy-MM-ddTHH:mm:ssZ.
                    "depthInMeters": [
                        0.0  # Optional. Depth of each sensor measure in meters."nLike sensor
                          moisture at 2m, 4m, 6m.
                    ],
                    "description": "str",  # Optional. Textual description of the resource.
                    "deviceId": "str",  # Optional. Id of the associated device.
                    "eTag": "str",  # Optional. The ETag value to implement optimistic
                      concurrency.
                    "hardwareId": "str",  # Optional. Id of the associated hardware.
                    "id": "str",  # Optional. Id of the resource.
                    "integrationId": "str",  # Optional. Integration id for the device.
                    "location": {
                        "latitude": 0.0,  # Latitude of the location. Required.
                        "longitude": 0.0  # Longitude of the location. Required.
                    },
                    "modifiedBy": "str",  # Optional. Modified by user/tenant id.
                    "modifiedDateTime": "2020-02-20 00:00:00",  # Optional. Date-time when
                      resource was last modified, sample format: yyyy-MM-ddTHH:mm:ssZ.
                    "name": "str",  # Optional. Name to identify resource.
                    "port": {
                        "name": "str",  # Optional. Name of the port.
                        "type": "str"  # Optional. Type of port digital/analog.
                    },
                    "properties": {
                        "str": {}  # Optional. A collection of key value pairs that belongs
                          to the resource."nEach pair must not have a key greater than 50
                          characters"nand must not have a value greater than 150 characters."nNote: A
                          maximum of 25 key value pairs can be provided for a resource and"nonly
                          string, numeral and datetime (yyyy-MM-ddTHH:mm:ssZ) values are supported.
                    },
                    "sensorDataModelId": "str",  # Optional. Id of the associated sensor data
                      model.
                    "sensorPartnerId": "str",  # Optional. Id of the associated sensor partner.
                    "status": "str",  # Optional. Status of the resource.
                    "type": "str"  # Optional. Type of sensor.
                }
        """
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls = kwargs.pop("cls", None)  # type: ClsType[JSON]

        request = build_sensors_get_request(
            sensor_partner_id=sensor_partner_id,
            sensor_id=sensor_id,
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        request.url = self._client.format_url(request.url)  # type: ignore

        pipeline_response = self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
            request, stream=False, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if response.content:
            deserialized = response.json()
        else:
            deserialized = None

        if cls:
            return cls(pipeline_response, cast(JSON, deserialized), {})

        return cast(JSON, deserialized)

    @distributed_trace
    def delete(  # pylint: disable=inconsistent-return-statements
        self, sensor_partner_id: str, sensor_id: str, **kwargs: Any
    ) -> None:
        """Deletes a sensor entity.

        :param sensor_partner_id: Id of the sensor partner. Required.
        :type sensor_partner_id: str
        :param sensor_id: Id of the sensor resource. Required.
        :type sensor_id: str
        :return: None
        :rtype: None
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls = kwargs.pop("cls", None)  # type: ClsType[None]

        request = build_sensors_delete_request(
            sensor_partner_id=sensor_partner_id,
            sensor_id=sensor_id,
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        request.url = self._client.format_url(request.url)  # type: ignore

        pipeline_response = self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
            request, stream=False, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [204]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if cls:
            return cls(pipeline_response, None, {})

    @distributed_trace
    def get_connection_string(self, sensor_partner_id: str, sensor_id: str, **kwargs: Any) -> JSON:
        """Gets a sensor connection string.

        :param sensor_partner_id: Id of the sensor partner. Required.
        :type sensor_partner_id: str
        :param sensor_id: Id of the sensor resource. Required.
        :type sensor_id: str
        :return: JSON object
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "primaryDeviceConnectionString": "str",  # Optional. Primary connection
                      string of the ioTHub device.
                    "secondaryDeviceConnectionString": "str"  # Optional. Secondary connection
                      string of the ioTHub device.
                }
        """
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls = kwargs.pop("cls", None)  # type: ClsType[JSON]

        request = build_sensors_get_connection_string_request(
            sensor_partner_id=sensor_partner_id,
            sensor_id=sensor_id,
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        request.url = self._client.format_url(request.url)  # type: ignore

        pipeline_response = self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
            request, stream=False, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if response.content:
            deserialized = response.json()
        else:
            deserialized = None

        if cls:
            return cls(pipeline_response, cast(JSON, deserialized), {})

        return cast(JSON, deserialized)

    @overload
    def renew_connection_string(
        self,
        sensor_partner_id: str,
        sensor_id: str,
        renew_connection_string_model: JSON,
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> JSON:
        """Renews a sensor connection string.

        :param sensor_partner_id: Id of the sensor partner. Required.
        :type sensor_partner_id: str
        :param sensor_id: Id of the sensor resource. Required.
        :type sensor_id: str
        :param renew_connection_string_model: Sensor's connection string model. Required.
        :type renew_connection_string_model: JSON
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: JSON object
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                renew_connection_string_model = {
                    "connectionStringType": "str"  # Specifies the type of connection string key
                      to be renewed valid values - Primary/Secondary/Both. Required. Known values are:
                      "Primary", "Secondary", and "Both".
                }

                # response body for status code(s): 200
                response == {
                    "primaryDeviceConnectionString": "str",  # Optional. Primary connection
                      string of the ioTHub device.
                    "secondaryDeviceConnectionString": "str"  # Optional. Secondary connection
                      string of the ioTHub device.
                }
        """

    @overload
    def renew_connection_string(
        self,
        sensor_partner_id: str,
        sensor_id: str,
        renew_connection_string_model: IO,
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> JSON:
        """Renews a sensor connection string.

        :param sensor_partner_id: Id of the sensor partner. Required.
        :type sensor_partner_id: str
        :param sensor_id: Id of the sensor resource. Required.
        :type sensor_id: str
        :param renew_connection_string_model: Sensor's connection string model. Required.
        :type renew_connection_string_model: IO
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: JSON object
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "primaryDeviceConnectionString": "str",  # Optional. Primary connection
                      string of the ioTHub device.
                    "secondaryDeviceConnectionString": "str"  # Optional. Secondary connection
                      string of the ioTHub device.
                }
        """

    @distributed_trace
    def renew_connection_string(
        self, sensor_partner_id: str, sensor_id: str, renew_connection_string_model: Union[JSON, IO], **kwargs: Any
    ) -> JSON:
        """Renews a sensor connection string.

        :param sensor_partner_id: Id of the sensor partner. Required.
        :type sensor_partner_id: str
        :param sensor_id: Id of the sensor resource. Required.
        :type sensor_id: str
        :param renew_connection_string_model: Sensor's connection string model. Is either a model type
         or a IO type. Required.
        :type renew_connection_string_model: JSON or IO
        :keyword content_type: Body Parameter content-type. Known values are: 'application/json'.
         Default value is None.
        :paramtype content_type: str
        :return: JSON object
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "primaryDeviceConnectionString": "str",  # Optional. Primary connection
                      string of the ioTHub device.
                    "secondaryDeviceConnectionString": "str"  # Optional. Secondary connection
                      string of the ioTHub device.
                }
        """
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type = kwargs.pop("content_type", _headers.pop("Content-Type", None))  # type: Optional[str]
        cls = kwargs.pop("cls", None)  # type: ClsType[JSON]

        content_type = content_type or "application/json"
        _json = None
        _content = None
        if isinstance(renew_connection_string_model, (IO, bytes)):
            _content = renew_connection_string_model
        else:
            _json = renew_connection_string_model

        request = build_sensors_renew_connection_string_request(
            sensor_partner_id=sensor_partner_id,
            sensor_id=sensor_id,
            content_type=content_type,
            api_version=self._config.api_version,
            json=_json,
            content=_content,
            headers=_headers,
            params=_params,
        )
        request.url = self._client.format_url(request.url)  # type: ignore

        pipeline_response = self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
            request, stream=False, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if response.content:
            deserialized = response.json()
        else:
            deserialized = None

        if cls:
            return cls(pipeline_response, cast(JSON, deserialized), {})

        return cast(JSON, deserialized)


class SolutionInferenceOperations:
    """
    .. warning::
        **DO NOT** instantiate this class directly.

        Instead, you should access the following operations through
        :class:`~azure.agrifood.farming.FarmBeatsClient`'s
        :attr:`solution_inference` attribute.
    """

    def __init__(self, *args, **kwargs):
        input_args = list(args)
        self._client = input_args.pop(0) if input_args else kwargs.pop("client")
        self._config = input_args.pop(0) if input_args else kwargs.pop("config")
        self._serialize = input_args.pop(0) if input_args else kwargs.pop("serializer")
        self._deserialize = input_args.pop(0) if input_args else kwargs.pop("deserializer")

    @overload
    def cancel(
        self,
        solution_id: str,
        solution_inference_request: JSON,
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> Dict[str, Any]:
        """Cancels a job for given solution id.

        :param solution_id: Id of solution for which job is to be cancelled. Required.
        :type solution_id: str
        :param solution_inference_request: solutionInferenceRequest containing input needed for job
         request processing. Required.
        :type solution_inference_request: JSON
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: dict mapping str to any
        :rtype: dict[str, any]
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                solution_inference_request = {
                    "requestPath": "str",  # RequestPath containing the api-version, query
                      parameters and path route to be called for partner request."nExpected format is
                      "/{api-version}/{resourceExposedByPartner}/{customerDefinedJobId}?query1=value1"."nNot
                      following this format may result into validation errors. Required.
                    "partnerRequestBody": {
                        "str": {}  # Optional. Api input parameters required by partner to
                          trigger/cancel job request.
                    }
                }

                # response body for status code(s): 200
                response == {
                    "str": {}  # Optional.
                }
        """

    @overload
    def cancel(
        self, solution_id: str, solution_inference_request: IO, *, content_type: str = "application/json", **kwargs: Any
    ) -> Dict[str, Any]:
        """Cancels a job for given solution id.

        :param solution_id: Id of solution for which job is to be cancelled. Required.
        :type solution_id: str
        :param solution_inference_request: solutionInferenceRequest containing input needed for job
         request processing. Required.
        :type solution_inference_request: IO
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: dict mapping str to any
        :rtype: dict[str, any]
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "str": {}  # Optional.
                }
        """

    @distributed_trace
    def cancel(self, solution_id: str, solution_inference_request: Union[JSON, IO], **kwargs: Any) -> Dict[str, Any]:
        """Cancels a job for given solution id.

        :param solution_id: Id of solution for which job is to be cancelled. Required.
        :type solution_id: str
        :param solution_inference_request: solutionInferenceRequest containing input needed for job
         request processing. Is either a model type or a IO type. Required.
        :type solution_inference_request: JSON or IO
        :keyword content_type: Body Parameter content-type. Known values are: 'application/json'.
         Default value is None.
        :paramtype content_type: str
        :return: dict mapping str to any
        :rtype: dict[str, any]
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "str": {}  # Optional.
                }
        """
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type = kwargs.pop("content_type", _headers.pop("Content-Type", None))  # type: Optional[str]
        cls = kwargs.pop("cls", None)  # type: ClsType[Dict[str, Any]]

        content_type = content_type or "application/json"
        _json = None
        _content = None
        if isinstance(solution_inference_request, (IO, bytes)):
            _content = solution_inference_request
        else:
            _json = solution_inference_request

        request = build_solution_inference_cancel_request(
            solution_id=solution_id,
            content_type=content_type,
            api_version=self._config.api_version,
            json=_json,
            content=_content,
            headers=_headers,
            params=_params,
        )
        request.url = self._client.format_url(request.url)  # type: ignore

        pipeline_response = self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
            request, stream=False, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if response.content:
            deserialized = response.json()
        else:
            deserialized = None

        if cls:
            return cls(pipeline_response, cast(Dict[str, Any], deserialized), {})

        return cast(Dict[str, Any], deserialized)

    def _create_or_update_initial(
        self, solution_id: str, solution_inference_request: Union[JSON, IO], **kwargs: Any
    ) -> Dict[str, Any]:
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type = kwargs.pop("content_type", _headers.pop("Content-Type", None))  # type: Optional[str]
        cls = kwargs.pop("cls", None)  # type: ClsType[Dict[str, Any]]

        content_type = content_type or "application/json"
        _json = None
        _content = None
        if isinstance(solution_inference_request, (IO, bytes)):
            _content = solution_inference_request
        else:
            _json = solution_inference_request

        request = build_solution_inference_create_or_update_request(
            solution_id=solution_id,
            content_type=content_type,
            api_version=self._config.api_version,
            json=_json,
            content=_content,
            headers=_headers,
            params=_params,
        )
        request.url = self._client.format_url(request.url)  # type: ignore

        pipeline_response = self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
            request, stream=False, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [202]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if response.content:
            deserialized = response.json()
        else:
            deserialized = None

        if cls:
            return cls(pipeline_response, cast(Dict[str, Any], deserialized), {})

        return cast(Dict[str, Any], deserialized)

    @overload
    def begin_create_or_update(
        self,
        solution_id: str,
        solution_inference_request: JSON,
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> LROPoller[Dict[str, Any]]:
        """Creates a job trigger for a solution.

        :param solution_id: Id of the solution resource. Required.
        :type solution_id: str
        :param solution_inference_request: solutionInferenceRequest containing input needed for job
         request processing. Required.
        :type solution_inference_request: JSON
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :keyword str continuation_token: A continuation token to restart a poller from a saved state.
        :keyword polling: By default, your polling method will be LROBasePolling. Pass in False for
         this operation to not poll, or pass in your own initialized polling object for a personal
         polling strategy.
        :paramtype polling: bool or ~azure.core.polling.PollingMethod
        :keyword int polling_interval: Default waiting time between two polls for LRO operations if no
         Retry-After header is present.
        :return: An instance of LROPoller that returns dict mapping str to any
        :rtype: ~azure.core.polling.LROPoller[dict[str, any]]
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                solution_inference_request = {
                    "requestPath": "str",  # RequestPath containing the api-version, query
                      parameters and path route to be called for partner request."nExpected format is
                      "/{api-version}/{resourceExposedByPartner}/{customerDefinedJobId}?query1=value1"."nNot
                      following this format may result into validation errors. Required.
                    "partnerRequestBody": {
                        "str": {}  # Optional. Api input parameters required by partner to
                          trigger/cancel job request.
                    }
                }

                # response body for status code(s): 202
                response == {
                    "str": {}  # Optional.
                }
        """

    @overload
    def begin_create_or_update(
        self, solution_id: str, solution_inference_request: IO, *, content_type: str = "application/json", **kwargs: Any
    ) -> LROPoller[Dict[str, Any]]:
        """Creates a job trigger for a solution.

        :param solution_id: Id of the solution resource. Required.
        :type solution_id: str
        :param solution_inference_request: solutionInferenceRequest containing input needed for job
         request processing. Required.
        :type solution_inference_request: IO
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Default value is "application/json".
        :paramtype content_type: str
        :keyword str continuation_token: A continuation token to restart a poller from a saved state.
        :keyword polling: By default, your polling method will be LROBasePolling. Pass in False for
         this operation to not poll, or pass in your own initialized polling object for a personal
         polling strategy.
        :paramtype polling: bool or ~azure.core.polling.PollingMethod
        :keyword int polling_interval: Default waiting time between two polls for LRO operations if no
         Retry-After header is present.
        :return: An instance of LROPoller that returns dict mapping str to any
        :rtype: ~azure.core.polling.LROPoller[dict[str, any]]
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 202
                response == {
                    "str": {}  # Optional.
                }
        """

    @distributed_trace
    def begin_create_or_update(
        self, solution_id: str, solution_inference_request: Union[JSON, IO], **kwargs: Any
    ) -> LROPoller[Dict[str, Any]]:
        """Creates a job trigger for a solution.

        :param solution_id: Id of the solution resource. Required.
        :type solution_id: str
        :param solution_inference_request: solutionInferenceRequest containing input needed for job
         request processing. Is either a model type or a IO type. Required.
        :type solution_inference_request: JSON or IO
        :keyword content_type: Body Parameter content-type. Known values are: 'application/json'.
         Default value is None.
        :paramtype content_type: str
        :keyword str continuation_token: A continuation token to restart a poller from a saved state.
        :keyword polling: By default, your polling method will be LROBasePolling. Pass in False for
         this operation to not poll, or pass in your own initialized polling object for a personal
         polling strategy.
        :paramtype polling: bool or ~azure.core.polling.PollingMethod
        :keyword int polling_interval: Default waiting time between two polls for LRO operations if no
         Retry-After header is present.
        :return: An instance of LROPoller that returns dict mapping str to any
        :rtype: ~azure.core.polling.LROPoller[dict[str, any]]
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 202
                response == {
                    "str": {}  # Optional.
                }
        """
        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type = kwargs.pop("content_type", _headers.pop("Content-Type", None))  # type: Optional[str]
        cls = kwargs.pop("cls", None)  # type: ClsType[Dict[str, Any]]
        polling = kwargs.pop("polling", True)  # type: Union[bool, PollingMethod]
        lro_delay = kwargs.pop("polling_interval", self._config.polling_interval)
        cont_token = kwargs.pop("continuation_token", None)  # type: Optional[str]
        if cont_token is None:
            raw_result = self._create_or_update_initial(  # type: ignore
                solution_id=solution_id,
                solution_inference_request=solution_inference_request,
                content_type=content_type,
                cls=lambda x, y, z: x,
                headers=_headers,
                params=_params,
                **kwargs
            )
        kwargs.pop("error_map", None)

        def get_long_running_output(pipeline_response):
            response = pipeline_response.http_response
            if response.content:
                deserialized = response.json()
            else:
                deserialized = None
            if cls:
                return cls(pipeline_response, deserialized, {})
            return deserialized

        if polling is True:
            polling_method = cast(
                PollingMethod, LROBasePolling(lro_delay, lro_options={"final-state-via": "location"}, **kwargs)
            )  # type: PollingMethod
        elif polling is False:
            polling_method = cast(PollingMethod, NoPolling())
        else:
            polling_method = polling
        if cont_token:
            return LROPoller.from_continuation_token(
                polling_method=polling_method,
                continuation_token=cont_token,
                client=self._client,
                deserialization_callback=get_long_running_output,
            )
        return LROPoller(self._client, raw_result, get_long_running_output, polling_method)

    @overload
    def fetch(
        self,
        solution_id: str,
        solution_inference_request: JSON,
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> Dict[str, Any]:
        """Fetches details of triggered job for a solution.

        :param solution_id: Id of the solution. Required.
        :type solution_id: str
        :param solution_inference_request: solutionInferenceRequest containing input needed for job
         request processing. Required.
        :type solution_inference_request: JSON
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: dict mapping str to any
        :rtype: dict[str, any]
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                solution_inference_request = {
                    "requestPath": "str",  # RequestPath containing the api-version, query
                      parameters and path route to be called for partner request."nExpected format is
                      "/{api-version}/{resourceExposedByPartner}/{customerDefinedJobId}?query1=value1"."nNot
                      following this format may result into validation errors. Required.
                    "partnerRequestBody": {
                        "str": {}  # Optional. Api input parameters required by partner to
                          trigger/cancel job request.
                    }
                }

                # response body for status code(s): 200
                response == {
                    "str": {}  # Optional.
                }
        """

    @overload
    def fetch(
        self, solution_id: str, solution_inference_request: IO, *, content_type: str = "application/json", **kwargs: Any
    ) -> Dict[str, Any]:
        """Fetches details of triggered job for a solution.

        :param solution_id: Id of the solution. Required.
        :type solution_id: str
        :param solution_inference_request: solutionInferenceRequest containing input needed for job
         request processing. Required.
        :type solution_inference_request: IO
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: dict mapping str to any
        :rtype: dict[str, any]
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "str": {}  # Optional.
                }
        """

    @distributed_trace
    def fetch(self, solution_id: str, solution_inference_request: Union[JSON, IO], **kwargs: Any) -> Dict[str, Any]:
        """Fetches details of triggered job for a solution.

        :param solution_id: Id of the solution. Required.
        :type solution_id: str
        :param solution_inference_request: solutionInferenceRequest containing input needed for job
         request processing. Is either a model type or a IO type. Required.
        :type solution_inference_request: JSON or IO
        :keyword content_type: Body Parameter content-type. Known values are: 'application/json'.
         Default value is None.
        :paramtype content_type: str
        :return: dict mapping str to any
        :rtype: dict[str, any]
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "str": {}  # Optional.
                }
        """
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type = kwargs.pop("content_type", _headers.pop("Content-Type", None))  # type: Optional[str]
        cls = kwargs.pop("cls", None)  # type: ClsType[Dict[str, Any]]

        content_type = content_type or "application/json"
        _json = None
        _content = None
        if isinstance(solution_inference_request, (IO, bytes)):
            _content = solution_inference_request
        else:
            _json = solution_inference_request

        request = build_solution_inference_fetch_request(
            solution_id=solution_id,
            content_type=content_type,
            api_version=self._config.api_version,
            json=_json,
            content=_content,
            headers=_headers,
            params=_params,
        )
        request.url = self._client.format_url(request.url)  # type: ignore

        pipeline_response = self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
            request, stream=False, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if response.content:
            deserialized = response.json()
        else:
            deserialized = None

        if cls:
            return cls(pipeline_response, cast(Dict[str, Any], deserialized), {})

        return cast(Dict[str, Any], deserialized)


class TillageDataOperations:
    """
    .. warning::
        **DO NOT** instantiate this class directly.

        Instead, you should access the following operations through
        :class:`~azure.agrifood.farming.FarmBeatsClient`'s
        :attr:`tillage_data` attribute.
    """

    def __init__(self, *args, **kwargs):
        input_args = list(args)
        self._client = input_args.pop(0) if input_args else kwargs.pop("client")
        self._config = input_args.pop(0) if input_args else kwargs.pop("config")
        self._serialize = input_args.pop(0) if input_args else kwargs.pop("serializer")
        self._deserialize = input_args.pop(0) if input_args else kwargs.pop("deserializer")

    @distributed_trace
    def list_by_party_id(
        self,
        party_id: str,
        *,
        min_tillage_depth: Optional[float] = None,
        max_tillage_depth: Optional[float] = None,
        min_tillage_pressure: Optional[float] = None,
        max_tillage_pressure: Optional[float] = None,
        sources: Optional[List[str]] = None,
        associated_boundary_ids: Optional[List[str]] = None,
        min_operation_start_date_time: Optional[datetime.datetime] = None,
        max_operation_start_date_time: Optional[datetime.datetime] = None,
        min_operation_end_date_time: Optional[datetime.datetime] = None,
        max_operation_end_date_time: Optional[datetime.datetime] = None,
        min_operation_modified_date_time: Optional[datetime.datetime] = None,
        max_operation_modified_date_time: Optional[datetime.datetime] = None,
        min_area: Optional[float] = None,
        max_area: Optional[float] = None,
        ids: Optional[List[str]] = None,
        names: Optional[List[str]] = None,
        property_filters: Optional[List[str]] = None,
        statuses: Optional[List[str]] = None,
        min_created_date_time: Optional[datetime.datetime] = None,
        max_created_date_time: Optional[datetime.datetime] = None,
        min_last_modified_date_time: Optional[datetime.datetime] = None,
        max_last_modified_date_time: Optional[datetime.datetime] = None,
        skip_token: Optional[str] = None,
        **kwargs: Any
    ) -> Iterable[JSON]:
        """Returns a paginated list of tillage data resources under a particular farm.

        :param party_id: ID of the associated party. Required.
        :type party_id: str
        :keyword min_tillage_depth: Minimum measured tillage depth (inclusive). Default value is None.
        :paramtype min_tillage_depth: float
        :keyword max_tillage_depth: Maximum measured tillage depth (inclusive). Default value is None.
        :paramtype max_tillage_depth: float
        :keyword min_tillage_pressure: Minimum pressure applied to a tillage implement (inclusive).
         Default value is None.
        :paramtype min_tillage_pressure: float
        :keyword max_tillage_pressure: Maximum pressure applied to a tillage implement (inclusive).
         Default value is None.
        :paramtype max_tillage_pressure: float
        :keyword sources: Sources of the operation data. Default value is None.
        :paramtype sources: list[str]
        :keyword associated_boundary_ids: Boundary IDs associated with operation data. Default value is
         None.
        :paramtype associated_boundary_ids: list[str]
        :keyword min_operation_start_date_time: Minimum start date-time of the operation data, sample
         format: yyyy-MM-ddTHH:mm:ssZ (inclusive). Default value is None.
        :paramtype min_operation_start_date_time: ~datetime.datetime
        :keyword max_operation_start_date_time: Maximum start date-time of the operation data, sample
         format: yyyy-MM-ddTHH:mm:ssZ (inclusive). Default value is None.
        :paramtype max_operation_start_date_time: ~datetime.datetime
        :keyword min_operation_end_date_time: Minimum end date-time of the operation data, sample
         format: yyyy-MM-ddTHH:mm:ssZ (inclusive). Default value is None.
        :paramtype min_operation_end_date_time: ~datetime.datetime
        :keyword max_operation_end_date_time: Maximum end date-time of the operation data, sample
         format: yyyy-MM-ddTHH:mm:ssZ (inclusive). Default value is None.
        :paramtype max_operation_end_date_time: ~datetime.datetime
        :keyword min_operation_modified_date_time: Minimum modified date-time of the operation data,
         sample format: yyyy-MM-ddTHH:mm:ssZ (inclusive). Default value is None.
        :paramtype min_operation_modified_date_time: ~datetime.datetime
        :keyword max_operation_modified_date_time: Maximum modified date-time of the operation data,
         sample format: yyyy-MM-ddTHH:mm:ssZ (inclusive). Default value is None.
        :paramtype max_operation_modified_date_time: ~datetime.datetime
        :keyword min_area: Minimum area for which operation was applied (inclusive). Default value is
         None.
        :paramtype min_area: float
        :keyword max_area: Maximum area for which operation was applied (inclusive). Default value is
         None.
        :paramtype max_area: float
        :keyword ids: Ids of the resource. Default value is None.
        :paramtype ids: list[str]
        :keyword names: Names of the resource. Default value is None.
        :paramtype names: list[str]
        :keyword property_filters: Filters on key-value pairs within the Properties object.
         eg. "{testKey} eq {testValue}". Default value is None.
        :paramtype property_filters: list[str]
        :keyword statuses: Statuses of the resource. Default value is None.
        :paramtype statuses: list[str]
        :keyword min_created_date_time: Minimum creation date of resource (inclusive). Default value is
         None.
        :paramtype min_created_date_time: ~datetime.datetime
        :keyword max_created_date_time: Maximum creation date of resource (inclusive). Default value is
         None.
        :paramtype max_created_date_time: ~datetime.datetime
        :keyword min_last_modified_date_time: Minimum last modified date of resource (inclusive).
         Default value is None.
        :paramtype min_last_modified_date_time: ~datetime.datetime
        :keyword max_last_modified_date_time: Maximum last modified date of resource (inclusive).
         Default value is None.
        :paramtype max_last_modified_date_time: ~datetime.datetime
        :keyword skip_token: Skip token for getting next set of results. Default value is None.
        :paramtype skip_token: str
        :return: An iterator like instance of JSON object
        :rtype: ~azure.core.paging.ItemPaged[JSON]
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "area": {
                        "unit": "str",  # Optional. Data unit.
                        "value": 0.0  # Optional. Data value.
                    },
                    "associatedBoundaryId": "str",  # Optional. Optional boundary ID of the field
                      for which operation was applied.
                    "attachmentsLink": "str",  # Optional. Link for attachments.
                    "createdBy": "str",  # Optional. Created by user/tenant id.
                    "createdDateTime": "2020-02-20 00:00:00",  # Optional. Date-time when
                      resource was created, sample format: yyyy-MM-ddTHH:mm:ssZ.
                    "description": "str",  # Optional. Textual description of the resource.
                    "eTag": "str",  # Optional. The ETag value to implement optimistic
                      concurrency.
                    "id": "str",  # Optional. Unique resource ID.
                    "modifiedBy": "str",  # Optional. Modified by user/tenant id.
                    "modifiedDateTime": "2020-02-20 00:00:00",  # Optional. Date-time when
                      resource was last modified, sample format: yyyy-MM-ddTHH:mm:ssZ.
                    "name": "str",  # Optional. Name to identify resource.
                    "operationEndDateTime": "2020-02-20 00:00:00",  # Optional. End date-time of
                      the operation data, sample format: yyyy-MM-ddTHH:mm:ssZ.
                    "operationModifiedDateTime": "2020-02-20 00:00:00",  # Optional. Modified
                      date-time of the operation data, sample format: yyyy-MM-ddTHH:mm:ssZ."nNote: this
                      will be specified by the source provider itself.
                    "operationStartDateTime": "2020-02-20 00:00:00",  # Optional. Start date-time
                      of the operation data, sample format: yyyy-MM-ddTHH:mm:ssZ.
                    "partyId": "str",  # Optional. Party ID which belongs to the operation data.
                    "properties": {
                        "str": {}  # Optional. A collection of key value pairs that belongs
                          to the resource."nEach pair must not have a key greater than 50
                          characters"nand must not have a value greater than 150 characters."nNote: A
                          maximum of 25 key value pairs can be provided for a resource and only
                          string,"nnumeral and datetime (yyyy-MM-ddTHH:mm:ssZ) values are supported.
                    },
                    "source": "str",  # Optional. Source of the resource.
                    "status": "str",  # Optional. Status of the resource.
                    "tillageDepth": {
                        "unit": "str",  # Optional. Data unit.
                        "value": 0.0  # Optional. Data value.
                    },
                    "tillagePressure": {
                        "unit": "str",  # Optional. Data unit.
                        "value": 0.0  # Optional. Data value.
                    }
                }
        """
        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls = kwargs.pop("cls", None)  # type: ClsType[JSON]

        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        def prepare_request(next_link=None):
            if not next_link:

                request = build_tillage_data_list_by_party_id_request(
                    party_id=party_id,
                    min_tillage_depth=min_tillage_depth,
                    max_tillage_depth=max_tillage_depth,
                    min_tillage_pressure=min_tillage_pressure,
                    max_tillage_pressure=max_tillage_pressure,
                    sources=sources,
                    associated_boundary_ids=associated_boundary_ids,
                    min_operation_start_date_time=min_operation_start_date_time,
                    max_operation_start_date_time=max_operation_start_date_time,
                    min_operation_end_date_time=min_operation_end_date_time,
                    max_operation_end_date_time=max_operation_end_date_time,
                    min_operation_modified_date_time=min_operation_modified_date_time,
                    max_operation_modified_date_time=max_operation_modified_date_time,
                    min_area=min_area,
                    max_area=max_area,
                    ids=ids,
                    names=names,
                    property_filters=property_filters,
                    statuses=statuses,
                    min_created_date_time=min_created_date_time,
                    max_created_date_time=max_created_date_time,
                    min_last_modified_date_time=min_last_modified_date_time,
                    max_last_modified_date_time=max_last_modified_date_time,
                    skip_token=skip_token,
                    api_version=self._config.api_version,
                    headers=_headers,
                    params=_params,
                )
                request.url = self._client.format_url(request.url)  # type: ignore

            else:
                # make call to next link with the client's api-version
                _parsed_next_link = urlparse(next_link)
                _next_request_params = case_insensitive_dict(parse_qs(_parsed_next_link.query))
                _next_request_params["api-version"] = self._config.api_version
                request = HttpRequest("GET", urljoin(next_link, _parsed_next_link.path), params=_next_request_params)
                request.url = self._client.format_url(request.url)  # type: ignore

            return request

        def extract_data(pipeline_response):
            deserialized = pipeline_response.http_response.json()
            list_of_elem = deserialized["value"]
            if cls:
                list_of_elem = cls(list_of_elem)
            return deserialized.get("nextLink", None), iter(list_of_elem)

        def get_next(next_link=None):
            request = prepare_request(next_link)

            pipeline_response = self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
                request, stream=False, **kwargs
            )
            response = pipeline_response.http_response

            if response.status_code not in [200]:
                map_error(status_code=response.status_code, response=response, error_map=error_map)
                raise HttpResponseError(response=response)

            return pipeline_response

        return ItemPaged(get_next, extract_data)

    @distributed_trace
    def get(self, party_id: str, tillage_data_id: str, **kwargs: Any) -> JSON:
        """Get a specified tillage data resource under a particular party.

        :param party_id: ID of the associated party resource. Required.
        :type party_id: str
        :param tillage_data_id: ID of the tillage data resource. Required.
        :type tillage_data_id: str
        :return: JSON object
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "area": {
                        "unit": "str",  # Optional. Data unit.
                        "value": 0.0  # Optional. Data value.
                    },
                    "associatedBoundaryId": "str",  # Optional. Optional boundary ID of the field
                      for which operation was applied.
                    "attachmentsLink": "str",  # Optional. Link for attachments.
                    "createdBy": "str",  # Optional. Created by user/tenant id.
                    "createdDateTime": "2020-02-20 00:00:00",  # Optional. Date-time when
                      resource was created, sample format: yyyy-MM-ddTHH:mm:ssZ.
                    "description": "str",  # Optional. Textual description of the resource.
                    "eTag": "str",  # Optional. The ETag value to implement optimistic
                      concurrency.
                    "id": "str",  # Optional. Unique resource ID.
                    "modifiedBy": "str",  # Optional. Modified by user/tenant id.
                    "modifiedDateTime": "2020-02-20 00:00:00",  # Optional. Date-time when
                      resource was last modified, sample format: yyyy-MM-ddTHH:mm:ssZ.
                    "name": "str",  # Optional. Name to identify resource.
                    "operationEndDateTime": "2020-02-20 00:00:00",  # Optional. End date-time of
                      the operation data, sample format: yyyy-MM-ddTHH:mm:ssZ.
                    "operationModifiedDateTime": "2020-02-20 00:00:00",  # Optional. Modified
                      date-time of the operation data, sample format: yyyy-MM-ddTHH:mm:ssZ."nNote: this
                      will be specified by the source provider itself.
                    "operationStartDateTime": "2020-02-20 00:00:00",  # Optional. Start date-time
                      of the operation data, sample format: yyyy-MM-ddTHH:mm:ssZ.
                    "partyId": "str",  # Optional. Party ID which belongs to the operation data.
                    "properties": {
                        "str": {}  # Optional. A collection of key value pairs that belongs
                          to the resource."nEach pair must not have a key greater than 50
                          characters"nand must not have a value greater than 150 characters."nNote: A
                          maximum of 25 key value pairs can be provided for a resource and only
                          string,"nnumeral and datetime (yyyy-MM-ddTHH:mm:ssZ) values are supported.
                    },
                    "source": "str",  # Optional. Source of the resource.
                    "status": "str",  # Optional. Status of the resource.
                    "tillageDepth": {
                        "unit": "str",  # Optional. Data unit.
                        "value": 0.0  # Optional. Data value.
                    },
                    "tillagePressure": {
                        "unit": "str",  # Optional. Data unit.
                        "value": 0.0  # Optional. Data value.
                    }
                }
        """
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls = kwargs.pop("cls", None)  # type: ClsType[JSON]

        request = build_tillage_data_get_request(
            party_id=party_id,
            tillage_data_id=tillage_data_id,
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        request.url = self._client.format_url(request.url)  # type: ignore

        pipeline_response = self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
            request, stream=False, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if response.content:
            deserialized = response.json()
        else:
            deserialized = None

        if cls:
            return cls(pipeline_response, cast(JSON, deserialized), {})

        return cast(JSON, deserialized)

    @overload
    def create_or_update(
        self,
        party_id: str,
        tillage_data_id: str,
        tillage_data: JSON,
        *,
        content_type: str = "application/merge-patch+json",
        **kwargs: Any
    ) -> JSON:
        """Creates or updates an tillage data resource under a particular party.

        :param party_id: ID of the associated party. Required.
        :type party_id: str
        :param tillage_data_id: ID of the tillage data resource. Required.
        :type tillage_data_id: str
        :param tillage_data: Tillage data resource payload to create or update. Required.
        :type tillage_data: JSON
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/merge-patch+json".
        :paramtype content_type: str
        :return: JSON object
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                tillage_data = {
                    "area": {
                        "unit": "str",  # Optional. Data unit.
                        "value": 0.0  # Optional. Data value.
                    },
                    "associatedBoundaryId": "str",  # Optional. Optional boundary ID of the field
                      for which operation was applied.
                    "attachmentsLink": "str",  # Optional. Link for attachments.
                    "createdBy": "str",  # Optional. Created by user/tenant id.
                    "createdDateTime": "2020-02-20 00:00:00",  # Optional. Date-time when
                      resource was created, sample format: yyyy-MM-ddTHH:mm:ssZ.
                    "description": "str",  # Optional. Textual description of the resource.
                    "eTag": "str",  # Optional. The ETag value to implement optimistic
                      concurrency.
                    "id": "str",  # Optional. Unique resource ID.
                    "modifiedBy": "str",  # Optional. Modified by user/tenant id.
                    "modifiedDateTime": "2020-02-20 00:00:00",  # Optional. Date-time when
                      resource was last modified, sample format: yyyy-MM-ddTHH:mm:ssZ.
                    "name": "str",  # Optional. Name to identify resource.
                    "operationEndDateTime": "2020-02-20 00:00:00",  # Optional. End date-time of
                      the operation data, sample format: yyyy-MM-ddTHH:mm:ssZ.
                    "operationModifiedDateTime": "2020-02-20 00:00:00",  # Optional. Modified
                      date-time of the operation data, sample format: yyyy-MM-ddTHH:mm:ssZ."nNote: this
                      will be specified by the source provider itself.
                    "operationStartDateTime": "2020-02-20 00:00:00",  # Optional. Start date-time
                      of the operation data, sample format: yyyy-MM-ddTHH:mm:ssZ.
                    "partyId": "str",  # Optional. Party ID which belongs to the operation data.
                    "properties": {
                        "str": {}  # Optional. A collection of key value pairs that belongs
                          to the resource."nEach pair must not have a key greater than 50
                          characters"nand must not have a value greater than 150 characters."nNote: A
                          maximum of 25 key value pairs can be provided for a resource and only
                          string,"nnumeral and datetime (yyyy-MM-ddTHH:mm:ssZ) values are supported.
                    },
                    "source": "str",  # Optional. Source of the resource.
                    "status": "str",  # Optional. Status of the resource.
                    "tillageDepth": {
                        "unit": "str",  # Optional. Data unit.
                        "value": 0.0  # Optional. Data value.
                    },
                    "tillagePressure": {
                        "unit": "str",  # Optional. Data unit.
                        "value": 0.0  # Optional. Data value.
                    }
                }

                # response body for status code(s): 200, 201
                response == {
                    "area": {
                        "unit": "str",  # Optional. Data unit.
                        "value": 0.0  # Optional. Data value.
                    },
                    "associatedBoundaryId": "str",  # Optional. Optional boundary ID of the field
                      for which operation was applied.
                    "attachmentsLink": "str",  # Optional. Link for attachments.
                    "createdBy": "str",  # Optional. Created by user/tenant id.
                    "createdDateTime": "2020-02-20 00:00:00",  # Optional. Date-time when
                      resource was created, sample format: yyyy-MM-ddTHH:mm:ssZ.
                    "description": "str",  # Optional. Textual description of the resource.
                    "eTag": "str",  # Optional. The ETag value to implement optimistic
                      concurrency.
                    "id": "str",  # Optional. Unique resource ID.
                    "modifiedBy": "str",  # Optional. Modified by user/tenant id.
                    "modifiedDateTime": "2020-02-20 00:00:00",  # Optional. Date-time when
                      resource was last modified, sample format: yyyy-MM-ddTHH:mm:ssZ.
                    "name": "str",  # Optional. Name to identify resource.
                    "operationEndDateTime": "2020-02-20 00:00:00",  # Optional. End date-time of
                      the operation data, sample format: yyyy-MM-ddTHH:mm:ssZ.
                    "operationModifiedDateTime": "2020-02-20 00:00:00",  # Optional. Modified
                      date-time of the operation data, sample format: yyyy-MM-ddTHH:mm:ssZ."nNote: this
                      will be specified by the source provider itself.
                    "operationStartDateTime": "2020-02-20 00:00:00",  # Optional. Start date-time
                      of the operation data, sample format: yyyy-MM-ddTHH:mm:ssZ.
                    "partyId": "str",  # Optional. Party ID which belongs to the operation data.
                    "properties": {
                        "str": {}  # Optional. A collection of key value pairs that belongs
                          to the resource."nEach pair must not have a key greater than 50
                          characters"nand must not have a value greater than 150 characters."nNote: A
                          maximum of 25 key value pairs can be provided for a resource and only
                          string,"nnumeral and datetime (yyyy-MM-ddTHH:mm:ssZ) values are supported.
                    },
                    "source": "str",  # Optional. Source of the resource.
                    "status": "str",  # Optional. Status of the resource.
                    "tillageDepth": {
                        "unit": "str",  # Optional. Data unit.
                        "value": 0.0  # Optional. Data value.
                    },
                    "tillagePressure": {
                        "unit": "str",  # Optional. Data unit.
                        "value": 0.0  # Optional. Data value.
                    }
                }
        """

    @overload
    def create_or_update(
        self,
        party_id: str,
        tillage_data_id: str,
        tillage_data: IO,
        *,
        content_type: str = "application/merge-patch+json",
        **kwargs: Any
    ) -> JSON:
        """Creates or updates an tillage data resource under a particular party.

        :param party_id: ID of the associated party. Required.
        :type party_id: str
        :param tillage_data_id: ID of the tillage data resource. Required.
        :type tillage_data_id: str
        :param tillage_data: Tillage data resource payload to create or update. Required.
        :type tillage_data: IO
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Default value is "application/merge-patch+json".
        :paramtype content_type: str
        :return: JSON object
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200, 201
                response == {
                    "area": {
                        "unit": "str",  # Optional. Data unit.
                        "value": 0.0  # Optional. Data value.
                    },
                    "associatedBoundaryId": "str",  # Optional. Optional boundary ID of the field
                      for which operation was applied.
                    "attachmentsLink": "str",  # Optional. Link for attachments.
                    "createdBy": "str",  # Optional. Created by user/tenant id.
                    "createdDateTime": "2020-02-20 00:00:00",  # Optional. Date-time when
                      resource was created, sample format: yyyy-MM-ddTHH:mm:ssZ.
                    "description": "str",  # Optional. Textual description of the resource.
                    "eTag": "str",  # Optional. The ETag value to implement optimistic
                      concurrency.
                    "id": "str",  # Optional. Unique resource ID.
                    "modifiedBy": "str",  # Optional. Modified by user/tenant id.
                    "modifiedDateTime": "2020-02-20 00:00:00",  # Optional. Date-time when
                      resource was last modified, sample format: yyyy-MM-ddTHH:mm:ssZ.
                    "name": "str",  # Optional. Name to identify resource.
                    "operationEndDateTime": "2020-02-20 00:00:00",  # Optional. End date-time of
                      the operation data, sample format: yyyy-MM-ddTHH:mm:ssZ.
                    "operationModifiedDateTime": "2020-02-20 00:00:00",  # Optional. Modified
                      date-time of the operation data, sample format: yyyy-MM-ddTHH:mm:ssZ."nNote: this
                      will be specified by the source provider itself.
                    "operationStartDateTime": "2020-02-20 00:00:00",  # Optional. Start date-time
                      of the operation data, sample format: yyyy-MM-ddTHH:mm:ssZ.
                    "partyId": "str",  # Optional. Party ID which belongs to the operation data.
                    "properties": {
                        "str": {}  # Optional. A collection of key value pairs that belongs
                          to the resource."nEach pair must not have a key greater than 50
                          characters"nand must not have a value greater than 150 characters."nNote: A
                          maximum of 25 key value pairs can be provided for a resource and only
                          string,"nnumeral and datetime (yyyy-MM-ddTHH:mm:ssZ) values are supported.
                    },
                    "source": "str",  # Optional. Source of the resource.
                    "status": "str",  # Optional. Status of the resource.
                    "tillageDepth": {
                        "unit": "str",  # Optional. Data unit.
                        "value": 0.0  # Optional. Data value.
                    },
                    "tillagePressure": {
                        "unit": "str",  # Optional. Data unit.
                        "value": 0.0  # Optional. Data value.
                    }
                }
        """

    @distributed_trace
    def create_or_update(
        self, party_id: str, tillage_data_id: str, tillage_data: Union[JSON, IO], **kwargs: Any
    ) -> JSON:
        """Creates or updates an tillage data resource under a particular party.

        :param party_id: ID of the associated party. Required.
        :type party_id: str
        :param tillage_data_id: ID of the tillage data resource. Required.
        :type tillage_data_id: str
        :param tillage_data: Tillage data resource payload to create or update. Is either a model type
         or a IO type. Required.
        :type tillage_data: JSON or IO
        :keyword content_type: Body Parameter content-type. Known values are:
         'application/merge-patch+json'. Default value is None.
        :paramtype content_type: str
        :return: JSON object
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200, 201
                response == {
                    "area": {
                        "unit": "str",  # Optional. Data unit.
                        "value": 0.0  # Optional. Data value.
                    },
                    "associatedBoundaryId": "str",  # Optional. Optional boundary ID of the field
                      for which operation was applied.
                    "attachmentsLink": "str",  # Optional. Link for attachments.
                    "createdBy": "str",  # Optional. Created by user/tenant id.
                    "createdDateTime": "2020-02-20 00:00:00",  # Optional. Date-time when
                      resource was created, sample format: yyyy-MM-ddTHH:mm:ssZ.
                    "description": "str",  # Optional. Textual description of the resource.
                    "eTag": "str",  # Optional. The ETag value to implement optimistic
                      concurrency.
                    "id": "str",  # Optional. Unique resource ID.
                    "modifiedBy": "str",  # Optional. Modified by user/tenant id.
                    "modifiedDateTime": "2020-02-20 00:00:00",  # Optional. Date-time when
                      resource was last modified, sample format: yyyy-MM-ddTHH:mm:ssZ.
                    "name": "str",  # Optional. Name to identify resource.
                    "operationEndDateTime": "2020-02-20 00:00:00",  # Optional. End date-time of
                      the operation data, sample format: yyyy-MM-ddTHH:mm:ssZ.
                    "operationModifiedDateTime": "2020-02-20 00:00:00",  # Optional. Modified
                      date-time of the operation data, sample format: yyyy-MM-ddTHH:mm:ssZ."nNote: this
                      will be specified by the source provider itself.
                    "operationStartDateTime": "2020-02-20 00:00:00",  # Optional. Start date-time
                      of the operation data, sample format: yyyy-MM-ddTHH:mm:ssZ.
                    "partyId": "str",  # Optional. Party ID which belongs to the operation data.
                    "properties": {
                        "str": {}  # Optional. A collection of key value pairs that belongs
                          to the resource."nEach pair must not have a key greater than 50
                          characters"nand must not have a value greater than 150 characters."nNote: A
                          maximum of 25 key value pairs can be provided for a resource and only
                          string,"nnumeral and datetime (yyyy-MM-ddTHH:mm:ssZ) values are supported.
                    },
                    "source": "str",  # Optional. Source of the resource.
                    "status": "str",  # Optional. Status of the resource.
                    "tillageDepth": {
                        "unit": "str",  # Optional. Data unit.
                        "value": 0.0  # Optional. Data value.
                    },
                    "tillagePressure": {
                        "unit": "str",  # Optional. Data unit.
                        "value": 0.0  # Optional. Data value.
                    }
                }
        """
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type = kwargs.pop("content_type", _headers.pop("Content-Type", None))  # type: Optional[str]
        cls = kwargs.pop("cls", None)  # type: ClsType[JSON]

        content_type = content_type or "application/merge-patch+json"
        _json = None
        _content = None
        if isinstance(tillage_data, (IO, bytes)):
            _content = tillage_data
        else:
            _json = tillage_data

        request = build_tillage_data_create_or_update_request(
            party_id=party_id,
            tillage_data_id=tillage_data_id,
            content_type=content_type,
            api_version=self._config.api_version,
            json=_json,
            content=_content,
            headers=_headers,
            params=_params,
        )
        request.url = self._client.format_url(request.url)  # type: ignore

        pipeline_response = self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
            request, stream=False, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200, 201]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if response.status_code == 200:
            if response.content:
                deserialized = response.json()
            else:
                deserialized = None

        if response.status_code == 201:
            if response.content:
                deserialized = response.json()
            else:
                deserialized = None

        if cls:
            return cls(pipeline_response, cast(JSON, deserialized), {})

        return cast(JSON, deserialized)

    @distributed_trace
    def delete(  # pylint: disable=inconsistent-return-statements
        self, party_id: str, tillage_data_id: str, **kwargs: Any
    ) -> None:
        """Deletes a specified tillage data resource under a particular party.

        :param party_id: ID of the associated party resource. Required.
        :type party_id: str
        :param tillage_data_id: ID of the tillage data. Required.
        :type tillage_data_id: str
        :return: None
        :rtype: None
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls = kwargs.pop("cls", None)  # type: ClsType[None]

        request = build_tillage_data_delete_request(
            party_id=party_id,
            tillage_data_id=tillage_data_id,
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        request.url = self._client.format_url(request.url)  # type: ignore

        pipeline_response = self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
            request, stream=False, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [204]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if cls:
            return cls(pipeline_response, None, {})

    @distributed_trace
    def list(
        self,
        *,
        min_tillage_depth: Optional[float] = None,
        max_tillage_depth: Optional[float] = None,
        min_tillage_pressure: Optional[float] = None,
        max_tillage_pressure: Optional[float] = None,
        sources: Optional[List[str]] = None,
        associated_boundary_ids: Optional[List[str]] = None,
        min_operation_start_date_time: Optional[datetime.datetime] = None,
        max_operation_start_date_time: Optional[datetime.datetime] = None,
        min_operation_end_date_time: Optional[datetime.datetime] = None,
        max_operation_end_date_time: Optional[datetime.datetime] = None,
        min_operation_modified_date_time: Optional[datetime.datetime] = None,
        max_operation_modified_date_time: Optional[datetime.datetime] = None,
        min_area: Optional[float] = None,
        max_area: Optional[float] = None,
        ids: Optional[List[str]] = None,
        names: Optional[List[str]] = None,
        property_filters: Optional[List[str]] = None,
        statuses: Optional[List[str]] = None,
        min_created_date_time: Optional[datetime.datetime] = None,
        max_created_date_time: Optional[datetime.datetime] = None,
        min_last_modified_date_time: Optional[datetime.datetime] = None,
        max_last_modified_date_time: Optional[datetime.datetime] = None,
        skip_token: Optional[str] = None,
        **kwargs: Any
    ) -> Iterable[JSON]:
        """Returns a paginated list of tillage data resources across all parties.

        :keyword min_tillage_depth: Minimum measured tillage depth (inclusive). Default value is None.
        :paramtype min_tillage_depth: float
        :keyword max_tillage_depth: Maximum measured tillage depth (inclusive). Default value is None.
        :paramtype max_tillage_depth: float
        :keyword min_tillage_pressure: Minimum pressure applied to a tillage implement (inclusive).
         Default value is None.
        :paramtype min_tillage_pressure: float
        :keyword max_tillage_pressure: Maximum pressure applied to a tillage implement (inclusive).
         Default value is None.
        :paramtype max_tillage_pressure: float
        :keyword sources: Sources of the operation data. Default value is None.
        :paramtype sources: list[str]
        :keyword associated_boundary_ids: Boundary IDs associated with operation data. Default value is
         None.
        :paramtype associated_boundary_ids: list[str]
        :keyword min_operation_start_date_time: Minimum start date-time of the operation data, sample
         format: yyyy-MM-ddTHH:mm:ssZ (inclusive). Default value is None.
        :paramtype min_operation_start_date_time: ~datetime.datetime
        :keyword max_operation_start_date_time: Maximum start date-time of the operation data, sample
         format: yyyy-MM-ddTHH:mm:ssZ (inclusive). Default value is None.
        :paramtype max_operation_start_date_time: ~datetime.datetime
        :keyword min_operation_end_date_time: Minimum end date-time of the operation data, sample
         format: yyyy-MM-ddTHH:mm:ssZ (inclusive). Default value is None.
        :paramtype min_operation_end_date_time: ~datetime.datetime
        :keyword max_operation_end_date_time: Maximum end date-time of the operation data, sample
         format: yyyy-MM-ddTHH:mm:ssZ (inclusive). Default value is None.
        :paramtype max_operation_end_date_time: ~datetime.datetime
        :keyword min_operation_modified_date_time: Minimum modified date-time of the operation data,
         sample format: yyyy-MM-ddTHH:mm:ssZ (inclusive). Default value is None.
        :paramtype min_operation_modified_date_time: ~datetime.datetime
        :keyword max_operation_modified_date_time: Maximum modified date-time of the operation data,
         sample format: yyyy-MM-ddTHH:mm:ssZ (inclusive). Default value is None.
        :paramtype max_operation_modified_date_time: ~datetime.datetime
        :keyword min_area: Minimum area for which operation was applied (inclusive). Default value is
         None.
        :paramtype min_area: float
        :keyword max_area: Maximum area for which operation was applied (inclusive). Default value is
         None.
        :paramtype max_area: float
        :keyword ids: Ids of the resource. Default value is None.
        :paramtype ids: list[str]
        :keyword names: Names of the resource. Default value is None.
        :paramtype names: list[str]
        :keyword property_filters: Filters on key-value pairs within the Properties object.
         eg. "{testKey} eq {testValue}". Default value is None.
        :paramtype property_filters: list[str]
        :keyword statuses: Statuses of the resource. Default value is None.
        :paramtype statuses: list[str]
        :keyword min_created_date_time: Minimum creation date of resource (inclusive). Default value is
         None.
        :paramtype min_created_date_time: ~datetime.datetime
        :keyword max_created_date_time: Maximum creation date of resource (inclusive). Default value is
         None.
        :paramtype max_created_date_time: ~datetime.datetime
        :keyword min_last_modified_date_time: Minimum last modified date of resource (inclusive).
         Default value is None.
        :paramtype min_last_modified_date_time: ~datetime.datetime
        :keyword max_last_modified_date_time: Maximum last modified date of resource (inclusive).
         Default value is None.
        :paramtype max_last_modified_date_time: ~datetime.datetime
        :keyword skip_token: Skip token for getting next set of results. Default value is None.
        :paramtype skip_token: str
        :return: An iterator like instance of JSON object
        :rtype: ~azure.core.paging.ItemPaged[JSON]
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "area": {
                        "unit": "str",  # Optional. Data unit.
                        "value": 0.0  # Optional. Data value.
                    },
                    "associatedBoundaryId": "str",  # Optional. Optional boundary ID of the field
                      for which operation was applied.
                    "attachmentsLink": "str",  # Optional. Link for attachments.
                    "createdBy": "str",  # Optional. Created by user/tenant id.
                    "createdDateTime": "2020-02-20 00:00:00",  # Optional. Date-time when
                      resource was created, sample format: yyyy-MM-ddTHH:mm:ssZ.
                    "description": "str",  # Optional. Textual description of the resource.
                    "eTag": "str",  # Optional. The ETag value to implement optimistic
                      concurrency.
                    "id": "str",  # Optional. Unique resource ID.
                    "modifiedBy": "str",  # Optional. Modified by user/tenant id.
                    "modifiedDateTime": "2020-02-20 00:00:00",  # Optional. Date-time when
                      resource was last modified, sample format: yyyy-MM-ddTHH:mm:ssZ.
                    "name": "str",  # Optional. Name to identify resource.
                    "operationEndDateTime": "2020-02-20 00:00:00",  # Optional. End date-time of
                      the operation data, sample format: yyyy-MM-ddTHH:mm:ssZ.
                    "operationModifiedDateTime": "2020-02-20 00:00:00",  # Optional. Modified
                      date-time of the operation data, sample format: yyyy-MM-ddTHH:mm:ssZ."nNote: this
                      will be specified by the source provider itself.
                    "operationStartDateTime": "2020-02-20 00:00:00",  # Optional. Start date-time
                      of the operation data, sample format: yyyy-MM-ddTHH:mm:ssZ.
                    "partyId": "str",  # Optional. Party ID which belongs to the operation data.
                    "properties": {
                        "str": {}  # Optional. A collection of key value pairs that belongs
                          to the resource."nEach pair must not have a key greater than 50
                          characters"nand must not have a value greater than 150 characters."nNote: A
                          maximum of 25 key value pairs can be provided for a resource and only
                          string,"nnumeral and datetime (yyyy-MM-ddTHH:mm:ssZ) values are supported.
                    },
                    "source": "str",  # Optional. Source of the resource.
                    "status": "str",  # Optional. Status of the resource.
                    "tillageDepth": {
                        "unit": "str",  # Optional. Data unit.
                        "value": 0.0  # Optional. Data value.
                    },
                    "tillagePressure": {
                        "unit": "str",  # Optional. Data unit.
                        "value": 0.0  # Optional. Data value.
                    }
                }
        """
        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls = kwargs.pop("cls", None)  # type: ClsType[JSON]

        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        def prepare_request(next_link=None):
            if not next_link:

                request = build_tillage_data_list_request(
                    min_tillage_depth=min_tillage_depth,
                    max_tillage_depth=max_tillage_depth,
                    min_tillage_pressure=min_tillage_pressure,
                    max_tillage_pressure=max_tillage_pressure,
                    sources=sources,
                    associated_boundary_ids=associated_boundary_ids,
                    min_operation_start_date_time=min_operation_start_date_time,
                    max_operation_start_date_time=max_operation_start_date_time,
                    min_operation_end_date_time=min_operation_end_date_time,
                    max_operation_end_date_time=max_operation_end_date_time,
                    min_operation_modified_date_time=min_operation_modified_date_time,
                    max_operation_modified_date_time=max_operation_modified_date_time,
                    min_area=min_area,
                    max_area=max_area,
                    ids=ids,
                    names=names,
                    property_filters=property_filters,
                    statuses=statuses,
                    min_created_date_time=min_created_date_time,
                    max_created_date_time=max_created_date_time,
                    min_last_modified_date_time=min_last_modified_date_time,
                    max_last_modified_date_time=max_last_modified_date_time,
                    skip_token=skip_token,
                    api_version=self._config.api_version,
                    headers=_headers,
                    params=_params,
                )
                request.url = self._client.format_url(request.url)  # type: ignore

            else:
                # make call to next link with the client's api-version
                _parsed_next_link = urlparse(next_link)
                _next_request_params = case_insensitive_dict(parse_qs(_parsed_next_link.query))
                _next_request_params["api-version"] = self._config.api_version
                request = HttpRequest("GET", urljoin(next_link, _parsed_next_link.path), params=_next_request_params)
                request.url = self._client.format_url(request.url)  # type: ignore

            return request

        def extract_data(pipeline_response):
            deserialized = pipeline_response.http_response.json()
            list_of_elem = deserialized["value"]
            if cls:
                list_of_elem = cls(list_of_elem)
            return deserialized.get("nextLink", None), iter(list_of_elem)

        def get_next(next_link=None):
            request = prepare_request(next_link)

            pipeline_response = self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
                request, stream=False, **kwargs
            )
            response = pipeline_response.http_response

            if response.status_code not in [200]:
                map_error(status_code=response.status_code, response=response, error_map=error_map)
                raise HttpResponseError(response=response)

            return pipeline_response

        return ItemPaged(get_next, extract_data)

    def _create_cascade_delete_job_initial(
        self, job_id: str, *, party_id: str, tillage_data_id: str, **kwargs: Any
    ) -> JSON:
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls = kwargs.pop("cls", None)  # type: ClsType[JSON]

        request = build_tillage_data_create_cascade_delete_job_request(
            job_id=job_id,
            party_id=party_id,
            tillage_data_id=tillage_data_id,
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        request.url = self._client.format_url(request.url)  # type: ignore

        pipeline_response = self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
            request, stream=False, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [202]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if response.content:
            deserialized = response.json()
        else:
            deserialized = None

        if cls:
            return cls(pipeline_response, cast(JSON, deserialized), {})

        return cast(JSON, deserialized)

    @distributed_trace
    def begin_create_cascade_delete_job(
        self, job_id: str, *, party_id: str, tillage_data_id: str, **kwargs: Any
    ) -> LROPoller[JSON]:
        """Create cascade delete job for tillage data resource.

        :param job_id: Job Id supplied by end user. Required.
        :type job_id: str
        :keyword party_id: Id of the party. Required.
        :paramtype party_id: str
        :keyword tillage_data_id: Id of the tillage data. Required.
        :paramtype tillage_data_id: str
        :keyword str continuation_token: A continuation token to restart a poller from a saved state.
        :keyword polling: By default, your polling method will be LROBasePolling. Pass in False for
         this operation to not poll, or pass in your own initialized polling object for a personal
         polling strategy.
        :paramtype polling: bool or ~azure.core.polling.PollingMethod
        :keyword int polling_interval: Default waiting time between two polls for LRO operations if no
         Retry-After header is present.
        :return: An instance of LROPoller that returns JSON object
        :rtype: ~azure.core.polling.LROPoller[JSON]
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 202
                response == {
                    "partyId": "str",  # Party Id. Required.
                    "resourceId": "str",  # The id of the resource. Required.
                    "resourceType": "str",  # The type of the resource. Required.
                    "createdDateTime": "2020-02-20 00:00:00",  # Optional. Job created at
                      dateTime. Sample format: yyyy-MM-ddTHH:mm:ssZ.
                    "durationInSeconds": 0.0,  # Optional. Duration of the job in seconds.
                    "endTime": "2020-02-20 00:00:00",  # Optional. Job end time when available.
                      Sample format: yyyy-MM-ddTHH:mm:ssZ.
                    "errorCode": "str",  # Optional. Error Code when job failed.
                    "id": "str",  # Optional. Unique job id.
                    "lastActionDateTime": "2020-02-20 00:00:00",  # Optional. Job was last acted
                      upon at dateTime. Sample format: yyyy-MM-ddTHH:mm:ssZ.
                    "message": "str",  # Optional. Status message to capture more details of the
                      job.
                    "startTime": "2020-02-20 00:00:00",  # Optional. Job start time when
                      available. Sample format: yyyy-MM-ddTHH:mm:ssZ.
                    "status": "str"  # Optional. Status of the job."nPossible values: 'Waiting',
                      'Running', 'Succeeded', 'Failed', 'Cancelled'. Known values are: "Waiting",
                      "Running", "Succeeded", "Failed", and "Cancelled".
                }
        """
        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls = kwargs.pop("cls", None)  # type: ClsType[JSON]
        polling = kwargs.pop("polling", True)  # type: Union[bool, PollingMethod]
        lro_delay = kwargs.pop("polling_interval", self._config.polling_interval)
        cont_token = kwargs.pop("continuation_token", None)  # type: Optional[str]
        if cont_token is None:
            raw_result = self._create_cascade_delete_job_initial(  # type: ignore
                job_id=job_id,
                party_id=party_id,
                tillage_data_id=tillage_data_id,
                cls=lambda x, y, z: x,
                headers=_headers,
                params=_params,
                **kwargs
            )
        kwargs.pop("error_map", None)

        def get_long_running_output(pipeline_response):
            response = pipeline_response.http_response
            if response.content:
                deserialized = response.json()
            else:
                deserialized = None
            if cls:
                return cls(pipeline_response, deserialized, {})
            return deserialized

        if polling is True:
            polling_method = cast(
                PollingMethod, LROBasePolling(lro_delay, lro_options={"final-state-via": "location"}, **kwargs)
            )  # type: PollingMethod
        elif polling is False:
            polling_method = cast(PollingMethod, NoPolling())
        else:
            polling_method = polling
        if cont_token:
            return LROPoller.from_continuation_token(
                polling_method=polling_method,
                continuation_token=cont_token,
                client=self._client,
                deserialization_callback=get_long_running_output,
            )
        return LROPoller(self._client, raw_result, get_long_running_output, polling_method)

    @distributed_trace
    def get_cascade_delete_job_details(self, job_id: str, **kwargs: Any) -> JSON:
        """Get cascade delete job for tillage data resource.

        :param job_id: Id of the job. Required.
        :type job_id: str
        :return: JSON object
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "partyId": "str",  # Party Id. Required.
                    "resourceId": "str",  # The id of the resource. Required.
                    "resourceType": "str",  # The type of the resource. Required.
                    "createdDateTime": "2020-02-20 00:00:00",  # Optional. Job created at
                      dateTime. Sample format: yyyy-MM-ddTHH:mm:ssZ.
                    "durationInSeconds": 0.0,  # Optional. Duration of the job in seconds.
                    "endTime": "2020-02-20 00:00:00",  # Optional. Job end time when available.
                      Sample format: yyyy-MM-ddTHH:mm:ssZ.
                    "errorCode": "str",  # Optional. Error Code when job failed.
                    "id": "str",  # Optional. Unique job id.
                    "lastActionDateTime": "2020-02-20 00:00:00",  # Optional. Job was last acted
                      upon at dateTime. Sample format: yyyy-MM-ddTHH:mm:ssZ.
                    "message": "str",  # Optional. Status message to capture more details of the
                      job.
                    "startTime": "2020-02-20 00:00:00",  # Optional. Job start time when
                      available. Sample format: yyyy-MM-ddTHH:mm:ssZ.
                    "status": "str"  # Optional. Status of the job."nPossible values: 'Waiting',
                      'Running', 'Succeeded', 'Failed', 'Cancelled'. Known values are: "Waiting",
                      "Running", "Succeeded", "Failed", and "Cancelled".
                }
        """
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls = kwargs.pop("cls", None)  # type: ClsType[JSON]

        request = build_tillage_data_get_cascade_delete_job_details_request(
            job_id=job_id,
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        request.url = self._client.format_url(request.url)  # type: ignore

        pipeline_response = self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
            request, stream=False, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if response.content:
            deserialized = response.json()
        else:
            deserialized = None

        if cls:
            return cls(pipeline_response, cast(JSON, deserialized), {})

        return cast(JSON, deserialized)


class WeatherOperations:
    """
    .. warning::
        **DO NOT** instantiate this class directly.

        Instead, you should access the following operations through
        :class:`~azure.agrifood.farming.FarmBeatsClient`'s
        :attr:`weather` attribute.
    """

    def __init__(self, *args, **kwargs):
        input_args = list(args)
        self._client = input_args.pop(0) if input_args else kwargs.pop("client")
        self._config = input_args.pop(0) if input_args else kwargs.pop("config")
        self._serialize = input_args.pop(0) if input_args else kwargs.pop("serializer")
        self._deserialize = input_args.pop(0) if input_args else kwargs.pop("deserializer")

    @distributed_trace
    def list(
        self,
        *,
        party_id: str,
        boundary_id: str,
        extension_id: str,
        weather_data_type: str,
        granularity: str,
        start_date_time: Optional[datetime.datetime] = None,
        end_date_time: Optional[datetime.datetime] = None,
        skip_token: Optional[str] = None,
        **kwargs: Any
    ) -> Iterable[JSON]:
        """Returns a paginated list of weather data.

        :keyword party_id: Party ID. Required.
        :paramtype party_id: str
        :keyword boundary_id: Boundary ID. Required.
        :paramtype boundary_id: str
        :keyword extension_id: ID of the weather extension. Required.
        :paramtype extension_id: str
        :keyword weather_data_type: Type of weather data (forecast/historical). Required.
        :paramtype weather_data_type: str
        :keyword granularity: Granularity of weather data (daily/hourly). Required.
        :paramtype granularity: str
        :keyword start_date_time: Weather data start UTC date-time (inclusive), sample format:
         yyyy-MM-ddTHH:mm:ssZ. Default value is None.
        :paramtype start_date_time: ~datetime.datetime
        :keyword end_date_time: Weather data end UTC date-time (inclusive), sample format:
         yyyy-MM-ddTHH:mm:ssZ. Default value is None.
        :paramtype end_date_time: ~datetime.datetime
        :keyword skip_token: Skip token for getting next set of results. Default value is None.
        :paramtype skip_token: str
        :return: An iterator like instance of JSON object
        :rtype: ~azure.core.paging.ItemPaged[JSON]
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "boundaryId": "str",  # Boundary ID. Required.
                    "dateTime": "2020-02-20 00:00:00",  # Date-time of the weather data, sample
                      format: yyyy-MM-ddTHH:mm:ssZ. Required.
                    "extensionId": "str",  # ID of the weather extension. Required.
                    "extensionVersion": "str",  # Version of the weather data extension.
                      Required.
                    "granularity": "str",  # Granularity of weather data (daily/hourly).
                      Required.
                    "location": {
                        "latitude": 0.0,  # Latitude of the location. Required.
                        "longitude": 0.0  # Longitude of the location. Required.
                    },
                    "partyId": "str",  # Party ID. Required.
                    "weatherDataType": "str",  # Type of weather data (forecast/historical).
                      Required.
                    "cloudCover": {
                        "unit": "str",  # Optional. Data unit.
                        "value": 0.0  # Optional. Data value.
                    },
                    "createdDateTime": "2020-02-20 00:00:00",  # Optional. Date-time when
                      resource was created, sample format: yyyy-MM-ddTHH:mm:ssZ.
                    "dewPoint": {
                        "unit": "str",  # Optional. Data unit.
                        "value": 0.0  # Optional. Data value.
                    },
                    "eTag": "str",  # Optional. The ETag value to implement optimistic
                      concurrency.
                    "growingDegreeDay": {
                        "unit": "str",  # Optional. Data unit.
                        "value": 0.0  # Optional. Data value.
                    },
                    "id": "str",  # Optional. Weather data ID.
                    "modifiedDateTime": "2020-02-20 00:00:00",  # Optional. Date-time when
                      resource was last modified, sample format: yyyy-MM-ddTHH:mm:ssZ.
                    "precipitation": {
                        "unit": "str",  # Optional. Data unit.
                        "value": 0.0  # Optional. Data value.
                    },
                    "pressure": {
                        "unit": "str",  # Optional. Data unit.
                        "value": 0.0  # Optional. Data value.
                    },
                    "properties": {
                        "str": {}  # Optional. A collection of key value pairs that belongs
                          to the resource."nEach pair must not have a key greater than 50
                          characters"nand must not have a value greater than 250 characters."nNote: A
                          maximum of 25 key value pairs can be provided for a resource and only string
                          and numeral values are supported.
                    },
                    "relativeHumidity": {
                        "unit": "str",  # Optional. Data unit.
                        "value": 0.0  # Optional. Data value.
                    },
                    "soilMoisture": {
                        "unit": "str",  # Optional. Data unit.
                        "value": 0.0  # Optional. Data value.
                    },
                    "soilTemperature": {
                        "unit": "str",  # Optional. Data unit.
                        "value": 0.0  # Optional. Data value.
                    },
                    "temperature": {
                        "unit": "str",  # Optional. Data unit.
                        "value": 0.0  # Optional. Data value.
                    },
                    "unitSystemCode": "str",  # Optional. Unit System like US/SI etc.
                    "visibility": {
                        "unit": "str",  # Optional. Data unit.
                        "value": 0.0  # Optional. Data value.
                    },
                    "wetBulbTemperature": {
                        "unit": "str",  # Optional. Data unit.
                        "value": 0.0  # Optional. Data value.
                    },
                    "windChill": {
                        "unit": "str",  # Optional. Data unit.
                        "value": 0.0  # Optional. Data value.
                    },
                    "windDirection": {
                        "unit": "str",  # Optional. Data unit.
                        "value": 0.0  # Optional. Data value.
                    },
                    "windGust": {
                        "unit": "str",  # Optional. Data unit.
                        "value": 0.0  # Optional. Data value.
                    },
                    "windSpeed": {
                        "unit": "str",  # Optional. Data unit.
                        "value": 0.0  # Optional. Data value.
                    }
                }
        """
        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls = kwargs.pop("cls", None)  # type: ClsType[JSON]

        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        def prepare_request(next_link=None):
            if not next_link:

                request = build_weather_list_request(
                    party_id=party_id,
                    boundary_id=boundary_id,
                    extension_id=extension_id,
                    weather_data_type=weather_data_type,
                    granularity=granularity,
                    start_date_time=start_date_time,
                    end_date_time=end_date_time,
                    skip_token=skip_token,
                    api_version=self._config.api_version,
                    headers=_headers,
                    params=_params,
                )
                request.url = self._client.format_url(request.url)  # type: ignore

            else:
                # make call to next link with the client's api-version
                _parsed_next_link = urlparse(next_link)
                _next_request_params = case_insensitive_dict(parse_qs(_parsed_next_link.query))
                _next_request_params["api-version"] = self._config.api_version
                request = HttpRequest("GET", urljoin(next_link, _parsed_next_link.path), params=_next_request_params)
                request.url = self._client.format_url(request.url)  # type: ignore

            return request

        def extract_data(pipeline_response):
            deserialized = pipeline_response.http_response.json()
            list_of_elem = deserialized["value"]
            if cls:
                list_of_elem = cls(list_of_elem)
            return deserialized.get("nextLink", None), iter(list_of_elem)

        def get_next(next_link=None):
            request = prepare_request(next_link)

            pipeline_response = self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
                request, stream=False, **kwargs
            )
            response = pipeline_response.http_response

            if response.status_code not in [200]:
                map_error(status_code=response.status_code, response=response, error_map=error_map)
                raise HttpResponseError(response=response)

            return pipeline_response

        return ItemPaged(get_next, extract_data)

    @distributed_trace
    def get_data_delete_job_details(self, job_id: str, **kwargs: Any) -> JSON:
        """Get weather data delete job.

        :param job_id: Id of the job. Required.
        :type job_id: str
        :return: JSON object
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "boundaryId": "str",  # The id of the boundary object for which weather data
                      is being fetched. Required.
                    "extensionId": "str",  # Id of the extension to be used for the
                      providerInput. eg. DTN.ClearAg. Required.
                    "partyId": "str",  # The id of the party for which weather data is being
                      fetched. Required.
                    "createdBy": "str",  # Optional. Created by user/tenant id.
                    "createdDateTime": "2020-02-20 00:00:00",  # Optional. Job created at
                      dateTime. Sample format: yyyy-MM-ddTHH:mm:ssZ.
                    "description": "str",  # Optional. Textual description of the resource.
                    "durationInSeconds": 0.0,  # Optional. Duration of the job in seconds.
                    "endDateTime": "2020-02-20 00:00:00",  # Optional. Weather data end UTC
                      date-time (inclusive), sample format: yyyy-MM-ddTHH:mm:ssZ.
                    "endTime": "2020-02-20 00:00:00",  # Optional. Job end time when available.
                      Sample format: yyyy-MM-ddTHH:mm:ssZ.
                    "errorCode": "str",  # Optional. Error Code when job failed.
                    "granularity": "str",  # Optional. Granularity of weather data. Possible
                      values include: 'daily' , 'hourly'.
                    "id": "str",  # Optional. Unique job id.
                    "lastActionDateTime": "2020-02-20 00:00:00",  # Optional. Job was last acted
                      upon at dateTime. Sample format: yyyy-MM-ddTHH:mm:ssZ.
                    "message": "str",  # Optional. Status message to capture more details of the
                      job.
                    "modifiedBy": "str",  # Optional. Modified by user/tenant id.
                    "name": "str",  # Optional. Name to identify resource.
                    "properties": {
                        "str": {}  # Optional. A collection of key value pairs that belongs
                          to the resource."nEach pair must not have a key greater than 50
                          characters"nand must not have a value greater than 150 characters."nNote: A
                          maximum of 25 key value pairs can be provided for a resource and only
                          string,"nnumeral and datetime (yyyy-MM-ddTHH:mm:ssZ) values are supported.
                    },
                    "startDateTime": "2020-02-20 00:00:00",  # Optional. Weather data start UTC
                      date-time (inclusive), sample format: yyyy-MM-ddTHH:mm:ssZ.
                    "startTime": "2020-02-20 00:00:00",  # Optional. Job start time when
                      available. Sample format: yyyy-MM-ddTHH:mm:ssZ.
                    "status": "str",  # Optional. Status of the job."nPossible values: 'Waiting',
                      'Running', 'Succeeded', 'Failed', 'Cancelled'.
                    "weatherDataType": "str"  # Optional. Type of weather data. Possible values
                      include: 'forecast' , 'historical'.
                }
        """
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls = kwargs.pop("cls", None)  # type: ClsType[JSON]

        request = build_weather_get_data_delete_job_details_request(
            job_id=job_id,
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        request.url = self._client.format_url(request.url)  # type: ignore

        pipeline_response = self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
            request, stream=False, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if response.content:
            deserialized = response.json()
        else:
            deserialized = None

        if cls:
            return cls(pipeline_response, cast(JSON, deserialized), {})

        return cast(JSON, deserialized)

    def _create_data_delete_job_initial(self, job_id: str, job: Union[JSON, IO], **kwargs: Any) -> JSON:
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type = kwargs.pop("content_type", _headers.pop("Content-Type", None))  # type: Optional[str]
        cls = kwargs.pop("cls", None)  # type: ClsType[JSON]

        content_type = content_type or "application/json"
        _json = None
        _content = None
        if isinstance(job, (IO, bytes)):
            _content = job
        else:
            _json = job

        request = build_weather_create_data_delete_job_request(
            job_id=job_id,
            content_type=content_type,
            api_version=self._config.api_version,
            json=_json,
            content=_content,
            headers=_headers,
            params=_params,
        )
        request.url = self._client.format_url(request.url)  # type: ignore

        pipeline_response = self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
            request, stream=False, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [202]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if response.content:
            deserialized = response.json()
        else:
            deserialized = None

        if cls:
            return cls(pipeline_response, cast(JSON, deserialized), {})

        return cast(JSON, deserialized)

    @overload
    def begin_create_data_delete_job(
        self, job_id: str, job: JSON, *, content_type: str = "application/json", **kwargs: Any
    ) -> LROPoller[JSON]:
        """Create a weather data delete job.

        :param job_id: Job Id supplied by end user. Required.
        :type job_id: str
        :param job: Job parameters supplied by user. Required.
        :type job: JSON
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :keyword str continuation_token: A continuation token to restart a poller from a saved state.
        :keyword polling: By default, your polling method will be LROBasePolling. Pass in False for
         this operation to not poll, or pass in your own initialized polling object for a personal
         polling strategy.
        :paramtype polling: bool or ~azure.core.polling.PollingMethod
        :keyword int polling_interval: Default waiting time between two polls for LRO operations if no
         Retry-After header is present.
        :return: An instance of LROPoller that returns JSON object
        :rtype: ~azure.core.polling.LROPoller[JSON]
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                job = {
                    "boundaryId": "str",  # The id of the boundary object for which weather data
                      is being fetched. Required.
                    "extensionId": "str",  # Id of the extension to be used for the
                      providerInput. eg. DTN.ClearAg. Required.
                    "partyId": "str",  # The id of the party for which weather data is being
                      fetched. Required.
                    "createdBy": "str",  # Optional. Created by user/tenant id.
                    "createdDateTime": "2020-02-20 00:00:00",  # Optional. Job created at
                      dateTime. Sample format: yyyy-MM-ddTHH:mm:ssZ.
                    "description": "str",  # Optional. Textual description of the resource.
                    "durationInSeconds": 0.0,  # Optional. Duration of the job in seconds.
                    "endDateTime": "2020-02-20 00:00:00",  # Optional. Weather data end UTC
                      date-time (inclusive), sample format: yyyy-MM-ddTHH:mm:ssZ.
                    "endTime": "2020-02-20 00:00:00",  # Optional. Job end time when available.
                      Sample format: yyyy-MM-ddTHH:mm:ssZ.
                    "errorCode": "str",  # Optional. Error Code when job failed.
                    "granularity": "str",  # Optional. Granularity of weather data. Possible
                      values include: 'daily' , 'hourly'.
                    "id": "str",  # Optional. Unique job id.
                    "lastActionDateTime": "2020-02-20 00:00:00",  # Optional. Job was last acted
                      upon at dateTime. Sample format: yyyy-MM-ddTHH:mm:ssZ.
                    "message": "str",  # Optional. Status message to capture more details of the
                      job.
                    "modifiedBy": "str",  # Optional. Modified by user/tenant id.
                    "name": "str",  # Optional. Name to identify resource.
                    "properties": {
                        "str": {}  # Optional. A collection of key value pairs that belongs
                          to the resource."nEach pair must not have a key greater than 50
                          characters"nand must not have a value greater than 150 characters."nNote: A
                          maximum of 25 key value pairs can be provided for a resource and only
                          string,"nnumeral and datetime (yyyy-MM-ddTHH:mm:ssZ) values are supported.
                    },
                    "startDateTime": "2020-02-20 00:00:00",  # Optional. Weather data start UTC
                      date-time (inclusive), sample format: yyyy-MM-ddTHH:mm:ssZ.
                    "startTime": "2020-02-20 00:00:00",  # Optional. Job start time when
                      available. Sample format: yyyy-MM-ddTHH:mm:ssZ.
                    "status": "str",  # Optional. Status of the job."nPossible values: 'Waiting',
                      'Running', 'Succeeded', 'Failed', 'Cancelled'.
                    "weatherDataType": "str"  # Optional. Type of weather data. Possible values
                      include: 'forecast' , 'historical'.
                }

                # response body for status code(s): 202
                response == {
                    "boundaryId": "str",  # The id of the boundary object for which weather data
                      is being fetched. Required.
                    "extensionId": "str",  # Id of the extension to be used for the
                      providerInput. eg. DTN.ClearAg. Required.
                    "partyId": "str",  # The id of the party for which weather data is being
                      fetched. Required.
                    "createdBy": "str",  # Optional. Created by user/tenant id.
                    "createdDateTime": "2020-02-20 00:00:00",  # Optional. Job created at
                      dateTime. Sample format: yyyy-MM-ddTHH:mm:ssZ.
                    "description": "str",  # Optional. Textual description of the resource.
                    "durationInSeconds": 0.0,  # Optional. Duration of the job in seconds.
                    "endDateTime": "2020-02-20 00:00:00",  # Optional. Weather data end UTC
                      date-time (inclusive), sample format: yyyy-MM-ddTHH:mm:ssZ.
                    "endTime": "2020-02-20 00:00:00",  # Optional. Job end time when available.
                      Sample format: yyyy-MM-ddTHH:mm:ssZ.
                    "errorCode": "str",  # Optional. Error Code when job failed.
                    "granularity": "str",  # Optional. Granularity of weather data. Possible
                      values include: 'daily' , 'hourly'.
                    "id": "str",  # Optional. Unique job id.
                    "lastActionDateTime": "2020-02-20 00:00:00",  # Optional. Job was last acted
                      upon at dateTime. Sample format: yyyy-MM-ddTHH:mm:ssZ.
                    "message": "str",  # Optional. Status message to capture more details of the
                      job.
                    "modifiedBy": "str",  # Optional. Modified by user/tenant id.
                    "name": "str",  # Optional. Name to identify resource.
                    "properties": {
                        "str": {}  # Optional. A collection of key value pairs that belongs
                          to the resource."nEach pair must not have a key greater than 50
                          characters"nand must not have a value greater than 150 characters."nNote: A
                          maximum of 25 key value pairs can be provided for a resource and only
                          string,"nnumeral and datetime (yyyy-MM-ddTHH:mm:ssZ) values are supported.
                    },
                    "startDateTime": "2020-02-20 00:00:00",  # Optional. Weather data start UTC
                      date-time (inclusive), sample format: yyyy-MM-ddTHH:mm:ssZ.
                    "startTime": "2020-02-20 00:00:00",  # Optional. Job start time when
                      available. Sample format: yyyy-MM-ddTHH:mm:ssZ.
                    "status": "str",  # Optional. Status of the job."nPossible values: 'Waiting',
                      'Running', 'Succeeded', 'Failed', 'Cancelled'.
                    "weatherDataType": "str"  # Optional. Type of weather data. Possible values
                      include: 'forecast' , 'historical'.
                }
        """

    @overload
    def begin_create_data_delete_job(
        self, job_id: str, job: IO, *, content_type: str = "application/json", **kwargs: Any
    ) -> LROPoller[JSON]:
        """Create a weather data delete job.

        :param job_id: Job Id supplied by end user. Required.
        :type job_id: str
        :param job: Job parameters supplied by user. Required.
        :type job: IO
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Default value is "application/json".
        :paramtype content_type: str
        :keyword str continuation_token: A continuation token to restart a poller from a saved state.
        :keyword polling: By default, your polling method will be LROBasePolling. Pass in False for
         this operation to not poll, or pass in your own initialized polling object for a personal
         polling strategy.
        :paramtype polling: bool or ~azure.core.polling.PollingMethod
        :keyword int polling_interval: Default waiting time between two polls for LRO operations if no
         Retry-After header is present.
        :return: An instance of LROPoller that returns JSON object
        :rtype: ~azure.core.polling.LROPoller[JSON]
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 202
                response == {
                    "boundaryId": "str",  # The id of the boundary object for which weather data
                      is being fetched. Required.
                    "extensionId": "str",  # Id of the extension to be used for the
                      providerInput. eg. DTN.ClearAg. Required.
                    "partyId": "str",  # The id of the party for which weather data is being
                      fetched. Required.
                    "createdBy": "str",  # Optional. Created by user/tenant id.
                    "createdDateTime": "2020-02-20 00:00:00",  # Optional. Job created at
                      dateTime. Sample format: yyyy-MM-ddTHH:mm:ssZ.
                    "description": "str",  # Optional. Textual description of the resource.
                    "durationInSeconds": 0.0,  # Optional. Duration of the job in seconds.
                    "endDateTime": "2020-02-20 00:00:00",  # Optional. Weather data end UTC
                      date-time (inclusive), sample format: yyyy-MM-ddTHH:mm:ssZ.
                    "endTime": "2020-02-20 00:00:00",  # Optional. Job end time when available.
                      Sample format: yyyy-MM-ddTHH:mm:ssZ.
                    "errorCode": "str",  # Optional. Error Code when job failed.
                    "granularity": "str",  # Optional. Granularity of weather data. Possible
                      values include: 'daily' , 'hourly'.
                    "id": "str",  # Optional. Unique job id.
                    "lastActionDateTime": "2020-02-20 00:00:00",  # Optional. Job was last acted
                      upon at dateTime. Sample format: yyyy-MM-ddTHH:mm:ssZ.
                    "message": "str",  # Optional. Status message to capture more details of the
                      job.
                    "modifiedBy": "str",  # Optional. Modified by user/tenant id.
                    "name": "str",  # Optional. Name to identify resource.
                    "properties": {
                        "str": {}  # Optional. A collection of key value pairs that belongs
                          to the resource."nEach pair must not have a key greater than 50
                          characters"nand must not have a value greater than 150 characters."nNote: A
                          maximum of 25 key value pairs can be provided for a resource and only
                          string,"nnumeral and datetime (yyyy-MM-ddTHH:mm:ssZ) values are supported.
                    },
                    "startDateTime": "2020-02-20 00:00:00",  # Optional. Weather data start UTC
                      date-time (inclusive), sample format: yyyy-MM-ddTHH:mm:ssZ.
                    "startTime": "2020-02-20 00:00:00",  # Optional. Job start time when
                      available. Sample format: yyyy-MM-ddTHH:mm:ssZ.
                    "status": "str",  # Optional. Status of the job."nPossible values: 'Waiting',
                      'Running', 'Succeeded', 'Failed', 'Cancelled'.
                    "weatherDataType": "str"  # Optional. Type of weather data. Possible values
                      include: 'forecast' , 'historical'.
                }
        """

    @distributed_trace
    def begin_create_data_delete_job(self, job_id: str, job: Union[JSON, IO], **kwargs: Any) -> LROPoller[JSON]:
        """Create a weather data delete job.

        :param job_id: Job Id supplied by end user. Required.
        :type job_id: str
        :param job: Job parameters supplied by user. Is either a model type or a IO type. Required.
        :type job: JSON or IO
        :keyword content_type: Body Parameter content-type. Known values are: 'application/json'.
         Default value is None.
        :paramtype content_type: str
        :keyword str continuation_token: A continuation token to restart a poller from a saved state.
        :keyword polling: By default, your polling method will be LROBasePolling. Pass in False for
         this operation to not poll, or pass in your own initialized polling object for a personal
         polling strategy.
        :paramtype polling: bool or ~azure.core.polling.PollingMethod
        :keyword int polling_interval: Default waiting time between two polls for LRO operations if no
         Retry-After header is present.
        :return: An instance of LROPoller that returns JSON object
        :rtype: ~azure.core.polling.LROPoller[JSON]
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 202
                response == {
                    "boundaryId": "str",  # The id of the boundary object for which weather data
                      is being fetched. Required.
                    "extensionId": "str",  # Id of the extension to be used for the
                      providerInput. eg. DTN.ClearAg. Required.
                    "partyId": "str",  # The id of the party for which weather data is being
                      fetched. Required.
                    "createdBy": "str",  # Optional. Created by user/tenant id.
                    "createdDateTime": "2020-02-20 00:00:00",  # Optional. Job created at
                      dateTime. Sample format: yyyy-MM-ddTHH:mm:ssZ.
                    "description": "str",  # Optional. Textual description of the resource.
                    "durationInSeconds": 0.0,  # Optional. Duration of the job in seconds.
                    "endDateTime": "2020-02-20 00:00:00",  # Optional. Weather data end UTC
                      date-time (inclusive), sample format: yyyy-MM-ddTHH:mm:ssZ.
                    "endTime": "2020-02-20 00:00:00",  # Optional. Job end time when available.
                      Sample format: yyyy-MM-ddTHH:mm:ssZ.
                    "errorCode": "str",  # Optional. Error Code when job failed.
                    "granularity": "str",  # Optional. Granularity of weather data. Possible
                      values include: 'daily' , 'hourly'.
                    "id": "str",  # Optional. Unique job id.
                    "lastActionDateTime": "2020-02-20 00:00:00",  # Optional. Job was last acted
                      upon at dateTime. Sample format: yyyy-MM-ddTHH:mm:ssZ.
                    "message": "str",  # Optional. Status message to capture more details of the
                      job.
                    "modifiedBy": "str",  # Optional. Modified by user/tenant id.
                    "name": "str",  # Optional. Name to identify resource.
                    "properties": {
                        "str": {}  # Optional. A collection of key value pairs that belongs
                          to the resource."nEach pair must not have a key greater than 50
                          characters"nand must not have a value greater than 150 characters."nNote: A
                          maximum of 25 key value pairs can be provided for a resource and only
                          string,"nnumeral and datetime (yyyy-MM-ddTHH:mm:ssZ) values are supported.
                    },
                    "startDateTime": "2020-02-20 00:00:00",  # Optional. Weather data start UTC
                      date-time (inclusive), sample format: yyyy-MM-ddTHH:mm:ssZ.
                    "startTime": "2020-02-20 00:00:00",  # Optional. Job start time when
                      available. Sample format: yyyy-MM-ddTHH:mm:ssZ.
                    "status": "str",  # Optional. Status of the job."nPossible values: 'Waiting',
                      'Running', 'Succeeded', 'Failed', 'Cancelled'.
                    "weatherDataType": "str"  # Optional. Type of weather data. Possible values
                      include: 'forecast' , 'historical'.
                }
        """
        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type = kwargs.pop("content_type", _headers.pop("Content-Type", None))  # type: Optional[str]
        cls = kwargs.pop("cls", None)  # type: ClsType[JSON]
        polling = kwargs.pop("polling", True)  # type: Union[bool, PollingMethod]
        lro_delay = kwargs.pop("polling_interval", self._config.polling_interval)
        cont_token = kwargs.pop("continuation_token", None)  # type: Optional[str]
        if cont_token is None:
            raw_result = self._create_data_delete_job_initial(  # type: ignore
                job_id=job_id,
                job=job,
                content_type=content_type,
                cls=lambda x, y, z: x,
                headers=_headers,
                params=_params,
                **kwargs
            )
        kwargs.pop("error_map", None)

        def get_long_running_output(pipeline_response):
            response = pipeline_response.http_response
            if response.content:
                deserialized = response.json()
            else:
                deserialized = None
            if cls:
                return cls(pipeline_response, deserialized, {})
            return deserialized

        if polling is True:
            polling_method = cast(
                PollingMethod, LROBasePolling(lro_delay, lro_options={"final-state-via": "location"}, **kwargs)
            )  # type: PollingMethod
        elif polling is False:
            polling_method = cast(PollingMethod, NoPolling())
        else:
            polling_method = polling
        if cont_token:
            return LROPoller.from_continuation_token(
                polling_method=polling_method,
                continuation_token=cont_token,
                client=self._client,
                deserialization_callback=get_long_running_output,
            )
        return LROPoller(self._client, raw_result, get_long_running_output, polling_method)

    @distributed_trace
    def get_data_ingestion_job_details(self, job_id: str, **kwargs: Any) -> JSON:
        """Get weather ingestion job.

        :param job_id: Id of the job. Required.
        :type job_id: str
        :return: JSON object
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "boundaryId": "str",  # The id of the boundary object for which weather data
                      is being fetched. Required.
                    "extensionApiInput": {
                        "str": {}  # Extension api input dictionary which would be used to
                          feed request query/body/parameter information. Required.
                    },
                    "extensionApiName": "str",  # Extension api name to which request is to be
                      made. Required.
                    "extensionId": "str",  # Id of the extension to be used for the
                      providerInput. eg. DTN.ClearAg. Required.
                    "partyId": "str",  # The id of the party for which weather data is being
                      fetched. Required.
                    "createdBy": "str",  # Optional. Created by user/tenant id.
                    "createdDateTime": "2020-02-20 00:00:00",  # Optional. Job created at
                      dateTime. Sample format: yyyy-MM-ddTHH:mm:ssZ.
                    "description": "str",  # Optional. Textual description of the resource.
                    "durationInSeconds": 0.0,  # Optional. Duration of the job in seconds.
                    "endTime": "2020-02-20 00:00:00",  # Optional. Job end time when available.
                      Sample format: yyyy-MM-ddTHH:mm:ssZ.
                    "errorCode": "str",  # Optional. Error Code when job failed.
                    "extensionDataProviderApiKey": "str",  # Optional. Api key of the weather
                      data provider.
                    "extensionDataProviderAppId": "str",  # Optional. App id of the weather data
                      provider.
                    "id": "str",  # Optional. Unique job id.
                    "lastActionDateTime": "2020-02-20 00:00:00",  # Optional. Job was last acted
                      upon at dateTime. Sample format: yyyy-MM-ddTHH:mm:ssZ.
                    "message": "str",  # Optional. Status message to capture more details of the
                      job.
                    "modifiedBy": "str",  # Optional. Modified by user/tenant id.
                    "name": "str",  # Optional. Name to identify resource.
                    "properties": {
                        "str": {}  # Optional. A collection of key value pairs that belongs
                          to the resource."nEach pair must not have a key greater than 50
                          characters"nand must not have a value greater than 150 characters."nNote: A
                          maximum of 25 key value pairs can be provided for a resource and only
                          string,"nnumeral and datetime (yyyy-MM-ddTHH:mm:ssZ) values are supported.
                    },
                    "startTime": "2020-02-20 00:00:00",  # Optional. Job start time when
                      available. Sample format: yyyy-MM-ddTHH:mm:ssZ.
                    "status": "str"  # Optional. Status of the job."nPossible values: 'Waiting',
                      'Running', 'Succeeded', 'Failed', 'Cancelled'.
                }
        """
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls = kwargs.pop("cls", None)  # type: ClsType[JSON]

        request = build_weather_get_data_ingestion_job_details_request(
            job_id=job_id,
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        request.url = self._client.format_url(request.url)  # type: ignore

        pipeline_response = self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
            request, stream=False, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if response.content:
            deserialized = response.json()
        else:
            deserialized = None

        if cls:
            return cls(pipeline_response, cast(JSON, deserialized), {})

        return cast(JSON, deserialized)

    def _create_data_ingestion_job_initial(self, job_id: str, job: Union[JSON, IO], **kwargs: Any) -> JSON:
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type = kwargs.pop("content_type", _headers.pop("Content-Type", None))  # type: Optional[str]
        cls = kwargs.pop("cls", None)  # type: ClsType[JSON]

        content_type = content_type or "application/json"
        _json = None
        _content = None
        if isinstance(job, (IO, bytes)):
            _content = job
        else:
            _json = job

        request = build_weather_create_data_ingestion_job_request(
            job_id=job_id,
            content_type=content_type,
            api_version=self._config.api_version,
            json=_json,
            content=_content,
            headers=_headers,
            params=_params,
        )
        request.url = self._client.format_url(request.url)  # type: ignore

        pipeline_response = self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
            request, stream=False, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [202]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if response.content:
            deserialized = response.json()
        else:
            deserialized = None

        if cls:
            return cls(pipeline_response, cast(JSON, deserialized), {})

        return cast(JSON, deserialized)

    @overload
    def begin_create_data_ingestion_job(
        self, job_id: str, job: JSON, *, content_type: str = "application/json", **kwargs: Any
    ) -> LROPoller[JSON]:
        """Create a weather data ingestion job.

        :param job_id: Job id supplied by user. Required.
        :type job_id: str
        :param job: Job parameters supplied by user. Required.
        :type job: JSON
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :keyword str continuation_token: A continuation token to restart a poller from a saved state.
        :keyword polling: By default, your polling method will be LROBasePolling. Pass in False for
         this operation to not poll, or pass in your own initialized polling object for a personal
         polling strategy.
        :paramtype polling: bool or ~azure.core.polling.PollingMethod
        :keyword int polling_interval: Default waiting time between two polls for LRO operations if no
         Retry-After header is present.
        :return: An instance of LROPoller that returns JSON object
        :rtype: ~azure.core.polling.LROPoller[JSON]
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                job = {
                    "boundaryId": "str",  # The id of the boundary object for which weather data
                      is being fetched. Required.
                    "extensionApiInput": {
                        "str": {}  # Extension api input dictionary which would be used to
                          feed request query/body/parameter information. Required.
                    },
                    "extensionApiName": "str",  # Extension api name to which request is to be
                      made. Required.
                    "extensionId": "str",  # Id of the extension to be used for the
                      providerInput. eg. DTN.ClearAg. Required.
                    "partyId": "str",  # The id of the party for which weather data is being
                      fetched. Required.
                    "createdBy": "str",  # Optional. Created by user/tenant id.
                    "createdDateTime": "2020-02-20 00:00:00",  # Optional. Job created at
                      dateTime. Sample format: yyyy-MM-ddTHH:mm:ssZ.
                    "description": "str",  # Optional. Textual description of the resource.
                    "durationInSeconds": 0.0,  # Optional. Duration of the job in seconds.
                    "endTime": "2020-02-20 00:00:00",  # Optional. Job end time when available.
                      Sample format: yyyy-MM-ddTHH:mm:ssZ.
                    "errorCode": "str",  # Optional. Error Code when job failed.
                    "extensionDataProviderApiKey": "str",  # Optional. Api key of the weather
                      data provider.
                    "extensionDataProviderAppId": "str",  # Optional. App id of the weather data
                      provider.
                    "id": "str",  # Optional. Unique job id.
                    "lastActionDateTime": "2020-02-20 00:00:00",  # Optional. Job was last acted
                      upon at dateTime. Sample format: yyyy-MM-ddTHH:mm:ssZ.
                    "message": "str",  # Optional. Status message to capture more details of the
                      job.
                    "modifiedBy": "str",  # Optional. Modified by user/tenant id.
                    "name": "str",  # Optional. Name to identify resource.
                    "properties": {
                        "str": {}  # Optional. A collection of key value pairs that belongs
                          to the resource."nEach pair must not have a key greater than 50
                          characters"nand must not have a value greater than 150 characters."nNote: A
                          maximum of 25 key value pairs can be provided for a resource and only
                          string,"nnumeral and datetime (yyyy-MM-ddTHH:mm:ssZ) values are supported.
                    },
                    "startTime": "2020-02-20 00:00:00",  # Optional. Job start time when
                      available. Sample format: yyyy-MM-ddTHH:mm:ssZ.
                    "status": "str"  # Optional. Status of the job."nPossible values: 'Waiting',
                      'Running', 'Succeeded', 'Failed', 'Cancelled'.
                }

                # response body for status code(s): 202
                response == {
                    "boundaryId": "str",  # The id of the boundary object for which weather data
                      is being fetched. Required.
                    "extensionApiInput": {
                        "str": {}  # Extension api input dictionary which would be used to
                          feed request query/body/parameter information. Required.
                    },
                    "extensionApiName": "str",  # Extension api name to which request is to be
                      made. Required.
                    "extensionId": "str",  # Id of the extension to be used for the
                      providerInput. eg. DTN.ClearAg. Required.
                    "partyId": "str",  # The id of the party for which weather data is being
                      fetched. Required.
                    "createdBy": "str",  # Optional. Created by user/tenant id.
                    "createdDateTime": "2020-02-20 00:00:00",  # Optional. Job created at
                      dateTime. Sample format: yyyy-MM-ddTHH:mm:ssZ.
                    "description": "str",  # Optional. Textual description of the resource.
                    "durationInSeconds": 0.0,  # Optional. Duration of the job in seconds.
                    "endTime": "2020-02-20 00:00:00",  # Optional. Job end time when available.
                      Sample format: yyyy-MM-ddTHH:mm:ssZ.
                    "errorCode": "str",  # Optional. Error Code when job failed.
                    "extensionDataProviderApiKey": "str",  # Optional. Api key of the weather
                      data provider.
                    "extensionDataProviderAppId": "str",  # Optional. App id of the weather data
                      provider.
                    "id": "str",  # Optional. Unique job id.
                    "lastActionDateTime": "2020-02-20 00:00:00",  # Optional. Job was last acted
                      upon at dateTime. Sample format: yyyy-MM-ddTHH:mm:ssZ.
                    "message": "str",  # Optional. Status message to capture more details of the
                      job.
                    "modifiedBy": "str",  # Optional. Modified by user/tenant id.
                    "name": "str",  # Optional. Name to identify resource.
                    "properties": {
                        "str": {}  # Optional. A collection of key value pairs that belongs
                          to the resource."nEach pair must not have a key greater than 50
                          characters"nand must not have a value greater than 150 characters."nNote: A
                          maximum of 25 key value pairs can be provided for a resource and only
                          string,"nnumeral and datetime (yyyy-MM-ddTHH:mm:ssZ) values are supported.
                    },
                    "startTime": "2020-02-20 00:00:00",  # Optional. Job start time when
                      available. Sample format: yyyy-MM-ddTHH:mm:ssZ.
                    "status": "str"  # Optional. Status of the job."nPossible values: 'Waiting',
                      'Running', 'Succeeded', 'Failed', 'Cancelled'.
                }
        """

    @overload
    def begin_create_data_ingestion_job(
        self, job_id: str, job: IO, *, content_type: str = "application/json", **kwargs: Any
    ) -> LROPoller[JSON]:
        """Create a weather data ingestion job.

        :param job_id: Job id supplied by user. Required.
        :type job_id: str
        :param job: Job parameters supplied by user. Required.
        :type job: IO
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Default value is "application/json".
        :paramtype content_type: str
        :keyword str continuation_token: A continuation token to restart a poller from a saved state.
        :keyword polling: By default, your polling method will be LROBasePolling. Pass in False for
         this operation to not poll, or pass in your own initialized polling object for a personal
         polling strategy.
        :paramtype polling: bool or ~azure.core.polling.PollingMethod
        :keyword int polling_interval: Default waiting time between two polls for LRO operations if no
         Retry-After header is present.
        :return: An instance of LROPoller that returns JSON object
        :rtype: ~azure.core.polling.LROPoller[JSON]
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 202
                response == {
                    "boundaryId": "str",  # The id of the boundary object for which weather data
                      is being fetched. Required.
                    "extensionApiInput": {
                        "str": {}  # Extension api input dictionary which would be used to
                          feed request query/body/parameter information. Required.
                    },
                    "extensionApiName": "str",  # Extension api name to which request is to be
                      made. Required.
                    "extensionId": "str",  # Id of the extension to be used for the
                      providerInput. eg. DTN.ClearAg. Required.
                    "partyId": "str",  # The id of the party for which weather data is being
                      fetched. Required.
                    "createdBy": "str",  # Optional. Created by user/tenant id.
                    "createdDateTime": "2020-02-20 00:00:00",  # Optional. Job created at
                      dateTime. Sample format: yyyy-MM-ddTHH:mm:ssZ.
                    "description": "str",  # Optional. Textual description of the resource.
                    "durationInSeconds": 0.0,  # Optional. Duration of the job in seconds.
                    "endTime": "2020-02-20 00:00:00",  # Optional. Job end time when available.
                      Sample format: yyyy-MM-ddTHH:mm:ssZ.
                    "errorCode": "str",  # Optional. Error Code when job failed.
                    "extensionDataProviderApiKey": "str",  # Optional. Api key of the weather
                      data provider.
                    "extensionDataProviderAppId": "str",  # Optional. App id of the weather data
                      provider.
                    "id": "str",  # Optional. Unique job id.
                    "lastActionDateTime": "2020-02-20 00:00:00",  # Optional. Job was last acted
                      upon at dateTime. Sample format: yyyy-MM-ddTHH:mm:ssZ.
                    "message": "str",  # Optional. Status message to capture more details of the
                      job.
                    "modifiedBy": "str",  # Optional. Modified by user/tenant id.
                    "name": "str",  # Optional. Name to identify resource.
                    "properties": {
                        "str": {}  # Optional. A collection of key value pairs that belongs
                          to the resource."nEach pair must not have a key greater than 50
                          characters"nand must not have a value greater than 150 characters."nNote: A
                          maximum of 25 key value pairs can be provided for a resource and only
                          string,"nnumeral and datetime (yyyy-MM-ddTHH:mm:ssZ) values are supported.
                    },
                    "startTime": "2020-02-20 00:00:00",  # Optional. Job start time when
                      available. Sample format: yyyy-MM-ddTHH:mm:ssZ.
                    "status": "str"  # Optional. Status of the job."nPossible values: 'Waiting',
                      'Running', 'Succeeded', 'Failed', 'Cancelled'.
                }
        """

    @distributed_trace
    def begin_create_data_ingestion_job(self, job_id: str, job: Union[JSON, IO], **kwargs: Any) -> LROPoller[JSON]:
        """Create a weather data ingestion job.

        :param job_id: Job id supplied by user. Required.
        :type job_id: str
        :param job: Job parameters supplied by user. Is either a model type or a IO type. Required.
        :type job: JSON or IO
        :keyword content_type: Body Parameter content-type. Known values are: 'application/json'.
         Default value is None.
        :paramtype content_type: str
        :keyword str continuation_token: A continuation token to restart a poller from a saved state.
        :keyword polling: By default, your polling method will be LROBasePolling. Pass in False for
         this operation to not poll, or pass in your own initialized polling object for a personal
         polling strategy.
        :paramtype polling: bool or ~azure.core.polling.PollingMethod
        :keyword int polling_interval: Default waiting time between two polls for LRO operations if no
         Retry-After header is present.
        :return: An instance of LROPoller that returns JSON object
        :rtype: ~azure.core.polling.LROPoller[JSON]
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 202
                response == {
                    "boundaryId": "str",  # The id of the boundary object for which weather data
                      is being fetched. Required.
                    "extensionApiInput": {
                        "str": {}  # Extension api input dictionary which would be used to
                          feed request query/body/parameter information. Required.
                    },
                    "extensionApiName": "str",  # Extension api name to which request is to be
                      made. Required.
                    "extensionId": "str",  # Id of the extension to be used for the
                      providerInput. eg. DTN.ClearAg. Required.
                    "partyId": "str",  # The id of the party for which weather data is being
                      fetched. Required.
                    "createdBy": "str",  # Optional. Created by user/tenant id.
                    "createdDateTime": "2020-02-20 00:00:00",  # Optional. Job created at
                      dateTime. Sample format: yyyy-MM-ddTHH:mm:ssZ.
                    "description": "str",  # Optional. Textual description of the resource.
                    "durationInSeconds": 0.0,  # Optional. Duration of the job in seconds.
                    "endTime": "2020-02-20 00:00:00",  # Optional. Job end time when available.
                      Sample format: yyyy-MM-ddTHH:mm:ssZ.
                    "errorCode": "str",  # Optional. Error Code when job failed.
                    "extensionDataProviderApiKey": "str",  # Optional. Api key of the weather
                      data provider.
                    "extensionDataProviderAppId": "str",  # Optional. App id of the weather data
                      provider.
                    "id": "str",  # Optional. Unique job id.
                    "lastActionDateTime": "2020-02-20 00:00:00",  # Optional. Job was last acted
                      upon at dateTime. Sample format: yyyy-MM-ddTHH:mm:ssZ.
                    "message": "str",  # Optional. Status message to capture more details of the
                      job.
                    "modifiedBy": "str",  # Optional. Modified by user/tenant id.
                    "name": "str",  # Optional. Name to identify resource.
                    "properties": {
                        "str": {}  # Optional. A collection of key value pairs that belongs
                          to the resource."nEach pair must not have a key greater than 50
                          characters"nand must not have a value greater than 150 characters."nNote: A
                          maximum of 25 key value pairs can be provided for a resource and only
                          string,"nnumeral and datetime (yyyy-MM-ddTHH:mm:ssZ) values are supported.
                    },
                    "startTime": "2020-02-20 00:00:00",  # Optional. Job start time when
                      available. Sample format: yyyy-MM-ddTHH:mm:ssZ.
                    "status": "str"  # Optional. Status of the job."nPossible values: 'Waiting',
                      'Running', 'Succeeded', 'Failed', 'Cancelled'.
                }
        """
        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type = kwargs.pop("content_type", _headers.pop("Content-Type", None))  # type: Optional[str]
        cls = kwargs.pop("cls", None)  # type: ClsType[JSON]
        polling = kwargs.pop("polling", True)  # type: Union[bool, PollingMethod]
        lro_delay = kwargs.pop("polling_interval", self._config.polling_interval)
        cont_token = kwargs.pop("continuation_token", None)  # type: Optional[str]
        if cont_token is None:
            raw_result = self._create_data_ingestion_job_initial(  # type: ignore
                job_id=job_id,
                job=job,
                content_type=content_type,
                cls=lambda x, y, z: x,
                headers=_headers,
                params=_params,
                **kwargs
            )
        kwargs.pop("error_map", None)

        def get_long_running_output(pipeline_response):
            response = pipeline_response.http_response
            if response.content:
                deserialized = response.json()
            else:
                deserialized = None
            if cls:
                return cls(pipeline_response, deserialized, {})
            return deserialized

        if polling is True:
            polling_method = cast(
                PollingMethod, LROBasePolling(lro_delay, lro_options={"final-state-via": "location"}, **kwargs)
            )  # type: PollingMethod
        elif polling is False:
            polling_method = cast(PollingMethod, NoPolling())
        else:
            polling_method = polling
        if cont_token:
            return LROPoller.from_continuation_token(
                polling_method=polling_method,
                continuation_token=cont_token,
                client=self._client,
                deserialization_callback=get_long_running_output,
            )
        return LROPoller(self._client, raw_result, get_long_running_output, polling_method)


class WeatherDataOperations:
    """
    .. warning::
        **DO NOT** instantiate this class directly.

        Instead, you should access the following operations through
        :class:`~azure.agrifood.farming.FarmBeatsClient`'s
        :attr:`weather_data` attribute.
    """

    def __init__(self, *args, **kwargs):
        input_args = list(args)
        self._client = input_args.pop(0) if input_args else kwargs.pop("client")
        self._config = input_args.pop(0) if input_args else kwargs.pop("config")
        self._serialize = input_args.pop(0) if input_args else kwargs.pop("serializer")
        self._deserialize = input_args.pop(0) if input_args else kwargs.pop("deserializer")

    @overload
    def get(
        self, weather_data_provider_request: JSON, *, content_type: str = "application/json", **kwargs: Any
    ) -> JSON:
        """Returns a list of WeatherData.

        :param weather_data_provider_request: Weather data provider request. Required.
        :type weather_data_provider_request: JSON
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: JSON object
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                weather_data_provider_request = {
                    "extensionApiName": "str",  # Extension api name to which request is to be
                      made. Required.
                    "extensionId": "str",  # Id of the extension to be used for the
                      providerInput. eg. DTN.ClearAg. Required.
                    "providerApiKey": "str",  # Api key of the weather data provider. Required.
                    "units": "str",  # Units for which request to data provider is to be sent.
                      Supported values are 'e' for English units, 'm' for Metric units, 'h' for Hybrid
                      units (UK) and 's' for Metric SI units. Required.
                    "additionalParams": {
                        "details": True,  # Optional. Default value is True. Details (Only
                          applicable for AzureWeatherMaps).
                        "iconResolution": "str"  # Optional. Icon Resolution (Only applicable
                          for AzureWeatherMaps).
                    },
                    "duration": 0,  # Optional. Specifies for how many days the daily forecast
                      responses are returned. Available values are 1, 5, 10, 25 and 45. (Only
                      applicable for Azure Weather Maps extension.).
                    "endTimeHours": 0,  # Optional. End of time range. Supported ranges are from
                      0 to 240. (Only applicable for DTN.ClearAg extension.).
                    "language": "str",  # Optional. Language (IETF BCP 47 language tag) in which
                      search results should be returned by the data provider. Examples: 'en-US', 'es',
                      'es-MX', 'fr-FR'.
                    "locations": [
                        {
                            "type": "str",  # Location Type eg.
                              LatLong/IataCode/IcaoCode/Placeid/PostalKey. Required. Known values are:
                              "LatLong", "IataCode", "IcaoCode", "PlaceId", and "PostalKey".
                            "value": "str"  # Location Value eg. "10,-25" for
                              LocationType Type "LatLong". Required.
                        }
                    ],
                    "providerAppId": "str",  # Optional. App id of the weather data provider.
                    "startTimeHours": 0  # Optional. Start of time range. Hour 0 represents the
                      current hour. (Only applicable for DTN.ClearAg extension.).
                }

                # response body for status code(s): 200
                response == {
                    "weatherMetadata": {
                        "extensionApiName": "str",  # Extension api name to which request is
                          to be made. Required.
                        "extensionId": "str",  # Id of the extension to be used for the
                          providerInput. eg. DTN.ClearAg. Required.
                        "extensionVersion": "str",  # Version of the weather data extension.
                          Required.
                        "units": "str",  # Units for which request to data provider is to be
                          sent. Supported values are 'e' for English units, 'm' for Metric units, 'h'
                          for Hybrid units (UK) and 's' for Metric SI units. Required.
                        "weatherDataType": "str",  # Type of weather data
                          (forecast/historical). Required.
                        "additionalParams": {
                            "details": True,  # Optional. Default value is True. Details
                              (Only applicable for AzureWeatherMaps).
                            "iconResolution": "str"  # Optional. Icon Resolution (Only
                              applicable for AzureWeatherMaps).
                        },
                        "duration": 0,  # Optional. Specifies for how many days the daily
                          forecast responses are returned. Available values are 1, 5, 10, 25 and 45.
                          (Only applicable for Azure Weather Maps extension.).
                        "endTimeHours": 0,  # Optional. End of time range. (Only applicable
                          for DTN.ClearAg extension.).
                        "language": "str",  # Optional. Language (IETF BCP 47 language tag)
                          in which search results should be returned by the data provider. Examples:
                          'en-US', 'es', 'es-MX', 'fr-FR'.
                        "startTimeHours": 0  # Optional. Start of time range. Hour 0
                          represents the current hour. (Only applicable for DTN.ClearAg extension.).
                    },
                    "errors": {
                        "locations": [
                            {
                                "code": 0,  # Optional. Status code returned by data
                                  provider.
                                "description": "str",  # Optional. Description of the
                                  error.
                                "location": {
                                    "type": "str",  # Location Type eg.
                                      LatLong/IataCode/IcaoCode/Placeid/PostalKey. Required. Known
                                      values are: "LatLong", "IataCode", "IcaoCode", "PlaceId", and
                                      "PostalKey".
                                    "value": "str"  # Location Value eg. "10,-25"
                                      for LocationType Type "LatLong". Required.
                                },
                                "retryable": bool  # Optional. Flag suggesting if
                                  retry attempt with same request body should be made to fetch required
                                  data.
                            }
                        ]
                    },
                    "locations": [
                        {
                            "data": {
                                "additionalAttributes": {
                                    "str": {}  # Optional. A collection of key
                                      value pairs that belongs to the resource. Each pair must not have
                                      a key greater than 50 characters and must not have a value
                                      greater than 250 characters. Note: A maximum of 100 key value
                                      pairs can be provided for a resource and only string and numeral
                                      values are supported.
                                },
                                "cloudCover": {
                                    "unit": "str",  # Optional. Data unit.
                                    "values": [
                                        0.0  # Optional. Data values.
                                    ]
                                },
                                "dayOfWeek": [
                                    "str"  # Optional. Day of week.
                                ],
                                "dayOrNight": [
                                    "str"  # Optional. This data field indicates
                                      whether it is daytime or nighttime based on the Local Apparent
                                      Time of the location.
                                ],
                                "expirationTime": [
                                    "str"  # Optional. Expiration time in Utc
                                      format.
                                ],
                                "hasPrecipitation": [
                                    bool  # Optional. Indicates whether there is
                                      precipitation or not.
                                ],
                                "iconCode": [
                                    "str"  # Optional. This number is the key to
                                      the weather icon lookup. The data field shows the icon number
                                      that is matched to represent the observed weather conditions.
                                ],
                                "iconCodeExtend": [
                                    "str"  # Optional. Code representing full set
                                      sensible weather.
                                ],
                                "pressureMeanSeaLevel": {
                                    "unit": "str",  # Optional. Data unit.
                                    "values": [
                                        0.0  # Optional. Data values.
                                    ]
                                },
                                "relativeHumidity": {
                                    "unit": "str",  # Optional. Data unit.
                                    "values": [
                                        0.0  # Optional. Data values.
                                    ]
                                },
                                "temperature": {
                                    "unit": "str",  # Optional. Data unit.
                                    "values": [
                                        0.0  # Optional. Data values.
                                    ]
                                },
                                "temperatureDewPoint": {
                                    "unit": "str",  # Optional. Data unit.
                                    "values": [
                                        0.0  # Optional. Data values.
                                    ]
                                },
                                "temperatureFeelsLike": {
                                    "unit": "str",  # Optional. Data unit.
                                    "values": [
                                        0.0  # Optional. Data values.
                                    ]
                                },
                                "temperatureHeatIndex": {
                                    "unit": "str",  # Optional. Data unit.
                                    "values": [
                                        0.0  # Optional. Data values.
                                    ]
                                },
                                "temperatureWindChill": {
                                    "unit": "str",  # Optional. Data unit.
                                    "values": [
                                        0.0  # Optional. Data values.
                                    ]
                                },
                                "uvDescription": [
                                    "str"  # Optional. The UV Index Description
                                      which complements the UV Index value by providing an associated
                                      level of risk of skin damage due to exposure (-2 = Not Available,
                                      -1 = No Report, 0 to 2 = Low, 3 to 5 = Moderate, 6 to 7 = High, 8
                                      to 10 = Very High, 11 to 16 = Extreme).
                                ],
                                "uvIndex": [
                                    "str"  # Optional. Hourly maximum UV index.
                                ],
                                "validTime": [
                                    "str"  # Optional. Time forecast is valid in
                                      Utc format.
                                ],
                                "validTimeLocal": [
                                    "str"  # Optional. Time forecast is valid in
                                      local apparent time.
                                ],
                                "visibility": {
                                    "unit": "str",  # Optional. Data unit.
                                    "values": [
                                        0.0  # Optional. Data values.
                                    ]
                                },
                                "wetBulbTemperature": {
                                    "unit": "str",  # Optional. Data unit.
                                    "values": [
                                        0.0  # Optional. Data values.
                                    ]
                                },
                                "windDirection": {
                                    "unit": "str",  # Optional. Data unit.
                                    "values": [
                                        0.0  # Optional. Data values.
                                    ]
                                },
                                "windGust": {
                                    "unit": "str",  # Optional. Data unit.
                                    "values": [
                                        0.0  # Optional. Data values.
                                    ]
                                },
                                "windSpeed": {
                                    "unit": "str",  # Optional. Data unit.
                                    "values": [
                                        0.0  # Optional. Data values.
                                    ]
                                },
                                "wxPhraseLong": [
                                    "str"  # Optional. Hourly sensible weather
                                      phrase containing longer description.
                                ],
                                "wxPhraseShort": [
                                    "str"  # Optional. Hourly sensible weather
                                      phrase containing short description.
                                ]
                            },
                            "lastRefreshedDateTime": "2020-02-20 00:00:00",  # Optional.
                              Date-time when resource was last requested, sample format:
                              yyyy-MM-ddTHH:mm:ssZ.
                            "location": {
                                "type": "str",  # Location Type eg.
                                  LatLong/IataCode/IcaoCode/Placeid/PostalKey. Required. Known values
                                  are: "LatLong", "IataCode", "IcaoCode", "PlaceId", and "PostalKey".
                                "value": "str"  # Location Value eg. "10,-25" for
                                  LocationType Type "LatLong". Required.
                            },
                            "requestCompletionTime": "str"  # Optional. Request
                              Completion Time in Utc of the location.
                        }
                    ],
                    "status": "str"  # Optional. Indicates a Succeeded, Failed, or
                      PartiallySucceeded response. Known values are: "Succeeded", "Failed", and
                      "PartiallySucceeded".
                }
        """

    @overload
    def get(self, weather_data_provider_request: IO, *, content_type: str = "application/json", **kwargs: Any) -> JSON:
        """Returns a list of WeatherData.

        :param weather_data_provider_request: Weather data provider request. Required.
        :type weather_data_provider_request: IO
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: JSON object
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "weatherMetadata": {
                        "extensionApiName": "str",  # Extension api name to which request is
                          to be made. Required.
                        "extensionId": "str",  # Id of the extension to be used for the
                          providerInput. eg. DTN.ClearAg. Required.
                        "extensionVersion": "str",  # Version of the weather data extension.
                          Required.
                        "units": "str",  # Units for which request to data provider is to be
                          sent. Supported values are 'e' for English units, 'm' for Metric units, 'h'
                          for Hybrid units (UK) and 's' for Metric SI units. Required.
                        "weatherDataType": "str",  # Type of weather data
                          (forecast/historical). Required.
                        "additionalParams": {
                            "details": True,  # Optional. Default value is True. Details
                              (Only applicable for AzureWeatherMaps).
                            "iconResolution": "str"  # Optional. Icon Resolution (Only
                              applicable for AzureWeatherMaps).
                        },
                        "duration": 0,  # Optional. Specifies for how many days the daily
                          forecast responses are returned. Available values are 1, 5, 10, 25 and 45.
                          (Only applicable for Azure Weather Maps extension.).
                        "endTimeHours": 0,  # Optional. End of time range. (Only applicable
                          for DTN.ClearAg extension.).
                        "language": "str",  # Optional. Language (IETF BCP 47 language tag)
                          in which search results should be returned by the data provider. Examples:
                          'en-US', 'es', 'es-MX', 'fr-FR'.
                        "startTimeHours": 0  # Optional. Start of time range. Hour 0
                          represents the current hour. (Only applicable for DTN.ClearAg extension.).
                    },
                    "errors": {
                        "locations": [
                            {
                                "code": 0,  # Optional. Status code returned by data
                                  provider.
                                "description": "str",  # Optional. Description of the
                                  error.
                                "location": {
                                    "type": "str",  # Location Type eg.
                                      LatLong/IataCode/IcaoCode/Placeid/PostalKey. Required. Known
                                      values are: "LatLong", "IataCode", "IcaoCode", "PlaceId", and
                                      "PostalKey".
                                    "value": "str"  # Location Value eg. "10,-25"
                                      for LocationType Type "LatLong". Required.
                                },
                                "retryable": bool  # Optional. Flag suggesting if
                                  retry attempt with same request body should be made to fetch required
                                  data.
                            }
                        ]
                    },
                    "locations": [
                        {
                            "data": {
                                "additionalAttributes": {
                                    "str": {}  # Optional. A collection of key
                                      value pairs that belongs to the resource. Each pair must not have
                                      a key greater than 50 characters and must not have a value
                                      greater than 250 characters. Note: A maximum of 100 key value
                                      pairs can be provided for a resource and only string and numeral
                                      values are supported.
                                },
                                "cloudCover": {
                                    "unit": "str",  # Optional. Data unit.
                                    "values": [
                                        0.0  # Optional. Data values.
                                    ]
                                },
                                "dayOfWeek": [
                                    "str"  # Optional. Day of week.
                                ],
                                "dayOrNight": [
                                    "str"  # Optional. This data field indicates
                                      whether it is daytime or nighttime based on the Local Apparent
                                      Time of the location.
                                ],
                                "expirationTime": [
                                    "str"  # Optional. Expiration time in Utc
                                      format.
                                ],
                                "hasPrecipitation": [
                                    bool  # Optional. Indicates whether there is
                                      precipitation or not.
                                ],
                                "iconCode": [
                                    "str"  # Optional. This number is the key to
                                      the weather icon lookup. The data field shows the icon number
                                      that is matched to represent the observed weather conditions.
                                ],
                                "iconCodeExtend": [
                                    "str"  # Optional. Code representing full set
                                      sensible weather.
                                ],
                                "pressureMeanSeaLevel": {
                                    "unit": "str",  # Optional. Data unit.
                                    "values": [
                                        0.0  # Optional. Data values.
                                    ]
                                },
                                "relativeHumidity": {
                                    "unit": "str",  # Optional. Data unit.
                                    "values": [
                                        0.0  # Optional. Data values.
                                    ]
                                },
                                "temperature": {
                                    "unit": "str",  # Optional. Data unit.
                                    "values": [
                                        0.0  # Optional. Data values.
                                    ]
                                },
                                "temperatureDewPoint": {
                                    "unit": "str",  # Optional. Data unit.
                                    "values": [
                                        0.0  # Optional. Data values.
                                    ]
                                },
                                "temperatureFeelsLike": {
                                    "unit": "str",  # Optional. Data unit.
                                    "values": [
                                        0.0  # Optional. Data values.
                                    ]
                                },
                                "temperatureHeatIndex": {
                                    "unit": "str",  # Optional. Data unit.
                                    "values": [
                                        0.0  # Optional. Data values.
                                    ]
                                },
                                "temperatureWindChill": {
                                    "unit": "str",  # Optional. Data unit.
                                    "values": [
                                        0.0  # Optional. Data values.
                                    ]
                                },
                                "uvDescription": [
                                    "str"  # Optional. The UV Index Description
                                      which complements the UV Index value by providing an associated
                                      level of risk of skin damage due to exposure (-2 = Not Available,
                                      -1 = No Report, 0 to 2 = Low, 3 to 5 = Moderate, 6 to 7 = High, 8
                                      to 10 = Very High, 11 to 16 = Extreme).
                                ],
                                "uvIndex": [
                                    "str"  # Optional. Hourly maximum UV index.
                                ],
                                "validTime": [
                                    "str"  # Optional. Time forecast is valid in
                                      Utc format.
                                ],
                                "validTimeLocal": [
                                    "str"  # Optional. Time forecast is valid in
                                      local apparent time.
                                ],
                                "visibility": {
                                    "unit": "str",  # Optional. Data unit.
                                    "values": [
                                        0.0  # Optional. Data values.
                                    ]
                                },
                                "wetBulbTemperature": {
                                    "unit": "str",  # Optional. Data unit.
                                    "values": [
                                        0.0  # Optional. Data values.
                                    ]
                                },
                                "windDirection": {
                                    "unit": "str",  # Optional. Data unit.
                                    "values": [
                                        0.0  # Optional. Data values.
                                    ]
                                },
                                "windGust": {
                                    "unit": "str",  # Optional. Data unit.
                                    "values": [
                                        0.0  # Optional. Data values.
                                    ]
                                },
                                "windSpeed": {
                                    "unit": "str",  # Optional. Data unit.
                                    "values": [
                                        0.0  # Optional. Data values.
                                    ]
                                },
                                "wxPhraseLong": [
                                    "str"  # Optional. Hourly sensible weather
                                      phrase containing longer description.
                                ],
                                "wxPhraseShort": [
                                    "str"  # Optional. Hourly sensible weather
                                      phrase containing short description.
                                ]
                            },
                            "lastRefreshedDateTime": "2020-02-20 00:00:00",  # Optional.
                              Date-time when resource was last requested, sample format:
                              yyyy-MM-ddTHH:mm:ssZ.
                            "location": {
                                "type": "str",  # Location Type eg.
                                  LatLong/IataCode/IcaoCode/Placeid/PostalKey. Required. Known values
                                  are: "LatLong", "IataCode", "IcaoCode", "PlaceId", and "PostalKey".
                                "value": "str"  # Location Value eg. "10,-25" for
                                  LocationType Type "LatLong". Required.
                            },
                            "requestCompletionTime": "str"  # Optional. Request
                              Completion Time in Utc of the location.
                        }
                    ],
                    "status": "str"  # Optional. Indicates a Succeeded, Failed, or
                      PartiallySucceeded response. Known values are: "Succeeded", "Failed", and
                      "PartiallySucceeded".
                }
        """

    @distributed_trace
    def get(self, weather_data_provider_request: Union[JSON, IO], **kwargs: Any) -> JSON:
        """Returns a list of WeatherData.

        :param weather_data_provider_request: Weather data provider request. Is either a model type or
         a IO type. Required.
        :type weather_data_provider_request: JSON or IO
        :keyword content_type: Body Parameter content-type. Known values are: 'application/json'.
         Default value is None.
        :paramtype content_type: str
        :return: JSON object
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "weatherMetadata": {
                        "extensionApiName": "str",  # Extension api name to which request is
                          to be made. Required.
                        "extensionId": "str",  # Id of the extension to be used for the
                          providerInput. eg. DTN.ClearAg. Required.
                        "extensionVersion": "str",  # Version of the weather data extension.
                          Required.
                        "units": "str",  # Units for which request to data provider is to be
                          sent. Supported values are 'e' for English units, 'm' for Metric units, 'h'
                          for Hybrid units (UK) and 's' for Metric SI units. Required.
                        "weatherDataType": "str",  # Type of weather data
                          (forecast/historical). Required.
                        "additionalParams": {
                            "details": True,  # Optional. Default value is True. Details
                              (Only applicable for AzureWeatherMaps).
                            "iconResolution": "str"  # Optional. Icon Resolution (Only
                              applicable for AzureWeatherMaps).
                        },
                        "duration": 0,  # Optional. Specifies for how many days the daily
                          forecast responses are returned. Available values are 1, 5, 10, 25 and 45.
                          (Only applicable for Azure Weather Maps extension.).
                        "endTimeHours": 0,  # Optional. End of time range. (Only applicable
                          for DTN.ClearAg extension.).
                        "language": "str",  # Optional. Language (IETF BCP 47 language tag)
                          in which search results should be returned by the data provider. Examples:
                          'en-US', 'es', 'es-MX', 'fr-FR'.
                        "startTimeHours": 0  # Optional. Start of time range. Hour 0
                          represents the current hour. (Only applicable for DTN.ClearAg extension.).
                    },
                    "errors": {
                        "locations": [
                            {
                                "code": 0,  # Optional. Status code returned by data
                                  provider.
                                "description": "str",  # Optional. Description of the
                                  error.
                                "location": {
                                    "type": "str",  # Location Type eg.
                                      LatLong/IataCode/IcaoCode/Placeid/PostalKey. Required. Known
                                      values are: "LatLong", "IataCode", "IcaoCode", "PlaceId", and
                                      "PostalKey".
                                    "value": "str"  # Location Value eg. "10,-25"
                                      for LocationType Type "LatLong". Required.
                                },
                                "retryable": bool  # Optional. Flag suggesting if
                                  retry attempt with same request body should be made to fetch required
                                  data.
                            }
                        ]
                    },
                    "locations": [
                        {
                            "data": {
                                "additionalAttributes": {
                                    "str": {}  # Optional. A collection of key
                                      value pairs that belongs to the resource. Each pair must not have
                                      a key greater than 50 characters and must not have a value
                                      greater than 250 characters. Note: A maximum of 100 key value
                                      pairs can be provided for a resource and only string and numeral
                                      values are supported.
                                },
                                "cloudCover": {
                                    "unit": "str",  # Optional. Data unit.
                                    "values": [
                                        0.0  # Optional. Data values.
                                    ]
                                },
                                "dayOfWeek": [
                                    "str"  # Optional. Day of week.
                                ],
                                "dayOrNight": [
                                    "str"  # Optional. This data field indicates
                                      whether it is daytime or nighttime based on the Local Apparent
                                      Time of the location.
                                ],
                                "expirationTime": [
                                    "str"  # Optional. Expiration time in Utc
                                      format.
                                ],
                                "hasPrecipitation": [
                                    bool  # Optional. Indicates whether there is
                                      precipitation or not.
                                ],
                                "iconCode": [
                                    "str"  # Optional. This number is the key to
                                      the weather icon lookup. The data field shows the icon number
                                      that is matched to represent the observed weather conditions.
                                ],
                                "iconCodeExtend": [
                                    "str"  # Optional. Code representing full set
                                      sensible weather.
                                ],
                                "pressureMeanSeaLevel": {
                                    "unit": "str",  # Optional. Data unit.
                                    "values": [
                                        0.0  # Optional. Data values.
                                    ]
                                },
                                "relativeHumidity": {
                                    "unit": "str",  # Optional. Data unit.
                                    "values": [
                                        0.0  # Optional. Data values.
                                    ]
                                },
                                "temperature": {
                                    "unit": "str",  # Optional. Data unit.
                                    "values": [
                                        0.0  # Optional. Data values.
                                    ]
                                },
                                "temperatureDewPoint": {
                                    "unit": "str",  # Optional. Data unit.
                                    "values": [
                                        0.0  # Optional. Data values.
                                    ]
                                },
                                "temperatureFeelsLike": {
                                    "unit": "str",  # Optional. Data unit.
                                    "values": [
                                        0.0  # Optional. Data values.
                                    ]
                                },
                                "temperatureHeatIndex": {
                                    "unit": "str",  # Optional. Data unit.
                                    "values": [
                                        0.0  # Optional. Data values.
                                    ]
                                },
                                "temperatureWindChill": {
                                    "unit": "str",  # Optional. Data unit.
                                    "values": [
                                        0.0  # Optional. Data values.
                                    ]
                                },
                                "uvDescription": [
                                    "str"  # Optional. The UV Index Description
                                      which complements the UV Index value by providing an associated
                                      level of risk of skin damage due to exposure (-2 = Not Available,
                                      -1 = No Report, 0 to 2 = Low, 3 to 5 = Moderate, 6 to 7 = High, 8
                                      to 10 = Very High, 11 to 16 = Extreme).
                                ],
                                "uvIndex": [
                                    "str"  # Optional. Hourly maximum UV index.
                                ],
                                "validTime": [
                                    "str"  # Optional. Time forecast is valid in
                                      Utc format.
                                ],
                                "validTimeLocal": [
                                    "str"  # Optional. Time forecast is valid in
                                      local apparent time.
                                ],
                                "visibility": {
                                    "unit": "str",  # Optional. Data unit.
                                    "values": [
                                        0.0  # Optional. Data values.
                                    ]
                                },
                                "wetBulbTemperature": {
                                    "unit": "str",  # Optional. Data unit.
                                    "values": [
                                        0.0  # Optional. Data values.
                                    ]
                                },
                                "windDirection": {
                                    "unit": "str",  # Optional. Data unit.
                                    "values": [
                                        0.0  # Optional. Data values.
                                    ]
                                },
                                "windGust": {
                                    "unit": "str",  # Optional. Data unit.
                                    "values": [
                                        0.0  # Optional. Data values.
                                    ]
                                },
                                "windSpeed": {
                                    "unit": "str",  # Optional. Data unit.
                                    "values": [
                                        0.0  # Optional. Data values.
                                    ]
                                },
                                "wxPhraseLong": [
                                    "str"  # Optional. Hourly sensible weather
                                      phrase containing longer description.
                                ],
                                "wxPhraseShort": [
                                    "str"  # Optional. Hourly sensible weather
                                      phrase containing short description.
                                ]
                            },
                            "lastRefreshedDateTime": "2020-02-20 00:00:00",  # Optional.
                              Date-time when resource was last requested, sample format:
                              yyyy-MM-ddTHH:mm:ssZ.
                            "location": {
                                "type": "str",  # Location Type eg.
                                  LatLong/IataCode/IcaoCode/Placeid/PostalKey. Required. Known values
                                  are: "LatLong", "IataCode", "IcaoCode", "PlaceId", and "PostalKey".
                                "value": "str"  # Location Value eg. "10,-25" for
                                  LocationType Type "LatLong". Required.
                            },
                            "requestCompletionTime": "str"  # Optional. Request
                              Completion Time in Utc of the location.
                        }
                    ],
                    "status": "str"  # Optional. Indicates a Succeeded, Failed, or
                      PartiallySucceeded response. Known values are: "Succeeded", "Failed", and
                      "PartiallySucceeded".
                }
        """
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type = kwargs.pop("content_type", _headers.pop("Content-Type", None))  # type: Optional[str]
        cls = kwargs.pop("cls", None)  # type: ClsType[JSON]

        content_type = content_type or "application/json"
        _json = None
        _content = None
        if isinstance(weather_data_provider_request, (IO, bytes)):
            _content = weather_data_provider_request
        else:
            _json = weather_data_provider_request

        request = build_weather_data_get_request(
            content_type=content_type,
            api_version=self._config.api_version,
            json=_json,
            content=_content,
            headers=_headers,
            params=_params,
        )
        request.url = self._client.format_url(request.url)  # type: ignore

        pipeline_response = self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
            request, stream=False, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        response_headers = {}
        response_headers["x-ms-cache-hit"] = self._deserialize("bool", response.headers.get("x-ms-cache-hit"))
        response_headers["x-ms-response-latency-in-milliseconds"] = self._deserialize(
            "int", response.headers.get("x-ms-response-latency-in-milliseconds")
        )

        if response.content:
            deserialized = response.json()
        else:
            deserialized = None

        if cls:
            return cls(pipeline_response, cast(JSON, deserialized), response_headers)

        return cast(JSON, deserialized)


class ZonesOperations:
    """
    .. warning::
        **DO NOT** instantiate this class directly.

        Instead, you should access the following operations through
        :class:`~azure.agrifood.farming.FarmBeatsClient`'s
        :attr:`zones` attribute.
    """

    def __init__(self, *args, **kwargs):
        input_args = list(args)
        self._client = input_args.pop(0) if input_args else kwargs.pop("client")
        self._config = input_args.pop(0) if input_args else kwargs.pop("config")
        self._serialize = input_args.pop(0) if input_args else kwargs.pop("serializer")
        self._deserialize = input_args.pop(0) if input_args else kwargs.pop("deserializer")

    @distributed_trace
    def list_by_party_id(
        self,
        party_id: str,
        *,
        types: Optional[List[str]] = None,
        management_zone_ids: Optional[List[str]] = None,
        sources: Optional[List[str]] = None,
        ids: Optional[List[str]] = None,
        names: Optional[List[str]] = None,
        property_filters: Optional[List[str]] = None,
        statuses: Optional[List[str]] = None,
        min_created_date_time: Optional[datetime.datetime] = None,
        max_created_date_time: Optional[datetime.datetime] = None,
        min_last_modified_date_time: Optional[datetime.datetime] = None,
        max_last_modified_date_time: Optional[datetime.datetime] = None,
        skip_token: Optional[str] = None,
        **kwargs: Any
    ) -> Iterable[JSON]:
        """Returns a paginated list of zone resources under a particular party.

        :param party_id: Id of the associated party. Required.
        :type party_id: str
        :keyword types: Types of the Zones. Default value is None.
        :paramtype types: list[str]
        :keyword management_zone_ids: ManagementZoneIds of the Zones. Default value is None.
        :paramtype management_zone_ids: list[str]
        :keyword sources: Sources of the Zones. Default value is None.
        :paramtype sources: list[str]
        :keyword ids: Ids of the resource. Default value is None.
        :paramtype ids: list[str]
        :keyword names: Names of the resource. Default value is None.
        :paramtype names: list[str]
        :keyword property_filters: Filters on key-value pairs within the Properties object.
         eg. "{testKey} eq {testValue}". Default value is None.
        :paramtype property_filters: list[str]
        :keyword statuses: Statuses of the resource. Default value is None.
        :paramtype statuses: list[str]
        :keyword min_created_date_time: Minimum creation date of resource (inclusive). Default value is
         None.
        :paramtype min_created_date_time: ~datetime.datetime
        :keyword max_created_date_time: Maximum creation date of resource (inclusive). Default value is
         None.
        :paramtype max_created_date_time: ~datetime.datetime
        :keyword min_last_modified_date_time: Minimum last modified date of resource (inclusive).
         Default value is None.
        :paramtype min_last_modified_date_time: ~datetime.datetime
        :keyword max_last_modified_date_time: Maximum last modified date of resource (inclusive).
         Default value is None.
        :paramtype max_last_modified_date_time: ~datetime.datetime
        :keyword skip_token: Skip token for getting next set of results. Default value is None.
        :paramtype skip_token: str
        :return: An iterator like instance of JSON object
        :rtype: ~azure.core.paging.ItemPaged[JSON]
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "createdBy": "str",  # Optional. Created by user/tenant id.
                    "createdDateTime": "2020-02-20 00:00:00",  # Optional. Date-time when
                      resource was created, sample format: yyyy-MM-ddTHH:mm:ssZ.
                    "description": "str",  # Optional. Textual description of the resource.
                    "eTag": "str",  # Optional. The ETag value to implement optimistic
                      concurrency.
                    "id": "str",  # Optional. Unique resource ID.
                    "managementZoneId": "str",  # Optional. Management Zone Id associated with
                      the Zone.
                    "modifiedBy": "str",  # Optional. Modified by user/tenant id.
                    "modifiedDateTime": "2020-02-20 00:00:00",  # Optional. Date-time when
                      resource was last modified, sample format: yyyy-MM-ddTHH:mm:ssZ.
                    "name": "str",  # Optional. Name to identify resource.
                    "partyId": "str",  # Optional. Party Id associated with the Zone.
                    "properties": {
                        "str": {}  # Optional. A collection of key value pairs that belongs
                          to the resource."nEach pair must not have a key greater than 50
                          characters"nand must not have a value greater than 150 characters."nNote: A
                          maximum of 25 key value pairs can be provided for a resource and only
                          string,"nnumeral and datetime (yyyy-MM-ddTHH:mm:ssZ) values are supported.
                    },
                    "source": "str",  # Optional. Source of the resource.
                    "status": "str",  # Optional. Status of the resource.
                    "type": "str"  # Optional. Type of the Zone.
                }
        """
        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls = kwargs.pop("cls", None)  # type: ClsType[JSON]

        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        def prepare_request(next_link=None):
            if not next_link:

                request = build_zones_list_by_party_id_request(
                    party_id=party_id,
                    types=types,
                    management_zone_ids=management_zone_ids,
                    sources=sources,
                    ids=ids,
                    names=names,
                    property_filters=property_filters,
                    statuses=statuses,
                    min_created_date_time=min_created_date_time,
                    max_created_date_time=max_created_date_time,
                    min_last_modified_date_time=min_last_modified_date_time,
                    max_last_modified_date_time=max_last_modified_date_time,
                    skip_token=skip_token,
                    api_version=self._config.api_version,
                    headers=_headers,
                    params=_params,
                )
                request.url = self._client.format_url(request.url)  # type: ignore

            else:
                # make call to next link with the client's api-version
                _parsed_next_link = urlparse(next_link)
                _next_request_params = case_insensitive_dict(parse_qs(_parsed_next_link.query))
                _next_request_params["api-version"] = self._config.api_version
                request = HttpRequest("GET", urljoin(next_link, _parsed_next_link.path), params=_next_request_params)
                request.url = self._client.format_url(request.url)  # type: ignore

            return request

        def extract_data(pipeline_response):
            deserialized = pipeline_response.http_response.json()
            list_of_elem = deserialized["value"]
            if cls:
                list_of_elem = cls(list_of_elem)
            return deserialized.get("nextLink", None), iter(list_of_elem)

        def get_next(next_link=None):
            request = prepare_request(next_link)

            pipeline_response = self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
                request, stream=False, **kwargs
            )
            response = pipeline_response.http_response

            if response.status_code not in [200]:
                map_error(status_code=response.status_code, response=response, error_map=error_map)
                raise HttpResponseError(response=response)

            return pipeline_response

        return ItemPaged(get_next, extract_data)

    @distributed_trace
    def get(self, party_id: str, zone_id: str, **kwargs: Any) -> JSON:
        """Gets a specified zone resource under a particular party.

        :param party_id: Id of the associated party. Required.
        :type party_id: str
        :param zone_id: Id of the zone. Required.
        :type zone_id: str
        :return: JSON object
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "createdBy": "str",  # Optional. Created by user/tenant id.
                    "createdDateTime": "2020-02-20 00:00:00",  # Optional. Date-time when
                      resource was created, sample format: yyyy-MM-ddTHH:mm:ssZ.
                    "description": "str",  # Optional. Textual description of the resource.
                    "eTag": "str",  # Optional. The ETag value to implement optimistic
                      concurrency.
                    "id": "str",  # Optional. Unique resource ID.
                    "managementZoneId": "str",  # Optional. Management Zone Id associated with
                      the Zone.
                    "modifiedBy": "str",  # Optional. Modified by user/tenant id.
                    "modifiedDateTime": "2020-02-20 00:00:00",  # Optional. Date-time when
                      resource was last modified, sample format: yyyy-MM-ddTHH:mm:ssZ.
                    "name": "str",  # Optional. Name to identify resource.
                    "partyId": "str",  # Optional. Party Id associated with the Zone.
                    "properties": {
                        "str": {}  # Optional. A collection of key value pairs that belongs
                          to the resource."nEach pair must not have a key greater than 50
                          characters"nand must not have a value greater than 150 characters."nNote: A
                          maximum of 25 key value pairs can be provided for a resource and only
                          string,"nnumeral and datetime (yyyy-MM-ddTHH:mm:ssZ) values are supported.
                    },
                    "source": "str",  # Optional. Source of the resource.
                    "status": "str",  # Optional. Status of the resource.
                    "type": "str"  # Optional. Type of the Zone.
                }
        """
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls = kwargs.pop("cls", None)  # type: ClsType[JSON]

        request = build_zones_get_request(
            party_id=party_id,
            zone_id=zone_id,
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        request.url = self._client.format_url(request.url)  # type: ignore

        pipeline_response = self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
            request, stream=False, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if response.content:
            deserialized = response.json()
        else:
            deserialized = None

        if cls:
            return cls(pipeline_response, cast(JSON, deserialized), {})

        return cast(JSON, deserialized)

    @overload
    def create_or_update(
        self,
        party_id: str,
        zone_id: str,
        zone: JSON,
        *,
        content_type: str = "application/merge-patch+json",
        **kwargs: Any
    ) -> JSON:
        """Creates or updates a Zone resource.

        :param party_id: Id of the party resource. Required.
        :type party_id: str
        :param zone_id: Id of the zone resource. Required.
        :type zone_id: str
        :param zone: Zone resource payload to create or update. Required.
        :type zone: JSON
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/merge-patch+json".
        :paramtype content_type: str
        :return: JSON object
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                zone = {
                    "createdBy": "str",  # Optional. Created by user/tenant id.
                    "createdDateTime": "2020-02-20 00:00:00",  # Optional. Date-time when
                      resource was created, sample format: yyyy-MM-ddTHH:mm:ssZ.
                    "description": "str",  # Optional. Textual description of the resource.
                    "eTag": "str",  # Optional. The ETag value to implement optimistic
                      concurrency.
                    "id": "str",  # Optional. Unique resource ID.
                    "managementZoneId": "str",  # Optional. Management Zone Id associated with
                      the Zone.
                    "modifiedBy": "str",  # Optional. Modified by user/tenant id.
                    "modifiedDateTime": "2020-02-20 00:00:00",  # Optional. Date-time when
                      resource was last modified, sample format: yyyy-MM-ddTHH:mm:ssZ.
                    "name": "str",  # Optional. Name to identify resource.
                    "partyId": "str",  # Optional. Party Id associated with the Zone.
                    "properties": {
                        "str": {}  # Optional. A collection of key value pairs that belongs
                          to the resource."nEach pair must not have a key greater than 50
                          characters"nand must not have a value greater than 150 characters."nNote: A
                          maximum of 25 key value pairs can be provided for a resource and only
                          string,"nnumeral and datetime (yyyy-MM-ddTHH:mm:ssZ) values are supported.
                    },
                    "source": "str",  # Optional. Source of the resource.
                    "status": "str",  # Optional. Status of the resource.
                    "type": "str"  # Optional. Type of the Zone.
                }

                # response body for status code(s): 200, 201
                response == {
                    "createdBy": "str",  # Optional. Created by user/tenant id.
                    "createdDateTime": "2020-02-20 00:00:00",  # Optional. Date-time when
                      resource was created, sample format: yyyy-MM-ddTHH:mm:ssZ.
                    "description": "str",  # Optional. Textual description of the resource.
                    "eTag": "str",  # Optional. The ETag value to implement optimistic
                      concurrency.
                    "id": "str",  # Optional. Unique resource ID.
                    "managementZoneId": "str",  # Optional. Management Zone Id associated with
                      the Zone.
                    "modifiedBy": "str",  # Optional. Modified by user/tenant id.
                    "modifiedDateTime": "2020-02-20 00:00:00",  # Optional. Date-time when
                      resource was last modified, sample format: yyyy-MM-ddTHH:mm:ssZ.
                    "name": "str",  # Optional. Name to identify resource.
                    "partyId": "str",  # Optional. Party Id associated with the Zone.
                    "properties": {
                        "str": {}  # Optional. A collection of key value pairs that belongs
                          to the resource."nEach pair must not have a key greater than 50
                          characters"nand must not have a value greater than 150 characters."nNote: A
                          maximum of 25 key value pairs can be provided for a resource and only
                          string,"nnumeral and datetime (yyyy-MM-ddTHH:mm:ssZ) values are supported.
                    },
                    "source": "str",  # Optional. Source of the resource.
                    "status": "str",  # Optional. Status of the resource.
                    "type": "str"  # Optional. Type of the Zone.
                }
        """

    @overload
    def create_or_update(
        self,
        party_id: str,
        zone_id: str,
        zone: IO,
        *,
        content_type: str = "application/merge-patch+json",
        **kwargs: Any
    ) -> JSON:
        """Creates or updates a Zone resource.

        :param party_id: Id of the party resource. Required.
        :type party_id: str
        :param zone_id: Id of the zone resource. Required.
        :type zone_id: str
        :param zone: Zone resource payload to create or update. Required.
        :type zone: IO
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Default value is "application/merge-patch+json".
        :paramtype content_type: str
        :return: JSON object
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200, 201
                response == {
                    "createdBy": "str",  # Optional. Created by user/tenant id.
                    "createdDateTime": "2020-02-20 00:00:00",  # Optional. Date-time when
                      resource was created, sample format: yyyy-MM-ddTHH:mm:ssZ.
                    "description": "str",  # Optional. Textual description of the resource.
                    "eTag": "str",  # Optional. The ETag value to implement optimistic
                      concurrency.
                    "id": "str",  # Optional. Unique resource ID.
                    "managementZoneId": "str",  # Optional. Management Zone Id associated with
                      the Zone.
                    "modifiedBy": "str",  # Optional. Modified by user/tenant id.
                    "modifiedDateTime": "2020-02-20 00:00:00",  # Optional. Date-time when
                      resource was last modified, sample format: yyyy-MM-ddTHH:mm:ssZ.
                    "name": "str",  # Optional. Name to identify resource.
                    "partyId": "str",  # Optional. Party Id associated with the Zone.
                    "properties": {
                        "str": {}  # Optional. A collection of key value pairs that belongs
                          to the resource."nEach pair must not have a key greater than 50
                          characters"nand must not have a value greater than 150 characters."nNote: A
                          maximum of 25 key value pairs can be provided for a resource and only
                          string,"nnumeral and datetime (yyyy-MM-ddTHH:mm:ssZ) values are supported.
                    },
                    "source": "str",  # Optional. Source of the resource.
                    "status": "str",  # Optional. Status of the resource.
                    "type": "str"  # Optional. Type of the Zone.
                }
        """

    @distributed_trace
    def create_or_update(self, party_id: str, zone_id: str, zone: Union[JSON, IO], **kwargs: Any) -> JSON:
        """Creates or updates a Zone resource.

        :param party_id: Id of the party resource. Required.
        :type party_id: str
        :param zone_id: Id of the zone resource. Required.
        :type zone_id: str
        :param zone: Zone resource payload to create or update. Is either a model type or a IO type.
         Required.
        :type zone: JSON or IO
        :keyword content_type: Body Parameter content-type. Known values are:
         'application/merge-patch+json'. Default value is None.
        :paramtype content_type: str
        :return: JSON object
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200, 201
                response == {
                    "createdBy": "str",  # Optional. Created by user/tenant id.
                    "createdDateTime": "2020-02-20 00:00:00",  # Optional. Date-time when
                      resource was created, sample format: yyyy-MM-ddTHH:mm:ssZ.
                    "description": "str",  # Optional. Textual description of the resource.
                    "eTag": "str",  # Optional. The ETag value to implement optimistic
                      concurrency.
                    "id": "str",  # Optional. Unique resource ID.
                    "managementZoneId": "str",  # Optional. Management Zone Id associated with
                      the Zone.
                    "modifiedBy": "str",  # Optional. Modified by user/tenant id.
                    "modifiedDateTime": "2020-02-20 00:00:00",  # Optional. Date-time when
                      resource was last modified, sample format: yyyy-MM-ddTHH:mm:ssZ.
                    "name": "str",  # Optional. Name to identify resource.
                    "partyId": "str",  # Optional. Party Id associated with the Zone.
                    "properties": {
                        "str": {}  # Optional. A collection of key value pairs that belongs
                          to the resource."nEach pair must not have a key greater than 50
                          characters"nand must not have a value greater than 150 characters."nNote: A
                          maximum of 25 key value pairs can be provided for a resource and only
                          string,"nnumeral and datetime (yyyy-MM-ddTHH:mm:ssZ) values are supported.
                    },
                    "source": "str",  # Optional. Source of the resource.
                    "status": "str",  # Optional. Status of the resource.
                    "type": "str"  # Optional. Type of the Zone.
                }
        """
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type = kwargs.pop("content_type", _headers.pop("Content-Type", None))  # type: Optional[str]
        cls = kwargs.pop("cls", None)  # type: ClsType[JSON]

        content_type = content_type or "application/merge-patch+json"
        _json = None
        _content = None
        if isinstance(zone, (IO, bytes)):
            _content = zone
        else:
            _json = zone

        request = build_zones_create_or_update_request(
            party_id=party_id,
            zone_id=zone_id,
            content_type=content_type,
            api_version=self._config.api_version,
            json=_json,
            content=_content,
            headers=_headers,
            params=_params,
        )
        request.url = self._client.format_url(request.url)  # type: ignore

        pipeline_response = self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
            request, stream=False, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200, 201]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if response.status_code == 200:
            if response.content:
                deserialized = response.json()
            else:
                deserialized = None

        if response.status_code == 201:
            if response.content:
                deserialized = response.json()
            else:
                deserialized = None

        if cls:
            return cls(pipeline_response, cast(JSON, deserialized), {})

        return cast(JSON, deserialized)

    @distributed_trace
    def delete(  # pylint: disable=inconsistent-return-statements
        self, party_id: str, zone_id: str, **kwargs: Any
    ) -> None:
        """Deletes a specified zone resource under a particular party.

        :param party_id: Id of the party. Required.
        :type party_id: str
        :param zone_id: Id of the zone. Required.
        :type zone_id: str
        :return: None
        :rtype: None
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls = kwargs.pop("cls", None)  # type: ClsType[None]

        request = build_zones_delete_request(
            party_id=party_id,
            zone_id=zone_id,
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        request.url = self._client.format_url(request.url)  # type: ignore

        pipeline_response = self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
            request, stream=False, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [204]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if cls:
            return cls(pipeline_response, None, {})

    @distributed_trace
    def list(
        self,
        *,
        types: Optional[List[str]] = None,
        management_zone_ids: Optional[List[str]] = None,
        sources: Optional[List[str]] = None,
        ids: Optional[List[str]] = None,
        names: Optional[List[str]] = None,
        property_filters: Optional[List[str]] = None,
        statuses: Optional[List[str]] = None,
        min_created_date_time: Optional[datetime.datetime] = None,
        max_created_date_time: Optional[datetime.datetime] = None,
        min_last_modified_date_time: Optional[datetime.datetime] = None,
        max_last_modified_date_time: Optional[datetime.datetime] = None,
        skip_token: Optional[str] = None,
        **kwargs: Any
    ) -> Iterable[JSON]:
        """Returns a paginated list of zone resources across all parties.

        :keyword types: Types of the Zones. Default value is None.
        :paramtype types: list[str]
        :keyword management_zone_ids: ManagementZoneIds of the Zones. Default value is None.
        :paramtype management_zone_ids: list[str]
        :keyword sources: Sources of the Zones. Default value is None.
        :paramtype sources: list[str]
        :keyword ids: Ids of the resource. Default value is None.
        :paramtype ids: list[str]
        :keyword names: Names of the resource. Default value is None.
        :paramtype names: list[str]
        :keyword property_filters: Filters on key-value pairs within the Properties object.
         eg. "{testKey} eq {testValue}". Default value is None.
        :paramtype property_filters: list[str]
        :keyword statuses: Statuses of the resource. Default value is None.
        :paramtype statuses: list[str]
        :keyword min_created_date_time: Minimum creation date of resource (inclusive). Default value is
         None.
        :paramtype min_created_date_time: ~datetime.datetime
        :keyword max_created_date_time: Maximum creation date of resource (inclusive). Default value is
         None.
        :paramtype max_created_date_time: ~datetime.datetime
        :keyword min_last_modified_date_time: Minimum last modified date of resource (inclusive).
         Default value is None.
        :paramtype min_last_modified_date_time: ~datetime.datetime
        :keyword max_last_modified_date_time: Maximum last modified date of resource (inclusive).
         Default value is None.
        :paramtype max_last_modified_date_time: ~datetime.datetime
        :keyword skip_token: Skip token for getting next set of results. Default value is None.
        :paramtype skip_token: str
        :return: An iterator like instance of JSON object
        :rtype: ~azure.core.paging.ItemPaged[JSON]
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "createdBy": "str",  # Optional. Created by user/tenant id.
                    "createdDateTime": "2020-02-20 00:00:00",  # Optional. Date-time when
                      resource was created, sample format: yyyy-MM-ddTHH:mm:ssZ.
                    "description": "str",  # Optional. Textual description of the resource.
                    "eTag": "str",  # Optional. The ETag value to implement optimistic
                      concurrency.
                    "id": "str",  # Optional. Unique resource ID.
                    "managementZoneId": "str",  # Optional. Management Zone Id associated with
                      the Zone.
                    "modifiedBy": "str",  # Optional. Modified by user/tenant id.
                    "modifiedDateTime": "2020-02-20 00:00:00",  # Optional. Date-time when
                      resource was last modified, sample format: yyyy-MM-ddTHH:mm:ssZ.
                    "name": "str",  # Optional. Name to identify resource.
                    "partyId": "str",  # Optional. Party Id associated with the Zone.
                    "properties": {
                        "str": {}  # Optional. A collection of key value pairs that belongs
                          to the resource."nEach pair must not have a key greater than 50
                          characters"nand must not have a value greater than 150 characters."nNote: A
                          maximum of 25 key value pairs can be provided for a resource and only
                          string,"nnumeral and datetime (yyyy-MM-ddTHH:mm:ssZ) values are supported.
                    },
                    "source": "str",  # Optional. Source of the resource.
                    "status": "str",  # Optional. Status of the resource.
                    "type": "str"  # Optional. Type of the Zone.
                }
        """
        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls = kwargs.pop("cls", None)  # type: ClsType[JSON]

        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        def prepare_request(next_link=None):
            if not next_link:

                request = build_zones_list_request(
                    types=types,
                    management_zone_ids=management_zone_ids,
                    sources=sources,
                    ids=ids,
                    names=names,
                    property_filters=property_filters,
                    statuses=statuses,
                    min_created_date_time=min_created_date_time,
                    max_created_date_time=max_created_date_time,
                    min_last_modified_date_time=min_last_modified_date_time,
                    max_last_modified_date_time=max_last_modified_date_time,
                    skip_token=skip_token,
                    api_version=self._config.api_version,
                    headers=_headers,
                    params=_params,
                )
                request.url = self._client.format_url(request.url)  # type: ignore

            else:
                # make call to next link with the client's api-version
                _parsed_next_link = urlparse(next_link)
                _next_request_params = case_insensitive_dict(parse_qs(_parsed_next_link.query))
                _next_request_params["api-version"] = self._config.api_version
                request = HttpRequest("GET", urljoin(next_link, _parsed_next_link.path), params=_next_request_params)
                request.url = self._client.format_url(request.url)  # type: ignore

            return request

        def extract_data(pipeline_response):
            deserialized = pipeline_response.http_response.json()
            list_of_elem = deserialized["value"]
            if cls:
                list_of_elem = cls(list_of_elem)
            return deserialized.get("nextLink", None), iter(list_of_elem)

        def get_next(next_link=None):
            request = prepare_request(next_link)

            pipeline_response = self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
                request, stream=False, **kwargs
            )
            response = pipeline_response.http_response

            if response.status_code not in [200]:
                map_error(status_code=response.status_code, response=response, error_map=error_map)
                raise HttpResponseError(response=response)

            return pipeline_response

        return ItemPaged(get_next, extract_data)

    @distributed_trace
    def get_cascade_delete_job_details(self, job_id: str, **kwargs: Any) -> JSON:
        """Get a cascade delete job for specified job id.

        :param job_id: Id of the job. Required.
        :type job_id: str
        :return: JSON object
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "partyId": "str",  # Party Id. Required.
                    "resourceId": "str",  # The id of the resource. Required.
                    "resourceType": "str",  # The type of the resource. Required.
                    "createdDateTime": "2020-02-20 00:00:00",  # Optional. Job created at
                      dateTime. Sample format: yyyy-MM-ddTHH:mm:ssZ.
                    "durationInSeconds": 0.0,  # Optional. Duration of the job in seconds.
                    "endTime": "2020-02-20 00:00:00",  # Optional. Job end time when available.
                      Sample format: yyyy-MM-ddTHH:mm:ssZ.
                    "errorCode": "str",  # Optional. Error Code when job failed.
                    "id": "str",  # Optional. Unique job id.
                    "lastActionDateTime": "2020-02-20 00:00:00",  # Optional. Job was last acted
                      upon at dateTime. Sample format: yyyy-MM-ddTHH:mm:ssZ.
                    "message": "str",  # Optional. Status message to capture more details of the
                      job.
                    "startTime": "2020-02-20 00:00:00",  # Optional. Job start time when
                      available. Sample format: yyyy-MM-ddTHH:mm:ssZ.
                    "status": "str"  # Optional. Status of the job."nPossible values: 'Waiting',
                      'Running', 'Succeeded', 'Failed', 'Cancelled'. Known values are: "Waiting",
                      "Running", "Succeeded", "Failed", and "Cancelled".
                }
        """
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls = kwargs.pop("cls", None)  # type: ClsType[JSON]

        request = build_zones_get_cascade_delete_job_details_request(
            job_id=job_id,
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        request.url = self._client.format_url(request.url)  # type: ignore

        pipeline_response = self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
            request, stream=False, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if response.content:
            deserialized = response.json()
        else:
            deserialized = None

        if cls:
            return cls(pipeline_response, cast(JSON, deserialized), {})

        return cast(JSON, deserialized)

    def _create_cascade_delete_job_initial(self, job_id: str, *, party_id: str, zone_id: str, **kwargs: Any) -> JSON:
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls = kwargs.pop("cls", None)  # type: ClsType[JSON]

        request = build_zones_create_cascade_delete_job_request(
            job_id=job_id,
            party_id=party_id,
            zone_id=zone_id,
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        request.url = self._client.format_url(request.url)  # type: ignore

        pipeline_response = self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
            request, stream=False, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [202]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if response.content:
            deserialized = response.json()
        else:
            deserialized = None

        if cls:
            return cls(pipeline_response, cast(JSON, deserialized), {})

        return cast(JSON, deserialized)

    @distributed_trace
    def begin_create_cascade_delete_job(
        self, job_id: str, *, party_id: str, zone_id: str, **kwargs: Any
    ) -> LROPoller[JSON]:
        """Create a cascade delete job for specified zone.

        :param job_id: Job ID supplied by end user. Required.
        :type job_id: str
        :keyword party_id: ID of the associated party. Required.
        :paramtype party_id: str
        :keyword zone_id: ID of the zone to be deleted. Required.
        :paramtype zone_id: str
        :keyword str continuation_token: A continuation token to restart a poller from a saved state.
        :keyword polling: By default, your polling method will be LROBasePolling. Pass in False for
         this operation to not poll, or pass in your own initialized polling object for a personal
         polling strategy.
        :paramtype polling: bool or ~azure.core.polling.PollingMethod
        :keyword int polling_interval: Default waiting time between two polls for LRO operations if no
         Retry-After header is present.
        :return: An instance of LROPoller that returns JSON object
        :rtype: ~azure.core.polling.LROPoller[JSON]
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 202
                response == {
                    "partyId": "str",  # Party Id. Required.
                    "resourceId": "str",  # The id of the resource. Required.
                    "resourceType": "str",  # The type of the resource. Required.
                    "createdDateTime": "2020-02-20 00:00:00",  # Optional. Job created at
                      dateTime. Sample format: yyyy-MM-ddTHH:mm:ssZ.
                    "durationInSeconds": 0.0,  # Optional. Duration of the job in seconds.
                    "endTime": "2020-02-20 00:00:00",  # Optional. Job end time when available.
                      Sample format: yyyy-MM-ddTHH:mm:ssZ.
                    "errorCode": "str",  # Optional. Error Code when job failed.
                    "id": "str",  # Optional. Unique job id.
                    "lastActionDateTime": "2020-02-20 00:00:00",  # Optional. Job was last acted
                      upon at dateTime. Sample format: yyyy-MM-ddTHH:mm:ssZ.
                    "message": "str",  # Optional. Status message to capture more details of the
                      job.
                    "startTime": "2020-02-20 00:00:00",  # Optional. Job start time when
                      available. Sample format: yyyy-MM-ddTHH:mm:ssZ.
                    "status": "str"  # Optional. Status of the job."nPossible values: 'Waiting',
                      'Running', 'Succeeded', 'Failed', 'Cancelled'. Known values are: "Waiting",
                      "Running", "Succeeded", "Failed", and "Cancelled".
                }
        """
        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls = kwargs.pop("cls", None)  # type: ClsType[JSON]
        polling = kwargs.pop("polling", True)  # type: Union[bool, PollingMethod]
        lro_delay = kwargs.pop("polling_interval", self._config.polling_interval)
        cont_token = kwargs.pop("continuation_token", None)  # type: Optional[str]
        if cont_token is None:
            raw_result = self._create_cascade_delete_job_initial(  # type: ignore
                job_id=job_id,
                party_id=party_id,
                zone_id=zone_id,
                cls=lambda x, y, z: x,
                headers=_headers,
                params=_params,
                **kwargs
            )
        kwargs.pop("error_map", None)

        def get_long_running_output(pipeline_response):
            response = pipeline_response.http_response
            if response.content:
                deserialized = response.json()
            else:
                deserialized = None
            if cls:
                return cls(pipeline_response, deserialized, {})
            return deserialized

        if polling is True:
            polling_method = cast(
                PollingMethod, LROBasePolling(lro_delay, lro_options={"final-state-via": "location"}, **kwargs)
            )  # type: PollingMethod
        elif polling is False:
            polling_method = cast(PollingMethod, NoPolling())
        else:
            polling_method = polling
        if cont_token:
            return LROPoller.from_continuation_token(
                polling_method=polling_method,
                continuation_token=cont_token,
                client=self._client,
                deserialization_callback=get_long_running_output,
            )
        return LROPoller(self._client, raw_result, get_long_running_output, polling_method)
