# pylint: disable=too-many-lines
# coding=utf-8
# --------------------------------------------------------------------------
# Copyright (c) Microsoft Corporation. All rights reserved.
# Licensed under the MIT License. See License.txt in the project root for license information.
# Code generated by Microsoft (R) AutoRest Code Generator.
# Changes may cause incorrect behavior and will be lost if the code is regenerated.
# --------------------------------------------------------------------------
import sys
from typing import Any, Callable, Dict, Optional, TypeVar

from azure.core.exceptions import ClientAuthenticationError, HttpResponseError, ResourceExistsError, ResourceNotFoundError, map_error
from azure.core.pipeline import PipelineResponse
from azure.core.pipeline.transport import AsyncHttpResponse
from azure.core.rest import HttpRequest
from azure.core.tracing.decorator_async import distributed_trace_async
from azure.core.utils import case_insensitive_dict

from ..._operations._operations import build_ccs_query_request, build_info_using_get_request, build_liveness_check_using_get_request, build_query_request, build_query_with_cursor_request, build_readiness_check_using_get_request
from .._vendor import MixinABC
if sys.version_info >= (3, 9):
    from collections.abc import MutableMapping
else:
    from typing import MutableMapping  # type: ignore
JSON = MutableMapping[str, Any] # pylint: disable=unsubscriptable-object
T = TypeVar('T')
ClsType = Optional[Callable[[PipelineResponse[HttpRequest, AsyncHttpResponse], T, Dict[str, Any]], Any]]

class ApiDocumentationOperationsMixin(MixinABC):

    @distributed_trace_async
    async def liveness_check_using_get(
        self,
        *,
        data_partition_id: str,
        **kwargs: Any
    ) -> Optional[str]:
        """livenessCheckUsingGET.

        livenessCheck.

        :keyword data_partition_id: tenant. This should be same value as first field in 'kind' field.
        :paramtype data_partition_id: str
        :return: str
        :rtype: str or None
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls = kwargs.pop('cls', None)  # type: ClsType[Optional[str]]

        
        request = build_liveness_check_using_get_request(
            data_partition_id=data_partition_id,
            headers=_headers,
            params=_params,
        )
        request.url = self._client.format_url(request.url)  # type: ignore

        pipeline_response = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
            request,
            stream=False,
            **kwargs
        )
        response = pipeline_response.http_response

        if response.status_code not in [200, 401, 403, 404]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        deserialized = None
        if response.status_code == 200:
            if response.content:
                deserialized = response.json()
            else:
                deserialized = None

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized



    @distributed_trace_async
    async def readiness_check_using_get(
        self,
        *,
        data_partition_id: str,
        **kwargs: Any
    ) -> Optional[str]:
        """readinessCheckUsingGET.

        readinessCheck.

        :keyword data_partition_id: tenant. This should be same value as first field in 'kind' field.
        :paramtype data_partition_id: str
        :return: str
        :rtype: str or None
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls = kwargs.pop('cls', None)  # type: ClsType[Optional[str]]

        
        request = build_readiness_check_using_get_request(
            data_partition_id=data_partition_id,
            headers=_headers,
            params=_params,
        )
        request.url = self._client.format_url(request.url)  # type: ignore

        pipeline_response = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
            request,
            stream=False,
            **kwargs
        )
        response = pipeline_response.http_response

        if response.status_code not in [200, 401, 403, 404]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        deserialized = None
        if response.status_code == 200:
            if response.content:
                deserialized = response.json()
            else:
                deserialized = None

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized



    @distributed_trace_async
    async def info_using_get(
        self,
        *,
        data_partition_id: str,
        **kwargs: Any
    ) -> Optional[JSON]:
        """infoUsingGET.

        info.

        :keyword data_partition_id: tenant. This should be same value as first field in 'kind' field.
        :paramtype data_partition_id: str
        :return: JSON object
        :rtype: JSON or None
        :raises: ~azure.core.exceptions.HttpResponseError

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response.json() == {
                    "artifactId": "str",  # Optional.
                    "branch": "str",  # Optional.
                    "buildTime": "str",  # Optional.
                    "commitId": "str",  # Optional.
                    "commitMessage": "str",  # Optional.
                    "connectedOuterServices": [
                        {
                            "name": "str",  # Optional.
                            "version": "str"  # Optional.
                        }
                    ],
                    "groupId": "str",  # Optional.
                    "version": "str"  # Optional.
                }
        """
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls = kwargs.pop('cls', None)  # type: ClsType[Optional[JSON]]

        
        request = build_info_using_get_request(
            data_partition_id=data_partition_id,
            headers=_headers,
            params=_params,
        )
        request.url = self._client.format_url(request.url)  # type: ignore

        pipeline_response = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
            request,
            stream=False,
            **kwargs
        )
        response = pipeline_response.http_response

        if response.status_code not in [200, 401, 403, 404]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        deserialized = None
        if response.status_code == 200:
            if response.content:
                deserialized = response.json()
            else:
                deserialized = None

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized



    @distributed_trace_async
    async def ccs_query(
        self,
        body: Optional[JSON] = None,
        *,
        account_id: str,
        data_partition_id: str,
        on_behalf_of: Optional[str] = None,
        **kwargs: Any
    ) -> Optional[JSON]:
        """CCS Query.

        The API supports cross cluster searches when given the list of partitions.

        :param body:  Default value is None.
        :type body: JSON
        :keyword account_id: Account ID is the active DELFI account (SLB account or customer's account)
         which the users choose to use with the Search API.
        :paramtype account_id: str
        :keyword data_partition_id: tenant. This should be same value as first field in 'kind' field.
        :paramtype data_partition_id: str
        :keyword on_behalf_of: Token (Google ID or SAuth) representing the user whose request is sent
         on behalf of. Default value is None.
        :paramtype on_behalf_of: str
        :return: JSON object
        :rtype: JSON or None
        :raises: ~azure.core.exceptions.HttpResponseError

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                body = {
                    "kind": "str",  # Required. 'kind' to search.
                    "limit": 0,  # Optional. The maximum number of results to return from the
                      given offset. If no limit is provided, then it will return 10 items. Max number
                      of items which can be fetched by the query is 1000. (If you wish to fetch large
                      set of items, please use query_with_cursor API).
                    "offset": 0,  # Optional. The starting offset from which to return results.
                    "query": "str",  # Optional. The query string in Lucene query string syntax.
                    "queryAsOwner": bool  # Optional. The queryAsOwner switches between viewer
                      and owner to return results that you are entitled to view or results you are the
                      owner of.
                }

                # response body for status code(s): 200
                response.json() == {
                    "results": [
                        {}  # Optional.
                    ],
                    "totalCount": 0.0  # Optional.
                }
        """
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type = kwargs.pop('content_type', _headers.pop('Content-Type', "application/json"))  # type: Optional[str]
        cls = kwargs.pop('cls', None)  # type: ClsType[Optional[JSON]]

        if body is not None:
            _json = body
        else:
            _json = None

        request = build_ccs_query_request(
            content_type=content_type,
            account_id=account_id,
            data_partition_id=data_partition_id,
            json=_json,
            on_behalf_of=on_behalf_of,
            headers=_headers,
            params=_params,
        )
        request.url = self._client.format_url(request.url)  # type: ignore

        pipeline_response = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
            request,
            stream=False,
            **kwargs
        )
        response = pipeline_response.http_response

        if response.status_code not in [200, 201, 400, 401, 403, 404, 502]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        deserialized = None
        if response.status_code == 200:
            if response.content:
                deserialized = response.json()
            else:
                deserialized = None

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized



    @distributed_trace_async
    async def query(
        self,
        body: Optional[JSON] = None,
        *,
        account_id: str,
        data_partition_id: str,
        on_behalf_of: Optional[str] = None,
        **kwargs: Any
    ) -> Optional[JSON]:
        """Query.

        The API supports full text search on string fields, range queries on date, numeric or string
        fields, along with geo-spatial search. Required roles: 'users.datalake.viewers' or
        'users.datalake.editors' or 'users.datalake.admins' or 'users.datalake.ops'. In addition, users
        must be a member of data groups to access the data.

        :param body:  Default value is None.
        :type body: JSON
        :keyword account_id: Account ID is the active DELFI account (SLB account or customer's account)
         which the users choose to use with the Search API.
        :paramtype account_id: str
        :keyword data_partition_id: tenant. This should be same value as first field in 'kind' field.
        :paramtype data_partition_id: str
        :keyword on_behalf_of: Token (Google ID or SAuth) representing the user whose request is sent
         on behalf of. Default value is None.
        :paramtype on_behalf_of: str
        :return: JSON object
        :rtype: JSON or None
        :raises: ~azure.core.exceptions.HttpResponseError

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                body = {
                    "kind": "str",  # Required. 'kind' to search.
                    "limit": 0,  # Optional. The maximum number of results to return from the
                      given offset. If no limit is provided, then it will return 10 items. Max number
                      of items which can be fetched by the query is 1000. (If you wish to fetch large
                      set of items, please use query_with_cursor API).
                    "offset": 0,  # Optional. The starting offset from which to return results.
                    "query": "str",  # Optional. The query string in Lucene query string syntax.
                    "queryAsOwner": bool,  # Optional. The queryAsOwner switches between viewer
                      and owner to return results that you are entitled to view or results you are the
                      owner of.
                    "returnedFields": [
                        "str"  # Optional. The fields on which to project the results.
                    ],
                    "sort": {
                        "field": [
                            "str"  # Optional. The list of fields to sort the results.
                        ],
                        "order": {}  # Optional. The list of orders to sort the results. The
                          element must be either ASC or DESC.
                    },
                    "spatialFilter": {
                        "byBoundingBox": {
                            "bottomRight": {
                                "latitude": 0.0,  # Optional. Latitude of point.
                                "longitude": 0.0  # Optional. Longitude of point.
                            },
                            "topLeft": {
                                "latitude": 0.0,  # Optional. Latitude of point.
                                "longitude": 0.0  # Optional. Longitude of point.
                            }
                        },
                        "byDistance": {
                            "distance": 0.0,  # Optional. The radius of the circle
                              centered on the specified location. Points which fall into this circle
                              are considered to be matches.
                            "point": {
                                "latitude": 0.0,  # Optional. Latitude of point.
                                "longitude": 0.0  # Optional. Longitude of point.
                            }
                        },
                        "byGeoPolygon": {
                            "points": [
                                {
                                    "latitude": 0.0,  # Optional. Latitude of
                                      point.
                                    "longitude": 0.0  # Optional. Longitude of
                                      point.
                                }
                            ]
                        },
                        "field": "str"  # Optional. geo-point field in the index on which
                          filtering will be performed. Use GET schema API to find which fields supports
                          spatial search.
                    },
                    "trackTotalCount": bool  # Optional. Tracks accurate record count matching
                      the query if 'true', partial count otherwise. Partial count queries are more
                      performant. Default is 'false' and returns 10000 if matching records are higher
                      than 10000.
                }

                # response body for status code(s): 200
                response.json() == {
                    "aggregations": [
                        {
                            "count": 0.0,  # Optional.
                            "key": "str"  # Optional.
                        }
                    ],
                    "results": [
                        {}  # Optional.
                    ],
                    "totalCount": 0.0  # Optional.
                }
        """
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type = kwargs.pop('content_type', _headers.pop('Content-Type', "application/json"))  # type: Optional[str]
        cls = kwargs.pop('cls', None)  # type: ClsType[Optional[JSON]]

        if body is not None:
            _json = body
        else:
            _json = None

        request = build_query_request(
            content_type=content_type,
            account_id=account_id,
            data_partition_id=data_partition_id,
            json=_json,
            on_behalf_of=on_behalf_of,
            headers=_headers,
            params=_params,
        )
        request.url = self._client.format_url(request.url)  # type: ignore

        pipeline_response = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
            request,
            stream=False,
            **kwargs
        )
        response = pipeline_response.http_response

        if response.status_code not in [200, 201, 400, 401, 403, 404, 502]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        deserialized = None
        if response.status_code == 200:
            if response.content:
                deserialized = response.json()
            else:
                deserialized = None

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized



    @distributed_trace_async
    async def query_with_cursor(
        self,
        body: Optional[JSON] = None,
        *,
        account_id: str,
        data_partition_id: str,
        on_behalf_of: Optional[str] = None,
        **kwargs: Any
    ) -> Optional[JSON]:
        """Query with cursor.

        The API supports full text search on string fields, range queries on date, numeric or string
        fields, along with geo-spatial search. Required roles: 'users.datalake.viewers' or
        'users.datalake.editors' or 'users.datalake.admins' or 'users.datalake.ops'. In addition, users
        must be a member of data groups to access the data. It can be used to retrieve large numbers of
        results (or even all results) from a single search request, in much the same way as you would
        use a cursor on a traditional database.

        :param body:  Default value is None.
        :type body: JSON
        :keyword account_id: Account ID is the active DELFI account (SLB account or customer's account)
         which the users choose to use with the Search API.
        :paramtype account_id: str
        :keyword data_partition_id: tenant. This should be same value as first field in 'kind' field.
        :paramtype data_partition_id: str
        :keyword on_behalf_of: Token (Google ID or SAuth) representing the user whose request is sent
         on behalf of. Default value is None.
        :paramtype on_behalf_of: str
        :return: JSON object
        :rtype: JSON or None
        :raises: ~azure.core.exceptions.HttpResponseError

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                body = {
                    "cursor": "str",  # Optional. Search context to retrieve next batch of
                      results.
                    "kind": "str",  # Required. 'kind' to search.
                    "limit": 0,  # Optional. The maximum number of results to return from the
                      given offset. If no limit is provided, then it will return 10 items. Max number
                      of items which can be fetched by the query is 1000. (If you wish to fetch large
                      set of items, please use query_with_cursor API).
                    "query": "str",  # Optional. The query string in Lucene query string syntax.
                    "queryAsOwner": bool,  # Optional. The queryAsOwner switches between viewer
                      and owner to return results that you are entitled to view or results you are the
                      owner of.
                    "returnedFields": [
                        "str"  # Optional. The fields on which to project the results.
                    ],
                    "sort": {
                        "field": [
                            "str"  # Optional. The list of fields to sort the results.
                        ],
                        "order": {}  # Optional. The list of orders to sort the results. The
                          element must be either ASC or DESC.
                    },
                    "spatialFilter": {
                        "byBoundingBox": {
                            "bottomRight": {
                                "latitude": 0.0,  # Optional. Latitude of point.
                                "longitude": 0.0  # Optional. Longitude of point.
                            },
                            "topLeft": {
                                "latitude": 0.0,  # Optional. Latitude of point.
                                "longitude": 0.0  # Optional. Longitude of point.
                            }
                        },
                        "byDistance": {
                            "distance": 0.0,  # Optional. The radius of the circle
                              centered on the specified location. Points which fall into this circle
                              are considered to be matches.
                            "point": {
                                "latitude": 0.0,  # Optional. Latitude of point.
                                "longitude": 0.0  # Optional. Longitude of point.
                            }
                        },
                        "byGeoPolygon": {
                            "points": [
                                {
                                    "latitude": 0.0,  # Optional. Latitude of
                                      point.
                                    "longitude": 0.0  # Optional. Longitude of
                                      point.
                                }
                            ]
                        },
                        "field": "str"  # Optional. geo-point field in the index on which
                          filtering will be performed. Use GET schema API to find which fields supports
                          spatial search.
                    },
                    "trackTotalCount": bool  # Optional. Tracks accurate record count matching
                      the query if 'true', partial count otherwise. Partial count queries are more
                      performant. Default is 'false' and returns 10000 if matching records are higher
                      than 10000.
                }

                # response body for status code(s): 200
                response.json() == {
                    "cursor": "str",  # Optional.
                    "results": [
                        {}  # Optional.
                    ],
                    "totalCount": 0.0  # Optional.
                }
        """
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type = kwargs.pop('content_type', _headers.pop('Content-Type', "application/json"))  # type: Optional[str]
        cls = kwargs.pop('cls', None)  # type: ClsType[Optional[JSON]]

        if body is not None:
            _json = body
        else:
            _json = None

        request = build_query_with_cursor_request(
            content_type=content_type,
            account_id=account_id,
            data_partition_id=data_partition_id,
            json=_json,
            on_behalf_of=on_behalf_of,
            headers=_headers,
            params=_params,
        )
        request.url = self._client.format_url(request.url)  # type: ignore

        pipeline_response = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
            request,
            stream=False,
            **kwargs
        )
        response = pipeline_response.http_response

        if response.status_code not in [200, 201, 400, 401, 403, 404, 502]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        deserialized = None
        if response.status_code == 200:
            if response.content:
                deserialized = response.json()
            else:
                deserialized = None

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized


