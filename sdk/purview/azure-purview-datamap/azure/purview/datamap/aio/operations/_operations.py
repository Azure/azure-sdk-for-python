# pylint: disable=too-many-lines
# coding=utf-8
# --------------------------------------------------------------------------
# Copyright (c) Microsoft Corporation. All rights reserved.
# Licensed under the MIT License. See License.txt in the project root for license information.
# Code generated by Microsoft (R) Python Code Generator.
# Changes may cause incorrect behavior and will be lost if the code is regenerated.
# --------------------------------------------------------------------------
from io import IOBase
import json
import sys
from typing import Any, Callable, Dict, IO, List, Optional, TypeVar, Union, overload

from azure.core.exceptions import (
    ClientAuthenticationError,
    HttpResponseError,
    ResourceExistsError,
    ResourceNotFoundError,
    ResourceNotModifiedError,
    map_error,
)
from azure.core.pipeline import PipelineResponse
from azure.core.rest import AsyncHttpResponse, HttpRequest
from azure.core.tracing.decorator_async import distributed_trace_async
from azure.core.utils import case_insensitive_dict

from ... import models as _models
from ..._model_base import SdkJSONEncoder, _deserialize
from ...operations._operations import (
    build_discovery_auto_complete_request,
    build_discovery_query_request,
    build_discovery_suggest_request,
    build_entity_add_classification_request,
    build_entity_add_classifications_by_unique_attribute_request,
    build_entity_add_classifications_request,
    build_entity_add_label_request,
    build_entity_add_labels_by_unique_attribute_request,
    build_entity_add_or_update_business_metadata_attributes_request,
    build_entity_add_or_update_business_metadata_request,
    build_entity_bulk_create_or_update_request,
    build_entity_bulk_delete_request,
    build_entity_bulk_set_classifications_request,
    build_entity_create_or_update_request,
    build_entity_delete_by_unique_attribute_request,
    build_entity_delete_request,
    build_entity_get_by_unique_attributes_request,
    build_entity_get_classification_request,
    build_entity_get_classifications_request,
    build_entity_get_header_request,
    build_entity_get_request,
    build_entity_get_sample_business_metadata_template_request,
    build_entity_import_business_metadata_request,
    build_entity_list_by_guids_request,
    build_entity_list_by_unique_attributes_request,
    build_entity_move_entities_to_collection_request,
    build_entity_partial_update_attribute_by_guid_request,
    build_entity_partial_update_by_unique_attributes_request,
    build_entity_remove_business_metadata_attributes_request,
    build_entity_remove_business_metadata_request,
    build_entity_remove_classification_by_unique_attribute_request,
    build_entity_remove_classification_request,
    build_entity_remove_labels_by_unique_attribute_request,
    build_entity_remove_labels_request,
    build_entity_set_labels_by_unique_attribute_request,
    build_entity_set_labels_request,
    build_entity_update_classifications_by_unique_attribute_request,
    build_entity_update_classifications_request,
    build_glossary_assign_term_to_entities_request,
    build_glossary_create_categories_request,
    build_glossary_create_category_request,
    build_glossary_create_request,
    build_glossary_create_term_request,
    build_glossary_create_terms_request,
    build_glossary_delete_category_request,
    build_glossary_delete_request,
    build_glossary_delete_term_assignment_from_entities_request,
    build_glossary_delete_term_request,
    build_glossary_get_category_request,
    build_glossary_get_detailed_request,
    build_glossary_get_request,
    build_glossary_get_term_request,
    build_glossary_list_categories_headers_request,
    build_glossary_list_categories_request,
    build_glossary_list_category_terms_request,
    build_glossary_list_entities_assigned_with_term_request,
    build_glossary_list_related_categories_request,
    build_glossary_list_related_terms_request,
    build_glossary_list_request,
    build_glossary_list_term_headers_request,
    build_glossary_list_terms_request,
    build_glossary_partial_update_category_request,
    build_glossary_partial_update_request,
    build_glossary_partial_update_term_request,
    build_glossary_update_category_request,
    build_glossary_update_request,
    build_glossary_update_term_request,
    build_lineage_get_by_unique_attribute_request,
    build_lineage_get_next_page_request,
    build_lineage_get_request,
    build_relationship_create_request,
    build_relationship_delete_request,
    build_relationship_get_request,
    build_relationship_update_request,
    build_type_bulk_create_request,
    build_type_bulk_delete_request,
    build_type_bulk_update_request,
    build_type_delete_request,
    build_type_get_business_metadata_def_by_guid_request,
    build_type_get_business_metadata_def_by_name_request,
    build_type_get_by_guid_request,
    build_type_get_by_name_request,
    build_type_get_classification_def_by_guid_request,
    build_type_get_classification_def_by_name_request,
    build_type_get_entity_def_by_guid_request,
    build_type_get_entity_def_by_name_request,
    build_type_get_enum_def_by_guid_request,
    build_type_get_enum_def_by_name_request,
    build_type_get_relationship_def_by_guid_request,
    build_type_get_relationship_def_by_name_request,
    build_type_get_struct_def_by_guid_request,
    build_type_get_struct_def_by_name_request,
    build_type_get_term_template_def_by_guid_request,
    build_type_get_term_template_def_by_name_request,
    build_type_list_headers_request,
    build_type_list_request,
)

if sys.version_info >= (3, 9):
    from collections.abc import MutableMapping
else:
    from typing import MutableMapping  # type: ignore  # pylint: disable=ungrouped-imports
JSON = MutableMapping[str, Any]  # pylint: disable=unsubscriptable-object
_Unset: Any = object()
T = TypeVar("T")
ClsType = Optional[Callable[[PipelineResponse[HttpRequest, AsyncHttpResponse], T, Dict[str, Any]], Any]]


class EntityOperations:  # pylint: disable=too-many-public-methods
    """
    .. warning::
        **DO NOT** instantiate this class directly.

        Instead, you should access the following operations through
        :class:`~azure.purview.datamap.aio.PurviewDataMapClient`'s
        :attr:`entity` attribute.
    """

    def __init__(self, *args, **kwargs) -> None:
        input_args = list(args)
        self._client = input_args.pop(0) if input_args else kwargs.pop("client")
        self._config = input_args.pop(0) if input_args else kwargs.pop("config")
        self._serialize = input_args.pop(0) if input_args else kwargs.pop("serializer")
        self._deserialize = input_args.pop(0) if input_args else kwargs.pop("deserializer")

    @overload
    async def create_or_update(
        self,
        entity: _models.AtlasEntityWithExtInfo,
        *,
        business_attribute_update_behavior: Optional[Union[str, _models.BusinessAttributeUpdateBehavior]] = None,
        collection_id: Optional[str] = None,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> _models.EntityMutationResponse:
        """Create or update an entity.
        Existing entity is matched using its unique guid if
        supplied or by its unique attributes eg: qualifiedName.
        Map and array of
        collections are not well supported. E.g., array<array:code:`<int>`>, array<map<string,
        int>>.
        For each contact type, the maximum number of contacts is 20.

        :param entity: Atlas entity with extended information. Required.
        :type entity: ~azure.purview.datamap.models.AtlasEntityWithExtInfo
        :keyword business_attribute_update_behavior: Used to define the update behavior for business
         attributes when updating
         entities. Known values are: "ignore", "replace", and "merge". Default value is None.
        :paramtype business_attribute_update_behavior: str or
         ~azure.purview.datamap.models.BusinessAttributeUpdateBehavior
        :keyword collection_id: The collection where entities will be moved to. Only specify a value if
         you
         need to move an entity to another collection. Default value is None.
        :paramtype collection_id: str
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :keyword bool stream: Whether to stream the response of this operation. Defaults to False. You
         will have to context manage the returned stream.
        :return: EntityMutationResponse. The EntityMutationResponse is compatible with MutableMapping
        :rtype: ~azure.purview.datamap.models.EntityMutationResponse
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @overload
    async def create_or_update(
        self,
        entity: JSON,
        *,
        business_attribute_update_behavior: Optional[Union[str, _models.BusinessAttributeUpdateBehavior]] = None,
        collection_id: Optional[str] = None,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> _models.EntityMutationResponse:
        """Create or update an entity.
        Existing entity is matched using its unique guid if
        supplied or by its unique attributes eg: qualifiedName.
        Map and array of
        collections are not well supported. E.g., array<array:code:`<int>`>, array<map<string,
        int>>.
        For each contact type, the maximum number of contacts is 20.

        :param entity: Atlas entity with extended information. Required.
        :type entity: JSON
        :keyword business_attribute_update_behavior: Used to define the update behavior for business
         attributes when updating
         entities. Known values are: "ignore", "replace", and "merge". Default value is None.
        :paramtype business_attribute_update_behavior: str or
         ~azure.purview.datamap.models.BusinessAttributeUpdateBehavior
        :keyword collection_id: The collection where entities will be moved to. Only specify a value if
         you
         need to move an entity to another collection. Default value is None.
        :paramtype collection_id: str
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :keyword bool stream: Whether to stream the response of this operation. Defaults to False. You
         will have to context manage the returned stream.
        :return: EntityMutationResponse. The EntityMutationResponse is compatible with MutableMapping
        :rtype: ~azure.purview.datamap.models.EntityMutationResponse
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @overload
    async def create_or_update(
        self,
        entity: IO[bytes],
        *,
        business_attribute_update_behavior: Optional[Union[str, _models.BusinessAttributeUpdateBehavior]] = None,
        collection_id: Optional[str] = None,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> _models.EntityMutationResponse:
        """Create or update an entity.
        Existing entity is matched using its unique guid if
        supplied or by its unique attributes eg: qualifiedName.
        Map and array of
        collections are not well supported. E.g., array<array:code:`<int>`>, array<map<string,
        int>>.
        For each contact type, the maximum number of contacts is 20.

        :param entity: Atlas entity with extended information. Required.
        :type entity: IO[bytes]
        :keyword business_attribute_update_behavior: Used to define the update behavior for business
         attributes when updating
         entities. Known values are: "ignore", "replace", and "merge". Default value is None.
        :paramtype business_attribute_update_behavior: str or
         ~azure.purview.datamap.models.BusinessAttributeUpdateBehavior
        :keyword collection_id: The collection where entities will be moved to. Only specify a value if
         you
         need to move an entity to another collection. Default value is None.
        :paramtype collection_id: str
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Default value is "application/json".
        :paramtype content_type: str
        :keyword bool stream: Whether to stream the response of this operation. Defaults to False. You
         will have to context manage the returned stream.
        :return: EntityMutationResponse. The EntityMutationResponse is compatible with MutableMapping
        :rtype: ~azure.purview.datamap.models.EntityMutationResponse
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @distributed_trace_async
    async def create_or_update(
        self,
        entity: Union[_models.AtlasEntityWithExtInfo, JSON, IO[bytes]],
        *,
        business_attribute_update_behavior: Optional[Union[str, _models.BusinessAttributeUpdateBehavior]] = None,
        collection_id: Optional[str] = None,
        **kwargs: Any
    ) -> _models.EntityMutationResponse:
        """Create or update an entity.
        Existing entity is matched using its unique guid if
        supplied or by its unique attributes eg: qualifiedName.
        Map and array of
        collections are not well supported. E.g., array<array:code:`<int>`>, array<map<string,
        int>>.
        For each contact type, the maximum number of contacts is 20.

        :param entity: Atlas entity with extended information. Is one of the following types:
         AtlasEntityWithExtInfo, JSON, IO[bytes] Required.
        :type entity: ~azure.purview.datamap.models.AtlasEntityWithExtInfo or JSON or IO[bytes]
        :keyword business_attribute_update_behavior: Used to define the update behavior for business
         attributes when updating
         entities. Known values are: "ignore", "replace", and "merge". Default value is None.
        :paramtype business_attribute_update_behavior: str or
         ~azure.purview.datamap.models.BusinessAttributeUpdateBehavior
        :keyword collection_id: The collection where entities will be moved to. Only specify a value if
         you
         need to move an entity to another collection. Default value is None.
        :paramtype collection_id: str
        :keyword content_type: Body parameter Content-Type. Known values are: application/json. Default
         value is None.
        :paramtype content_type: str
        :keyword bool stream: Whether to stream the response of this operation. Defaults to False. You
         will have to context manage the returned stream.
        :return: EntityMutationResponse. The EntityMutationResponse is compatible with MutableMapping
        :rtype: ~azure.purview.datamap.models.EntityMutationResponse
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[_models.EntityMutationResponse] = kwargs.pop("cls", None)

        content_type = content_type or "application/json"
        _content = None
        if isinstance(entity, (IOBase, bytes)):
            _content = entity
        else:
            _content = json.dumps(entity, cls=SdkJSONEncoder, exclude_readonly=True)  # type: ignore

        _request = build_entity_create_or_update_request(
            business_attribute_update_behavior=business_attribute_update_behavior,
            collection_id=collection_id,
            content_type=content_type,
            api_version=self._config.api_version,
            content=_content,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = kwargs.pop("stream", False)
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                await response.read()  # Load the body in memory and close the socket
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = _deserialize(_models.ErrorResponse, response.json())
            raise HttpResponseError(response=response, model=error)

        if _stream:
            deserialized = response.iter_bytes()
        else:
            deserialized = _deserialize(_models.EntityMutationResponse, response.json())

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore

    @distributed_trace_async
    async def list_by_guids(
        self,
        *,
        guid: List[str],
        min_ext_info: Optional[bool] = None,
        ignore_relationships: Optional[bool] = None,
        **kwargs: Any
    ) -> _models.AtlasEntitiesWithExtInfo:
        """List entities in bulk identified by its GUIDs.

        :keyword guid: An array of GUIDs of entities to list. Required.
        :paramtype guid: list[str]
        :keyword min_ext_info: Whether to return minimal information for referred entities. Default
         value is None.
        :paramtype min_ext_info: bool
        :keyword ignore_relationships: Whether to ignore relationship attributes. Default value is
         None.
        :paramtype ignore_relationships: bool
        :keyword bool stream: Whether to stream the response of this operation. Defaults to False. You
         will have to context manage the returned stream.
        :return: AtlasEntitiesWithExtInfo. The AtlasEntitiesWithExtInfo is compatible with
         MutableMapping
        :rtype: ~azure.purview.datamap.models.AtlasEntitiesWithExtInfo
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[_models.AtlasEntitiesWithExtInfo] = kwargs.pop("cls", None)

        _request = build_entity_list_by_guids_request(
            guid=guid,
            min_ext_info=min_ext_info,
            ignore_relationships=ignore_relationships,
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = kwargs.pop("stream", False)
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                await response.read()  # Load the body in memory and close the socket
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = _deserialize(_models.ErrorResponse, response.json())
            raise HttpResponseError(response=response, model=error)

        if _stream:
            deserialized = response.iter_bytes()
        else:
            deserialized = _deserialize(_models.AtlasEntitiesWithExtInfo, response.json())

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore

    @overload
    async def bulk_create_or_update(
        self,
        entities: _models.AtlasEntitiesWithExtInfo,
        *,
        collection_id: Optional[str] = None,
        business_attribute_update_behavior: Optional[Union[str, _models.BusinessAttributeUpdateBehavior]] = None,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> _models.EntityMutationResponse:
        """Create or update entities in bulk.
        Existing entity is matched using its unique
        guid if supplied or by its unique attributes eg: qualifiedName.
        Map and array
        of collections are not well supported. E.g., array<array:code:`<int>`>,
        array<map<string, int>>.
        For each contact type, the maximum number of contacts
        is 20.

        :param entities: An array of entities to create or update. Required.
        :type entities: ~azure.purview.datamap.models.AtlasEntitiesWithExtInfo
        :keyword collection_id: The collection where entities will be moved to. Only specify a value if
         you
         need to move an entity to another collection. Default value is None.
        :paramtype collection_id: str
        :keyword business_attribute_update_behavior: Used to define the update behavior for business
         attributes when updating
         entities. Known values are: "ignore", "replace", and "merge". Default value is None.
        :paramtype business_attribute_update_behavior: str or
         ~azure.purview.datamap.models.BusinessAttributeUpdateBehavior
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :keyword bool stream: Whether to stream the response of this operation. Defaults to False. You
         will have to context manage the returned stream.
        :return: EntityMutationResponse. The EntityMutationResponse is compatible with MutableMapping
        :rtype: ~azure.purview.datamap.models.EntityMutationResponse
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @overload
    async def bulk_create_or_update(
        self,
        entities: JSON,
        *,
        collection_id: Optional[str] = None,
        business_attribute_update_behavior: Optional[Union[str, _models.BusinessAttributeUpdateBehavior]] = None,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> _models.EntityMutationResponse:
        """Create or update entities in bulk.
        Existing entity is matched using its unique
        guid if supplied or by its unique attributes eg: qualifiedName.
        Map and array
        of collections are not well supported. E.g., array<array:code:`<int>`>,
        array<map<string, int>>.
        For each contact type, the maximum number of contacts
        is 20.

        :param entities: An array of entities to create or update. Required.
        :type entities: JSON
        :keyword collection_id: The collection where entities will be moved to. Only specify a value if
         you
         need to move an entity to another collection. Default value is None.
        :paramtype collection_id: str
        :keyword business_attribute_update_behavior: Used to define the update behavior for business
         attributes when updating
         entities. Known values are: "ignore", "replace", and "merge". Default value is None.
        :paramtype business_attribute_update_behavior: str or
         ~azure.purview.datamap.models.BusinessAttributeUpdateBehavior
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :keyword bool stream: Whether to stream the response of this operation. Defaults to False. You
         will have to context manage the returned stream.
        :return: EntityMutationResponse. The EntityMutationResponse is compatible with MutableMapping
        :rtype: ~azure.purview.datamap.models.EntityMutationResponse
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @overload
    async def bulk_create_or_update(
        self,
        entities: IO[bytes],
        *,
        collection_id: Optional[str] = None,
        business_attribute_update_behavior: Optional[Union[str, _models.BusinessAttributeUpdateBehavior]] = None,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> _models.EntityMutationResponse:
        """Create or update entities in bulk.
        Existing entity is matched using its unique
        guid if supplied or by its unique attributes eg: qualifiedName.
        Map and array
        of collections are not well supported. E.g., array<array:code:`<int>`>,
        array<map<string, int>>.
        For each contact type, the maximum number of contacts
        is 20.

        :param entities: An array of entities to create or update. Required.
        :type entities: IO[bytes]
        :keyword collection_id: The collection where entities will be moved to. Only specify a value if
         you
         need to move an entity to another collection. Default value is None.
        :paramtype collection_id: str
        :keyword business_attribute_update_behavior: Used to define the update behavior for business
         attributes when updating
         entities. Known values are: "ignore", "replace", and "merge". Default value is None.
        :paramtype business_attribute_update_behavior: str or
         ~azure.purview.datamap.models.BusinessAttributeUpdateBehavior
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Default value is "application/json".
        :paramtype content_type: str
        :keyword bool stream: Whether to stream the response of this operation. Defaults to False. You
         will have to context manage the returned stream.
        :return: EntityMutationResponse. The EntityMutationResponse is compatible with MutableMapping
        :rtype: ~azure.purview.datamap.models.EntityMutationResponse
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @distributed_trace_async
    async def bulk_create_or_update(
        self,
        entities: Union[_models.AtlasEntitiesWithExtInfo, JSON, IO[bytes]],
        *,
        collection_id: Optional[str] = None,
        business_attribute_update_behavior: Optional[Union[str, _models.BusinessAttributeUpdateBehavior]] = None,
        **kwargs: Any
    ) -> _models.EntityMutationResponse:
        """Create or update entities in bulk.
        Existing entity is matched using its unique
        guid if supplied or by its unique attributes eg: qualifiedName.
        Map and array
        of collections are not well supported. E.g., array<array:code:`<int>`>,
        array<map<string, int>>.
        For each contact type, the maximum number of contacts
        is 20.

        :param entities: An array of entities to create or update. Is one of the following types:
         AtlasEntitiesWithExtInfo, JSON, IO[bytes] Required.
        :type entities: ~azure.purview.datamap.models.AtlasEntitiesWithExtInfo or JSON or IO[bytes]
        :keyword collection_id: The collection where entities will be moved to. Only specify a value if
         you
         need to move an entity to another collection. Default value is None.
        :paramtype collection_id: str
        :keyword business_attribute_update_behavior: Used to define the update behavior for business
         attributes when updating
         entities. Known values are: "ignore", "replace", and "merge". Default value is None.
        :paramtype business_attribute_update_behavior: str or
         ~azure.purview.datamap.models.BusinessAttributeUpdateBehavior
        :keyword content_type: Body parameter Content-Type. Known values are: application/json. Default
         value is None.
        :paramtype content_type: str
        :keyword bool stream: Whether to stream the response of this operation. Defaults to False. You
         will have to context manage the returned stream.
        :return: EntityMutationResponse. The EntityMutationResponse is compatible with MutableMapping
        :rtype: ~azure.purview.datamap.models.EntityMutationResponse
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[_models.EntityMutationResponse] = kwargs.pop("cls", None)

        content_type = content_type or "application/json"
        _content = None
        if isinstance(entities, (IOBase, bytes)):
            _content = entities
        else:
            _content = json.dumps(entities, cls=SdkJSONEncoder, exclude_readonly=True)  # type: ignore

        _request = build_entity_bulk_create_or_update_request(
            collection_id=collection_id,
            business_attribute_update_behavior=business_attribute_update_behavior,
            content_type=content_type,
            api_version=self._config.api_version,
            content=_content,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = kwargs.pop("stream", False)
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                await response.read()  # Load the body in memory and close the socket
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = _deserialize(_models.ErrorResponse, response.json())
            raise HttpResponseError(response=response, model=error)

        if _stream:
            deserialized = response.iter_bytes()
        else:
            deserialized = _deserialize(_models.EntityMutationResponse, response.json())

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore

    @distributed_trace_async
    async def bulk_delete(self, *, guid: List[str], **kwargs: Any) -> _models.EntityMutationResponse:
        """Delete a list of entities in bulk identified by their GUIDs or unique
        attributes.

        :keyword guid: An array of GUIDs of entities to delete. Required.
        :paramtype guid: list[str]
        :keyword bool stream: Whether to stream the response of this operation. Defaults to False. You
         will have to context manage the returned stream.
        :return: EntityMutationResponse. The EntityMutationResponse is compatible with MutableMapping
        :rtype: ~azure.purview.datamap.models.EntityMutationResponse
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[_models.EntityMutationResponse] = kwargs.pop("cls", None)

        _request = build_entity_bulk_delete_request(
            guid=guid,
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = kwargs.pop("stream", False)
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                await response.read()  # Load the body in memory and close the socket
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = _deserialize(_models.ErrorResponse, response.json())
            raise HttpResponseError(response=response, model=error)

        if _stream:
            deserialized = response.iter_bytes()
        else:
            deserialized = _deserialize(_models.EntityMutationResponse, response.json())

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore

    @overload
    async def add_classification(  # pylint: disable=inconsistent-return-statements
        self, request: _models.ClassificationAssociateRequest, *, content_type: str = "application/json", **kwargs: Any
    ) -> None:
        """Associate a classification to multiple entities in bulk.

        :param request: The request to associate a classification to multiple entities. Required.
        :type request: ~azure.purview.datamap.models.ClassificationAssociateRequest
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: None
        :rtype: None
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @overload
    async def add_classification(  # pylint: disable=inconsistent-return-statements
        self, request: JSON, *, content_type: str = "application/json", **kwargs: Any
    ) -> None:
        """Associate a classification to multiple entities in bulk.

        :param request: The request to associate a classification to multiple entities. Required.
        :type request: JSON
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: None
        :rtype: None
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @overload
    async def add_classification(  # pylint: disable=inconsistent-return-statements
        self, request: IO[bytes], *, content_type: str = "application/json", **kwargs: Any
    ) -> None:
        """Associate a classification to multiple entities in bulk.

        :param request: The request to associate a classification to multiple entities. Required.
        :type request: IO[bytes]
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: None
        :rtype: None
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @distributed_trace_async
    async def add_classification(  # pylint: disable=inconsistent-return-statements
        self, request: Union[_models.ClassificationAssociateRequest, JSON, IO[bytes]], **kwargs: Any
    ) -> None:
        """Associate a classification to multiple entities in bulk.

        :param request: The request to associate a classification to multiple entities. Is one of the
         following types: ClassificationAssociateRequest, JSON, IO[bytes] Required.
        :type request: ~azure.purview.datamap.models.ClassificationAssociateRequest or JSON or
         IO[bytes]
        :keyword content_type: Body parameter Content-Type. Known values are: application/json. Default
         value is None.
        :paramtype content_type: str
        :return: None
        :rtype: None
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[None] = kwargs.pop("cls", None)

        content_type = content_type or "application/json"
        _content = None
        if isinstance(request, (IOBase, bytes)):
            _content = request
        else:
            _content = json.dumps(request, cls=SdkJSONEncoder, exclude_readonly=True)  # type: ignore

        _request = build_entity_add_classification_request(
            content_type=content_type,
            api_version=self._config.api_version,
            content=_content,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = False
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [204]:
            if _stream:
                await response.read()  # Load the body in memory and close the socket
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = _deserialize(_models.ErrorResponse, response.json())
            raise HttpResponseError(response=response, model=error)

        if cls:
            return cls(pipeline_response, None, {})  # type: ignore

    @distributed_trace_async
    async def get(
        self,
        guid: str,
        *,
        min_ext_info: Optional[bool] = None,
        ignore_relationships: Optional[bool] = None,
        **kwargs: Any
    ) -> _models.AtlasEntityWithExtInfo:
        """Get complete definition of an entity given its GUID.

        :param guid: The globally unique identifier of the entity. Required.
        :type guid: str
        :keyword min_ext_info: Whether to return minimal information for referred entities. Default
         value is None.
        :paramtype min_ext_info: bool
        :keyword ignore_relationships: Whether to ignore relationship attributes. Default value is
         None.
        :paramtype ignore_relationships: bool
        :keyword bool stream: Whether to stream the response of this operation. Defaults to False. You
         will have to context manage the returned stream.
        :return: AtlasEntityWithExtInfo. The AtlasEntityWithExtInfo is compatible with MutableMapping
        :rtype: ~azure.purview.datamap.models.AtlasEntityWithExtInfo
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[_models.AtlasEntityWithExtInfo] = kwargs.pop("cls", None)

        _request = build_entity_get_request(
            guid=guid,
            min_ext_info=min_ext_info,
            ignore_relationships=ignore_relationships,
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = kwargs.pop("stream", False)
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                await response.read()  # Load the body in memory and close the socket
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = _deserialize(_models.ErrorResponse, response.json())
            raise HttpResponseError(response=response, model=error)

        if _stream:
            deserialized = response.iter_bytes()
        else:
            deserialized = _deserialize(_models.AtlasEntityWithExtInfo, response.json())

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore

    @distributed_trace_async
    async def partial_update_attribute_by_guid(
        self, guid: str, body: Any, *, name: str, **kwargs: Any
    ) -> _models.EntityMutationResponse:
        """Update entity partially - create or update entity attribute identified by its
        GUID.
        Supports only primitive attribute type and entity references.
        It does not
        support updating complex types like arrays, and maps.
        Null updates are not
        possible.

        :param guid: The globally unique identifier of the entity. Required.
        :type guid: str
        :param body: The value of the attribute. Required.
        :type body: any
        :keyword name: The name of the attribute. Required.
        :paramtype name: str
        :keyword content_type: Body parameter Content-Type. Known values are: application/json. Default
         value is "application/json".
        :paramtype content_type: str
        :keyword bool stream: Whether to stream the response of this operation. Defaults to False. You
         will have to context manage the returned stream.
        :return: EntityMutationResponse. The EntityMutationResponse is compatible with MutableMapping
        :rtype: ~azure.purview.datamap.models.EntityMutationResponse
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: str = kwargs.pop("content_type", _headers.pop("Content-Type", "application/json"))
        cls: ClsType[_models.EntityMutationResponse] = kwargs.pop("cls", None)

        _content = json.dumps(body, cls=SdkJSONEncoder, exclude_readonly=True)  # type: ignore

        _request = build_entity_partial_update_attribute_by_guid_request(
            guid=guid,
            name=name,
            content_type=content_type,
            api_version=self._config.api_version,
            content=_content,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = kwargs.pop("stream", False)
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                await response.read()  # Load the body in memory and close the socket
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = _deserialize(_models.ErrorResponse, response.json())
            raise HttpResponseError(response=response, model=error)

        if _stream:
            deserialized = response.iter_bytes()
        else:
            deserialized = _deserialize(_models.EntityMutationResponse, response.json())

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore

    @distributed_trace_async
    async def delete(self, guid: str, **kwargs: Any) -> _models.EntityMutationResponse:
        """Delete an entity identified by its GUID.

        :param guid: The globally unique identifier of the entity. Required.
        :type guid: str
        :keyword bool stream: Whether to stream the response of this operation. Defaults to False. You
         will have to context manage the returned stream.
        :return: EntityMutationResponse. The EntityMutationResponse is compatible with MutableMapping
        :rtype: ~azure.purview.datamap.models.EntityMutationResponse
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[_models.EntityMutationResponse] = kwargs.pop("cls", None)

        _request = build_entity_delete_request(
            guid=guid,
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = kwargs.pop("stream", False)
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                await response.read()  # Load the body in memory and close the socket
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = _deserialize(_models.ErrorResponse, response.json())
            raise HttpResponseError(response=response, model=error)

        if _stream:
            deserialized = response.iter_bytes()
        else:
            deserialized = _deserialize(_models.EntityMutationResponse, response.json())

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore

    @distributed_trace_async
    async def get_classification(
        self, guid: str, classification_name: str, **kwargs: Any
    ) -> _models.AtlasClassification:
        """Get classification for a given entity represented by a GUID.

        :param guid: The globally unique identifier of the entity. Required.
        :type guid: str
        :param classification_name: The name of the classification. Required.
        :type classification_name: str
        :keyword bool stream: Whether to stream the response of this operation. Defaults to False. You
         will have to context manage the returned stream.
        :return: AtlasClassification. The AtlasClassification is compatible with MutableMapping
        :rtype: ~azure.purview.datamap.models.AtlasClassification
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[_models.AtlasClassification] = kwargs.pop("cls", None)

        _request = build_entity_get_classification_request(
            guid=guid,
            classification_name=classification_name,
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = kwargs.pop("stream", False)
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                await response.read()  # Load the body in memory and close the socket
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = _deserialize(_models.ErrorResponse, response.json())
            raise HttpResponseError(response=response, model=error)

        if _stream:
            deserialized = response.iter_bytes()
        else:
            deserialized = _deserialize(_models.AtlasClassification, response.json())

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore

    @distributed_trace_async
    async def remove_classification(  # pylint: disable=inconsistent-return-statements
        self, guid: str, classification_name: str, **kwargs: Any
    ) -> None:
        """Delete a given classification from an existing entity represented by a GUID.

        :param guid: The globally unique identifier of the entity. Required.
        :type guid: str
        :param classification_name: The name of the classification. Required.
        :type classification_name: str
        :return: None
        :rtype: None
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[None] = kwargs.pop("cls", None)

        _request = build_entity_remove_classification_request(
            guid=guid,
            classification_name=classification_name,
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = False
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [204]:
            if _stream:
                await response.read()  # Load the body in memory and close the socket
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = _deserialize(_models.ErrorResponse, response.json())
            raise HttpResponseError(response=response, model=error)

        if cls:
            return cls(pipeline_response, None, {})  # type: ignore

    @distributed_trace_async
    async def get_classifications(self, guid: str, **kwargs: Any) -> _models.AtlasClassifications:
        """List classifications for a given entity represented by a GUID.

        :param guid: The globally unique identifier of the entity. Required.
        :type guid: str
        :keyword bool stream: Whether to stream the response of this operation. Defaults to False. You
         will have to context manage the returned stream.
        :return: AtlasClassifications. The AtlasClassifications is compatible with MutableMapping
        :rtype: ~azure.purview.datamap.models.AtlasClassifications
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[_models.AtlasClassifications] = kwargs.pop("cls", None)

        _request = build_entity_get_classifications_request(
            guid=guid,
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = kwargs.pop("stream", False)
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                await response.read()  # Load the body in memory and close the socket
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = _deserialize(_models.ErrorResponse, response.json())
            raise HttpResponseError(response=response, model=error)

        if _stream:
            deserialized = response.iter_bytes()
        else:
            deserialized = _deserialize(_models.AtlasClassifications, response.json())

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore

    @overload
    async def add_classifications(  # pylint: disable=inconsistent-return-statements
        self,
        guid: str,
        classifications: List[_models.AtlasClassification],
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> None:
        """Add classifications to an existing entity represented by a GUID.

        :param guid: The globally unique identifier of the entity. Required.
        :type guid: str
        :param classifications: An array of classifications to be added. Required.
        :type classifications: list[~azure.purview.datamap.models.AtlasClassification]
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: None
        :rtype: None
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @overload
    async def add_classifications(  # pylint: disable=inconsistent-return-statements
        self, guid: str, classifications: IO[bytes], *, content_type: str = "application/json", **kwargs: Any
    ) -> None:
        """Add classifications to an existing entity represented by a GUID.

        :param guid: The globally unique identifier of the entity. Required.
        :type guid: str
        :param classifications: An array of classifications to be added. Required.
        :type classifications: IO[bytes]
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: None
        :rtype: None
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @distributed_trace_async
    async def add_classifications(  # pylint: disable=inconsistent-return-statements
        self, guid: str, classifications: Union[List[_models.AtlasClassification], IO[bytes]], **kwargs: Any
    ) -> None:
        """Add classifications to an existing entity represented by a GUID.

        :param guid: The globally unique identifier of the entity. Required.
        :type guid: str
        :param classifications: An array of classifications to be added. Is either a
         [AtlasClassification] type or a IO[bytes] type. Required.
        :type classifications: list[~azure.purview.datamap.models.AtlasClassification] or IO[bytes]
        :keyword content_type: Body parameter Content-Type. Known values are: application/json. Default
         value is None.
        :paramtype content_type: str
        :return: None
        :rtype: None
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[None] = kwargs.pop("cls", None)

        content_type = content_type or "application/json"
        _content = None
        if isinstance(classifications, (IOBase, bytes)):
            _content = classifications
        else:
            _content = json.dumps(classifications, cls=SdkJSONEncoder, exclude_readonly=True)  # type: ignore

        _request = build_entity_add_classifications_request(
            guid=guid,
            content_type=content_type,
            api_version=self._config.api_version,
            content=_content,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = False
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [204]:
            if _stream:
                await response.read()  # Load the body in memory and close the socket
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = _deserialize(_models.ErrorResponse, response.json())
            raise HttpResponseError(response=response, model=error)

        if cls:
            return cls(pipeline_response, None, {})  # type: ignore

    @overload
    async def update_classifications(  # pylint: disable=inconsistent-return-statements
        self,
        guid: str,
        classifications: List[_models.AtlasClassification],
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> None:
        """Update classifications to an existing entity represented by a guid.

        :param guid: The globally unique identifier of the entity. Required.
        :type guid: str
        :param classifications: An array of classifications to be updated. Required.
        :type classifications: list[~azure.purview.datamap.models.AtlasClassification]
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: None
        :rtype: None
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @overload
    async def update_classifications(  # pylint: disable=inconsistent-return-statements
        self, guid: str, classifications: IO[bytes], *, content_type: str = "application/json", **kwargs: Any
    ) -> None:
        """Update classifications to an existing entity represented by a guid.

        :param guid: The globally unique identifier of the entity. Required.
        :type guid: str
        :param classifications: An array of classifications to be updated. Required.
        :type classifications: IO[bytes]
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: None
        :rtype: None
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @distributed_trace_async
    async def update_classifications(  # pylint: disable=inconsistent-return-statements
        self, guid: str, classifications: Union[List[_models.AtlasClassification], IO[bytes]], **kwargs: Any
    ) -> None:
        """Update classifications to an existing entity represented by a guid.

        :param guid: The globally unique identifier of the entity. Required.
        :type guid: str
        :param classifications: An array of classifications to be updated. Is either a
         [AtlasClassification] type or a IO[bytes] type. Required.
        :type classifications: list[~azure.purview.datamap.models.AtlasClassification] or IO[bytes]
        :keyword content_type: Body parameter Content-Type. Known values are: application/json. Default
         value is None.
        :paramtype content_type: str
        :return: None
        :rtype: None
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[None] = kwargs.pop("cls", None)

        content_type = content_type or "application/json"
        _content = None
        if isinstance(classifications, (IOBase, bytes)):
            _content = classifications
        else:
            _content = json.dumps(classifications, cls=SdkJSONEncoder, exclude_readonly=True)  # type: ignore

        _request = build_entity_update_classifications_request(
            guid=guid,
            content_type=content_type,
            api_version=self._config.api_version,
            content=_content,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = False
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [204]:
            if _stream:
                await response.read()  # Load the body in memory and close the socket
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = _deserialize(_models.ErrorResponse, response.json())
            raise HttpResponseError(response=response, model=error)

        if cls:
            return cls(pipeline_response, None, {})  # type: ignore

    @distributed_trace_async
    async def get_by_unique_attributes(
        self,
        type_name: str,
        *,
        min_ext_info: Optional[bool] = None,
        ignore_relationships: Optional[bool] = None,
        attr: Optional[str] = None,
        **kwargs: Any
    ) -> _models.AtlasEntityWithExtInfo:
        """Get complete definition of an entity given its type and unique attribute.

        In
        addition to the typeName path parameter, attribute key-value pair(s) can be
        provided in the following format:
        attr:\:code:`<attrName>`=:code:`<attrValue>`.

        NOTE: The
        attrName and attrValue should be unique across entities, eg.
        qualifiedName.

        The REST request would look something like this:
        GET
        /v2/entity/uniqueAttribute/type/aType?attr:aTypeAttribute=someValue.

        :param type_name: The name of the type. Required.
        :type type_name: str
        :keyword min_ext_info: Whether to return minimal information for referred entities. Default
         value is None.
        :paramtype min_ext_info: bool
        :keyword ignore_relationships: Whether to ignore relationship attributes. Default value is
         None.
        :paramtype ignore_relationships: bool
        :keyword attr: The qualified name of the entity. (This is only an example. qualifiedName can
         be changed to other unique attributes). Default value is None.
        :paramtype attr: str
        :keyword bool stream: Whether to stream the response of this operation. Defaults to False. You
         will have to context manage the returned stream.
        :return: AtlasEntityWithExtInfo. The AtlasEntityWithExtInfo is compatible with MutableMapping
        :rtype: ~azure.purview.datamap.models.AtlasEntityWithExtInfo
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[_models.AtlasEntityWithExtInfo] = kwargs.pop("cls", None)

        _request = build_entity_get_by_unique_attributes_request(
            type_name=type_name,
            min_ext_info=min_ext_info,
            ignore_relationships=ignore_relationships,
            attr=attr,
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = kwargs.pop("stream", False)
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                await response.read()  # Load the body in memory and close the socket
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = _deserialize(_models.ErrorResponse, response.json())
            raise HttpResponseError(response=response, model=error)

        if _stream:
            deserialized = response.iter_bytes()
        else:
            deserialized = _deserialize(_models.AtlasEntityWithExtInfo, response.json())

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore

    @overload
    async def partial_update_by_unique_attributes(
        self,
        type_name: str,
        atlas_entity_with_ext_info: _models.AtlasEntityWithExtInfo,
        *,
        attr: Optional[str] = None,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> _models.EntityMutationResponse:
        """Update entity partially - Allow a subset of attributes to be updated on an
        entity which is identified by its type and unique attribute eg:
        Referenceable.qualifiedName. Null updates are not possible.

        In addition to the
        typeName path parameter, attribute key-value pair(s) can be provided in the
        following format:

        attr::code:`<attrName>`=:code:`<attrValue>`.
        NOTE: The attrName and
        attrValue should be unique across entities, eg. qualifiedName.

        The REST
        request would look something like this:
        PUT
        /v2/entity/uniqueAttribute/type/aType?attr:aTypeAttribute=someValue.

        :param type_name: The name of the type. Required.
        :type type_name: str
        :param atlas_entity_with_ext_info: Atlas entity with extended information. Required.
        :type atlas_entity_with_ext_info: ~azure.purview.datamap.models.AtlasEntityWithExtInfo
        :keyword attr: The qualified name of the entity. (This is only an example. qualifiedName can
         be changed to other unique attributes). Default value is None.
        :paramtype attr: str
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :keyword bool stream: Whether to stream the response of this operation. Defaults to False. You
         will have to context manage the returned stream.
        :return: EntityMutationResponse. The EntityMutationResponse is compatible with MutableMapping
        :rtype: ~azure.purview.datamap.models.EntityMutationResponse
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @overload
    async def partial_update_by_unique_attributes(
        self,
        type_name: str,
        atlas_entity_with_ext_info: JSON,
        *,
        attr: Optional[str] = None,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> _models.EntityMutationResponse:
        """Update entity partially - Allow a subset of attributes to be updated on an
        entity which is identified by its type and unique attribute eg:
        Referenceable.qualifiedName. Null updates are not possible.

        In addition to the
        typeName path parameter, attribute key-value pair(s) can be provided in the
        following format:

        attr::code:`<attrName>`=:code:`<attrValue>`.
        NOTE: The attrName and
        attrValue should be unique across entities, eg. qualifiedName.

        The REST
        request would look something like this:
        PUT
        /v2/entity/uniqueAttribute/type/aType?attr:aTypeAttribute=someValue.

        :param type_name: The name of the type. Required.
        :type type_name: str
        :param atlas_entity_with_ext_info: Atlas entity with extended information. Required.
        :type atlas_entity_with_ext_info: JSON
        :keyword attr: The qualified name of the entity. (This is only an example. qualifiedName can
         be changed to other unique attributes). Default value is None.
        :paramtype attr: str
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :keyword bool stream: Whether to stream the response of this operation. Defaults to False. You
         will have to context manage the returned stream.
        :return: EntityMutationResponse. The EntityMutationResponse is compatible with MutableMapping
        :rtype: ~azure.purview.datamap.models.EntityMutationResponse
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @overload
    async def partial_update_by_unique_attributes(
        self,
        type_name: str,
        atlas_entity_with_ext_info: IO[bytes],
        *,
        attr: Optional[str] = None,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> _models.EntityMutationResponse:
        """Update entity partially - Allow a subset of attributes to be updated on an
        entity which is identified by its type and unique attribute eg:
        Referenceable.qualifiedName. Null updates are not possible.

        In addition to the
        typeName path parameter, attribute key-value pair(s) can be provided in the
        following format:

        attr::code:`<attrName>`=:code:`<attrValue>`.
        NOTE: The attrName and
        attrValue should be unique across entities, eg. qualifiedName.

        The REST
        request would look something like this:
        PUT
        /v2/entity/uniqueAttribute/type/aType?attr:aTypeAttribute=someValue.

        :param type_name: The name of the type. Required.
        :type type_name: str
        :param atlas_entity_with_ext_info: Atlas entity with extended information. Required.
        :type atlas_entity_with_ext_info: IO[bytes]
        :keyword attr: The qualified name of the entity. (This is only an example. qualifiedName can
         be changed to other unique attributes). Default value is None.
        :paramtype attr: str
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Default value is "application/json".
        :paramtype content_type: str
        :keyword bool stream: Whether to stream the response of this operation. Defaults to False. You
         will have to context manage the returned stream.
        :return: EntityMutationResponse. The EntityMutationResponse is compatible with MutableMapping
        :rtype: ~azure.purview.datamap.models.EntityMutationResponse
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @distributed_trace_async
    async def partial_update_by_unique_attributes(
        self,
        type_name: str,
        atlas_entity_with_ext_info: Union[_models.AtlasEntityWithExtInfo, JSON, IO[bytes]],
        *,
        attr: Optional[str] = None,
        **kwargs: Any
    ) -> _models.EntityMutationResponse:
        """Update entity partially - Allow a subset of attributes to be updated on an
        entity which is identified by its type and unique attribute eg:
        Referenceable.qualifiedName. Null updates are not possible.

        In addition to the
        typeName path parameter, attribute key-value pair(s) can be provided in the
        following format:

        attr::code:`<attrName>`=:code:`<attrValue>`.
        NOTE: The attrName and
        attrValue should be unique across entities, eg. qualifiedName.

        The REST
        request would look something like this:
        PUT
        /v2/entity/uniqueAttribute/type/aType?attr:aTypeAttribute=someValue.

        :param type_name: The name of the type. Required.
        :type type_name: str
        :param atlas_entity_with_ext_info: Atlas entity with extended information. Is one of the
         following types: AtlasEntityWithExtInfo, JSON, IO[bytes] Required.
        :type atlas_entity_with_ext_info: ~azure.purview.datamap.models.AtlasEntityWithExtInfo or JSON
         or IO[bytes]
        :keyword attr: The qualified name of the entity. (This is only an example. qualifiedName can
         be changed to other unique attributes). Default value is None.
        :paramtype attr: str
        :keyword content_type: Body parameter Content-Type. Known values are: application/json. Default
         value is None.
        :paramtype content_type: str
        :keyword bool stream: Whether to stream the response of this operation. Defaults to False. You
         will have to context manage the returned stream.
        :return: EntityMutationResponse. The EntityMutationResponse is compatible with MutableMapping
        :rtype: ~azure.purview.datamap.models.EntityMutationResponse
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[_models.EntityMutationResponse] = kwargs.pop("cls", None)

        content_type = content_type or "application/json"
        _content = None
        if isinstance(atlas_entity_with_ext_info, (IOBase, bytes)):
            _content = atlas_entity_with_ext_info
        else:
            _content = json.dumps(atlas_entity_with_ext_info, cls=SdkJSONEncoder, exclude_readonly=True)  # type: ignore

        _request = build_entity_partial_update_by_unique_attributes_request(
            type_name=type_name,
            attr=attr,
            content_type=content_type,
            api_version=self._config.api_version,
            content=_content,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = kwargs.pop("stream", False)
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                await response.read()  # Load the body in memory and close the socket
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = _deserialize(_models.ErrorResponse, response.json())
            raise HttpResponseError(response=response, model=error)

        if _stream:
            deserialized = response.iter_bytes()
        else:
            deserialized = _deserialize(_models.EntityMutationResponse, response.json())

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore

    @distributed_trace_async
    async def delete_by_unique_attribute(
        self, type_name: str, *, attr: Optional[str] = None, **kwargs: Any
    ) -> _models.EntityMutationResponse:
        """Delete an entity identified by its type and unique attributes.
        In addition to
        the typeName path parameter, attribute key-value pair(s) can be provided in the
        following format:
        attr:\:code:`<attrName>`=\:code:`<attrValue>`.
        NOTE: The attrName and
        attrValue should be unique across entities, eg. qualifiedName.

        The REST
        request would look something like this:
        DELETE
        /v2/entity/uniqueAttribute/type/aType?attr:aTypeAttribute=someValue.

        :param type_name: The name of the type. Required.
        :type type_name: str
        :keyword attr: The qualified name of the entity. (This is only an example. qualifiedName can
         be changed to other unique attributes). Default value is None.
        :paramtype attr: str
        :keyword bool stream: Whether to stream the response of this operation. Defaults to False. You
         will have to context manage the returned stream.
        :return: EntityMutationResponse. The EntityMutationResponse is compatible with MutableMapping
        :rtype: ~azure.purview.datamap.models.EntityMutationResponse
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[_models.EntityMutationResponse] = kwargs.pop("cls", None)

        _request = build_entity_delete_by_unique_attribute_request(
            type_name=type_name,
            attr=attr,
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = kwargs.pop("stream", False)
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                await response.read()  # Load the body in memory and close the socket
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = _deserialize(_models.ErrorResponse, response.json())
            raise HttpResponseError(response=response, model=error)

        if _stream:
            deserialized = response.iter_bytes()
        else:
            deserialized = _deserialize(_models.EntityMutationResponse, response.json())

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore

    @distributed_trace_async
    async def remove_classification_by_unique_attribute(  # pylint: disable=inconsistent-return-statements,name-too-long
        self, type_name: str, classification_name: str, *, attr: Optional[str] = None, **kwargs: Any
    ) -> None:
        """Delete a given classification from an entity identified by its type and unique
        attributes.

        :param type_name: The name of the type. Required.
        :type type_name: str
        :param classification_name: The name of the classification. Required.
        :type classification_name: str
        :keyword attr: The qualified name of the entity. (This is only an example. qualifiedName can
         be changed to other unique attributes). Default value is None.
        :paramtype attr: str
        :return: None
        :rtype: None
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[None] = kwargs.pop("cls", None)

        _request = build_entity_remove_classification_by_unique_attribute_request(
            type_name=type_name,
            classification_name=classification_name,
            attr=attr,
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = False
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [204]:
            if _stream:
                await response.read()  # Load the body in memory and close the socket
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = _deserialize(_models.ErrorResponse, response.json())
            raise HttpResponseError(response=response, model=error)

        if cls:
            return cls(pipeline_response, None, {})  # type: ignore

    @overload
    async def add_classifications_by_unique_attribute(  # pylint: disable=inconsistent-return-statements
        self,
        type_name: str,
        atlas_classification_array: List[_models.AtlasClassification],
        *,
        attr: Optional[str] = None,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> None:
        """Add classification to the entity identified by its type and unique attributes.

        :param type_name: The name of the type. Required.
        :type type_name: str
        :param atlas_classification_array: An array of classification to be added. Required.
        :type atlas_classification_array: list[~azure.purview.datamap.models.AtlasClassification]
        :keyword attr: The qualified name of the entity. (This is only an example. qualifiedName can
         be changed to other unique attributes). Default value is None.
        :paramtype attr: str
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: None
        :rtype: None
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @overload
    async def add_classifications_by_unique_attribute(  # pylint: disable=inconsistent-return-statements
        self,
        type_name: str,
        atlas_classification_array: IO[bytes],
        *,
        attr: Optional[str] = None,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> None:
        """Add classification to the entity identified by its type and unique attributes.

        :param type_name: The name of the type. Required.
        :type type_name: str
        :param atlas_classification_array: An array of classification to be added. Required.
        :type atlas_classification_array: IO[bytes]
        :keyword attr: The qualified name of the entity. (This is only an example. qualifiedName can
         be changed to other unique attributes). Default value is None.
        :paramtype attr: str
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: None
        :rtype: None
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @distributed_trace_async
    async def add_classifications_by_unique_attribute(  # pylint: disable=inconsistent-return-statements
        self,
        type_name: str,
        atlas_classification_array: Union[List[_models.AtlasClassification], IO[bytes]],
        *,
        attr: Optional[str] = None,
        **kwargs: Any
    ) -> None:
        """Add classification to the entity identified by its type and unique attributes.

        :param type_name: The name of the type. Required.
        :type type_name: str
        :param atlas_classification_array: An array of classification to be added. Is either a
         [AtlasClassification] type or a IO[bytes] type. Required.
        :type atlas_classification_array: list[~azure.purview.datamap.models.AtlasClassification] or
         IO[bytes]
        :keyword attr: The qualified name of the entity. (This is only an example. qualifiedName can
         be changed to other unique attributes). Default value is None.
        :paramtype attr: str
        :keyword content_type: Body parameter Content-Type. Known values are: application/json. Default
         value is None.
        :paramtype content_type: str
        :return: None
        :rtype: None
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[None] = kwargs.pop("cls", None)

        content_type = content_type or "application/json"
        _content = None
        if isinstance(atlas_classification_array, (IOBase, bytes)):
            _content = atlas_classification_array
        else:
            _content = json.dumps(atlas_classification_array, cls=SdkJSONEncoder, exclude_readonly=True)  # type: ignore

        _request = build_entity_add_classifications_by_unique_attribute_request(
            type_name=type_name,
            attr=attr,
            content_type=content_type,
            api_version=self._config.api_version,
            content=_content,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = False
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [204]:
            if _stream:
                await response.read()  # Load the body in memory and close the socket
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = _deserialize(_models.ErrorResponse, response.json())
            raise HttpResponseError(response=response, model=error)

        if cls:
            return cls(pipeline_response, None, {})  # type: ignore

    @overload
    async def update_classifications_by_unique_attribute(  # pylint: disable=inconsistent-return-statements,name-too-long
        self,
        type_name: str,
        atlas_classification_array: List[_models.AtlasClassification],
        *,
        attr: Optional[str] = None,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> None:
        """Update classification on an entity identified by its type and unique attributes.

        :param type_name: The name of the type. Required.
        :type type_name: str
        :param atlas_classification_array: An array of classification to be updated. Required.
        :type atlas_classification_array: list[~azure.purview.datamap.models.AtlasClassification]
        :keyword attr: The qualified name of the entity. (This is only an example. qualifiedName can
         be changed to other unique attributes). Default value is None.
        :paramtype attr: str
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: None
        :rtype: None
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @overload
    async def update_classifications_by_unique_attribute(  # pylint: disable=inconsistent-return-statements,name-too-long
        self,
        type_name: str,
        atlas_classification_array: IO[bytes],
        *,
        attr: Optional[str] = None,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> None:
        """Update classification on an entity identified by its type and unique attributes.

        :param type_name: The name of the type. Required.
        :type type_name: str
        :param atlas_classification_array: An array of classification to be updated. Required.
        :type atlas_classification_array: IO[bytes]
        :keyword attr: The qualified name of the entity. (This is only an example. qualifiedName can
         be changed to other unique attributes). Default value is None.
        :paramtype attr: str
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: None
        :rtype: None
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @distributed_trace_async
    async def update_classifications_by_unique_attribute(  # pylint: disable=inconsistent-return-statements,name-too-long
        self,
        type_name: str,
        atlas_classification_array: Union[List[_models.AtlasClassification], IO[bytes]],
        *,
        attr: Optional[str] = None,
        **kwargs: Any
    ) -> None:
        """Update classification on an entity identified by its type and unique attributes.

        :param type_name: The name of the type. Required.
        :type type_name: str
        :param atlas_classification_array: An array of classification to be updated. Is either a
         [AtlasClassification] type or a IO[bytes] type. Required.
        :type atlas_classification_array: list[~azure.purview.datamap.models.AtlasClassification] or
         IO[bytes]
        :keyword attr: The qualified name of the entity. (This is only an example. qualifiedName can
         be changed to other unique attributes). Default value is None.
        :paramtype attr: str
        :keyword content_type: Body parameter Content-Type. Known values are: application/json. Default
         value is None.
        :paramtype content_type: str
        :return: None
        :rtype: None
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[None] = kwargs.pop("cls", None)

        content_type = content_type or "application/json"
        _content = None
        if isinstance(atlas_classification_array, (IOBase, bytes)):
            _content = atlas_classification_array
        else:
            _content = json.dumps(atlas_classification_array, cls=SdkJSONEncoder, exclude_readonly=True)  # type: ignore

        _request = build_entity_update_classifications_by_unique_attribute_request(
            type_name=type_name,
            attr=attr,
            content_type=content_type,
            api_version=self._config.api_version,
            content=_content,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = False
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [204]:
            if _stream:
                await response.read()  # Load the body in memory and close the socket
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = _deserialize(_models.ErrorResponse, response.json())
            raise HttpResponseError(response=response, model=error)

        if cls:
            return cls(pipeline_response, None, {})  # type: ignore

    @overload
    async def bulk_set_classifications(
        self, entity_headers: _models.AtlasEntityHeaders, *, content_type: str = "application/json", **kwargs: Any
    ) -> List[str]:
        """Set classifications on entities in bulk.

        :param entity_headers: Atlas entity headers. Required.
        :type entity_headers: ~azure.purview.datamap.models.AtlasEntityHeaders
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :keyword bool stream: Whether to stream the response of this operation. Defaults to False. You
         will have to context manage the returned stream.
        :return: list of str
        :rtype: list[str]
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @overload
    async def bulk_set_classifications(
        self, entity_headers: JSON, *, content_type: str = "application/json", **kwargs: Any
    ) -> List[str]:
        """Set classifications on entities in bulk.

        :param entity_headers: Atlas entity headers. Required.
        :type entity_headers: JSON
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :keyword bool stream: Whether to stream the response of this operation. Defaults to False. You
         will have to context manage the returned stream.
        :return: list of str
        :rtype: list[str]
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @overload
    async def bulk_set_classifications(
        self, entity_headers: IO[bytes], *, content_type: str = "application/json", **kwargs: Any
    ) -> List[str]:
        """Set classifications on entities in bulk.

        :param entity_headers: Atlas entity headers. Required.
        :type entity_headers: IO[bytes]
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Default value is "application/json".
        :paramtype content_type: str
        :keyword bool stream: Whether to stream the response of this operation. Defaults to False. You
         will have to context manage the returned stream.
        :return: list of str
        :rtype: list[str]
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @distributed_trace_async
    async def bulk_set_classifications(
        self, entity_headers: Union[_models.AtlasEntityHeaders, JSON, IO[bytes]], **kwargs: Any
    ) -> List[str]:
        """Set classifications on entities in bulk.

        :param entity_headers: Atlas entity headers. Is one of the following types: AtlasEntityHeaders,
         JSON, IO[bytes] Required.
        :type entity_headers: ~azure.purview.datamap.models.AtlasEntityHeaders or JSON or IO[bytes]
        :keyword content_type: Body parameter Content-Type. Known values are: application/json. Default
         value is None.
        :paramtype content_type: str
        :keyword bool stream: Whether to stream the response of this operation. Defaults to False. You
         will have to context manage the returned stream.
        :return: list of str
        :rtype: list[str]
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[List[str]] = kwargs.pop("cls", None)

        content_type = content_type or "application/json"
        _content = None
        if isinstance(entity_headers, (IOBase, bytes)):
            _content = entity_headers
        else:
            _content = json.dumps(entity_headers, cls=SdkJSONEncoder, exclude_readonly=True)  # type: ignore

        _request = build_entity_bulk_set_classifications_request(
            content_type=content_type,
            api_version=self._config.api_version,
            content=_content,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = kwargs.pop("stream", False)
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                await response.read()  # Load the body in memory and close the socket
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = _deserialize(_models.ErrorResponse, response.json())
            raise HttpResponseError(response=response, model=error)

        if _stream:
            deserialized = response.iter_bytes()
        else:
            deserialized = _deserialize(List[str], response.json())

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore

    @distributed_trace_async
    async def list_by_unique_attributes(
        self,
        type_name: str,
        *,
        min_ext_info: Optional[bool] = None,
        ignore_relationships: Optional[bool] = None,
        attr_n_qualified_name: Optional[str] = None,
        **kwargs: Any
    ) -> _models.AtlasEntitiesWithExtInfo:
        """Bulk API to retrieve list of entities identified by its unique attributes.
        In
        addition to the typeName path parameter, attribute key-value pair(s) can be
        provided in the following
        format

        typeName=\:code:`<typeName>`&attr_1:\:code:`<attrName>`=\:code:`<attrValue>`&attr_2:\:code:`<attrName>`=\:code:`<attrValue>`&attr_3:\:code:`<attrName>`=\:code:`<attrValue>`

        NOTE:
        The attrName should be an unique attribute for the given entity-type.
        The REST
        request would look something like this

        GET
        /v2/entity/bulk/uniqueAttribute/type/hive_db?attr_1:qualifiedName=db1@cl1&attr_2:qualifiedName=db2@cl1

        Note:
        at least one unique attribute must be provided.

        :param type_name: The name of the type. Required.
        :type type_name: str
        :keyword min_ext_info: Whether to return minimal information for referred entities. Default
         value is None.
        :paramtype min_ext_info: bool
        :keyword ignore_relationships: Whether to ignore relationship attributes. Default value is
         None.
        :paramtype ignore_relationships: bool
        :keyword attr_n_qualified_name: Qualified name of an entity. E.g. to find 2 entities you can
         set
         attrs_1:qualifiedName=db1@cl1&attrs_2:qualifiedName=db2@cl1. (This is only an
         example. qualifiedName can be changed to other unique attributes). Default value is None.
        :paramtype attr_n_qualified_name: str
        :keyword bool stream: Whether to stream the response of this operation. Defaults to False. You
         will have to context manage the returned stream.
        :return: AtlasEntitiesWithExtInfo. The AtlasEntitiesWithExtInfo is compatible with
         MutableMapping
        :rtype: ~azure.purview.datamap.models.AtlasEntitiesWithExtInfo
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[_models.AtlasEntitiesWithExtInfo] = kwargs.pop("cls", None)

        _request = build_entity_list_by_unique_attributes_request(
            type_name=type_name,
            min_ext_info=min_ext_info,
            ignore_relationships=ignore_relationships,
            attr_n_qualified_name=attr_n_qualified_name,
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = kwargs.pop("stream", False)
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                await response.read()  # Load the body in memory and close the socket
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = _deserialize(_models.ErrorResponse, response.json())
            raise HttpResponseError(response=response, model=error)

        if _stream:
            deserialized = response.iter_bytes()
        else:
            deserialized = _deserialize(_models.AtlasEntitiesWithExtInfo, response.json())

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore

    @distributed_trace_async
    async def get_header(self, guid: str, **kwargs: Any) -> _models.AtlasEntityHeader:
        """Get entity header given its GUID.

        :param guid: The globally unique identifier of the entity. Required.
        :type guid: str
        :keyword bool stream: Whether to stream the response of this operation. Defaults to False. You
         will have to context manage the returned stream.
        :return: AtlasEntityHeader. The AtlasEntityHeader is compatible with MutableMapping
        :rtype: ~azure.purview.datamap.models.AtlasEntityHeader
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[_models.AtlasEntityHeader] = kwargs.pop("cls", None)

        _request = build_entity_get_header_request(
            guid=guid,
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = kwargs.pop("stream", False)
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                await response.read()  # Load the body in memory and close the socket
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = _deserialize(_models.ErrorResponse, response.json())
            raise HttpResponseError(response=response, model=error)

        if _stream:
            deserialized = response.iter_bytes()
        else:
            deserialized = _deserialize(_models.AtlasEntityHeader, response.json())

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore

    @overload
    async def remove_business_metadata(  # pylint: disable=inconsistent-return-statements
        self,
        guid: str,
        business_metadata: Dict[str, Dict[str, Any]],
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> None:
        """Remove business metadata from an entity.

        :param guid: The globally unique identifier of the entity. Required.
        :type guid: str
        :param business_metadata: Business metadata payload. Required.
        :type business_metadata: dict[str, dict[str, any]]
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: None
        :rtype: None
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @overload
    async def remove_business_metadata(  # pylint: disable=inconsistent-return-statements
        self, guid: str, business_metadata: IO[bytes], *, content_type: str = "application/json", **kwargs: Any
    ) -> None:
        """Remove business metadata from an entity.

        :param guid: The globally unique identifier of the entity. Required.
        :type guid: str
        :param business_metadata: Business metadata payload. Required.
        :type business_metadata: IO[bytes]
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: None
        :rtype: None
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @distributed_trace_async
    async def remove_business_metadata(  # pylint: disable=inconsistent-return-statements
        self, guid: str, business_metadata: Union[Dict[str, Dict[str, Any]], IO[bytes]], **kwargs: Any
    ) -> None:
        """Remove business metadata from an entity.

        :param guid: The globally unique identifier of the entity. Required.
        :type guid: str
        :param business_metadata: Business metadata payload. Is either a {str: {str: Any}} type or a
         IO[bytes] type. Required.
        :type business_metadata: dict[str, dict[str, any]] or IO[bytes]
        :keyword content_type: Body parameter Content-Type. Known values are: application/json. Default
         value is None.
        :paramtype content_type: str
        :return: None
        :rtype: None
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[None] = kwargs.pop("cls", None)

        content_type = content_type or "application/json"
        _content = None
        if isinstance(business_metadata, (IOBase, bytes)):
            _content = business_metadata
        else:
            _content = json.dumps(business_metadata, cls=SdkJSONEncoder, exclude_readonly=True)  # type: ignore

        _request = build_entity_remove_business_metadata_request(
            guid=guid,
            content_type=content_type,
            api_version=self._config.api_version,
            content=_content,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = False
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [204]:
            if _stream:
                await response.read()  # Load the body in memory and close the socket
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = _deserialize(_models.ErrorResponse, response.json())
            raise HttpResponseError(response=response, model=error)

        if cls:
            return cls(pipeline_response, None, {})  # type: ignore

    @overload
    async def add_or_update_business_metadata(  # pylint: disable=inconsistent-return-statements
        self,
        guid: str,
        business_metadata: Dict[str, Dict[str, Any]],
        *,
        is_overwrite: Optional[bool] = None,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> None:
        """Add business metadata to an entity.

        :param guid: The globally unique identifier of the entity. Required.
        :type guid: str
        :param business_metadata: BusinessMetadata payload. Required.
        :type business_metadata: dict[str, dict[str, any]]
        :keyword is_overwrite: Whether to overwrite the existing business metadata on the entity or
         not,
         default is false. Default value is None.
        :paramtype is_overwrite: bool
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: None
        :rtype: None
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @overload
    async def add_or_update_business_metadata(  # pylint: disable=inconsistent-return-statements
        self,
        guid: str,
        business_metadata: IO[bytes],
        *,
        is_overwrite: Optional[bool] = None,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> None:
        """Add business metadata to an entity.

        :param guid: The globally unique identifier of the entity. Required.
        :type guid: str
        :param business_metadata: BusinessMetadata payload. Required.
        :type business_metadata: IO[bytes]
        :keyword is_overwrite: Whether to overwrite the existing business metadata on the entity or
         not,
         default is false. Default value is None.
        :paramtype is_overwrite: bool
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: None
        :rtype: None
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @distributed_trace_async
    async def add_or_update_business_metadata(  # pylint: disable=inconsistent-return-statements
        self,
        guid: str,
        business_metadata: Union[Dict[str, Dict[str, Any]], IO[bytes]],
        *,
        is_overwrite: Optional[bool] = None,
        **kwargs: Any
    ) -> None:
        """Add business metadata to an entity.

        :param guid: The globally unique identifier of the entity. Required.
        :type guid: str
        :param business_metadata: BusinessMetadata payload. Is either a {str: {str: Any}} type or a
         IO[bytes] type. Required.
        :type business_metadata: dict[str, dict[str, any]] or IO[bytes]
        :keyword is_overwrite: Whether to overwrite the existing business metadata on the entity or
         not,
         default is false. Default value is None.
        :paramtype is_overwrite: bool
        :keyword content_type: Body parameter Content-Type. Known values are: application/json. Default
         value is None.
        :paramtype content_type: str
        :return: None
        :rtype: None
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[None] = kwargs.pop("cls", None)

        content_type = content_type or "application/json"
        _content = None
        if isinstance(business_metadata, (IOBase, bytes)):
            _content = business_metadata
        else:
            _content = json.dumps(business_metadata, cls=SdkJSONEncoder, exclude_readonly=True)  # type: ignore

        _request = build_entity_add_or_update_business_metadata_request(
            guid=guid,
            is_overwrite=is_overwrite,
            content_type=content_type,
            api_version=self._config.api_version,
            content=_content,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = False
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [204]:
            if _stream:
                await response.read()  # Load the body in memory and close the socket
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = _deserialize(_models.ErrorResponse, response.json())
            raise HttpResponseError(response=response, model=error)

        if cls:
            return cls(pipeline_response, None, {})  # type: ignore

    @overload
    async def remove_business_metadata_attributes(  # pylint: disable=inconsistent-return-statements
        self,
        bm_name: str,
        guid: str,
        business_metadata_attributes: Dict[str, Any],
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> None:
        """Delete business metadata attributes from an entity.

        :param bm_name: BusinessMetadata name. Required.
        :type bm_name: str
        :param guid: The globally unique identifier of the entity. Required.
        :type guid: str
        :param business_metadata_attributes: Business metadata attribute payload. Required.
        :type business_metadata_attributes: dict[str, any]
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: None
        :rtype: None
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @overload
    async def remove_business_metadata_attributes(  # pylint: disable=inconsistent-return-statements
        self,
        bm_name: str,
        guid: str,
        business_metadata_attributes: IO[bytes],
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> None:
        """Delete business metadata attributes from an entity.

        :param bm_name: BusinessMetadata name. Required.
        :type bm_name: str
        :param guid: The globally unique identifier of the entity. Required.
        :type guid: str
        :param business_metadata_attributes: Business metadata attribute payload. Required.
        :type business_metadata_attributes: IO[bytes]
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: None
        :rtype: None
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @distributed_trace_async
    async def remove_business_metadata_attributes(  # pylint: disable=inconsistent-return-statements
        self, bm_name: str, guid: str, business_metadata_attributes: Union[Dict[str, Any], IO[bytes]], **kwargs: Any
    ) -> None:
        """Delete business metadata attributes from an entity.

        :param bm_name: BusinessMetadata name. Required.
        :type bm_name: str
        :param guid: The globally unique identifier of the entity. Required.
        :type guid: str
        :param business_metadata_attributes: Business metadata attribute payload. Is either a {str:
         Any} type or a IO[bytes] type. Required.
        :type business_metadata_attributes: dict[str, any] or IO[bytes]
        :keyword content_type: Body parameter Content-Type. Known values are: application/json. Default
         value is None.
        :paramtype content_type: str
        :return: None
        :rtype: None
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[None] = kwargs.pop("cls", None)

        content_type = content_type or "application/json"
        _content = None
        if isinstance(business_metadata_attributes, (IOBase, bytes)):
            _content = business_metadata_attributes
        else:
            _content = json.dumps(business_metadata_attributes, cls=SdkJSONEncoder, exclude_readonly=True)  # type: ignore

        _request = build_entity_remove_business_metadata_attributes_request(
            bm_name=bm_name,
            guid=guid,
            content_type=content_type,
            api_version=self._config.api_version,
            content=_content,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = False
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [204]:
            if _stream:
                await response.read()  # Load the body in memory and close the socket
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = _deserialize(_models.ErrorResponse, response.json())
            raise HttpResponseError(response=response, model=error)

        if cls:
            return cls(pipeline_response, None, {})  # type: ignore

    @overload
    async def add_or_update_business_metadata_attributes(  # pylint: disable=inconsistent-return-statements,name-too-long
        self,
        bm_name: str,
        guid: str,
        business_metadata_attributes: Dict[str, Any],
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> None:
        """Add or update business metadata attributes.

        :param bm_name: BusinessMetadata name. Required.
        :type bm_name: str
        :param guid: The globally unique identifier of the entity. Required.
        :type guid: str
        :param business_metadata_attributes: Business metadata attribute payload. Required.
        :type business_metadata_attributes: dict[str, any]
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: None
        :rtype: None
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @overload
    async def add_or_update_business_metadata_attributes(  # pylint: disable=inconsistent-return-statements,name-too-long
        self,
        bm_name: str,
        guid: str,
        business_metadata_attributes: IO[bytes],
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> None:
        """Add or update business metadata attributes.

        :param bm_name: BusinessMetadata name. Required.
        :type bm_name: str
        :param guid: The globally unique identifier of the entity. Required.
        :type guid: str
        :param business_metadata_attributes: Business metadata attribute payload. Required.
        :type business_metadata_attributes: IO[bytes]
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: None
        :rtype: None
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @distributed_trace_async
    async def add_or_update_business_metadata_attributes(  # pylint: disable=inconsistent-return-statements,name-too-long
        self, bm_name: str, guid: str, business_metadata_attributes: Union[Dict[str, Any], IO[bytes]], **kwargs: Any
    ) -> None:
        """Add or update business metadata attributes.

        :param bm_name: BusinessMetadata name. Required.
        :type bm_name: str
        :param guid: The globally unique identifier of the entity. Required.
        :type guid: str
        :param business_metadata_attributes: Business metadata attribute payload. Is either a {str:
         Any} type or a IO[bytes] type. Required.
        :type business_metadata_attributes: dict[str, any] or IO[bytes]
        :keyword content_type: Body parameter Content-Type. Known values are: application/json. Default
         value is None.
        :paramtype content_type: str
        :return: None
        :rtype: None
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[None] = kwargs.pop("cls", None)

        content_type = content_type or "application/json"
        _content = None
        if isinstance(business_metadata_attributes, (IOBase, bytes)):
            _content = business_metadata_attributes
        else:
            _content = json.dumps(business_metadata_attributes, cls=SdkJSONEncoder, exclude_readonly=True)  # type: ignore

        _request = build_entity_add_or_update_business_metadata_attributes_request(
            bm_name=bm_name,
            guid=guid,
            content_type=content_type,
            api_version=self._config.api_version,
            content=_content,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = False
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [204]:
            if _stream:
                await response.read()  # Load the body in memory and close the socket
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = _deserialize(_models.ErrorResponse, response.json())
            raise HttpResponseError(response=response, model=error)

        if cls:
            return cls(pipeline_response, None, {})  # type: ignore

    @distributed_trace_async
    async def get_sample_business_metadata_template(self, **kwargs: Any) -> bytes:
        """Get the sample Template for uploading/creating bulk BusinessMetaData.

        :keyword bool stream: Whether to stream the response of this operation. Defaults to False. You
         will have to context manage the returned stream.
        :return: bytes
        :rtype: bytes
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[bytes] = kwargs.pop("cls", None)

        _request = build_entity_get_sample_business_metadata_template_request(
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = kwargs.pop("stream", True)
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                await response.read()  # Load the body in memory and close the socket
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        await response.read()
        deserialized = response.content

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore

    @distributed_trace_async
    async def import_business_metadata(
        self, body: JSON = _Unset, *, uploaded_input_stream: bytes = _Unset, **kwargs: Any
    ) -> _models.BulkImportResponse:
        """Upload the file for creating Business Metadata in BULK.

        :param body: Required.
        :type body: JSON
        :keyword uploaded_input_stream: InputStream of file. Required.
        :paramtype uploaded_input_stream: bytes
        :keyword content_type: The content type for the operation. Always multipart/form-data for this
         operation. Default value is "multipart/form-data".
        :paramtype content_type: str
        :keyword bool stream: Whether to stream the response of this operation. Defaults to False. You
         will have to context manage the returned stream.
        :return: BulkImportResponse. The BulkImportResponse is compatible with MutableMapping
        :rtype: ~azure.purview.datamap.models.BulkImportResponse
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                body = {
                    "uploadedInputStream": bytes("bytes", encoding="utf-8")  # InputStream of
                      file. Required.
                }
        """
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: str = kwargs.pop("content_type", _headers.pop("content-type", "multipart/form-data"))
        cls: ClsType[_models.BulkImportResponse] = kwargs.pop("cls", None)

        if body is _Unset:
            if uploaded_input_stream is _Unset:
                raise TypeError("missing required argument: uploaded_input_stream")
            body = {"uploadedinputstream": uploaded_input_stream}
            body = {k: v for k, v in body.items() if v is not None}
        _content = json.dumps(body, cls=SdkJSONEncoder, exclude_readonly=True)  # type: ignore

        _request = build_entity_import_business_metadata_request(
            content_type=content_type,
            api_version=self._config.api_version,
            content=_content,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = kwargs.pop("stream", False)
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                await response.read()  # Load the body in memory and close the socket
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = _deserialize(_models.ErrorResponse, response.json())
            raise HttpResponseError(response=response, model=error)

        if _stream:
            deserialized = response.iter_bytes()
        else:
            deserialized = _deserialize(_models.BulkImportResponse, response.json())

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore

    @overload
    async def remove_labels(  # pylint: disable=inconsistent-return-statements
        self, guid: str, body: List[str], *, content_type: str = "application/json", **kwargs: Any
    ) -> None:
        """Delete given labels to a given entity.

        :param guid: The globally unique identifier of the entity. Required.
        :type guid: str
        :param body: set of labels to be deleted. Required.
        :type body: list[str]
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: None
        :rtype: None
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @overload
    async def remove_labels(  # pylint: disable=inconsistent-return-statements
        self, guid: str, body: IO[bytes], *, content_type: str = "application/json", **kwargs: Any
    ) -> None:
        """Delete given labels to a given entity.

        :param guid: The globally unique identifier of the entity. Required.
        :type guid: str
        :param body: set of labels to be deleted. Required.
        :type body: IO[bytes]
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: None
        :rtype: None
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @distributed_trace_async
    async def remove_labels(  # pylint: disable=inconsistent-return-statements
        self, guid: str, body: Union[List[str], IO[bytes]], **kwargs: Any
    ) -> None:
        """Delete given labels to a given entity.

        :param guid: The globally unique identifier of the entity. Required.
        :type guid: str
        :param body: set of labels to be deleted. Is either a [str] type or a IO[bytes] type. Required.
        :type body: list[str] or IO[bytes]
        :keyword content_type: Body parameter Content-Type. Known values are: application/json. Default
         value is None.
        :paramtype content_type: str
        :return: None
        :rtype: None
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[None] = kwargs.pop("cls", None)

        content_type = content_type or "application/json"
        _content = None
        if isinstance(body, (IOBase, bytes)):
            _content = body
        else:
            _content = json.dumps(body, cls=SdkJSONEncoder, exclude_readonly=True)  # type: ignore

        _request = build_entity_remove_labels_request(
            guid=guid,
            content_type=content_type,
            api_version=self._config.api_version,
            content=_content,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = False
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [204]:
            if _stream:
                await response.read()  # Load the body in memory and close the socket
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = _deserialize(_models.ErrorResponse, response.json())
            raise HttpResponseError(response=response, model=error)

        if cls:
            return cls(pipeline_response, None, {})  # type: ignore

    @overload
    async def set_labels(  # pylint: disable=inconsistent-return-statements
        self, guid: str, body: List[str], *, content_type: str = "application/json", **kwargs: Any
    ) -> None:
        """Set labels to a given entity.

        :param guid: The globally unique identifier of the entity. Required.
        :type guid: str
        :param body: set of labels to be set to the entity. Required.
        :type body: list[str]
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: None
        :rtype: None
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @overload
    async def set_labels(  # pylint: disable=inconsistent-return-statements
        self, guid: str, body: IO[bytes], *, content_type: str = "application/json", **kwargs: Any
    ) -> None:
        """Set labels to a given entity.

        :param guid: The globally unique identifier of the entity. Required.
        :type guid: str
        :param body: set of labels to be set to the entity. Required.
        :type body: IO[bytes]
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: None
        :rtype: None
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @distributed_trace_async
    async def set_labels(  # pylint: disable=inconsistent-return-statements
        self, guid: str, body: Union[List[str], IO[bytes]], **kwargs: Any
    ) -> None:
        """Set labels to a given entity.

        :param guid: The globally unique identifier of the entity. Required.
        :type guid: str
        :param body: set of labels to be set to the entity. Is either a [str] type or a IO[bytes] type.
         Required.
        :type body: list[str] or IO[bytes]
        :keyword content_type: Body parameter Content-Type. Known values are: application/json. Default
         value is None.
        :paramtype content_type: str
        :return: None
        :rtype: None
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[None] = kwargs.pop("cls", None)

        content_type = content_type or "application/json"
        _content = None
        if isinstance(body, (IOBase, bytes)):
            _content = body
        else:
            _content = json.dumps(body, cls=SdkJSONEncoder, exclude_readonly=True)  # type: ignore

        _request = build_entity_set_labels_request(
            guid=guid,
            content_type=content_type,
            api_version=self._config.api_version,
            content=_content,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = False
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [204]:
            if _stream:
                await response.read()  # Load the body in memory and close the socket
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = _deserialize(_models.ErrorResponse, response.json())
            raise HttpResponseError(response=response, model=error)

        if cls:
            return cls(pipeline_response, None, {})  # type: ignore

    @overload
    async def add_label(  # pylint: disable=inconsistent-return-statements
        self, guid: str, body: List[str], *, content_type: str = "application/json", **kwargs: Any
    ) -> None:
        """Add given labels to a given entity.

        :param guid: The globally unique identifier of the entity. Required.
        :type guid: str
        :param body: set of labels to be added. Required.
        :type body: list[str]
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: None
        :rtype: None
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @overload
    async def add_label(  # pylint: disable=inconsistent-return-statements
        self, guid: str, body: IO[bytes], *, content_type: str = "application/json", **kwargs: Any
    ) -> None:
        """Add given labels to a given entity.

        :param guid: The globally unique identifier of the entity. Required.
        :type guid: str
        :param body: set of labels to be added. Required.
        :type body: IO[bytes]
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: None
        :rtype: None
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @distributed_trace_async
    async def add_label(  # pylint: disable=inconsistent-return-statements
        self, guid: str, body: Union[List[str], IO[bytes]], **kwargs: Any
    ) -> None:
        """Add given labels to a given entity.

        :param guid: The globally unique identifier of the entity. Required.
        :type guid: str
        :param body: set of labels to be added. Is either a [str] type or a IO[bytes] type. Required.
        :type body: list[str] or IO[bytes]
        :keyword content_type: Body parameter Content-Type. Known values are: application/json. Default
         value is None.
        :paramtype content_type: str
        :return: None
        :rtype: None
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[None] = kwargs.pop("cls", None)

        content_type = content_type or "application/json"
        _content = None
        if isinstance(body, (IOBase, bytes)):
            _content = body
        else:
            _content = json.dumps(body, cls=SdkJSONEncoder, exclude_readonly=True)  # type: ignore

        _request = build_entity_add_label_request(
            guid=guid,
            content_type=content_type,
            api_version=self._config.api_version,
            content=_content,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = False
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [204]:
            if _stream:
                await response.read()  # Load the body in memory and close the socket
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = _deserialize(_models.ErrorResponse, response.json())
            raise HttpResponseError(response=response, model=error)

        if cls:
            return cls(pipeline_response, None, {})  # type: ignore

    @overload
    async def remove_labels_by_unique_attribute(  # pylint: disable=inconsistent-return-statements
        self,
        type_name: str,
        body: List[str],
        *,
        attr: Optional[str] = None,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> None:
        """Delete given labels to a given entity identified by its type and unique
        attribute.

        If labels is null/empty, no labels will be removed.

        If any labels
        in labels set are non-existing labels, they will be ignored, only existing
        labels will be removed. In addition to the typeName path parameter, attribute
        key-value pair(s) can be provided in the following format:
        attr::code:`<attrName>`=:code:`<attrValue>`. NOTE: The attrName and attrValue should be unique
        across entities, eg. qualifiedName. The REST request would look something like
        this: DELETE
        /v2/entity/uniqueAttribute/type/aType?attr:aTypeAttribute=someValue.

        :param type_name: The name of the type. Required.
        :type type_name: str
        :param body: set of labels to be deleted. Required.
        :type body: list[str]
        :keyword attr: The qualified name of the entity. (This is only an example. qualifiedName can
         be changed to other unique attributes). Default value is None.
        :paramtype attr: str
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: None
        :rtype: None
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @overload
    async def remove_labels_by_unique_attribute(  # pylint: disable=inconsistent-return-statements
        self,
        type_name: str,
        body: IO[bytes],
        *,
        attr: Optional[str] = None,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> None:
        """Delete given labels to a given entity identified by its type and unique
        attribute.

        If labels is null/empty, no labels will be removed.

        If any labels
        in labels set are non-existing labels, they will be ignored, only existing
        labels will be removed. In addition to the typeName path parameter, attribute
        key-value pair(s) can be provided in the following format:
        attr::code:`<attrName>`=:code:`<attrValue>`. NOTE: The attrName and attrValue should be unique
        across entities, eg. qualifiedName. The REST request would look something like
        this: DELETE
        /v2/entity/uniqueAttribute/type/aType?attr:aTypeAttribute=someValue.

        :param type_name: The name of the type. Required.
        :type type_name: str
        :param body: set of labels to be deleted. Required.
        :type body: IO[bytes]
        :keyword attr: The qualified name of the entity. (This is only an example. qualifiedName can
         be changed to other unique attributes). Default value is None.
        :paramtype attr: str
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: None
        :rtype: None
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @distributed_trace_async
    async def remove_labels_by_unique_attribute(  # pylint: disable=inconsistent-return-statements
        self, type_name: str, body: Union[List[str], IO[bytes]], *, attr: Optional[str] = None, **kwargs: Any
    ) -> None:
        """Delete given labels to a given entity identified by its type and unique
        attribute.

        If labels is null/empty, no labels will be removed.

        If any labels
        in labels set are non-existing labels, they will be ignored, only existing
        labels will be removed. In addition to the typeName path parameter, attribute
        key-value pair(s) can be provided in the following format:
        attr::code:`<attrName>`=:code:`<attrValue>`. NOTE: The attrName and attrValue should be unique
        across entities, eg. qualifiedName. The REST request would look something like
        this: DELETE
        /v2/entity/uniqueAttribute/type/aType?attr:aTypeAttribute=someValue.

        :param type_name: The name of the type. Required.
        :type type_name: str
        :param body: set of labels to be deleted. Is either a [str] type or a IO[bytes] type. Required.
        :type body: list[str] or IO[bytes]
        :keyword attr: The qualified name of the entity. (This is only an example. qualifiedName can
         be changed to other unique attributes). Default value is None.
        :paramtype attr: str
        :keyword content_type: Body parameter Content-Type. Known values are: application/json. Default
         value is None.
        :paramtype content_type: str
        :return: None
        :rtype: None
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[None] = kwargs.pop("cls", None)

        content_type = content_type or "application/json"
        _content = None
        if isinstance(body, (IOBase, bytes)):
            _content = body
        else:
            _content = json.dumps(body, cls=SdkJSONEncoder, exclude_readonly=True)  # type: ignore

        _request = build_entity_remove_labels_by_unique_attribute_request(
            type_name=type_name,
            attr=attr,
            content_type=content_type,
            api_version=self._config.api_version,
            content=_content,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = False
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [204]:
            if _stream:
                await response.read()  # Load the body in memory and close the socket
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = _deserialize(_models.ErrorResponse, response.json())
            raise HttpResponseError(response=response, model=error)

        if cls:
            return cls(pipeline_response, None, {})  # type: ignore

    @overload
    async def set_labels_by_unique_attribute(  # pylint: disable=inconsistent-return-statements
        self,
        type_name: str,
        body: List[str],
        *,
        attr: Optional[str] = None,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> None:
        """Set labels to a given entity identified by its type and unique attributes.

        If
        labels is null/empty, existing labels will all be removed.

        In addition to the
        typeName path parameter, attribute key-value pair(s) can be provided in the
        following format: attr::code:`<attrName>`=:code:`<attrValue>`.

        NOTE: The attrName and
        attrValue should be unique across entities, eg. qualifiedName.

        The REST
        request would look something like this: POST
        /v2/entity/uniqueAttribute/type/aType?attr:aTypeAttribute=someValue.

        :param type_name: The name of the type. Required.
        :type type_name: str
        :param body: set of labels to be set. Required.
        :type body: list[str]
        :keyword attr: The qualified name of the entity. (This is only an example. qualifiedName can
         be changed to other unique attributes). Default value is None.
        :paramtype attr: str
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: None
        :rtype: None
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @overload
    async def set_labels_by_unique_attribute(  # pylint: disable=inconsistent-return-statements
        self,
        type_name: str,
        body: IO[bytes],
        *,
        attr: Optional[str] = None,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> None:
        """Set labels to a given entity identified by its type and unique attributes.

        If
        labels is null/empty, existing labels will all be removed.

        In addition to the
        typeName path parameter, attribute key-value pair(s) can be provided in the
        following format: attr::code:`<attrName>`=:code:`<attrValue>`.

        NOTE: The attrName and
        attrValue should be unique across entities, eg. qualifiedName.

        The REST
        request would look something like this: POST
        /v2/entity/uniqueAttribute/type/aType?attr:aTypeAttribute=someValue.

        :param type_name: The name of the type. Required.
        :type type_name: str
        :param body: set of labels to be set. Required.
        :type body: IO[bytes]
        :keyword attr: The qualified name of the entity. (This is only an example. qualifiedName can
         be changed to other unique attributes). Default value is None.
        :paramtype attr: str
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: None
        :rtype: None
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @distributed_trace_async
    async def set_labels_by_unique_attribute(  # pylint: disable=inconsistent-return-statements
        self, type_name: str, body: Union[List[str], IO[bytes]], *, attr: Optional[str] = None, **kwargs: Any
    ) -> None:
        """Set labels to a given entity identified by its type and unique attributes.

        If
        labels is null/empty, existing labels will all be removed.

        In addition to the
        typeName path parameter, attribute key-value pair(s) can be provided in the
        following format: attr::code:`<attrName>`=:code:`<attrValue>`.

        NOTE: The attrName and
        attrValue should be unique across entities, eg. qualifiedName.

        The REST
        request would look something like this: POST
        /v2/entity/uniqueAttribute/type/aType?attr:aTypeAttribute=someValue.

        :param type_name: The name of the type. Required.
        :type type_name: str
        :param body: set of labels to be set. Is either a [str] type or a IO[bytes] type. Required.
        :type body: list[str] or IO[bytes]
        :keyword attr: The qualified name of the entity. (This is only an example. qualifiedName can
         be changed to other unique attributes). Default value is None.
        :paramtype attr: str
        :keyword content_type: Body parameter Content-Type. Known values are: application/json. Default
         value is None.
        :paramtype content_type: str
        :return: None
        :rtype: None
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[None] = kwargs.pop("cls", None)

        content_type = content_type or "application/json"
        _content = None
        if isinstance(body, (IOBase, bytes)):
            _content = body
        else:
            _content = json.dumps(body, cls=SdkJSONEncoder, exclude_readonly=True)  # type: ignore

        _request = build_entity_set_labels_by_unique_attribute_request(
            type_name=type_name,
            attr=attr,
            content_type=content_type,
            api_version=self._config.api_version,
            content=_content,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = False
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [204]:
            if _stream:
                await response.read()  # Load the body in memory and close the socket
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = _deserialize(_models.ErrorResponse, response.json())
            raise HttpResponseError(response=response, model=error)

        if cls:
            return cls(pipeline_response, None, {})  # type: ignore

    @overload
    async def add_labels_by_unique_attribute(  # pylint: disable=inconsistent-return-statements
        self,
        type_name: str,
        body: List[str],
        *,
        attr: Optional[str] = None,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> None:
        """Add given labels to a given entity identified by its type and unique
        attributes.

        If labels is null/empty, no labels will be added.

        In addition to
        the typeName path parameter, attribute key-value pair(s) can be provided in the
        following format: attr::code:`<attrName>`=:code:`<attrValue>`.

        NOTE: The attrName and
        attrValue should be unique across entities, eg. qualifiedName.

        The REST
        request would look something like this: PUT
        /v2/entity/uniqueAttribute/type/aType?attr:aTypeAttribute=someValue.

        :param type_name: The name of the type. Required.
        :type type_name: str
        :param body: set of labels to be added. Required.
        :type body: list[str]
        :keyword attr: The qualified name of the entity. (This is only an example. qualifiedName can
         be changed to other unique attributes). Default value is None.
        :paramtype attr: str
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: None
        :rtype: None
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @overload
    async def add_labels_by_unique_attribute(  # pylint: disable=inconsistent-return-statements
        self,
        type_name: str,
        body: IO[bytes],
        *,
        attr: Optional[str] = None,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> None:
        """Add given labels to a given entity identified by its type and unique
        attributes.

        If labels is null/empty, no labels will be added.

        In addition to
        the typeName path parameter, attribute key-value pair(s) can be provided in the
        following format: attr::code:`<attrName>`=:code:`<attrValue>`.

        NOTE: The attrName and
        attrValue should be unique across entities, eg. qualifiedName.

        The REST
        request would look something like this: PUT
        /v2/entity/uniqueAttribute/type/aType?attr:aTypeAttribute=someValue.

        :param type_name: The name of the type. Required.
        :type type_name: str
        :param body: set of labels to be added. Required.
        :type body: IO[bytes]
        :keyword attr: The qualified name of the entity. (This is only an example. qualifiedName can
         be changed to other unique attributes). Default value is None.
        :paramtype attr: str
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: None
        :rtype: None
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @distributed_trace_async
    async def add_labels_by_unique_attribute(  # pylint: disable=inconsistent-return-statements
        self, type_name: str, body: Union[List[str], IO[bytes]], *, attr: Optional[str] = None, **kwargs: Any
    ) -> None:
        """Add given labels to a given entity identified by its type and unique
        attributes.

        If labels is null/empty, no labels will be added.

        In addition to
        the typeName path parameter, attribute key-value pair(s) can be provided in the
        following format: attr::code:`<attrName>`=:code:`<attrValue>`.

        NOTE: The attrName and
        attrValue should be unique across entities, eg. qualifiedName.

        The REST
        request would look something like this: PUT
        /v2/entity/uniqueAttribute/type/aType?attr:aTypeAttribute=someValue.

        :param type_name: The name of the type. Required.
        :type type_name: str
        :param body: set of labels to be added. Is either a [str] type or a IO[bytes] type. Required.
        :type body: list[str] or IO[bytes]
        :keyword attr: The qualified name of the entity. (This is only an example. qualifiedName can
         be changed to other unique attributes). Default value is None.
        :paramtype attr: str
        :keyword content_type: Body parameter Content-Type. Known values are: application/json. Default
         value is None.
        :paramtype content_type: str
        :return: None
        :rtype: None
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[None] = kwargs.pop("cls", None)

        content_type = content_type or "application/json"
        _content = None
        if isinstance(body, (IOBase, bytes)):
            _content = body
        else:
            _content = json.dumps(body, cls=SdkJSONEncoder, exclude_readonly=True)  # type: ignore

        _request = build_entity_add_labels_by_unique_attribute_request(
            type_name=type_name,
            attr=attr,
            content_type=content_type,
            api_version=self._config.api_version,
            content=_content,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = False
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [204]:
            if _stream:
                await response.read()  # Load the body in memory and close the socket
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = _deserialize(_models.ErrorResponse, response.json())
            raise HttpResponseError(response=response, model=error)

        if cls:
            return cls(pipeline_response, None, {})  # type: ignore

    @overload
    async def move_entities_to_collection(
        self,
        move_entities_request: _models.MoveEntitiesRequest,
        *,
        collection_id: str,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> _models.EntityMutationResponse:
        """Move existing entities to the target collection.

        :param move_entities_request: Entity guids to be moved to target collection. Required.
        :type move_entities_request: ~azure.purview.datamap.models.MoveEntitiesRequest
        :keyword collection_id: The collection where entities will be moved to. Required.
        :paramtype collection_id: str
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :keyword bool stream: Whether to stream the response of this operation. Defaults to False. You
         will have to context manage the returned stream.
        :return: EntityMutationResponse. The EntityMutationResponse is compatible with MutableMapping
        :rtype: ~azure.purview.datamap.models.EntityMutationResponse
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @overload
    async def move_entities_to_collection(
        self, move_entities_request: JSON, *, collection_id: str, content_type: str = "application/json", **kwargs: Any
    ) -> _models.EntityMutationResponse:
        """Move existing entities to the target collection.

        :param move_entities_request: Entity guids to be moved to target collection. Required.
        :type move_entities_request: JSON
        :keyword collection_id: The collection where entities will be moved to. Required.
        :paramtype collection_id: str
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :keyword bool stream: Whether to stream the response of this operation. Defaults to False. You
         will have to context manage the returned stream.
        :return: EntityMutationResponse. The EntityMutationResponse is compatible with MutableMapping
        :rtype: ~azure.purview.datamap.models.EntityMutationResponse
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @overload
    async def move_entities_to_collection(
        self,
        move_entities_request: IO[bytes],
        *,
        collection_id: str,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> _models.EntityMutationResponse:
        """Move existing entities to the target collection.

        :param move_entities_request: Entity guids to be moved to target collection. Required.
        :type move_entities_request: IO[bytes]
        :keyword collection_id: The collection where entities will be moved to. Required.
        :paramtype collection_id: str
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Default value is "application/json".
        :paramtype content_type: str
        :keyword bool stream: Whether to stream the response of this operation. Defaults to False. You
         will have to context manage the returned stream.
        :return: EntityMutationResponse. The EntityMutationResponse is compatible with MutableMapping
        :rtype: ~azure.purview.datamap.models.EntityMutationResponse
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @distributed_trace_async
    async def move_entities_to_collection(
        self,
        move_entities_request: Union[_models.MoveEntitiesRequest, JSON, IO[bytes]],
        *,
        collection_id: str,
        **kwargs: Any
    ) -> _models.EntityMutationResponse:
        """Move existing entities to the target collection.

        :param move_entities_request: Entity guids to be moved to target collection. Is one of the
         following types: MoveEntitiesRequest, JSON, IO[bytes] Required.
        :type move_entities_request: ~azure.purview.datamap.models.MoveEntitiesRequest or JSON or
         IO[bytes]
        :keyword collection_id: The collection where entities will be moved to. Required.
        :paramtype collection_id: str
        :keyword content_type: Body parameter Content-Type. Known values are: application/json. Default
         value is None.
        :paramtype content_type: str
        :keyword bool stream: Whether to stream the response of this operation. Defaults to False. You
         will have to context manage the returned stream.
        :return: EntityMutationResponse. The EntityMutationResponse is compatible with MutableMapping
        :rtype: ~azure.purview.datamap.models.EntityMutationResponse
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[_models.EntityMutationResponse] = kwargs.pop("cls", None)

        content_type = content_type or "application/json"
        _content = None
        if isinstance(move_entities_request, (IOBase, bytes)):
            _content = move_entities_request
        else:
            _content = json.dumps(move_entities_request, cls=SdkJSONEncoder, exclude_readonly=True)  # type: ignore

        _request = build_entity_move_entities_to_collection_request(
            collection_id=collection_id,
            content_type=content_type,
            api_version=self._config.api_version,
            content=_content,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = kwargs.pop("stream", False)
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                await response.read()  # Load the body in memory and close the socket
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = _deserialize(_models.ErrorResponse, response.json())
            raise HttpResponseError(response=response, model=error)

        if _stream:
            deserialized = response.iter_bytes()
        else:
            deserialized = _deserialize(_models.EntityMutationResponse, response.json())

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore


class GlossaryOperations:  # pylint: disable=too-many-public-methods
    """
    .. warning::
        **DO NOT** instantiate this class directly.

        Instead, you should access the following operations through
        :class:`~azure.purview.datamap.aio.PurviewDataMapClient`'s
        :attr:`glossary` attribute.
    """

    def __init__(self, *args, **kwargs) -> None:
        input_args = list(args)
        self._client = input_args.pop(0) if input_args else kwargs.pop("client")
        self._config = input_args.pop(0) if input_args else kwargs.pop("config")
        self._serialize = input_args.pop(0) if input_args else kwargs.pop("serializer")
        self._deserialize = input_args.pop(0) if input_args else kwargs.pop("deserializer")

    @distributed_trace_async
    async def list(
        self,
        *,
        limit: Optional[int] = None,
        offset: Optional[int] = None,
        sort: Optional[str] = None,
        ignore_terms_and_categories: Optional[bool] = None,
        **kwargs: Any
    ) -> List[_models.AtlasGlossary]:
        """Get all glossaries. Recommend using limit/offset to get pagination result.
        Recommend using 'ignoreTermsAndCategories=true' and fetch terms/categories
        separately using

         'GET /datamap/api/atlas/v2/glossary/{glossaryGuid}/terms'
        and

         'GET '/datamap/api/atlas/v2/glossary/{glossaryGuid}/categories'.

        :keyword limit: The page size - by default there is no paging. Default value is None.
        :paramtype limit: int
        :keyword offset: The offset for pagination purpose. Default value is None.
        :paramtype offset: int
        :keyword sort: The sort order, ASC (default) or DESC. Default value is None.
        :paramtype sort: str
        :keyword ignore_terms_and_categories: Whether ignore terms and categories. Default value is
         None.
        :paramtype ignore_terms_and_categories: bool
        :keyword bool stream: Whether to stream the response of this operation. Defaults to False. You
         will have to context manage the returned stream.
        :return: list of AtlasGlossary
        :rtype: list[~azure.purview.datamap.models.AtlasGlossary]
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[List[_models.AtlasGlossary]] = kwargs.pop("cls", None)

        _request = build_glossary_list_request(
            limit=limit,
            offset=offset,
            sort=sort,
            ignore_terms_and_categories=ignore_terms_and_categories,
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = kwargs.pop("stream", False)
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                await response.read()  # Load the body in memory and close the socket
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = _deserialize(_models.ErrorResponse, response.json())
            raise HttpResponseError(response=response, model=error)

        if _stream:
            deserialized = response.iter_bytes()
        else:
            deserialized = _deserialize(List[_models.AtlasGlossary], response.json())

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore

    @overload
    async def create(
        self, atlas_glossary: _models.AtlasGlossary, *, content_type: str = "application/json", **kwargs: Any
    ) -> _models.AtlasGlossary:
        """Create a glossary.

        :param atlas_glossary: Glossary definition, terms & categories can be anchored to a glossary.
         Using
         the anchor attribute when creating the Term/Category. Required.
        :type atlas_glossary: ~azure.purview.datamap.models.AtlasGlossary
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :keyword bool stream: Whether to stream the response of this operation. Defaults to False. You
         will have to context manage the returned stream.
        :return: AtlasGlossary. The AtlasGlossary is compatible with MutableMapping
        :rtype: ~azure.purview.datamap.models.AtlasGlossary
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @overload
    async def create(
        self, atlas_glossary: JSON, *, content_type: str = "application/json", **kwargs: Any
    ) -> _models.AtlasGlossary:
        """Create a glossary.

        :param atlas_glossary: Glossary definition, terms & categories can be anchored to a glossary.
         Using
         the anchor attribute when creating the Term/Category. Required.
        :type atlas_glossary: JSON
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :keyword bool stream: Whether to stream the response of this operation. Defaults to False. You
         will have to context manage the returned stream.
        :return: AtlasGlossary. The AtlasGlossary is compatible with MutableMapping
        :rtype: ~azure.purview.datamap.models.AtlasGlossary
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @overload
    async def create(
        self, atlas_glossary: IO[bytes], *, content_type: str = "application/json", **kwargs: Any
    ) -> _models.AtlasGlossary:
        """Create a glossary.

        :param atlas_glossary: Glossary definition, terms & categories can be anchored to a glossary.
         Using
         the anchor attribute when creating the Term/Category. Required.
        :type atlas_glossary: IO[bytes]
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Default value is "application/json".
        :paramtype content_type: str
        :keyword bool stream: Whether to stream the response of this operation. Defaults to False. You
         will have to context manage the returned stream.
        :return: AtlasGlossary. The AtlasGlossary is compatible with MutableMapping
        :rtype: ~azure.purview.datamap.models.AtlasGlossary
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @distributed_trace_async
    async def create(
        self, atlas_glossary: Union[_models.AtlasGlossary, JSON, IO[bytes]], **kwargs: Any
    ) -> _models.AtlasGlossary:
        """Create a glossary.

        :param atlas_glossary: Glossary definition, terms & categories can be anchored to a glossary.
         Using
         the anchor attribute when creating the Term/Category. Is one of the following types:
         AtlasGlossary, JSON, IO[bytes] Required.
        :type atlas_glossary: ~azure.purview.datamap.models.AtlasGlossary or JSON or IO[bytes]
        :keyword content_type: Body parameter Content-Type. Known values are: application/json. Default
         value is None.
        :paramtype content_type: str
        :keyword bool stream: Whether to stream the response of this operation. Defaults to False. You
         will have to context manage the returned stream.
        :return: AtlasGlossary. The AtlasGlossary is compatible with MutableMapping
        :rtype: ~azure.purview.datamap.models.AtlasGlossary
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[_models.AtlasGlossary] = kwargs.pop("cls", None)

        content_type = content_type or "application/json"
        _content = None
        if isinstance(atlas_glossary, (IOBase, bytes)):
            _content = atlas_glossary
        else:
            _content = json.dumps(atlas_glossary, cls=SdkJSONEncoder, exclude_readonly=True)  # type: ignore

        _request = build_glossary_create_request(
            content_type=content_type,
            api_version=self._config.api_version,
            content=_content,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = kwargs.pop("stream", False)
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                await response.read()  # Load the body in memory and close the socket
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = _deserialize(_models.ErrorResponse, response.json())
            raise HttpResponseError(response=response, model=error)

        if _stream:
            deserialized = response.iter_bytes()
        else:
            deserialized = _deserialize(_models.AtlasGlossary, response.json())

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore

    @overload
    async def create_categories(
        self,
        glossary_category: List[_models.AtlasGlossaryCategory],
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> List[_models.AtlasGlossaryCategory]:
        """Create glossary category in bulk.

        :param glossary_category: An array of glossary category definitions to be created. Required.
        :type glossary_category: list[~azure.purview.datamap.models.AtlasGlossaryCategory]
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :keyword bool stream: Whether to stream the response of this operation. Defaults to False. You
         will have to context manage the returned stream.
        :return: list of AtlasGlossaryCategory
        :rtype: list[~azure.purview.datamap.models.AtlasGlossaryCategory]
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @overload
    async def create_categories(
        self, glossary_category: IO[bytes], *, content_type: str = "application/json", **kwargs: Any
    ) -> List[_models.AtlasGlossaryCategory]:
        """Create glossary category in bulk.

        :param glossary_category: An array of glossary category definitions to be created. Required.
        :type glossary_category: IO[bytes]
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Default value is "application/json".
        :paramtype content_type: str
        :keyword bool stream: Whether to stream the response of this operation. Defaults to False. You
         will have to context manage the returned stream.
        :return: list of AtlasGlossaryCategory
        :rtype: list[~azure.purview.datamap.models.AtlasGlossaryCategory]
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @distributed_trace_async
    async def create_categories(
        self, glossary_category: Union[List[_models.AtlasGlossaryCategory], IO[bytes]], **kwargs: Any
    ) -> List[_models.AtlasGlossaryCategory]:
        """Create glossary category in bulk.

        :param glossary_category: An array of glossary category definitions to be created. Is either a
         [AtlasGlossaryCategory] type or a IO[bytes] type. Required.
        :type glossary_category: list[~azure.purview.datamap.models.AtlasGlossaryCategory] or IO[bytes]
        :keyword content_type: Body parameter Content-Type. Known values are: application/json. Default
         value is None.
        :paramtype content_type: str
        :keyword bool stream: Whether to stream the response of this operation. Defaults to False. You
         will have to context manage the returned stream.
        :return: list of AtlasGlossaryCategory
        :rtype: list[~azure.purview.datamap.models.AtlasGlossaryCategory]
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[List[_models.AtlasGlossaryCategory]] = kwargs.pop("cls", None)

        content_type = content_type or "application/json"
        _content = None
        if isinstance(glossary_category, (IOBase, bytes)):
            _content = glossary_category
        else:
            _content = json.dumps(glossary_category, cls=SdkJSONEncoder, exclude_readonly=True)  # type: ignore

        _request = build_glossary_create_categories_request(
            content_type=content_type,
            api_version=self._config.api_version,
            content=_content,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = kwargs.pop("stream", False)
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                await response.read()  # Load the body in memory and close the socket
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = _deserialize(_models.ErrorResponse, response.json())
            raise HttpResponseError(response=response, model=error)

        if _stream:
            deserialized = response.iter_bytes()
        else:
            deserialized = _deserialize(List[_models.AtlasGlossaryCategory], response.json())

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore

    @overload
    async def create_category(
        self, glossary_category: _models.AtlasGlossaryCategory, *, content_type: str = "application/json", **kwargs: Any
    ) -> _models.AtlasGlossaryCategory:
        """Create a glossary category.

        :param glossary_category: The glossary category definition. A category must be anchored to a
         Glossary
         when creating.
         Optionally, terms belonging to the category and the hierarchy
         can also be defined during creation. Required.
        :type glossary_category: ~azure.purview.datamap.models.AtlasGlossaryCategory
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :keyword bool stream: Whether to stream the response of this operation. Defaults to False. You
         will have to context manage the returned stream.
        :return: AtlasGlossaryCategory. The AtlasGlossaryCategory is compatible with MutableMapping
        :rtype: ~azure.purview.datamap.models.AtlasGlossaryCategory
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @overload
    async def create_category(
        self, glossary_category: JSON, *, content_type: str = "application/json", **kwargs: Any
    ) -> _models.AtlasGlossaryCategory:
        """Create a glossary category.

        :param glossary_category: The glossary category definition. A category must be anchored to a
         Glossary
         when creating.
         Optionally, terms belonging to the category and the hierarchy
         can also be defined during creation. Required.
        :type glossary_category: JSON
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :keyword bool stream: Whether to stream the response of this operation. Defaults to False. You
         will have to context manage the returned stream.
        :return: AtlasGlossaryCategory. The AtlasGlossaryCategory is compatible with MutableMapping
        :rtype: ~azure.purview.datamap.models.AtlasGlossaryCategory
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @overload
    async def create_category(
        self, glossary_category: IO[bytes], *, content_type: str = "application/json", **kwargs: Any
    ) -> _models.AtlasGlossaryCategory:
        """Create a glossary category.

        :param glossary_category: The glossary category definition. A category must be anchored to a
         Glossary
         when creating.
         Optionally, terms belonging to the category and the hierarchy
         can also be defined during creation. Required.
        :type glossary_category: IO[bytes]
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Default value is "application/json".
        :paramtype content_type: str
        :keyword bool stream: Whether to stream the response of this operation. Defaults to False. You
         will have to context manage the returned stream.
        :return: AtlasGlossaryCategory. The AtlasGlossaryCategory is compatible with MutableMapping
        :rtype: ~azure.purview.datamap.models.AtlasGlossaryCategory
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @distributed_trace_async
    async def create_category(
        self, glossary_category: Union[_models.AtlasGlossaryCategory, JSON, IO[bytes]], **kwargs: Any
    ) -> _models.AtlasGlossaryCategory:
        """Create a glossary category.

        :param glossary_category: The glossary category definition. A category must be anchored to a
         Glossary
         when creating.
         Optionally, terms belonging to the category and the hierarchy
         can also be defined during creation. Is one of the following types: AtlasGlossaryCategory,
         JSON, IO[bytes] Required.
        :type glossary_category: ~azure.purview.datamap.models.AtlasGlossaryCategory or JSON or
         IO[bytes]
        :keyword content_type: Body parameter Content-Type. Known values are: application/json. Default
         value is None.
        :paramtype content_type: str
        :keyword bool stream: Whether to stream the response of this operation. Defaults to False. You
         will have to context manage the returned stream.
        :return: AtlasGlossaryCategory. The AtlasGlossaryCategory is compatible with MutableMapping
        :rtype: ~azure.purview.datamap.models.AtlasGlossaryCategory
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[_models.AtlasGlossaryCategory] = kwargs.pop("cls", None)

        content_type = content_type or "application/json"
        _content = None
        if isinstance(glossary_category, (IOBase, bytes)):
            _content = glossary_category
        else:
            _content = json.dumps(glossary_category, cls=SdkJSONEncoder, exclude_readonly=True)  # type: ignore

        _request = build_glossary_create_category_request(
            content_type=content_type,
            api_version=self._config.api_version,
            content=_content,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = kwargs.pop("stream", False)
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                await response.read()  # Load the body in memory and close the socket
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = _deserialize(_models.ErrorResponse, response.json())
            raise HttpResponseError(response=response, model=error)

        if _stream:
            deserialized = response.iter_bytes()
        else:
            deserialized = _deserialize(_models.AtlasGlossaryCategory, response.json())

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore

    @distributed_trace_async
    async def get_category(self, category_guid: str, **kwargs: Any) -> _models.AtlasGlossaryCategory:
        """Get specific glossary category by its GUID.

        :param category_guid: The globally unique identifier of the category. Required.
        :type category_guid: str
        :keyword bool stream: Whether to stream the response of this operation. Defaults to False. You
         will have to context manage the returned stream.
        :return: AtlasGlossaryCategory. The AtlasGlossaryCategory is compatible with MutableMapping
        :rtype: ~azure.purview.datamap.models.AtlasGlossaryCategory
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[_models.AtlasGlossaryCategory] = kwargs.pop("cls", None)

        _request = build_glossary_get_category_request(
            category_guid=category_guid,
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = kwargs.pop("stream", False)
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                await response.read()  # Load the body in memory and close the socket
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = _deserialize(_models.ErrorResponse, response.json())
            raise HttpResponseError(response=response, model=error)

        if _stream:
            deserialized = response.iter_bytes()
        else:
            deserialized = _deserialize(_models.AtlasGlossaryCategory, response.json())

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore

    @overload
    async def update_category(
        self,
        category_guid: str,
        glossary_category: _models.AtlasGlossaryCategory,
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> _models.AtlasGlossaryCategory:
        """Update the given glossary category by its GUID.

        :param category_guid: The globally unique identifier of the category. Required.
        :type category_guid: str
        :param glossary_category: The glossary category to be updated. Required.
        :type glossary_category: ~azure.purview.datamap.models.AtlasGlossaryCategory
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :keyword bool stream: Whether to stream the response of this operation. Defaults to False. You
         will have to context manage the returned stream.
        :return: AtlasGlossaryCategory. The AtlasGlossaryCategory is compatible with MutableMapping
        :rtype: ~azure.purview.datamap.models.AtlasGlossaryCategory
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @overload
    async def update_category(
        self, category_guid: str, glossary_category: JSON, *, content_type: str = "application/json", **kwargs: Any
    ) -> _models.AtlasGlossaryCategory:
        """Update the given glossary category by its GUID.

        :param category_guid: The globally unique identifier of the category. Required.
        :type category_guid: str
        :param glossary_category: The glossary category to be updated. Required.
        :type glossary_category: JSON
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :keyword bool stream: Whether to stream the response of this operation. Defaults to False. You
         will have to context manage the returned stream.
        :return: AtlasGlossaryCategory. The AtlasGlossaryCategory is compatible with MutableMapping
        :rtype: ~azure.purview.datamap.models.AtlasGlossaryCategory
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @overload
    async def update_category(
        self, category_guid: str, glossary_category: IO[bytes], *, content_type: str = "application/json", **kwargs: Any
    ) -> _models.AtlasGlossaryCategory:
        """Update the given glossary category by its GUID.

        :param category_guid: The globally unique identifier of the category. Required.
        :type category_guid: str
        :param glossary_category: The glossary category to be updated. Required.
        :type glossary_category: IO[bytes]
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Default value is "application/json".
        :paramtype content_type: str
        :keyword bool stream: Whether to stream the response of this operation. Defaults to False. You
         will have to context manage the returned stream.
        :return: AtlasGlossaryCategory. The AtlasGlossaryCategory is compatible with MutableMapping
        :rtype: ~azure.purview.datamap.models.AtlasGlossaryCategory
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @distributed_trace_async
    async def update_category(
        self,
        category_guid: str,
        glossary_category: Union[_models.AtlasGlossaryCategory, JSON, IO[bytes]],
        **kwargs: Any
    ) -> _models.AtlasGlossaryCategory:
        """Update the given glossary category by its GUID.

        :param category_guid: The globally unique identifier of the category. Required.
        :type category_guid: str
        :param glossary_category: The glossary category to be updated. Is one of the following types:
         AtlasGlossaryCategory, JSON, IO[bytes] Required.
        :type glossary_category: ~azure.purview.datamap.models.AtlasGlossaryCategory or JSON or
         IO[bytes]
        :keyword content_type: Body parameter Content-Type. Known values are: application/json. Default
         value is None.
        :paramtype content_type: str
        :keyword bool stream: Whether to stream the response of this operation. Defaults to False. You
         will have to context manage the returned stream.
        :return: AtlasGlossaryCategory. The AtlasGlossaryCategory is compatible with MutableMapping
        :rtype: ~azure.purview.datamap.models.AtlasGlossaryCategory
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[_models.AtlasGlossaryCategory] = kwargs.pop("cls", None)

        content_type = content_type or "application/json"
        _content = None
        if isinstance(glossary_category, (IOBase, bytes)):
            _content = glossary_category
        else:
            _content = json.dumps(glossary_category, cls=SdkJSONEncoder, exclude_readonly=True)  # type: ignore

        _request = build_glossary_update_category_request(
            category_guid=category_guid,
            content_type=content_type,
            api_version=self._config.api_version,
            content=_content,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = kwargs.pop("stream", False)
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                await response.read()  # Load the body in memory and close the socket
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = _deserialize(_models.ErrorResponse, response.json())
            raise HttpResponseError(response=response, model=error)

        if _stream:
            deserialized = response.iter_bytes()
        else:
            deserialized = _deserialize(_models.AtlasGlossaryCategory, response.json())

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore

    @distributed_trace_async
    async def delete_category(  # pylint: disable=inconsistent-return-statements
        self, category_guid: str, **kwargs: Any
    ) -> None:
        """Delete a glossary category.

        :param category_guid: The globally unique identifier of the category. Required.
        :type category_guid: str
        :return: None
        :rtype: None
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[None] = kwargs.pop("cls", None)

        _request = build_glossary_delete_category_request(
            category_guid=category_guid,
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = False
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [204]:
            if _stream:
                await response.read()  # Load the body in memory and close the socket
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = _deserialize(_models.ErrorResponse, response.json())
            raise HttpResponseError(response=response, model=error)

        if cls:
            return cls(pipeline_response, None, {})  # type: ignore

    @distributed_trace_async
    async def partial_update_category(
        self, category_guid: str, partial_updates: Any, **kwargs: Any
    ) -> _models.AtlasGlossaryCategory:
        """Update the glossary category partially. So far we only supports partial
        updating shortDescription and longDescription for category.

        :param category_guid: The globally unique identifier of the category. Required.
        :type category_guid: str
        :param partial_updates: A map containing keys as attribute names and values as corresponding
         attribute
         values for partial update. Required.
        :type partial_updates: any
        :keyword content_type: Body parameter Content-Type. Known values are: application/json. Default
         value is "application/json".
        :paramtype content_type: str
        :keyword bool stream: Whether to stream the response of this operation. Defaults to False. You
         will have to context manage the returned stream.
        :return: AtlasGlossaryCategory. The AtlasGlossaryCategory is compatible with MutableMapping
        :rtype: ~azure.purview.datamap.models.AtlasGlossaryCategory
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: str = kwargs.pop("content_type", _headers.pop("Content-Type", "application/json"))
        cls: ClsType[_models.AtlasGlossaryCategory] = kwargs.pop("cls", None)

        _content = json.dumps(partial_updates, cls=SdkJSONEncoder, exclude_readonly=True)  # type: ignore

        _request = build_glossary_partial_update_category_request(
            category_guid=category_guid,
            content_type=content_type,
            api_version=self._config.api_version,
            content=_content,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = kwargs.pop("stream", False)
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                await response.read()  # Load the body in memory and close the socket
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = _deserialize(_models.ErrorResponse, response.json())
            raise HttpResponseError(response=response, model=error)

        if _stream:
            deserialized = response.iter_bytes()
        else:
            deserialized = _deserialize(_models.AtlasGlossaryCategory, response.json())

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore

    @distributed_trace_async
    async def list_related_categories(
        self,
        category_guid: str,
        *,
        limit: Optional[int] = None,
        offset: Optional[int] = None,
        sort: Optional[str] = None,
        **kwargs: Any
    ) -> Dict[str, List[_models.AtlasRelatedCategoryHeader]]:
        """Get all related categories (parent and children). Limit, offset, and sort
        parameters are currently not being enabled and won't work even they are passed.

        :param category_guid: The globally unique identifier of the category. Required.
        :type category_guid: str
        :keyword limit: The page size - by default there is no paging. Default value is None.
        :paramtype limit: int
        :keyword offset: The offset for pagination purpose. Default value is None.
        :paramtype offset: int
        :keyword sort: The sort order, ASC (default) or DESC. Default value is None.
        :paramtype sort: str
        :keyword bool stream: Whether to stream the response of this operation. Defaults to False. You
         will have to context manage the returned stream.
        :return: dict mapping str to list of AtlasRelatedCategoryHeader
        :rtype: dict[str, list[~azure.purview.datamap.models.AtlasRelatedCategoryHeader]]
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[Dict[str, List[_models.AtlasRelatedCategoryHeader]]] = kwargs.pop("cls", None)

        _request = build_glossary_list_related_categories_request(
            category_guid=category_guid,
            limit=limit,
            offset=offset,
            sort=sort,
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = kwargs.pop("stream", False)
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                await response.read()  # Load the body in memory and close the socket
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = _deserialize(_models.ErrorResponse, response.json())
            raise HttpResponseError(response=response, model=error)

        if _stream:
            deserialized = response.iter_bytes()
        else:
            deserialized = _deserialize(Dict[str, List[_models.AtlasRelatedCategoryHeader]], response.json())

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore

    @distributed_trace_async
    async def list_category_terms(
        self,
        category_guid: str,
        *,
        limit: Optional[int] = None,
        offset: Optional[int] = None,
        sort: Optional[str] = None,
        **kwargs: Any
    ) -> List[_models.AtlasRelatedTermHeader]:
        """Get all terms associated with the specific category.

        :param category_guid: The globally unique identifier of the category. Required.
        :type category_guid: str
        :keyword limit: The page size - by default there is no paging. Default value is None.
        :paramtype limit: int
        :keyword offset: The offset for pagination purpose. Default value is None.
        :paramtype offset: int
        :keyword sort: The sort order, ASC (default) or DESC. Default value is None.
        :paramtype sort: str
        :keyword bool stream: Whether to stream the response of this operation. Defaults to False. You
         will have to context manage the returned stream.
        :return: list of AtlasRelatedTermHeader
        :rtype: list[~azure.purview.datamap.models.AtlasRelatedTermHeader]
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[List[_models.AtlasRelatedTermHeader]] = kwargs.pop("cls", None)

        _request = build_glossary_list_category_terms_request(
            category_guid=category_guid,
            limit=limit,
            offset=offset,
            sort=sort,
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = kwargs.pop("stream", False)
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                await response.read()  # Load the body in memory and close the socket
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = _deserialize(_models.ErrorResponse, response.json())
            raise HttpResponseError(response=response, model=error)

        if _stream:
            deserialized = response.iter_bytes()
        else:
            deserialized = _deserialize(List[_models.AtlasRelatedTermHeader], response.json())

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore

    @overload
    async def create_term(
        self,
        glossary_term: _models.AtlasGlossaryTerm,
        *,
        include_term_hierarchy: Optional[bool] = None,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> _models.AtlasGlossaryTerm:
        """Create a glossary term.

        :param glossary_term: The glossary term definition. A term must be anchored to a Glossary at
         the time
         of creation.
         Optionally it can be categorized as well. Required.
        :type glossary_term: ~azure.purview.datamap.models.AtlasGlossaryTerm
        :keyword include_term_hierarchy: Whether include term hierarchy. Default value is None.
        :paramtype include_term_hierarchy: bool
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :keyword bool stream: Whether to stream the response of this operation. Defaults to False. You
         will have to context manage the returned stream.
        :return: AtlasGlossaryTerm. The AtlasGlossaryTerm is compatible with MutableMapping
        :rtype: ~azure.purview.datamap.models.AtlasGlossaryTerm
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @overload
    async def create_term(
        self,
        glossary_term: JSON,
        *,
        include_term_hierarchy: Optional[bool] = None,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> _models.AtlasGlossaryTerm:
        """Create a glossary term.

        :param glossary_term: The glossary term definition. A term must be anchored to a Glossary at
         the time
         of creation.
         Optionally it can be categorized as well. Required.
        :type glossary_term: JSON
        :keyword include_term_hierarchy: Whether include term hierarchy. Default value is None.
        :paramtype include_term_hierarchy: bool
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :keyword bool stream: Whether to stream the response of this operation. Defaults to False. You
         will have to context manage the returned stream.
        :return: AtlasGlossaryTerm. The AtlasGlossaryTerm is compatible with MutableMapping
        :rtype: ~azure.purview.datamap.models.AtlasGlossaryTerm
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @overload
    async def create_term(
        self,
        glossary_term: IO[bytes],
        *,
        include_term_hierarchy: Optional[bool] = None,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> _models.AtlasGlossaryTerm:
        """Create a glossary term.

        :param glossary_term: The glossary term definition. A term must be anchored to a Glossary at
         the time
         of creation.
         Optionally it can be categorized as well. Required.
        :type glossary_term: IO[bytes]
        :keyword include_term_hierarchy: Whether include term hierarchy. Default value is None.
        :paramtype include_term_hierarchy: bool
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Default value is "application/json".
        :paramtype content_type: str
        :keyword bool stream: Whether to stream the response of this operation. Defaults to False. You
         will have to context manage the returned stream.
        :return: AtlasGlossaryTerm. The AtlasGlossaryTerm is compatible with MutableMapping
        :rtype: ~azure.purview.datamap.models.AtlasGlossaryTerm
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @distributed_trace_async
    async def create_term(
        self,
        glossary_term: Union[_models.AtlasGlossaryTerm, JSON, IO[bytes]],
        *,
        include_term_hierarchy: Optional[bool] = None,
        **kwargs: Any
    ) -> _models.AtlasGlossaryTerm:
        """Create a glossary term.

        :param glossary_term: The glossary term definition. A term must be anchored to a Glossary at
         the time
         of creation.
         Optionally it can be categorized as well. Is one of the following types: AtlasGlossaryTerm,
         JSON, IO[bytes] Required.
        :type glossary_term: ~azure.purview.datamap.models.AtlasGlossaryTerm or JSON or IO[bytes]
        :keyword include_term_hierarchy: Whether include term hierarchy. Default value is None.
        :paramtype include_term_hierarchy: bool
        :keyword content_type: Body parameter Content-Type. Known values are: application/json. Default
         value is None.
        :paramtype content_type: str
        :keyword bool stream: Whether to stream the response of this operation. Defaults to False. You
         will have to context manage the returned stream.
        :return: AtlasGlossaryTerm. The AtlasGlossaryTerm is compatible with MutableMapping
        :rtype: ~azure.purview.datamap.models.AtlasGlossaryTerm
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[_models.AtlasGlossaryTerm] = kwargs.pop("cls", None)

        content_type = content_type or "application/json"
        _content = None
        if isinstance(glossary_term, (IOBase, bytes)):
            _content = glossary_term
        else:
            _content = json.dumps(glossary_term, cls=SdkJSONEncoder, exclude_readonly=True)  # type: ignore

        _request = build_glossary_create_term_request(
            include_term_hierarchy=include_term_hierarchy,
            content_type=content_type,
            api_version=self._config.api_version,
            content=_content,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = kwargs.pop("stream", False)
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                await response.read()  # Load the body in memory and close the socket
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = _deserialize(_models.ErrorResponse, response.json())
            raise HttpResponseError(response=response, model=error)

        if _stream:
            deserialized = response.iter_bytes()
        else:
            deserialized = _deserialize(_models.AtlasGlossaryTerm, response.json())

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore

    @distributed_trace_async
    async def get_term(self, term_guid: str, **kwargs: Any) -> _models.AtlasGlossaryTerm:
        """Get a specific glossary term by its GUID.

        :param term_guid: The globally unique identifier for glossary term. Required.
        :type term_guid: str
        :keyword bool stream: Whether to stream the response of this operation. Defaults to False. You
         will have to context manage the returned stream.
        :return: AtlasGlossaryTerm. The AtlasGlossaryTerm is compatible with MutableMapping
        :rtype: ~azure.purview.datamap.models.AtlasGlossaryTerm
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[_models.AtlasGlossaryTerm] = kwargs.pop("cls", None)

        _request = build_glossary_get_term_request(
            term_guid=term_guid,
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = kwargs.pop("stream", False)
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                await response.read()  # Load the body in memory and close the socket
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = _deserialize(_models.ErrorResponse, response.json())
            raise HttpResponseError(response=response, model=error)

        if _stream:
            deserialized = response.iter_bytes()
        else:
            deserialized = _deserialize(_models.AtlasGlossaryTerm, response.json())

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore

    @overload
    async def update_term(
        self,
        term_guid: str,
        glossary_term: _models.AtlasGlossaryTerm,
        *,
        include_term_hierarchy: Optional[bool] = None,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> _models.AtlasGlossaryTerm:
        """Update the given glossary term by its GUID.

        :param term_guid: The globally unique identifier for glossary term. Required.
        :type term_guid: str
        :param glossary_term: The glossary term to be updated. Required.
        :type glossary_term: ~azure.purview.datamap.models.AtlasGlossaryTerm
        :keyword include_term_hierarchy: Whether include term hierarchy. Default value is None.
        :paramtype include_term_hierarchy: bool
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :keyword bool stream: Whether to stream the response of this operation. Defaults to False. You
         will have to context manage the returned stream.
        :return: AtlasGlossaryTerm. The AtlasGlossaryTerm is compatible with MutableMapping
        :rtype: ~azure.purview.datamap.models.AtlasGlossaryTerm
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @overload
    async def update_term(
        self,
        term_guid: str,
        glossary_term: JSON,
        *,
        include_term_hierarchy: Optional[bool] = None,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> _models.AtlasGlossaryTerm:
        """Update the given glossary term by its GUID.

        :param term_guid: The globally unique identifier for glossary term. Required.
        :type term_guid: str
        :param glossary_term: The glossary term to be updated. Required.
        :type glossary_term: JSON
        :keyword include_term_hierarchy: Whether include term hierarchy. Default value is None.
        :paramtype include_term_hierarchy: bool
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :keyword bool stream: Whether to stream the response of this operation. Defaults to False. You
         will have to context manage the returned stream.
        :return: AtlasGlossaryTerm. The AtlasGlossaryTerm is compatible with MutableMapping
        :rtype: ~azure.purview.datamap.models.AtlasGlossaryTerm
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @overload
    async def update_term(
        self,
        term_guid: str,
        glossary_term: IO[bytes],
        *,
        include_term_hierarchy: Optional[bool] = None,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> _models.AtlasGlossaryTerm:
        """Update the given glossary term by its GUID.

        :param term_guid: The globally unique identifier for glossary term. Required.
        :type term_guid: str
        :param glossary_term: The glossary term to be updated. Required.
        :type glossary_term: IO[bytes]
        :keyword include_term_hierarchy: Whether include term hierarchy. Default value is None.
        :paramtype include_term_hierarchy: bool
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Default value is "application/json".
        :paramtype content_type: str
        :keyword bool stream: Whether to stream the response of this operation. Defaults to False. You
         will have to context manage the returned stream.
        :return: AtlasGlossaryTerm. The AtlasGlossaryTerm is compatible with MutableMapping
        :rtype: ~azure.purview.datamap.models.AtlasGlossaryTerm
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @distributed_trace_async
    async def update_term(
        self,
        term_guid: str,
        glossary_term: Union[_models.AtlasGlossaryTerm, JSON, IO[bytes]],
        *,
        include_term_hierarchy: Optional[bool] = None,
        **kwargs: Any
    ) -> _models.AtlasGlossaryTerm:
        """Update the given glossary term by its GUID.

        :param term_guid: The globally unique identifier for glossary term. Required.
        :type term_guid: str
        :param glossary_term: The glossary term to be updated. Is one of the following types:
         AtlasGlossaryTerm, JSON, IO[bytes] Required.
        :type glossary_term: ~azure.purview.datamap.models.AtlasGlossaryTerm or JSON or IO[bytes]
        :keyword include_term_hierarchy: Whether include term hierarchy. Default value is None.
        :paramtype include_term_hierarchy: bool
        :keyword content_type: Body parameter Content-Type. Known values are: application/json. Default
         value is None.
        :paramtype content_type: str
        :keyword bool stream: Whether to stream the response of this operation. Defaults to False. You
         will have to context manage the returned stream.
        :return: AtlasGlossaryTerm. The AtlasGlossaryTerm is compatible with MutableMapping
        :rtype: ~azure.purview.datamap.models.AtlasGlossaryTerm
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[_models.AtlasGlossaryTerm] = kwargs.pop("cls", None)

        content_type = content_type or "application/json"
        _content = None
        if isinstance(glossary_term, (IOBase, bytes)):
            _content = glossary_term
        else:
            _content = json.dumps(glossary_term, cls=SdkJSONEncoder, exclude_readonly=True)  # type: ignore

        _request = build_glossary_update_term_request(
            term_guid=term_guid,
            include_term_hierarchy=include_term_hierarchy,
            content_type=content_type,
            api_version=self._config.api_version,
            content=_content,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = kwargs.pop("stream", False)
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                await response.read()  # Load the body in memory and close the socket
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = _deserialize(_models.ErrorResponse, response.json())
            raise HttpResponseError(response=response, model=error)

        if _stream:
            deserialized = response.iter_bytes()
        else:
            deserialized = _deserialize(_models.AtlasGlossaryTerm, response.json())

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore

    @distributed_trace_async
    async def delete_term(  # pylint: disable=inconsistent-return-statements
        self, term_guid: str, **kwargs: Any
    ) -> None:
        """Delete a glossary term.

        :param term_guid: The globally unique identifier for glossary term. Required.
        :type term_guid: str
        :return: None
        :rtype: None
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[None] = kwargs.pop("cls", None)

        _request = build_glossary_delete_term_request(
            term_guid=term_guid,
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = False
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [204]:
            if _stream:
                await response.read()  # Load the body in memory and close the socket
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = _deserialize(_models.ErrorResponse, response.json())
            raise HttpResponseError(response=response, model=error)

        if cls:
            return cls(pipeline_response, None, {})  # type: ignore

    @distributed_trace_async
    async def partial_update_term(
        self, term_guid: str, partial_updates: Any, *, include_term_hierarchy: Optional[bool] = None, **kwargs: Any
    ) -> _models.AtlasGlossaryTerm:
        """Update the glossary term partially. So far we only supports partial updating
        shortDescription, longDescription, abbreviation, usage and status for term.

        :param term_guid: The globally unique identifier for glossary term. Required.
        :type term_guid: str
        :param partial_updates: A map containing keys as attribute names and values as corresponding
         attribute
         values to be updated. Required.
        :type partial_updates: any
        :keyword include_term_hierarchy: Whether include term hierarchy. Default value is None.
        :paramtype include_term_hierarchy: bool
        :keyword content_type: Body parameter Content-Type. Known values are: application/json. Default
         value is "application/json".
        :paramtype content_type: str
        :keyword bool stream: Whether to stream the response of this operation. Defaults to False. You
         will have to context manage the returned stream.
        :return: AtlasGlossaryTerm. The AtlasGlossaryTerm is compatible with MutableMapping
        :rtype: ~azure.purview.datamap.models.AtlasGlossaryTerm
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: str = kwargs.pop("content_type", _headers.pop("Content-Type", "application/json"))
        cls: ClsType[_models.AtlasGlossaryTerm] = kwargs.pop("cls", None)

        _content = json.dumps(partial_updates, cls=SdkJSONEncoder, exclude_readonly=True)  # type: ignore

        _request = build_glossary_partial_update_term_request(
            term_guid=term_guid,
            include_term_hierarchy=include_term_hierarchy,
            content_type=content_type,
            api_version=self._config.api_version,
            content=_content,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = kwargs.pop("stream", False)
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                await response.read()  # Load the body in memory and close the socket
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = _deserialize(_models.ErrorResponse, response.json())
            raise HttpResponseError(response=response, model=error)

        if _stream:
            deserialized = response.iter_bytes()
        else:
            deserialized = _deserialize(_models.AtlasGlossaryTerm, response.json())

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore

    @overload
    async def create_terms(
        self,
        glossary_term: List[_models.AtlasGlossaryTerm],
        *,
        include_term_hierarchy: Optional[bool] = None,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> List[_models.AtlasGlossaryTerm]:
        """Create glossary terms in bulk.

        :param glossary_term: An array of glossary term definitions to be created in bulk. Required.
        :type glossary_term: list[~azure.purview.datamap.models.AtlasGlossaryTerm]
        :keyword include_term_hierarchy: Whether include term hierarchy. Default value is None.
        :paramtype include_term_hierarchy: bool
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :keyword bool stream: Whether to stream the response of this operation. Defaults to False. You
         will have to context manage the returned stream.
        :return: list of AtlasGlossaryTerm
        :rtype: list[~azure.purview.datamap.models.AtlasGlossaryTerm]
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @overload
    async def create_terms(
        self,
        glossary_term: IO[bytes],
        *,
        include_term_hierarchy: Optional[bool] = None,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> List[_models.AtlasGlossaryTerm]:
        """Create glossary terms in bulk.

        :param glossary_term: An array of glossary term definitions to be created in bulk. Required.
        :type glossary_term: IO[bytes]
        :keyword include_term_hierarchy: Whether include term hierarchy. Default value is None.
        :paramtype include_term_hierarchy: bool
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Default value is "application/json".
        :paramtype content_type: str
        :keyword bool stream: Whether to stream the response of this operation. Defaults to False. You
         will have to context manage the returned stream.
        :return: list of AtlasGlossaryTerm
        :rtype: list[~azure.purview.datamap.models.AtlasGlossaryTerm]
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @distributed_trace_async
    async def create_terms(
        self,
        glossary_term: Union[List[_models.AtlasGlossaryTerm], IO[bytes]],
        *,
        include_term_hierarchy: Optional[bool] = None,
        **kwargs: Any
    ) -> List[_models.AtlasGlossaryTerm]:
        """Create glossary terms in bulk.

        :param glossary_term: An array of glossary term definitions to be created in bulk. Is either a
         [AtlasGlossaryTerm] type or a IO[bytes] type. Required.
        :type glossary_term: list[~azure.purview.datamap.models.AtlasGlossaryTerm] or IO[bytes]
        :keyword include_term_hierarchy: Whether include term hierarchy. Default value is None.
        :paramtype include_term_hierarchy: bool
        :keyword content_type: Body parameter Content-Type. Known values are: application/json. Default
         value is None.
        :paramtype content_type: str
        :keyword bool stream: Whether to stream the response of this operation. Defaults to False. You
         will have to context manage the returned stream.
        :return: list of AtlasGlossaryTerm
        :rtype: list[~azure.purview.datamap.models.AtlasGlossaryTerm]
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[List[_models.AtlasGlossaryTerm]] = kwargs.pop("cls", None)

        content_type = content_type or "application/json"
        _content = None
        if isinstance(glossary_term, (IOBase, bytes)):
            _content = glossary_term
        else:
            _content = json.dumps(glossary_term, cls=SdkJSONEncoder, exclude_readonly=True)  # type: ignore

        _request = build_glossary_create_terms_request(
            include_term_hierarchy=include_term_hierarchy,
            content_type=content_type,
            api_version=self._config.api_version,
            content=_content,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = kwargs.pop("stream", False)
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                await response.read()  # Load the body in memory and close the socket
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = _deserialize(_models.ErrorResponse, response.json())
            raise HttpResponseError(response=response, model=error)

        if _stream:
            deserialized = response.iter_bytes()
        else:
            deserialized = _deserialize(List[_models.AtlasGlossaryTerm], response.json())

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore

    @distributed_trace_async
    async def list_entities_assigned_with_term(
        self,
        term_guid: str,
        *,
        limit: Optional[int] = None,
        offset: Optional[int] = None,
        sort: Optional[str] = None,
        **kwargs: Any
    ) -> List[_models.AtlasRelatedObjectId]:
        """List all related objects assigned with the specified term. Recommend using
        limit/offset to get pagination result.

        :param term_guid: The globally unique identifier for glossary term. Required.
        :type term_guid: str
        :keyword limit: The page size - by default there is no paging. Default value is None.
        :paramtype limit: int
        :keyword offset: The offset for pagination purpose. Default value is None.
        :paramtype offset: int
        :keyword sort: The sort order, ASC (default) or DESC. Default value is None.
        :paramtype sort: str
        :keyword bool stream: Whether to stream the response of this operation. Defaults to False. You
         will have to context manage the returned stream.
        :return: list of AtlasRelatedObjectId
        :rtype: list[~azure.purview.datamap.models.AtlasRelatedObjectId]
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[List[_models.AtlasRelatedObjectId]] = kwargs.pop("cls", None)

        _request = build_glossary_list_entities_assigned_with_term_request(
            term_guid=term_guid,
            limit=limit,
            offset=offset,
            sort=sort,
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = kwargs.pop("stream", False)
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                await response.read()  # Load the body in memory and close the socket
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = _deserialize(_models.ErrorResponse, response.json())
            raise HttpResponseError(response=response, model=error)

        if _stream:
            deserialized = response.iter_bytes()
        else:
            deserialized = _deserialize(List[_models.AtlasRelatedObjectId], response.json())

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore

    @overload
    async def assign_term_to_entities(  # pylint: disable=inconsistent-return-statements
        self,
        term_guid: str,
        related_object_ids: List[_models.AtlasRelatedObjectId],
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> None:
        """Assign the given term to the provided list of related objects. Recommend using
        small batches with multiple API calls.

        `Entities Create Or Update
        operation
        <https://learn.microsoft.com/en-us/rest/api/purview/datamapdataplane/entity/bulk-create-or-update?tabs=HTTP>`_
        is an alternative to assign a term to multiple entities.

        :param term_guid: The globally unique identifier for glossary term. Required.
        :type term_guid: str
        :param related_object_ids: An array of related object IDs to which the term has to be
         associated. Required.
        :type related_object_ids: list[~azure.purview.datamap.models.AtlasRelatedObjectId]
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: None
        :rtype: None
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @overload
    async def assign_term_to_entities(  # pylint: disable=inconsistent-return-statements
        self, term_guid: str, related_object_ids: IO[bytes], *, content_type: str = "application/json", **kwargs: Any
    ) -> None:
        """Assign the given term to the provided list of related objects. Recommend using
        small batches with multiple API calls.

        `Entities Create Or Update
        operation
        <https://learn.microsoft.com/en-us/rest/api/purview/datamapdataplane/entity/bulk-create-or-update?tabs=HTTP>`_
        is an alternative to assign a term to multiple entities.

        :param term_guid: The globally unique identifier for glossary term. Required.
        :type term_guid: str
        :param related_object_ids: An array of related object IDs to which the term has to be
         associated. Required.
        :type related_object_ids: IO[bytes]
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: None
        :rtype: None
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @distributed_trace_async
    async def assign_term_to_entities(  # pylint: disable=inconsistent-return-statements
        self, term_guid: str, related_object_ids: Union[List[_models.AtlasRelatedObjectId], IO[bytes]], **kwargs: Any
    ) -> None:
        """Assign the given term to the provided list of related objects. Recommend using
        small batches with multiple API calls.

        `Entities Create Or Update
        operation
        <https://learn.microsoft.com/en-us/rest/api/purview/datamapdataplane/entity/bulk-create-or-update?tabs=HTTP>`_
        is an alternative to assign a term to multiple entities.

        :param term_guid: The globally unique identifier for glossary term. Required.
        :type term_guid: str
        :param related_object_ids: An array of related object IDs to which the term has to be
         associated. Is either a [AtlasRelatedObjectId] type or a IO[bytes] type. Required.
        :type related_object_ids: list[~azure.purview.datamap.models.AtlasRelatedObjectId] or IO[bytes]
        :keyword content_type: Body parameter Content-Type. Known values are: application/json. Default
         value is None.
        :paramtype content_type: str
        :return: None
        :rtype: None
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[None] = kwargs.pop("cls", None)

        content_type = content_type or "application/json"
        _content = None
        if isinstance(related_object_ids, (IOBase, bytes)):
            _content = related_object_ids
        else:
            _content = json.dumps(related_object_ids, cls=SdkJSONEncoder, exclude_readonly=True)  # type: ignore

        _request = build_glossary_assign_term_to_entities_request(
            term_guid=term_guid,
            content_type=content_type,
            api_version=self._config.api_version,
            content=_content,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = False
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [204]:
            if _stream:
                await response.read()  # Load the body in memory and close the socket
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = _deserialize(_models.ErrorResponse, response.json())
            raise HttpResponseError(response=response, model=error)

        if cls:
            return cls(pipeline_response, None, {})  # type: ignore

    @overload
    async def delete_term_assignment_from_entities(  # pylint: disable=inconsistent-return-statements
        self,
        term_guid: str,
        related_object_ids: List[_models.AtlasRelatedObjectId],
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> None:
        """Delete the term assignment for the given list of related objects.

        :param term_guid: The globally unique identifier for glossary term. Required.
        :type term_guid: str
        :param related_object_ids: An array of related object IDs from which the term has to be
         dissociated. Required.
        :type related_object_ids: list[~azure.purview.datamap.models.AtlasRelatedObjectId]
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: None
        :rtype: None
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @overload
    async def delete_term_assignment_from_entities(  # pylint: disable=inconsistent-return-statements
        self, term_guid: str, related_object_ids: IO[bytes], *, content_type: str = "application/json", **kwargs: Any
    ) -> None:
        """Delete the term assignment for the given list of related objects.

        :param term_guid: The globally unique identifier for glossary term. Required.
        :type term_guid: str
        :param related_object_ids: An array of related object IDs from which the term has to be
         dissociated. Required.
        :type related_object_ids: IO[bytes]
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: None
        :rtype: None
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @distributed_trace_async
    async def delete_term_assignment_from_entities(  # pylint: disable=inconsistent-return-statements
        self, term_guid: str, related_object_ids: Union[List[_models.AtlasRelatedObjectId], IO[bytes]], **kwargs: Any
    ) -> None:
        """Delete the term assignment for the given list of related objects.

        :param term_guid: The globally unique identifier for glossary term. Required.
        :type term_guid: str
        :param related_object_ids: An array of related object IDs from which the term has to be
         dissociated. Is either a [AtlasRelatedObjectId] type or a IO[bytes] type. Required.
        :type related_object_ids: list[~azure.purview.datamap.models.AtlasRelatedObjectId] or IO[bytes]
        :keyword content_type: Body parameter Content-Type. Known values are: application/json. Default
         value is None.
        :paramtype content_type: str
        :return: None
        :rtype: None
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[None] = kwargs.pop("cls", None)

        content_type = content_type or "application/json"
        _content = None
        if isinstance(related_object_ids, (IOBase, bytes)):
            _content = related_object_ids
        else:
            _content = json.dumps(related_object_ids, cls=SdkJSONEncoder, exclude_readonly=True)  # type: ignore

        _request = build_glossary_delete_term_assignment_from_entities_request(
            term_guid=term_guid,
            content_type=content_type,
            api_version=self._config.api_version,
            content=_content,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = False
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [204]:
            if _stream:
                await response.read()  # Load the body in memory and close the socket
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = _deserialize(_models.ErrorResponse, response.json())
            raise HttpResponseError(response=response, model=error)

        if cls:
            return cls(pipeline_response, None, {})  # type: ignore

    @distributed_trace_async
    async def list_related_terms(
        self,
        term_guid: str,
        *,
        limit: Optional[int] = None,
        offset: Optional[int] = None,
        sort: Optional[str] = None,
        **kwargs: Any
    ) -> Dict[str, List[_models.AtlasRelatedTermHeader]]:
        """Get all related terms for a specific term by its GUID. Limit, offset, and sort
        parameters are currently not being enabled and won't work even they are passed.

        :param term_guid: The globally unique identifier for glossary term. Required.
        :type term_guid: str
        :keyword limit: The page size - by default there is no paging. Default value is None.
        :paramtype limit: int
        :keyword offset: The offset for pagination purpose. Default value is None.
        :paramtype offset: int
        :keyword sort: The sort order, ASC (default) or DESC. Default value is None.
        :paramtype sort: str
        :keyword bool stream: Whether to stream the response of this operation. Defaults to False. You
         will have to context manage the returned stream.
        :return: dict mapping str to list of AtlasRelatedTermHeader
        :rtype: dict[str, list[~azure.purview.datamap.models.AtlasRelatedTermHeader]]
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[Dict[str, List[_models.AtlasRelatedTermHeader]]] = kwargs.pop("cls", None)

        _request = build_glossary_list_related_terms_request(
            term_guid=term_guid,
            limit=limit,
            offset=offset,
            sort=sort,
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = kwargs.pop("stream", False)
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                await response.read()  # Load the body in memory and close the socket
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = _deserialize(_models.ErrorResponse, response.json())
            raise HttpResponseError(response=response, model=error)

        if _stream:
            deserialized = response.iter_bytes()
        else:
            deserialized = _deserialize(Dict[str, List[_models.AtlasRelatedTermHeader]], response.json())

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore

    @distributed_trace_async
    async def get(self, glossary_guid: str, **kwargs: Any) -> _models.AtlasGlossary:
        """Get a specific Glossary by its GUID.

        :param glossary_guid: The globally unique identifier for glossary. Required.
        :type glossary_guid: str
        :keyword bool stream: Whether to stream the response of this operation. Defaults to False. You
         will have to context manage the returned stream.
        :return: AtlasGlossary. The AtlasGlossary is compatible with MutableMapping
        :rtype: ~azure.purview.datamap.models.AtlasGlossary
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[_models.AtlasGlossary] = kwargs.pop("cls", None)

        _request = build_glossary_get_request(
            glossary_guid=glossary_guid,
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = kwargs.pop("stream", False)
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                await response.read()  # Load the body in memory and close the socket
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = _deserialize(_models.ErrorResponse, response.json())
            raise HttpResponseError(response=response, model=error)

        if _stream:
            deserialized = response.iter_bytes()
        else:
            deserialized = _deserialize(_models.AtlasGlossary, response.json())

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore

    @overload
    async def update(
        self,
        glossary_guid: str,
        updated_glossary: _models.AtlasGlossary,
        *,
        ignore_terms_and_categories: Optional[bool] = None,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> _models.AtlasGlossary:
        """Update the given glossary.

        :param glossary_guid: The globally unique identifier for glossary. Required.
        :type glossary_guid: str
        :param updated_glossary: The glossary definition to be updated. Required.
        :type updated_glossary: ~azure.purview.datamap.models.AtlasGlossary
        :keyword ignore_terms_and_categories: Whether ignore terms and categories. Default value is
         None.
        :paramtype ignore_terms_and_categories: bool
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :keyword bool stream: Whether to stream the response of this operation. Defaults to False. You
         will have to context manage the returned stream.
        :return: AtlasGlossary. The AtlasGlossary is compatible with MutableMapping
        :rtype: ~azure.purview.datamap.models.AtlasGlossary
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @overload
    async def update(
        self,
        glossary_guid: str,
        updated_glossary: JSON,
        *,
        ignore_terms_and_categories: Optional[bool] = None,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> _models.AtlasGlossary:
        """Update the given glossary.

        :param glossary_guid: The globally unique identifier for glossary. Required.
        :type glossary_guid: str
        :param updated_glossary: The glossary definition to be updated. Required.
        :type updated_glossary: JSON
        :keyword ignore_terms_and_categories: Whether ignore terms and categories. Default value is
         None.
        :paramtype ignore_terms_and_categories: bool
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :keyword bool stream: Whether to stream the response of this operation. Defaults to False. You
         will have to context manage the returned stream.
        :return: AtlasGlossary. The AtlasGlossary is compatible with MutableMapping
        :rtype: ~azure.purview.datamap.models.AtlasGlossary
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @overload
    async def update(
        self,
        glossary_guid: str,
        updated_glossary: IO[bytes],
        *,
        ignore_terms_and_categories: Optional[bool] = None,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> _models.AtlasGlossary:
        """Update the given glossary.

        :param glossary_guid: The globally unique identifier for glossary. Required.
        :type glossary_guid: str
        :param updated_glossary: The glossary definition to be updated. Required.
        :type updated_glossary: IO[bytes]
        :keyword ignore_terms_and_categories: Whether ignore terms and categories. Default value is
         None.
        :paramtype ignore_terms_and_categories: bool
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Default value is "application/json".
        :paramtype content_type: str
        :keyword bool stream: Whether to stream the response of this operation. Defaults to False. You
         will have to context manage the returned stream.
        :return: AtlasGlossary. The AtlasGlossary is compatible with MutableMapping
        :rtype: ~azure.purview.datamap.models.AtlasGlossary
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @distributed_trace_async
    async def update(
        self,
        glossary_guid: str,
        updated_glossary: Union[_models.AtlasGlossary, JSON, IO[bytes]],
        *,
        ignore_terms_and_categories: Optional[bool] = None,
        **kwargs: Any
    ) -> _models.AtlasGlossary:
        """Update the given glossary.

        :param glossary_guid: The globally unique identifier for glossary. Required.
        :type glossary_guid: str
        :param updated_glossary: The glossary definition to be updated. Is one of the following types:
         AtlasGlossary, JSON, IO[bytes] Required.
        :type updated_glossary: ~azure.purview.datamap.models.AtlasGlossary or JSON or IO[bytes]
        :keyword ignore_terms_and_categories: Whether ignore terms and categories. Default value is
         None.
        :paramtype ignore_terms_and_categories: bool
        :keyword content_type: Body parameter Content-Type. Known values are: application/json. Default
         value is None.
        :paramtype content_type: str
        :keyword bool stream: Whether to stream the response of this operation. Defaults to False. You
         will have to context manage the returned stream.
        :return: AtlasGlossary. The AtlasGlossary is compatible with MutableMapping
        :rtype: ~azure.purview.datamap.models.AtlasGlossary
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[_models.AtlasGlossary] = kwargs.pop("cls", None)

        content_type = content_type or "application/json"
        _content = None
        if isinstance(updated_glossary, (IOBase, bytes)):
            _content = updated_glossary
        else:
            _content = json.dumps(updated_glossary, cls=SdkJSONEncoder, exclude_readonly=True)  # type: ignore

        _request = build_glossary_update_request(
            glossary_guid=glossary_guid,
            ignore_terms_and_categories=ignore_terms_and_categories,
            content_type=content_type,
            api_version=self._config.api_version,
            content=_content,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = kwargs.pop("stream", False)
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                await response.read()  # Load the body in memory and close the socket
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = _deserialize(_models.ErrorResponse, response.json())
            raise HttpResponseError(response=response, model=error)

        if _stream:
            deserialized = response.iter_bytes()
        else:
            deserialized = _deserialize(_models.AtlasGlossary, response.json())

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore

    @distributed_trace_async
    async def delete(self, glossary_guid: str, **kwargs: Any) -> None:  # pylint: disable=inconsistent-return-statements
        """Delete a glossary. Will delete underlying terms/categories together. Recommend
        separate delete terms and categories.

        :param glossary_guid: The globally unique identifier for glossary. Required.
        :type glossary_guid: str
        :return: None
        :rtype: None
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[None] = kwargs.pop("cls", None)

        _request = build_glossary_delete_request(
            glossary_guid=glossary_guid,
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = False
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [204]:
            if _stream:
                await response.read()  # Load the body in memory and close the socket
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = _deserialize(_models.ErrorResponse, response.json())
            raise HttpResponseError(response=response, model=error)

        if cls:
            return cls(pipeline_response, None, {})  # type: ignore

    @distributed_trace_async
    async def list_categories(
        self,
        glossary_guid: str,
        *,
        limit: Optional[int] = None,
        offset: Optional[int] = None,
        sort: Optional[str] = None,
        **kwargs: Any
    ) -> List[_models.AtlasGlossaryCategory]:
        """Get the categories belonging to a specific glossary. Recommend using
        limit/offset to get pagination result.

        :param glossary_guid: The globally unique identifier for glossary. Required.
        :type glossary_guid: str
        :keyword limit: The page size - by default there is no paging. Default value is None.
        :paramtype limit: int
        :keyword offset: The offset for pagination purpose. Default value is None.
        :paramtype offset: int
        :keyword sort: The sort order, ASC (default) or DESC. Default value is None.
        :paramtype sort: str
        :keyword bool stream: Whether to stream the response of this operation. Defaults to False. You
         will have to context manage the returned stream.
        :return: list of AtlasGlossaryCategory
        :rtype: list[~azure.purview.datamap.models.AtlasGlossaryCategory]
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[List[_models.AtlasGlossaryCategory]] = kwargs.pop("cls", None)

        _request = build_glossary_list_categories_request(
            glossary_guid=glossary_guid,
            limit=limit,
            offset=offset,
            sort=sort,
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = kwargs.pop("stream", False)
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                await response.read()  # Load the body in memory and close the socket
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = _deserialize(_models.ErrorResponse, response.json())
            raise HttpResponseError(response=response, model=error)

        if _stream:
            deserialized = response.iter_bytes()
        else:
            deserialized = _deserialize(List[_models.AtlasGlossaryCategory], response.json())

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore

    @distributed_trace_async
    async def list_categories_headers(
        self,
        glossary_guid: str,
        *,
        limit: Optional[int] = None,
        offset: Optional[int] = None,
        sort: Optional[str] = None,
        **kwargs: Any
    ) -> List[_models.AtlasRelatedCategoryHeader]:
        """Get the category headers belonging to a specific glossary. Recommend using
        limit/offset to get pagination result.

        :param glossary_guid: The globally unique identifier for glossary. Required.
        :type glossary_guid: str
        :keyword limit: The page size - by default there is no paging. Default value is None.
        :paramtype limit: int
        :keyword offset: The offset for pagination purpose. Default value is None.
        :paramtype offset: int
        :keyword sort: The sort order, ASC (default) or DESC. Default value is None.
        :paramtype sort: str
        :keyword bool stream: Whether to stream the response of this operation. Defaults to False. You
         will have to context manage the returned stream.
        :return: list of AtlasRelatedCategoryHeader
        :rtype: list[~azure.purview.datamap.models.AtlasRelatedCategoryHeader]
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[List[_models.AtlasRelatedCategoryHeader]] = kwargs.pop("cls", None)

        _request = build_glossary_list_categories_headers_request(
            glossary_guid=glossary_guid,
            limit=limit,
            offset=offset,
            sort=sort,
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = kwargs.pop("stream", False)
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                await response.read()  # Load the body in memory and close the socket
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = _deserialize(_models.ErrorResponse, response.json())
            raise HttpResponseError(response=response, model=error)

        if _stream:
            deserialized = response.iter_bytes()
        else:
            deserialized = _deserialize(List[_models.AtlasRelatedCategoryHeader], response.json())

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore

    @distributed_trace_async
    async def get_detailed(self, glossary_guid: str, **kwargs: Any) -> _models.AtlasGlossaryExtInfo:
        """Get a specific glossary with detailed information. This API is not
        recommend.

        Recommend to fetch terms/categories details separately using

        GET /datamap/api/atlas/v2/glossary/{glossaryGuid}/terms and

        GET /datamap/api/atlas/v2/glossary/{glossaryGuid}/categories.

        :param glossary_guid: The globally unique identifier for glossary. Required.
        :type glossary_guid: str
        :keyword bool stream: Whether to stream the response of this operation. Defaults to False. You
         will have to context manage the returned stream.
        :return: AtlasGlossaryExtInfo. The AtlasGlossaryExtInfo is compatible with MutableMapping
        :rtype: ~azure.purview.datamap.models.AtlasGlossaryExtInfo
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[_models.AtlasGlossaryExtInfo] = kwargs.pop("cls", None)

        _request = build_glossary_get_detailed_request(
            glossary_guid=glossary_guid,
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = kwargs.pop("stream", False)
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                await response.read()  # Load the body in memory and close the socket
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = _deserialize(_models.ErrorResponse, response.json())
            raise HttpResponseError(response=response, model=error)

        if _stream:
            deserialized = response.iter_bytes()
        else:
            deserialized = _deserialize(_models.AtlasGlossaryExtInfo, response.json())

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore

    @distributed_trace_async
    async def partial_update(
        self,
        glossary_guid: str,
        partial_updates: Any,
        *,
        ignore_terms_and_categories: Optional[bool] = None,
        **kwargs: Any
    ) -> _models.AtlasGlossary:
        """Update the glossary partially. Some properties such as qualifiedName are not
        allowed to be updated.

        So far we only supports partial updating
        shortDescription, longDescription, language and usage for glossary.

        Recommend
        using 'ignoreTermsAndCategories=true' to reduce response body size.

        :param glossary_guid: The globally unique identifier for glossary. Required.
        :type glossary_guid: str
        :param partial_updates: A map containing keys as attribute names and values as corresponding
         attribute
         values. Required.
        :type partial_updates: any
        :keyword ignore_terms_and_categories: Whether ignore terms and categories. Default value is
         None.
        :paramtype ignore_terms_and_categories: bool
        :keyword content_type: Body parameter Content-Type. Known values are: application/json. Default
         value is "application/json".
        :paramtype content_type: str
        :keyword bool stream: Whether to stream the response of this operation. Defaults to False. You
         will have to context manage the returned stream.
        :return: AtlasGlossary. The AtlasGlossary is compatible with MutableMapping
        :rtype: ~azure.purview.datamap.models.AtlasGlossary
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: str = kwargs.pop("content_type", _headers.pop("Content-Type", "application/json"))
        cls: ClsType[_models.AtlasGlossary] = kwargs.pop("cls", None)

        _content = json.dumps(partial_updates, cls=SdkJSONEncoder, exclude_readonly=True)  # type: ignore

        _request = build_glossary_partial_update_request(
            glossary_guid=glossary_guid,
            ignore_terms_and_categories=ignore_terms_and_categories,
            content_type=content_type,
            api_version=self._config.api_version,
            content=_content,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = kwargs.pop("stream", False)
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                await response.read()  # Load the body in memory and close the socket
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = _deserialize(_models.ErrorResponse, response.json())
            raise HttpResponseError(response=response, model=error)

        if _stream:
            deserialized = response.iter_bytes()
        else:
            deserialized = _deserialize(_models.AtlasGlossary, response.json())

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore

    @distributed_trace_async
    async def list_terms(
        self,
        glossary_guid: str,
        *,
        limit: Optional[int] = None,
        offset: Optional[int] = None,
        sort: Optional[str] = None,
        **kwargs: Any
    ) -> List[_models.AtlasGlossaryTerm]:
        """Get terms belonging to a specific glossary. Recommend using limit/offset to get
        pagination result.

        :param glossary_guid: The globally unique identifier for glossary. Required.
        :type glossary_guid: str
        :keyword limit: The page size - by default there is no paging. Default value is None.
        :paramtype limit: int
        :keyword offset: The offset for pagination purpose. Default value is None.
        :paramtype offset: int
        :keyword sort: The sort order, ASC (default) or DESC. Default value is None.
        :paramtype sort: str
        :keyword bool stream: Whether to stream the response of this operation. Defaults to False. You
         will have to context manage the returned stream.
        :return: list of AtlasGlossaryTerm
        :rtype: list[~azure.purview.datamap.models.AtlasGlossaryTerm]
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[List[_models.AtlasGlossaryTerm]] = kwargs.pop("cls", None)

        _request = build_glossary_list_terms_request(
            glossary_guid=glossary_guid,
            limit=limit,
            offset=offset,
            sort=sort,
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = kwargs.pop("stream", False)
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                await response.read()  # Load the body in memory and close the socket
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = _deserialize(_models.ErrorResponse, response.json())
            raise HttpResponseError(response=response, model=error)

        if _stream:
            deserialized = response.iter_bytes()
        else:
            deserialized = _deserialize(List[_models.AtlasGlossaryTerm], response.json())

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore

    @distributed_trace_async
    async def list_term_headers(
        self,
        glossary_guid: str,
        *,
        limit: Optional[int] = None,
        offset: Optional[int] = None,
        sort: Optional[str] = None,
        **kwargs: Any
    ) -> List[_models.AtlasRelatedTermHeader]:
        """Get term headers belonging to a specific glossary. Recommend using limit/offset
        to get pagination result.

        :param glossary_guid: The globally unique identifier for glossary. Required.
        :type glossary_guid: str
        :keyword limit: The page size - by default there is no paging. Default value is None.
        :paramtype limit: int
        :keyword offset: The offset for pagination purpose. Default value is None.
        :paramtype offset: int
        :keyword sort: The sort order, ASC (default) or DESC. Default value is None.
        :paramtype sort: str
        :keyword bool stream: Whether to stream the response of this operation. Defaults to False. You
         will have to context manage the returned stream.
        :return: list of AtlasRelatedTermHeader
        :rtype: list[~azure.purview.datamap.models.AtlasRelatedTermHeader]
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[List[_models.AtlasRelatedTermHeader]] = kwargs.pop("cls", None)

        _request = build_glossary_list_term_headers_request(
            glossary_guid=glossary_guid,
            limit=limit,
            offset=offset,
            sort=sort,
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = kwargs.pop("stream", False)
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                await response.read()  # Load the body in memory and close the socket
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = _deserialize(_models.ErrorResponse, response.json())
            raise HttpResponseError(response=response, model=error)

        if _stream:
            deserialized = response.iter_bytes()
        else:
            deserialized = _deserialize(List[_models.AtlasRelatedTermHeader], response.json())

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore


class DiscoveryOperations:
    """
    .. warning::
        **DO NOT** instantiate this class directly.

        Instead, you should access the following operations through
        :class:`~azure.purview.datamap.aio.PurviewDataMapClient`'s
        :attr:`discovery` attribute.
    """

    def __init__(self, *args, **kwargs) -> None:
        input_args = list(args)
        self._client = input_args.pop(0) if input_args else kwargs.pop("client")
        self._config = input_args.pop(0) if input_args else kwargs.pop("config")
        self._serialize = input_args.pop(0) if input_args else kwargs.pop("serializer")
        self._deserialize = input_args.pop(0) if input_args else kwargs.pop("deserializer")

    @overload
    async def query(
        self, search_request: _models.SearchRequest, *, content_type: str = "application/json", **kwargs: Any
    ) -> _models.SearchResult:
        """Get data using search.

        :param search_request: An object specifying the search criteria. Required.
        :type search_request: ~azure.purview.datamap.models.SearchRequest
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :keyword bool stream: Whether to stream the response of this operation. Defaults to False. You
         will have to context manage the returned stream.
        :return: SearchResult. The SearchResult is compatible with MutableMapping
        :rtype: ~azure.purview.datamap.models.SearchResult
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @overload
    async def query(
        self, search_request: JSON, *, content_type: str = "application/json", **kwargs: Any
    ) -> _models.SearchResult:
        """Get data using search.

        :param search_request: An object specifying the search criteria. Required.
        :type search_request: JSON
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :keyword bool stream: Whether to stream the response of this operation. Defaults to False. You
         will have to context manage the returned stream.
        :return: SearchResult. The SearchResult is compatible with MutableMapping
        :rtype: ~azure.purview.datamap.models.SearchResult
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @overload
    async def query(
        self, search_request: IO[bytes], *, content_type: str = "application/json", **kwargs: Any
    ) -> _models.SearchResult:
        """Get data using search.

        :param search_request: An object specifying the search criteria. Required.
        :type search_request: IO[bytes]
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Default value is "application/json".
        :paramtype content_type: str
        :keyword bool stream: Whether to stream the response of this operation. Defaults to False. You
         will have to context manage the returned stream.
        :return: SearchResult. The SearchResult is compatible with MutableMapping
        :rtype: ~azure.purview.datamap.models.SearchResult
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @distributed_trace_async
    async def query(
        self, search_request: Union[_models.SearchRequest, JSON, IO[bytes]], **kwargs: Any
    ) -> _models.SearchResult:
        """Get data using search.

        :param search_request: An object specifying the search criteria. Is one of the following types:
         SearchRequest, JSON, IO[bytes] Required.
        :type search_request: ~azure.purview.datamap.models.SearchRequest or JSON or IO[bytes]
        :keyword content_type: Body parameter Content-Type. Known values are: application/json. Default
         value is None.
        :paramtype content_type: str
        :keyword bool stream: Whether to stream the response of this operation. Defaults to False. You
         will have to context manage the returned stream.
        :return: SearchResult. The SearchResult is compatible with MutableMapping
        :rtype: ~azure.purview.datamap.models.SearchResult
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[_models.SearchResult] = kwargs.pop("cls", None)

        content_type = content_type or "application/json"
        _content = None
        if isinstance(search_request, (IOBase, bytes)):
            _content = search_request
        else:
            _content = json.dumps(search_request, cls=SdkJSONEncoder, exclude_readonly=True)  # type: ignore

        _request = build_discovery_query_request(
            content_type=content_type,
            api_version=self._config.api_version,
            content=_content,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = kwargs.pop("stream", False)
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                await response.read()  # Load the body in memory and close the socket
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = _deserialize(_models.ErrorResponse, response.json())
            raise HttpResponseError(response=response, model=error)

        if _stream:
            deserialized = response.iter_bytes()
        else:
            deserialized = _deserialize(_models.SearchResult, response.json())

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore

    @overload
    async def suggest(
        self, suggest_request: _models.SuggestRequest, *, content_type: str = "application/json", **kwargs: Any
    ) -> _models.SuggestResult:
        """Get search suggestions by query criteria.

        :param suggest_request: An object specifying the suggest criteria. Required.
        :type suggest_request: ~azure.purview.datamap.models.SuggestRequest
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :keyword bool stream: Whether to stream the response of this operation. Defaults to False. You
         will have to context manage the returned stream.
        :return: SuggestResult. The SuggestResult is compatible with MutableMapping
        :rtype: ~azure.purview.datamap.models.SuggestResult
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @overload
    async def suggest(
        self, suggest_request: JSON, *, content_type: str = "application/json", **kwargs: Any
    ) -> _models.SuggestResult:
        """Get search suggestions by query criteria.

        :param suggest_request: An object specifying the suggest criteria. Required.
        :type suggest_request: JSON
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :keyword bool stream: Whether to stream the response of this operation. Defaults to False. You
         will have to context manage the returned stream.
        :return: SuggestResult. The SuggestResult is compatible with MutableMapping
        :rtype: ~azure.purview.datamap.models.SuggestResult
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @overload
    async def suggest(
        self, suggest_request: IO[bytes], *, content_type: str = "application/json", **kwargs: Any
    ) -> _models.SuggestResult:
        """Get search suggestions by query criteria.

        :param suggest_request: An object specifying the suggest criteria. Required.
        :type suggest_request: IO[bytes]
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Default value is "application/json".
        :paramtype content_type: str
        :keyword bool stream: Whether to stream the response of this operation. Defaults to False. You
         will have to context manage the returned stream.
        :return: SuggestResult. The SuggestResult is compatible with MutableMapping
        :rtype: ~azure.purview.datamap.models.SuggestResult
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @distributed_trace_async
    async def suggest(
        self, suggest_request: Union[_models.SuggestRequest, JSON, IO[bytes]], **kwargs: Any
    ) -> _models.SuggestResult:
        """Get search suggestions by query criteria.

        :param suggest_request: An object specifying the suggest criteria. Is one of the following
         types: SuggestRequest, JSON, IO[bytes] Required.
        :type suggest_request: ~azure.purview.datamap.models.SuggestRequest or JSON or IO[bytes]
        :keyword content_type: Body parameter Content-Type. Known values are: application/json. Default
         value is None.
        :paramtype content_type: str
        :keyword bool stream: Whether to stream the response of this operation. Defaults to False. You
         will have to context manage the returned stream.
        :return: SuggestResult. The SuggestResult is compatible with MutableMapping
        :rtype: ~azure.purview.datamap.models.SuggestResult
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[_models.SuggestResult] = kwargs.pop("cls", None)

        content_type = content_type or "application/json"
        _content = None
        if isinstance(suggest_request, (IOBase, bytes)):
            _content = suggest_request
        else:
            _content = json.dumps(suggest_request, cls=SdkJSONEncoder, exclude_readonly=True)  # type: ignore

        _request = build_discovery_suggest_request(
            content_type=content_type,
            api_version=self._config.api_version,
            content=_content,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = kwargs.pop("stream", False)
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                await response.read()  # Load the body in memory and close the socket
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = _deserialize(_models.ErrorResponse, response.json())
            raise HttpResponseError(response=response, model=error)

        if _stream:
            deserialized = response.iter_bytes()
        else:
            deserialized = _deserialize(_models.SuggestResult, response.json())

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore

    @overload
    async def auto_complete(
        self,
        auto_complete_request: _models.AutoCompleteRequest,
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> _models.AutoCompleteResult:
        """Get auto complete options.

        :param auto_complete_request: An object specifying the autocomplete criteria. Required.
        :type auto_complete_request: ~azure.purview.datamap.models.AutoCompleteRequest
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :keyword bool stream: Whether to stream the response of this operation. Defaults to False. You
         will have to context manage the returned stream.
        :return: AutoCompleteResult. The AutoCompleteResult is compatible with MutableMapping
        :rtype: ~azure.purview.datamap.models.AutoCompleteResult
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @overload
    async def auto_complete(
        self, auto_complete_request: JSON, *, content_type: str = "application/json", **kwargs: Any
    ) -> _models.AutoCompleteResult:
        """Get auto complete options.

        :param auto_complete_request: An object specifying the autocomplete criteria. Required.
        :type auto_complete_request: JSON
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :keyword bool stream: Whether to stream the response of this operation. Defaults to False. You
         will have to context manage the returned stream.
        :return: AutoCompleteResult. The AutoCompleteResult is compatible with MutableMapping
        :rtype: ~azure.purview.datamap.models.AutoCompleteResult
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @overload
    async def auto_complete(
        self, auto_complete_request: IO[bytes], *, content_type: str = "application/json", **kwargs: Any
    ) -> _models.AutoCompleteResult:
        """Get auto complete options.

        :param auto_complete_request: An object specifying the autocomplete criteria. Required.
        :type auto_complete_request: IO[bytes]
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Default value is "application/json".
        :paramtype content_type: str
        :keyword bool stream: Whether to stream the response of this operation. Defaults to False. You
         will have to context manage the returned stream.
        :return: AutoCompleteResult. The AutoCompleteResult is compatible with MutableMapping
        :rtype: ~azure.purview.datamap.models.AutoCompleteResult
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @distributed_trace_async
    async def auto_complete(
        self, auto_complete_request: Union[_models.AutoCompleteRequest, JSON, IO[bytes]], **kwargs: Any
    ) -> _models.AutoCompleteResult:
        """Get auto complete options.

        :param auto_complete_request: An object specifying the autocomplete criteria. Is one of the
         following types: AutoCompleteRequest, JSON, IO[bytes] Required.
        :type auto_complete_request: ~azure.purview.datamap.models.AutoCompleteRequest or JSON or
         IO[bytes]
        :keyword content_type: Body parameter Content-Type. Known values are: application/json. Default
         value is None.
        :paramtype content_type: str
        :keyword bool stream: Whether to stream the response of this operation. Defaults to False. You
         will have to context manage the returned stream.
        :return: AutoCompleteResult. The AutoCompleteResult is compatible with MutableMapping
        :rtype: ~azure.purview.datamap.models.AutoCompleteResult
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[_models.AutoCompleteResult] = kwargs.pop("cls", None)

        content_type = content_type or "application/json"
        _content = None
        if isinstance(auto_complete_request, (IOBase, bytes)):
            _content = auto_complete_request
        else:
            _content = json.dumps(auto_complete_request, cls=SdkJSONEncoder, exclude_readonly=True)  # type: ignore

        _request = build_discovery_auto_complete_request(
            content_type=content_type,
            api_version=self._config.api_version,
            content=_content,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = kwargs.pop("stream", False)
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                await response.read()  # Load the body in memory and close the socket
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = _deserialize(_models.ErrorResponse, response.json())
            raise HttpResponseError(response=response, model=error)

        if _stream:
            deserialized = response.iter_bytes()
        else:
            deserialized = _deserialize(_models.AutoCompleteResult, response.json())

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore


class LineageOperations:
    """
    .. warning::
        **DO NOT** instantiate this class directly.

        Instead, you should access the following operations through
        :class:`~azure.purview.datamap.aio.PurviewDataMapClient`'s
        :attr:`lineage` attribute.
    """

    def __init__(self, *args, **kwargs) -> None:
        input_args = list(args)
        self._client = input_args.pop(0) if input_args else kwargs.pop("client")
        self._config = input_args.pop(0) if input_args else kwargs.pop("config")
        self._serialize = input_args.pop(0) if input_args else kwargs.pop("serializer")
        self._deserialize = input_args.pop(0) if input_args else kwargs.pop("deserializer")

    @distributed_trace_async
    async def get(
        self, guid: str, *, direction: Union[str, _models.Direction], depth: Optional[int] = None, **kwargs: Any
    ) -> _models.AtlasLineageInfo:
        """Get lineage info of the entity specified by GUID.

        :param guid: The globally unique identifier of the entity. Required.
        :type guid: str
        :keyword direction: The direction of the lineage, which could be INPUT, OUTPUT or BOTH. Known
         values are: "BOTH", "INPUT", and "OUTPUT". Required.
        :paramtype direction: str or ~azure.purview.datamap.models.Direction
        :keyword depth: The number of hops for lineage. Default value is None.
        :paramtype depth: int
        :keyword bool stream: Whether to stream the response of this operation. Defaults to False. You
         will have to context manage the returned stream.
        :return: AtlasLineageInfo. The AtlasLineageInfo is compatible with MutableMapping
        :rtype: ~azure.purview.datamap.models.AtlasLineageInfo
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[_models.AtlasLineageInfo] = kwargs.pop("cls", None)

        _request = build_lineage_get_request(
            guid=guid,
            direction=direction,
            depth=depth,
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = kwargs.pop("stream", False)
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                await response.read()  # Load the body in memory and close the socket
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = _deserialize(_models.ErrorResponse, response.json())
            raise HttpResponseError(response=response, model=error)

        if _stream:
            deserialized = response.iter_bytes()
        else:
            deserialized = _deserialize(_models.AtlasLineageInfo, response.json())

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore

    @distributed_trace_async
    async def get_next_page(
        self,
        guid: str,
        *,
        direction: Union[str, _models.Direction],
        offset: Optional[int] = None,
        limit: Optional[int] = None,
        **kwargs: Any
    ) -> _models.AtlasLineageInfo:
        """Return immediate next page lineage info about entity with pagination.

        :param guid: The globally unique identifier of the entity. Required.
        :type guid: str
        :keyword direction: The direction of the lineage, which could be INPUT, OUTPUT or BOTH. Known
         values are: "BOTH", "INPUT", and "OUTPUT". Required.
        :paramtype direction: str or ~azure.purview.datamap.models.Direction
        :keyword offset: The offset for pagination purpose. Default value is None.
        :paramtype offset: int
        :keyword limit: The page size - by default there is no paging. Default value is None.
        :paramtype limit: int
        :keyword bool stream: Whether to stream the response of this operation. Defaults to False. You
         will have to context manage the returned stream.
        :return: AtlasLineageInfo. The AtlasLineageInfo is compatible with MutableMapping
        :rtype: ~azure.purview.datamap.models.AtlasLineageInfo
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[_models.AtlasLineageInfo] = kwargs.pop("cls", None)

        _request = build_lineage_get_next_page_request(
            guid=guid,
            direction=direction,
            offset=offset,
            limit=limit,
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = kwargs.pop("stream", False)
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                await response.read()  # Load the body in memory and close the socket
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = _deserialize(_models.ErrorResponse, response.json())
            raise HttpResponseError(response=response, model=error)

        if _stream:
            deserialized = response.iter_bytes()
        else:
            deserialized = _deserialize(_models.AtlasLineageInfo, response.json())

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore

    @distributed_trace_async
    async def get_by_unique_attribute(
        self,
        type_name: str,
        *,
        direction: Union[str, _models.Direction],
        depth: Optional[int] = None,
        attr: Optional[str] = None,
        **kwargs: Any
    ) -> _models.AtlasLineageInfo:
        """Return lineage info about entity.

        In addition to the typeName path parameter,
        attribute key-value pair(s) can be provided in the following
        format

        attr:[attrName]=[attrValue]

        NOTE: The attrName and attrValue should be
        unique across entities, eg. qualifiedName.

        The REST request would look
        something like this:

        GET
        /v2/lineage/uniqueAttribute/type/aType?attr:aTypeAttribute=someValue.

        :param type_name: The name of the type. Required.
        :type type_name: str
        :keyword direction: The direction of the lineage, which could be INPUT, OUTPUT or BOTH. Known
         values are: "BOTH", "INPUT", and "OUTPUT". Required.
        :paramtype direction: str or ~azure.purview.datamap.models.Direction
        :keyword depth: The number of hops for lineage. Default value is None.
        :paramtype depth: int
        :keyword attr: The qualified name of the entity. (This is only an example. qualifiedName can
         be changed to other unique attributes). Default value is None.
        :paramtype attr: str
        :keyword bool stream: Whether to stream the response of this operation. Defaults to False. You
         will have to context manage the returned stream.
        :return: AtlasLineageInfo. The AtlasLineageInfo is compatible with MutableMapping
        :rtype: ~azure.purview.datamap.models.AtlasLineageInfo
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[_models.AtlasLineageInfo] = kwargs.pop("cls", None)

        _request = build_lineage_get_by_unique_attribute_request(
            type_name=type_name,
            direction=direction,
            depth=depth,
            attr=attr,
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = kwargs.pop("stream", False)
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                await response.read()  # Load the body in memory and close the socket
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = _deserialize(_models.ErrorResponse, response.json())
            raise HttpResponseError(response=response, model=error)

        if _stream:
            deserialized = response.iter_bytes()
        else:
            deserialized = _deserialize(_models.AtlasLineageInfo, response.json())

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore


class RelationshipOperations:
    """
    .. warning::
        **DO NOT** instantiate this class directly.

        Instead, you should access the following operations through
        :class:`~azure.purview.datamap.aio.PurviewDataMapClient`'s
        :attr:`relationship` attribute.
    """

    def __init__(self, *args, **kwargs) -> None:
        input_args = list(args)
        self._client = input_args.pop(0) if input_args else kwargs.pop("client")
        self._config = input_args.pop(0) if input_args else kwargs.pop("config")
        self._serialize = input_args.pop(0) if input_args else kwargs.pop("serializer")
        self._deserialize = input_args.pop(0) if input_args else kwargs.pop("deserializer")

    @overload
    async def create(
        self, relationship: _models.AtlasRelationship, *, content_type: str = "application/json", **kwargs: Any
    ) -> _models.AtlasRelationship:
        """Create a new relationship between entities.

        :param relationship: The AtlasRelationship object containing the information for the
         relationship to
         be created. Required.
        :type relationship: ~azure.purview.datamap.models.AtlasRelationship
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :keyword bool stream: Whether to stream the response of this operation. Defaults to False. You
         will have to context manage the returned stream.
        :return: AtlasRelationship. The AtlasRelationship is compatible with MutableMapping
        :rtype: ~azure.purview.datamap.models.AtlasRelationship
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @overload
    async def create(
        self, relationship: JSON, *, content_type: str = "application/json", **kwargs: Any
    ) -> _models.AtlasRelationship:
        """Create a new relationship between entities.

        :param relationship: The AtlasRelationship object containing the information for the
         relationship to
         be created. Required.
        :type relationship: JSON
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :keyword bool stream: Whether to stream the response of this operation. Defaults to False. You
         will have to context manage the returned stream.
        :return: AtlasRelationship. The AtlasRelationship is compatible with MutableMapping
        :rtype: ~azure.purview.datamap.models.AtlasRelationship
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @overload
    async def create(
        self, relationship: IO[bytes], *, content_type: str = "application/json", **kwargs: Any
    ) -> _models.AtlasRelationship:
        """Create a new relationship between entities.

        :param relationship: The AtlasRelationship object containing the information for the
         relationship to
         be created. Required.
        :type relationship: IO[bytes]
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Default value is "application/json".
        :paramtype content_type: str
        :keyword bool stream: Whether to stream the response of this operation. Defaults to False. You
         will have to context manage the returned stream.
        :return: AtlasRelationship. The AtlasRelationship is compatible with MutableMapping
        :rtype: ~azure.purview.datamap.models.AtlasRelationship
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @distributed_trace_async
    async def create(
        self, relationship: Union[_models.AtlasRelationship, JSON, IO[bytes]], **kwargs: Any
    ) -> _models.AtlasRelationship:
        """Create a new relationship between entities.

        :param relationship: The AtlasRelationship object containing the information for the
         relationship to
         be created. Is one of the following types: AtlasRelationship, JSON, IO[bytes] Required.
        :type relationship: ~azure.purview.datamap.models.AtlasRelationship or JSON or IO[bytes]
        :keyword content_type: Body parameter Content-Type. Known values are: application/json. Default
         value is None.
        :paramtype content_type: str
        :keyword bool stream: Whether to stream the response of this operation. Defaults to False. You
         will have to context manage the returned stream.
        :return: AtlasRelationship. The AtlasRelationship is compatible with MutableMapping
        :rtype: ~azure.purview.datamap.models.AtlasRelationship
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[_models.AtlasRelationship] = kwargs.pop("cls", None)

        content_type = content_type or "application/json"
        _content = None
        if isinstance(relationship, (IOBase, bytes)):
            _content = relationship
        else:
            _content = json.dumps(relationship, cls=SdkJSONEncoder, exclude_readonly=True)  # type: ignore

        _request = build_relationship_create_request(
            content_type=content_type,
            api_version=self._config.api_version,
            content=_content,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = kwargs.pop("stream", False)
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                await response.read()  # Load the body in memory and close the socket
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = _deserialize(_models.ErrorResponse, response.json())
            raise HttpResponseError(response=response, model=error)

        if _stream:
            deserialized = response.iter_bytes()
        else:
            deserialized = _deserialize(_models.AtlasRelationship, response.json())

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore

    @overload
    async def update(
        self, relationship: _models.AtlasRelationship, *, content_type: str = "application/json", **kwargs: Any
    ) -> _models.AtlasRelationship:
        """Update an existing relationship between entities.

        :param relationship: The AtlasRelationship object containing the information for the
         relationship to
         be created. Required.
        :type relationship: ~azure.purview.datamap.models.AtlasRelationship
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :keyword bool stream: Whether to stream the response of this operation. Defaults to False. You
         will have to context manage the returned stream.
        :return: AtlasRelationship. The AtlasRelationship is compatible with MutableMapping
        :rtype: ~azure.purview.datamap.models.AtlasRelationship
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @overload
    async def update(
        self, relationship: JSON, *, content_type: str = "application/json", **kwargs: Any
    ) -> _models.AtlasRelationship:
        """Update an existing relationship between entities.

        :param relationship: The AtlasRelationship object containing the information for the
         relationship to
         be created. Required.
        :type relationship: JSON
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :keyword bool stream: Whether to stream the response of this operation. Defaults to False. You
         will have to context manage the returned stream.
        :return: AtlasRelationship. The AtlasRelationship is compatible with MutableMapping
        :rtype: ~azure.purview.datamap.models.AtlasRelationship
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @overload
    async def update(
        self, relationship: IO[bytes], *, content_type: str = "application/json", **kwargs: Any
    ) -> _models.AtlasRelationship:
        """Update an existing relationship between entities.

        :param relationship: The AtlasRelationship object containing the information for the
         relationship to
         be created. Required.
        :type relationship: IO[bytes]
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Default value is "application/json".
        :paramtype content_type: str
        :keyword bool stream: Whether to stream the response of this operation. Defaults to False. You
         will have to context manage the returned stream.
        :return: AtlasRelationship. The AtlasRelationship is compatible with MutableMapping
        :rtype: ~azure.purview.datamap.models.AtlasRelationship
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @distributed_trace_async
    async def update(
        self, relationship: Union[_models.AtlasRelationship, JSON, IO[bytes]], **kwargs: Any
    ) -> _models.AtlasRelationship:
        """Update an existing relationship between entities.

        :param relationship: The AtlasRelationship object containing the information for the
         relationship to
         be created. Is one of the following types: AtlasRelationship, JSON, IO[bytes] Required.
        :type relationship: ~azure.purview.datamap.models.AtlasRelationship or JSON or IO[bytes]
        :keyword content_type: Body parameter Content-Type. Known values are: application/json. Default
         value is None.
        :paramtype content_type: str
        :keyword bool stream: Whether to stream the response of this operation. Defaults to False. You
         will have to context manage the returned stream.
        :return: AtlasRelationship. The AtlasRelationship is compatible with MutableMapping
        :rtype: ~azure.purview.datamap.models.AtlasRelationship
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[_models.AtlasRelationship] = kwargs.pop("cls", None)

        content_type = content_type or "application/json"
        _content = None
        if isinstance(relationship, (IOBase, bytes)):
            _content = relationship
        else:
            _content = json.dumps(relationship, cls=SdkJSONEncoder, exclude_readonly=True)  # type: ignore

        _request = build_relationship_update_request(
            content_type=content_type,
            api_version=self._config.api_version,
            content=_content,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = kwargs.pop("stream", False)
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                await response.read()  # Load the body in memory and close the socket
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = _deserialize(_models.ErrorResponse, response.json())
            raise HttpResponseError(response=response, model=error)

        if _stream:
            deserialized = response.iter_bytes()
        else:
            deserialized = _deserialize(_models.AtlasRelationship, response.json())

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore

    @distributed_trace_async
    async def get(
        self, guid: str, *, extended_info: Optional[bool] = None, **kwargs: Any
    ) -> _models.AtlasRelationshipWithExtInfo:
        """Get relationship information between entities by its GUID.

        :param guid: The globally unique identifier of the relationship. Required.
        :type guid: str
        :keyword extended_info: Limits whether includes extended information. Default value is None.
        :paramtype extended_info: bool
        :keyword bool stream: Whether to stream the response of this operation. Defaults to False. You
         will have to context manage the returned stream.
        :return: AtlasRelationshipWithExtInfo. The AtlasRelationshipWithExtInfo is compatible with
         MutableMapping
        :rtype: ~azure.purview.datamap.models.AtlasRelationshipWithExtInfo
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[_models.AtlasRelationshipWithExtInfo] = kwargs.pop("cls", None)

        _request = build_relationship_get_request(
            guid=guid,
            extended_info=extended_info,
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = kwargs.pop("stream", False)
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                await response.read()  # Load the body in memory and close the socket
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = _deserialize(_models.ErrorResponse, response.json())
            raise HttpResponseError(response=response, model=error)

        if _stream:
            deserialized = response.iter_bytes()
        else:
            deserialized = _deserialize(_models.AtlasRelationshipWithExtInfo, response.json())

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore

    @distributed_trace_async
    async def delete(self, guid: str, **kwargs: Any) -> None:  # pylint: disable=inconsistent-return-statements
        """Delete a relationship between entities by its GUID.

        :param guid: The globally unique identifier of the relationship. Required.
        :type guid: str
        :return: None
        :rtype: None
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[None] = kwargs.pop("cls", None)

        _request = build_relationship_delete_request(
            guid=guid,
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = False
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [204]:
            if _stream:
                await response.read()  # Load the body in memory and close the socket
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = _deserialize(_models.ErrorResponse, response.json())
            raise HttpResponseError(response=response, model=error)

        if cls:
            return cls(pipeline_response, None, {})  # type: ignore


class TypeOperations:  # pylint: disable=too-many-public-methods
    """
    .. warning::
        **DO NOT** instantiate this class directly.

        Instead, you should access the following operations through
        :class:`~azure.purview.datamap.aio.PurviewDataMapClient`'s
        :attr:`type` attribute.
    """

    def __init__(self, *args, **kwargs) -> None:
        input_args = list(args)
        self._client = input_args.pop(0) if input_args else kwargs.pop("client")
        self._config = input_args.pop(0) if input_args else kwargs.pop("config")
        self._serialize = input_args.pop(0) if input_args else kwargs.pop("serializer")
        self._deserialize = input_args.pop(0) if input_args else kwargs.pop("deserializer")

    @distributed_trace_async
    async def get_business_metadata_def_by_guid(self, guid: str, **kwargs: Any) -> _models.AtlasBusinessMetadataDef:
        """Get the businessMetadata definition for the given guid.

        :param guid: businessMetadata guid. Required.
        :type guid: str
        :keyword bool stream: Whether to stream the response of this operation. Defaults to False. You
         will have to context manage the returned stream.
        :return: AtlasBusinessMetadataDef. The AtlasBusinessMetadataDef is compatible with
         MutableMapping
        :rtype: ~azure.purview.datamap.models.AtlasBusinessMetadataDef
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[_models.AtlasBusinessMetadataDef] = kwargs.pop("cls", None)

        _request = build_type_get_business_metadata_def_by_guid_request(
            guid=guid,
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = kwargs.pop("stream", False)
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                await response.read()  # Load the body in memory and close the socket
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = _deserialize(_models.ErrorResponse, response.json())
            raise HttpResponseError(response=response, model=error)

        if _stream:
            deserialized = response.iter_bytes()
        else:
            deserialized = _deserialize(_models.AtlasBusinessMetadataDef, response.json())

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore

    @distributed_trace_async
    async def get_business_metadata_def_by_name(self, name: str, **kwargs: Any) -> _models.AtlasBusinessMetadataDef:
        """Get the businessMetadata definition by it's name (unique).

        :param name: businessMetadata name. Required.
        :type name: str
        :keyword bool stream: Whether to stream the response of this operation. Defaults to False. You
         will have to context manage the returned stream.
        :return: AtlasBusinessMetadataDef. The AtlasBusinessMetadataDef is compatible with
         MutableMapping
        :rtype: ~azure.purview.datamap.models.AtlasBusinessMetadataDef
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[_models.AtlasBusinessMetadataDef] = kwargs.pop("cls", None)

        _request = build_type_get_business_metadata_def_by_name_request(
            name=name,
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = kwargs.pop("stream", False)
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                await response.read()  # Load the body in memory and close the socket
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = _deserialize(_models.ErrorResponse, response.json())
            raise HttpResponseError(response=response, model=error)

        if _stream:
            deserialized = response.iter_bytes()
        else:
            deserialized = _deserialize(_models.AtlasBusinessMetadataDef, response.json())

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore

    @distributed_trace_async
    async def get_classification_def_by_guid(self, guid: str, **kwargs: Any) -> _models.AtlasClassificationDef:
        """Get the classification definition for the given GUID.

        :param guid: The globally unique identifier of the classification. Required.
        :type guid: str
        :keyword bool stream: Whether to stream the response of this operation. Defaults to False. You
         will have to context manage the returned stream.
        :return: AtlasClassificationDef. The AtlasClassificationDef is compatible with MutableMapping
        :rtype: ~azure.purview.datamap.models.AtlasClassificationDef
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[_models.AtlasClassificationDef] = kwargs.pop("cls", None)

        _request = build_type_get_classification_def_by_guid_request(
            guid=guid,
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = kwargs.pop("stream", False)
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                await response.read()  # Load the body in memory and close the socket
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = _deserialize(_models.ErrorResponse, response.json())
            raise HttpResponseError(response=response, model=error)

        if _stream:
            deserialized = response.iter_bytes()
        else:
            deserialized = _deserialize(_models.AtlasClassificationDef, response.json())

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore

    @distributed_trace_async
    async def get_classification_def_by_name(self, name: str, **kwargs: Any) -> _models.AtlasClassificationDef:
        """Get the classification definition by its name (unique).

        :param name: The name of the classification. Required.
        :type name: str
        :keyword bool stream: Whether to stream the response of this operation. Defaults to False. You
         will have to context manage the returned stream.
        :return: AtlasClassificationDef. The AtlasClassificationDef is compatible with MutableMapping
        :rtype: ~azure.purview.datamap.models.AtlasClassificationDef
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[_models.AtlasClassificationDef] = kwargs.pop("cls", None)

        _request = build_type_get_classification_def_by_name_request(
            name=name,
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = kwargs.pop("stream", False)
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                await response.read()  # Load the body in memory and close the socket
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = _deserialize(_models.ErrorResponse, response.json())
            raise HttpResponseError(response=response, model=error)

        if _stream:
            deserialized = response.iter_bytes()
        else:
            deserialized = _deserialize(_models.AtlasClassificationDef, response.json())

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore

    @distributed_trace_async
    async def get_entity_def_by_guid(self, guid: str, **kwargs: Any) -> _models.AtlasEntityDef:
        """Get the Entity definition for the given GUID.

        :param guid: The globally unique identifier of the entity. Required.
        :type guid: str
        :keyword bool stream: Whether to stream the response of this operation. Defaults to False. You
         will have to context manage the returned stream.
        :return: AtlasEntityDef. The AtlasEntityDef is compatible with MutableMapping
        :rtype: ~azure.purview.datamap.models.AtlasEntityDef
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[_models.AtlasEntityDef] = kwargs.pop("cls", None)

        _request = build_type_get_entity_def_by_guid_request(
            guid=guid,
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = kwargs.pop("stream", False)
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                await response.read()  # Load the body in memory and close the socket
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = _deserialize(_models.ErrorResponse, response.json())
            raise HttpResponseError(response=response, model=error)

        if _stream:
            deserialized = response.iter_bytes()
        else:
            deserialized = _deserialize(_models.AtlasEntityDef, response.json())

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore

    @distributed_trace_async
    async def get_entity_def_by_name(self, name: str, **kwargs: Any) -> _models.AtlasEntityDef:
        """Get the entity definition by its name (unique).

        :param name: The name of the entity. Required.
        :type name: str
        :keyword bool stream: Whether to stream the response of this operation. Defaults to False. You
         will have to context manage the returned stream.
        :return: AtlasEntityDef. The AtlasEntityDef is compatible with MutableMapping
        :rtype: ~azure.purview.datamap.models.AtlasEntityDef
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[_models.AtlasEntityDef] = kwargs.pop("cls", None)

        _request = build_type_get_entity_def_by_name_request(
            name=name,
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = kwargs.pop("stream", False)
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                await response.read()  # Load the body in memory and close the socket
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = _deserialize(_models.ErrorResponse, response.json())
            raise HttpResponseError(response=response, model=error)

        if _stream:
            deserialized = response.iter_bytes()
        else:
            deserialized = _deserialize(_models.AtlasEntityDef, response.json())

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore

    @distributed_trace_async
    async def get_enum_def_by_guid(self, guid: str, **kwargs: Any) -> _models.AtlasEnumDef:
        """Get the enum definition for the given GUID.

        :param guid: The globally unique identifier of the enum. Required.
        :type guid: str
        :keyword bool stream: Whether to stream the response of this operation. Defaults to False. You
         will have to context manage the returned stream.
        :return: AtlasEnumDef. The AtlasEnumDef is compatible with MutableMapping
        :rtype: ~azure.purview.datamap.models.AtlasEnumDef
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[_models.AtlasEnumDef] = kwargs.pop("cls", None)

        _request = build_type_get_enum_def_by_guid_request(
            guid=guid,
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = kwargs.pop("stream", False)
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                await response.read()  # Load the body in memory and close the socket
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = _deserialize(_models.ErrorResponse, response.json())
            raise HttpResponseError(response=response, model=error)

        if _stream:
            deserialized = response.iter_bytes()
        else:
            deserialized = _deserialize(_models.AtlasEnumDef, response.json())

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore

    @distributed_trace_async
    async def get_enum_def_by_name(self, name: str, **kwargs: Any) -> _models.AtlasEnumDef:
        """Get the enum definition by its name (unique).

        :param name: The name of the enum. Required.
        :type name: str
        :keyword bool stream: Whether to stream the response of this operation. Defaults to False. You
         will have to context manage the returned stream.
        :return: AtlasEnumDef. The AtlasEnumDef is compatible with MutableMapping
        :rtype: ~azure.purview.datamap.models.AtlasEnumDef
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[_models.AtlasEnumDef] = kwargs.pop("cls", None)

        _request = build_type_get_enum_def_by_name_request(
            name=name,
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = kwargs.pop("stream", False)
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                await response.read()  # Load the body in memory and close the socket
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = _deserialize(_models.ErrorResponse, response.json())
            raise HttpResponseError(response=response, model=error)

        if _stream:
            deserialized = response.iter_bytes()
        else:
            deserialized = _deserialize(_models.AtlasEnumDef, response.json())

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore

    @distributed_trace_async
    async def get_relationship_def_by_guid(self, guid: str, **kwargs: Any) -> _models.AtlasRelationshipDef:
        """Get the relationship definition for the given GUID.

        :param guid: The globally unique identifier of the relationship. Required.
        :type guid: str
        :keyword bool stream: Whether to stream the response of this operation. Defaults to False. You
         will have to context manage the returned stream.
        :return: AtlasRelationshipDef. The AtlasRelationshipDef is compatible with MutableMapping
        :rtype: ~azure.purview.datamap.models.AtlasRelationshipDef
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[_models.AtlasRelationshipDef] = kwargs.pop("cls", None)

        _request = build_type_get_relationship_def_by_guid_request(
            guid=guid,
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = kwargs.pop("stream", False)
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                await response.read()  # Load the body in memory and close the socket
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = _deserialize(_models.ErrorResponse, response.json())
            raise HttpResponseError(response=response, model=error)

        if _stream:
            deserialized = response.iter_bytes()
        else:
            deserialized = _deserialize(_models.AtlasRelationshipDef, response.json())

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore

    @distributed_trace_async
    async def get_relationship_def_by_name(self, name: str, **kwargs: Any) -> _models.AtlasRelationshipDef:
        """Get the relationship definition by its name (unique).

        :param name: The name of the relationship. Required.
        :type name: str
        :keyword bool stream: Whether to stream the response of this operation. Defaults to False. You
         will have to context manage the returned stream.
        :return: AtlasRelationshipDef. The AtlasRelationshipDef is compatible with MutableMapping
        :rtype: ~azure.purview.datamap.models.AtlasRelationshipDef
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[_models.AtlasRelationshipDef] = kwargs.pop("cls", None)

        _request = build_type_get_relationship_def_by_name_request(
            name=name,
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = kwargs.pop("stream", False)
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                await response.read()  # Load the body in memory and close the socket
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = _deserialize(_models.ErrorResponse, response.json())
            raise HttpResponseError(response=response, model=error)

        if _stream:
            deserialized = response.iter_bytes()
        else:
            deserialized = _deserialize(_models.AtlasRelationshipDef, response.json())

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore

    @distributed_trace_async
    async def get_struct_def_by_guid(self, guid: str, **kwargs: Any) -> _models.AtlasStructDef:
        """Get the struct definition for the given GUID.

        :param guid: The globally unique identifier of the struct. Required.
        :type guid: str
        :keyword bool stream: Whether to stream the response of this operation. Defaults to False. You
         will have to context manage the returned stream.
        :return: AtlasStructDef. The AtlasStructDef is compatible with MutableMapping
        :rtype: ~azure.purview.datamap.models.AtlasStructDef
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[_models.AtlasStructDef] = kwargs.pop("cls", None)

        _request = build_type_get_struct_def_by_guid_request(
            guid=guid,
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = kwargs.pop("stream", False)
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                await response.read()  # Load the body in memory and close the socket
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = _deserialize(_models.ErrorResponse, response.json())
            raise HttpResponseError(response=response, model=error)

        if _stream:
            deserialized = response.iter_bytes()
        else:
            deserialized = _deserialize(_models.AtlasStructDef, response.json())

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore

    @distributed_trace_async
    async def get_struct_def_by_name(self, name: str, **kwargs: Any) -> _models.AtlasStructDef:
        """Get the struct definition by its name (unique).

        :param name: The name of the struct. Required.
        :type name: str
        :keyword bool stream: Whether to stream the response of this operation. Defaults to False. You
         will have to context manage the returned stream.
        :return: AtlasStructDef. The AtlasStructDef is compatible with MutableMapping
        :rtype: ~azure.purview.datamap.models.AtlasStructDef
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[_models.AtlasStructDef] = kwargs.pop("cls", None)

        _request = build_type_get_struct_def_by_name_request(
            name=name,
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = kwargs.pop("stream", False)
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                await response.read()  # Load the body in memory and close the socket
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = _deserialize(_models.ErrorResponse, response.json())
            raise HttpResponseError(response=response, model=error)

        if _stream:
            deserialized = response.iter_bytes()
        else:
            deserialized = _deserialize(_models.AtlasStructDef, response.json())

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore

    @distributed_trace_async
    async def get_by_guid(self, guid: str, **kwargs: Any) -> _models.AtlasTypeDef:
        """Get the type definition for the given GUID.

        :param guid: The globally unique identifier of the type. Required.
        :type guid: str
        :keyword bool stream: Whether to stream the response of this operation. Defaults to False. You
         will have to context manage the returned stream.
        :return: AtlasTypeDef. The AtlasTypeDef is compatible with MutableMapping
        :rtype: ~azure.purview.datamap.models.AtlasTypeDef
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[_models.AtlasTypeDef] = kwargs.pop("cls", None)

        _request = build_type_get_by_guid_request(
            guid=guid,
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = kwargs.pop("stream", False)
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                await response.read()  # Load the body in memory and close the socket
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = _deserialize(_models.ErrorResponse, response.json())
            raise HttpResponseError(response=response, model=error)

        if _stream:
            deserialized = response.iter_bytes()
        else:
            deserialized = _deserialize(_models.AtlasTypeDef, response.json())

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore

    @distributed_trace_async
    async def get_by_name(self, name: str, **kwargs: Any) -> _models.AtlasTypeDef:
        """Get the type definition by its name (unique).

        :param name: The name of the type. Required.
        :type name: str
        :keyword bool stream: Whether to stream the response of this operation. Defaults to False. You
         will have to context manage the returned stream.
        :return: AtlasTypeDef. The AtlasTypeDef is compatible with MutableMapping
        :rtype: ~azure.purview.datamap.models.AtlasTypeDef
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[_models.AtlasTypeDef] = kwargs.pop("cls", None)

        _request = build_type_get_by_name_request(
            name=name,
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = kwargs.pop("stream", False)
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                await response.read()  # Load the body in memory and close the socket
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = _deserialize(_models.ErrorResponse, response.json())
            raise HttpResponseError(response=response, model=error)

        if _stream:
            deserialized = response.iter_bytes()
        else:
            deserialized = _deserialize(_models.AtlasTypeDef, response.json())

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore

    @distributed_trace_async
    async def delete(self, name: str, **kwargs: Any) -> None:  # pylint: disable=inconsistent-return-statements
        """Delete API for type identified by its name.

        :param name: The name of the type. Required.
        :type name: str
        :return: None
        :rtype: None
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[None] = kwargs.pop("cls", None)

        _request = build_type_delete_request(
            name=name,
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = False
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [204]:
            if _stream:
                await response.read()  # Load the body in memory and close the socket
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = _deserialize(_models.ErrorResponse, response.json())
            raise HttpResponseError(response=response, model=error)

        if cls:
            return cls(pipeline_response, None, {})  # type: ignore

    @distributed_trace_async
    async def list(
        self,
        *,
        include_term_template: Optional[bool] = None,
        type: Optional[Union[str, _models.Typedef]] = None,
        **kwargs: Any
    ) -> _models.AtlasTypesDef:
        """List all type definitions in bulk.

        :keyword include_term_template: Whether include termtemplatedef when return all typedefs.
         This is always true
         when search filter type=term_template. Default value is None.
        :paramtype include_term_template: bool
        :keyword type: Typedef name as search filter when get typedefs. Known values are: "enum",
         "entity", "classification", "relationship", "struct", and "term_template". Default value is
         None.
        :paramtype type: str or ~azure.purview.datamap.models.Typedef
        :keyword bool stream: Whether to stream the response of this operation. Defaults to False. You
         will have to context manage the returned stream.
        :return: AtlasTypesDef. The AtlasTypesDef is compatible with MutableMapping
        :rtype: ~azure.purview.datamap.models.AtlasTypesDef
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[_models.AtlasTypesDef] = kwargs.pop("cls", None)

        _request = build_type_list_request(
            include_term_template=include_term_template,
            type=type,
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = kwargs.pop("stream", False)
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                await response.read()  # Load the body in memory and close the socket
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = _deserialize(_models.ErrorResponse, response.json())
            raise HttpResponseError(response=response, model=error)

        if _stream:
            deserialized = response.iter_bytes()
        else:
            deserialized = _deserialize(_models.AtlasTypesDef, response.json())

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore

    @overload
    async def bulk_create(
        self, types_def: _models.AtlasTypesDef, *, content_type: str = "application/json", **kwargs: Any
    ) -> _models.AtlasTypesDef:
        """Create all atlas type definitions in bulk, only new definitions will be
        created.
        Any changes to the existing definitions will be discarded.

        :param types_def: A composite wrapper object with corresponding lists of the type definition.
         Required.
        :type types_def: ~azure.purview.datamap.models.AtlasTypesDef
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :keyword bool stream: Whether to stream the response of this operation. Defaults to False. You
         will have to context manage the returned stream.
        :return: AtlasTypesDef. The AtlasTypesDef is compatible with MutableMapping
        :rtype: ~azure.purview.datamap.models.AtlasTypesDef
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @overload
    async def bulk_create(
        self, types_def: JSON, *, content_type: str = "application/json", **kwargs: Any
    ) -> _models.AtlasTypesDef:
        """Create all atlas type definitions in bulk, only new definitions will be
        created.
        Any changes to the existing definitions will be discarded.

        :param types_def: A composite wrapper object with corresponding lists of the type definition.
         Required.
        :type types_def: JSON
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :keyword bool stream: Whether to stream the response of this operation. Defaults to False. You
         will have to context manage the returned stream.
        :return: AtlasTypesDef. The AtlasTypesDef is compatible with MutableMapping
        :rtype: ~azure.purview.datamap.models.AtlasTypesDef
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @overload
    async def bulk_create(
        self, types_def: IO[bytes], *, content_type: str = "application/json", **kwargs: Any
    ) -> _models.AtlasTypesDef:
        """Create all atlas type definitions in bulk, only new definitions will be
        created.
        Any changes to the existing definitions will be discarded.

        :param types_def: A composite wrapper object with corresponding lists of the type definition.
         Required.
        :type types_def: IO[bytes]
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Default value is "application/json".
        :paramtype content_type: str
        :keyword bool stream: Whether to stream the response of this operation. Defaults to False. You
         will have to context manage the returned stream.
        :return: AtlasTypesDef. The AtlasTypesDef is compatible with MutableMapping
        :rtype: ~azure.purview.datamap.models.AtlasTypesDef
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @distributed_trace_async
    async def bulk_create(
        self, types_def: Union[_models.AtlasTypesDef, JSON, IO[bytes]], **kwargs: Any
    ) -> _models.AtlasTypesDef:
        """Create all atlas type definitions in bulk, only new definitions will be
        created.
        Any changes to the existing definitions will be discarded.

        :param types_def: A composite wrapper object with corresponding lists of the type definition.
         Is one of the following types: AtlasTypesDef, JSON, IO[bytes] Required.
        :type types_def: ~azure.purview.datamap.models.AtlasTypesDef or JSON or IO[bytes]
        :keyword content_type: Body parameter Content-Type. Known values are: application/json. Default
         value is None.
        :paramtype content_type: str
        :keyword bool stream: Whether to stream the response of this operation. Defaults to False. You
         will have to context manage the returned stream.
        :return: AtlasTypesDef. The AtlasTypesDef is compatible with MutableMapping
        :rtype: ~azure.purview.datamap.models.AtlasTypesDef
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[_models.AtlasTypesDef] = kwargs.pop("cls", None)

        content_type = content_type or "application/json"
        _content = None
        if isinstance(types_def, (IOBase, bytes)):
            _content = types_def
        else:
            _content = json.dumps(types_def, cls=SdkJSONEncoder, exclude_readonly=True)  # type: ignore

        _request = build_type_bulk_create_request(
            content_type=content_type,
            api_version=self._config.api_version,
            content=_content,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = kwargs.pop("stream", False)
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                await response.read()  # Load the body in memory and close the socket
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = _deserialize(_models.ErrorResponse, response.json())
            raise HttpResponseError(response=response, model=error)

        if _stream:
            deserialized = response.iter_bytes()
        else:
            deserialized = _deserialize(_models.AtlasTypesDef, response.json())

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore

    @overload
    async def bulk_update(
        self, types_def: _models.AtlasTypesDef, *, content_type: str = "application/json", **kwargs: Any
    ) -> _models.AtlasTypesDef:
        """Update all types in bulk, changes detected in the type definitions would be
        persisted.

        :param types_def: A composite object that captures all type definition changes. Required.
        :type types_def: ~azure.purview.datamap.models.AtlasTypesDef
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :keyword bool stream: Whether to stream the response of this operation. Defaults to False. You
         will have to context manage the returned stream.
        :return: AtlasTypesDef. The AtlasTypesDef is compatible with MutableMapping
        :rtype: ~azure.purview.datamap.models.AtlasTypesDef
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @overload
    async def bulk_update(
        self, types_def: JSON, *, content_type: str = "application/json", **kwargs: Any
    ) -> _models.AtlasTypesDef:
        """Update all types in bulk, changes detected in the type definitions would be
        persisted.

        :param types_def: A composite object that captures all type definition changes. Required.
        :type types_def: JSON
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :keyword bool stream: Whether to stream the response of this operation. Defaults to False. You
         will have to context manage the returned stream.
        :return: AtlasTypesDef. The AtlasTypesDef is compatible with MutableMapping
        :rtype: ~azure.purview.datamap.models.AtlasTypesDef
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @overload
    async def bulk_update(
        self, types_def: IO[bytes], *, content_type: str = "application/json", **kwargs: Any
    ) -> _models.AtlasTypesDef:
        """Update all types in bulk, changes detected in the type definitions would be
        persisted.

        :param types_def: A composite object that captures all type definition changes. Required.
        :type types_def: IO[bytes]
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Default value is "application/json".
        :paramtype content_type: str
        :keyword bool stream: Whether to stream the response of this operation. Defaults to False. You
         will have to context manage the returned stream.
        :return: AtlasTypesDef. The AtlasTypesDef is compatible with MutableMapping
        :rtype: ~azure.purview.datamap.models.AtlasTypesDef
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @distributed_trace_async
    async def bulk_update(
        self, types_def: Union[_models.AtlasTypesDef, JSON, IO[bytes]], **kwargs: Any
    ) -> _models.AtlasTypesDef:
        """Update all types in bulk, changes detected in the type definitions would be
        persisted.

        :param types_def: A composite object that captures all type definition changes. Is one of the
         following types: AtlasTypesDef, JSON, IO[bytes] Required.
        :type types_def: ~azure.purview.datamap.models.AtlasTypesDef or JSON or IO[bytes]
        :keyword content_type: Body parameter Content-Type. Known values are: application/json. Default
         value is None.
        :paramtype content_type: str
        :keyword bool stream: Whether to stream the response of this operation. Defaults to False. You
         will have to context manage the returned stream.
        :return: AtlasTypesDef. The AtlasTypesDef is compatible with MutableMapping
        :rtype: ~azure.purview.datamap.models.AtlasTypesDef
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[_models.AtlasTypesDef] = kwargs.pop("cls", None)

        content_type = content_type or "application/json"
        _content = None
        if isinstance(types_def, (IOBase, bytes)):
            _content = types_def
        else:
            _content = json.dumps(types_def, cls=SdkJSONEncoder, exclude_readonly=True)  # type: ignore

        _request = build_type_bulk_update_request(
            content_type=content_type,
            api_version=self._config.api_version,
            content=_content,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = kwargs.pop("stream", False)
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                await response.read()  # Load the body in memory and close the socket
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = _deserialize(_models.ErrorResponse, response.json())
            raise HttpResponseError(response=response, model=error)

        if _stream:
            deserialized = response.iter_bytes()
        else:
            deserialized = _deserialize(_models.AtlasTypesDef, response.json())

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore

    @overload
    async def bulk_delete(  # pylint: disable=inconsistent-return-statements
        self, types_def: _models.AtlasTypesDef, *, content_type: str = "application/json", **kwargs: Any
    ) -> None:
        """Delete API for all types in bulk.

        :param types_def: A composite object that captures all types to be deleted. Required.
        :type types_def: ~azure.purview.datamap.models.AtlasTypesDef
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: None
        :rtype: None
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @overload
    async def bulk_delete(  # pylint: disable=inconsistent-return-statements
        self, types_def: JSON, *, content_type: str = "application/json", **kwargs: Any
    ) -> None:
        """Delete API for all types in bulk.

        :param types_def: A composite object that captures all types to be deleted. Required.
        :type types_def: JSON
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: None
        :rtype: None
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @overload
    async def bulk_delete(  # pylint: disable=inconsistent-return-statements
        self, types_def: IO[bytes], *, content_type: str = "application/json", **kwargs: Any
    ) -> None:
        """Delete API for all types in bulk.

        :param types_def: A composite object that captures all types to be deleted. Required.
        :type types_def: IO[bytes]
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: None
        :rtype: None
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @distributed_trace_async
    async def bulk_delete(  # pylint: disable=inconsistent-return-statements
        self, types_def: Union[_models.AtlasTypesDef, JSON, IO[bytes]], **kwargs: Any
    ) -> None:
        """Delete API for all types in bulk.

        :param types_def: A composite object that captures all types to be deleted. Is one of the
         following types: AtlasTypesDef, JSON, IO[bytes] Required.
        :type types_def: ~azure.purview.datamap.models.AtlasTypesDef or JSON or IO[bytes]
        :keyword content_type: Body parameter Content-Type. Known values are: application/json. Default
         value is None.
        :paramtype content_type: str
        :return: None
        :rtype: None
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[None] = kwargs.pop("cls", None)

        content_type = content_type or "application/json"
        _content = None
        if isinstance(types_def, (IOBase, bytes)):
            _content = types_def
        else:
            _content = json.dumps(types_def, cls=SdkJSONEncoder, exclude_readonly=True)  # type: ignore

        _request = build_type_bulk_delete_request(
            content_type=content_type,
            api_version=self._config.api_version,
            content=_content,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = False
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [204]:
            if _stream:
                await response.read()  # Load the body in memory and close the socket
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = _deserialize(_models.ErrorResponse, response.json())
            raise HttpResponseError(response=response, model=error)

        if cls:
            return cls(pipeline_response, None, {})  # type: ignore

    @distributed_trace_async
    async def list_headers(
        self,
        *,
        include_term_template: Optional[bool] = None,
        type: Optional[Union[str, _models.Typedef]] = None,
        **kwargs: Any
    ) -> List[_models.AtlasTypeDefHeader]:
        """List all type definitions returned as a list of minimal information header.

        :keyword include_term_template: Whether include termtemplatedef when return all typedefs.
         This is always true
         when search filter type=term_template. Default value is None.
        :paramtype include_term_template: bool
        :keyword type: Typedef name as search filter when get typedefs. Known values are: "enum",
         "entity", "classification", "relationship", "struct", and "term_template". Default value is
         None.
        :paramtype type: str or ~azure.purview.datamap.models.Typedef
        :keyword bool stream: Whether to stream the response of this operation. Defaults to False. You
         will have to context manage the returned stream.
        :return: list of AtlasTypeDefHeader
        :rtype: list[~azure.purview.datamap.models.AtlasTypeDefHeader]
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[List[_models.AtlasTypeDefHeader]] = kwargs.pop("cls", None)

        _request = build_type_list_headers_request(
            include_term_template=include_term_template,
            type=type,
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = kwargs.pop("stream", False)
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                await response.read()  # Load the body in memory and close the socket
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = _deserialize(_models.ErrorResponse, response.json())
            raise HttpResponseError(response=response, model=error)

        if _stream:
            deserialized = response.iter_bytes()
        else:
            deserialized = _deserialize(List[_models.AtlasTypeDefHeader], response.json())

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore

    @distributed_trace_async
    async def get_term_template_def_by_guid(self, guid: str, **kwargs: Any) -> _models.TermTemplateDef:
        """Get the term template definition for the given GUID.

        :param guid: The globally unique identifier of the term template. Required.
        :type guid: str
        :keyword bool stream: Whether to stream the response of this operation. Defaults to False. You
         will have to context manage the returned stream.
        :return: TermTemplateDef. The TermTemplateDef is compatible with MutableMapping
        :rtype: ~azure.purview.datamap.models.TermTemplateDef
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[_models.TermTemplateDef] = kwargs.pop("cls", None)

        _request = build_type_get_term_template_def_by_guid_request(
            guid=guid,
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = kwargs.pop("stream", False)
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                await response.read()  # Load the body in memory and close the socket
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = _deserialize(_models.ErrorResponse, response.json())
            raise HttpResponseError(response=response, model=error)

        if _stream:
            deserialized = response.iter_bytes()
        else:
            deserialized = _deserialize(_models.TermTemplateDef, response.json())

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore

    @distributed_trace_async
    async def get_term_template_def_by_name(self, name: str, **kwargs: Any) -> _models.TermTemplateDef:
        """Get the term template definition by its name (unique).

        :param name: The unique name of the term template. Required.
        :type name: str
        :keyword bool stream: Whether to stream the response of this operation. Defaults to False. You
         will have to context manage the returned stream.
        :return: TermTemplateDef. The TermTemplateDef is compatible with MutableMapping
        :rtype: ~azure.purview.datamap.models.TermTemplateDef
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[_models.TermTemplateDef] = kwargs.pop("cls", None)

        _request = build_type_get_term_template_def_by_name_request(
            name=name,
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = kwargs.pop("stream", False)
        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                await response.read()  # Load the body in memory and close the socket
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = _deserialize(_models.ErrorResponse, response.json())
            raise HttpResponseError(response=response, model=error)

        if _stream:
            deserialized = response.iter_bytes()
        else:
            deserialized = _deserialize(_models.TermTemplateDef, response.json())

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore
