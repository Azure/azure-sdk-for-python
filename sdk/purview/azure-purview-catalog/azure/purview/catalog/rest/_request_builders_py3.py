# coding=utf-8
# --------------------------------------------------------------------------
# Copyright (c) Microsoft Corporation. All rights reserved.
# Licensed under the MIT License. See License.txt in the project root for license information.
# Code generated by Microsoft (R) AutoRest Code Generator.
# Changes may cause incorrect behavior and will be lost if the code is regenerated.
# --------------------------------------------------------------------------
from typing import Any, Dict, IO, List, Optional, Union

from azure.core.pipeline.transport._base import _format_url_section
from azure.purview.catalog.core.rest import HttpRequest
from msrest import Serializer

_SERIALIZER = Serializer()


def build_entityrest_create_or_update_request(
    *,
    json: Any = None,
    content: Any = None,
    **kwargs: Any
) -> HttpRequest:
    """Create or update an entity.

    Create or update an entity in Atlas.
    Existing entity is matched using its unique guid if supplied or by its unique attributes eg:
    qualifiedName.
    Map and array of collections are not well supported. E.g., array<array:code:`<int>`>,
    array<map<string, int>>.

    See https://aka.ms/azsdk/python/llcwiki for how to incorporate this request_builder into your code flow.

    :keyword json: Atlas entity with extended information.
    :paramtype json: Any
    :keyword content: Atlas entity with extended information.
    :paramtype content: Any
    :return: Returns an :class:`~azure.purview.catalog.core.rest.HttpRequest` that you will pass to the client's `send_request` method.
     See https://aka.ms/azsdk/python/llcwiki for how to incorporate this response into your code flow.
    :rtype: ~azure.purview.catalog.core.rest.HttpRequest
    """
    content_type = kwargs.pop("content_type", None)
    accept = "application/json"

    # Construct URL
    url = kwargs.pop("template_url", '/atlas/v2/entity')

    # Construct headers
    header_parameters = kwargs.pop("headers", {})  # type: Dict[str, Any]
    if content_type is not None:
        header_parameters['Content-Type'] = _SERIALIZER.header("content_type", content_type, 'str')
    header_parameters['Accept'] = _SERIALIZER.header("accept", accept, 'str')

    return HttpRequest(
        method="POST",
        url=url,
        headers=header_parameters,
        json=json,
        content=content,
        **kwargs
    )


def build_entityrest_get_by_guids_request(
    *,
    guid: List[str],
    min_ext_info: Optional[bool] = False,
    ignore_relationships: Optional[bool] = False,
    exclude_relationship_types: Optional[List[str]] = None,
    **kwargs: Any
) -> HttpRequest:
    """List entities in bulk identified by its GUIDs.

    List entities in bulk identified by its GUIDs.

    See https://aka.ms/azsdk/python/llcwiki for how to incorporate this request_builder into your code flow.

    :keyword guid: An array of GUIDs of entities to create.
    :paramtype guid: list[str]
    :keyword min_ext_info: Whether to return minimal information for referred entities.
    :paramtype min_ext_info: bool
    :keyword ignore_relationships: Whether to ignore relationship attributes.
    :paramtype ignore_relationships: bool
    :keyword exclude_relationship_types: An array of the relationship types need to be excluded
     from the response.
    :paramtype exclude_relationship_types: list[str]
    :return: Returns an :class:`~azure.purview.catalog.core.rest.HttpRequest` that you will pass to the client's `send_request` method.
     See https://aka.ms/azsdk/python/llcwiki for how to incorporate this response into your code flow.
    :rtype: ~azure.purview.catalog.core.rest.HttpRequest
    """
    accept = "application/json"

    # Construct URL
    url = kwargs.pop("template_url", '/atlas/v2/entity/bulk')

    # Construct parameters
    query_parameters = kwargs.pop("params", {})  # type: Dict[str, Any]
    query_parameters['guid'] = [_SERIALIZER.query("guid", q, 'str') if q is not None else '' for q in guid]
    if min_ext_info is not None:
        query_parameters['minExtInfo'] = _SERIALIZER.query("min_ext_info", min_ext_info, 'bool')
    if ignore_relationships is not None:
        query_parameters['ignoreRelationships'] = _SERIALIZER.query("ignore_relationships", ignore_relationships, 'bool')
    if exclude_relationship_types is not None:
        query_parameters['excludeRelationshipTypes'] = [_SERIALIZER.query("exclude_relationship_types", q, 'str') if q is not None else '' for q in exclude_relationship_types]

    # Construct headers
    header_parameters = kwargs.pop("headers", {})  # type: Dict[str, Any]
    header_parameters['Accept'] = _SERIALIZER.header("accept", accept, 'str')

    return HttpRequest(
        method="GET",
        url=url,
        params=query_parameters,
        headers=header_parameters,
        **kwargs
    )


def build_entityrest_create_or_update_bulk_request(
    *,
    json: Any = None,
    content: Any = None,
    **kwargs: Any
) -> HttpRequest:
    """Create or update entities in bulk.

    Create or update entities in Atlas in bulk.
    Existing entity is matched using its unique guid if supplied or by its unique attributes eg:
    qualifiedName.
    Map and array of collections are not well supported. E.g., array<array:code:`<int>`>,
    array<map<string, int>>.

    See https://aka.ms/azsdk/python/llcwiki for how to incorporate this request_builder into your code flow.

    :keyword json: An array of entities to create or update.
    :paramtype json: Any
    :keyword content: An array of entities to create or update.
    :paramtype content: Any
    :return: Returns an :class:`~azure.purview.catalog.core.rest.HttpRequest` that you will pass to the client's `send_request` method.
     See https://aka.ms/azsdk/python/llcwiki for how to incorporate this response into your code flow.
    :rtype: ~azure.purview.catalog.core.rest.HttpRequest
    """
    content_type = kwargs.pop("content_type", None)
    accept = "application/json"

    # Construct URL
    url = kwargs.pop("template_url", '/atlas/v2/entity/bulk')

    # Construct headers
    header_parameters = kwargs.pop("headers", {})  # type: Dict[str, Any]
    if content_type is not None:
        header_parameters['Content-Type'] = _SERIALIZER.header("content_type", content_type, 'str')
    header_parameters['Accept'] = _SERIALIZER.header("accept", accept, 'str')

    return HttpRequest(
        method="POST",
        url=url,
        headers=header_parameters,
        json=json,
        content=content,
        **kwargs
    )


def build_entityrest_bulk_delete_request(
    *,
    guid: List[str],
    **kwargs: Any
) -> HttpRequest:
    """Delete a list of entities in bulk identified by their GUIDs or unique attributes.

    Delete a list of entities in bulk identified by their GUIDs or unique attributes.

    See https://aka.ms/azsdk/python/llcwiki for how to incorporate this request_builder into your code flow.

    :keyword guid: An array of GUIDs of entities to delete.
    :paramtype guid: list[str]
    :return: Returns an :class:`~azure.purview.catalog.core.rest.HttpRequest` that you will pass to the client's `send_request` method.
     See https://aka.ms/azsdk/python/llcwiki for how to incorporate this response into your code flow.
    :rtype: ~azure.purview.catalog.core.rest.HttpRequest
    """
    accept = "application/json"

    # Construct URL
    url = kwargs.pop("template_url", '/atlas/v2/entity/bulk')

    # Construct parameters
    query_parameters = kwargs.pop("params", {})  # type: Dict[str, Any]
    query_parameters['guid'] = [_SERIALIZER.query("guid", q, 'str') if q is not None else '' for q in guid]

    # Construct headers
    header_parameters = kwargs.pop("headers", {})  # type: Dict[str, Any]
    header_parameters['Accept'] = _SERIALIZER.header("accept", accept, 'str')

    return HttpRequest(
        method="DELETE",
        url=url,
        params=query_parameters,
        headers=header_parameters,
        **kwargs
    )


def build_entityrest_add_classification_request(
    *,
    json: Any = None,
    content: Any = None,
    **kwargs: Any
) -> HttpRequest:
    """Associate a classification to multiple entities in bulk.

    Associate a classification to multiple entities in bulk.

    See https://aka.ms/azsdk/python/llcwiki for how to incorporate this request_builder into your code flow.

    :keyword json: The request to associate a classification to multiple entities.
    :paramtype json: Any
    :keyword content: The request to associate a classification to multiple entities.
    :paramtype content: Any
    :return: Returns an :class:`~azure.purview.catalog.core.rest.HttpRequest` that you will pass to the client's `send_request` method.
     See https://aka.ms/azsdk/python/llcwiki for how to incorporate this response into your code flow.
    :rtype: ~azure.purview.catalog.core.rest.HttpRequest
    """
    content_type = kwargs.pop("content_type", None)

    # Construct URL
    url = kwargs.pop("template_url", '/atlas/v2/entity/bulk/classification')

    # Construct headers
    header_parameters = kwargs.pop("headers", {})  # type: Dict[str, Any]
    if content_type is not None:
        header_parameters['Content-Type'] = _SERIALIZER.header("content_type", content_type, 'str')

    return HttpRequest(
        method="POST",
        url=url,
        headers=header_parameters,
        json=json,
        content=content,
        **kwargs
    )


def build_entityrest_get_by_id_request(
    guid: str,
    *,
    min_ext_info: Optional[bool] = False,
    ignore_relationships: Optional[bool] = False,
    **kwargs: Any
) -> HttpRequest:
    """Get complete definition of an entity given its GUID.

    Get complete definition of an entity given its GUID.

    See https://aka.ms/azsdk/python/llcwiki for how to incorporate this request_builder into your code flow.

    :param guid: The globally unique identifier of the entity.
    :type guid: str
    :keyword min_ext_info: Whether to return minimal information for referred entities.
    :paramtype min_ext_info: bool
    :keyword ignore_relationships: Whether to ignore relationship attributes.
    :paramtype ignore_relationships: bool
    :return: Returns an :class:`~azure.purview.catalog.core.rest.HttpRequest` that you will pass to the client's `send_request` method.
     See https://aka.ms/azsdk/python/llcwiki for how to incorporate this response into your code flow.
    :rtype: ~azure.purview.catalog.core.rest.HttpRequest
    """
    accept = "application/json"

    # Construct URL
    url = kwargs.pop("template_url", '/atlas/v2/entity/guid/{guid}')
    path_format_arguments = {
        'guid': _SERIALIZER.url("guid", guid, 'str', max_length=4096, min_length=1),
    }
    url = _format_url_section(url, **path_format_arguments)

    # Construct parameters
    query_parameters = kwargs.pop("params", {})  # type: Dict[str, Any]
    if min_ext_info is not None:
        query_parameters['minExtInfo'] = _SERIALIZER.query("min_ext_info", min_ext_info, 'bool')
    if ignore_relationships is not None:
        query_parameters['ignoreRelationships'] = _SERIALIZER.query("ignore_relationships", ignore_relationships, 'bool')

    # Construct headers
    header_parameters = kwargs.pop("headers", {})  # type: Dict[str, Any]
    header_parameters['Accept'] = _SERIALIZER.header("accept", accept, 'str')

    return HttpRequest(
        method="GET",
        url=url,
        params=query_parameters,
        headers=header_parameters,
        **kwargs
    )


def build_entityrest_partial_update_entity_attr_by_guid_request(
    guid: str,
    *,
    json: Any = None,
    content: Optional[object] = None,
    name: str,
    **kwargs: Any
) -> HttpRequest:
    """Update entity partially - Create/Update entity attribute identified by its GUID.

    Update entity partially - create or update entity attribute identified by its GUID.
    Supports only primitive attribute type and entity references.
    It does not support updating complex types like arrays, and maps.
    Null updates are not possible.

    See https://aka.ms/azsdk/python/llcwiki for how to incorporate this request_builder into your code flow.

    :param guid: The globally unique identifier of the entity.
    :type guid: str
    :keyword json: The value of the attribute.
    :paramtype json: Any
    :keyword content: The value of the attribute.
    :paramtype content: object
    :keyword name: The name of the attribute.
    :paramtype name: str
    :return: Returns an :class:`~azure.purview.catalog.core.rest.HttpRequest` that you will pass to the client's `send_request` method.
     See https://aka.ms/azsdk/python/llcwiki for how to incorporate this response into your code flow.
    :rtype: ~azure.purview.catalog.core.rest.HttpRequest
    """
    content_type = kwargs.pop("content_type", None)
    accept = "application/json"

    # Construct URL
    url = kwargs.pop("template_url", '/atlas/v2/entity/guid/{guid}')
    path_format_arguments = {
        'guid': _SERIALIZER.url("guid", guid, 'str', max_length=4096, min_length=1),
    }
    url = _format_url_section(url, **path_format_arguments)

    # Construct parameters
    query_parameters = kwargs.pop("params", {})  # type: Dict[str, Any]
    query_parameters['name'] = _SERIALIZER.query("name", name, 'str')

    # Construct headers
    header_parameters = kwargs.pop("headers", {})  # type: Dict[str, Any]
    if content_type is not None:
        header_parameters['Content-Type'] = _SERIALIZER.header("content_type", content_type, 'str')
    header_parameters['Accept'] = _SERIALIZER.header("accept", accept, 'str')

    return HttpRequest(
        method="PUT",
        url=url,
        params=query_parameters,
        headers=header_parameters,
        json=json,
        content=content,
        **kwargs
    )


def build_entityrest_delete_by_guid_request(
    guid: str,
    **kwargs: Any
) -> HttpRequest:
    """Delete an entity identified by its GUID.

    Delete an entity identified by its GUID.

    See https://aka.ms/azsdk/python/llcwiki for how to incorporate this request_builder into your code flow.

    :param guid: The globally unique identifier of the entity.
    :type guid: str
    :return: Returns an :class:`~azure.purview.catalog.core.rest.HttpRequest` that you will pass to the client's `send_request` method.
     See https://aka.ms/azsdk/python/llcwiki for how to incorporate this response into your code flow.
    :rtype: ~azure.purview.catalog.core.rest.HttpRequest
    """
    accept = "application/json"

    # Construct URL
    url = kwargs.pop("template_url", '/atlas/v2/entity/guid/{guid}')
    path_format_arguments = {
        'guid': _SERIALIZER.url("guid", guid, 'str', max_length=4096, min_length=1),
    }
    url = _format_url_section(url, **path_format_arguments)

    # Construct headers
    header_parameters = kwargs.pop("headers", {})  # type: Dict[str, Any]
    header_parameters['Accept'] = _SERIALIZER.header("accept", accept, 'str')

    return HttpRequest(
        method="DELETE",
        url=url,
        headers=header_parameters,
        **kwargs
    )


def build_entityrest_get_classification_request(
    guid: str,
    classification_name: str,
    **kwargs: Any
) -> HttpRequest:
    """List classifications for a given entity represented by a GUID.

    List classifications for a given entity represented by a GUID.

    See https://aka.ms/azsdk/python/llcwiki for how to incorporate this request_builder into your code flow.

    :param guid: The globally unique identifier of the entity.
    :type guid: str
    :param classification_name: The name of the classification.
    :type classification_name: str
    :return: Returns an :class:`~azure.purview.catalog.core.rest.HttpRequest` that you will pass to the client's `send_request` method.
     See https://aka.ms/azsdk/python/llcwiki for how to incorporate this response into your code flow.
    :rtype: ~azure.purview.catalog.core.rest.HttpRequest
    """
    accept = "application/json"

    # Construct URL
    url = kwargs.pop("template_url", '/atlas/v2/entity/guid/{guid}/classification/{classificationName}')
    path_format_arguments = {
        'guid': _SERIALIZER.url("guid", guid, 'str', max_length=4096, min_length=1),
        'classificationName': _SERIALIZER.url("classification_name", classification_name, 'str', max_length=4096, min_length=1),
    }
    url = _format_url_section(url, **path_format_arguments)

    # Construct headers
    header_parameters = kwargs.pop("headers", {})  # type: Dict[str, Any]
    header_parameters['Accept'] = _SERIALIZER.header("accept", accept, 'str')

    return HttpRequest(
        method="GET",
        url=url,
        headers=header_parameters,
        **kwargs
    )


def build_entityrest_delete_classification_request(
    guid: str,
    classification_name: str,
    **kwargs: Any
) -> HttpRequest:
    """Delete a given classification from an existing entity represented by a GUID.

    Delete a given classification from an existing entity represented by a GUID.

    See https://aka.ms/azsdk/python/llcwiki for how to incorporate this request_builder into your code flow.

    :param guid: The globally unique identifier of the entity.
    :type guid: str
    :param classification_name: The name of the classification.
    :type classification_name: str
    :return: Returns an :class:`~azure.purview.catalog.core.rest.HttpRequest` that you will pass to the client's `send_request` method.
     See https://aka.ms/azsdk/python/llcwiki for how to incorporate this response into your code flow.
    :rtype: ~azure.purview.catalog.core.rest.HttpRequest
    """

    # Construct URL
    url = kwargs.pop("template_url", '/atlas/v2/entity/guid/{guid}/classification/{classificationName}')
    path_format_arguments = {
        'guid': _SERIALIZER.url("guid", guid, 'str', max_length=4096, min_length=1),
        'classificationName': _SERIALIZER.url("classification_name", classification_name, 'str', max_length=4096, min_length=1),
    }
    url = _format_url_section(url, **path_format_arguments)

    return HttpRequest(
        method="DELETE",
        url=url,
        **kwargs
    )


def build_entityrest_get_classifications_request(
    guid: str,
    **kwargs: Any
) -> HttpRequest:
    """List classifications for a given entity represented by a GUID.

    List classifications for a given entity represented by a GUID.

    See https://aka.ms/azsdk/python/llcwiki for how to incorporate this request_builder into your code flow.

    :param guid: The globally unique identifier of the entity.
    :type guid: str
    :return: Returns an :class:`~azure.purview.catalog.core.rest.HttpRequest` that you will pass to the client's `send_request` method.
     See https://aka.ms/azsdk/python/llcwiki for how to incorporate this response into your code flow.
    :rtype: ~azure.purview.catalog.core.rest.HttpRequest
    """
    accept = "application/json"

    # Construct URL
    url = kwargs.pop("template_url", '/atlas/v2/entity/guid/{guid}/classifications')
    path_format_arguments = {
        'guid': _SERIALIZER.url("guid", guid, 'str', max_length=4096, min_length=1),
    }
    url = _format_url_section(url, **path_format_arguments)

    # Construct headers
    header_parameters = kwargs.pop("headers", {})  # type: Dict[str, Any]
    header_parameters['Accept'] = _SERIALIZER.header("accept", accept, 'str')

    return HttpRequest(
        method="GET",
        url=url,
        headers=header_parameters,
        **kwargs
    )


def build_entityrest_add_classifications_request(
    guid: str,
    *,
    json: Any = None,
    content: Any = None,
    **kwargs: Any
) -> HttpRequest:
    """Add classifications to an existing entity represented by a GUID.

    Add classifications to an existing entity represented by a GUID.

    See https://aka.ms/azsdk/python/llcwiki for how to incorporate this request_builder into your code flow.

    :param guid: The globally unique identifier of the entity.
    :type guid: str
    :keyword json: An array of classifications to be added.
    :paramtype json: Any
    :keyword content: An array of classifications to be added.
    :paramtype content: Any
    :return: Returns an :class:`~azure.purview.catalog.core.rest.HttpRequest` that you will pass to the client's `send_request` method.
     See https://aka.ms/azsdk/python/llcwiki for how to incorporate this response into your code flow.
    :rtype: ~azure.purview.catalog.core.rest.HttpRequest
    """
    content_type = kwargs.pop("content_type", None)

    # Construct URL
    url = kwargs.pop("template_url", '/atlas/v2/entity/guid/{guid}/classifications')
    path_format_arguments = {
        'guid': _SERIALIZER.url("guid", guid, 'str', max_length=4096, min_length=1),
    }
    url = _format_url_section(url, **path_format_arguments)

    # Construct headers
    header_parameters = kwargs.pop("headers", {})  # type: Dict[str, Any]
    if content_type is not None:
        header_parameters['Content-Type'] = _SERIALIZER.header("content_type", content_type, 'str')

    return HttpRequest(
        method="POST",
        url=url,
        headers=header_parameters,
        json=json,
        content=content,
        **kwargs
    )


def build_entityrest_update_classifications_request(
    guid: str,
    *,
    json: Any = None,
    content: Any = None,
    **kwargs: Any
) -> HttpRequest:
    """Update classifications to an existing entity represented by a guid.

    Update classifications to an existing entity represented by a guid.

    See https://aka.ms/azsdk/python/llcwiki for how to incorporate this request_builder into your code flow.

    :param guid: The globally unique identifier of the entity.
    :type guid: str
    :keyword json: An array of classifications to be updated.
    :paramtype json: Any
    :keyword content: An array of classifications to be updated.
    :paramtype content: Any
    :return: Returns an :class:`~azure.purview.catalog.core.rest.HttpRequest` that you will pass to the client's `send_request` method.
     See https://aka.ms/azsdk/python/llcwiki for how to incorporate this response into your code flow.
    :rtype: ~azure.purview.catalog.core.rest.HttpRequest
    """
    content_type = kwargs.pop("content_type", None)

    # Construct URL
    url = kwargs.pop("template_url", '/atlas/v2/entity/guid/{guid}/classifications')
    path_format_arguments = {
        'guid': _SERIALIZER.url("guid", guid, 'str', max_length=4096, min_length=1),
    }
    url = _format_url_section(url, **path_format_arguments)

    # Construct headers
    header_parameters = kwargs.pop("headers", {})  # type: Dict[str, Any]
    if content_type is not None:
        header_parameters['Content-Type'] = _SERIALIZER.header("content_type", content_type, 'str')

    return HttpRequest(
        method="PUT",
        url=url,
        headers=header_parameters,
        json=json,
        content=content,
        **kwargs
    )


def build_entityrest_get_by_unique_attributes_request(
    type_name: str,
    *,
    min_ext_info: Optional[bool] = False,
    ignore_relationships: Optional[bool] = False,
    attr_qualified_name: Optional[str] = None,
    **kwargs: Any
) -> HttpRequest:
    """Get complete definition of an entity given its type and unique attribute.

    Get complete definition of an entity given its type and unique attribute.
    In addition to the typeName path parameter, attribute key-value pair(s) can be provided in the
    following format:
    attr:\:code:`<attrName>`=:code:`<attrValue>`.
    NOTE: The attrName and attrValue should be unique across entities, eg. qualifiedName.
    The REST request would look something like this:
    GET /v2/entity/uniqueAttribute/type/aType?attr:aTypeAttribute=someValue.

    See https://aka.ms/azsdk/python/llcwiki for how to incorporate this request_builder into your code flow.

    :param type_name: The name of the type.
    :type type_name: str
    :keyword min_ext_info: Whether to return minimal information for referred entities.
    :paramtype min_ext_info: bool
    :keyword ignore_relationships: Whether to ignore relationship attributes.
    :paramtype ignore_relationships: bool
    :keyword attr_qualified_name: The qualified name of the entity.
    :paramtype attr_qualified_name: str
    :return: Returns an :class:`~azure.purview.catalog.core.rest.HttpRequest` that you will pass to the client's `send_request` method.
     See https://aka.ms/azsdk/python/llcwiki for how to incorporate this response into your code flow.
    :rtype: ~azure.purview.catalog.core.rest.HttpRequest
    """
    accept = "application/json"

    # Construct URL
    url = kwargs.pop("template_url", '/atlas/v2/entity/uniqueAttribute/type/{typeName}')
    path_format_arguments = {
        'typeName': _SERIALIZER.url("type_name", type_name, 'str', max_length=4096, min_length=1),
    }
    url = _format_url_section(url, **path_format_arguments)

    # Construct parameters
    query_parameters = kwargs.pop("params", {})  # type: Dict[str, Any]
    if min_ext_info is not None:
        query_parameters['minExtInfo'] = _SERIALIZER.query("min_ext_info", min_ext_info, 'bool')
    if ignore_relationships is not None:
        query_parameters['ignoreRelationships'] = _SERIALIZER.query("ignore_relationships", ignore_relationships, 'bool')
    if attr_qualified_name is not None:
        query_parameters['attr:qualifiedName'] = _SERIALIZER.query("attr_qualified_name", attr_qualified_name, 'str')

    # Construct headers
    header_parameters = kwargs.pop("headers", {})  # type: Dict[str, Any]
    header_parameters['Accept'] = _SERIALIZER.header("accept", accept, 'str')

    return HttpRequest(
        method="GET",
        url=url,
        params=query_parameters,
        headers=header_parameters,
        **kwargs
    )


def build_entityrest_partial_update_entity_by_unique_attrs_request(
    type_name: str,
    *,
    json: Any = None,
    content: Any = None,
    attr_qualified_name: Optional[str] = None,
    **kwargs: Any
) -> HttpRequest:
    """Update entity partially - Allow a subset of attributes to be updated on.

    Update entity partially - Allow a subset of attributes to be updated on
    an entity which is identified by its type and unique attribute  eg:
    Referenceable.qualifiedName.
    Null updates are not possible.
    In addition to the typeName path parameter, attribute key-value pair(s) can be provided in the
    following format:
    attr::code:`<attrName>`=:code:`<attrValue>`.
    NOTE: The attrName and attrValue should be unique across entities, eg. qualifiedName.
    The REST request would look something like this:
    PUT /v2/entity/uniqueAttribute/type/aType?attr:aTypeAttribute=someValue.

    See https://aka.ms/azsdk/python/llcwiki for how to incorporate this request_builder into your code flow.

    :param type_name: The name of the type.
    :type type_name: str
    :keyword json: Atlas entity with extended information.
    :paramtype json: Any
    :keyword content: Atlas entity with extended information.
    :paramtype content: Any
    :keyword attr_qualified_name: The qualified name of the entity.
    :paramtype attr_qualified_name: str
    :return: Returns an :class:`~azure.purview.catalog.core.rest.HttpRequest` that you will pass to the client's `send_request` method.
     See https://aka.ms/azsdk/python/llcwiki for how to incorporate this response into your code flow.
    :rtype: ~azure.purview.catalog.core.rest.HttpRequest
    """
    content_type = kwargs.pop("content_type", None)
    accept = "application/json"

    # Construct URL
    url = kwargs.pop("template_url", '/atlas/v2/entity/uniqueAttribute/type/{typeName}')
    path_format_arguments = {
        'typeName': _SERIALIZER.url("type_name", type_name, 'str', max_length=4096, min_length=1),
    }
    url = _format_url_section(url, **path_format_arguments)

    # Construct parameters
    query_parameters = kwargs.pop("params", {})  # type: Dict[str, Any]
    if attr_qualified_name is not None:
        query_parameters['attr:qualifiedName'] = _SERIALIZER.query("attr_qualified_name", attr_qualified_name, 'str')

    # Construct headers
    header_parameters = kwargs.pop("headers", {})  # type: Dict[str, Any]
    if content_type is not None:
        header_parameters['Content-Type'] = _SERIALIZER.header("content_type", content_type, 'str')
    header_parameters['Accept'] = _SERIALIZER.header("accept", accept, 'str')

    return HttpRequest(
        method="PUT",
        url=url,
        params=query_parameters,
        headers=header_parameters,
        json=json,
        content=content,
        **kwargs
    )


def build_entityrest_delete_by_unique_attribute_request(
    type_name: str,
    *,
    attr_qualified_name: Optional[str] = None,
    **kwargs: Any
) -> HttpRequest:
    """Delete an entity identified by its type and unique attributes.

    Delete an entity identified by its type and unique attributes.
    In addition to the typeName path parameter, attribute key-value pair(s) can be provided in the
    following format:
    attr:\:code:`<attrName>`=\:code:`<attrValue>`.
    NOTE: The attrName and attrValue should be unique across entities, eg. qualifiedName.
    The REST request would look something like this:
    DELETE /v2/entity/uniqueAttribute/type/aType?attr:aTypeAttribute=someValue.

    See https://aka.ms/azsdk/python/llcwiki for how to incorporate this request_builder into your code flow.

    :param type_name: The name of the type.
    :type type_name: str
    :keyword attr_qualified_name: The qualified name of the entity.
    :paramtype attr_qualified_name: str
    :return: Returns an :class:`~azure.purview.catalog.core.rest.HttpRequest` that you will pass to the client's `send_request` method.
     See https://aka.ms/azsdk/python/llcwiki for how to incorporate this response into your code flow.
    :rtype: ~azure.purview.catalog.core.rest.HttpRequest
    """
    accept = "application/json"

    # Construct URL
    url = kwargs.pop("template_url", '/atlas/v2/entity/uniqueAttribute/type/{typeName}')
    path_format_arguments = {
        'typeName': _SERIALIZER.url("type_name", type_name, 'str', max_length=4096, min_length=1),
    }
    url = _format_url_section(url, **path_format_arguments)

    # Construct parameters
    query_parameters = kwargs.pop("params", {})  # type: Dict[str, Any]
    if attr_qualified_name is not None:
        query_parameters['attr:qualifiedName'] = _SERIALIZER.query("attr_qualified_name", attr_qualified_name, 'str')

    # Construct headers
    header_parameters = kwargs.pop("headers", {})  # type: Dict[str, Any]
    header_parameters['Accept'] = _SERIALIZER.header("accept", accept, 'str')

    return HttpRequest(
        method="DELETE",
        url=url,
        params=query_parameters,
        headers=header_parameters,
        **kwargs
    )


def build_entityrest_delete_classification_by_unique_attribute_request(
    type_name: str,
    classification_name: str,
    *,
    attr_qualified_name: Optional[str] = None,
    **kwargs: Any
) -> HttpRequest:
    """Delete a given classification from an entity.

    Delete a given classification from an entity identified by its type and unique attributes.

    See https://aka.ms/azsdk/python/llcwiki for how to incorporate this request_builder into your code flow.

    :param type_name: The name of the type.
    :type type_name: str
    :param classification_name: The name of the classification.
    :type classification_name: str
    :keyword attr_qualified_name: The qualified name of the entity.
    :paramtype attr_qualified_name: str
    :return: Returns an :class:`~azure.purview.catalog.core.rest.HttpRequest` that you will pass to the client's `send_request` method.
     See https://aka.ms/azsdk/python/llcwiki for how to incorporate this response into your code flow.
    :rtype: ~azure.purview.catalog.core.rest.HttpRequest
    """

    # Construct URL
    url = kwargs.pop("template_url", '/atlas/v2/entity/uniqueAttribute/type/{typeName}/classification/{classificationName}')
    path_format_arguments = {
        'typeName': _SERIALIZER.url("type_name", type_name, 'str', max_length=4096, min_length=1),
        'classificationName': _SERIALIZER.url("classification_name", classification_name, 'str', max_length=4096, min_length=1),
    }
    url = _format_url_section(url, **path_format_arguments)

    # Construct parameters
    query_parameters = kwargs.pop("params", {})  # type: Dict[str, Any]
    if attr_qualified_name is not None:
        query_parameters['attr:qualifiedName'] = _SERIALIZER.query("attr_qualified_name", attr_qualified_name, 'str')

    return HttpRequest(
        method="DELETE",
        url=url,
        params=query_parameters,
        **kwargs
    )


def build_entityrest_add_classifications_by_unique_attribute_request(
    type_name: str,
    *,
    json: Any = None,
    content: Any = None,
    attr_qualified_name: Optional[str] = None,
    **kwargs: Any
) -> HttpRequest:
    """Add classification to the entity.

    Add classification to the entity identified by its type and unique attributes.

    See https://aka.ms/azsdk/python/llcwiki for how to incorporate this request_builder into your code flow.

    :param type_name: The name of the type.
    :type type_name: str
    :keyword json: An array of classification to be added.
    :paramtype json: Any
    :keyword content: An array of classification to be added.
    :paramtype content: Any
    :keyword attr_qualified_name: The qualified name of the entity.
    :paramtype attr_qualified_name: str
    :return: Returns an :class:`~azure.purview.catalog.core.rest.HttpRequest` that you will pass to the client's `send_request` method.
     See https://aka.ms/azsdk/python/llcwiki for how to incorporate this response into your code flow.
    :rtype: ~azure.purview.catalog.core.rest.HttpRequest
    """
    content_type = kwargs.pop("content_type", None)

    # Construct URL
    url = kwargs.pop("template_url", '/atlas/v2/entity/uniqueAttribute/type/{typeName}/classifications')
    path_format_arguments = {
        'typeName': _SERIALIZER.url("type_name", type_name, 'str', max_length=4096, min_length=1),
    }
    url = _format_url_section(url, **path_format_arguments)

    # Construct parameters
    query_parameters = kwargs.pop("params", {})  # type: Dict[str, Any]
    if attr_qualified_name is not None:
        query_parameters['attr:qualifiedName'] = _SERIALIZER.query("attr_qualified_name", attr_qualified_name, 'str')

    # Construct headers
    header_parameters = kwargs.pop("headers", {})  # type: Dict[str, Any]
    if content_type is not None:
        header_parameters['Content-Type'] = _SERIALIZER.header("content_type", content_type, 'str')

    return HttpRequest(
        method="POST",
        url=url,
        params=query_parameters,
        headers=header_parameters,
        json=json,
        content=content,
        **kwargs
    )


def build_entityrest_update_classifications_by_unique_attribute_request(
    type_name: str,
    *,
    json: Any = None,
    content: Any = None,
    attr_qualified_name: Optional[str] = None,
    **kwargs: Any
) -> HttpRequest:
    """Update classification on an entity identified by its type and unique attributes.

    Update classification on an entity identified by its type and unique attributes.

    See https://aka.ms/azsdk/python/llcwiki for how to incorporate this request_builder into your code flow.

    :param type_name: The name of the type.
    :type type_name: str
    :keyword json: An array of classification to be updated.
    :paramtype json: Any
    :keyword content: An array of classification to be updated.
    :paramtype content: Any
    :keyword attr_qualified_name: The qualified name of the entity.
    :paramtype attr_qualified_name: str
    :return: Returns an :class:`~azure.purview.catalog.core.rest.HttpRequest` that you will pass to the client's `send_request` method.
     See https://aka.ms/azsdk/python/llcwiki for how to incorporate this response into your code flow.
    :rtype: ~azure.purview.catalog.core.rest.HttpRequest
    """
    content_type = kwargs.pop("content_type", None)

    # Construct URL
    url = kwargs.pop("template_url", '/atlas/v2/entity/uniqueAttribute/type/{typeName}/classifications')
    path_format_arguments = {
        'typeName': _SERIALIZER.url("type_name", type_name, 'str', max_length=4096, min_length=1),
    }
    url = _format_url_section(url, **path_format_arguments)

    # Construct parameters
    query_parameters = kwargs.pop("params", {})  # type: Dict[str, Any]
    if attr_qualified_name is not None:
        query_parameters['attr:qualifiedName'] = _SERIALIZER.query("attr_qualified_name", attr_qualified_name, 'str')

    # Construct headers
    header_parameters = kwargs.pop("headers", {})  # type: Dict[str, Any]
    if content_type is not None:
        header_parameters['Content-Type'] = _SERIALIZER.header("content_type", content_type, 'str')

    return HttpRequest(
        method="PUT",
        url=url,
        params=query_parameters,
        headers=header_parameters,
        json=json,
        content=content,
        **kwargs
    )


def build_entityrest_set_classifications_request(
    *,
    json: Any = None,
    content: Any = None,
    **kwargs: Any
) -> HttpRequest:
    """Set classifications on entities in bulk.

    Set classifications on entities in bulk.

    See https://aka.ms/azsdk/python/llcwiki for how to incorporate this request_builder into your code flow.

    :keyword json: Atlas entity headers.
    :paramtype json: Any
    :keyword content: Atlas entity headers.
    :paramtype content: Any
    :return: Returns an :class:`~azure.purview.catalog.core.rest.HttpRequest` that you will pass to the client's `send_request` method.
     See https://aka.ms/azsdk/python/llcwiki for how to incorporate this response into your code flow.
    :rtype: ~azure.purview.catalog.core.rest.HttpRequest
    """
    content_type = kwargs.pop("content_type", None)
    accept = "application/json"

    # Construct URL
    url = kwargs.pop("template_url", '/atlas/v2/entity/bulk/setClassifications')

    # Construct headers
    header_parameters = kwargs.pop("headers", {})  # type: Dict[str, Any]
    if content_type is not None:
        header_parameters['Content-Type'] = _SERIALIZER.header("content_type", content_type, 'str')
    header_parameters['Accept'] = _SERIALIZER.header("accept", accept, 'str')

    return HttpRequest(
        method="POST",
        url=url,
        headers=header_parameters,
        json=json,
        content=content,
        **kwargs
    )


def build_entityrest_get_entities_by_unique_attributes_request(
    type_name: str,
    *,
    min_ext_info: Optional[bool] = False,
    ignore_relationships: Optional[bool] = False,
    attr_n_qualified_name: Optional[str] = None,
    **kwargs: Any
) -> HttpRequest:
    """Bulk API to retrieve list of entities identified by its unique attributes.

    Bulk API to retrieve list of entities identified by its unique attributes.

    In addition to the typeName path parameter, attribute key-value pair(s) can be provided in the
    following format

    typeName=\:code:`<typeName>`&attr_1:\:code:`<attrName>`=\:code:`<attrValue>`&attr_2:\:code:`<attrName>`=\:code:`<attrValue>`&attr_3:\:code:`<attrName>`=\:code:`<attrValue>`

    NOTE: The attrName should be an unique attribute for the given entity-type

    The REST request would look something like this

    GET
    /v2/entity/bulk/uniqueAttribute/type/hive_db?attr_0:qualifiedName=db1@cl1&attr_2:qualifiedName=db2@cl1.

    See https://aka.ms/azsdk/python/llcwiki for how to incorporate this request_builder into your code flow.

    :param type_name: The name of the type.
    :type type_name: str
    :keyword min_ext_info: Whether to return minimal information for referred entities.
    :paramtype min_ext_info: bool
    :keyword ignore_relationships: Whether to ignore relationship attributes.
    :paramtype ignore_relationships: bool
    :keyword attr_n_qualified_name: Qualified name of an entity. E.g. to find 2 entities you can
     set attrs_0:qualifiedName=db1@cl1&attrs_2:qualifiedName=db2@cl1.
    :paramtype attr_n_qualified_name: str
    :return: Returns an :class:`~azure.purview.catalog.core.rest.HttpRequest` that you will pass to the client's `send_request` method.
     See https://aka.ms/azsdk/python/llcwiki for how to incorporate this response into your code flow.
    :rtype: ~azure.purview.catalog.core.rest.HttpRequest
    """
    accept = "application/json"

    # Construct URL
    url = kwargs.pop("template_url", '/atlas/v2/entity/bulk/uniqueAttribute/type/{typeName}')
    path_format_arguments = {
        'typeName': _SERIALIZER.url("type_name", type_name, 'str', max_length=4096, min_length=1),
    }
    url = _format_url_section(url, **path_format_arguments)

    # Construct parameters
    query_parameters = kwargs.pop("params", {})  # type: Dict[str, Any]
    if min_ext_info is not None:
        query_parameters['minExtInfo'] = _SERIALIZER.query("min_ext_info", min_ext_info, 'bool')
    if ignore_relationships is not None:
        query_parameters['ignoreRelationships'] = _SERIALIZER.query("ignore_relationships", ignore_relationships, 'bool')
    if attr_n_qualified_name is not None:
        query_parameters['attr_N:qualifiedName'] = _SERIALIZER.query("attr_n_qualified_name", attr_n_qualified_name, 'str')

    # Construct headers
    header_parameters = kwargs.pop("headers", {})  # type: Dict[str, Any]
    header_parameters['Accept'] = _SERIALIZER.header("accept", accept, 'str')

    return HttpRequest(
        method="GET",
        url=url,
        params=query_parameters,
        headers=header_parameters,
        **kwargs
    )


def build_entityrest_get_header_by_id_request(
    guid: str,
    **kwargs: Any
) -> HttpRequest:
    """Get entity header given its GUID.

    Get entity header given its GUID.

    See https://aka.ms/azsdk/python/llcwiki for how to incorporate this request_builder into your code flow.

    :param guid: The globally unique identifier of the entity.
    :type guid: str
    :return: Returns an :class:`~azure.purview.catalog.core.rest.HttpRequest` that you will pass to the client's `send_request` method.
     See https://aka.ms/azsdk/python/llcwiki for how to incorporate this response into your code flow.
    :rtype: ~azure.purview.catalog.core.rest.HttpRequest
    """
    accept = "application/json"

    # Construct URL
    url = kwargs.pop("template_url", '/atlas/v2/entity/guid/{guid}/header')
    path_format_arguments = {
        'guid': _SERIALIZER.url("guid", guid, 'str', max_length=4096, min_length=1),
    }
    url = _format_url_section(url, **path_format_arguments)

    # Construct headers
    header_parameters = kwargs.pop("headers", {})  # type: Dict[str, Any]
    header_parameters['Accept'] = _SERIALIZER.header("accept", accept, 'str')

    return HttpRequest(
        method="GET",
        url=url,
        headers=header_parameters,
        **kwargs
    )


def build_glossaryrest_get_glossaries_request(
    *,
    limit: Optional[int] = None,
    offset: Optional[int] = None,
    sort: Optional[str] = "ASC",
    **kwargs: Any
) -> HttpRequest:
    """Get all glossaries registered with Atlas.

    Get all glossaries registered with Atlas.

    See https://aka.ms/azsdk/python/llcwiki for how to incorporate this request_builder into your code flow.

    :keyword limit: The page size - by default there is no paging.
    :paramtype limit: int
    :keyword offset: The offset for pagination purpose.
    :paramtype offset: int
    :keyword sort: The sort order, ASC (default) or DESC.
    :paramtype sort: str
    :return: Returns an :class:`~azure.purview.catalog.core.rest.HttpRequest` that you will pass to the client's `send_request` method.
     See https://aka.ms/azsdk/python/llcwiki for how to incorporate this response into your code flow.
    :rtype: ~azure.purview.catalog.core.rest.HttpRequest
    """
    accept = "application/json"

    # Construct URL
    url = kwargs.pop("template_url", '/atlas/v2/glossary')

    # Construct parameters
    query_parameters = kwargs.pop("params", {})  # type: Dict[str, Any]
    if limit is not None:
        query_parameters['limit'] = _SERIALIZER.query("limit", limit, 'int')
    if offset is not None:
        query_parameters['offset'] = _SERIALIZER.query("offset", offset, 'int')
    if sort is not None:
        query_parameters['sort'] = _SERIALIZER.query("sort", sort, 'str')

    # Construct headers
    header_parameters = kwargs.pop("headers", {})  # type: Dict[str, Any]
    header_parameters['Accept'] = _SERIALIZER.header("accept", accept, 'str')

    return HttpRequest(
        method="GET",
        url=url,
        params=query_parameters,
        headers=header_parameters,
        **kwargs
    )


def build_glossaryrest_create_glossary_request(
    *,
    json: Any = None,
    content: Any = None,
    **kwargs: Any
) -> HttpRequest:
    """Create a glossary.

    Create a glossary.

    See https://aka.ms/azsdk/python/llcwiki for how to incorporate this request_builder into your code flow.

    :keyword json: Glossary definition, terms & categories can be anchored to a glossary.
     Using the anchor attribute when creating the Term/Category.
    :paramtype json: Any
    :keyword content: Glossary definition, terms & categories can be anchored to a glossary.
     Using the anchor attribute when creating the Term/Category.
    :paramtype content: Any
    :return: Returns an :class:`~azure.purview.catalog.core.rest.HttpRequest` that you will pass to the client's `send_request` method.
     See https://aka.ms/azsdk/python/llcwiki for how to incorporate this response into your code flow.
    :rtype: ~azure.purview.catalog.core.rest.HttpRequest
    """
    content_type = kwargs.pop("content_type", None)
    accept = "application/json"

    # Construct URL
    url = kwargs.pop("template_url", '/atlas/v2/glossary')

    # Construct headers
    header_parameters = kwargs.pop("headers", {})  # type: Dict[str, Any]
    if content_type is not None:
        header_parameters['Content-Type'] = _SERIALIZER.header("content_type", content_type, 'str')
    header_parameters['Accept'] = _SERIALIZER.header("accept", accept, 'str')

    return HttpRequest(
        method="POST",
        url=url,
        headers=header_parameters,
        json=json,
        content=content,
        **kwargs
    )


def build_glossaryrest_create_glossary_categories_request(
    *,
    json: Any = None,
    content: Any = None,
    **kwargs: Any
) -> HttpRequest:
    """Create glossary category in bulk.

    Create glossary category in bulk.

    See https://aka.ms/azsdk/python/llcwiki for how to incorporate this request_builder into your code flow.

    :keyword json: An array of glossary category definitions to be created.
    :paramtype json: Any
    :keyword content: An array of glossary category definitions to be created.
    :paramtype content: Any
    :return: Returns an :class:`~azure.purview.catalog.core.rest.HttpRequest` that you will pass to the client's `send_request` method.
     See https://aka.ms/azsdk/python/llcwiki for how to incorporate this response into your code flow.
    :rtype: ~azure.purview.catalog.core.rest.HttpRequest
    """
    content_type = kwargs.pop("content_type", None)
    accept = "application/json"

    # Construct URL
    url = kwargs.pop("template_url", '/atlas/v2/glossary/categories')

    # Construct headers
    header_parameters = kwargs.pop("headers", {})  # type: Dict[str, Any]
    if content_type is not None:
        header_parameters['Content-Type'] = _SERIALIZER.header("content_type", content_type, 'str')
    header_parameters['Accept'] = _SERIALIZER.header("accept", accept, 'str')

    return HttpRequest(
        method="POST",
        url=url,
        headers=header_parameters,
        json=json,
        content=content,
        **kwargs
    )


def build_glossaryrest_create_glossary_category_request(
    *,
    json: Any = None,
    content: Any = None,
    **kwargs: Any
) -> HttpRequest:
    """Create a glossary category.

    Create a glossary category.

    See https://aka.ms/azsdk/python/llcwiki for how to incorporate this request_builder into your code flow.

    :keyword json: The glossary category definition. A category must be anchored to a Glossary when
     creating.
     Optionally, terms belonging to the category and the hierarchy can also be defined during
     creation.
    :paramtype json: Any
    :keyword content: The glossary category definition. A category must be anchored to a Glossary
     when creating.
     Optionally, terms belonging to the category and the hierarchy can also be defined during
     creation.
    :paramtype content: Any
    :return: Returns an :class:`~azure.purview.catalog.core.rest.HttpRequest` that you will pass to the client's `send_request` method.
     See https://aka.ms/azsdk/python/llcwiki for how to incorporate this response into your code flow.
    :rtype: ~azure.purview.catalog.core.rest.HttpRequest
    """
    content_type = kwargs.pop("content_type", None)
    accept = "application/json"

    # Construct URL
    url = kwargs.pop("template_url", '/atlas/v2/glossary/category')

    # Construct headers
    header_parameters = kwargs.pop("headers", {})  # type: Dict[str, Any]
    if content_type is not None:
        header_parameters['Content-Type'] = _SERIALIZER.header("content_type", content_type, 'str')
    header_parameters['Accept'] = _SERIALIZER.header("accept", accept, 'str')

    return HttpRequest(
        method="POST",
        url=url,
        headers=header_parameters,
        json=json,
        content=content,
        **kwargs
    )


def build_glossaryrest_get_glossary_category_request(
    category_guid: str,
    **kwargs: Any
) -> HttpRequest:
    """Get specific glossary category by its GUID.

    Get specific glossary category by its GUID.

    See https://aka.ms/azsdk/python/llcwiki for how to incorporate this request_builder into your code flow.

    :param category_guid: The globally unique identifier of the category.
    :type category_guid: str
    :return: Returns an :class:`~azure.purview.catalog.core.rest.HttpRequest` that you will pass to the client's `send_request` method.
     See https://aka.ms/azsdk/python/llcwiki for how to incorporate this response into your code flow.
    :rtype: ~azure.purview.catalog.core.rest.HttpRequest
    """
    accept = "application/json"

    # Construct URL
    url = kwargs.pop("template_url", '/atlas/v2/glossary/category/{categoryGuid}')
    path_format_arguments = {
        'categoryGuid': _SERIALIZER.url("category_guid", category_guid, 'str', max_length=4096, min_length=1),
    }
    url = _format_url_section(url, **path_format_arguments)

    # Construct headers
    header_parameters = kwargs.pop("headers", {})  # type: Dict[str, Any]
    header_parameters['Accept'] = _SERIALIZER.header("accept", accept, 'str')

    return HttpRequest(
        method="GET",
        url=url,
        headers=header_parameters,
        **kwargs
    )


def build_glossaryrest_update_glossary_category_request(
    category_guid: str,
    *,
    json: Any = None,
    content: Any = None,
    **kwargs: Any
) -> HttpRequest:
    """Update the given glossary category by its GUID.

    Update the given glossary category by its GUID.

    See https://aka.ms/azsdk/python/llcwiki for how to incorporate this request_builder into your code flow.

    :param category_guid: The globally unique identifier of the category.
    :type category_guid: str
    :keyword json: The glossary category to be updated.
    :paramtype json: Any
    :keyword content: The glossary category to be updated.
    :paramtype content: Any
    :return: Returns an :class:`~azure.purview.catalog.core.rest.HttpRequest` that you will pass to the client's `send_request` method.
     See https://aka.ms/azsdk/python/llcwiki for how to incorporate this response into your code flow.
    :rtype: ~azure.purview.catalog.core.rest.HttpRequest
    """
    content_type = kwargs.pop("content_type", None)
    accept = "application/json"

    # Construct URL
    url = kwargs.pop("template_url", '/atlas/v2/glossary/category/{categoryGuid}')
    path_format_arguments = {
        'categoryGuid': _SERIALIZER.url("category_guid", category_guid, 'str', max_length=4096, min_length=1),
    }
    url = _format_url_section(url, **path_format_arguments)

    # Construct headers
    header_parameters = kwargs.pop("headers", {})  # type: Dict[str, Any]
    if content_type is not None:
        header_parameters['Content-Type'] = _SERIALIZER.header("content_type", content_type, 'str')
    header_parameters['Accept'] = _SERIALIZER.header("accept", accept, 'str')

    return HttpRequest(
        method="PUT",
        url=url,
        headers=header_parameters,
        json=json,
        content=content,
        **kwargs
    )


def build_glossaryrest_delete_glossary_category_request(
    category_guid: str,
    **kwargs: Any
) -> HttpRequest:
    """Delete a glossary category.

    Delete a glossary category.

    See https://aka.ms/azsdk/python/llcwiki for how to incorporate this request_builder into your code flow.

    :param category_guid: The globally unique identifier of the category.
    :type category_guid: str
    :return: Returns an :class:`~azure.purview.catalog.core.rest.HttpRequest` that you will pass to the client's `send_request` method.
     See https://aka.ms/azsdk/python/llcwiki for how to incorporate this response into your code flow.
    :rtype: ~azure.purview.catalog.core.rest.HttpRequest
    """

    # Construct URL
    url = kwargs.pop("template_url", '/atlas/v2/glossary/category/{categoryGuid}')
    path_format_arguments = {
        'categoryGuid': _SERIALIZER.url("category_guid", category_guid, 'str', max_length=4096, min_length=1),
    }
    url = _format_url_section(url, **path_format_arguments)

    return HttpRequest(
        method="DELETE",
        url=url,
        **kwargs
    )


def build_glossaryrest_partial_update_glossary_category_request(
    category_guid: str,
    *,
    json: Any = None,
    content: Any = None,
    **kwargs: Any
) -> HttpRequest:
    """Update the glossary category partially.

    Update the glossary category partially.

    See https://aka.ms/azsdk/python/llcwiki for how to incorporate this request_builder into your code flow.

    :param category_guid: The globally unique identifier of the category.
    :type category_guid: str
    :keyword json: A map containing keys as attribute names and values as corresponding attribute
     values for partial update.
    :paramtype json: Any
    :keyword content: A map containing keys as attribute names and values as corresponding
     attribute values for partial update.
    :paramtype content: Any
    :return: Returns an :class:`~azure.purview.catalog.core.rest.HttpRequest` that you will pass to the client's `send_request` method.
     See https://aka.ms/azsdk/python/llcwiki for how to incorporate this response into your code flow.
    :rtype: ~azure.purview.catalog.core.rest.HttpRequest
    """
    content_type = kwargs.pop("content_type", None)
    accept = "application/json"

    # Construct URL
    url = kwargs.pop("template_url", '/atlas/v2/glossary/category/{categoryGuid}/partial')
    path_format_arguments = {
        'categoryGuid': _SERIALIZER.url("category_guid", category_guid, 'str', max_length=4096, min_length=1),
    }
    url = _format_url_section(url, **path_format_arguments)

    # Construct headers
    header_parameters = kwargs.pop("headers", {})  # type: Dict[str, Any]
    if content_type is not None:
        header_parameters['Content-Type'] = _SERIALIZER.header("content_type", content_type, 'str')
    header_parameters['Accept'] = _SERIALIZER.header("accept", accept, 'str')

    return HttpRequest(
        method="PUT",
        url=url,
        headers=header_parameters,
        json=json,
        content=content,
        **kwargs
    )


def build_glossaryrest_get_related_categories_request(
    category_guid: str,
    *,
    limit: Optional[int] = None,
    offset: Optional[int] = None,
    sort: Optional[str] = "ASC",
    **kwargs: Any
) -> HttpRequest:
    """Get all related categories.

    Get all related categories (parent and children). Limit, offset, and sort parameters are
    currently not being enabled and won't work even they are passed.

    See https://aka.ms/azsdk/python/llcwiki for how to incorporate this request_builder into your code flow.

    :param category_guid: The globally unique identifier of the category.
    :type category_guid: str
    :keyword limit: The page size - by default there is no paging.
    :paramtype limit: int
    :keyword offset: The offset for pagination purpose.
    :paramtype offset: int
    :keyword sort: The sort order, ASC (default) or DESC.
    :paramtype sort: str
    :return: Returns an :class:`~azure.purview.catalog.core.rest.HttpRequest` that you will pass to the client's `send_request` method.
     See https://aka.ms/azsdk/python/llcwiki for how to incorporate this response into your code flow.
    :rtype: ~azure.purview.catalog.core.rest.HttpRequest
    """
    accept = "application/json"

    # Construct URL
    url = kwargs.pop("template_url", '/atlas/v2/glossary/category/{categoryGuid}/related')
    path_format_arguments = {
        'categoryGuid': _SERIALIZER.url("category_guid", category_guid, 'str', max_length=4096, min_length=1),
    }
    url = _format_url_section(url, **path_format_arguments)

    # Construct parameters
    query_parameters = kwargs.pop("params", {})  # type: Dict[str, Any]
    if limit is not None:
        query_parameters['limit'] = _SERIALIZER.query("limit", limit, 'int')
    if offset is not None:
        query_parameters['offset'] = _SERIALIZER.query("offset", offset, 'int')
    if sort is not None:
        query_parameters['sort'] = _SERIALIZER.query("sort", sort, 'str')

    # Construct headers
    header_parameters = kwargs.pop("headers", {})  # type: Dict[str, Any]
    header_parameters['Accept'] = _SERIALIZER.header("accept", accept, 'str')

    return HttpRequest(
        method="GET",
        url=url,
        params=query_parameters,
        headers=header_parameters,
        **kwargs
    )


def build_glossaryrest_get_category_terms_request(
    category_guid: str,
    *,
    limit: Optional[int] = None,
    offset: Optional[int] = None,
    sort: Optional[str] = "ASC",
    **kwargs: Any
) -> HttpRequest:
    """Get all terms associated with the specific category.

    Get all terms associated with the specific category.

    See https://aka.ms/azsdk/python/llcwiki for how to incorporate this request_builder into your code flow.

    :param category_guid: The globally unique identifier of the category.
    :type category_guid: str
    :keyword limit: The page size - by default there is no paging.
    :paramtype limit: int
    :keyword offset: The offset for pagination purpose.
    :paramtype offset: int
    :keyword sort: The sort order, ASC (default) or DESC.
    :paramtype sort: str
    :return: Returns an :class:`~azure.purview.catalog.core.rest.HttpRequest` that you will pass to the client's `send_request` method.
     See https://aka.ms/azsdk/python/llcwiki for how to incorporate this response into your code flow.
    :rtype: ~azure.purview.catalog.core.rest.HttpRequest
    """
    accept = "application/json"

    # Construct URL
    url = kwargs.pop("template_url", '/atlas/v2/glossary/category/{categoryGuid}/terms')
    path_format_arguments = {
        'categoryGuid': _SERIALIZER.url("category_guid", category_guid, 'str', max_length=4096, min_length=1),
    }
    url = _format_url_section(url, **path_format_arguments)

    # Construct parameters
    query_parameters = kwargs.pop("params", {})  # type: Dict[str, Any]
    if limit is not None:
        query_parameters['limit'] = _SERIALIZER.query("limit", limit, 'int')
    if offset is not None:
        query_parameters['offset'] = _SERIALIZER.query("offset", offset, 'int')
    if sort is not None:
        query_parameters['sort'] = _SERIALIZER.query("sort", sort, 'str')

    # Construct headers
    header_parameters = kwargs.pop("headers", {})  # type: Dict[str, Any]
    header_parameters['Accept'] = _SERIALIZER.header("accept", accept, 'str')

    return HttpRequest(
        method="GET",
        url=url,
        params=query_parameters,
        headers=header_parameters,
        **kwargs
    )


def build_glossaryrest_create_glossary_term_request(
    *,
    json: Any = None,
    content: Any = None,
    **kwargs: Any
) -> HttpRequest:
    """Create a glossary term.

    Create a glossary term.

    See https://aka.ms/azsdk/python/llcwiki for how to incorporate this request_builder into your code flow.

    :keyword json: The glossary term definition. A term must be anchored to a Glossary at the time
     of creation.
     Optionally it can be categorized as well.
    :paramtype json: Any
    :keyword content: The glossary term definition. A term must be anchored to a Glossary at the
     time of creation.
     Optionally it can be categorized as well.
    :paramtype content: Any
    :return: Returns an :class:`~azure.purview.catalog.core.rest.HttpRequest` that you will pass to the client's `send_request` method.
     See https://aka.ms/azsdk/python/llcwiki for how to incorporate this response into your code flow.
    :rtype: ~azure.purview.catalog.core.rest.HttpRequest
    """
    content_type = kwargs.pop("content_type", None)
    accept = "application/json"

    # Construct URL
    url = kwargs.pop("template_url", '/atlas/v2/glossary/term')

    # Construct headers
    header_parameters = kwargs.pop("headers", {})  # type: Dict[str, Any]
    if content_type is not None:
        header_parameters['Content-Type'] = _SERIALIZER.header("content_type", content_type, 'str')
    header_parameters['Accept'] = _SERIALIZER.header("accept", accept, 'str')

    return HttpRequest(
        method="POST",
        url=url,
        headers=header_parameters,
        json=json,
        content=content,
        **kwargs
    )


def build_glossaryrest_get_glossary_term_request(
    term_guid: str,
    **kwargs: Any
) -> HttpRequest:
    """Get a specific glossary term by its GUID.

    Get a specific glossary term by its GUID.

    See https://aka.ms/azsdk/python/llcwiki for how to incorporate this request_builder into your code flow.

    :param term_guid: The globally unique identifier for glossary term.
    :type term_guid: str
    :return: Returns an :class:`~azure.purview.catalog.core.rest.HttpRequest` that you will pass to the client's `send_request` method.
     See https://aka.ms/azsdk/python/llcwiki for how to incorporate this response into your code flow.
    :rtype: ~azure.purview.catalog.core.rest.HttpRequest
    """
    accept = "application/json"

    # Construct URL
    url = kwargs.pop("template_url", '/atlas/v2/glossary/term/{termGuid}')
    path_format_arguments = {
        'termGuid': _SERIALIZER.url("term_guid", term_guid, 'str', max_length=4096, min_length=1),
    }
    url = _format_url_section(url, **path_format_arguments)

    # Construct headers
    header_parameters = kwargs.pop("headers", {})  # type: Dict[str, Any]
    header_parameters['Accept'] = _SERIALIZER.header("accept", accept, 'str')

    return HttpRequest(
        method="GET",
        url=url,
        headers=header_parameters,
        **kwargs
    )


def build_glossaryrest_update_glossary_term_request(
    term_guid: str,
    *,
    json: Any = None,
    content: Any = None,
    **kwargs: Any
) -> HttpRequest:
    """Update the given glossary term by its GUID.

    Update the given glossary term by its GUID.

    See https://aka.ms/azsdk/python/llcwiki for how to incorporate this request_builder into your code flow.

    :param term_guid: The globally unique identifier for glossary term.
    :type term_guid: str
    :keyword json: The glossary term to be updated.
    :paramtype json: Any
    :keyword content: The glossary term to be updated.
    :paramtype content: Any
    :return: Returns an :class:`~azure.purview.catalog.core.rest.HttpRequest` that you will pass to the client's `send_request` method.
     See https://aka.ms/azsdk/python/llcwiki for how to incorporate this response into your code flow.
    :rtype: ~azure.purview.catalog.core.rest.HttpRequest
    """
    content_type = kwargs.pop("content_type", None)
    accept = "application/json"

    # Construct URL
    url = kwargs.pop("template_url", '/atlas/v2/glossary/term/{termGuid}')
    path_format_arguments = {
        'termGuid': _SERIALIZER.url("term_guid", term_guid, 'str', max_length=4096, min_length=1),
    }
    url = _format_url_section(url, **path_format_arguments)

    # Construct headers
    header_parameters = kwargs.pop("headers", {})  # type: Dict[str, Any]
    if content_type is not None:
        header_parameters['Content-Type'] = _SERIALIZER.header("content_type", content_type, 'str')
    header_parameters['Accept'] = _SERIALIZER.header("accept", accept, 'str')

    return HttpRequest(
        method="PUT",
        url=url,
        headers=header_parameters,
        json=json,
        content=content,
        **kwargs
    )


def build_glossaryrest_delete_glossary_term_request(
    term_guid: str,
    **kwargs: Any
) -> HttpRequest:
    """Delete a glossary term.

    Delete a glossary term.

    See https://aka.ms/azsdk/python/llcwiki for how to incorporate this request_builder into your code flow.

    :param term_guid: The globally unique identifier for glossary term.
    :type term_guid: str
    :return: Returns an :class:`~azure.purview.catalog.core.rest.HttpRequest` that you will pass to the client's `send_request` method.
     See https://aka.ms/azsdk/python/llcwiki for how to incorporate this response into your code flow.
    :rtype: ~azure.purview.catalog.core.rest.HttpRequest
    """

    # Construct URL
    url = kwargs.pop("template_url", '/atlas/v2/glossary/term/{termGuid}')
    path_format_arguments = {
        'termGuid': _SERIALIZER.url("term_guid", term_guid, 'str', max_length=4096, min_length=1),
    }
    url = _format_url_section(url, **path_format_arguments)

    return HttpRequest(
        method="DELETE",
        url=url,
        **kwargs
    )


def build_glossaryrest_partial_update_glossary_term_request(
    term_guid: str,
    *,
    json: Any = None,
    content: Any = None,
    **kwargs: Any
) -> HttpRequest:
    """Update the glossary term partially.

    Update the glossary term partially.

    See https://aka.ms/azsdk/python/llcwiki for how to incorporate this request_builder into your code flow.

    :param term_guid: The globally unique identifier for glossary term.
    :type term_guid: str
    :keyword json: A map containing keys as attribute names and values as corresponding attribute
     values to be updated.
    :paramtype json: Any
    :keyword content: A map containing keys as attribute names and values as corresponding
     attribute values to be updated.
    :paramtype content: Any
    :return: Returns an :class:`~azure.purview.catalog.core.rest.HttpRequest` that you will pass to the client's `send_request` method.
     See https://aka.ms/azsdk/python/llcwiki for how to incorporate this response into your code flow.
    :rtype: ~azure.purview.catalog.core.rest.HttpRequest
    """
    content_type = kwargs.pop("content_type", None)
    accept = "application/json"

    # Construct URL
    url = kwargs.pop("template_url", '/atlas/v2/glossary/term/{termGuid}/partial')
    path_format_arguments = {
        'termGuid': _SERIALIZER.url("term_guid", term_guid, 'str', max_length=4096, min_length=1),
    }
    url = _format_url_section(url, **path_format_arguments)

    # Construct headers
    header_parameters = kwargs.pop("headers", {})  # type: Dict[str, Any]
    if content_type is not None:
        header_parameters['Content-Type'] = _SERIALIZER.header("content_type", content_type, 'str')
    header_parameters['Accept'] = _SERIALIZER.header("accept", accept, 'str')

    return HttpRequest(
        method="PUT",
        url=url,
        headers=header_parameters,
        json=json,
        content=content,
        **kwargs
    )


def build_glossaryrest_create_glossary_terms_request(
    *,
    json: Any = None,
    content: Any = None,
    **kwargs: Any
) -> HttpRequest:
    """Create glossary terms in bulk.

    Create glossary terms in bulk.

    See https://aka.ms/azsdk/python/llcwiki for how to incorporate this request_builder into your code flow.

    :keyword json: An array of glossary term definitions to be created in bulk.
    :paramtype json: Any
    :keyword content: An array of glossary term definitions to be created in bulk.
    :paramtype content: Any
    :return: Returns an :class:`~azure.purview.catalog.core.rest.HttpRequest` that you will pass to the client's `send_request` method.
     See https://aka.ms/azsdk/python/llcwiki for how to incorporate this response into your code flow.
    :rtype: ~azure.purview.catalog.core.rest.HttpRequest
    """
    content_type = kwargs.pop("content_type", None)
    accept = "application/json"

    # Construct URL
    url = kwargs.pop("template_url", '/atlas/v2/glossary/terms')

    # Construct headers
    header_parameters = kwargs.pop("headers", {})  # type: Dict[str, Any]
    if content_type is not None:
        header_parameters['Content-Type'] = _SERIALIZER.header("content_type", content_type, 'str')
    header_parameters['Accept'] = _SERIALIZER.header("accept", accept, 'str')

    return HttpRequest(
        method="POST",
        url=url,
        headers=header_parameters,
        json=json,
        content=content,
        **kwargs
    )


def build_glossaryrest_get_entities_assigned_with_term_request(
    term_guid: str,
    *,
    limit: Optional[int] = None,
    offset: Optional[int] = None,
    sort: Optional[str] = "ASC",
    **kwargs: Any
) -> HttpRequest:
    """Get all related objects assigned with the specified term.

    Get all related objects assigned with the specified term.

    See https://aka.ms/azsdk/python/llcwiki for how to incorporate this request_builder into your code flow.

    :param term_guid: The globally unique identifier for glossary term.
    :type term_guid: str
    :keyword limit: The page size - by default there is no paging.
    :paramtype limit: int
    :keyword offset: The offset for pagination purpose.
    :paramtype offset: int
    :keyword sort: The sort order, ASC (default) or DESC.
    :paramtype sort: str
    :return: Returns an :class:`~azure.purview.catalog.core.rest.HttpRequest` that you will pass to the client's `send_request` method.
     See https://aka.ms/azsdk/python/llcwiki for how to incorporate this response into your code flow.
    :rtype: ~azure.purview.catalog.core.rest.HttpRequest
    """
    accept = "application/json"

    # Construct URL
    url = kwargs.pop("template_url", '/atlas/v2/glossary/terms/{termGuid}/assignedEntities')
    path_format_arguments = {
        'termGuid': _SERIALIZER.url("term_guid", term_guid, 'str', max_length=4096, min_length=1),
    }
    url = _format_url_section(url, **path_format_arguments)

    # Construct parameters
    query_parameters = kwargs.pop("params", {})  # type: Dict[str, Any]
    if limit is not None:
        query_parameters['limit'] = _SERIALIZER.query("limit", limit, 'int')
    if offset is not None:
        query_parameters['offset'] = _SERIALIZER.query("offset", offset, 'int')
    if sort is not None:
        query_parameters['sort'] = _SERIALIZER.query("sort", sort, 'str')

    # Construct headers
    header_parameters = kwargs.pop("headers", {})  # type: Dict[str, Any]
    header_parameters['Accept'] = _SERIALIZER.header("accept", accept, 'str')

    return HttpRequest(
        method="GET",
        url=url,
        params=query_parameters,
        headers=header_parameters,
        **kwargs
    )


def build_glossaryrest_assign_term_to_entities_request(
    term_guid: str,
    *,
    json: Any = None,
    content: Any = None,
    **kwargs: Any
) -> HttpRequest:
    """Assign the given term to the provided list of related objects.

    Assign the given term to the provided list of related objects.

    See https://aka.ms/azsdk/python/llcwiki for how to incorporate this request_builder into your code flow.

    :param term_guid: The globally unique identifier for glossary term.
    :type term_guid: str
    :keyword json: An array of related object IDs to which the term has to be associated.
    :paramtype json: Any
    :keyword content: An array of related object IDs to which the term has to be associated.
    :paramtype content: Any
    :return: Returns an :class:`~azure.purview.catalog.core.rest.HttpRequest` that you will pass to the client's `send_request` method.
     See https://aka.ms/azsdk/python/llcwiki for how to incorporate this response into your code flow.
    :rtype: ~azure.purview.catalog.core.rest.HttpRequest
    """
    content_type = kwargs.pop("content_type", None)

    # Construct URL
    url = kwargs.pop("template_url", '/atlas/v2/glossary/terms/{termGuid}/assignedEntities')
    path_format_arguments = {
        'termGuid': _SERIALIZER.url("term_guid", term_guid, 'str', max_length=4096, min_length=1),
    }
    url = _format_url_section(url, **path_format_arguments)

    # Construct headers
    header_parameters = kwargs.pop("headers", {})  # type: Dict[str, Any]
    if content_type is not None:
        header_parameters['Content-Type'] = _SERIALIZER.header("content_type", content_type, 'str')

    return HttpRequest(
        method="POST",
        url=url,
        headers=header_parameters,
        json=json,
        content=content,
        **kwargs
    )


def build_glossaryrest_remove_term_assignment_from_entities_request(
    term_guid: str,
    *,
    json: Any = None,
    content: Any = None,
    **kwargs: Any
) -> HttpRequest:
    """Delete the term assignment for the given list of related objects.

    Delete the term assignment for the given list of related objects.

    See https://aka.ms/azsdk/python/llcwiki for how to incorporate this request_builder into your code flow.

    :param term_guid: The globally unique identifier for glossary term.
    :type term_guid: str
    :keyword json: An array of related object IDs from which the term has to be dissociated.
    :paramtype json: Any
    :keyword content: An array of related object IDs from which the term has to be dissociated.
    :paramtype content: Any
    :return: Returns an :class:`~azure.purview.catalog.core.rest.HttpRequest` that you will pass to the client's `send_request` method.
     See https://aka.ms/azsdk/python/llcwiki for how to incorporate this response into your code flow.
    :rtype: ~azure.purview.catalog.core.rest.HttpRequest
    """
    content_type = kwargs.pop("content_type", None)

    # Construct URL
    url = kwargs.pop("template_url", '/atlas/v2/glossary/terms/{termGuid}/assignedEntities')
    path_format_arguments = {
        'termGuid': _SERIALIZER.url("term_guid", term_guid, 'str', max_length=4096, min_length=1),
    }
    url = _format_url_section(url, **path_format_arguments)

    # Construct headers
    header_parameters = kwargs.pop("headers", {})  # type: Dict[str, Any]
    if content_type is not None:
        header_parameters['Content-Type'] = _SERIALIZER.header("content_type", content_type, 'str')

    return HttpRequest(
        method="PUT",
        url=url,
        headers=header_parameters,
        json=json,
        content=content,
        **kwargs
    )


def build_glossaryrest_delete_term_assignment_from_entities_request(
    term_guid: str,
    *,
    json: Any = None,
    content: Any = None,
    **kwargs: Any
) -> HttpRequest:
    """Delete the term assignment for the given list of related objects.

    Delete the term assignment for the given list of related objects.

    See https://aka.ms/azsdk/python/llcwiki for how to incorporate this request_builder into your code flow.

    :param term_guid: The globally unique identifier for glossary term.
    :type term_guid: str
    :keyword json: An array of related object IDs from which the term has to be dissociated.
    :paramtype json: Any
    :keyword content: An array of related object IDs from which the term has to be dissociated.
    :paramtype content: Any
    :return: Returns an :class:`~azure.purview.catalog.core.rest.HttpRequest` that you will pass to the client's `send_request` method.
     See https://aka.ms/azsdk/python/llcwiki for how to incorporate this response into your code flow.
    :rtype: ~azure.purview.catalog.core.rest.HttpRequest
    """
    content_type = kwargs.pop("content_type", None)

    # Construct URL
    url = kwargs.pop("template_url", '/atlas/v2/glossary/terms/{termGuid}/assignedEntities')
    path_format_arguments = {
        'termGuid': _SERIALIZER.url("term_guid", term_guid, 'str', max_length=4096, min_length=1),
    }
    url = _format_url_section(url, **path_format_arguments)

    # Construct headers
    header_parameters = kwargs.pop("headers", {})  # type: Dict[str, Any]
    if content_type is not None:
        header_parameters['Content-Type'] = _SERIALIZER.header("content_type", content_type, 'str')

    return HttpRequest(
        method="DELETE",
        url=url,
        headers=header_parameters,
        json=json,
        content=content,
        **kwargs
    )


def build_glossaryrest_get_related_terms_request(
    term_guid: str,
    *,
    limit: Optional[int] = None,
    offset: Optional[int] = None,
    sort: Optional[str] = "ASC",
    **kwargs: Any
) -> HttpRequest:
    """Get all related terms for a specific term by its GUID.

    Get all related terms for a specific term by its GUID. Limit, offset, and sort parameters are
    currently not being enabled and won't work even they are passed.

    See https://aka.ms/azsdk/python/llcwiki for how to incorporate this request_builder into your code flow.

    :param term_guid: The globally unique identifier for glossary term.
    :type term_guid: str
    :keyword limit: The page size - by default there is no paging.
    :paramtype limit: int
    :keyword offset: The offset for pagination purpose.
    :paramtype offset: int
    :keyword sort: The sort order, ASC (default) or DESC.
    :paramtype sort: str
    :return: Returns an :class:`~azure.purview.catalog.core.rest.HttpRequest` that you will pass to the client's `send_request` method.
     See https://aka.ms/azsdk/python/llcwiki for how to incorporate this response into your code flow.
    :rtype: ~azure.purview.catalog.core.rest.HttpRequest
    """
    accept = "application/json"

    # Construct URL
    url = kwargs.pop("template_url", '/atlas/v2/glossary/terms/{termGuid}/related')
    path_format_arguments = {
        'termGuid': _SERIALIZER.url("term_guid", term_guid, 'str', max_length=4096, min_length=1),
    }
    url = _format_url_section(url, **path_format_arguments)

    # Construct parameters
    query_parameters = kwargs.pop("params", {})  # type: Dict[str, Any]
    if limit is not None:
        query_parameters['limit'] = _SERIALIZER.query("limit", limit, 'int')
    if offset is not None:
        query_parameters['offset'] = _SERIALIZER.query("offset", offset, 'int')
    if sort is not None:
        query_parameters['sort'] = _SERIALIZER.query("sort", sort, 'str')

    # Construct headers
    header_parameters = kwargs.pop("headers", {})  # type: Dict[str, Any]
    header_parameters['Accept'] = _SERIALIZER.header("accept", accept, 'str')

    return HttpRequest(
        method="GET",
        url=url,
        params=query_parameters,
        headers=header_parameters,
        **kwargs
    )


def build_glossaryrest_get_glossary_request(
    glossary_guid: str,
    **kwargs: Any
) -> HttpRequest:
    """Get a specific Glossary by its GUID.

    Get a specific Glossary by its GUID.

    See https://aka.ms/azsdk/python/llcwiki for how to incorporate this request_builder into your code flow.

    :param glossary_guid: The globally unique identifier for glossary.
    :type glossary_guid: str
    :return: Returns an :class:`~azure.purview.catalog.core.rest.HttpRequest` that you will pass to the client's `send_request` method.
     See https://aka.ms/azsdk/python/llcwiki for how to incorporate this response into your code flow.
    :rtype: ~azure.purview.catalog.core.rest.HttpRequest
    """
    accept = "application/json"

    # Construct URL
    url = kwargs.pop("template_url", '/atlas/v2/glossary/{glossaryGuid}')
    path_format_arguments = {
        'glossaryGuid': _SERIALIZER.url("glossary_guid", glossary_guid, 'str', max_length=4096, min_length=1),
    }
    url = _format_url_section(url, **path_format_arguments)

    # Construct headers
    header_parameters = kwargs.pop("headers", {})  # type: Dict[str, Any]
    header_parameters['Accept'] = _SERIALIZER.header("accept", accept, 'str')

    return HttpRequest(
        method="GET",
        url=url,
        headers=header_parameters,
        **kwargs
    )


def build_glossaryrest_update_glossary_request(
    glossary_guid: str,
    *,
    json: Any = None,
    content: Any = None,
    **kwargs: Any
) -> HttpRequest:
    """Update the given glossary.

    Update the given glossary.

    See https://aka.ms/azsdk/python/llcwiki for how to incorporate this request_builder into your code flow.

    :param glossary_guid: The globally unique identifier for glossary.
    :type glossary_guid: str
    :keyword json: The glossary definition to be updated.
    :paramtype json: Any
    :keyword content: The glossary definition to be updated.
    :paramtype content: Any
    :return: Returns an :class:`~azure.purview.catalog.core.rest.HttpRequest` that you will pass to the client's `send_request` method.
     See https://aka.ms/azsdk/python/llcwiki for how to incorporate this response into your code flow.
    :rtype: ~azure.purview.catalog.core.rest.HttpRequest
    """
    content_type = kwargs.pop("content_type", None)
    accept = "application/json"

    # Construct URL
    url = kwargs.pop("template_url", '/atlas/v2/glossary/{glossaryGuid}')
    path_format_arguments = {
        'glossaryGuid': _SERIALIZER.url("glossary_guid", glossary_guid, 'str', max_length=4096, min_length=1),
    }
    url = _format_url_section(url, **path_format_arguments)

    # Construct headers
    header_parameters = kwargs.pop("headers", {})  # type: Dict[str, Any]
    if content_type is not None:
        header_parameters['Content-Type'] = _SERIALIZER.header("content_type", content_type, 'str')
    header_parameters['Accept'] = _SERIALIZER.header("accept", accept, 'str')

    return HttpRequest(
        method="PUT",
        url=url,
        headers=header_parameters,
        json=json,
        content=content,
        **kwargs
    )


def build_glossaryrest_delete_glossary_request(
    glossary_guid: str,
    **kwargs: Any
) -> HttpRequest:
    """Delete a glossary.

    Delete a glossary.

    See https://aka.ms/azsdk/python/llcwiki for how to incorporate this request_builder into your code flow.

    :param glossary_guid: The globally unique identifier for glossary.
    :type glossary_guid: str
    :return: Returns an :class:`~azure.purview.catalog.core.rest.HttpRequest` that you will pass to the client's `send_request` method.
     See https://aka.ms/azsdk/python/llcwiki for how to incorporate this response into your code flow.
    :rtype: ~azure.purview.catalog.core.rest.HttpRequest
    """

    # Construct URL
    url = kwargs.pop("template_url", '/atlas/v2/glossary/{glossaryGuid}')
    path_format_arguments = {
        'glossaryGuid': _SERIALIZER.url("glossary_guid", glossary_guid, 'str', max_length=4096, min_length=1),
    }
    url = _format_url_section(url, **path_format_arguments)

    return HttpRequest(
        method="DELETE",
        url=url,
        **kwargs
    )


def build_glossaryrest_get_glossary_categories_request(
    glossary_guid: str,
    *,
    limit: Optional[int] = None,
    offset: Optional[int] = None,
    sort: Optional[str] = "ASC",
    **kwargs: Any
) -> HttpRequest:
    """Get the categories belonging to a specific glossary.

    Get the categories belonging to a specific glossary.

    See https://aka.ms/azsdk/python/llcwiki for how to incorporate this request_builder into your code flow.

    :param glossary_guid: The globally unique identifier for glossary.
    :type glossary_guid: str
    :keyword limit: The page size - by default there is no paging.
    :paramtype limit: int
    :keyword offset: The offset for pagination purpose.
    :paramtype offset: int
    :keyword sort: The sort order, ASC (default) or DESC.
    :paramtype sort: str
    :return: Returns an :class:`~azure.purview.catalog.core.rest.HttpRequest` that you will pass to the client's `send_request` method.
     See https://aka.ms/azsdk/python/llcwiki for how to incorporate this response into your code flow.
    :rtype: ~azure.purview.catalog.core.rest.HttpRequest
    """
    accept = "application/json"

    # Construct URL
    url = kwargs.pop("template_url", '/atlas/v2/glossary/{glossaryGuid}/categories')
    path_format_arguments = {
        'glossaryGuid': _SERIALIZER.url("glossary_guid", glossary_guid, 'str', max_length=4096, min_length=1),
    }
    url = _format_url_section(url, **path_format_arguments)

    # Construct parameters
    query_parameters = kwargs.pop("params", {})  # type: Dict[str, Any]
    if limit is not None:
        query_parameters['limit'] = _SERIALIZER.query("limit", limit, 'int')
    if offset is not None:
        query_parameters['offset'] = _SERIALIZER.query("offset", offset, 'int')
    if sort is not None:
        query_parameters['sort'] = _SERIALIZER.query("sort", sort, 'str')

    # Construct headers
    header_parameters = kwargs.pop("headers", {})  # type: Dict[str, Any]
    header_parameters['Accept'] = _SERIALIZER.header("accept", accept, 'str')

    return HttpRequest(
        method="GET",
        url=url,
        params=query_parameters,
        headers=header_parameters,
        **kwargs
    )


def build_glossaryrest_get_glossary_categories_headers_request(
    glossary_guid: str,
    *,
    limit: Optional[int] = None,
    offset: Optional[int] = None,
    sort: Optional[str] = "ASC",
    **kwargs: Any
) -> HttpRequest:
    """Get the category headers belonging to a specific glossary.

    Get the category headers belonging to a specific glossary.

    See https://aka.ms/azsdk/python/llcwiki for how to incorporate this request_builder into your code flow.

    :param glossary_guid: The globally unique identifier for glossary.
    :type glossary_guid: str
    :keyword limit: The page size - by default there is no paging.
    :paramtype limit: int
    :keyword offset: The offset for pagination purpose.
    :paramtype offset: int
    :keyword sort: The sort order, ASC (default) or DESC.
    :paramtype sort: str
    :return: Returns an :class:`~azure.purview.catalog.core.rest.HttpRequest` that you will pass to the client's `send_request` method.
     See https://aka.ms/azsdk/python/llcwiki for how to incorporate this response into your code flow.
    :rtype: ~azure.purview.catalog.core.rest.HttpRequest
    """
    accept = "application/json"

    # Construct URL
    url = kwargs.pop("template_url", '/atlas/v2/glossary/{glossaryGuid}/categories/headers')
    path_format_arguments = {
        'glossaryGuid': _SERIALIZER.url("glossary_guid", glossary_guid, 'str', max_length=4096, min_length=1),
    }
    url = _format_url_section(url, **path_format_arguments)

    # Construct parameters
    query_parameters = kwargs.pop("params", {})  # type: Dict[str, Any]
    if limit is not None:
        query_parameters['limit'] = _SERIALIZER.query("limit", limit, 'int')
    if offset is not None:
        query_parameters['offset'] = _SERIALIZER.query("offset", offset, 'int')
    if sort is not None:
        query_parameters['sort'] = _SERIALIZER.query("sort", sort, 'str')

    # Construct headers
    header_parameters = kwargs.pop("headers", {})  # type: Dict[str, Any]
    header_parameters['Accept'] = _SERIALIZER.header("accept", accept, 'str')

    return HttpRequest(
        method="GET",
        url=url,
        params=query_parameters,
        headers=header_parameters,
        **kwargs
    )


def build_glossaryrest_get_detailed_glossary_request(
    glossary_guid: str,
    **kwargs: Any
) -> HttpRequest:
    """Get a specific glossary with detailed information.

    Get a specific glossary with detailed information.

    See https://aka.ms/azsdk/python/llcwiki for how to incorporate this request_builder into your code flow.

    :param glossary_guid: The globally unique identifier for glossary.
    :type glossary_guid: str
    :return: Returns an :class:`~azure.purview.catalog.core.rest.HttpRequest` that you will pass to the client's `send_request` method.
     See https://aka.ms/azsdk/python/llcwiki for how to incorporate this response into your code flow.
    :rtype: ~azure.purview.catalog.core.rest.HttpRequest
    """
    accept = "application/json"

    # Construct URL
    url = kwargs.pop("template_url", '/atlas/v2/glossary/{glossaryGuid}/detailed')
    path_format_arguments = {
        'glossaryGuid': _SERIALIZER.url("glossary_guid", glossary_guid, 'str', max_length=4096, min_length=1),
    }
    url = _format_url_section(url, **path_format_arguments)

    # Construct headers
    header_parameters = kwargs.pop("headers", {})  # type: Dict[str, Any]
    header_parameters['Accept'] = _SERIALIZER.header("accept", accept, 'str')

    return HttpRequest(
        method="GET",
        url=url,
        headers=header_parameters,
        **kwargs
    )


def build_glossaryrest_partial_update_glossary_request(
    glossary_guid: str,
    *,
    json: Any = None,
    content: Any = None,
    **kwargs: Any
) -> HttpRequest:
    """Update the glossary partially.

    Update the glossary partially. Some properties such as qualifiedName are not allowed to be
    updated.

    See https://aka.ms/azsdk/python/llcwiki for how to incorporate this request_builder into your code flow.

    :param glossary_guid: The globally unique identifier for glossary.
    :type glossary_guid: str
    :keyword json: A map containing keys as attribute names and values as corresponding attribute
     values.
    :paramtype json: Any
    :keyword content: A map containing keys as attribute names and values as corresponding
     attribute values.
    :paramtype content: Any
    :return: Returns an :class:`~azure.purview.catalog.core.rest.HttpRequest` that you will pass to the client's `send_request` method.
     See https://aka.ms/azsdk/python/llcwiki for how to incorporate this response into your code flow.
    :rtype: ~azure.purview.catalog.core.rest.HttpRequest
    """
    content_type = kwargs.pop("content_type", None)
    accept = "application/json"

    # Construct URL
    url = kwargs.pop("template_url", '/atlas/v2/glossary/{glossaryGuid}/partial')
    path_format_arguments = {
        'glossaryGuid': _SERIALIZER.url("glossary_guid", glossary_guid, 'str', max_length=4096, min_length=1),
    }
    url = _format_url_section(url, **path_format_arguments)

    # Construct headers
    header_parameters = kwargs.pop("headers", {})  # type: Dict[str, Any]
    if content_type is not None:
        header_parameters['Content-Type'] = _SERIALIZER.header("content_type", content_type, 'str')
    header_parameters['Accept'] = _SERIALIZER.header("accept", accept, 'str')

    return HttpRequest(
        method="PUT",
        url=url,
        headers=header_parameters,
        json=json,
        content=content,
        **kwargs
    )


def build_glossaryrest_get_glossary_terms_request(
    glossary_guid: str,
    *,
    limit: Optional[int] = None,
    offset: Optional[int] = None,
    sort: Optional[str] = "ASC",
    **kwargs: Any
) -> HttpRequest:
    """Get terms belonging to a specific glossary.

    Get terms belonging to a specific glossary.

    See https://aka.ms/azsdk/python/llcwiki for how to incorporate this request_builder into your code flow.

    :param glossary_guid: The globally unique identifier for glossary.
    :type glossary_guid: str
    :keyword limit: The page size - by default there is no paging.
    :paramtype limit: int
    :keyword offset: The offset for pagination purpose.
    :paramtype offset: int
    :keyword sort: The sort order, ASC (default) or DESC.
    :paramtype sort: str
    :return: Returns an :class:`~azure.purview.catalog.core.rest.HttpRequest` that you will pass to the client's `send_request` method.
     See https://aka.ms/azsdk/python/llcwiki for how to incorporate this response into your code flow.
    :rtype: ~azure.purview.catalog.core.rest.HttpRequest
    """
    accept = "application/json"

    # Construct URL
    url = kwargs.pop("template_url", '/atlas/v2/glossary/{glossaryGuid}/terms')
    path_format_arguments = {
        'glossaryGuid': _SERIALIZER.url("glossary_guid", glossary_guid, 'str', max_length=4096, min_length=1),
    }
    url = _format_url_section(url, **path_format_arguments)

    # Construct parameters
    query_parameters = kwargs.pop("params", {})  # type: Dict[str, Any]
    if limit is not None:
        query_parameters['limit'] = _SERIALIZER.query("limit", limit, 'int')
    if offset is not None:
        query_parameters['offset'] = _SERIALIZER.query("offset", offset, 'int')
    if sort is not None:
        query_parameters['sort'] = _SERIALIZER.query("sort", sort, 'str')

    # Construct headers
    header_parameters = kwargs.pop("headers", {})  # type: Dict[str, Any]
    header_parameters['Accept'] = _SERIALIZER.header("accept", accept, 'str')

    return HttpRequest(
        method="GET",
        url=url,
        params=query_parameters,
        headers=header_parameters,
        **kwargs
    )


def build_glossaryrest_get_glossary_term_headers_request(
    glossary_guid: str,
    *,
    limit: Optional[int] = None,
    offset: Optional[int] = None,
    sort: Optional[str] = "ASC",
    **kwargs: Any
) -> HttpRequest:
    """Get term headers belonging to a specific glossary.

    Get term headers belonging to a specific glossary.

    See https://aka.ms/azsdk/python/llcwiki for how to incorporate this request_builder into your code flow.

    :param glossary_guid: The globally unique identifier for glossary.
    :type glossary_guid: str
    :keyword limit: The page size - by default there is no paging.
    :paramtype limit: int
    :keyword offset: The offset for pagination purpose.
    :paramtype offset: int
    :keyword sort: The sort order, ASC (default) or DESC.
    :paramtype sort: str
    :return: Returns an :class:`~azure.purview.catalog.core.rest.HttpRequest` that you will pass to the client's `send_request` method.
     See https://aka.ms/azsdk/python/llcwiki for how to incorporate this response into your code flow.
    :rtype: ~azure.purview.catalog.core.rest.HttpRequest
    """
    accept = "application/json"

    # Construct URL
    url = kwargs.pop("template_url", '/atlas/v2/glossary/{glossaryGuid}/terms/headers')
    path_format_arguments = {
        'glossaryGuid': _SERIALIZER.url("glossary_guid", glossary_guid, 'str', max_length=4096, min_length=1),
    }
    url = _format_url_section(url, **path_format_arguments)

    # Construct parameters
    query_parameters = kwargs.pop("params", {})  # type: Dict[str, Any]
    if limit is not None:
        query_parameters['limit'] = _SERIALIZER.query("limit", limit, 'int')
    if offset is not None:
        query_parameters['offset'] = _SERIALIZER.query("offset", offset, 'int')
    if sort is not None:
        query_parameters['sort'] = _SERIALIZER.query("sort", sort, 'str')

    # Construct headers
    header_parameters = kwargs.pop("headers", {})  # type: Dict[str, Any]
    header_parameters['Accept'] = _SERIALIZER.header("accept", accept, 'str')

    return HttpRequest(
        method="GET",
        url=url,
        params=query_parameters,
        headers=header_parameters,
        **kwargs
    )


def build_glossaryrest_import_glossary_terms_via_csv_request(
    glossary_guid: str,
    *,
    files: Optional[IO] = None,
    content: Any = None,
    api_version: Optional[str] = "2020-12-01-preview",
    **kwargs: Any
) -> HttpRequest:
    """Import Glossary Terms from local csv file.

    Import Glossary Terms from local csv file.

    See https://aka.ms/azsdk/python/llcwiki for how to incorporate this request_builder into your code flow.

    :param glossary_guid: The globally unique identifier for glossary.
    :type glossary_guid: str
    :keyword files: The csv file to import glossary terms from.
    :paramtype files: IO
    :keyword content: The csv file to import glossary terms from.
    :paramtype content: Any
    :keyword api_version: Api Version.
    :paramtype api_version: str
    :return: Returns an :class:`~azure.purview.catalog.core.rest.HttpRequest` that you will pass to the client's `send_request` method.
     See https://aka.ms/azsdk/python/llcwiki for how to incorporate this response into your code flow.
    :rtype: ~azure.purview.catalog.core.rest.HttpRequest
    """
    content_type = kwargs.pop("content_type", None)
    accept = "application/json"

    # Construct URL
    url = kwargs.pop("template_url", '/glossary/{glossaryGuid}/terms/import')
    path_format_arguments = {
        'glossaryGuid': _SERIALIZER.url("glossary_guid", glossary_guid, 'str', max_length=4096, min_length=1),
    }
    url = _format_url_section(url, **path_format_arguments)

    # Construct parameters
    query_parameters = kwargs.pop("params", {})  # type: Dict[str, Any]
    if api_version is not None:
        query_parameters['api-version'] = _SERIALIZER.query("api_version", api_version, 'str')

    # Construct headers
    header_parameters = kwargs.pop("headers", {})  # type: Dict[str, Any]
    if content_type is not None:
        header_parameters['Content-Type'] = _SERIALIZER.header("content_type", content_type, 'str')
    header_parameters['Accept'] = _SERIALIZER.header("accept", accept, 'str')

    return HttpRequest(
        method="POST",
        url=url,
        params=query_parameters,
        headers=header_parameters,
        files=files,
        content=content,
        **kwargs
    )


def build_glossaryrest_import_glossary_terms_via_csv_by_glossary_name_request(
    glossary_name: str,
    *,
    files: Optional[IO] = None,
    content: Any = None,
    include_term_hierarchy: Optional[bool] = False,
    api_version: Optional[str] = "2020-12-01-preview",
    **kwargs: Any
) -> HttpRequest:
    """Import Glossary Terms from local csv file by glossaryName.

    Import Glossary Terms from local csv file by glossaryName.

    See https://aka.ms/azsdk/python/llcwiki for how to incorporate this request_builder into your code flow.

    :param glossary_name: The name of the glossary.
    :type glossary_name: str
    :keyword files: The csv file to import glossary terms from.
    :paramtype files: IO
    :keyword content: The csv file to import glossary terms from.
    :paramtype content: Any
    :keyword include_term_hierarchy: Whether include term hierarchy.
    :paramtype include_term_hierarchy: bool
    :keyword api_version: Api Version.
    :paramtype api_version: str
    :return: Returns an :class:`~azure.purview.catalog.core.rest.HttpRequest` that you will pass to the client's `send_request` method.
     See https://aka.ms/azsdk/python/llcwiki for how to incorporate this response into your code flow.
    :rtype: ~azure.purview.catalog.core.rest.HttpRequest
    """
    content_type = kwargs.pop("content_type", None)
    accept = "application/json"

    # Construct URL
    url = kwargs.pop("template_url", '/glossary/name/{glossaryName}/terms/import')
    path_format_arguments = {
        'glossaryName': _SERIALIZER.url("glossary_name", glossary_name, 'str', max_length=4096, min_length=1),
    }
    url = _format_url_section(url, **path_format_arguments)

    # Construct parameters
    query_parameters = kwargs.pop("params", {})  # type: Dict[str, Any]
    if include_term_hierarchy is not None:
        query_parameters['includeTermHierarchy'] = _SERIALIZER.query("include_term_hierarchy", include_term_hierarchy, 'bool')
    if api_version is not None:
        query_parameters['api-version'] = _SERIALIZER.query("api_version", api_version, 'str')

    # Construct headers
    header_parameters = kwargs.pop("headers", {})  # type: Dict[str, Any]
    if content_type is not None:
        header_parameters['Content-Type'] = _SERIALIZER.header("content_type", content_type, 'str')
    header_parameters['Accept'] = _SERIALIZER.header("accept", accept, 'str')

    return HttpRequest(
        method="POST",
        url=url,
        params=query_parameters,
        headers=header_parameters,
        files=files,
        content=content,
        **kwargs
    )


def build_glossaryrest_get_import_csv_operation_status_request(
    operation_guid: str,
    *,
    api_version: Optional[str] = "2020-12-01-preview",
    **kwargs: Any
) -> HttpRequest:
    """Get the status of import csv operation.

    Get the status of import csv operation.

    See https://aka.ms/azsdk/python/llcwiki for how to incorporate this request_builder into your code flow.

    :param operation_guid: The globally unique identifier for async operation/job`.
    :type operation_guid: str
    :keyword api_version: Api Version.
    :paramtype api_version: str
    :return: Returns an :class:`~azure.purview.catalog.core.rest.HttpRequest` that you will pass to the client's `send_request` method.
     See https://aka.ms/azsdk/python/llcwiki for how to incorporate this response into your code flow.
    :rtype: ~azure.purview.catalog.core.rest.HttpRequest
    """
    accept = "application/json"

    # Construct URL
    url = kwargs.pop("template_url", '/glossary/terms/import/{operationGuid}')
    path_format_arguments = {
        'operationGuid': _SERIALIZER.url("operation_guid", operation_guid, 'str', max_length=4096, min_length=1),
    }
    url = _format_url_section(url, **path_format_arguments)

    # Construct parameters
    query_parameters = kwargs.pop("params", {})  # type: Dict[str, Any]
    if api_version is not None:
        query_parameters['api-version'] = _SERIALIZER.query("api_version", api_version, 'str')

    # Construct headers
    header_parameters = kwargs.pop("headers", {})  # type: Dict[str, Any]
    header_parameters['Accept'] = _SERIALIZER.header("accept", accept, 'str')

    return HttpRequest(
        method="GET",
        url=url,
        params=query_parameters,
        headers=header_parameters,
        **kwargs
    )


def build_glossaryrest_export_glossary_terms_as_csv_request(
    glossary_guid: str,
    *,
    json: Any = None,
    content: Any = None,
    api_version: Optional[str] = "2020-12-01-preview",
    **kwargs: Any
) -> HttpRequest:
    """Export Glossary Terms as csv file.

    Export Glossary Terms as csv file.

    See https://aka.ms/azsdk/python/llcwiki for how to incorporate this request_builder into your code flow.

    :param glossary_guid: The globally unique identifier for glossary.
    :type glossary_guid: str
    :keyword json: An array of term guids.
    :paramtype json: Any
    :keyword content: An array of term guids.
    :paramtype content: Any
    :keyword api_version: Api Version.
    :paramtype api_version: str
    :return: Returns an :class:`~azure.purview.catalog.core.rest.HttpRequest` that you will pass to the client's `send_request` method.
     See https://aka.ms/azsdk/python/llcwiki for how to incorporate this response into your code flow.
    :rtype: ~azure.purview.catalog.core.rest.HttpRequest
    """
    content_type = kwargs.pop("content_type", None)
    accept = "application/octet-stream"

    # Construct URL
    url = kwargs.pop("template_url", '/glossary/{glossaryGuid}/terms/export')
    path_format_arguments = {
        'glossaryGuid': _SERIALIZER.url("glossary_guid", glossary_guid, 'str', max_length=4096, min_length=1),
    }
    url = _format_url_section(url, **path_format_arguments)

    # Construct parameters
    query_parameters = kwargs.pop("params", {})  # type: Dict[str, Any]
    if api_version is not None:
        query_parameters['api-version'] = _SERIALIZER.query("api_version", api_version, 'str')

    # Construct headers
    header_parameters = kwargs.pop("headers", {})  # type: Dict[str, Any]
    if content_type is not None:
        header_parameters['Content-Type'] = _SERIALIZER.header("content_type", content_type, 'str')
    header_parameters['Accept'] = _SERIALIZER.header("accept", accept, 'str')

    return HttpRequest(
        method="POST",
        url=url,
        params=query_parameters,
        headers=header_parameters,
        json=json,
        content=content,
        **kwargs
    )


def build_glossaryrest_get_terms_by_glossary_name_request(
    glossary_name: str,
    *,
    limit: Optional[int] = None,
    offset: Optional[int] = None,
    api_version: Optional[str] = "2020-12-01-preview",
    **kwargs: Any
) -> HttpRequest:
    """Get terms by glossary name.

    Get terms by glossary name.

    See https://aka.ms/azsdk/python/llcwiki for how to incorporate this request_builder into your code flow.

    :param glossary_name: The name of the glossary.
    :type glossary_name: str
    :keyword limit: The page size - by default there is no paging.
    :paramtype limit: int
    :keyword offset: The offset for pagination purpose.
    :paramtype offset: int
    :keyword api_version: Api Version.
    :paramtype api_version: str
    :return: Returns an :class:`~azure.purview.catalog.core.rest.HttpRequest` that you will pass to the client's `send_request` method.
     See https://aka.ms/azsdk/python/llcwiki for how to incorporate this response into your code flow.
    :rtype: ~azure.purview.catalog.core.rest.HttpRequest
    """
    accept = "application/json"

    # Construct URL
    url = kwargs.pop("template_url", '/glossary/name/{glossaryName}/terms')
    path_format_arguments = {
        'glossaryName': _SERIALIZER.url("glossary_name", glossary_name, 'str', max_length=4096, min_length=1),
    }
    url = _format_url_section(url, **path_format_arguments)

    # Construct parameters
    query_parameters = kwargs.pop("params", {})  # type: Dict[str, Any]
    if limit is not None:
        query_parameters['limit'] = _SERIALIZER.query("limit", limit, 'int')
    if offset is not None:
        query_parameters['offset'] = _SERIALIZER.query("offset", offset, 'int')
    if api_version is not None:
        query_parameters['api-version'] = _SERIALIZER.query("api_version", api_version, 'str')

    # Construct headers
    header_parameters = kwargs.pop("headers", {})  # type: Dict[str, Any]
    header_parameters['Accept'] = _SERIALIZER.header("accept", accept, 'str')

    return HttpRequest(
        method="GET",
        url=url,
        params=query_parameters,
        headers=header_parameters,
        **kwargs
    )


def build_discoveryrest_search_advanced_request(
    *,
    json: Any = None,
    content: Any = None,
    api_version: Optional[str] = "2020-12-01-preview",
    **kwargs: Any
) -> HttpRequest:
    """Gets data using search.

    Gets data using search.

    See https://aka.ms/azsdk/python/llcwiki for how to incorporate this request_builder into your code flow.

    :keyword json: An object specifying the search criteria.
    :paramtype json: Any
    :keyword content: An object specifying the search criteria.
    :paramtype content: Any
    :keyword api_version: Api Version.
    :paramtype api_version: str
    :return: Returns an :class:`~azure.purview.catalog.core.rest.HttpRequest` that you will pass to the client's `send_request` method.
     See https://aka.ms/azsdk/python/llcwiki for how to incorporate this response into your code flow.
    :rtype: ~azure.purview.catalog.core.rest.HttpRequest
    """
    content_type = kwargs.pop("content_type", None)
    accept = "application/json"

    # Construct URL
    url = kwargs.pop("template_url", '/search/query')

    # Construct parameters
    query_parameters = kwargs.pop("params", {})  # type: Dict[str, Any]
    if api_version is not None:
        query_parameters['api-version'] = _SERIALIZER.query("api_version", api_version, 'str')

    # Construct headers
    header_parameters = kwargs.pop("headers", {})  # type: Dict[str, Any]
    if content_type is not None:
        header_parameters['Content-Type'] = _SERIALIZER.header("content_type", content_type, 'str')
    header_parameters['Accept'] = _SERIALIZER.header("accept", accept, 'str')

    return HttpRequest(
        method="POST",
        url=url,
        params=query_parameters,
        headers=header_parameters,
        json=json,
        content=content,
        **kwargs
    )


def build_discoveryrest_suggest_request(
    *,
    json: Any = None,
    content: Any = None,
    api_version: Optional[str] = "2020-12-01-preview",
    **kwargs: Any
) -> HttpRequest:
    """Get search suggestions by query criteria.

    Get search suggestions by query criteria.

    See https://aka.ms/azsdk/python/llcwiki for how to incorporate this request_builder into your code flow.

    :keyword json: An object specifying the suggest criteria.
    :paramtype json: Any
    :keyword content: An object specifying the suggest criteria.
    :paramtype content: Any
    :keyword api_version: Api Version.
    :paramtype api_version: str
    :return: Returns an :class:`~azure.purview.catalog.core.rest.HttpRequest` that you will pass to the client's `send_request` method.
     See https://aka.ms/azsdk/python/llcwiki for how to incorporate this response into your code flow.
    :rtype: ~azure.purview.catalog.core.rest.HttpRequest
    """
    content_type = kwargs.pop("content_type", None)
    accept = "application/json"

    # Construct URL
    url = kwargs.pop("template_url", '/search/suggest')

    # Construct parameters
    query_parameters = kwargs.pop("params", {})  # type: Dict[str, Any]
    if api_version is not None:
        query_parameters['api-version'] = _SERIALIZER.query("api_version", api_version, 'str')

    # Construct headers
    header_parameters = kwargs.pop("headers", {})  # type: Dict[str, Any]
    if content_type is not None:
        header_parameters['Content-Type'] = _SERIALIZER.header("content_type", content_type, 'str')
    header_parameters['Accept'] = _SERIALIZER.header("accept", accept, 'str')

    return HttpRequest(
        method="POST",
        url=url,
        params=query_parameters,
        headers=header_parameters,
        json=json,
        content=content,
        **kwargs
    )


def build_discoveryrest_auto_complete_request(
    *,
    json: Any = None,
    content: Any = None,
    api_version: Optional[str] = "2020-12-01-preview",
    **kwargs: Any
) -> HttpRequest:
    """Get auto complete options.

    Get auto complete options.

    See https://aka.ms/azsdk/python/llcwiki for how to incorporate this request_builder into your code flow.

    :keyword json: An object specifying the autocomplete criteria.
    :paramtype json: Any
    :keyword content: An object specifying the autocomplete criteria.
    :paramtype content: Any
    :keyword api_version: Api Version.
    :paramtype api_version: str
    :return: Returns an :class:`~azure.purview.catalog.core.rest.HttpRequest` that you will pass to the client's `send_request` method.
     See https://aka.ms/azsdk/python/llcwiki for how to incorporate this response into your code flow.
    :rtype: ~azure.purview.catalog.core.rest.HttpRequest
    """
    content_type = kwargs.pop("content_type", None)
    accept = "application/json"

    # Construct URL
    url = kwargs.pop("template_url", '/search/autocomplete')

    # Construct parameters
    query_parameters = kwargs.pop("params", {})  # type: Dict[str, Any]
    if api_version is not None:
        query_parameters['api-version'] = _SERIALIZER.query("api_version", api_version, 'str')

    # Construct headers
    header_parameters = kwargs.pop("headers", {})  # type: Dict[str, Any]
    if content_type is not None:
        header_parameters['Content-Type'] = _SERIALIZER.header("content_type", content_type, 'str')
    header_parameters['Accept'] = _SERIALIZER.header("accept", accept, 'str')

    return HttpRequest(
        method="POST",
        url=url,
        params=query_parameters,
        headers=header_parameters,
        json=json,
        content=content,
        **kwargs
    )


def build_lineagerest_get_lineage_graph_request(
    guid: str,
    *,
    direction: Union[str, "_models.Enum7"],
    depth: Optional[int] = 3,
    width: Optional[int] = 10,
    include_parent: Optional[bool] = None,
    get_derived_lineage: Optional[bool] = None,
    **kwargs: Any
) -> HttpRequest:
    """Get lineage info about the specified entity by GUID.

    Get lineage info about the specified entity by GUID.

    See https://aka.ms/azsdk/python/llcwiki for how to incorporate this request_builder into your code flow.

    :param guid: The globally unique identifier of the entity.
    :type guid: str
    :keyword direction: The direction of the lineage, which could be INPUT, OUTPUT or BOTH.
    :paramtype direction: str or ~azure.purview.catalog.models.Enum7
    :keyword depth: The number of hops for lineage.
    :paramtype depth: int
    :keyword width: The number of max expanding width in lineage.
    :paramtype width: int
    :keyword include_parent: True to include the parent chain in the response.
    :paramtype include_parent: bool
    :keyword get_derived_lineage: True to include derived lineage in the response.
    :paramtype get_derived_lineage: bool
    :return: Returns an :class:`~azure.purview.catalog.core.rest.HttpRequest` that you will pass to the client's `send_request` method.
     See https://aka.ms/azsdk/python/llcwiki for how to incorporate this response into your code flow.
    :rtype: ~azure.purview.catalog.core.rest.HttpRequest
    """
    accept = "application/json"

    # Construct URL
    url = kwargs.pop("template_url", '/atlas/v2/lineage/{guid}')
    path_format_arguments = {
        'guid': _SERIALIZER.url("guid", guid, 'str', max_length=4096, min_length=1),
    }
    url = _format_url_section(url, **path_format_arguments)

    # Construct parameters
    query_parameters = kwargs.pop("params", {})  # type: Dict[str, Any]
    if depth is not None:
        query_parameters['depth'] = _SERIALIZER.query("depth", depth, 'int')
    if width is not None:
        query_parameters['width'] = _SERIALIZER.query("width", width, 'int')
    query_parameters['direction'] = _SERIALIZER.query("direction", direction, 'str')
    if include_parent is not None:
        query_parameters['includeParent'] = _SERIALIZER.query("include_parent", include_parent, 'bool')
    if get_derived_lineage is not None:
        query_parameters['getDerivedLineage'] = _SERIALIZER.query("get_derived_lineage", get_derived_lineage, 'bool')

    # Construct headers
    header_parameters = kwargs.pop("headers", {})  # type: Dict[str, Any]
    header_parameters['Accept'] = _SERIALIZER.header("accept", accept, 'str')

    return HttpRequest(
        method="GET",
        url=url,
        params=query_parameters,
        headers=header_parameters,
        **kwargs
    )


def build_lineagerest_next_level_lineage_request(
    guid: str,
    *,
    direction: Union[str, "_models.Enum7"],
    get_derived_lineage: Optional[bool] = None,
    offset: Optional[int] = None,
    limit: Optional[int] = None,
    api_version: Optional[str] = "2020-12-01-preview",
    **kwargs: Any
) -> HttpRequest:
    """Return immediate next level lineage info about entity with pagination.

    Return immediate next level lineage info about entity with pagination.

    See https://aka.ms/azsdk/python/llcwiki for how to incorporate this request_builder into your code flow.

    :param guid: The globally unique identifier of the entity.
    :type guid: str
    :keyword direction: The direction of the lineage, which could be INPUT, OUTPUT or BOTH.
    :paramtype direction: str or ~azure.purview.catalog.models.Enum7
    :keyword get_derived_lineage: True to include derived lineage in the response.
    :paramtype get_derived_lineage: bool
    :keyword offset: The offset for pagination purpose.
    :paramtype offset: int
    :keyword limit: The page size - by default there is no paging.
    :paramtype limit: int
    :keyword api_version: Api Version.
    :paramtype api_version: str
    :return: Returns an :class:`~azure.purview.catalog.core.rest.HttpRequest` that you will pass to the client's `send_request` method.
     See https://aka.ms/azsdk/python/llcwiki for how to incorporate this response into your code flow.
    :rtype: ~azure.purview.catalog.core.rest.HttpRequest
    """
    accept = "application/json"

    # Construct URL
    url = kwargs.pop("template_url", '/lineage/{guid}/next/')
    path_format_arguments = {
        'guid': _SERIALIZER.url("guid", guid, 'str', max_length=4096, min_length=1),
    }
    url = _format_url_section(url, **path_format_arguments)

    # Construct parameters
    query_parameters = kwargs.pop("params", {})  # type: Dict[str, Any]
    query_parameters['direction'] = _SERIALIZER.query("direction", direction, 'str')
    if get_derived_lineage is not None:
        query_parameters['getDerivedLineage'] = _SERIALIZER.query("get_derived_lineage", get_derived_lineage, 'bool')
    if offset is not None:
        query_parameters['offset'] = _SERIALIZER.query("offset", offset, 'int')
    if limit is not None:
        query_parameters['limit'] = _SERIALIZER.query("limit", limit, 'int')
    if api_version is not None:
        query_parameters['api-version'] = _SERIALIZER.query("api_version", api_version, 'str')

    # Construct headers
    header_parameters = kwargs.pop("headers", {})  # type: Dict[str, Any]
    header_parameters['Accept'] = _SERIALIZER.header("accept", accept, 'str')

    return HttpRequest(
        method="GET",
        url=url,
        params=query_parameters,
        headers=header_parameters,
        **kwargs
    )


def build_relationshiprest_create_request(
    *,
    json: Any = None,
    content: Any = None,
    **kwargs: Any
) -> HttpRequest:
    """Create a new relationship between entities.

    Create a new relationship between entities.

    See https://aka.ms/azsdk/python/llcwiki for how to incorporate this request_builder into your code flow.

    :keyword json: The AtlasRelationship object containing the information for the relationship to
     be created.
    :paramtype json: Any
    :keyword content: The AtlasRelationship object containing the information for the relationship
     to be created.
    :paramtype content: Any
    :return: Returns an :class:`~azure.purview.catalog.core.rest.HttpRequest` that you will pass to the client's `send_request` method.
     See https://aka.ms/azsdk/python/llcwiki for how to incorporate this response into your code flow.
    :rtype: ~azure.purview.catalog.core.rest.HttpRequest
    """
    content_type = kwargs.pop("content_type", None)
    accept = "application/json"

    # Construct URL
    url = kwargs.pop("template_url", '/atlas/v2/relationship')

    # Construct headers
    header_parameters = kwargs.pop("headers", {})  # type: Dict[str, Any]
    if content_type is not None:
        header_parameters['Content-Type'] = _SERIALIZER.header("content_type", content_type, 'str')
    header_parameters['Accept'] = _SERIALIZER.header("accept", accept, 'str')

    return HttpRequest(
        method="POST",
        url=url,
        headers=header_parameters,
        json=json,
        content=content,
        **kwargs
    )


def build_relationshiprest_update_request(
    *,
    json: Any = None,
    content: Any = None,
    **kwargs: Any
) -> HttpRequest:
    """Update an existing relationship between entities.

    Update an existing relationship between entities.

    See https://aka.ms/azsdk/python/llcwiki for how to incorporate this request_builder into your code flow.

    :keyword json: The AtlasRelationship object containing the information for the relationship to
     be created.
    :paramtype json: Any
    :keyword content: The AtlasRelationship object containing the information for the relationship
     to be created.
    :paramtype content: Any
    :return: Returns an :class:`~azure.purview.catalog.core.rest.HttpRequest` that you will pass to the client's `send_request` method.
     See https://aka.ms/azsdk/python/llcwiki for how to incorporate this response into your code flow.
    :rtype: ~azure.purview.catalog.core.rest.HttpRequest
    """
    content_type = kwargs.pop("content_type", None)
    accept = "application/json"

    # Construct URL
    url = kwargs.pop("template_url", '/atlas/v2/relationship')

    # Construct headers
    header_parameters = kwargs.pop("headers", {})  # type: Dict[str, Any]
    if content_type is not None:
        header_parameters['Content-Type'] = _SERIALIZER.header("content_type", content_type, 'str')
    header_parameters['Accept'] = _SERIALIZER.header("accept", accept, 'str')

    return HttpRequest(
        method="PUT",
        url=url,
        headers=header_parameters,
        json=json,
        content=content,
        **kwargs
    )


def build_relationshiprest_get_by_id2_request(
    guid: str,
    *,
    extended_info: Optional[bool] = None,
    **kwargs: Any
) -> HttpRequest:
    """Get relationship information between entities by its GUID.

    Get relationship information between entities by its GUID.

    See https://aka.ms/azsdk/python/llcwiki for how to incorporate this request_builder into your code flow.

    :param guid: The globally unique identifier of the relationship.
    :type guid: str
    :keyword extended_info: Limits whether includes extended information.
    :paramtype extended_info: bool
    :return: Returns an :class:`~azure.purview.catalog.core.rest.HttpRequest` that you will pass to the client's `send_request` method.
     See https://aka.ms/azsdk/python/llcwiki for how to incorporate this response into your code flow.
    :rtype: ~azure.purview.catalog.core.rest.HttpRequest
    """
    accept = "application/json"

    # Construct URL
    url = kwargs.pop("template_url", '/atlas/v2/relationship/guid/{guid}')
    path_format_arguments = {
        'guid': _SERIALIZER.url("guid", guid, 'str', max_length=4096, min_length=1),
    }
    url = _format_url_section(url, **path_format_arguments)

    # Construct parameters
    query_parameters = kwargs.pop("params", {})  # type: Dict[str, Any]
    if extended_info is not None:
        query_parameters['extendedInfo'] = _SERIALIZER.query("extended_info", extended_info, 'bool')

    # Construct headers
    header_parameters = kwargs.pop("headers", {})  # type: Dict[str, Any]
    header_parameters['Accept'] = _SERIALIZER.header("accept", accept, 'str')

    return HttpRequest(
        method="GET",
        url=url,
        params=query_parameters,
        headers=header_parameters,
        **kwargs
    )


def build_relationshiprest_delete_by_id_request(
    guid: str,
    **kwargs: Any
) -> HttpRequest:
    """Delete a relationship between entities by its GUID.

    Delete a relationship between entities by its GUID.

    See https://aka.ms/azsdk/python/llcwiki for how to incorporate this request_builder into your code flow.

    :param guid: The globally unique identifier of the relationship.
    :type guid: str
    :return: Returns an :class:`~azure.purview.catalog.core.rest.HttpRequest` that you will pass to the client's `send_request` method.
     See https://aka.ms/azsdk/python/llcwiki for how to incorporate this response into your code flow.
    :rtype: ~azure.purview.catalog.core.rest.HttpRequest
    """

    # Construct URL
    url = kwargs.pop("template_url", '/atlas/v2/relationship/guid/{guid}')
    path_format_arguments = {
        'guid': _SERIALIZER.url("guid", guid, 'str', max_length=4096, min_length=1),
    }
    url = _format_url_section(url, **path_format_arguments)

    return HttpRequest(
        method="DELETE",
        url=url,
        **kwargs
    )


def build_typesrest_get_classification_def_by_guid_request(
    guid: str,
    **kwargs: Any
) -> HttpRequest:
    """Get the classification definition for the given GUID.

    Get the classification definition for the given GUID.

    See https://aka.ms/azsdk/python/llcwiki for how to incorporate this request_builder into your code flow.

    :param guid: The globally unique identifier of the classification.
    :type guid: str
    :return: Returns an :class:`~azure.purview.catalog.core.rest.HttpRequest` that you will pass to the client's `send_request` method.
     See https://aka.ms/azsdk/python/llcwiki for how to incorporate this response into your code flow.
    :rtype: ~azure.purview.catalog.core.rest.HttpRequest
    """
    accept = "application/json"

    # Construct URL
    url = kwargs.pop("template_url", '/atlas/v2/types/classificationdef/guid/{guid}')
    path_format_arguments = {
        'guid': _SERIALIZER.url("guid", guid, 'str', max_length=4096, min_length=1),
    }
    url = _format_url_section(url, **path_format_arguments)

    # Construct headers
    header_parameters = kwargs.pop("headers", {})  # type: Dict[str, Any]
    header_parameters['Accept'] = _SERIALIZER.header("accept", accept, 'str')

    return HttpRequest(
        method="GET",
        url=url,
        headers=header_parameters,
        **kwargs
    )


def build_typesrest_get_classification_def_by_name_request(
    name: str,
    **kwargs: Any
) -> HttpRequest:
    """Get the classification definition by its name.

    Get the classification definition by its name (unique).

    See https://aka.ms/azsdk/python/llcwiki for how to incorporate this request_builder into your code flow.

    :param name: The name of the classification.
    :type name: str
    :return: Returns an :class:`~azure.purview.catalog.core.rest.HttpRequest` that you will pass to the client's `send_request` method.
     See https://aka.ms/azsdk/python/llcwiki for how to incorporate this response into your code flow.
    :rtype: ~azure.purview.catalog.core.rest.HttpRequest
    """
    accept = "application/json"

    # Construct URL
    url = kwargs.pop("template_url", '/atlas/v2/types/classificationdef/name/{name}')
    path_format_arguments = {
        'name': _SERIALIZER.url("name", name, 'str', max_length=4096, min_length=1),
    }
    url = _format_url_section(url, **path_format_arguments)

    # Construct headers
    header_parameters = kwargs.pop("headers", {})  # type: Dict[str, Any]
    header_parameters['Accept'] = _SERIALIZER.header("accept", accept, 'str')

    return HttpRequest(
        method="GET",
        url=url,
        headers=header_parameters,
        **kwargs
    )


def build_typesrest_get_entity_def_by_guid_request(
    guid: str,
    **kwargs: Any
) -> HttpRequest:
    """Get the Entity definition for the given GUID.

    Get the Entity definition for the given GUID.

    See https://aka.ms/azsdk/python/llcwiki for how to incorporate this request_builder into your code flow.

    :param guid: The globally unique identifier of the entity.
    :type guid: str
    :return: Returns an :class:`~azure.purview.catalog.core.rest.HttpRequest` that you will pass to the client's `send_request` method.
     See https://aka.ms/azsdk/python/llcwiki for how to incorporate this response into your code flow.
    :rtype: ~azure.purview.catalog.core.rest.HttpRequest
    """
    accept = "application/json"

    # Construct URL
    url = kwargs.pop("template_url", '/atlas/v2/types/entitydef/guid/{guid}')
    path_format_arguments = {
        'guid': _SERIALIZER.url("guid", guid, 'str', max_length=4096, min_length=1),
    }
    url = _format_url_section(url, **path_format_arguments)

    # Construct headers
    header_parameters = kwargs.pop("headers", {})  # type: Dict[str, Any]
    header_parameters['Accept'] = _SERIALIZER.header("accept", accept, 'str')

    return HttpRequest(
        method="GET",
        url=url,
        headers=header_parameters,
        **kwargs
    )


def build_typesrest_get_entity_def_by_name_request(
    name: str,
    **kwargs: Any
) -> HttpRequest:
    """Get the entity definition by its name.

    Get the entity definition by its name (unique).

    See https://aka.ms/azsdk/python/llcwiki for how to incorporate this request_builder into your code flow.

    :param name: The name of the entity.
    :type name: str
    :return: Returns an :class:`~azure.purview.catalog.core.rest.HttpRequest` that you will pass to the client's `send_request` method.
     See https://aka.ms/azsdk/python/llcwiki for how to incorporate this response into your code flow.
    :rtype: ~azure.purview.catalog.core.rest.HttpRequest
    """
    accept = "application/json"

    # Construct URL
    url = kwargs.pop("template_url", '/atlas/v2/types/entitydef/name/{name}')
    path_format_arguments = {
        'name': _SERIALIZER.url("name", name, 'str', max_length=4096, min_length=1),
    }
    url = _format_url_section(url, **path_format_arguments)

    # Construct headers
    header_parameters = kwargs.pop("headers", {})  # type: Dict[str, Any]
    header_parameters['Accept'] = _SERIALIZER.header("accept", accept, 'str')

    return HttpRequest(
        method="GET",
        url=url,
        headers=header_parameters,
        **kwargs
    )


def build_typesrest_get_enum_def_by_guid_request(
    guid: str,
    **kwargs: Any
) -> HttpRequest:
    """Get the enum definition for the given GUID.

    Get the enum definition for the given GUID.

    See https://aka.ms/azsdk/python/llcwiki for how to incorporate this request_builder into your code flow.

    :param guid: The globally unique identifier of the enum.
    :type guid: str
    :return: Returns an :class:`~azure.purview.catalog.core.rest.HttpRequest` that you will pass to the client's `send_request` method.
     See https://aka.ms/azsdk/python/llcwiki for how to incorporate this response into your code flow.
    :rtype: ~azure.purview.catalog.core.rest.HttpRequest
    """
    accept = "application/json"

    # Construct URL
    url = kwargs.pop("template_url", '/atlas/v2/types/enumdef/guid/{guid}')
    path_format_arguments = {
        'guid': _SERIALIZER.url("guid", guid, 'str', max_length=4096, min_length=1),
    }
    url = _format_url_section(url, **path_format_arguments)

    # Construct headers
    header_parameters = kwargs.pop("headers", {})  # type: Dict[str, Any]
    header_parameters['Accept'] = _SERIALIZER.header("accept", accept, 'str')

    return HttpRequest(
        method="GET",
        url=url,
        headers=header_parameters,
        **kwargs
    )


def build_typesrest_get_enum_def_by_name_request(
    name: str,
    **kwargs: Any
) -> HttpRequest:
    """Get the enum definition by its name.

    Get the enum definition by its name (unique).

    See https://aka.ms/azsdk/python/llcwiki for how to incorporate this request_builder into your code flow.

    :param name: The name of the enum.
    :type name: str
    :return: Returns an :class:`~azure.purview.catalog.core.rest.HttpRequest` that you will pass to the client's `send_request` method.
     See https://aka.ms/azsdk/python/llcwiki for how to incorporate this response into your code flow.
    :rtype: ~azure.purview.catalog.core.rest.HttpRequest
    """
    accept = "application/json"

    # Construct URL
    url = kwargs.pop("template_url", '/atlas/v2/types/enumdef/name/{name}')
    path_format_arguments = {
        'name': _SERIALIZER.url("name", name, 'str', max_length=4096, min_length=1),
    }
    url = _format_url_section(url, **path_format_arguments)

    # Construct headers
    header_parameters = kwargs.pop("headers", {})  # type: Dict[str, Any]
    header_parameters['Accept'] = _SERIALIZER.header("accept", accept, 'str')

    return HttpRequest(
        method="GET",
        url=url,
        headers=header_parameters,
        **kwargs
    )


def build_typesrest_get_relationship_def_by_guid_request(
    guid: str,
    **kwargs: Any
) -> HttpRequest:
    """Get the relationship definition for the given GUID.

    Get the relationship definition for the given GUID.

    See https://aka.ms/azsdk/python/llcwiki for how to incorporate this request_builder into your code flow.

    :param guid: The globally unique identifier of the relationship.
    :type guid: str
    :return: Returns an :class:`~azure.purview.catalog.core.rest.HttpRequest` that you will pass to the client's `send_request` method.
     See https://aka.ms/azsdk/python/llcwiki for how to incorporate this response into your code flow.
    :rtype: ~azure.purview.catalog.core.rest.HttpRequest
    """
    accept = "application/json"

    # Construct URL
    url = kwargs.pop("template_url", '/atlas/v2/types/relationshipdef/guid/{guid}')
    path_format_arguments = {
        'guid': _SERIALIZER.url("guid", guid, 'str', max_length=4096, min_length=1),
    }
    url = _format_url_section(url, **path_format_arguments)

    # Construct headers
    header_parameters = kwargs.pop("headers", {})  # type: Dict[str, Any]
    header_parameters['Accept'] = _SERIALIZER.header("accept", accept, 'str')

    return HttpRequest(
        method="GET",
        url=url,
        headers=header_parameters,
        **kwargs
    )


def build_typesrest_get_relationship_def_by_name_request(
    name: str,
    **kwargs: Any
) -> HttpRequest:
    """Get the relationship definition by its name.

    Get the relationship definition by its name (unique).

    See https://aka.ms/azsdk/python/llcwiki for how to incorporate this request_builder into your code flow.

    :param name: The name of the relationship.
    :type name: str
    :return: Returns an :class:`~azure.purview.catalog.core.rest.HttpRequest` that you will pass to the client's `send_request` method.
     See https://aka.ms/azsdk/python/llcwiki for how to incorporate this response into your code flow.
    :rtype: ~azure.purview.catalog.core.rest.HttpRequest
    """
    accept = "application/json"

    # Construct URL
    url = kwargs.pop("template_url", '/atlas/v2/types/relationshipdef/name/{name}')
    path_format_arguments = {
        'name': _SERIALIZER.url("name", name, 'str', max_length=4096, min_length=1),
    }
    url = _format_url_section(url, **path_format_arguments)

    # Construct headers
    header_parameters = kwargs.pop("headers", {})  # type: Dict[str, Any]
    header_parameters['Accept'] = _SERIALIZER.header("accept", accept, 'str')

    return HttpRequest(
        method="GET",
        url=url,
        headers=header_parameters,
        **kwargs
    )


def build_typesrest_get_struct_def_by_guid_request(
    guid: str,
    **kwargs: Any
) -> HttpRequest:
    """Get the struct definition for the given GUID.

    Get the struct definition for the given GUID.

    See https://aka.ms/azsdk/python/llcwiki for how to incorporate this request_builder into your code flow.

    :param guid: The globally unique identifier of the struct.
    :type guid: str
    :return: Returns an :class:`~azure.purview.catalog.core.rest.HttpRequest` that you will pass to the client's `send_request` method.
     See https://aka.ms/azsdk/python/llcwiki for how to incorporate this response into your code flow.
    :rtype: ~azure.purview.catalog.core.rest.HttpRequest
    """
    accept = "application/json"

    # Construct URL
    url = kwargs.pop("template_url", '/atlas/v2/types/structdef/guid/{guid}')
    path_format_arguments = {
        'guid': _SERIALIZER.url("guid", guid, 'str', max_length=4096, min_length=1),
    }
    url = _format_url_section(url, **path_format_arguments)

    # Construct headers
    header_parameters = kwargs.pop("headers", {})  # type: Dict[str, Any]
    header_parameters['Accept'] = _SERIALIZER.header("accept", accept, 'str')

    return HttpRequest(
        method="GET",
        url=url,
        headers=header_parameters,
        **kwargs
    )


def build_typesrest_get_struct_def_by_name_request(
    name: str,
    **kwargs: Any
) -> HttpRequest:
    """Get the struct definition by its name.

    Get the struct definition by its name (unique).

    See https://aka.ms/azsdk/python/llcwiki for how to incorporate this request_builder into your code flow.

    :param name: The name of the struct.
    :type name: str
    :return: Returns an :class:`~azure.purview.catalog.core.rest.HttpRequest` that you will pass to the client's `send_request` method.
     See https://aka.ms/azsdk/python/llcwiki for how to incorporate this response into your code flow.
    :rtype: ~azure.purview.catalog.core.rest.HttpRequest
    """
    accept = "application/json"

    # Construct URL
    url = kwargs.pop("template_url", '/atlas/v2/types/structdef/name/{name}')
    path_format_arguments = {
        'name': _SERIALIZER.url("name", name, 'str', max_length=4096, min_length=1),
    }
    url = _format_url_section(url, **path_format_arguments)

    # Construct headers
    header_parameters = kwargs.pop("headers", {})  # type: Dict[str, Any]
    header_parameters['Accept'] = _SERIALIZER.header("accept", accept, 'str')

    return HttpRequest(
        method="GET",
        url=url,
        headers=header_parameters,
        **kwargs
    )


def build_typesrest_get_type_def_by_guid_request(
    guid: str,
    **kwargs: Any
) -> HttpRequest:
    """Get the type definition for the given GUID.

    Get the type definition for the given GUID.

    See https://aka.ms/azsdk/python/llcwiki for how to incorporate this request_builder into your code flow.

    :param guid: The globally unique identifier of the type.
    :type guid: str
    :return: Returns an :class:`~azure.purview.catalog.core.rest.HttpRequest` that you will pass to the client's `send_request` method.
     See https://aka.ms/azsdk/python/llcwiki for how to incorporate this response into your code flow.
    :rtype: ~azure.purview.catalog.core.rest.HttpRequest
    """
    accept = "application/json"

    # Construct URL
    url = kwargs.pop("template_url", '/atlas/v2/types/typedef/guid/{guid}')
    path_format_arguments = {
        'guid': _SERIALIZER.url("guid", guid, 'str', max_length=4096, min_length=1),
    }
    url = _format_url_section(url, **path_format_arguments)

    # Construct headers
    header_parameters = kwargs.pop("headers", {})  # type: Dict[str, Any]
    header_parameters['Accept'] = _SERIALIZER.header("accept", accept, 'str')

    return HttpRequest(
        method="GET",
        url=url,
        headers=header_parameters,
        **kwargs
    )


def build_typesrest_get_type_def_by_name_request(
    name: str,
    **kwargs: Any
) -> HttpRequest:
    """Get the type definition by its name.

    Get the type definition by its name (unique).

    See https://aka.ms/azsdk/python/llcwiki for how to incorporate this request_builder into your code flow.

    :param name: The name of the type.
    :type name: str
    :return: Returns an :class:`~azure.purview.catalog.core.rest.HttpRequest` that you will pass to the client's `send_request` method.
     See https://aka.ms/azsdk/python/llcwiki for how to incorporate this response into your code flow.
    :rtype: ~azure.purview.catalog.core.rest.HttpRequest
    """
    accept = "application/json"

    # Construct URL
    url = kwargs.pop("template_url", '/atlas/v2/types/typedef/name/{name}')
    path_format_arguments = {
        'name': _SERIALIZER.url("name", name, 'str', max_length=4096, min_length=1),
    }
    url = _format_url_section(url, **path_format_arguments)

    # Construct headers
    header_parameters = kwargs.pop("headers", {})  # type: Dict[str, Any]
    header_parameters['Accept'] = _SERIALIZER.header("accept", accept, 'str')

    return HttpRequest(
        method="GET",
        url=url,
        headers=header_parameters,
        **kwargs
    )


def build_typesrest_delete_type_by_name_request(
    name: str,
    **kwargs: Any
) -> HttpRequest:
    """Delete API for type identified by its name.

    Delete API for type identified by its name.

    See https://aka.ms/azsdk/python/llcwiki for how to incorporate this request_builder into your code flow.

    :param name: The name of the type.
    :type name: str
    :return: Returns an :class:`~azure.purview.catalog.core.rest.HttpRequest` that you will pass to the client's `send_request` method.
     See https://aka.ms/azsdk/python/llcwiki for how to incorporate this response into your code flow.
    :rtype: ~azure.purview.catalog.core.rest.HttpRequest
    """

    # Construct URL
    url = kwargs.pop("template_url", '/atlas/v2/types/typedef/name/{name}')
    path_format_arguments = {
        'name': _SERIALIZER.url("name", name, 'str', max_length=4096, min_length=1),
    }
    url = _format_url_section(url, **path_format_arguments)

    return HttpRequest(
        method="DELETE",
        url=url,
        **kwargs
    )


def build_typesrest_get_all_type_defs_request(
    *,
    include_term_template: Optional[bool] = False,
    type: Optional[Union[str, "_models.Enum14"]] = None,
    **kwargs: Any
) -> HttpRequest:
    """Get all type definitions in bulk.

    Get all type definitions in Atlas in bulk.

    See https://aka.ms/azsdk/python/llcwiki for how to incorporate this request_builder into your code flow.

    :keyword include_term_template: Whether include termtemplatedef when return all typedefs.
     This is always true when search filter type=term_template.
    :paramtype include_term_template: bool
    :keyword type: Typedef name as search filter when get typedefs.
    :paramtype type: str or ~azure.purview.catalog.models.Enum14
    :return: Returns an :class:`~azure.purview.catalog.core.rest.HttpRequest` that you will pass to the client's `send_request` method.
     See https://aka.ms/azsdk/python/llcwiki for how to incorporate this response into your code flow.
    :rtype: ~azure.purview.catalog.core.rest.HttpRequest
    """
    accept = "application/json"

    # Construct URL
    url = kwargs.pop("template_url", '/atlas/v2/types/typedefs')

    # Construct parameters
    query_parameters = kwargs.pop("params", {})  # type: Dict[str, Any]
    if include_term_template is not None:
        query_parameters['includeTermTemplate'] = _SERIALIZER.query("include_term_template", include_term_template, 'bool')
    if type is not None:
        query_parameters['type'] = _SERIALIZER.query("type", type, 'str')

    # Construct headers
    header_parameters = kwargs.pop("headers", {})  # type: Dict[str, Any]
    header_parameters['Accept'] = _SERIALIZER.header("accept", accept, 'str')

    return HttpRequest(
        method="GET",
        url=url,
        params=query_parameters,
        headers=header_parameters,
        **kwargs
    )


def build_typesrest_create_type_defs_request(
    *,
    json: Any = None,
    content: Any = None,
    **kwargs: Any
) -> HttpRequest:
    """Create all atlas type definitions in bulk.

    Create all atlas type definitions in bulk, only new definitions will be created.
    Any changes to the existing definitions will be discarded.

    See https://aka.ms/azsdk/python/llcwiki for how to incorporate this request_builder into your code flow.

    :keyword json: A composite wrapper object with corresponding lists of the type definition.
    :paramtype json: Any
    :keyword content: A composite wrapper object with corresponding lists of the type definition.
    :paramtype content: Any
    :return: Returns an :class:`~azure.purview.catalog.core.rest.HttpRequest` that you will pass to the client's `send_request` method.
     See https://aka.ms/azsdk/python/llcwiki for how to incorporate this response into your code flow.
    :rtype: ~azure.purview.catalog.core.rest.HttpRequest
    """
    content_type = kwargs.pop("content_type", None)
    accept = "application/json"

    # Construct URL
    url = kwargs.pop("template_url", '/atlas/v2/types/typedefs')

    # Construct headers
    header_parameters = kwargs.pop("headers", {})  # type: Dict[str, Any]
    if content_type is not None:
        header_parameters['Content-Type'] = _SERIALIZER.header("content_type", content_type, 'str')
    header_parameters['Accept'] = _SERIALIZER.header("accept", accept, 'str')

    return HttpRequest(
        method="POST",
        url=url,
        headers=header_parameters,
        json=json,
        content=content,
        **kwargs
    )


def build_typesrest_update_atlas_type_defs_request(
    *,
    json: Any = None,
    content: Any = None,
    **kwargs: Any
) -> HttpRequest:
    """Update all types in bulk.

    Update all types in bulk, changes detected in the type definitions would be persisted.

    See https://aka.ms/azsdk/python/llcwiki for how to incorporate this request_builder into your code flow.

    :keyword json: A composite object that captures all type definition changes.
    :paramtype json: Any
    :keyword content: A composite object that captures all type definition changes.
    :paramtype content: Any
    :return: Returns an :class:`~azure.purview.catalog.core.rest.HttpRequest` that you will pass to the client's `send_request` method.
     See https://aka.ms/azsdk/python/llcwiki for how to incorporate this response into your code flow.
    :rtype: ~azure.purview.catalog.core.rest.HttpRequest
    """
    content_type = kwargs.pop("content_type", None)
    accept = "application/json"

    # Construct URL
    url = kwargs.pop("template_url", '/atlas/v2/types/typedefs')

    # Construct headers
    header_parameters = kwargs.pop("headers", {})  # type: Dict[str, Any]
    if content_type is not None:
        header_parameters['Content-Type'] = _SERIALIZER.header("content_type", content_type, 'str')
    header_parameters['Accept'] = _SERIALIZER.header("accept", accept, 'str')

    return HttpRequest(
        method="PUT",
        url=url,
        headers=header_parameters,
        json=json,
        content=content,
        **kwargs
    )


def build_typesrest_delete_type_defs_request(
    *,
    json: Any = None,
    content: Any = None,
    **kwargs: Any
) -> HttpRequest:
    """Delete API for all types in bulk.

    Delete API for all types in bulk.

    See https://aka.ms/azsdk/python/llcwiki for how to incorporate this request_builder into your code flow.

    :keyword json: A composite object that captures all types to be deleted.
    :paramtype json: Any
    :keyword content: A composite object that captures all types to be deleted.
    :paramtype content: Any
    :return: Returns an :class:`~azure.purview.catalog.core.rest.HttpRequest` that you will pass to the client's `send_request` method.
     See https://aka.ms/azsdk/python/llcwiki for how to incorporate this response into your code flow.
    :rtype: ~azure.purview.catalog.core.rest.HttpRequest
    """
    content_type = kwargs.pop("content_type", None)

    # Construct URL
    url = kwargs.pop("template_url", '/atlas/v2/types/typedefs')

    # Construct headers
    header_parameters = kwargs.pop("headers", {})  # type: Dict[str, Any]
    if content_type is not None:
        header_parameters['Content-Type'] = _SERIALIZER.header("content_type", content_type, 'str')

    return HttpRequest(
        method="DELETE",
        url=url,
        headers=header_parameters,
        json=json,
        content=content,
        **kwargs
    )


def build_typesrest_get_type_def_headers_request(
    *,
    include_term_template: Optional[bool] = False,
    type: Optional[Union[str, "_models.Enum14"]] = None,
    **kwargs: Any
) -> HttpRequest:
    """List all type definitions returned as a list of minimal information header.

    List all type definitions returned as a list of minimal information header.

    See https://aka.ms/azsdk/python/llcwiki for how to incorporate this request_builder into your code flow.

    :keyword include_term_template: Whether include termtemplatedef when return all typedefs.
     This is always true when search filter type=term_template.
    :paramtype include_term_template: bool
    :keyword type: Typedef name as search filter when get typedefs.
    :paramtype type: str or ~azure.purview.catalog.models.Enum14
    :return: Returns an :class:`~azure.purview.catalog.core.rest.HttpRequest` that you will pass to the client's `send_request` method.
     See https://aka.ms/azsdk/python/llcwiki for how to incorporate this response into your code flow.
    :rtype: ~azure.purview.catalog.core.rest.HttpRequest
    """
    accept = "application/json"

    # Construct URL
    url = kwargs.pop("template_url", '/atlas/v2/types/typedefs/headers')

    # Construct parameters
    query_parameters = kwargs.pop("params", {})  # type: Dict[str, Any]
    if include_term_template is not None:
        query_parameters['includeTermTemplate'] = _SERIALIZER.query("include_term_template", include_term_template, 'bool')
    if type is not None:
        query_parameters['type'] = _SERIALIZER.query("type", type, 'str')

    # Construct headers
    header_parameters = kwargs.pop("headers", {})  # type: Dict[str, Any]
    header_parameters['Accept'] = _SERIALIZER.header("accept", accept, 'str')

    return HttpRequest(
        method="GET",
        url=url,
        params=query_parameters,
        headers=header_parameters,
        **kwargs
    )


def build_typesrest_get_type_statistics_request(
    *,
    api_version: Optional[str] = "2020-12-01-preview",
    **kwargs: Any
) -> HttpRequest:
    """Get type statistics.

    Get type statistics.

    See https://aka.ms/azsdk/python/llcwiki for how to incorporate this request_builder into your code flow.

    :keyword api_version: Api Version.
    :paramtype api_version: str
    :return: Returns an :class:`~azure.purview.catalog.core.rest.HttpRequest` that you will pass to the client's `send_request` method.
     See https://aka.ms/azsdk/python/llcwiki for how to incorporate this response into your code flow.
    :rtype: ~azure.purview.catalog.core.rest.HttpRequest
    """
    accept = "application/json"

    # Construct URL
    url = kwargs.pop("template_url", '/types/statistics')

    # Construct parameters
    query_parameters = kwargs.pop("params", {})  # type: Dict[str, Any]
    if api_version is not None:
        query_parameters['api-version'] = _SERIALIZER.query("api_version", api_version, 'str')

    # Construct headers
    header_parameters = kwargs.pop("headers", {})  # type: Dict[str, Any]
    header_parameters['Accept'] = _SERIALIZER.header("accept", accept, 'str')

    return HttpRequest(
        method="GET",
        url=url,
        params=query_parameters,
        headers=header_parameters,
        **kwargs
    )


def build_typesrest_get_term_template_def_by_guid_request(
    guid: str,
    *,
    api_version: Optional[str] = "2020-12-01-preview",
    **kwargs: Any
) -> HttpRequest:
    """Get the term template definition for the given GUID.

    Get the term template definition for the given GUID.

    See https://aka.ms/azsdk/python/llcwiki for how to incorporate this request_builder into your code flow.

    :param guid: The globally unique identifier of the term template.
    :type guid: str
    :keyword api_version: Api Version.
    :paramtype api_version: str
    :return: Returns an :class:`~azure.purview.catalog.core.rest.HttpRequest` that you will pass to the client's `send_request` method.
     See https://aka.ms/azsdk/python/llcwiki for how to incorporate this response into your code flow.
    :rtype: ~azure.purview.catalog.core.rest.HttpRequest
    """
    accept = "application/json"

    # Construct URL
    url = kwargs.pop("template_url", '/types/termtemplatedef/guid/{guid}')
    path_format_arguments = {
        'guid': _SERIALIZER.url("guid", guid, 'str', max_length=4096, min_length=1),
    }
    url = _format_url_section(url, **path_format_arguments)

    # Construct parameters
    query_parameters = kwargs.pop("params", {})  # type: Dict[str, Any]
    if api_version is not None:
        query_parameters['api-version'] = _SERIALIZER.query("api_version", api_version, 'str')

    # Construct headers
    header_parameters = kwargs.pop("headers", {})  # type: Dict[str, Any]
    header_parameters['Accept'] = _SERIALIZER.header("accept", accept, 'str')

    return HttpRequest(
        method="GET",
        url=url,
        params=query_parameters,
        headers=header_parameters,
        **kwargs
    )


def build_typesrest_get_term_template_def_by_name_request(
    name: str,
    *,
    api_version: Optional[str] = "2020-12-01-preview",
    **kwargs: Any
) -> HttpRequest:
    """Get the term template definition by its name.

    Get the term template definition by its name (unique).

    See https://aka.ms/azsdk/python/llcwiki for how to incorporate this request_builder into your code flow.

    :param name: The name of the term template.
    :type name: str
    :keyword api_version: Api Version.
    :paramtype api_version: str
    :return: Returns an :class:`~azure.purview.catalog.core.rest.HttpRequest` that you will pass to the client's `send_request` method.
     See https://aka.ms/azsdk/python/llcwiki for how to incorporate this response into your code flow.
    :rtype: ~azure.purview.catalog.core.rest.HttpRequest
    """
    accept = "application/json"

    # Construct URL
    url = kwargs.pop("template_url", '/types/termtemplatedef/name/{name}')
    path_format_arguments = {
        'name': _SERIALIZER.url("name", name, 'str', max_length=4096, min_length=1),
    }
    url = _format_url_section(url, **path_format_arguments)

    # Construct parameters
    query_parameters = kwargs.pop("params", {})  # type: Dict[str, Any]
    if api_version is not None:
        query_parameters['api-version'] = _SERIALIZER.query("api_version", api_version, 'str')

    # Construct headers
    header_parameters = kwargs.pop("headers", {})  # type: Dict[str, Any]
    header_parameters['Accept'] = _SERIALIZER.header("accept", accept, 'str')

    return HttpRequest(
        method="GET",
        url=url,
        params=query_parameters,
        headers=header_parameters,
        **kwargs
    )

