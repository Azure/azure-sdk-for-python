# coding=utf-8
# --------------------------------------------------------------------------
# Copyright (c) Microsoft Corporation. All rights reserved.
# Licensed under the MIT License. See License.txt in the project root for license information.
# Code generated by Microsoft (R) AutoRest Code Generator.
# Changes may cause incorrect behavior and will be lost if the code is regenerated.
# --------------------------------------------------------------------------

from enum import Enum, EnumMeta
from six import with_metaclass

class _CaseInsensitiveEnumMeta(EnumMeta):
    def __getitem__(self, name):
        return super().__getitem__(name.upper())

    def __getattr__(cls, name):
        """Return the enum member matching `name`
        We use __getattr__ instead of descriptors or inserting into the enum
        class' __dict__ in order to support `name` and `value` being both
        properties for enum members (which live in the class' __dict__) and
        enum members themselves.
        """
        try:
            return cls._member_map_[name.upper()]
        except KeyError:
            raise AttributeError(name)


class ApplicationDefinitionKind(with_metaclass(_CaseInsensitiveEnumMeta, str, Enum)):
    """The mechanism used to define a Service Fabric application.
    """

    #: Indicates the application definition kind is invalid. All Service Fabric enumerations have the
    #: invalid type. The value is 65535.
    INVALID = "Invalid"
    #: Indicates the application is defined by a Service Fabric application description. The value is
    #: 0.
    SERVICE_FABRIC_APPLICATION_DESCRIPTION = "ServiceFabricApplicationDescription"
    #: Indicates the application is defined by compose file(s). The value is 1.
    COMPOSE = "Compose"

class ApplicationPackageCleanupPolicy(with_metaclass(_CaseInsensitiveEnumMeta, str, Enum)):
    """The kind of action that needs to be taken for cleaning up the application package after
    successful provision.
    """

    #: Indicates that the application package cleanup policy is invalid. This value is default. The
    #: value is zero.
    INVALID = "Invalid"
    #: Indicates that the cleanup policy of application packages is based on the cluster setting
    #: "CleanupApplicationPackageOnProvisionSuccess." The value is 1.
    DEFAULT = "Default"
    #: Indicates that the service fabric runtime determines when to do the application package
    #: cleanup. By default, cleanup is done on successful provision. The value is 2.
    AUTOMATIC = "Automatic"
    #: Indicates that the user has to explicitly clean up the application package. The value is 3.
    MANUAL = "Manual"

class ApplicationResourceUpgradeState(with_metaclass(_CaseInsensitiveEnumMeta, str, Enum)):
    """The state of the application resource upgrade.
    """

    #: Indicates the upgrade state is invalid. All Service Fabric enumerations have the invalid type.
    #: The value is 0.
    INVALID = "Invalid"
    #: The upgrade is in the progress of provisioning target application type version. The value is 1.
    PROVISIONING_TARGET = "ProvisioningTarget"
    #: The upgrade is rolling forward to the target version but is not complete yet. The value is 2.
    ROLLING_FORWARD = "RollingForward"
    #: The upgrade is in the progress of unprovisioning current application type version and rolling
    #: forward to the target version is completed. The value is 3.
    UNPROVISIONING_CURRENT = "UnprovisioningCurrent"
    #: The upgrade has finished rolling forward. The value is 4.
    COMPLETED_ROLLFORWARD = "CompletedRollforward"
    #: The upgrade is rolling back to the previous version but is not complete yet. The value is 5.
    ROLLING_BACK = "RollingBack"
    #: The upgrade is in the progress of unprovisioning target application type version and rolling
    #: back to the current version is completed. The value is 6.
    UNPROVISIONING_TARGET = "UnprovisioningTarget"
    #: The upgrade has finished rolling back. The value is 7.
    COMPLETED_ROLLBACK = "CompletedRollback"
    #: The upgrade has failed and is unable to execute FailureAction. The value is 8.
    FAILED = "Failed"

class ApplicationScopedVolumeKind(with_metaclass(_CaseInsensitiveEnumMeta, str, Enum)):
    """Specifies the application-scoped volume kind.
    """

    #: Provides Service Fabric High Availability Volume Disk.
    SERVICE_FABRIC_VOLUME_DISK = "ServiceFabricVolumeDisk"

class ApplicationStatus(with_metaclass(_CaseInsensitiveEnumMeta, str, Enum)):
    """The status of the application.
    """

    #: Indicates the application status is invalid. All Service Fabric enumerations have the invalid
    #: type. The value is zero.
    INVALID = "Invalid"
    #: Indicates the application status is ready. The value is 1.
    READY = "Ready"
    #: Indicates the application status is upgrading. The value is 2.
    UPGRADING = "Upgrading"
    #: Indicates the application status is creating. The value is 3.
    CREATING = "Creating"
    #: Indicates the application status is deleting. The value is 4.
    DELETING = "Deleting"
    #: Indicates the creation or deletion of application was terminated due to persistent failures.
    #: Another create/delete request can be accepted to resume a failed application. The value is 5.
    FAILED = "Failed"

class ApplicationTypeDefinitionKind(with_metaclass(_CaseInsensitiveEnumMeta, str, Enum)):
    """The mechanism used to define a Service Fabric application type.
    """

    #: Indicates the application type definition kind is invalid. All Service Fabric enumerations have
    #: the invalid type. The value is 0.
    INVALID = "Invalid"
    #: Indicates the application type is defined and created by a Service Fabric application package
    #: provided by the user. The value is 1.
    SERVICE_FABRIC_APPLICATION_PACKAGE = "ServiceFabricApplicationPackage"
    #: Indicates the application type is defined and created implicitly as part of a compose
    #: deployment. The value is 2.
    COMPOSE = "Compose"

class ApplicationTypeStatus(with_metaclass(_CaseInsensitiveEnumMeta, str, Enum)):
    """The status of the application type.
    """

    #: Indicates the application type status is invalid. All Service Fabric enumerations have the
    #: invalid type. The value is zero.
    INVALID = "Invalid"
    #: Indicates that the application type is being provisioned in the cluster. The value is 1.
    PROVISIONING = "Provisioning"
    #: Indicates that the application type is fully provisioned and is available for use. An
    #: application of this type and version can be created. The value is 2.
    AVAILABLE = "Available"
    #: Indicates that the application type is in process of being unprovisioned from the cluster. The
    #: value is 3.
    UNPROVISIONING = "Unprovisioning"
    #: Indicates that the application type provisioning failed and it is unavailable for use. The
    #: failure details can be obtained from the application type information query. The failed
    #: application type information remains in the cluster until it is unprovisioned or reprovisioned
    #: successfully. The value is 4.
    FAILED = "Failed"

class AutoScalingMechanismKind(with_metaclass(_CaseInsensitiveEnumMeta, str, Enum)):
    """Enumerates the mechanisms for auto scaling.
    """

    #: Indicates that scaling should be performed by adding or removing replicas.
    ADD_REMOVE_REPLICA = "AddRemoveReplica"

class AutoScalingMetricKind(with_metaclass(_CaseInsensitiveEnumMeta, str, Enum)):
    """Enumerates the metrics that are used for triggering auto scaling.
    """

    #: Indicates that the metric is one of resources, like cpu or memory.
    RESOURCE = "Resource"

class AutoScalingResourceMetricName(with_metaclass(_CaseInsensitiveEnumMeta, str, Enum)):
    """Enumerates the resources that are used for triggering auto scaling.
    """

    #: Indicates that the resource is CPU cores.
    CPU = "cpu"
    #: Indicates that the resource is memory in GB.
    MEMORY_IN_GB = "memoryInGB"

class AutoScalingTriggerKind(with_metaclass(_CaseInsensitiveEnumMeta, str, Enum)):
    """Enumerates the triggers for auto scaling.
    """

    #: Indicates that scaling should be performed based on average load of all replicas in the
    #: service.
    AVERAGE_LOAD = "AverageLoad"

class BackupEntityKind(with_metaclass(_CaseInsensitiveEnumMeta, str, Enum)):
    """The entity type of a Service Fabric entity such as Application, Service or a Partition where
    periodic backups can be enabled.
    """

    #: Indicates an invalid entity kind. All Service Fabric enumerations have the invalid type.
    INVALID = "Invalid"
    #: Indicates the entity is a Service Fabric partition.
    PARTITION = "Partition"
    #: Indicates the entity is a Service Fabric service.
    SERVICE = "Service"
    #: Indicates the entity is a Service Fabric application.
    APPLICATION = "Application"

class BackupPolicyScope(with_metaclass(_CaseInsensitiveEnumMeta, str, Enum)):
    """Specifies the scope at which the backup policy is applied.
    """

    #: Indicates an invalid backup policy scope type. All Service Fabric enumerations have the invalid
    #: type.
    INVALID = "Invalid"
    #: Indicates the backup policy is applied at partition level. Hence overriding any policy which
    #: may have applied at partition's service or application level.
    PARTITION = "Partition"
    #: Indicates the backup policy is applied at service level. All partitions of the service inherit
    #: this policy unless explicitly overridden at partition level.
    SERVICE = "Service"
    #: Indicates the backup policy is applied at application level. All services and partitions of the
    #: application inherit this policy unless explicitly overridden at service or partition level.
    APPLICATION = "Application"

class BackupScheduleFrequencyType(with_metaclass(_CaseInsensitiveEnumMeta, str, Enum)):
    """Describes the frequency with which to run the time based backup schedule.
    """

    #: Indicates an invalid backup schedule frequency type. All Service Fabric enumerations have the
    #: invalid type.
    INVALID = "Invalid"
    #: Indicates that the time based backup schedule is repeated at a daily frequency.
    DAILY = "Daily"
    #: Indicates that the time based backup schedule is repeated at a weekly frequency.
    WEEKLY = "Weekly"

class BackupScheduleKind(with_metaclass(_CaseInsensitiveEnumMeta, str, Enum)):
    """The kind of backup schedule, time based or frequency based.
    """

    #: Indicates an invalid backup schedule kind. All Service Fabric enumerations have the invalid
    #: type.
    INVALID = "Invalid"
    #: Indicates a time-based backup schedule.
    TIME_BASED = "TimeBased"
    #: Indicates a frequency-based backup schedule.
    FREQUENCY_BASED = "FrequencyBased"

class BackupState(with_metaclass(_CaseInsensitiveEnumMeta, str, Enum)):
    """Represents the current state of the partition backup operation.
    """

    #: Indicates an invalid backup state. All Service Fabric enumerations have the invalid type.
    INVALID = "Invalid"
    #: Operation has been validated and accepted. Backup is yet to be triggered.
    ACCEPTED = "Accepted"
    #: Backup operation has been triggered and is under process.
    BACKUP_IN_PROGRESS = "BackupInProgress"
    #: Operation completed with success.
    SUCCESS = "Success"
    #: Operation completed with failure.
    FAILURE = "Failure"
    #: Operation timed out.
    TIMEOUT = "Timeout"

class BackupStorageKind(with_metaclass(_CaseInsensitiveEnumMeta, str, Enum)):
    """The kind of backup storage, where backups are saved.
    """

    #: Indicates an invalid backup storage kind. All Service Fabric enumerations have the invalid
    #: type.
    INVALID = "Invalid"
    #: Indicates file/ SMB share to be used as backup storage.
    FILE_SHARE = "FileShare"
    #: Indicates Azure blob store to be used as backup storage.
    AZURE_BLOB_STORE = "AzureBlobStore"
    #: Indicates Dsms Azure blob store to be used as backup storage.
    DSMS_AZURE_BLOB_STORE = "DsmsAzureBlobStore"
    #: Indicates Azure blob store to be used as backup storage using managed identity.
    MANAGED_IDENTITY_AZURE_BLOB_STORE = "ManagedIdentityAzureBlobStore"

class BackupSuspensionScope(with_metaclass(_CaseInsensitiveEnumMeta, str, Enum)):
    """Specifies the scope at which the backup suspension was applied.
    """

    #: Indicates an invalid backup suspension scope type also indicating entity is not suspended. All
    #: Service Fabric enumerations have the invalid type.
    INVALID = "Invalid"
    #: Indicates the backup suspension is applied at partition level.
    PARTITION = "Partition"
    #: Indicates the backup suspension is applied at service level. All partitions of the service are
    #: hence suspended for backup.
    SERVICE = "Service"
    #: Indicates the backup suspension is applied at application level. All services and partitions of
    #: the application are hence suspended for backup.
    APPLICATION = "Application"

class BackupType(with_metaclass(_CaseInsensitiveEnumMeta, str, Enum)):
    """Describes the type of backup, whether its full or incremental.
    """

    #: Indicates an invalid backup type. All Service Fabric enumerations have the invalid type.
    INVALID = "Invalid"
    #: Indicates a full backup.
    FULL = "Full"
    #: Indicates an incremental backup. A backup chain is comprised of a full backup followed by 0 or
    #: more incremental backups.
    INCREMENTAL = "Incremental"

class ChaosEventKind(with_metaclass(_CaseInsensitiveEnumMeta, str, Enum)):
    """The kind of Chaos event.
    """

    #: Indicates an invalid Chaos event kind. All Service Fabric enumerations have the invalid type.
    INVALID = "Invalid"
    #: Indicates a Chaos event that gets generated when Chaos is started.
    STARTED = "Started"
    #: Indicates a Chaos event that gets generated when Chaos has decided on the faults for an
    #: iteration. This Chaos event contains the details of the faults as a list of strings.
    EXECUTING_FAULTS = "ExecutingFaults"
    #: Indicates a Chaos event that gets generated when Chaos is waiting for the cluster to become
    #: ready for faulting, for example, Chaos may be waiting for the on-going upgrade to finish.
    WAITING = "Waiting"
    #: Indicates a Chaos event that gets generated when the cluster entities do not become stable and
    #: healthy within ChaosParameters.MaxClusterStabilizationTimeoutInSeconds.
    VALIDATION_FAILED = "ValidationFailed"
    #: Indicates a Chaos event that gets generated when an unexpected event has occurred in the Chaos
    #: engine, for example, due to the cluster snapshot being inconsistent, while faulting a faultable
    #: entity Chaos found that the entity was already faulted.
    TEST_ERROR = "TestError"
    #: Indicates a Chaos event that gets generated when Chaos stops because either the user issued a
    #: stop or the time to run was up.
    STOPPED = "Stopped"

class ChaosScheduleStatus(with_metaclass(_CaseInsensitiveEnumMeta, str, Enum)):
    """Current status of the schedule.
    """

    #: Indicates an invalid Chaos Schedule status. All Service Fabric enumerations have the invalid
    #: type. The value is zero.
    INVALID = "Invalid"
    #: Indicates that the schedule is stopped and not being used to schedule runs of chaos. The value
    #: is one.
    STOPPED = "Stopped"
    #: Indicates that the schedule is active and is being used to schedule runs of Chaos. The value is
    #: two.
    ACTIVE = "Active"
    #: Indicates that the schedule is expired and will no longer be used to schedule runs of Chaos.
    #: The value is three.
    EXPIRED = "Expired"
    #: Indicates that the schedule is pending and is not yet being used to schedule runs of Chaos but
    #: will be used when the start time is passed. The value is four.
    PENDING = "Pending"

class ChaosStatus(with_metaclass(_CaseInsensitiveEnumMeta, str, Enum)):
    """Current status of the Chaos run.
    """

    #: Indicates an invalid Chaos status. All Service Fabric enumerations have the invalid type. The
    #: value is zero.
    INVALID = "Invalid"
    #: Indicates that Chaos is not stopped. The value is one.
    RUNNING = "Running"
    #: Indicates that Chaos is not scheduling further faults. The value is two.
    STOPPED = "Stopped"

class ComposeDeploymentStatus(with_metaclass(_CaseInsensitiveEnumMeta, str, Enum)):
    """The status of the compose deployment.
    """

    #: Indicates that the compose deployment status is invalid. The value is zero.
    INVALID = "Invalid"
    #: Indicates that the compose deployment is being provisioned in background. The value is 1.
    PROVISIONING = "Provisioning"
    #: Indicates that the compose deployment is being created in background. The value is 2.
    CREATING = "Creating"
    #: Indicates that the compose deployment has been successfully created or upgraded. The value is
    #: 3.
    READY = "Ready"
    #: Indicates that the compose deployment is being unprovisioned in background. The value is 4.
    UNPROVISIONING = "Unprovisioning"
    #: Indicates that the compose deployment is being deleted in background. The value is 5.
    DELETING = "Deleting"
    #: Indicates that the compose deployment was terminated due to persistent failures. The value is
    #: 6.
    FAILED = "Failed"
    #: Indicates that the compose deployment is being upgraded in the background. The value is 7.
    UPGRADING = "Upgrading"

class ComposeDeploymentUpgradeState(with_metaclass(_CaseInsensitiveEnumMeta, str, Enum)):
    """The state of the compose deployment upgrade.
    """

    #: Indicates the upgrade state is invalid. All Service Fabric enumerations have the invalid type.
    #: The value is zero.
    INVALID = "Invalid"
    #: The upgrade is in the progress of provisioning target application type version. The value is 1.
    PROVISIONING_TARGET = "ProvisioningTarget"
    #: The upgrade is rolling forward to the target version but is not complete yet. The value is 2.
    ROLLING_FORWARD_IN_PROGRESS = "RollingForwardInProgress"
    #: The current upgrade domain has finished upgrading. The overall upgrade is waiting for an
    #: explicit move next request in UnmonitoredManual mode or performing health checks in Monitored
    #: mode. The value is 3.
    ROLLING_FORWARD_PENDING = "RollingForwardPending"
    #: The upgrade is in the progress of unprovisioning current application type version and rolling
    #: forward to the target version is completed. The value is 4.
    UNPROVISIONING_CURRENT = "UnprovisioningCurrent"
    #: The upgrade has finished rolling forward. The value is 5.
    ROLLING_FORWARD_COMPLETED = "RollingForwardCompleted"
    #: The upgrade is rolling back to the previous version but is not complete yet. The value is 6.
    ROLLING_BACK_IN_PROGRESS = "RollingBackInProgress"
    #: The upgrade is in the progress of unprovisioning target application type version and rolling
    #: back to the current version is completed. The value is 7.
    UNPROVISIONING_TARGET = "UnprovisioningTarget"
    #: The upgrade has finished rolling back. The value is 8.
    ROLLING_BACK_COMPLETED = "RollingBackCompleted"
    #: The upgrade has failed and is unable to execute FailureAction. The value is 9.
    FAILED = "Failed"

class CreateFabricDump(with_metaclass(_CaseInsensitiveEnumMeta, str, Enum)):
    """Specify True to create a dump of the fabric node process. This is case-sensitive.
    """

    FALSE = "False"
    TRUE = "True"

class DataLossMode(with_metaclass(_CaseInsensitiveEnumMeta, str, Enum)):

    #: Reserved.  Do not pass into API.
    INVALID = "Invalid"
    #: PartialDataLoss option will cause a quorum of replicas to go down, triggering an OnDataLoss
    #: event in the system for the given partition.
    PARTIAL_DATA_LOSS = "PartialDataLoss"
    #: FullDataLoss option will drop all the replicas which means that all the data will be lost.
    FULL_DATA_LOSS = "FullDataLoss"

class DayOfWeek(with_metaclass(_CaseInsensitiveEnumMeta, str, Enum)):
    """Describes the days in a week.
    """

    #: Indicates the Day referred is Sunday.
    SUNDAY = "Sunday"
    #: Indicates the Day referred is Monday.
    MONDAY = "Monday"
    #: Indicates the Day referred is Tuesday.
    TUESDAY = "Tuesday"
    #: Indicates the Day referred is Wednesday.
    WEDNESDAY = "Wednesday"
    #: Indicates the Day referred is Thursday.
    THURSDAY = "Thursday"
    #: Indicates the Day referred is Friday.
    FRIDAY = "Friday"
    #: Indicates the Day referred is Saturday.
    SATURDAY = "Saturday"

class DeactivationIntent(with_metaclass(_CaseInsensitiveEnumMeta, str, Enum)):
    """Describes the intent or reason for deactivating the node. The possible values are following.
    """

    #: Indicates that the node should be paused. The value is 1.
    PAUSE = "Pause"
    #: Indicates that the intent is for the node to be restarted after a short period of time. The
    #: value is 2.
    RESTART = "Restart"
    #: Indicates the intent is for the node to remove data. The value is 3.
    REMOVE_DATA = "RemoveData"

class DeployedApplicationStatus(with_metaclass(_CaseInsensitiveEnumMeta, str, Enum)):
    """The status of the application deployed on the node. Following are the possible values.
    """

    #: Indicates that deployment status is not valid. All Service Fabric enumerations have the invalid
    #: type. The value is zero.
    INVALID = "Invalid"
    #: Indicates that the package is downloading from the ImageStore. The value is 1.
    DOWNLOADING = "Downloading"
    #: Indicates that the package is activating. The value is 2.
    ACTIVATING = "Activating"
    #: Indicates that the package is active. The value is 3.
    ACTIVE = "Active"
    #: Indicates that the package is upgrading. The value is 4.
    UPGRADING = "Upgrading"
    #: Indicates that the package is deactivating. The value is 5.
    DEACTIVATING = "Deactivating"

class DeploymentStatus(with_metaclass(_CaseInsensitiveEnumMeta, str, Enum)):
    """Specifies the status of a deployed application or service package on a Service Fabric node.
    """

    #: Indicates status of the application or service package is not known or invalid. The value is 0.
    INVALID = "Invalid"
    #: Indicates the application or service package is being downloaded to the node from the
    #: ImageStore. The value is 1.
    DOWNLOADING = "Downloading"
    #: Indicates the application or service package is being activated. The value is 2.
    ACTIVATING = "Activating"
    #: Indicates the application or service package is active the node. The value is 3.
    ACTIVE = "Active"
    #: Indicates the application or service package is being upgraded. The value is 4.
    UPGRADING = "Upgrading"
    #: Indicates the application or service package is being deactivated. The value is 5.
    DEACTIVATING = "Deactivating"
    #: Indicates the application or service package has ran to completion successfully. The value is
    #: 6.
    RAN_TO_COMPLETION = "RanToCompletion"
    #: Indicates the application or service package has failed to run to completion. The value is 7.
    FAILED = "Failed"

class DiagnosticsSinkKind(with_metaclass(_CaseInsensitiveEnumMeta, str, Enum)):
    """The kind of DiagnosticsSink.
    """

    #: Indicates an invalid sink kind. All Service Fabric enumerations have the invalid type.
    INVALID = "Invalid"
    #: Diagnostics settings for Geneva.
    AZURE_INTERNAL_MONITORING_PIPELINE = "AzureInternalMonitoringPipeline"

class EntityKind(with_metaclass(_CaseInsensitiveEnumMeta, str, Enum)):
    """The entity type of a Service Fabric entity such as Cluster, Node, Application, Service,
    Partition, Replica etc.
    """

    #: Indicates an invalid entity kind. All Service Fabric enumerations have the invalid type. The
    #: value is zero.
    INVALID = "Invalid"
    #: Indicates the entity is a Service Fabric node. The value is 1.
    NODE = "Node"
    #: Indicates the entity is a Service Fabric partition. The value is 2.
    PARTITION = "Partition"
    #: Indicates the entity is a Service Fabric service. The value is 3.
    SERVICE = "Service"
    #: Indicates the entity is a Service Fabric application. The value is 4.
    APPLICATION = "Application"
    #: Indicates the entity is a Service Fabric replica. The value is 5.
    REPLICA = "Replica"
    #: Indicates the entity is a Service Fabric deployed application. The value is 6.
    DEPLOYED_APPLICATION = "DeployedApplication"
    #: Indicates the entity is a Service Fabric deployed service package. The value is 7.
    DEPLOYED_SERVICE_PACKAGE = "DeployedServicePackage"
    #: Indicates the entity is a Service Fabric cluster. The value is 8.
    CLUSTER = "Cluster"

class EntryPointStatus(with_metaclass(_CaseInsensitiveEnumMeta, str, Enum)):
    """Specifies the status of the code package entry point deployed on a Service Fabric node.
    """

    #: Indicates status of entry point is not known or invalid. The value is 0.
    INVALID = "Invalid"
    #: Indicates the entry point is scheduled to be started. The value is 1.
    PENDING = "Pending"
    #: Indicates the entry point is being started. The value is 2.
    STARTING = "Starting"
    #: Indicates the entry point was started successfully and is running. The value is 3.
    STARTED = "Started"
    #: Indicates the entry point is being stopped. The value is 4.
    STOPPING = "Stopping"
    #: Indicates the entry point is not running. The value is 5.
    STOPPED = "Stopped"

class EnvironmentVariableType(with_metaclass(_CaseInsensitiveEnumMeta, str, Enum)):
    """The type of the environment variable being given in value
    """

    #: The environment variable in clear text, will not be processed in any way and passed in as is.
    CLEAR_TEXT = "ClearText"
    #: The URI to a KeyVault secret version, will be resolved using the application's managed identity
    #: (this type is only valid if the app was assigned a managed identity) before getting passed in.
    KEY_VAULT_REFERENCE = "KeyVaultReference"
    #: The reference to a SecretValue resource, will be resolved before getting passed in.
    SECRET_VALUE_REFERENCE = "SecretValueReference"

class ExecutionPolicyType(with_metaclass(_CaseInsensitiveEnumMeta, str, Enum)):
    """Enumerates the execution policy types for services.
    """

    #: Indicates the default execution policy, always restart the service if an exit occurs.
    DEFAULT = "Default"
    #: Indicates that the service will perform its desired operation and complete successfully. If the
    #: service encounters failure, it will restarted based on restart policy specified. If the service
    #: completes its operation successfully, it will not be restarted again.
    RUN_TO_COMPLETION = "RunToCompletion"

class FabricErrorCodes(with_metaclass(_CaseInsensitiveEnumMeta, str, Enum)):
    """Defines the fabric error codes that be returned as part of the error object in response to
    Service Fabric API operations that are not successful. Following are the error code values that
    can be returned for a specific HTTP status code.
    
    
    *
      Possible values of the error code for HTTP status code 400 (Bad Request)
    
    
      * "FABRIC_E_INVALID_PARTITION_KEY"
      * "FABRIC_E_IMAGEBUILDER_VALIDATION_ERROR"
      * "FABRIC_E_INVALID_ADDRESS"
      * "FABRIC_E_APPLICATION_NOT_UPGRADING"
      * "FABRIC_E_APPLICATION_UPGRADE_VALIDATION_ERROR"
      * "FABRIC_E_FABRIC_NOT_UPGRADING"
      * "FABRIC_E_FABRIC_UPGRADE_VALIDATION_ERROR"
      * "FABRIC_E_INVALID_CONFIGURATION"
      * "FABRIC_E_INVALID_NAME_URI"
      * "FABRIC_E_PATH_TOO_LONG"
      * "FABRIC_E_KEY_TOO_LARGE"
      * "FABRIC_E_SERVICE_AFFINITY_CHAIN_NOT_SUPPORTED"
      * "FABRIC_E_INVALID_ATOMIC_GROUP"
      * "FABRIC_E_VALUE_EMPTY"
      * "FABRIC_E_BACKUP_IS_ENABLED"
      * "FABRIC_E_RESTORE_SOURCE_TARGET_PARTITION_MISMATCH"
      * "FABRIC_E_INVALID_FOR_STATELESS_SERVICES"
      * "FABRIC_E_INVALID_SERVICE_SCALING_POLICY"
      * "E_INVALIDARG"
    
    *
      Possible values of the error code for HTTP status code 404 (Not Found)
    
    
      * "FABRIC_E_NODE_NOT_FOUND"
      * "FABRIC_E_APPLICATION_TYPE_NOT_FOUND"
      * "FABRIC_E_APPLICATION_NOT_FOUND"
      * "FABRIC_E_SERVICE_TYPE_NOT_FOUND"
      * "FABRIC_E_SERVICE_DOES_NOT_EXIST"
      * "FABRIC_E_SERVICE_TYPE_TEMPLATE_NOT_FOUND"
      * "FABRIC_E_CONFIGURATION_SECTION_NOT_FOUND"
      * "FABRIC_E_PARTITION_NOT_FOUND"
      * "FABRIC_E_REPLICA_DOES_NOT_EXIST"
      * "FABRIC_E_SERVICE_GROUP_DOES_NOT_EXIST"
      * "FABRIC_E_CONFIGURATION_PARAMETER_NOT_FOUND"
      * "FABRIC_E_DIRECTORY_NOT_FOUND"
      * "FABRIC_E_FABRIC_VERSION_NOT_FOUND"
      * "FABRIC_E_FILE_NOT_FOUND"
      * "FABRIC_E_NAME_DOES_NOT_EXIST"
      * "FABRIC_E_PROPERTY_DOES_NOT_EXIST"
      * "FABRIC_E_ENUMERATION_COMPLETED"
      * "FABRIC_E_SERVICE_MANIFEST_NOT_FOUND"
      * "FABRIC_E_KEY_NOT_FOUND"
      * "FABRIC_E_HEALTH_ENTITY_NOT_FOUND"
      * "FABRIC_E_BACKUP_NOT_ENABLED"
      * "FABRIC_E_BACKUP_POLICY_NOT_EXISTING"
      * "FABRIC_E_FAULT_ANALYSIS_SERVICE_NOT_EXISTING"
      * "FABRIC_E_IMAGEBUILDER_RESERVED_DIRECTORY_ERROR"
    
    *
      Possible values of the error code for HTTP status code 409 (Conflict)
    
    
      * "FABRIC_E_APPLICATION_TYPE_ALREADY_EXISTS"
      * "FABRIC_E_APPLICATION_ALREADY_EXISTS"
      * "FABRIC_E_APPLICATION_ALREADY_IN_TARGET_VERSION"
      * "FABRIC_E_APPLICATION_TYPE_PROVISION_IN_PROGRESS"
      * "FABRIC_E_APPLICATION_UPGRADE_IN_PROGRESS"
      * "FABRIC_E_SERVICE_ALREADY_EXISTS"
      * "FABRIC_E_SERVICE_GROUP_ALREADY_EXISTS"
      * "FABRIC_E_APPLICATION_TYPE_IN_USE"
      * "FABRIC_E_FABRIC_ALREADY_IN_TARGET_VERSION"
      * "FABRIC_E_FABRIC_VERSION_ALREADY_EXISTS"
      * "FABRIC_E_FABRIC_VERSION_IN_USE"
      * "FABRIC_E_FABRIC_UPGRADE_IN_PROGRESS"
      * "FABRIC_E_NAME_ALREADY_EXISTS"
      * "FABRIC_E_NAME_NOT_EMPTY"
      * "FABRIC_E_PROPERTY_CHECK_FAILED"
      * "FABRIC_E_SERVICE_METADATA_MISMATCH"
      * "FABRIC_E_SERVICE_TYPE_MISMATCH"
      * "FABRIC_E_HEALTH_STALE_REPORT"
      * "FABRIC_E_SEQUENCE_NUMBER_CHECK_FAILED"
      * "FABRIC_E_NODE_HAS_NOT_STOPPED_YET"
      * "FABRIC_E_INSTANCE_ID_MISMATCH"
      * "FABRIC_E_BACKUP_IN_PROGRESS"
      * "FABRIC_E_RESTORE_IN_PROGRESS"
      * "FABRIC_E_BACKUP_POLICY_ALREADY_EXISTING"
    
    *
      Possible values of the error code for HTTP status code 413 (Request Entity Too Large)
    
    
      * "FABRIC_E_VALUE_TOO_LARGE"
    
    *
      Possible values of the error code for HTTP status code 500 (Internal Server Error)
    
    
      * "FABRIC_E_NODE_IS_UP"
      * "E_FAIL"
      * "FABRIC_E_SINGLE_INSTANCE_APPLICATION_ALREADY_EXISTS"
      * "FABRIC_E_SINGLE_INSTANCE_APPLICATION_NOT_FOUND"
      * "FABRIC_E_VOLUME_ALREADY_EXISTS"
      * "FABRIC_E_VOLUME_NOT_FOUND"
      * "SerializationError"
    
    *
      Possible values of the error code for HTTP status code 503 (Service Unavailable)
    
    
      * "FABRIC_E_NO_WRITE_QUORUM"
      * "FABRIC_E_NOT_PRIMARY"
      * "FABRIC_E_NOT_READY"
      * "FABRIC_E_RECONFIGURATION_PENDING"
      * "FABRIC_E_SERVICE_OFFLINE"
      * "E_ABORT"
      * "FABRIC_E_VALUE_TOO_LARGE"
    
    *
      Possible values of the error code for HTTP status code 504 (Gateway Timeout)
    
    
      * "FABRIC_E_COMMUNICATION_ERROR"
      * "FABRIC_E_OPERATION_NOT_COMPLETE"
      * "FABRIC_E_TIMEOUT"
    """

    FABRIC_E_INVALID_PARTITION_KEY = "FABRIC_E_INVALID_PARTITION_KEY"
    FABRIC_E_IMAGEBUILDER_VALIDATION_ERROR = "FABRIC_E_IMAGEBUILDER_VALIDATION_ERROR"
    FABRIC_E_INVALID_ADDRESS = "FABRIC_E_INVALID_ADDRESS"
    FABRIC_E_APPLICATION_NOT_UPGRADING = "FABRIC_E_APPLICATION_NOT_UPGRADING"
    FABRIC_E_APPLICATION_UPGRADE_VALIDATION_ERROR = "FABRIC_E_APPLICATION_UPGRADE_VALIDATION_ERROR"
    FABRIC_E_FABRIC_NOT_UPGRADING = "FABRIC_E_FABRIC_NOT_UPGRADING"
    FABRIC_E_FABRIC_UPGRADE_VALIDATION_ERROR = "FABRIC_E_FABRIC_UPGRADE_VALIDATION_ERROR"
    FABRIC_E_INVALID_CONFIGURATION = "FABRIC_E_INVALID_CONFIGURATION"
    FABRIC_E_INVALID_NAME_URI = "FABRIC_E_INVALID_NAME_URI"
    FABRIC_E_PATH_TOO_LONG = "FABRIC_E_PATH_TOO_LONG"
    FABRIC_E_KEY_TOO_LARGE = "FABRIC_E_KEY_TOO_LARGE"
    FABRIC_E_SERVICE_AFFINITY_CHAIN_NOT_SUPPORTED = "FABRIC_E_SERVICE_AFFINITY_CHAIN_NOT_SUPPORTED"
    FABRIC_E_INVALID_ATOMIC_GROUP = "FABRIC_E_INVALID_ATOMIC_GROUP"
    FABRIC_E_VALUE_EMPTY = "FABRIC_E_VALUE_EMPTY"
    FABRIC_E_NODE_NOT_FOUND = "FABRIC_E_NODE_NOT_FOUND"
    FABRIC_E_APPLICATION_TYPE_NOT_FOUND = "FABRIC_E_APPLICATION_TYPE_NOT_FOUND"
    FABRIC_E_APPLICATION_NOT_FOUND = "FABRIC_E_APPLICATION_NOT_FOUND"
    FABRIC_E_SERVICE_TYPE_NOT_FOUND = "FABRIC_E_SERVICE_TYPE_NOT_FOUND"
    FABRIC_E_SERVICE_DOES_NOT_EXIST = "FABRIC_E_SERVICE_DOES_NOT_EXIST"
    FABRIC_E_SERVICE_TYPE_TEMPLATE_NOT_FOUND = "FABRIC_E_SERVICE_TYPE_TEMPLATE_NOT_FOUND"
    FABRIC_E_CONFIGURATION_SECTION_NOT_FOUND = "FABRIC_E_CONFIGURATION_SECTION_NOT_FOUND"
    FABRIC_E_PARTITION_NOT_FOUND = "FABRIC_E_PARTITION_NOT_FOUND"
    FABRIC_E_REPLICA_DOES_NOT_EXIST = "FABRIC_E_REPLICA_DOES_NOT_EXIST"
    FABRIC_E_SERVICE_GROUP_DOES_NOT_EXIST = "FABRIC_E_SERVICE_GROUP_DOES_NOT_EXIST"
    FABRIC_E_CONFIGURATION_PARAMETER_NOT_FOUND = "FABRIC_E_CONFIGURATION_PARAMETER_NOT_FOUND"
    FABRIC_E_DIRECTORY_NOT_FOUND = "FABRIC_E_DIRECTORY_NOT_FOUND"
    FABRIC_E_FABRIC_VERSION_NOT_FOUND = "FABRIC_E_FABRIC_VERSION_NOT_FOUND"
    FABRIC_E_FILE_NOT_FOUND = "FABRIC_E_FILE_NOT_FOUND"
    FABRIC_E_NAME_DOES_NOT_EXIST = "FABRIC_E_NAME_DOES_NOT_EXIST"
    FABRIC_E_PROPERTY_DOES_NOT_EXIST = "FABRIC_E_PROPERTY_DOES_NOT_EXIST"
    FABRIC_E_ENUMERATION_COMPLETED = "FABRIC_E_ENUMERATION_COMPLETED"
    FABRIC_E_SERVICE_MANIFEST_NOT_FOUND = "FABRIC_E_SERVICE_MANIFEST_NOT_FOUND"
    FABRIC_E_KEY_NOT_FOUND = "FABRIC_E_KEY_NOT_FOUND"
    FABRIC_E_HEALTH_ENTITY_NOT_FOUND = "FABRIC_E_HEALTH_ENTITY_NOT_FOUND"
    FABRIC_E_APPLICATION_TYPE_ALREADY_EXISTS = "FABRIC_E_APPLICATION_TYPE_ALREADY_EXISTS"
    FABRIC_E_APPLICATION_ALREADY_EXISTS = "FABRIC_E_APPLICATION_ALREADY_EXISTS"
    FABRIC_E_APPLICATION_ALREADY_IN_TARGET_VERSION = "FABRIC_E_APPLICATION_ALREADY_IN_TARGET_VERSION"
    FABRIC_E_APPLICATION_TYPE_PROVISION_IN_PROGRESS = "FABRIC_E_APPLICATION_TYPE_PROVISION_IN_PROGRESS"
    FABRIC_E_APPLICATION_UPGRADE_IN_PROGRESS = "FABRIC_E_APPLICATION_UPGRADE_IN_PROGRESS"
    FABRIC_E_SERVICE_ALREADY_EXISTS = "FABRIC_E_SERVICE_ALREADY_EXISTS"
    FABRIC_E_SERVICE_GROUP_ALREADY_EXISTS = "FABRIC_E_SERVICE_GROUP_ALREADY_EXISTS"
    FABRIC_E_APPLICATION_TYPE_IN_USE = "FABRIC_E_APPLICATION_TYPE_IN_USE"
    FABRIC_E_FABRIC_ALREADY_IN_TARGET_VERSION = "FABRIC_E_FABRIC_ALREADY_IN_TARGET_VERSION"
    FABRIC_E_FABRIC_VERSION_ALREADY_EXISTS = "FABRIC_E_FABRIC_VERSION_ALREADY_EXISTS"
    FABRIC_E_FABRIC_VERSION_IN_USE = "FABRIC_E_FABRIC_VERSION_IN_USE"
    FABRIC_E_FABRIC_UPGRADE_IN_PROGRESS = "FABRIC_E_FABRIC_UPGRADE_IN_PROGRESS"
    FABRIC_E_NAME_ALREADY_EXISTS = "FABRIC_E_NAME_ALREADY_EXISTS"
    FABRIC_E_NAME_NOT_EMPTY = "FABRIC_E_NAME_NOT_EMPTY"
    FABRIC_E_PROPERTY_CHECK_FAILED = "FABRIC_E_PROPERTY_CHECK_FAILED"
    FABRIC_E_SERVICE_METADATA_MISMATCH = "FABRIC_E_SERVICE_METADATA_MISMATCH"
    FABRIC_E_SERVICE_TYPE_MISMATCH = "FABRIC_E_SERVICE_TYPE_MISMATCH"
    FABRIC_E_HEALTH_STALE_REPORT = "FABRIC_E_HEALTH_STALE_REPORT"
    FABRIC_E_SEQUENCE_NUMBER_CHECK_FAILED = "FABRIC_E_SEQUENCE_NUMBER_CHECK_FAILED"
    FABRIC_E_NODE_HAS_NOT_STOPPED_YET = "FABRIC_E_NODE_HAS_NOT_STOPPED_YET"
    FABRIC_E_INSTANCE_ID_MISMATCH = "FABRIC_E_INSTANCE_ID_MISMATCH"
    FABRIC_E_VALUE_TOO_LARGE = "FABRIC_E_VALUE_TOO_LARGE"
    FABRIC_E_NO_WRITE_QUORUM = "FABRIC_E_NO_WRITE_QUORUM"
    FABRIC_E_NOT_PRIMARY = "FABRIC_E_NOT_PRIMARY"
    FABRIC_E_NOT_READY = "FABRIC_E_NOT_READY"
    FABRIC_E_RECONFIGURATION_PENDING = "FABRIC_E_RECONFIGURATION_PENDING"
    FABRIC_E_SERVICE_OFFLINE = "FABRIC_E_SERVICE_OFFLINE"
    E_ABORT = "E_ABORT"
    FABRIC_E_COMMUNICATION_ERROR = "FABRIC_E_COMMUNICATION_ERROR"
    FABRIC_E_OPERATION_NOT_COMPLETE = "FABRIC_E_OPERATION_NOT_COMPLETE"
    FABRIC_E_TIMEOUT = "FABRIC_E_TIMEOUT"
    FABRIC_E_NODE_IS_UP = "FABRIC_E_NODE_IS_UP"
    E_FAIL = "E_FAIL"
    FABRIC_E_BACKUP_IS_ENABLED = "FABRIC_E_BACKUP_IS_ENABLED"
    FABRIC_E_RESTORE_SOURCE_TARGET_PARTITION_MISMATCH = "FABRIC_E_RESTORE_SOURCE_TARGET_PARTITION_MISMATCH"
    FABRIC_E_INVALID_FOR_STATELESS_SERVICES = "FABRIC_E_INVALID_FOR_STATELESS_SERVICES"
    FABRIC_E_BACKUP_NOT_ENABLED = "FABRIC_E_BACKUP_NOT_ENABLED"
    FABRIC_E_BACKUP_POLICY_NOT_EXISTING = "FABRIC_E_BACKUP_POLICY_NOT_EXISTING"
    FABRIC_E_FAULT_ANALYSIS_SERVICE_NOT_EXISTING = "FABRIC_E_FAULT_ANALYSIS_SERVICE_NOT_EXISTING"
    FABRIC_E_BACKUP_IN_PROGRESS = "FABRIC_E_BACKUP_IN_PROGRESS"
    FABRIC_E_RESTORE_IN_PROGRESS = "FABRIC_E_RESTORE_IN_PROGRESS"
    FABRIC_E_BACKUP_POLICY_ALREADY_EXISTING = "FABRIC_E_BACKUP_POLICY_ALREADY_EXISTING"
    FABRIC_E_INVALID_SERVICE_SCALING_POLICY = "FABRIC_E_INVALID_SERVICE_SCALING_POLICY"
    E_INVALIDARG = "E_INVALIDARG"
    FABRIC_E_SINGLE_INSTANCE_APPLICATION_ALREADY_EXISTS = "FABRIC_E_SINGLE_INSTANCE_APPLICATION_ALREADY_EXISTS"
    FABRIC_E_SINGLE_INSTANCE_APPLICATION_NOT_FOUND = "FABRIC_E_SINGLE_INSTANCE_APPLICATION_NOT_FOUND"
    FABRIC_E_VOLUME_ALREADY_EXISTS = "FABRIC_E_VOLUME_ALREADY_EXISTS"
    FABRIC_E_VOLUME_NOT_FOUND = "FABRIC_E_VOLUME_NOT_FOUND"
    SERIALIZATION_ERROR = "SerializationError"
    FABRIC_E_IMAGEBUILDER_RESERVED_DIRECTORY_ERROR = "FABRIC_E_IMAGEBUILDER_RESERVED_DIRECTORY_ERROR"

class FabricEventKind(with_metaclass(_CaseInsensitiveEnumMeta, str, Enum)):
    """The kind of FabricEvent.
    """

    CLUSTER_EVENT = "ClusterEvent"
    CONTAINER_INSTANCE_EVENT = "ContainerInstanceEvent"
    NODE_EVENT = "NodeEvent"
    APPLICATION_EVENT = "ApplicationEvent"
    SERVICE_EVENT = "ServiceEvent"
    PARTITION_EVENT = "PartitionEvent"
    REPLICA_EVENT = "ReplicaEvent"
    PARTITION_ANALYSIS_EVENT = "PartitionAnalysisEvent"
    APPLICATION_CREATED = "ApplicationCreated"
    APPLICATION_DELETED = "ApplicationDeleted"
    APPLICATION_NEW_HEALTH_REPORT = "ApplicationNewHealthReport"
    APPLICATION_HEALTH_REPORT_EXPIRED = "ApplicationHealthReportExpired"
    APPLICATION_UPGRADE_COMPLETED = "ApplicationUpgradeCompleted"
    APPLICATION_UPGRADE_DOMAIN_COMPLETED = "ApplicationUpgradeDomainCompleted"
    APPLICATION_UPGRADE_ROLLBACK_COMPLETED = "ApplicationUpgradeRollbackCompleted"
    APPLICATION_UPGRADE_ROLLBACK_STARTED = "ApplicationUpgradeRollbackStarted"
    APPLICATION_UPGRADE_STARTED = "ApplicationUpgradeStarted"
    DEPLOYED_APPLICATION_NEW_HEALTH_REPORT = "DeployedApplicationNewHealthReport"
    DEPLOYED_APPLICATION_HEALTH_REPORT_EXPIRED = "DeployedApplicationHealthReportExpired"
    APPLICATION_PROCESS_EXITED = "ApplicationProcessExited"
    APPLICATION_CONTAINER_INSTANCE_EXITED = "ApplicationContainerInstanceExited"
    NODE_ABORTED = "NodeAborted"
    NODE_ADDED_TO_CLUSTER = "NodeAddedToCluster"
    NODE_CLOSED = "NodeClosed"
    NODE_DEACTIVATE_COMPLETED = "NodeDeactivateCompleted"
    NODE_DEACTIVATE_STARTED = "NodeDeactivateStarted"
    NODE_DOWN = "NodeDown"
    NODE_NEW_HEALTH_REPORT = "NodeNewHealthReport"
    NODE_HEALTH_REPORT_EXPIRED = "NodeHealthReportExpired"
    NODE_OPEN_SUCCEEDED = "NodeOpenSucceeded"
    NODE_OPEN_FAILED = "NodeOpenFailed"
    NODE_REMOVED_FROM_CLUSTER = "NodeRemovedFromCluster"
    NODE_UP = "NodeUp"
    PARTITION_NEW_HEALTH_REPORT = "PartitionNewHealthReport"
    PARTITION_HEALTH_REPORT_EXPIRED = "PartitionHealthReportExpired"
    PARTITION_RECONFIGURED = "PartitionReconfigured"
    PARTITION_PRIMARY_MOVE_ANALYSIS = "PartitionPrimaryMoveAnalysis"
    SERVICE_CREATED = "ServiceCreated"
    SERVICE_DELETED = "ServiceDeleted"
    SERVICE_NEW_HEALTH_REPORT = "ServiceNewHealthReport"
    SERVICE_HEALTH_REPORT_EXPIRED = "ServiceHealthReportExpired"
    DEPLOYED_SERVICE_PACKAGE_NEW_HEALTH_REPORT = "DeployedServicePackageNewHealthReport"
    DEPLOYED_SERVICE_PACKAGE_HEALTH_REPORT_EXPIRED = "DeployedServicePackageHealthReportExpired"
    STATEFUL_REPLICA_NEW_HEALTH_REPORT = "StatefulReplicaNewHealthReport"
    STATEFUL_REPLICA_HEALTH_REPORT_EXPIRED = "StatefulReplicaHealthReportExpired"
    STATELESS_REPLICA_NEW_HEALTH_REPORT = "StatelessReplicaNewHealthReport"
    STATELESS_REPLICA_HEALTH_REPORT_EXPIRED = "StatelessReplicaHealthReportExpired"
    CLUSTER_NEW_HEALTH_REPORT = "ClusterNewHealthReport"
    CLUSTER_HEALTH_REPORT_EXPIRED = "ClusterHealthReportExpired"
    CLUSTER_UPGRADE_COMPLETED = "ClusterUpgradeCompleted"
    CLUSTER_UPGRADE_DOMAIN_COMPLETED = "ClusterUpgradeDomainCompleted"
    CLUSTER_UPGRADE_ROLLBACK_COMPLETED = "ClusterUpgradeRollbackCompleted"
    CLUSTER_UPGRADE_ROLLBACK_STARTED = "ClusterUpgradeRollbackStarted"
    CLUSTER_UPGRADE_STARTED = "ClusterUpgradeStarted"
    CHAOS_STOPPED = "ChaosStopped"
    CHAOS_STARTED = "ChaosStarted"
    CHAOS_CODE_PACKAGE_RESTART_SCHEDULED = "ChaosCodePackageRestartScheduled"
    CHAOS_REPLICA_REMOVAL_SCHEDULED = "ChaosReplicaRemovalScheduled"
    CHAOS_PARTITION_SECONDARY_MOVE_SCHEDULED = "ChaosPartitionSecondaryMoveScheduled"
    CHAOS_PARTITION_PRIMARY_MOVE_SCHEDULED = "ChaosPartitionPrimaryMoveScheduled"
    CHAOS_REPLICA_RESTART_SCHEDULED = "ChaosReplicaRestartScheduled"
    CHAOS_NODE_RESTART_SCHEDULED = "ChaosNodeRestartScheduled"

class FabricReplicaStatus(with_metaclass(_CaseInsensitiveEnumMeta, str, Enum)):
    """Specifies the status of the replica.
    """

    #: Indicates that the read or write operation access status is not valid. This value is not
    #: returned to the caller.
    INVALID = "Invalid"
    #: Indicates that the replica is down.
    DOWN = "Down"
    #: Indicates that the replica is up.
    UP = "Up"

class FailureAction(with_metaclass(_CaseInsensitiveEnumMeta, str, Enum)):
    """The compensating action to perform when a Monitored upgrade encounters monitoring policy or
    health policy violations.
    Invalid indicates the failure action is invalid. Rollback specifies that the upgrade will start
    rolling back automatically.
    Manual indicates that the upgrade will switch to UnmonitoredManual upgrade mode.
    """

    #: Indicates the failure action is invalid. All Service Fabric enumerations have the invalid type.
    #: The value is zero.
    INVALID = "Invalid"
    #: The upgrade will start rolling back automatically. The value is 1.
    ROLLBACK = "Rollback"
    #: The upgrade will switch to UnmonitoredManual upgrade mode. The value is 2.
    MANUAL = "Manual"

class FailureReason(with_metaclass(_CaseInsensitiveEnumMeta, str, Enum)):
    """The cause of an upgrade failure that resulted in FailureAction being executed.
    """

    #: Indicates the reason is invalid or unknown. All Service Fabric enumerations have the invalid
    #: type. The value is zero.
    NONE = "None"
    #: There was an external request to roll back the upgrade. The value is 1.
    INTERRUPTED = "Interrupted"
    #: The upgrade failed due to health policy violations. The value is 2.
    HEALTH_CHECK = "HealthCheck"
    #: An upgrade domain took longer than the allowed upgrade domain timeout to process. The value is
    #: 3.
    UPGRADE_DOMAIN_TIMEOUT = "UpgradeDomainTimeout"
    #: The overall upgrade took longer than the allowed upgrade timeout to process. The value is 4.
    OVERALL_UPGRADE_TIMEOUT = "OverallUpgradeTimeout"

class HeaderMatchType(with_metaclass(_CaseInsensitiveEnumMeta, str, Enum)):
    """how to match header value
    """

    EXACT = "exact"

class HealthEvaluationKind(with_metaclass(_CaseInsensitiveEnumMeta, str, Enum)):
    """The health manager in the cluster performs health evaluations in determining the aggregated
    health state of an entity. This enumeration provides information on the kind of evaluation that
    was performed. Following are the possible values.
    """

    #: Indicates that the health evaluation is invalid. The value is zero.
    INVALID = "Invalid"
    #: Indicates that the health evaluation is for a health event. The value is 1.
    EVENT = "Event"
    #: Indicates that the health evaluation is for the replicas of a partition. The value is 2.
    REPLICAS = "Replicas"
    #: Indicates that the health evaluation is for the partitions of a service. The value is 3.
    PARTITIONS = "Partitions"
    #: Indicates that the health evaluation is for the deployed service packages of a deployed
    #: application. The value is 4.
    DEPLOYED_SERVICE_PACKAGES = "DeployedServicePackages"
    #: Indicates that the health evaluation is for the deployed applications of an application. The
    #: value is 5.
    DEPLOYED_APPLICATIONS = "DeployedApplications"
    #: Indicates that the health evaluation is for services of an application. The value is 6.
    SERVICES = "Services"
    #: Indicates that the health evaluation is for the cluster nodes. The value is 7.
    NODES = "Nodes"
    #: Indicates that the health evaluation is for the cluster applications. The value is 8.
    APPLICATIONS = "Applications"
    #: Indicates that the health evaluation is for the system application. The value is 9.
    SYSTEM_APPLICATION = "SystemApplication"
    #: Indicates that the health evaluation is for the deployed applications of an application in an
    #: upgrade domain. The value is 10.
    UPGRADE_DOMAIN_DEPLOYED_APPLICATIONS = "UpgradeDomainDeployedApplications"
    #: Indicates that the health evaluation is for the cluster nodes in an upgrade domain. The value
    #: is 11.
    UPGRADE_DOMAIN_NODES = "UpgradeDomainNodes"
    #: Indicates that the health evaluation is for a replica. The value is 13.
    REPLICA = "Replica"
    #: Indicates that the health evaluation is for a partition. The value is 14.
    PARTITION = "Partition"
    #: Indicates that the health evaluation is for a deployed service package. The value is 16.
    DEPLOYED_SERVICE_PACKAGE = "DeployedServicePackage"
    #: Indicates that the health evaluation is for a deployed application. The value is 17.
    DEPLOYED_APPLICATION = "DeployedApplication"
    #: Indicates that the health evaluation is for a service. The value is 15.
    SERVICE = "Service"
    #: Indicates that the health evaluation is for a node. The value is 12.
    NODE = "Node"
    #: Indicates that the health evaluation is for an application. The value is 18.
    APPLICATION = "Application"
    #: Indicates that the health evaluation is for the delta of unhealthy cluster nodes. The value is
    #: 19.
    DELTA_NODES_CHECK = "DeltaNodesCheck"
    #: Indicates that the health evaluation is for the delta of unhealthy upgrade domain cluster
    #: nodes. The value is 20.
    UPGRADE_DOMAIN_DELTA_NODES_CHECK = "UpgradeDomainDeltaNodesCheck"
    #: – Indicates that the health evaluation is for applications of an application type. The value is
    #: 21.
    APPLICATION_TYPE_APPLICATIONS = "ApplicationTypeApplications"
    #: – Indicates that the health evaluation is for nodes of a node type. The value is 22.
    NODE_TYPE_NODES = "NodeTypeNodes"

class HealthState(with_metaclass(_CaseInsensitiveEnumMeta, str, Enum)):
    """The health state of a Service Fabric entity such as Cluster, Node, Application, Service,
    Partition, Replica etc.
    """

    #: Indicates an invalid health state. All Service Fabric enumerations have the invalid type. The
    #: value is zero.
    INVALID = "Invalid"
    #: Indicates the health state is okay. The value is 1.
    OK = "Ok"
    #: Indicates the health state is at a warning level. The value is 2.
    WARNING = "Warning"
    #: Indicates the health state is at an error level. Error health state should be investigated, as
    #: they can impact the correct functionality of the cluster. The value is 3.
    ERROR = "Error"
    #: Indicates an unknown health status. The value is 65535.
    UNKNOWN = "Unknown"

class HostIsolationMode(with_metaclass(_CaseInsensitiveEnumMeta, str, Enum)):
    """Specifies the isolation mode of main entry point of a code package when it's host type is
    ContainerHost. This is specified as part of container host policies in application manifest
    while importing service manifest.
    """

    #: Indicates the isolation mode is not applicable for given HostType. The value is 0.
    NONE = "None"
    #: This is the default isolation mode for a ContainerHost. The value is 1.
    PROCESS = "Process"
    #: Indicates the ContainerHost is a Hyper-V container. This applies to only Windows containers.
    #: The value is 2.
    HYPER_V = "HyperV"

class HostOptions(with_metaclass(_CaseInsensitiveEnumMeta, str, Enum)):
    """choices for server host
    """

    #: host: http://localhost:19080/.
    HTTP_LOCALHOST19080_ = "http://localhost:19080/"
    #: host: https://localhost:19080/.
    HTTPS_LOCALHOST19080_ = "https://localhost:19080/"

class HostType(with_metaclass(_CaseInsensitiveEnumMeta, str, Enum)):
    """Specifies the type of host for main entry point of a code package as specified in service
    manifest.
    """

    #: Indicates the type of host is not known or invalid. The value is 0.
    INVALID = "Invalid"
    #: Indicates the host is an executable. The value is 1.
    EXE_HOST = "ExeHost"
    #: Indicates the host is a container. The value is 2.
    CONTAINER_HOST = "ContainerHost"

class ImageRegistryPasswordType(with_metaclass(_CaseInsensitiveEnumMeta, str, Enum)):
    """The type of the image registry password being given in password
    """

    #: The image registry password in clear text, will not be processed in any way and used directly.
    CLEAR_TEXT = "ClearText"
    #: The URI to a KeyVault secret version, will be resolved using the application's managed identity
    #: (this type is only valid if the app was assigned a managed identity) before getting used.
    KEY_VAULT_REFERENCE = "KeyVaultReference"
    #: The reference to a SecretValue resource, will be resolved before getting used.
    SECRET_VALUE_REFERENCE = "SecretValueReference"

class ImpactLevel(with_metaclass(_CaseInsensitiveEnumMeta, str, Enum)):
    """The level of impact expected.
    """

    INVALID = "Invalid"
    NONE = "None"
    RESTART = "Restart"
    REMOVE_DATA = "RemoveData"
    REMOVE_NODE = "RemoveNode"

class ManagedIdentityType(with_metaclass(_CaseInsensitiveEnumMeta, str, Enum)):
    """The type of managed identity to be used to connect to Azure Blob Store via Managed Identity.
    """

    #: Indicates an invalid managed identity type. All Service Fabric enumerations have the invalid
    #: type.
    INVALID = "Invalid"
    #: Indicates VMSS managed identity should be used to connect to Azure blob store.
    VMSS = "VMSS"
    #: Indicates cluster managed identity should be used to connect to Azure blob store.
    CLUSTER = "Cluster"

class MoveCost(with_metaclass(_CaseInsensitiveEnumMeta, str, Enum)):
    """Specifies the move cost for the service.
    """

    #: Zero move cost. This value is zero.
    ZERO = "Zero"
    #: Specifies the move cost of the service as Low. The value is 1.
    LOW = "Low"
    #: Specifies the move cost of the service as Medium. The value is 2.
    MEDIUM = "Medium"
    #: Specifies the move cost of the service as High. The value is 3.
    HIGH = "High"
    #: Specifies the move cost of the service as VeryHigh. The value is 4.
    VERY_HIGH = "VeryHigh"

class NetworkKind(with_metaclass(_CaseInsensitiveEnumMeta, str, Enum)):
    """The type of a Service Fabric container network.
    """

    #: Indicates a container network local to a single Service Fabric cluster. The value is 1.
    LOCAL = "Local"

class NodeDeactivationIntent(with_metaclass(_CaseInsensitiveEnumMeta, str, Enum)):
    """The intent or the reason for deactivating the node. Following are the possible values for it.
    """

    #: Indicates the node deactivation intent is invalid. All Service Fabric enumerations have the
    #: invalid type. The value is zero. This value is not used.
    INVALID = "Invalid"
    #: Indicates that the node should be paused. The value is 1.
    PAUSE = "Pause"
    #: Indicates that the intent is for the node to be restarted after a short period of time. Service
    #: Fabric does not restart the node, this action is done outside of Service Fabric. The value is
    #: 2.
    RESTART = "Restart"
    #: Indicates that the intent is to reimage the node. Service Fabric does not reimage the node,
    #: this action is done outside of Service Fabric. The value is 3.
    REMOVE_DATA = "RemoveData"
    #: Indicates that the node is being decommissioned and is not expected to return. Service Fabric
    #: does not decommission the node, this action is done outside of Service Fabric. The value is 4.
    REMOVE_NODE = "RemoveNode"

class NodeDeactivationStatus(with_metaclass(_CaseInsensitiveEnumMeta, str, Enum)):
    """The status of node deactivation operation. Following are the possible values.
    """

    #: No status is associated with the task. The value is zero.
    NONE = "None"
    #: When a node is deactivated Service Fabric performs checks to ensure that the operation is safe
    #: to proceed to ensure availability of the service and reliability of the state. This value
    #: indicates that one or more safety checks are in progress. The value is 1.
    SAFETY_CHECK_IN_PROGRESS = "SafetyCheckInProgress"
    #: When a node is deactivated Service Fabric performs checks to ensure that the operation is safe
    #: to proceed to ensure availability of the service and reliability of the state. This value
    #: indicates that all safety checks have been completed. The value is 2.
    SAFETY_CHECK_COMPLETE = "SafetyCheckComplete"
    #: The task is completed. The value is 3.
    COMPLETED = "Completed"

class NodeDeactivationTaskType(with_metaclass(_CaseInsensitiveEnumMeta, str, Enum)):
    """The type of the task that performed the node deactivation. Following are the possible values.
    """

    #: Indicates the node deactivation task type is invalid. All Service Fabric enumerations have the
    #: invalid type. The value is zero. This value is not used.
    INVALID = "Invalid"
    #: Specifies the task created by Infrastructure hosting the nodes. The value is 1.
    INFRASTRUCTURE = "Infrastructure"
    #: Specifies the task that was created by the Repair Manager service. The value is 2.
    REPAIR = "Repair"
    #: Specifies that the task was created by using the public API. The value is 3.
    CLIENT = "Client"

class NodeStatus(with_metaclass(_CaseInsensitiveEnumMeta, str, Enum)):
    """The status of the node.
    """

    #: Indicates the node status is invalid. All Service Fabric enumerations have the invalid type.
    #: The value is zero.
    INVALID = "Invalid"
    #: Indicates the node is up. The value is 1.
    UP = "Up"
    #: Indicates the node is down. The value is 2.
    DOWN = "Down"
    #: Indicates the node is in process of being enabled. The value is 3.
    ENABLING = "Enabling"
    #: Indicates the node is in the process of being disabled. The value is 4.
    DISABLING = "Disabling"
    #: Indicates the node is disabled. The value is 5.
    DISABLED = "Disabled"
    #: Indicates the node is unknown. A node would be in Unknown state if Service Fabric does not have
    #: authoritative information about that node. This can happen if the system learns about a node at
    #: runtime.The value is 6.
    UNKNOWN = "Unknown"
    #: Indicates the node is removed. A node would be in Removed state if NodeStateRemoved API has
    #: been called for this node. In other words, Service Fabric has been informed that the persisted
    #: state on the node has been permanently lost. The value is 7.
    REMOVED = "Removed"

class NodeStatusFilter(with_metaclass(_CaseInsensitiveEnumMeta, str, Enum)):

    #: This filter value will match all of the nodes excepts the ones with status as Unknown or
    #: Removed.
    DEFAULT = "default"
    #: This filter value will match all of the nodes.
    ALL = "all"
    #: This filter value will match nodes that are Up.
    UP = "up"
    #: This filter value will match nodes that are Down.
    DOWN = "down"
    #: This filter value will match nodes that are in the process of being enabled with status as
    #: Enabling.
    ENABLING = "enabling"
    #: This filter value will match nodes that are in the process of being disabled with status as
    #: Disabling.
    DISABLING = "disabling"
    #: This filter value will match nodes that are Disabled.
    DISABLED = "disabled"
    #: This filter value will match nodes whose status is Unknown. A node would be in Unknown state if
    #: Service Fabric does not have authoritative information about that node. This can happen if the
    #: system learns about a node at runtime.
    UNKNOWN = "unknown"
    #: This filter value will match nodes whose status is Removed. These are the nodes that are
    #: removed from the cluster using the RemoveNodeState API.
    REMOVED = "removed"

class NodeTransitionType(with_metaclass(_CaseInsensitiveEnumMeta, str, Enum)):

    #: Reserved.  Do not pass into API.
    INVALID = "Invalid"
    #: Transition a stopped node to up.
    START = "Start"
    #: Transition an up node to stopped.
    STOP = "Stop"

class NodeUpgradePhase(with_metaclass(_CaseInsensitiveEnumMeta, str, Enum)):
    """The state of the upgrading node.
    """

    #: Indicates the upgrade state is invalid. All Service Fabric enumerations have the invalid type.
    #: The value is zero.
    INVALID = "Invalid"
    #: The upgrade has not started yet due to pending safety checks. The value is 1.
    PRE_UPGRADE_SAFETY_CHECK = "PreUpgradeSafetyCheck"
    #: The upgrade is in progress. The value is 2.
    UPGRADING = "Upgrading"
    #: The upgrade has completed and post upgrade safety checks are being performed. The value is 3.
    POST_UPGRADE_SAFETY_CHECK = "PostUpgradeSafetyCheck"

class OperatingSystemType(with_metaclass(_CaseInsensitiveEnumMeta, str, Enum)):
    """The operation system required by the code in service.
    """

    #: The required operating system is Linux.
    LINUX = "Linux"
    #: The required operating system is Windows.
    WINDOWS = "Windows"

class OperationState(with_metaclass(_CaseInsensitiveEnumMeta, str, Enum)):
    """The state of the operation.
    """

    #: The operation state is invalid.
    INVALID = "Invalid"
    #: The operation is in progress.
    RUNNING = "Running"
    #: The operation is rolling back internal system state because it encountered a fatal error or was
    #: cancelled by the user.  "RollingBack"     does not refer to user state.  For example, if
    #: CancelOperation is called on a command of type PartitionDataLoss, state of "RollingBack" does
    #: not mean service data is being restored (assuming the command has progressed far enough to
    #: cause data loss). It means the system is rolling back/cleaning up internal system state
    #: associated with the command.
    ROLLING_BACK = "RollingBack"
    #: The operation has completed successfully and is no longer running.
    COMPLETED = "Completed"
    #: The operation has failed and is no longer running.
    FAULTED = "Faulted"
    #: The operation was cancelled by the user using CancelOperation, and is no longer running.
    CANCELLED = "Cancelled"
    #: The operation was cancelled by the user using CancelOperation, with the force parameter set to
    #: true.  It is no longer running.  Refer to CancelOperation for more details.
    FORCE_CANCELLED = "ForceCancelled"

class OperationType(with_metaclass(_CaseInsensitiveEnumMeta, str, Enum)):
    """The type of the operation.
    """

    #: The operation state is invalid.
    INVALID = "Invalid"
    #: An operation started using the StartDataLoss API.
    PARTITION_DATA_LOSS = "PartitionDataLoss"
    #: An operation started using the StartQuorumLoss API.
    PARTITION_QUORUM_LOSS = "PartitionQuorumLoss"
    #: An operation started using the StartPartitionRestart API.
    PARTITION_RESTART = "PartitionRestart"
    #: An operation started using the StartNodeTransition API.
    NODE_TRANSITION = "NodeTransition"

class Ordering(with_metaclass(_CaseInsensitiveEnumMeta, str, Enum)):
    """Defines the order.
    """

    #: Descending sort order.
    DESC = "Desc"
    #: Ascending sort order.
    ASC = "Asc"

class PackageSharingPolicyScope(with_metaclass(_CaseInsensitiveEnumMeta, str, Enum)):
    """Represents the scope for PackageSharingPolicy. This is specified during
    DeployServicePackageToNode operation.
    """

    #: No package sharing policy scope. The value is 0.
    NONE = "None"
    #: Share all code, config and data packages from corresponding service manifest. The value is 1.
    ALL = "All"
    #: Share all code packages from corresponding service manifest. The value is 2.
    CODE = "Code"
    #: Share all config packages from corresponding service manifest. The value is 3.
    CONFIG = "Config"
    #: Share all data packages from corresponding service manifest. The value is 4.
    DATA = "Data"

class PartitionAccessStatus(with_metaclass(_CaseInsensitiveEnumMeta, str, Enum)):
    """Specifies the access status of the partition.
    """

    #: Indicates that the read or write operation access status is not valid. This value is not
    #: returned to the caller.
    INVALID = "Invalid"
    #: Indicates that the read or write operation access is granted and the operation is allowed.
    GRANTED = "Granted"
    #: Indicates that the client should try again later, because a reconfiguration is in progress.
    RECONFIGURATION_PENDING = "ReconfigurationPending"
    #: Indicates that this client request was received by a replica that is not a Primary replica.
    NOT_PRIMARY = "NotPrimary"
    #: Indicates that no write quorum is available and, therefore, no write operation can be accepted.
    NO_WRITE_QUORUM = "NoWriteQuorum"

class PartitionScheme(with_metaclass(_CaseInsensitiveEnumMeta, str, Enum)):
    """Enumerates the ways that a service can be partitioned.
    """

    #: Indicates the partition kind is invalid. All Service Fabric enumerations have the invalid type.
    #: The value is zero.
    INVALID = "Invalid"
    #: Indicates that the partition is based on string names, and is a
    #: SingletonPartitionSchemeDescription object, The value is 1.
    SINGLETON = "Singleton"
    #: Indicates that the partition is based on Int64 key ranges, and is a
    #: UniformInt64RangePartitionSchemeDescription object. The value is 2.
    UNIFORM_INT64_RANGE = "UniformInt64Range"
    #: Indicates that the partition is based on string names, and is a NamedPartitionSchemeDescription
    #: object. The value is 3.
    NAMED = "Named"

class PathMatchType(with_metaclass(_CaseInsensitiveEnumMeta, str, Enum)):
    """how to match value in the Uri
    """

    PREFIX = "prefix"

class PropertyBatchInfoKind(with_metaclass(_CaseInsensitiveEnumMeta, str, Enum)):
    """The kind of property batch info, determined by the results of a property batch. The following
    are the possible values.
    """

    #: Indicates the property batch info is invalid. All Service Fabric enumerations have the invalid
    #: type.
    INVALID = "Invalid"
    #: The property batch succeeded.
    SUCCESSFUL = "Successful"
    #: The property batch failed.
    FAILED = "Failed"

class PropertyBatchOperationKind(with_metaclass(_CaseInsensitiveEnumMeta, str, Enum)):
    """The kind of property batch operation, determined by the operation to be performed. The
    following are the possible values.
    """

    #: Indicates the property operation is invalid. All Service Fabric enumerations have the invalid
    #: type. The value is zero.
    INVALID = "Invalid"
    #: The operation will create or edit a property. The value is 1.
    PUT = "Put"
    #: The operation will get a property. The value is 2.
    GET = "Get"
    #: The operation will check that a property exists or doesn't exists, depending on the provided
    #: value. The value is 3.
    CHECK_EXISTS = "CheckExists"
    #: The operation will ensure that the sequence number is equal to the provided value. The value is
    #: 4.
    CHECK_SEQUENCE = "CheckSequence"
    #: The operation will delete a property. The value is 5.
    DELETE = "Delete"
    #: The operation will ensure that the value of a property is equal to the provided value. The
    #: value is 7.
    CHECK_VALUE = "CheckValue"

class PropertyValueKind(with_metaclass(_CaseInsensitiveEnumMeta, str, Enum)):
    """The kind of property, determined by the type of data. Following are the possible values.
    """

    #: Indicates the property is invalid. All Service Fabric enumerations have the invalid type. The
    #: value is zero.
    INVALID = "Invalid"
    #: The data inside the property is a binary blob. The value is 1.
    BINARY = "Binary"
    #: The data inside the property is an int64. The value is 2.
    INT64 = "Int64"
    #: The data inside the property is a double. The value is 3.
    DOUBLE = "Double"
    #: The data inside the property is a string. The value is 4.
    STRING = "String"
    #: The data inside the property is a guid. The value is 5.
    GUID = "Guid"

class ProvisionApplicationTypeKind(with_metaclass(_CaseInsensitiveEnumMeta, str, Enum)):
    """The kind of application type registration or provision requested. The application package can
    be registered or provisioned either from the image store or from an external store. Following
    are the kinds of the application type provision.
    """

    #: Indicates that the provision kind is invalid. This value is default and should not be used. The
    #: value is zero.
    INVALID = "Invalid"
    #: Indicates that the provision is for a package that was previously uploaded to the image store.
    #: The value is 1.
    IMAGE_STORE_PATH = "ImageStorePath"
    #: Indicates that the provision is for an application package that was previously uploaded to an
    #: external store. The application package ends with the extension *.sfpkg. The value is 2.
    EXTERNAL_STORE = "ExternalStore"

class QuorumLossMode(with_metaclass(_CaseInsensitiveEnumMeta, str, Enum)):

    #: Reserved.  Do not pass into API.
    INVALID = "Invalid"
    #: Partial Quorum loss mode : Minimum number of replicas for a partition will be down that will
    #: cause a quorum loss.
    QUORUM_REPLICAS = "QuorumReplicas"
    ALL_REPLICAS = "AllReplicas"

class ReconfigurationPhase(with_metaclass(_CaseInsensitiveEnumMeta, str, Enum)):
    """The reconfiguration phase of a replica of a stateful service.
    """

    #: Indicates the invalid reconfiguration phase.
    UNKNOWN = "Unknown"
    #: Specifies that there is no reconfiguration in progress.
    NONE = "None"
    #: Refers to the phase where the reconfiguration is transferring data from the previous primary to
    #: the new primary.
    PHASE0 = "Phase0"
    #: Refers to the phase where the reconfiguration is querying the replica set for the progress.
    PHASE1 = "Phase1"
    #: Refers to the phase where the reconfiguration is ensuring that data from the current primary is
    #: present in a majority of the replica set.
    PHASE2 = "Phase2"
    #: This phase is for internal use only.
    PHASE3 = "Phase3"
    #: This phase is for internal use only.
    PHASE4 = "Phase4"
    #: This phase is for internal use only.
    ABORT_PHASE_ZERO = "AbortPhaseZero"

class ReconfigurationType(with_metaclass(_CaseInsensitiveEnumMeta, str, Enum)):
    """The type of reconfiguration for replica of a stateful service.
    """

    #: Indicates the invalid reconfiguration type.
    UNKNOWN = "Unknown"
    #: Specifies that the primary replica is being swapped with a different replica.
    SWAP_PRIMARY = "SwapPrimary"
    #: Reconfiguration triggered in response to a primary going down. This could be due to many
    #: reasons such as primary replica crashing etc.
    FAILOVER = "Failover"
    #: Reconfigurations where the primary replica is not changing.
    OTHER = "Other"

class RepairImpactKind(with_metaclass(_CaseInsensitiveEnumMeta, str, Enum)):
    """Specifies the kind of the impact. This type supports the Service Fabric platform; it is not
    meant to be used directly from your code.'
    """

    #: The repair impact is not valid or is of an unknown type.
    INVALID = "Invalid"
    #: The repair impact affects a set of Service Fabric nodes.
    NODE = "Node"

class RepairTargetKind(with_metaclass(_CaseInsensitiveEnumMeta, str, Enum)):
    """Specifies the kind of the repair target. This type supports the Service Fabric platform; it is
    not meant to be used directly from your code.'
    """

    #: The repair target is not valid or is of an unknown type.
    INVALID = "Invalid"
    #: The repair target is a set of Service Fabric nodes.
    NODE = "Node"

class RepairTaskHealthCheckState(with_metaclass(_CaseInsensitiveEnumMeta, str, Enum)):
    """Specifies the workflow state of a repair task's health check. This type supports the Service
    Fabric platform; it is not meant to be used directly from your code.
    """

    #: Indicates that the health check has not started.
    NOT_STARTED = "NotStarted"
    #: Indicates that the health check is in progress.
    IN_PROGRESS = "InProgress"
    #: Indicates that the health check succeeded.
    SUCCEEDED = "Succeeded"
    #: Indicates that the health check was skipped.
    SKIPPED = "Skipped"
    #: Indicates that the health check timed out.
    TIMED_OUT = "TimedOut"

class ReplicaHealthReportServiceKind(with_metaclass(_CaseInsensitiveEnumMeta, str, Enum)):

    #: Does not use Service Fabric to make its state highly available or reliable. The value is 1.
    STATELESS = "Stateless"
    #: Uses Service Fabric to make its state or part of its state highly available and reliable. The
    #: value is 2.
    STATEFUL = "Stateful"

class ReplicaKind(with_metaclass(_CaseInsensitiveEnumMeta, str, Enum)):
    """The role of a replica of a stateful service.
    """

    #: Represents an invalid replica kind. The value is zero.
    INVALID = "Invalid"
    #: Represents a key value store replica. The value is 1.
    KEY_VALUE_STORE = "KeyValueStore"

class ReplicaRole(with_metaclass(_CaseInsensitiveEnumMeta, str, Enum)):
    """The role of a replica of a stateful service.
    """

    #: Indicates the initial role that a replica is created in. The value is zero.
    UNKNOWN = "Unknown"
    #: Specifies that the replica has no responsibility in regard to the replica set. The value is 1.
    NONE = "None"
    #: Refers to the replica in the set on which all read and write operations are complete in order
    #: to enforce strong consistency semantics. Read operations are handled directly by the Primary
    #: replica, while write operations must be acknowledged by a quorum of the replicas in the replica
    #: set. There can only be one Primary replica in a replica set at a time. The value is 2.
    PRIMARY = "Primary"
    #: Refers to a replica in the set that receives a state transfer from the Primary replica to
    #: prepare for becoming an active Secondary replica. There can be multiple Idle Secondary replicas
    #: in a replica set at a time. Idle Secondary replicas do not count as a part of a write quorum.
    #: The value is 3.
    IDLE_SECONDARY = "IdleSecondary"
    #: Refers to a replica in the set that receives state updates from the Primary replica, applies
    #: them, and sends acknowledgements back. Secondary replicas must participate in the write quorum
    #: for a replica set. There can be multiple active Secondary replicas in a replica set at a time.
    #: The number of active Secondary replicas is configurable that the reliability subsystem should
    #: maintain. The value is 4.
    ACTIVE_SECONDARY = "ActiveSecondary"

class ReplicaStatus(with_metaclass(_CaseInsensitiveEnumMeta, str, Enum)):
    """The status of a replica of a service.
    """

    #: Indicates the replica status is invalid. All Service Fabric enumerations have the invalid type.
    #: The value is zero.
    INVALID = "Invalid"
    #: The replica is being built. This means that a primary replica is seeding this replica. The
    #: value is 1.
    IN_BUILD = "InBuild"
    #: The replica is in standby. The value is 2.
    STANDBY = "Standby"
    #: The replica is ready. The value is 3.
    READY = "Ready"
    #: The replica is down. The value is 4.
    DOWN = "Down"
    #: Replica is dropped. This means that the replica has been removed from the replica set. If it is
    #: persisted, its state has been deleted. The value is 5.
    DROPPED = "Dropped"

class ReplicatorOperationName(with_metaclass(_CaseInsensitiveEnumMeta, str, Enum)):
    """Specifies the operation currently being executed by the Replicator.
    """

    #: Default value if the replicator is not yet ready.
    INVALID = "Invalid"
    #: Replicator is not running any operation from Service Fabric perspective.
    NONE = "None"
    #: Replicator is opening.
    OPEN = "Open"
    #: Replicator is in the process of changing its role.
    CHANGE_ROLE = "ChangeRole"
    #: Due to a change in the replica set, replicator is being updated with its Epoch.
    UPDATE_EPOCH = "UpdateEpoch"
    #: Replicator is closing.
    CLOSE = "Close"
    #: Replicator is being aborted.
    ABORT = "Abort"
    #: Replicator is handling the data loss condition, where the user service may potentially be
    #: recovering state from an external source.
    ON_DATA_LOSS = "OnDataLoss"
    #: Replicator is waiting for a quorum of replicas to be caught up to the latest state.
    WAIT_FOR_CATCHUP = "WaitForCatchup"
    #: Replicator is in the process of building one or more replicas.
    BUILD = "Build"

class ResourceStatus(with_metaclass(_CaseInsensitiveEnumMeta, str, Enum)):
    """Status of the resource.
    """

    #: Indicates the resource status is unknown. The value is zero.
    UNKNOWN = "Unknown"
    #: Indicates the resource is ready. The value is 1.
    READY = "Ready"
    #: Indicates the resource is upgrading. The value is 2.
    UPGRADING = "Upgrading"
    #: Indicates the resource is being created. The value is 3.
    CREATING = "Creating"
    #: Indicates the resource is being deleted. The value is 4.
    DELETING = "Deleting"
    #: Indicates the resource is not functional due to persistent failures. See statusDetails property
    #: for more details. The value is 5.
    FAILED = "Failed"

class RestartPartitionMode(with_metaclass(_CaseInsensitiveEnumMeta, str, Enum)):

    #: Reserved.  Do not pass into API.
    INVALID = "Invalid"
    #: All replicas or instances in the partition are restarted at once.
    ALL_REPLICAS_OR_INSTANCES = "AllReplicasOrInstances"
    #: Only the secondary replicas are restarted.
    ONLY_ACTIVE_SECONDARIES = "OnlyActiveSecondaries"

class RestartPolicy(with_metaclass(_CaseInsensitiveEnumMeta, str, Enum)):
    """Enumerates the restart policy for RunToCompletionExecutionPolicy
    """

    #: Service will be restarted when it encounters a failure.
    ON_FAILURE = "OnFailure"
    #: Service will never be restarted. If the service encounters a failure, it will move to Failed
    #: state.
    NEVER = "Never"

class RestoreState(with_metaclass(_CaseInsensitiveEnumMeta, str, Enum)):
    """Represents the current state of the partition restore operation.
    """

    #: Indicates an invalid restore state. All Service Fabric enumerations have the invalid type.
    INVALID = "Invalid"
    #: Operation has been validated and accepted. Restore is yet to be triggered.
    ACCEPTED = "Accepted"
    #: Restore operation has been triggered and is under process.
    RESTORE_IN_PROGRESS = "RestoreInProgress"
    #: Operation completed with success.
    SUCCESS = "Success"
    #: Operation completed with failure.
    FAILURE = "Failure"
    #: Operation timed out.
    TIMEOUT = "Timeout"

class ResultStatus(with_metaclass(_CaseInsensitiveEnumMeta, str, Enum)):
    """A value describing the overall result of the repair task execution. Must be specified in the
    Restoring and later states, and is immutable once set.
    """

    #: Indicates that the repair task result is invalid. All Service Fabric enumerations have the
    #: invalid value.
    INVALID = "Invalid"
    #: Indicates that the repair task completed execution successfully.
    SUCCEEDED = "Succeeded"
    #: Indicates that the repair task was cancelled prior to execution.
    CANCELLED = "Cancelled"
    #: Indicates that execution of the repair task was interrupted by a cancellation request after
    #: some work had already been performed.
    INTERRUPTED = "Interrupted"
    #: Indicates that there was a failure during execution of the repair task. Some work may have been
    #: performed.
    FAILED = "Failed"
    #: Indicates that the repair task result is not yet available, because the repair task has not
    #: finished executing.
    PENDING = "Pending"

class RetentionPolicyType(with_metaclass(_CaseInsensitiveEnumMeta, str, Enum)):
    """The type of retention policy. Currently only "Basic" retention policy is supported.
    """

    #: Indicates a basic retention policy type.
    BASIC = "Basic"
    #: Indicates an invalid retention policy type.
    INVALID = "Invalid"

class RollingUpgradeMode(with_metaclass(_CaseInsensitiveEnumMeta, str, Enum)):
    """The mode used to monitor health during a rolling upgrade. The values are UnmonitoredAuto,
    UnmonitoredManual, and Monitored.
    """

    #: Indicates the upgrade mode is invalid. All Service Fabric enumerations have the invalid type.
    #: The value is zero.
    INVALID = "Invalid"
    #: The upgrade will proceed automatically without performing any health monitoring. The value is
    #: 1.
    UNMONITORED_AUTO = "UnmonitoredAuto"
    #: The upgrade will stop after completing each upgrade domain, giving the opportunity to manually
    #: monitor health before proceeding. The value is 2.
    UNMONITORED_MANUAL = "UnmonitoredManual"
    #: The upgrade will stop after completing each upgrade domain and automatically monitor health
    #: before proceeding. The value is 3.
    MONITORED = "Monitored"

class SafetyCheckKind(with_metaclass(_CaseInsensitiveEnumMeta, str, Enum)):
    """The kind of safety check performed by service fabric before continuing with the operations.
    These checks ensure the availability of the service and the reliability of the state. Following
    are the kinds of safety checks.
    """

    #: Indicates that the upgrade safety check kind is invalid. All Service Fabric enumerations have
    #: the invalid type. The value is zero.
    INVALID = "Invalid"
    #: Indicates that if we bring down the node then this will result in global seed node quorum loss.
    #: The value is 1.
    ENSURE_SEED_NODE_QUORUM = "EnsureSeedNodeQuorum"
    #: Indicates that there is some partition for which if we bring down the replica on the node, it
    #: will result in quorum loss for that partition. The value is 2.
    ENSURE_PARTITION_QUORUM = "EnsurePartitionQuorum"
    #: Indicates that there is some replica on the node that was moved out of this node due to
    #: upgrade. Service Fabric is now waiting for the primary to be moved back to this node. The value
    #: is 3.
    WAIT_FOR_PRIMARY_PLACEMENT = "WaitForPrimaryPlacement"
    #: Indicates that Service Fabric is waiting for a primary replica to be moved out of the node
    #: before starting upgrade on that node. The value is 4.
    WAIT_FOR_PRIMARY_SWAP = "WaitForPrimarySwap"
    #: Indicates that there is some replica on the node that is involved in a reconfiguration. Service
    #: Fabric is waiting for the reconfiguration to be complete before staring upgrade on that node.
    #: The value is 5.
    WAIT_FOR_RECONFIGURATION = "WaitForReconfiguration"
    #: Indicates that there is either a replica on the node that is going through copy, or there is a
    #: primary replica on the node that is copying data to some other replica. In both cases, bringing
    #: down the replica on the node due to upgrade will abort the copy. The value is 6.
    WAIT_FOR_INBUILD_REPLICA = "WaitForInbuildReplica"
    #: Indicates that there is either a stateless service partition on the node having exactly one
    #: instance, or there is a primary replica on the node for which the partition is quorum loss. In
    #: both cases, bringing down the replicas due to upgrade will result in loss of availability. The
    #: value is 7.
    ENSURE_AVAILABILITY = "EnsureAvailability"

class ScalingMechanismKind(with_metaclass(_CaseInsensitiveEnumMeta, str, Enum)):
    """Enumerates the ways that a service can be scaled.
    """

    #: Indicates the scaling mechanism is invalid. All Service Fabric enumerations have the invalid
    #: type. The value is zero.
    INVALID = "Invalid"
    #: Indicates a mechanism for scaling where new instances are added or removed from a partition.
    #: The value is 1.
    PARTITION_INSTANCE_COUNT = "PartitionInstanceCount"
    #: Indicates a mechanism for scaling where new named partitions are added or removed from a
    #: service. The value is 2.
    ADD_REMOVE_INCREMENTAL_NAMED_PARTITION = "AddRemoveIncrementalNamedPartition"

class ScalingTriggerKind(with_metaclass(_CaseInsensitiveEnumMeta, str, Enum)):
    """Enumerates the ways that a service can be scaled.
    """

    #: Indicates the scaling trigger is invalid. All Service Fabric enumerations have the invalid
    #: type. The value is zero.
    INVALID = "Invalid"
    #: Indicates a trigger where scaling decisions are made based on average load of a partition. The
    #: value is 1.
    AVERAGE_PARTITION_LOAD = "AveragePartitionLoad"
    #: Indicates a trigger where scaling decisions are made based on average load of a service. The
    #: value is 2.
    AVERAGE_SERVICE_LOAD = "AverageServiceLoad"

class Scheme(with_metaclass(_CaseInsensitiveEnumMeta, str, Enum)):
    """Scheme for the http probe. Can be Http or Https.
    """

    #: Indicates that the probe is http.
    HTTP = "http"
    #: Indicates that the probe is https. No cert validation.
    HTTPS = "https"

class SecretKind(with_metaclass(_CaseInsensitiveEnumMeta, str, Enum)):
    """Describes the kind of secret.
    """

    #: A simple secret resource whose plaintext value is provided by the user.
    INLINED_VALUE = "inlinedValue"
    #: A secret resource that references a specific version of a secret stored in Azure Key Vault; the
    #: expected value is a versioned KeyVault URI corresponding to the version of the secret being
    #: referenced.
    KEY_VAULT_VERSIONED_REFERENCE = "keyVaultVersionedReference"

class ServiceCorrelationScheme(with_metaclass(_CaseInsensitiveEnumMeta, str, Enum)):
    """The service correlation scheme.
    """

    #: An invalid correlation scheme. Cannot be used. The value is zero.
    INVALID = "Invalid"
    #: Indicates that this service has an affinity relationship with another service. Provided for
    #: backwards compatibility, consider preferring the Aligned or NonAlignedAffinity options. The
    #: value is 1.
    AFFINITY = "Affinity"
    #: Aligned affinity ensures that the primaries of the partitions of the affinitized services are
    #: collocated on the same nodes. This is the default and is the same as selecting the Affinity
    #: scheme. The value is 2.
    ALIGNED_AFFINITY = "AlignedAffinity"
    #: Non-Aligned affinity guarantees that all replicas of each service will be placed on the same
    #: nodes. Unlike Aligned Affinity, this does not guarantee that replicas of particular role will
    #: be collocated. The value is 3.
    NON_ALIGNED_AFFINITY = "NonAlignedAffinity"

class ServiceEndpointRole(with_metaclass(_CaseInsensitiveEnumMeta, str, Enum)):
    """The role of the replica where the endpoint is reported.
    """

    #: Indicates the service endpoint role is invalid. All Service Fabric enumerations have the
    #: invalid type. The value is zero.
    INVALID = "Invalid"
    #: Indicates that the service endpoint is of a stateless service. The value is 1.
    STATELESS = "Stateless"
    #: Indicates that the service endpoint is of a primary replica of a stateful service. The value is
    #: 2.
    STATEFUL_PRIMARY = "StatefulPrimary"
    #: Indicates that the service endpoint is of a secondary replica of a stateful service. The value
    #: is 3.
    STATEFUL_SECONDARY = "StatefulSecondary"

class ServiceKind(with_metaclass(_CaseInsensitiveEnumMeta, str, Enum)):
    """The kind of service (Stateless or Stateful).
    """

    #: Indicates the service kind is invalid. All Service Fabric enumerations have the invalid type.
    #: The value is zero.
    INVALID = "Invalid"
    #: Does not use Service Fabric to make its state highly available or reliable. The value is 1.
    STATELESS = "Stateless"
    #: Uses Service Fabric to make its state or part of its state highly available and reliable. The
    #: value is 2.
    STATEFUL = "Stateful"

class ServiceLoadMetricWeight(with_metaclass(_CaseInsensitiveEnumMeta, str, Enum)):
    """Determines the metric weight relative to the other metrics that are configured for this
    service. During runtime, if two metrics end up in conflict, the Cluster Resource Manager
    prefers the metric with the higher weight.
    """

    #: Disables resource balancing for this metric. This value is zero.
    ZERO = "Zero"
    #: Specifies the metric weight of the service load as Low. The value is 1.
    LOW = "Low"
    #: Specifies the metric weight of the service load as Medium. The value is 2.
    MEDIUM = "Medium"
    #: Specifies the metric weight of the service load as High. The value is 3.
    HIGH = "High"

class ServiceOperationName(with_metaclass(_CaseInsensitiveEnumMeta, str, Enum)):
    """Specifies the current active life-cycle operation on a stateful service replica or stateless
    service instance.
    """

    #: Reserved for future use.
    UNKNOWN = "Unknown"
    #: The service replica or instance is not going through any life-cycle changes.
    NONE = "None"
    #: The service replica or instance is being opened.
    OPEN = "Open"
    #: The service replica is changing roles.
    CHANGE_ROLE = "ChangeRole"
    #: The service replica or instance is being closed.
    CLOSE = "Close"
    #: The service replica or instance is being aborted.
    ABORT = "Abort"

class ServicePackageActivationMode(with_metaclass(_CaseInsensitiveEnumMeta, str, Enum)):
    """The activation mode of service package to be used for a Service Fabric service. This is
    specified at the time of creating the Service.
    """

    #: This is the default activation mode. With this activation mode, replicas or instances from
    #: different partition(s) of service, on a given node, will share same activation of service
    #: package on a node. The value is zero.
    SHARED_PROCESS = "SharedProcess"
    #: With this activation mode, each replica or instance of service, on a given node, will have its
    #: own dedicated activation of service package on a node. The value is 1.
    EXCLUSIVE_PROCESS = "ExclusiveProcess"

class ServicePartitionKind(with_metaclass(_CaseInsensitiveEnumMeta, str, Enum)):
    """The kind of partitioning scheme used to partition the service.
    """

    #: Indicates the partition kind is invalid. All Service Fabric enumerations have the invalid type.
    #: The value is zero.
    INVALID = "Invalid"
    #: Indicates that there is only one partition, and SingletonPartitionSchemeDescription was
    #: specified while creating the service. The value is 1.
    SINGLETON = "Singleton"
    #: Indicates that the partition is based on Int64 key ranges, and
    #: UniformInt64RangePartitionSchemeDescription was specified while creating the service. The value
    #: is 2.
    INT64_RANGE = "Int64Range"
    #: Indicates that the partition is based on string names, and NamedPartitionInformation  was
    #: specified while creating the service. The value is 3.
    NAMED = "Named"

class ServicePartitionStatus(with_metaclass(_CaseInsensitiveEnumMeta, str, Enum)):
    """The status of the service fabric service partition.
    """

    #: Indicates the partition status is invalid. All Service Fabric enumerations have the invalid
    #: type. The value is zero.
    INVALID = "Invalid"
    #: Indicates that the partition is ready. This means that for a stateless service partition there
    #: is at least one instance that is up and for a stateful service partition the number of ready
    #: replicas is greater than or equal to the MinReplicaSetSize. The value is 1.
    READY = "Ready"
    #: Indicates that the partition is not ready. This status is returned when none of the other
    #: states apply. The value is 2.
    NOT_READY = "NotReady"
    #: Indicates that the partition is in quorum loss. This means that number of replicas that are up
    #: and participating in a replica set is less than MinReplicaSetSize for this partition. The value
    #: is 3.
    IN_QUORUM_LOSS = "InQuorumLoss"
    #: Indicates that the partition is undergoing reconfiguration of its replica sets. This can happen
    #: due to failover, upgrade, load balancing or addition or removal of replicas from the replica
    #: set. The value is 4.
    RECONFIGURING = "Reconfiguring"
    #: Indicates that the partition is being deleted. The value is 5.
    DELETING = "Deleting"

class ServicePlacementPolicyType(with_metaclass(_CaseInsensitiveEnumMeta, str, Enum)):
    """The type of placement policy for a service fabric service. Following are the possible values.
    """

    #: Indicates the type of the placement policy is invalid. All Service Fabric enumerations have the
    #: invalid type. The value is zero.
    INVALID = "Invalid"
    #: Indicates that the ServicePlacementPolicyDescription is of type
    #: ServicePlacementInvalidDomainPolicyDescription, which indicates that a particular fault or
    #: upgrade domain cannot be used for placement of this service. The value is 1.
    INVALID_DOMAIN = "InvalidDomain"
    #: Indicates that the ServicePlacementPolicyDescription is of type
    #: ServicePlacementRequireDomainDistributionPolicyDescription indicating that the replicas of the
    #: service must be placed in a specific domain. The value is 2.
    REQUIRE_DOMAIN = "RequireDomain"
    #: Indicates that the ServicePlacementPolicyDescription is of type
    #: ServicePlacementPreferPrimaryDomainPolicyDescription, which indicates that if possible the
    #: Primary replica for the partitions of the service should be located in a particular domain as
    #: an optimization. The value is 3.
    PREFER_PRIMARY_DOMAIN = "PreferPrimaryDomain"
    #: Indicates that the ServicePlacementPolicyDescription is of type
    #: ServicePlacementRequireDomainDistributionPolicyDescription, indicating that the system will
    #: disallow placement of any two replicas from the same partition in the same domain at any time.
    #: The value is 4.
    REQUIRE_DOMAIN_DISTRIBUTION = "RequireDomainDistribution"
    #: Indicates that the ServicePlacementPolicyDescription is of type
    #: ServicePlacementNonPartiallyPlaceServicePolicyDescription, which indicates that if possible all
    #: replicas of a particular partition of the service should be placed atomically. The value is 5.
    NON_PARTIALLY_PLACE_SERVICE = "NonPartiallyPlaceService"
    #: Indicates that the ServicePlacementPolicyDescription is of type
    #: ServicePlacementAllowMultipleStatelessInstancesOnNodePolicyDescription, which indicates that
    #: multiple stateless instances of a particular partition of the service can be placed on a node.
    #: The value is 6.
    ALLOW_MULTIPLE_STATELESS_INSTANCES_ON_NODE = "AllowMultipleStatelessInstancesOnNode"

class ServiceStatus(with_metaclass(_CaseInsensitiveEnumMeta, str, Enum)):
    """The status of the application.
    """

    #: Indicates the service status is unknown. The value is zero.
    UNKNOWN = "Unknown"
    #: Indicates the service status is active. The value is 1.
    ACTIVE = "Active"
    #: Indicates the service is upgrading. The value is 2.
    UPGRADING = "Upgrading"
    #: Indicates the service is being deleted. The value is 3.
    DELETING = "Deleting"
    #: Indicates the service is being created. The value is 4.
    CREATING = "Creating"
    #: Indicates creation or deletion was terminated due to persistent failures. Another create/delete
    #: request can be accepted. The value is 5.
    FAILED = "Failed"

class ServiceTypeRegistrationStatus(with_metaclass(_CaseInsensitiveEnumMeta, str, Enum)):
    """The status of the service type registration on the node.
    """

    #: Indicates the registration status is invalid. All Service Fabric enumerations have the invalid
    #: type. The value is zero.
    INVALID = "Invalid"
    #: Indicates that the service type is disabled on this node. A type gets disabled when there are
    #: too many failures of the code package hosting the service type. If the service type is
    #: disabled, new replicas of that service type will not be placed on the node until it is enabled
    #: again. The service type is enabled again after the process hosting it comes up and re-registers
    #: the type or a preconfigured time interval has passed. The value is 1.
    DISABLED = "Disabled"
    #: Indicates that the service type is enabled on this node. Replicas of this service type can be
    #: placed on this node when the code package registers the service type. The value is 2.
    ENABLED = "Enabled"
    #: Indicates that the service type is enabled and registered on the node by a code package.
    #: Replicas of this service type can now be placed on this node. The value is 3.
    REGISTERED = "Registered"

class SettingType(with_metaclass(_CaseInsensitiveEnumMeta, str, Enum)):
    """The type of the setting being given in value
    """

    #: The setting in clear text, will not be processed in any way and passed in as is.
    CLEAR_TEXT = "ClearText"
    #: The URI to a KeyVault secret version, will be resolved using the application's managed identity
    #: (this type is only valid if the app was assigned a managed identity) before getting passed in.
    KEY_VAULT_REFERENCE = "KeyVaultReference"
    #: The reference to a SecretValue resource, will be resolved before getting passed in.
    SECRET_VALUE_REFERENCE = "SecretValueReference"

class SizeTypes(with_metaclass(_CaseInsensitiveEnumMeta, str, Enum)):
    """Volume size
    """

    SMALL = "Small"
    MEDIUM = "Medium"
    LARGE = "Large"

class State(with_metaclass(_CaseInsensitiveEnumMeta, str, Enum)):
    """The workflow state of the repair task. Valid initial states are Created, Claimed, and
    Preparing.
    """

    #: Indicates that the repair task state is invalid. All Service Fabric enumerations have the
    #: invalid value.
    INVALID = "Invalid"
    #: Indicates that the repair task has been created.
    CREATED = "Created"
    #: Indicates that the repair task has been claimed by a repair executor.
    CLAIMED = "Claimed"
    #: Indicates that the Repair Manager is preparing the system to handle the impact of the repair
    #: task, usually by taking resources offline gracefully.
    PREPARING = "Preparing"
    #: Indicates that the repair task has been approved by the Repair Manager and is safe to execute.
    APPROVED = "Approved"
    #: Indicates that execution of the repair task is in progress.
    EXECUTING = "Executing"
    #: Indicates that the Repair Manager is restoring the system to its pre-repair state, usually by
    #: bringing resources back online.
    RESTORING = "Restoring"
    #: Indicates that the repair task has completed, and no further state changes will occur.
    COMPLETED = "Completed"

class UpgradeDomainState(with_metaclass(_CaseInsensitiveEnumMeta, str, Enum)):
    """The state of the upgrade domain.
    """

    #: Indicates the upgrade domain state is invalid. All Service Fabric enumerations have the invalid
    #: type. The value is zero.
    INVALID = "Invalid"
    #: The upgrade domain has not started upgrading yet. The value is 1.
    PENDING = "Pending"
    #: The upgrade domain is being upgraded but not complete yet. The value is 2.
    IN_PROGRESS = "InProgress"
    #: The upgrade domain has completed upgrade. The value is 3.
    COMPLETED = "Completed"

class UpgradeKind(with_metaclass(_CaseInsensitiveEnumMeta, str, Enum)):
    """The kind of upgrade out of the following possible values.
    """

    #: Indicates the upgrade kind is invalid. All Service Fabric enumerations have the invalid type.
    #: The value is zero.
    INVALID = "Invalid"
    #: The upgrade progresses one upgrade domain at a time. The value is 1.
    ROLLING = "Rolling"

class UpgradeMode(with_metaclass(_CaseInsensitiveEnumMeta, str, Enum)):
    """The mode used to monitor health during a rolling upgrade. The values are UnmonitoredAuto,
    UnmonitoredManual, and Monitored.
    """

    #: Indicates the upgrade mode is invalid. All Service Fabric enumerations have the invalid type.
    #: The value is zero.
    INVALID = "Invalid"
    #: The upgrade will proceed automatically without performing any health monitoring. The value is
    #: 1.
    UNMONITORED_AUTO = "UnmonitoredAuto"
    #: The upgrade will stop after completing each upgrade domain, giving the opportunity to manually
    #: monitor health before proceeding. The value is 2.
    UNMONITORED_MANUAL = "UnmonitoredManual"
    #: The upgrade will stop after completing each upgrade domain and automatically monitor health
    #: before proceeding. The value is 3.
    MONITORED = "Monitored"

class UpgradeSortOrder(with_metaclass(_CaseInsensitiveEnumMeta, str, Enum)):
    """Defines the order in which an upgrade proceeds through the cluster.
    """

    #: Indicates that this sort order is not valid. All Service Fabric enumerations have the invalid
    #: type. The value is 0.
    INVALID = "Invalid"
    #: Indicates that the default sort order (as specified in cluster manifest) will be used. The
    #: value is 1.
    DEFAULT = "Default"
    #: Indicates that forward numeric sort order (UD names sorted as numbers) will be used. The value
    #: is 2.
    NUMERIC = "Numeric"
    #: Indicates that forward lexicographical sort order (UD names sorted as strings) will be used.
    #: The value is 3.
    LEXICOGRAPHICAL = "Lexicographical"
    #: Indicates that reverse numeric sort order (UD names sorted as numbers) will be used. The value
    #: is 4.
    REVERSE_NUMERIC = "ReverseNumeric"
    #: Indicates that reverse lexicographical sort order (UD names sorted as strings) will be used.
    #: The value is 5.
    REVERSE_LEXICOGRAPHICAL = "ReverseLexicographical"

class UpgradeState(with_metaclass(_CaseInsensitiveEnumMeta, str, Enum)):
    """The state of the upgrade domain.
    """

    #: Indicates the upgrade state is invalid. All Service Fabric enumerations have the invalid type.
    #: The value is zero.
    INVALID = "Invalid"
    #: The upgrade is rolling back to the previous version but is not complete yet. The value is 1.
    ROLLING_BACK_IN_PROGRESS = "RollingBackInProgress"
    #: The upgrade has finished rolling back. The value is 2.
    ROLLING_BACK_COMPLETED = "RollingBackCompleted"
    #: The current upgrade domain has finished upgrading. The overall upgrade is waiting for an
    #: explicit move next request in UnmonitoredManual mode or performing health checks in Monitored
    #: mode. The value is 3.
    ROLLING_FORWARD_PENDING = "RollingForwardPending"
    #: The upgrade is rolling forward to the target version but is not complete yet. The value is 4.
    ROLLING_FORWARD_IN_PROGRESS = "RollingForwardInProgress"
    #: The upgrade has finished rolling forward. The value is 5.
    ROLLING_FORWARD_COMPLETED = "RollingForwardCompleted"
    #: The upgrade has failed and is unable to execute FailureAction. The value is 6.
    FAILED = "Failed"

class UpgradeType(with_metaclass(_CaseInsensitiveEnumMeta, str, Enum)):
    """The type of upgrade out of the following possible values.
    """

    #: Indicates the upgrade kind is invalid. All Service Fabric enumerations have the invalid type.
    #: The value is zero.
    INVALID = "Invalid"
    #: The upgrade progresses one upgrade domain at a time. The value is 1.
    ROLLING = "Rolling"
    #: The upgrade gets restarted by force. The value is 2.
    ROLLING_FORCE_RESTART = "Rolling_ForceRestart"

class VolumeProvider(with_metaclass(_CaseInsensitiveEnumMeta, str, Enum)):
    """Describes the provider of the volume resource.
    """

    #: Provides volumes that are backed by Azure Files.
    SF_AZURE_FILE = "SFAzureFile"
