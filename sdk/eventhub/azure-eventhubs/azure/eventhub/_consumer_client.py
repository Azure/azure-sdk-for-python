# --------------------------------------------------------------------------------------------
# Copyright (c) Microsoft Corporation. All rights reserved.
# Licensed under the MIT License. See License.txt in the project root for license information.
# --------------------------------------------------------------------------------------------
import logging
from typing import Any, Union, TYPE_CHECKING
from ._common import EventHubSharedKeyCredential, EventHubSASTokenCredential
from ._eventprocessor.event_processor import EventProcessor
from ._client import EventHubClient
if TYPE_CHECKING:
    from azure.core.credentials import TokenCredential  # type: ignore

log = logging.getLogger(__name__)


class EventHubConsumerClient(EventHubClient):
    """ he EventHubProducerClient class defines a high level interface for
    receiving events from the Azure Event Hubs service.

    :param host: The hostname of the Event Hub.
    :type host: str
    :param event_hub_path: The path of the specific Event Hub to connect the client to.
    :type event_hub_path: str
    :param network_tracing: Whether to output network trace logs to the logger. Default
     is `False`.
    :type network_tracing: bool
    :param credential: The credential object used for authentication which implements particular interface
     of getting tokens. It accepts ~azure.eventhub.EventHubSharedKeyCredential,
     ~azure.eventhub.EventHubSASTokenCredential, credential objects generated by the azure-identity library and
     objects that implement get_token(self, *scopes) method.
    :param http_proxy: HTTP proxy settings. This must be a dictionary with the following
     keys: 'proxy_hostname' (str value) and 'proxy_port' (int value).
     Additionally the following keys may also be present: 'username', 'password'.
    :type http_proxy: dict[str, Any]
    :param auth_timeout: The time in seconds to wait for a token to be authorized by the service.
     The default value is 60 seconds. If set to 0, no timeout will be enforced from the client.
    :type auth_timeout: float
    :param user_agent: The user agent that needs to be appended to the built in user agent string.
    :type user_agent: str
    :param retry_total: The total number of attempts to redo the failed operation when an error happened. Default
     value is 3.
    :type retry_total: int
    :keyword transport_type: The type of transport protocol that will be used for communicating with
     the Event Hubs service. Default is ~azure.eventhub.TransportType.Amqp.
        :class: ~azure.eventhub.TransportType
    :keyword partition_manager: stores the load balancing data and checkpoint data when receiving events
     if partition_manager is specified. If it's None, this EventHubConsumerClient instance will receive
     events without load balancing and checkpoint.
        :class: subclass of ~azure.eventhub.PartitionManager
    :keyword float load_balancing_interval: When load balancing kicks in, this is the interval in seconds
     between two load balancing. Default is 10.

    .. admonition:: Example:

        .. literalinclude:: ../samples/sync_samples/test_examples_eventhub.py
            :start-after: [START create_eventhub_consumer_client_sync]
            :end-before: [END create_eventhub_consumer_client_sync]
            :language: python
            :dedent: 4
            :caption: Create a new instance of the EventHubConsumerClient.
    """

    def __init__(self, host, event_hub_path, credential, **kwargs):
        # type:(str, str, Union[EventHubSharedKeyCredential, EventHubSASTokenCredential, TokenCredential], Any) -> None
        receive_timeout = kwargs.get("receive_timeout", 3)
        if receive_timeout <= 0:
            raise ValueError("receive_timeout must be greater than 0.")

        kwargs['receive_timeout'] = receive_timeout

        super(EventHubConsumerClient, self).__init__(host=host, event_hub_path=event_hub_path, credential=credential, **kwargs)
        self._partition_manager = kwargs.get("partition_manager")
        self._load_balancing_interval = kwargs.get("load_balancing_interval", 10)
        self._event_processors = dict()
        self._closed = False

    @classmethod
    def _stop_eventprocessor(cls, event_processor):
        # pylint: disable=protected-access
        eventhub_client = event_processor._eventhub_client
        consumer_group = event_processor._consumer_group_name
        partition_id = event_processor._partition_id
        with eventhub_client._lock:
            event_processor.stop()
            if partition_id and (consumer_group, partition_id) in eventhub_client._event_processors:
                del eventhub_client._event_processors[(consumer_group, partition_id)]
            elif (consumer_group, '-1') in eventhub_client._event_processors:
                del eventhub_client._event_processors[(consumer_group, "-1")]

    def receive(self, on_event, consumer_group, **kwargs):
        """Receive events from partition(s) optionally with load balancing and checkpointing.

        :param on_event:
        :param consumer_group:
        :param partition_id:
        :param owner_level:
        :param prefetch:
        :param track_last_enqueued_event_properties:
        :param initial_event_position:
        :param on_error:
        :param on_partition_initialize:
        :param on_partition_close:
        :return: None

        Example:
            .. literalinclude:: ../examples/test_examples_eventhub.py
                :start-after: [START eventhub_consumer_client_receive_sync]
                :end-before: [END eventhub_consumer_client_receive_sync]
                :language: python
                :dedent: 4
                :caption: Receive events from the EventHub.
        """
        partition_id = kwargs.get("partition_id", None)

        with self._lock:
            error = None
            if (consumer_group, '-1') in self._event_processors:
                error = ValueError("This consumer client is already receiving events from all partitions for"
                                   " consumer group {}. "
                                   "Cannot receive from any other partitions again.".format(consumer_group))
            elif partition_id is None and any(x[0] == consumer_group for x in self._event_processors.keys()):
                error = ValueError("This consumer client is already receiving events for consumer group {}. "
                                   "Cannot receive from all partitions again.".format(consumer_group))
            elif (consumer_group, partition_id) in self._event_processors:
                error = ValueError("This consumer is already receiving events from partition {} for consumer group {}. "
                                   "Cannot receive from it again.".format(partition_id, consumer_group))
            if error:
                log.warning(error)
                raise error

            event_processor = EventProcessor(
                self, consumer_group, on_event,
                partition_manager=self._partition_manager,
                partition_id=partition_id,
                polling_interval=self._load_balancing_interval,
                **kwargs
            )
            self._event_processors[(consumer_group, partition_id or "-1")] = event_processor

        event_processor.start()

    def close(self):
        # type: () -> None
        """Stop retrieving events from event hubs and close the underlying AMQP connection and links.

        Example:
            .. literalinclude:: ../examples/test_examples_eventhub.py
                :start-after: [START eventhub_consumer_client_close_sync]
                :end-before: [END eventhub_consumer_client_close_sync]
                :language: python
                :dedent: 4
                :caption: Close down the handler.

        """
        with self._lock:
            for _ in range(len(self._event_processors)):
                _, ep = self._event_processors.popitem()
                ep.stop()
            super(EventHubConsumerClient, self).close()
