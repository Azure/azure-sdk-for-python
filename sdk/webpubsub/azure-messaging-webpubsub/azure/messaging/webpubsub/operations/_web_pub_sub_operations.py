# coding=utf-8
# --------------------------------------------------------------------------
# Copyright (c) Microsoft Corporation. All rights reserved.
# Licensed under the MIT License. See License.txt in the project root for license information.
# Code generated by Microsoft (R) AutoRest Code Generator.
# Changes may cause incorrect behavior and will be lost if the code is regenerated.
# --------------------------------------------------------------------------
from typing import TYPE_CHECKING
import warnings

from azure.core.exceptions import ClientAuthenticationError, HttpResponseError, ResourceExistsError, ResourceNotFoundError, map_error
from azure.core.pipeline import PipelineResponse
from azure.core.pipeline.transport import HttpResponse
from azure.core.rest import HttpRequest

from .. import models as _models
from .._rest import *

if TYPE_CHECKING:
    # pylint: disable=unused-import,ungrouped-imports
    from typing import Any, Callable, Dict, Generic, IO, List, Optional, TypeVar, Union

    T = TypeVar('T')
    ClsType = Optional[Callable[[PipelineResponse[HttpRequest, HttpResponse], T, Dict[str, Any]], Any]]

class WebPubSubOperations(object):
    """WebPubSubOperations operations.

    You should not instantiate this class directly. Instead, you should create a Client instance that
    instantiates it for you and attaches it as an attribute.

    :param client: Client for service requests.
    :param config: Configuration of service client.
    :param serializer: An object model serializer.
    :param deserializer: An object model deserializer.
    """

    def __init__(self, client, config, serializer, deserializer):
        self._client = client
        self._serialize = serializer
        self._deserialize = deserializer
        self._config = config

    def send_to_all(
        self,
        hub,  # type: str
        payload_message,  # type: Union[IO, str, IO]
        excluded=None,  # type: Optional[List[str]]
        api_version="2020-10-01",  # type: Optional[str]
        **kwargs  # type: Any
    ):
        # type: (...) -> None
        """Broadcast content inside request body to all the connected client connections.

        Broadcast content inside request body to all the connected client connections.

        :param hub: Target hub name, which should start with alphabetic characters and only contain
         alpha-numeric characters or underscore.
        :type hub: str
        :param payload_message: The payload body.
        :type payload_message: IO or str or IO
        :param excluded: Excluded connection Ids.
        :type excluded: list[str]
        :param api_version: Api Version.
        :type api_version: str
        :keyword str content_type: Media type of the body sent to the API. Default value is "application/octet-stream".
         Allowed values are: "application/octet-stream", "text/plain", "application/json".
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: None, or the result of cls(response)
        :rtype: None
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType[None]
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}))

        request = prepare_webpubsub_send_to_all(
            hub=hub,
            excluded=excluded,
            api_version=api_version,
            payload_message=payload_message,
            template_url=self.send_to_all.metadata['url'],
            **kwargs
        )
        request.url = self._client.format_url(request.url)
        kwargs.pop("content_type", None)

        pipeline_response = self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [202]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if cls:
            return cls(pipeline_response, None, {})

    send_to_all.metadata = {'url': '/api/hubs/{hub}/:send'}  # type: ignore

    def check_connection_existence(
        self,
        hub,  # type: str
        connection_id,  # type: str
        api_version="2020-10-01",  # type: Optional[str]
        **kwargs  # type: Any
    ):
        # type: (...) -> None
        """Check if the connection with the given connectionId exists.

        Check if the connection with the given connectionId exists.

        :param hub: Target hub name, which should start with alphabetic characters and only contain
         alpha-numeric characters or underscore.
        :type hub: str
        :param connection_id: The connection Id.
        :type connection_id: str
        :param api_version: Api Version.
        :type api_version: str
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: None, or the result of cls(response)
        :rtype: None
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType[None]
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}))

        request = prepare_webpubsub_check_connection_existence(
            hub=hub,
            connection_id=connection_id,
            api_version=api_version,
            template_url=self.check_connection_existence.metadata['url'],
            **kwargs
        )
        request.url = self._client.format_url(request.url)
        kwargs.pop("content_type", None)

        pipeline_response = self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [200, 404]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if cls:
            return cls(pipeline_response, None, {})

    check_connection_existence.metadata = {'url': '/api/hubs/{hub}/connections/{connectionId}'}  # type: ignore

    def close_client_connection(
        self,
        hub,  # type: str
        connection_id,  # type: str
        reason=None,  # type: Optional[str]
        api_version="2020-10-01",  # type: Optional[str]
        **kwargs  # type: Any
    ):
        # type: (...) -> None
        """Close the client connection.

        Close the client connection.

        :param hub: Target hub name, which should start with alphabetic characters and only contain
         alpha-numeric characters or underscore.
        :type hub: str
        :param connection_id: Target connection Id.
        :type connection_id: str
        :param reason: The reason closing the client connection.
        :type reason: str
        :param api_version: Api Version.
        :type api_version: str
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: None, or the result of cls(response)
        :rtype: None
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType[None]
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}))

        request = prepare_webpubsub_close_client_connection(
            hub=hub,
            connection_id=connection_id,
            reason=reason,
            api_version=api_version,
            template_url=self.close_client_connection.metadata['url'],
            **kwargs
        )
        request.url = self._client.format_url(request.url)
        kwargs.pop("content_type", None)

        pipeline_response = self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if cls:
            return cls(pipeline_response, None, {})

    close_client_connection.metadata = {'url': '/api/hubs/{hub}/connections/{connectionId}'}  # type: ignore

    def send_to_connection(
        self,
        hub,  # type: str
        connection_id,  # type: str
        payload_message,  # type: Union[IO, str, IO]
        api_version="2020-10-01",  # type: Optional[str]
        **kwargs  # type: Any
    ):
        # type: (...) -> None
        """Send content inside request body to the specific connection.

        Send content inside request body to the specific connection.

        :param hub: Target hub name, which should start with alphabetic characters and only contain
         alpha-numeric characters or underscore.
        :type hub: str
        :param connection_id: The connection Id.
        :type connection_id: str
        :param payload_message: The payload body.
        :type payload_message: IO or str or IO
        :param api_version: Api Version.
        :type api_version: str
        :keyword str content_type: Media type of the body sent to the API. Default value is "application/octet-stream".
         Allowed values are: "application/octet-stream", "text/plain", "application/json".
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: None, or the result of cls(response)
        :rtype: None
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType[None]
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}))

        request = prepare_webpubsub_send_to_connection(
            hub=hub,
            connection_id=connection_id,
            api_version=api_version,
            payload_message=payload_message,
            template_url=self.send_to_connection.metadata['url'],
            **kwargs
        )
        request.url = self._client.format_url(request.url)
        kwargs.pop("content_type", None)

        pipeline_response = self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [202]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if cls:
            return cls(pipeline_response, None, {})

    send_to_connection.metadata = {'url': '/api/hubs/{hub}/connections/{connectionId}/:send'}  # type: ignore

    def check_group_existence(
        self,
        hub,  # type: str
        group,  # type: str
        api_version="2020-10-01",  # type: Optional[str]
        **kwargs  # type: Any
    ):
        # type: (...) -> None
        """Check if there are any client connections inside the given group.

        Check if there are any client connections inside the given group.

        :param hub: Target hub name, which should start with alphabetic characters and only contain
         alpha-numeric characters or underscore.
        :type hub: str
        :param group: Target group name, which length should be greater than 0 and less than 1025.
        :type group: str
        :param api_version: Api Version.
        :type api_version: str
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: None, or the result of cls(response)
        :rtype: None
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType[None]
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}))

        request = prepare_webpubsub_check_group_existence(
            hub=hub,
            group=group,
            api_version=api_version,
            template_url=self.check_group_existence.metadata['url'],
            **kwargs
        )
        request.url = self._client.format_url(request.url)
        kwargs.pop("content_type", None)

        pipeline_response = self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [200, 404]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if cls:
            return cls(pipeline_response, None, {})

    check_group_existence.metadata = {'url': '/api/hubs/{hub}/groups/{group}'}  # type: ignore

    def send_to_group(
        self,
        hub,  # type: str
        group,  # type: str
        payload_message,  # type: Union[IO, str, IO]
        excluded=None,  # type: Optional[List[str]]
        api_version="2020-10-01",  # type: Optional[str]
        **kwargs  # type: Any
    ):
        # type: (...) -> None
        """Send content inside request body to a group of connections.

        Send content inside request body to a group of connections.

        :param hub: Target hub name, which should start with alphabetic characters and only contain
         alpha-numeric characters or underscore.
        :type hub: str
        :param group: Target group name, which length should be greater than 0 and less than 1025.
        :type group: str
        :param payload_message: The payload body.
        :type payload_message: IO or str or IO
        :param excluded: Excluded connection Ids.
        :type excluded: list[str]
        :param api_version: Api Version.
        :type api_version: str
        :keyword str content_type: Media type of the body sent to the API. Default value is "application/octet-stream".
         Allowed values are: "application/octet-stream", "text/plain", "application/json".
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: None, or the result of cls(response)
        :rtype: None
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType[None]
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}))

        request = prepare_webpubsub_send_to_group(
            hub=hub,
            group=group,
            excluded=excluded,
            api_version=api_version,
            payload_message=payload_message,
            template_url=self.send_to_group.metadata['url'],
            **kwargs
        )
        request.url = self._client.format_url(request.url)
        kwargs.pop("content_type", None)

        pipeline_response = self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [202]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if cls:
            return cls(pipeline_response, None, {})

    send_to_group.metadata = {'url': '/api/hubs/{hub}/groups/{group}/:send'}  # type: ignore

    def add_connection_to_group(
        self,
        hub,  # type: str
        group,  # type: str
        connection_id,  # type: str
        api_version="2020-10-01",  # type: Optional[str]
        **kwargs  # type: Any
    ):
        # type: (...) -> None
        """Add a connection to the target group.

        Add a connection to the target group.

        :param hub: Target hub name, which should start with alphabetic characters and only contain
         alpha-numeric characters or underscore.
        :type hub: str
        :param group: Target group name, which length should be greater than 0 and less than 1025.
        :type group: str
        :param connection_id: Target connection Id.
        :type connection_id: str
        :param api_version: Api Version.
        :type api_version: str
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: None, or the result of cls(response)
        :rtype: None
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType[None]
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}))

        request = prepare_webpubsub_add_connection_to_group(
            hub=hub,
            group=group,
            connection_id=connection_id,
            api_version=api_version,
            template_url=self.add_connection_to_group.metadata['url'],
            **kwargs
        )
        request.url = self._client.format_url(request.url)
        kwargs.pop("content_type", None)

        pipeline_response = self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [200, 404]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if cls:
            return cls(pipeline_response, None, {})

    add_connection_to_group.metadata = {'url': '/api/hubs/{hub}/groups/{group}/connections/{connectionId}'}  # type: ignore

    def remove_connection_from_group(
        self,
        hub,  # type: str
        group,  # type: str
        connection_id,  # type: str
        api_version="2020-10-01",  # type: Optional[str]
        **kwargs  # type: Any
    ):
        # type: (...) -> None
        """Remove a connection from the target group.

        Remove a connection from the target group.

        :param hub: Target hub name, which should start with alphabetic characters and only contain
         alpha-numeric characters or underscore.
        :type hub: str
        :param group: Target group name, which length should be greater than 0 and less than 1025.
        :type group: str
        :param connection_id: Target connection Id.
        :type connection_id: str
        :param api_version: Api Version.
        :type api_version: str
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: None, or the result of cls(response)
        :rtype: None
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType[None]
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}))

        request = prepare_webpubsub_remove_connection_from_group(
            hub=hub,
            group=group,
            connection_id=connection_id,
            api_version=api_version,
            template_url=self.remove_connection_from_group.metadata['url'],
            **kwargs
        )
        request.url = self._client.format_url(request.url)
        kwargs.pop("content_type", None)

        pipeline_response = self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [200, 404]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if cls:
            return cls(pipeline_response, None, {})

    remove_connection_from_group.metadata = {'url': '/api/hubs/{hub}/groups/{group}/connections/{connectionId}'}  # type: ignore

    def check_user_existence(
        self,
        hub,  # type: str
        user_id,  # type: str
        api_version="2020-10-01",  # type: Optional[str]
        **kwargs  # type: Any
    ):
        # type: (...) -> None
        """Check if there are any client connections connected for the given user.

        Check if there are any client connections connected for the given user.

        :param hub: Target hub name, which should start with alphabetic characters and only contain
         alpha-numeric characters or underscore.
        :type hub: str
        :param user_id: Target user Id.
        :type user_id: str
        :param api_version: Api Version.
        :type api_version: str
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: None, or the result of cls(response)
        :rtype: None
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType[None]
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}))

        request = prepare_webpubsub_check_user_existence(
            hub=hub,
            user_id=user_id,
            api_version=api_version,
            template_url=self.check_user_existence.metadata['url'],
            **kwargs
        )
        request.url = self._client.format_url(request.url)
        kwargs.pop("content_type", None)

        pipeline_response = self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [200, 404]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if cls:
            return cls(pipeline_response, None, {})

    check_user_existence.metadata = {'url': '/api/hubs/{hub}/users/{userId}'}  # type: ignore

    def send_to_user(
        self,
        hub,  # type: str
        user_id,  # type: str
        payload_message,  # type: Union[IO, str, IO]
        api_version="2020-10-01",  # type: Optional[str]
        **kwargs  # type: Any
    ):
        # type: (...) -> None
        """Send content inside request body to the specific user.

        Send content inside request body to the specific user.

        :param hub: Target hub name, which should start with alphabetic characters and only contain
         alpha-numeric characters or underscore.
        :type hub: str
        :param user_id: The user Id.
        :type user_id: str
        :param payload_message: The payload body.
        :type payload_message: IO or str or IO
        :param api_version: Api Version.
        :type api_version: str
        :keyword str content_type: Media type of the body sent to the API. Default value is "application/octet-stream".
         Allowed values are: "application/octet-stream", "text/plain", "application/json".
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: None, or the result of cls(response)
        :rtype: None
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType[None]
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}))

        request = prepare_webpubsub_send_to_user(
            hub=hub,
            user_id=user_id,
            api_version=api_version,
            payload_message=payload_message,
            template_url=self.send_to_user.metadata['url'],
            **kwargs
        )
        request.url = self._client.format_url(request.url)
        kwargs.pop("content_type", None)

        pipeline_response = self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [202]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if cls:
            return cls(pipeline_response, None, {})

    send_to_user.metadata = {'url': '/api/hubs/{hub}/users/{userId}/:send'}  # type: ignore

    def check_user_existence_in_group(
        self,
        hub,  # type: str
        group,  # type: str
        user_id,  # type: str
        api_version="2020-10-01",  # type: Optional[str]
        **kwargs  # type: Any
    ):
        # type: (...) -> None
        """Check whether a user exists in the target group.

        Check whether a user exists in the target group.

        :param hub: Target hub name, which should start with alphabetic characters and only contain
         alpha-numeric characters or underscore.
        :type hub: str
        :param group: Target group name, which length should be greater than 0 and less than 1025.
        :type group: str
        :param user_id: Target user Id.
        :type user_id: str
        :param api_version: Api Version.
        :type api_version: str
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: None, or the result of cls(response)
        :rtype: None
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType[None]
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}))

        request = prepare_webpubsub_check_user_existence_in_group(
            hub=hub,
            group=group,
            user_id=user_id,
            api_version=api_version,
            template_url=self.check_user_existence_in_group.metadata['url'],
            **kwargs
        )
        request.url = self._client.format_url(request.url)
        kwargs.pop("content_type", None)

        pipeline_response = self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [200, 404]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if cls:
            return cls(pipeline_response, None, {})

    check_user_existence_in_group.metadata = {'url': '/api/hubs/{hub}/users/{userId}/groups/{group}'}  # type: ignore

    def add_user_to_group(
        self,
        hub,  # type: str
        group,  # type: str
        user_id,  # type: str
        api_version="2020-10-01",  # type: Optional[str]
        **kwargs  # type: Any
    ):
        # type: (...) -> None
        """Add a user to the target group.

        Add a user to the target group.

        :param hub: Target hub name, which should start with alphabetic characters and only contain
         alpha-numeric characters or underscore.
        :type hub: str
        :param group: Target group name, which length should be greater than 0 and less than 1025.
        :type group: str
        :param user_id: Target user Id.
        :type user_id: str
        :param api_version: Api Version.
        :type api_version: str
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: None, or the result of cls(response)
        :rtype: None
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType[None]
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}))

        request = prepare_webpubsub_add_user_to_group(
            hub=hub,
            group=group,
            user_id=user_id,
            api_version=api_version,
            template_url=self.add_user_to_group.metadata['url'],
            **kwargs
        )
        request.url = self._client.format_url(request.url)
        kwargs.pop("content_type", None)

        pipeline_response = self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if cls:
            return cls(pipeline_response, None, {})

    add_user_to_group.metadata = {'url': '/api/hubs/{hub}/users/{userId}/groups/{group}'}  # type: ignore

    def remove_user_from_group(
        self,
        hub,  # type: str
        group,  # type: str
        user_id,  # type: str
        api_version="2020-10-01",  # type: Optional[str]
        **kwargs  # type: Any
    ):
        # type: (...) -> None
        """Remove a user from the target group.

        Remove a user from the target group.

        :param hub: Target hub name, which should start with alphabetic characters and only contain
         alpha-numeric characters or underscore.
        :type hub: str
        :param group: Target group name, which length should be greater than 0 and less than 1025.
        :type group: str
        :param user_id: Target user Id.
        :type user_id: str
        :param api_version: Api Version.
        :type api_version: str
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: None, or the result of cls(response)
        :rtype: None
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType[None]
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}))

        request = prepare_webpubsub_remove_user_from_group(
            hub=hub,
            group=group,
            user_id=user_id,
            api_version=api_version,
            template_url=self.remove_user_from_group.metadata['url'],
            **kwargs
        )
        request.url = self._client.format_url(request.url)
        kwargs.pop("content_type", None)

        pipeline_response = self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if cls:
            return cls(pipeline_response, None, {})

    remove_user_from_group.metadata = {'url': '/api/hubs/{hub}/users/{userId}/groups/{group}'}  # type: ignore

    def remove_user_from_all_groups(
        self,
        hub,  # type: str
        user_id,  # type: str
        api_version="2020-10-01",  # type: Optional[str]
        **kwargs  # type: Any
    ):
        # type: (...) -> None
        """Remove a user from all groups.

        Remove a user from all groups.

        :param hub: Target hub name, which should start with alphabetic characters and only contain
         alpha-numeric characters or underscore.
        :type hub: str
        :param user_id: Target user Id.
        :type user_id: str
        :param api_version: Api Version.
        :type api_version: str
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: None, or the result of cls(response)
        :rtype: None
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType[None]
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}))

        request = prepare_webpubsub_remove_user_from_all_groups(
            hub=hub,
            user_id=user_id,
            api_version=api_version,
            template_url=self.remove_user_from_all_groups.metadata['url'],
            **kwargs
        )
        request.url = self._client.format_url(request.url)
        kwargs.pop("content_type", None)

        pipeline_response = self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if cls:
            return cls(pipeline_response, None, {})

    remove_user_from_all_groups.metadata = {'url': '/api/hubs/{hub}/users/{userId}/groups'}  # type: ignore

    def grant_permission(
        self,
        hub,  # type: str
        permission,  # type: Union[str, "_models.Enum0"]
        connection_id,  # type: str
        target_name=None,  # type: Optional[str]
        api_version="2020-10-01",  # type: Optional[str]
        **kwargs  # type: Any
    ):
        # type: (...) -> None
        """Grant permission to the connection.

        Grant permission to the connection.

        :param hub: Target hub name, which should start with alphabetic characters and only contain
         alpha-numeric characters or underscore.
        :type hub: str
        :param permission: The permission: current supported actions are joinLeaveGroup and
         sendToGroup.
        :type permission: str or ~azure.messaging.webpubsub.models.Enum0
        :param connection_id: Target connection Id.
        :type connection_id: str
        :param target_name: Optional. If not set, grant the permission to all the targets. If set,
         grant the permission to the specific target. The meaning of the target depends on the specific
         permission.
        :type target_name: str
        :param api_version: Api Version.
        :type api_version: str
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: None, or the result of cls(response)
        :rtype: None
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType[None]
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}))

        request = prepare_webpubsub_grant_permission(
            hub=hub,
            permission=permission,
            connection_id=connection_id,
            target_name=target_name,
            api_version=api_version,
            template_url=self.grant_permission.metadata['url'],
            **kwargs
        )
        request.url = self._client.format_url(request.url)
        kwargs.pop("content_type", None)

        pipeline_response = self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if cls:
            return cls(pipeline_response, None, {})

    grant_permission.metadata = {'url': '/api/hubs/{hub}/permissions/{permission}/connections/{connectionId}'}  # type: ignore

    def revoke_permission(
        self,
        hub,  # type: str
        permission,  # type: Union[str, "_models.Enum1"]
        connection_id,  # type: str
        target_name=None,  # type: Optional[str]
        api_version="2020-10-01",  # type: Optional[str]
        **kwargs  # type: Any
    ):
        # type: (...) -> None
        """Revoke permission for the connection.

        Revoke permission for the connection.

        :param hub: Target hub name, which should start with alphabetic characters and only contain
         alpha-numeric characters or underscore.
        :type hub: str
        :param permission: The permission: current supported actions are joinLeaveGroup and
         sendToGroup.
        :type permission: str or ~azure.messaging.webpubsub.models.Enum1
        :param connection_id: Target connection Id.
        :type connection_id: str
        :param target_name: Optional. If not set, revoke the permission for all targets. If set, revoke
         the permission for the specific target. The meaning of the target depends on the specific
         permission.
        :type target_name: str
        :param api_version: Api Version.
        :type api_version: str
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: None, or the result of cls(response)
        :rtype: None
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType[None]
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}))

        request = prepare_webpubsub_revoke_permission(
            hub=hub,
            permission=permission,
            connection_id=connection_id,
            target_name=target_name,
            api_version=api_version,
            template_url=self.revoke_permission.metadata['url'],
            **kwargs
        )
        request.url = self._client.format_url(request.url)
        kwargs.pop("content_type", None)

        pipeline_response = self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if cls:
            return cls(pipeline_response, None, {})

    revoke_permission.metadata = {'url': '/api/hubs/{hub}/permissions/{permission}/connections/{connectionId}'}  # type: ignore

    def check_permission(
        self,
        hub,  # type: str
        permission,  # type: Union[str, "_models.Enum2"]
        connection_id,  # type: str
        target_name=None,  # type: Optional[str]
        api_version="2020-10-01",  # type: Optional[str]
        **kwargs  # type: Any
    ):
        # type: (...) -> None
        """Check if a connection have permission to the specific action.

        Check if a connection have permission to the specific action.

        :param hub: Target hub name, which should start with alphabetic characters and only contain
         alpha-numeric characters or underscore.
        :type hub: str
        :param permission: The permission: current supported actions are joinLeaveGroup and
         sendToGroup.
        :type permission: str or ~azure.messaging.webpubsub.models.Enum2
        :param connection_id: Target connection Id.
        :type connection_id: str
        :param target_name: Optional. If not set, get the permission for all targets. If set, get the
         permission for the specific target. The meaning of the target depends on the specific
         permission.
        :type target_name: str
        :param api_version: Api Version.
        :type api_version: str
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: None, or the result of cls(response)
        :rtype: None
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType[None]
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}))

        request = prepare_webpubsub_check_permission(
            hub=hub,
            permission=permission,
            connection_id=connection_id,
            target_name=target_name,
            api_version=api_version,
            template_url=self.check_permission.metadata['url'],
            **kwargs
        )
        request.url = self._client.format_url(request.url)
        kwargs.pop("content_type", None)

        pipeline_response = self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [200, 404]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if cls:
            return cls(pipeline_response, None, {})

    check_permission.metadata = {'url': '/api/hubs/{hub}/permissions/{permission}/connections/{connectionId}'}  # type: ignore
