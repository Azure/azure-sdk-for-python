# coding=utf-8
# --------------------------------------------------------------------------
# Copyright (c) Microsoft Corporation. All rights reserved.
# Licensed under the MIT License. See License.txt in the project root for license information.
# Code generated by Microsoft (R) AutoRest Code Generator.
# Changes may cause incorrect behavior and will be lost if the code is regenerated.
# --------------------------------------------------------------------------


import sys
from typing import Any, Mapping, overload, Union, Optional, TypeVar, Tuple
import json
import math
import threading

from .. import _model_base
from ._model_base import rest_discriminator, rest_field, AzureJSONEncoder
from ._enums import WebPubSubDataType

if sys.version_info >= (3, 9):
    from collections.abc import MutableMapping
else:
    from typing import MutableMapping  # type: ignore  # pylint: disable=ungrouped-imports
if sys.version_info >= (3, 8):
    from typing import Literal  # pylint: disable=no-name-in-module, ungrouped-imports
else:
    from typing_extensions import Literal  # type: ignore  # pylint: disable=ungrouped-imports
JSON = MutableMapping[str, Any]  # pylint: disable=unsubscriptable-object


class JoinGroupMessage(_model_base.Model):
    kind: str = rest_field(default="joinGroup")
    group: str = rest_field()
    ack_id: Optional[int] = rest_field(name="ackId")

    @overload
    def __init__(self, *, kind: str = "joinGroup", group: str, ack_id: Optional[int] = None) -> None:
        ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]):
        ...

    def __init__(self, *args, **kwargs):
        super().__init__(*args, **kwargs)


class LeaveGroupMessage(_model_base.Model):
    kind: str = rest_field(default="leaveGroup")
    group: str = rest_field()
    ack_id: Optional[int] = rest_field(name="ackId")

    @overload
    def __init__(self, *, kind: str = "leaveGroup", group: str, ack_id: Optional[int] = None) -> None:
        ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]):
        ...

    def __init__(self, *args, **kwargs):
        super().__init__(*args, **kwargs)


class AckMessageError(_model_base.Model):
    name: str = rest_field()
    message: str = rest_field()

    @overload
    def __init__(self, *, name: str, message: str):
        ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]):
        ...

    def __init__(self, *args, **kwargs):
        super().__init__(*args, **kwargs)


class AckMessage(_model_base.Model):
    kind: Literal["ack"] = rest_field(default="ack")
    ack_id: int = rest_field(name="ackId")
    success: bool = rest_field()
    error: Optional[AckMessageError] = rest_field()

    @overload
    def __init__(
        self,
        *,
        kind: Literal["ack"] = "ack",
        ack_id: int,
        success: bool,
        error: Optional[AckMessageError] = None,
    ) -> None:
        ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]):
        ...

    def __init__(self, *args, **kwargs):
        super().__init__(*args, **kwargs)


class SendEventMessage(_model_base.Model):
    kind: Literal["sendEvent"] = rest_field(default="sendEvent")
    data_type: WebPubSubDataType = rest_field(name="dataType")
    data: Any = rest_field()
    event: str = rest_field()
    ack_id: Optional[int] = rest_field(name="ackId")

    @overload
    def __init__(
        self,
        data_type: WebPubSubDataType,
        data: Any,
        event: str,
        ack_id: Optional[int] = None,
    ) -> None:
        ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]):
        ...

    def __init__(self, *args, **kwargs):
        super().__init__(*args, **kwargs)


class SendToGroupMessage(_model_base.Model):
    kind: Literal["sendToGroup"] = rest_field(default="sendToGroup")
    data_type: WebPubSubDataType = rest_field(name="dataType")
    data: Any = rest_field()
    no_echo: bool = rest_field(name="noEcho")
    ack_id: Optional[int] = rest_field(name="ackId")

    @overload
    def __init__(
        self,
        data_type: WebPubSubDataType,
        data: Any,
        no_echo: bool,
        ack_id: Optional[int] = None,
    ) -> None:
        ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]):
        ...

    def __init__(self, *args, **kwargs):
        super().__init__(*args, **kwargs)


class JoinGroupData(_model_base.Model):
    type: Literal["joinGroup"] = rest_field(default="joinGroup")
    group: str = rest_field()
    ack_id: Optional[int] = rest_field(name="ackId")

    @overload
    def __init__(
        self,
        *,
        type: Literal["joinGroup"] = "joinGroup",
        group: str,
        ack_id: Optional[int] = None,
    ) -> None:
        ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]):
        ...

    def __init__(self, *args, **kwargs):
        super().__init__(*args, **kwargs)


class LeaveGroupData(_model_base.Model):
    type: Literal["leaveGroup"] = rest_field(default="leaveGroup")
    group: str = rest_field()
    ack_id: Optional[int] = rest_field(name="ackId")

    @overload
    def __init__(
        self,
        *,
        type: Literal["leaveGroup"] = "leaveGroup",
        group: str,
        ack_id: Optional[int] = None,
    ) -> None:
        ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]):
        ...

    def __init__(self, *args, **kwargs):
        super().__init__(*args, **kwargs)

class SendEventData(_model_base.Model):
    type: Literal["event"] = rest_field(default="event")
    data_type: WebPubSubDataType = rest_field(name="dataType")
    data: Any = rest_field()
    event: str = rest_field()
    ack_id: Optional[int] = rest_field(name="ackId")

    @overload
    def __init__(
        self,
        *,
        type: Literal["event"] = "event",
        data_type: WebPubSubDataType,
        data: Any,
        event: str,
        ack_id: Optional[int] = None,
    ) -> None:
        ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]):
        ...

    def __init__(self, *args, **kwargs):
        super().__init__(*args, **kwargs)


class SequenceAckMessage(_model_base.Model):
    kind: Literal["sequenceAck"] = rest_field(default="sequenceAck")
    sequence_id: int = rest_field(name="sequenceId")

    @overload
    def __init__(
        self,
        *,
        kind: Literal["sequenceAck"] = "sequenceAck",
        sequence_id: int,
    ) -> None:
        ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]):
        ...

    def __init__(self, *args, **kwargs):
        super().__init__(*args, **kwargs)


class OnConnectedArgs(_model_base.Model):
    connection_id: str = rest_field(name="connectionId")
    user_id: str = rest_field(name="userId")

    @overload
    def __init__(self, *, connection_id: str, user_id: str) -> None:
        ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]):
        ...

    def __init__(self, *args, **kwargs):
        super().__init__(*args, **kwargs)


class WebPubSubMessageBase(_model_base.Model):
    __mapping__ = {}
    kind: Literal[None] = rest_discriminator(name="kind")

    @overload
    def __init__(self) -> None:
        ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]):
        ...

    def __init__(self, *args, **kwargs):
        super().__init__(*args, **kwargs)
        self.kind: Literal[None] = None


class ConnectedMessage(_model_base.Model, discriminator="connected"):
    kind: Literal["connected"] = rest_discriminator()
    connection_id: int = rest_field(name="connectionId")
    user_id: str = rest_field(name="userId")
    reconnection_token: str = rest_field(name="reconnectionToken")

    @overload
    def __init__(self, *, connection_id: int, user_id: str, reconnection_token: str) -> None:
        ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]):
        ...

    def __init__(self, *args, **kwargs):
        super().__init__(*args, **kwargs)
        self.kind = "connected"


class DisconnectedMessage(WebPubSubMessageBase):
    def __init__(self, message: str) -> None:
        super().__init__()
        self.kind: Literal["disconnected"] = "disconnected"
        self.message = message


class GroupDataMessage(WebPubSubMessageBase):
    def __init__(
        self,
        data_type: WebPubSubDataType,
        data: Any,
        group: str,
        from_user_id: str,
        sequence_id: Optional[int] = None,
    ) -> None:
        super().__init__()
        self.kind: Literal["groupData"] = "groupData"
        self.data_type = data_type
        self.data = data
        self.group = group
        self.from_user_id = from_user_id
        self.sequence_id = sequence_id


class ServerDataMessage(WebPubSubMessageBase):
    def __init__(self, data_type: WebPubSubDataType, data: Any, sequence_id: Optional[int] = None) -> None:
        super().__init__()
        self.kind: Literal["serverData"] = "serverData"
        self.data_type = data_type
        self.data = data
        self.sequence_id = sequence_id


class SendToGroupMessage(WebPubSubMessageBase):
    def __init__(
        self,
        data_type: WebPubSubDataType,
        data: Any,
        group: str,
        no_echo: bool,
        ack_id: Optional[int] = None,
    ) -> None:
        super().__init__()
        self.kind: Literal["sendToGroup"] = "sendToGroup"
        self.data_type = data_type
        self.data = data
        self.group = group
        self.no_echo = no_echo
        self.ack_id = ack_id


class OnRestoreGroupFailedArgs:
    def __init__(self, group: str, error: Exception) -> None:
        self.group = group
        self.error = error


WebPubSubMessage = TypeVar(
    "WebPubSubMessage",
    GroupDataMessage,
    ServerDataMessage,
    JoinGroupMessage,
    LeaveGroupMessage,
    ConnectedMessage,
    DisconnectedMessage,
    SendToGroupMessage,
    SendEventMessage,
    SequenceAckMessage,
    AckMessage,
)


def parse_payload(data: Any, data_type: str) -> Any:
    if data_type == "text":
        if not isinstance(data, str):
            raise TypeError("Message must be a string when dataType is text")
        return data
    if data_type == "json":
        return data
    if data_type == "binary" or data_type == "protobuf":
        # // TODO
        return data
    raise TypeError(f"Unsupported dataType: {data_type}")


class WebPubSubClientProtocol:
    def __init__(self) -> None:
        self.is_reliable_sub_protocol = None
        self.name = None

    @staticmethod
    def parse_messages(input: str) -> WebPubSubMessage:
        if input is None:
            raise Exception("No input")
        if not isinstance(input, str):
            raise Exception("Invalid input for JSON hub protocol. Expected a string.")

        message = json.loads(input)
        if message["type"] == "system":
            if message["event"] == "connected":
                result = ConnectedMessage(
                    connection_id=message["connectionId"],
                    user_id=message["userId"],
                    reconnection_token=message["reconnectionToken"],
                )
            elif message["event"] == "disconnected":
                result = DisconnectedMessage(message=message["message"])
            else:
                raise Exception()
        elif message["type"] == "message":
            if message["from"] == "group":
                data = parse_payload(message["data"], message["data_type"])
                result = GroupDataMessage(data=data, **message)
            elif message["type"] == "server":
                data = parse_payload(message["data"], message["data_type"])
                result = ServerDataMessage(data=data, **message)
            else:
                raise Exception()
        elif message["type"] == "ack":
            result = AckMessage(
                ack_id=message["ackId"],
                success=message["success"],
                error=message.get("error"),
            )
        else:
            raise Exception()
        return result

    @staticmethod
    def write_message(message: WebPubSubMessage) -> str:
        if message.kind == "joinGroup":
            data = JoinGroupData(group=message.group, ack_id=message.ack_id)
        elif message.kind == "leaveGroup":
            data = LeaveGroupData(group=message.group, ack_id=message.ack_id)
        elif message.kind == "sendEvent":
            data = SendEventData()

        return json.dumps(data, cls=AzureJSONEncoder)


class WebPubSubJsonProtocol(WebPubSubClientProtocol):
    def __init__(self) -> None:
        super().__init__()
        self.is_reliable_sub_protocol = False
        self.name = "json.webpubsub.azure.v1"


class WebPubSubJsonReliableProtocol(WebPubSubClientProtocol):
    def __init__(self) -> None:
        super().__init__()
        self.is_reliable_sub_protocol = True
        self.name = "json.reliable.webpubsub.azure.v1"


class WebPubSubRetryOptions:
    def __init__(
        self,
        max_retries: Optional[int] = None,
        retry_delay_in_ms: Optional[int] = None,
        max_retry_delay_in_ms: Optional[int] = None,
        mode: Optional[Literal["Exponential", "Fixed"]] = None,
    ) -> None:
        self.max_retries = max_retries
        self.retry_delay_in_ms = retry_delay_in_ms
        self.max_retry_delay_in_ms = max_retry_delay_in_ms
        self.mode = mode


class WebPubSubClientOptions:
    def __init__(
        self,
        protocol: Optional[WebPubSubClientProtocol] = None,
        auto_reconnect: Optional[bool] = None,
        auto_restore_groups: Optional[bool] = None,
        message_retry_options: Optional[WebPubSubRetryOptions] = None,
    ) -> None:
        self.protocol = protocol
        self.auto_reconnect = auto_reconnect
        self.auto_restore_groups = auto_restore_groups
        self.message_retry_options = message_retry_options


class SendMessageErrorOptions:
    def __init__(self, ack_id: Optional[int] = None, error_detail: Optional[AckMessageError] = None) -> None:
        self.ack_id = ack_id
        self.error_detail = error_detail
        self.cv = threading.Condition()


class SendMessageError(Exception):
    def __init__(self, message: str, ack_id: Optional[int]=None, error_detail: Optional[AckMessageError]=None, *args: object) -> None:
        super().__init__(message, *args)
        self.name = "SendMessageError"
        self.ack_id = ack_id
        self.error_detail = error_detail


class OnGroupDataMessageArgs:
    def __init__(self, message: GroupDataMessage) -> None:
        self.message = message


class OnServerDataMessageArgs:
    def __init__(self, message: ServerDataMessage) -> None:
        self.message = message


class CloseEvent:
    def __init__(self, close_status_code: Optional[int] = None, close_reason: Optional[str] = None) -> None:
        self.close_status_code = close_status_code
        self.close_reason = close_reason


class OnDisconnectedArgs:
    def __init__(self, connection_id: Optional[str] = None, message: Optional[DisconnectedMessage] = None) -> None:
        self.connection_id = connection_id
        self.message = message


class OnRejoinGroupFailedArgs:
    def __init__(self, group: str, error: Exception) -> None:
        self.group = group
        self.error = error


class SendToGroupOptions:
    def __init__(self, no_echo: bool, fire_and_forget: bool, ack_id: Optional[int] = None) -> None:
        self.no_echo = no_echo
        self.fire_and_forget = fire_and_forget
        self.ack_id = ack_id


class SendEventOptions:
    def __init__(self, fire_and_forget: bool, ack_id: Optional[int] = None) -> None:
        self.fire_and_forget = fire_and_forget
        self.ack_id = ack_id


class JoinGroupOptions:
    def __init__(self, ack_id: Optional[int] = None) -> None:
        self.ack_id = ack_id


class LeaveGroupOptions:
    def __init__(self, ack_id: Optional[int] = None) -> None:
        self.ack_id = ack_id


class RetryPolicy:
    def __init__(self, retry_options: WebPubSubRetryOptions) -> None:
        self.retry_options = retry_options
        self.max_retries_to_get_max_delay = math.ceil(
            math.log2(self.retry_options.max_retry_delay_in_ms) - math.log2(self.retry_options.retry_delay_in_ms) + 1
        )

    def next_retry_delay_in_ms(self, retry_attempt: int) -> Union[int, None]:
        if retry_attempt > self.retry_options.max_retries:
            return None
        else:
            if self.retry_options.mode != "Fixed":
                return self.retry_options.retry_delay_in_ms
            else:
                return self.calculate_exponential_delay(retry_attempt)

    def calculate_exponential_delay(self, attempt: int) -> int:
        if attempt >= self.max_retries_to_get_max_delay:
            return self.retry_options.max_retry_delay_in_ms
        else:
            return (1 << (attempt - 1)) * self.retry_options.retry_delay_in_ms


class WebPubSubGroup:
    def __init__(self, name: str) -> None:
        self.name = name
        self.is_joined = False


class SequenceId:
    def __init__(self) -> None:
        self.sequence_id = 0
        self.is_update = False

    def try_update(self, sequence_id: int) -> bool:
        self.is_update = True
        if sequence_id > self.sequence_id:
            self.sequence_id = sequence_id
            return True
        return False

    def try_get_sequence_id(self) -> Tuple[bool, Union[int, None]]:
        if self.is_update:
            self.is_update = False
            return (True, self.sequence_id)
        return (False, None)

    def reset(self):
        self.sequence_id = 0
        self.is_update = False
