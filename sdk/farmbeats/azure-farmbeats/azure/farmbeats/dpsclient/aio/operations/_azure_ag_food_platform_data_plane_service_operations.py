# coding=utf-8
# --------------------------------------------------------------------------
# Code generated by Microsoft (R) AutoRest Code Generator (autorest: 3.0.6351, generator: {generator})
# Changes may cause incorrect behavior and will be lost if the code is regenerated.
# --------------------------------------------------------------------------
import datetime
from typing import Any, Callable, Dict, Generic, List, Optional, TypeVar, Union
import warnings

from azure.core.exceptions import ClientAuthenticationError, HttpResponseError, ResourceExistsError, ResourceNotFoundError, map_error
from azure.core.pipeline import PipelineResponse
from azure.core.pipeline.transport import AsyncHttpResponse, HttpRequest

from ... import models as _models

T = TypeVar('T')
ClsType = Optional[Callable[[PipelineResponse[HttpRequest, AsyncHttpResponse], T, Dict[str, Any]], Any]]

class AzureAgFoodPlatformDataPlaneServiceOperationsMixin:

    async def get_boundaries(
        self,
        farmer_id: str,
        is_primary: Optional[bool] = None,
        parent_type: Optional[str] = None,
        parent_ids: Optional[List[str]] = None,
        min_acreage: Optional[float] = None,
        max_acreage: Optional[float] = None,
        ids: Optional[List[str]] = None,
        names: Optional[List[str]] = None,
        property_filters: Optional[List[str]] = None,
        statuses: Optional[List[str]] = None,
        min_created_date_time: Optional[datetime.datetime] = None,
        max_created_date_time: Optional[datetime.datetime] = None,
        min_last_modified_date_time: Optional[datetime.datetime] = None,
        max_last_modified_date_time: Optional[datetime.datetime] = None,
        max_page_size: Optional[int] = 50,
        skip_token: Optional[str] = None,
        **kwargs
    ) -> "_models.BoundaryListResponse":
        """Returns a list of boundaries.

        :param farmer_id: Id of the farmer.
        :type farmer_id: str
        :param is_primary: Is the boundary primary.
        :type is_primary: bool
        :param parent_type: Type of the parent it belongs to.
        :type parent_type: str
        :param parent_ids: Parent Ids of the resource.
        :type parent_ids: list[str]
        :param min_acreage: Minimum acreage of the boundary (inclusive).
        :type min_acreage: float
        :param max_acreage: Maximum acreage of the boundary (inclusive).
        :type max_acreage: float
        :param ids: Ids of the resource.
        :type ids: list[str]
        :param names: Names of the resource.
        :type names: list[str]
        :param property_filters: Filters on key-value pairs within the Properties object.
         eg. "{testkey} eq {testvalue}".
        :type property_filters: list[str]
        :param statuses: Statuses of the resource.
        :type statuses: list[str]
        :param min_created_date_time: Minimum creation date of resource (inclusive).
        :type min_created_date_time: ~datetime.datetime
        :param max_created_date_time: Maximum creation date of resource (inclusive).
        :type max_created_date_time: ~datetime.datetime
        :param min_last_modified_date_time: Minimum last modified date of resource (inclusive).
        :type min_last_modified_date_time: ~datetime.datetime
        :param max_last_modified_date_time: Maximum last modified date of resource (inclusive).
        :type max_last_modified_date_time: ~datetime.datetime
        :param max_page_size: Maximum number of items needed (inclusive).
         Minimum = 10, Maximum = 1000, Default value = 50.
        :type max_page_size: int
        :param skip_token: Skip token for getting next set of results.
        :type skip_token: str
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: BoundaryListResponse, or the result of cls(response)
        :rtype: ~dpsclient.models.BoundaryListResponse
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType["_models.BoundaryListResponse"]
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}))
        api_version = "2020-12-31-preview"
        accept = "application/json"

        # Construct URL
        url = self.get_boundaries.metadata['url']  # type: ignore
        path_format_arguments = {
            'farmerId': self._serialize.url("farmer_id", farmer_id, 'str'),
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]
        if is_primary is not None:
            query_parameters['isPrimary'] = self._serialize.query("is_primary", is_primary, 'bool')
        if parent_type is not None:
            query_parameters['parentType'] = self._serialize.query("parent_type", parent_type, 'str')
        if parent_ids is not None:
            query_parameters['parentIds'] = [self._serialize.query("parent_ids", q, 'str') if q is not None else '' for q in parent_ids]
        if min_acreage is not None:
            query_parameters['minAcreage'] = self._serialize.query("min_acreage", min_acreage, 'float')
        if max_acreage is not None:
            query_parameters['maxAcreage'] = self._serialize.query("max_acreage", max_acreage, 'float')
        if ids is not None:
            query_parameters['ids'] = [self._serialize.query("ids", q, 'str') if q is not None else '' for q in ids]
        if names is not None:
            query_parameters['names'] = [self._serialize.query("names", q, 'str') if q is not None else '' for q in names]
        if property_filters is not None:
            query_parameters['propertyFilters'] = [self._serialize.query("property_filters", q, 'str') if q is not None else '' for q in property_filters]
        if statuses is not None:
            query_parameters['statuses'] = [self._serialize.query("statuses", q, 'str') if q is not None else '' for q in statuses]
        if min_created_date_time is not None:
            query_parameters['minCreatedDateTime'] = self._serialize.query("min_created_date_time", min_created_date_time, 'iso-8601')
        if max_created_date_time is not None:
            query_parameters['maxCreatedDateTime'] = self._serialize.query("max_created_date_time", max_created_date_time, 'iso-8601')
        if min_last_modified_date_time is not None:
            query_parameters['minLastModifiedDateTime'] = self._serialize.query("min_last_modified_date_time", min_last_modified_date_time, 'iso-8601')
        if max_last_modified_date_time is not None:
            query_parameters['maxLastModifiedDateTime'] = self._serialize.query("max_last_modified_date_time", max_last_modified_date_time, 'iso-8601')
        if max_page_size is not None:
            query_parameters['$maxPageSize'] = self._serialize.query("max_page_size", max_page_size, 'int', maximum=1000, minimum=10)
        if skip_token is not None:
            query_parameters['$skipToken'] = self._serialize.query("skip_token", skip_token, 'str')
        query_parameters['api-version'] = self._serialize.query("api_version", api_version, 'str')

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]
        header_parameters['Accept'] = self._serialize.header("accept", accept, 'str')

        request = self._client.get(url, query_parameters, header_parameters)
        pipeline_response = await self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        deserialized = self._deserialize('BoundaryListResponse', pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized
    get_boundaries.metadata = {'url': '/farmers/{farmerId}/boundaries'}  # type: ignore

    async def get_all_boundaries(
        self,
        is_primary: Optional[bool] = None,
        parent_type: Optional[str] = None,
        parent_ids: Optional[List[str]] = None,
        min_acreage: Optional[float] = None,
        max_acreage: Optional[float] = None,
        ids: Optional[List[str]] = None,
        names: Optional[List[str]] = None,
        property_filters: Optional[List[str]] = None,
        statuses: Optional[List[str]] = None,
        min_created_date_time: Optional[datetime.datetime] = None,
        max_created_date_time: Optional[datetime.datetime] = None,
        min_last_modified_date_time: Optional[datetime.datetime] = None,
        max_last_modified_date_time: Optional[datetime.datetime] = None,
        max_page_size: Optional[int] = 50,
        skip_token: Optional[str] = None,
        **kwargs
    ) -> "_models.BoundaryListResponse":
        """Returns a list of boundaries across all farmers.

        :param is_primary: Is the boundary primary.
        :type is_primary: bool
        :param parent_type: Type of the parent it belongs to.
        :type parent_type: str
        :param parent_ids: Parent Ids of the resource.
        :type parent_ids: list[str]
        :param min_acreage: Minimum acreage of the boundary (inclusive).
        :type min_acreage: float
        :param max_acreage: Maximum acreage of the boundary (inclusive).
        :type max_acreage: float
        :param ids: Ids of the resource.
        :type ids: list[str]
        :param names: Names of the resource.
        :type names: list[str]
        :param property_filters: Filters on key-value pairs within the Properties object.
         eg. "{testkey} eq {testvalue}".
        :type property_filters: list[str]
        :param statuses: Statuses of the resource.
        :type statuses: list[str]
        :param min_created_date_time: Minimum creation date of resource (inclusive).
        :type min_created_date_time: ~datetime.datetime
        :param max_created_date_time: Maximum creation date of resource (inclusive).
        :type max_created_date_time: ~datetime.datetime
        :param min_last_modified_date_time: Minimum last modified date of resource (inclusive).
        :type min_last_modified_date_time: ~datetime.datetime
        :param max_last_modified_date_time: Maximum last modified date of resource (inclusive).
        :type max_last_modified_date_time: ~datetime.datetime
        :param max_page_size: Maximum number of items needed (inclusive).
         Minimum = 10, Maximum = 1000, Default value = 50.
        :type max_page_size: int
        :param skip_token: Skip token for getting next set of results.
        :type skip_token: str
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: BoundaryListResponse, or the result of cls(response)
        :rtype: ~dpsclient.models.BoundaryListResponse
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType["_models.BoundaryListResponse"]
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}))
        api_version = "2020-12-31-preview"
        accept = "application/json"

        # Construct URL
        url = self.get_all_boundaries.metadata['url']  # type: ignore

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]
        if is_primary is not None:
            query_parameters['isPrimary'] = self._serialize.query("is_primary", is_primary, 'bool')
        if parent_type is not None:
            query_parameters['parentType'] = self._serialize.query("parent_type", parent_type, 'str')
        if parent_ids is not None:
            query_parameters['parentIds'] = [self._serialize.query("parent_ids", q, 'str') if q is not None else '' for q in parent_ids]
        if min_acreage is not None:
            query_parameters['minAcreage'] = self._serialize.query("min_acreage", min_acreage, 'float')
        if max_acreage is not None:
            query_parameters['maxAcreage'] = self._serialize.query("max_acreage", max_acreage, 'float')
        if ids is not None:
            query_parameters['ids'] = [self._serialize.query("ids", q, 'str') if q is not None else '' for q in ids]
        if names is not None:
            query_parameters['names'] = [self._serialize.query("names", q, 'str') if q is not None else '' for q in names]
        if property_filters is not None:
            query_parameters['propertyFilters'] = [self._serialize.query("property_filters", q, 'str') if q is not None else '' for q in property_filters]
        if statuses is not None:
            query_parameters['statuses'] = [self._serialize.query("statuses", q, 'str') if q is not None else '' for q in statuses]
        if min_created_date_time is not None:
            query_parameters['minCreatedDateTime'] = self._serialize.query("min_created_date_time", min_created_date_time, 'iso-8601')
        if max_created_date_time is not None:
            query_parameters['maxCreatedDateTime'] = self._serialize.query("max_created_date_time", max_created_date_time, 'iso-8601')
        if min_last_modified_date_time is not None:
            query_parameters['minLastModifiedDateTime'] = self._serialize.query("min_last_modified_date_time", min_last_modified_date_time, 'iso-8601')
        if max_last_modified_date_time is not None:
            query_parameters['maxLastModifiedDateTime'] = self._serialize.query("max_last_modified_date_time", max_last_modified_date_time, 'iso-8601')
        if max_page_size is not None:
            query_parameters['$maxPageSize'] = self._serialize.query("max_page_size", max_page_size, 'int', maximum=1000, minimum=10)
        if skip_token is not None:
            query_parameters['$skipToken'] = self._serialize.query("skip_token", skip_token, 'str')
        query_parameters['api-version'] = self._serialize.query("api_version", api_version, 'str')

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]
        header_parameters['Accept'] = self._serialize.header("accept", accept, 'str')

        request = self._client.get(url, query_parameters, header_parameters)
        pipeline_response = await self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        deserialized = self._deserialize('BoundaryListResponse', pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized
    get_all_boundaries.metadata = {'url': '/boundaries'}  # type: ignore

    async def get_boundary(
        self,
        farmer_id: str,
        boundary_id: str,
        **kwargs
    ) -> "_models.Boundary":
        """Returns field for the given id.

        :param farmer_id: Id of the farmer.
        :type farmer_id: str
        :param boundary_id: Id of the boundary.
        :type boundary_id: str
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: Boundary, or the result of cls(response)
        :rtype: ~dpsclient.models.Boundary
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType["_models.Boundary"]
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}))
        api_version = "2020-12-31-preview"
        accept = "application/json"

        # Construct URL
        url = self.get_boundary.metadata['url']  # type: ignore
        path_format_arguments = {
            'farmerId': self._serialize.url("farmer_id", farmer_id, 'str'),
            'boundaryId': self._serialize.url("boundary_id", boundary_id, 'str'),
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]
        query_parameters['api-version'] = self._serialize.query("api_version", api_version, 'str')

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]
        header_parameters['Accept'] = self._serialize.header("accept", accept, 'str')

        request = self._client.get(url, query_parameters, header_parameters)
        pipeline_response = await self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        deserialized = self._deserialize('Boundary', pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized
    get_boundary.metadata = {'url': '/farmers/{farmerId}/boundaries/{boundaryId}'}  # type: ignore

    async def create_boundary(
        self,
        farmer_id: str,
        boundary_id: str,
        body: Optional["_models.Boundary"] = None,
        **kwargs
    ) -> "_models.Boundary":
        """Creates new field with given request body.

        :param farmer_id: Id of the associated farmer.
        :type farmer_id: str
        :param boundary_id: Boundary id.
        :type boundary_id: str
        :param body: Boundary object.
        :type body: ~dpsclient.models.Boundary
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: Boundary, or the result of cls(response)
        :rtype: ~dpsclient.models.Boundary
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType["_models.Boundary"]
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}))
        api_version = "2020-12-31-preview"
        content_type = kwargs.pop("content_type", "application/json")
        accept = "application/json"

        # Construct URL
        url = self.create_boundary.metadata['url']  # type: ignore
        path_format_arguments = {
            'farmerId': self._serialize.url("farmer_id", farmer_id, 'str'),
            'boundaryId': self._serialize.url("boundary_id", boundary_id, 'str'),
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]
        query_parameters['api-version'] = self._serialize.query("api_version", api_version, 'str')

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]
        header_parameters['Content-Type'] = self._serialize.header("content_type", content_type, 'str')
        header_parameters['Accept'] = self._serialize.header("accept", accept, 'str')

        body_content_kwargs = {}  # type: Dict[str, Any]
        if body is not None:
            body_content = self._serialize.body(body, 'Boundary')
        else:
            body_content = None
        body_content_kwargs['content'] = body_content
        request = self._client.put(url, query_parameters, header_parameters, **body_content_kwargs)
        pipeline_response = await self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [201]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        deserialized = self._deserialize('Boundary', pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized
    create_boundary.metadata = {'url': '/farmers/{farmerId}/boundaries/{boundaryId}'}  # type: ignore

    async def update_boundary(
        self,
        farmer_id: str,
        boundary_id: str,
        body: Optional["_models.Boundary"] = None,
        **kwargs
    ) -> "_models.Boundary":
        """Creates new field with given request body.

        :param farmer_id: Id of the farmer.
        :type farmer_id: str
        :param boundary_id: Id of the boundary.
        :type boundary_id: str
        :param body: Boundary object.
        :type body: ~dpsclient.models.Boundary
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: Boundary, or the result of cls(response)
        :rtype: ~dpsclient.models.Boundary
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType["_models.Boundary"]
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}))
        api_version = "2020-12-31-preview"
        content_type = kwargs.pop("content_type", "application/json")
        accept = "application/json"

        # Construct URL
        url = self.update_boundary.metadata['url']  # type: ignore
        path_format_arguments = {
            'farmerId': self._serialize.url("farmer_id", farmer_id, 'str'),
            'boundaryId': self._serialize.url("boundary_id", boundary_id, 'str'),
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]
        query_parameters['api-version'] = self._serialize.query("api_version", api_version, 'str')

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]
        header_parameters['Content-Type'] = self._serialize.header("content_type", content_type, 'str')
        header_parameters['Accept'] = self._serialize.header("accept", accept, 'str')

        body_content_kwargs = {}  # type: Dict[str, Any]
        if body is not None:
            body_content = self._serialize.body(body, 'Boundary')
        else:
            body_content = None
        body_content_kwargs['content'] = body_content
        request = self._client.patch(url, query_parameters, header_parameters, **body_content_kwargs)
        pipeline_response = await self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        deserialized = self._deserialize('Boundary', pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized
    update_boundary.metadata = {'url': '/farmers/{farmerId}/boundaries/{boundaryId}'}  # type: ignore

    async def delete_boundary(
        self,
        farmer_id: str,
        boundary_id: str,
        **kwargs
    ) -> None:
        """Creates new field with given request body.

        :param farmer_id: Id of the farmer.
        :type farmer_id: str
        :param boundary_id: Id of the boundary.
        :type boundary_id: str
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: None, or the result of cls(response)
        :rtype: None
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType[None]
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}))
        api_version = "2020-12-31-preview"

        # Construct URL
        url = self.delete_boundary.metadata['url']  # type: ignore
        path_format_arguments = {
            'farmerId': self._serialize.url("farmer_id", farmer_id, 'str'),
            'boundaryId': self._serialize.url("boundary_id", boundary_id, 'str'),
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]
        query_parameters['api-version'] = self._serialize.query("api_version", api_version, 'str')

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]

        request = self._client.delete(url, query_parameters, header_parameters)
        pipeline_response = await self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if cls:
            return cls(pipeline_response, None, {})

    delete_boundary.metadata = {'url': '/farmers/{farmerId}/boundaries/{boundaryId}'}  # type: ignore

    async def create_crop(
        self,
        crop_id: str,
        body: Optional["_models.Crop"] = None,
        **kwargs
    ) -> "_models.Crop":
        """Creates new crop object with given request body.

        :param crop_id: Crop id.
        :type crop_id: str
        :param body: Crop object.
        :type body: ~dpsclient.models.Crop
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: Crop, or the result of cls(response)
        :rtype: ~dpsclient.models.Crop
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType["_models.Crop"]
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}))
        api_version = "2020-12-31-preview"
        content_type = kwargs.pop("content_type", "application/json")
        accept = "application/json"

        # Construct URL
        url = self.create_crop.metadata['url']  # type: ignore
        path_format_arguments = {
            'cropId': self._serialize.url("crop_id", crop_id, 'str'),
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]
        query_parameters['api-version'] = self._serialize.query("api_version", api_version, 'str')

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]
        header_parameters['Content-Type'] = self._serialize.header("content_type", content_type, 'str')
        header_parameters['Accept'] = self._serialize.header("accept", accept, 'str')

        body_content_kwargs = {}  # type: Dict[str, Any]
        if body is not None:
            body_content = self._serialize.body(body, 'Crop')
        else:
            body_content = None
        body_content_kwargs['content'] = body_content
        request = self._client.put(url, query_parameters, header_parameters, **body_content_kwargs)
        pipeline_response = await self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [201]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        deserialized = self._deserialize('Crop', pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized
    create_crop.metadata = {'url': '/crops/{cropId}'}  # type: ignore

    async def get_crop(
        self,
        crop_id: str,
        **kwargs
    ) -> "_models.Crop":
        """Get crop object with given crop id.

        :param crop_id: Crop Id.
        :type crop_id: str
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: Crop, or the result of cls(response)
        :rtype: ~dpsclient.models.Crop
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType["_models.Crop"]
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}))
        api_version = "2020-12-31-preview"
        accept = "application/json"

        # Construct URL
        url = self.get_crop.metadata['url']  # type: ignore
        path_format_arguments = {
            'cropId': self._serialize.url("crop_id", crop_id, 'str'),
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]
        query_parameters['api-version'] = self._serialize.query("api_version", api_version, 'str')

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]
        header_parameters['Accept'] = self._serialize.header("accept", accept, 'str')

        request = self._client.get(url, query_parameters, header_parameters)
        pipeline_response = await self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        deserialized = self._deserialize('Crop', pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized
    get_crop.metadata = {'url': '/crops/{cropId}'}  # type: ignore

    async def update_crop(
        self,
        crop_id: str,
        body: Optional["_models.Crop"] = None,
        **kwargs
    ) -> "_models.Crop":
        """Updates Crop for given crop Id.

        :param crop_id: Id of crop that need to be updated (system-generated).
        :type crop_id: str
        :param body: New state of crop.
        :type body: ~dpsclient.models.Crop
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: Crop, or the result of cls(response)
        :rtype: ~dpsclient.models.Crop
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType["_models.Crop"]
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}))
        api_version = "2020-12-31-preview"
        content_type = kwargs.pop("content_type", "application/json")
        accept = "application/json"

        # Construct URL
        url = self.update_crop.metadata['url']  # type: ignore
        path_format_arguments = {
            'cropId': self._serialize.url("crop_id", crop_id, 'str'),
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]
        query_parameters['api-version'] = self._serialize.query("api_version", api_version, 'str')

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]
        header_parameters['Content-Type'] = self._serialize.header("content_type", content_type, 'str')
        header_parameters['Accept'] = self._serialize.header("accept", accept, 'str')

        body_content_kwargs = {}  # type: Dict[str, Any]
        if body is not None:
            body_content = self._serialize.body(body, 'Crop')
        else:
            body_content = None
        body_content_kwargs['content'] = body_content
        request = self._client.patch(url, query_parameters, header_parameters, **body_content_kwargs)
        pipeline_response = await self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        deserialized = self._deserialize('Crop', pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized
    update_crop.metadata = {'url': '/crops/{cropId}'}  # type: ignore

    async def delete_crop(
        self,
        crop_id: str,
        **kwargs
    ) -> None:
        """Deletes Crop for given crop id.

        :param crop_id: Id of crop to be deleted.
        :type crop_id: str
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: None, or the result of cls(response)
        :rtype: None
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType[None]
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}))
        api_version = "2020-12-31-preview"

        # Construct URL
        url = self.delete_crop.metadata['url']  # type: ignore
        path_format_arguments = {
            'cropId': self._serialize.url("crop_id", crop_id, 'str'),
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]
        query_parameters['api-version'] = self._serialize.query("api_version", api_version, 'str')

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]

        request = self._client.delete(url, query_parameters, header_parameters)
        pipeline_response = await self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if cls:
            return cls(pipeline_response, None, {})

    delete_crop.metadata = {'url': '/crops/{cropId}'}  # type: ignore

    async def get_crops(
        self,
        phenotypes: Optional[List[str]] = None,
        ids: Optional[List[str]] = None,
        names: Optional[List[str]] = None,
        property_filters: Optional[List[str]] = None,
        statuses: Optional[List[str]] = None,
        min_created_date_time: Optional[datetime.datetime] = None,
        max_created_date_time: Optional[datetime.datetime] = None,
        min_last_modified_date_time: Optional[datetime.datetime] = None,
        max_last_modified_date_time: Optional[datetime.datetime] = None,
        max_page_size: Optional[int] = 50,
        skip_token: Optional[str] = None,
        **kwargs
    ) -> "_models.CropListResponse":
        """Returns a list of crops.

        :param phenotypes: Crop phenotypes of the resource.
        :type phenotypes: list[str]
        :param ids: Ids of the resource.
        :type ids: list[str]
        :param names: Names of the resource.
        :type names: list[str]
        :param property_filters: Filters on key-value pairs within the Properties object.
         eg. "{testkey} eq {testvalue}".
        :type property_filters: list[str]
        :param statuses: Statuses of the resource.
        :type statuses: list[str]
        :param min_created_date_time: Minimum creation date of resource (inclusive).
        :type min_created_date_time: ~datetime.datetime
        :param max_created_date_time: Maximum creation date of resource (inclusive).
        :type max_created_date_time: ~datetime.datetime
        :param min_last_modified_date_time: Minimum last modified date of resource (inclusive).
        :type min_last_modified_date_time: ~datetime.datetime
        :param max_last_modified_date_time: Maximum last modified date of resource (inclusive).
        :type max_last_modified_date_time: ~datetime.datetime
        :param max_page_size: Maximum number of items needed (inclusive).
         Minimum = 10, Maximum = 1000, Default value = 50.
        :type max_page_size: int
        :param skip_token: Skip token for getting next set of results.
        :type skip_token: str
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: CropListResponse, or the result of cls(response)
        :rtype: ~dpsclient.models.CropListResponse
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType["_models.CropListResponse"]
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}))
        api_version = "2020-12-31-preview"
        accept = "application/json"

        # Construct URL
        url = self.get_crops.metadata['url']  # type: ignore

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]
        if phenotypes is not None:
            query_parameters['phenotypes'] = [self._serialize.query("phenotypes", q, 'str') if q is not None else '' for q in phenotypes]
        if ids is not None:
            query_parameters['ids'] = [self._serialize.query("ids", q, 'str') if q is not None else '' for q in ids]
        if names is not None:
            query_parameters['names'] = [self._serialize.query("names", q, 'str') if q is not None else '' for q in names]
        if property_filters is not None:
            query_parameters['propertyFilters'] = [self._serialize.query("property_filters", q, 'str') if q is not None else '' for q in property_filters]
        if statuses is not None:
            query_parameters['statuses'] = [self._serialize.query("statuses", q, 'str') if q is not None else '' for q in statuses]
        if min_created_date_time is not None:
            query_parameters['minCreatedDateTime'] = self._serialize.query("min_created_date_time", min_created_date_time, 'iso-8601')
        if max_created_date_time is not None:
            query_parameters['maxCreatedDateTime'] = self._serialize.query("max_created_date_time", max_created_date_time, 'iso-8601')
        if min_last_modified_date_time is not None:
            query_parameters['minLastModifiedDateTime'] = self._serialize.query("min_last_modified_date_time", min_last_modified_date_time, 'iso-8601')
        if max_last_modified_date_time is not None:
            query_parameters['maxLastModifiedDateTime'] = self._serialize.query("max_last_modified_date_time", max_last_modified_date_time, 'iso-8601')
        if max_page_size is not None:
            query_parameters['$maxPageSize'] = self._serialize.query("max_page_size", max_page_size, 'int', maximum=1000, minimum=10)
        if skip_token is not None:
            query_parameters['$skipToken'] = self._serialize.query("skip_token", skip_token, 'str')
        query_parameters['api-version'] = self._serialize.query("api_version", api_version, 'str')

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]
        header_parameters['Accept'] = self._serialize.header("accept", accept, 'str')

        request = self._client.get(url, query_parameters, header_parameters)
        pipeline_response = await self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        deserialized = self._deserialize('CropListResponse', pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized
    get_crops.metadata = {'url': '/crops'}  # type: ignore

    async def create_crop_variety(
        self,
        crop_variety_id: str,
        body: Optional["_models.CropVariety"] = None,
        **kwargs
    ) -> "_models.CropVariety":
        """Creates new cropVariety object with given request body.

        :param crop_variety_id: CropVariety id.
        :type crop_variety_id: str
        :param body: CropVariety object.
        :type body: ~dpsclient.models.CropVariety
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: CropVariety, or the result of cls(response)
        :rtype: ~dpsclient.models.CropVariety
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType["_models.CropVariety"]
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}))
        api_version = "2020-12-31-preview"
        content_type = kwargs.pop("content_type", "application/json")
        accept = "application/json"

        # Construct URL
        url = self.create_crop_variety.metadata['url']  # type: ignore
        path_format_arguments = {
            'cropVarietyId': self._serialize.url("crop_variety_id", crop_variety_id, 'str'),
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]
        query_parameters['api-version'] = self._serialize.query("api_version", api_version, 'str')

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]
        header_parameters['Content-Type'] = self._serialize.header("content_type", content_type, 'str')
        header_parameters['Accept'] = self._serialize.header("accept", accept, 'str')

        body_content_kwargs = {}  # type: Dict[str, Any]
        if body is not None:
            body_content = self._serialize.body(body, 'CropVariety')
        else:
            body_content = None
        body_content_kwargs['content'] = body_content
        request = self._client.put(url, query_parameters, header_parameters, **body_content_kwargs)
        pipeline_response = await self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [201]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        deserialized = self._deserialize('CropVariety', pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized
    create_crop_variety.metadata = {'url': '/cropVarieties/{cropVarietyId}'}  # type: ignore

    async def get_crop_variety(
        self,
        crop_variety_id: str,
        **kwargs
    ) -> "_models.CropVariety":
        """Get cropVariety object with given cropVariety id.

        :param crop_variety_id: CropVariety Id.
        :type crop_variety_id: str
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: CropVariety, or the result of cls(response)
        :rtype: ~dpsclient.models.CropVariety
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType["_models.CropVariety"]
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}))
        api_version = "2020-12-31-preview"
        accept = "application/json"

        # Construct URL
        url = self.get_crop_variety.metadata['url']  # type: ignore
        path_format_arguments = {
            'cropVarietyId': self._serialize.url("crop_variety_id", crop_variety_id, 'str'),
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]
        query_parameters['api-version'] = self._serialize.query("api_version", api_version, 'str')

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]
        header_parameters['Accept'] = self._serialize.header("accept", accept, 'str')

        request = self._client.get(url, query_parameters, header_parameters)
        pipeline_response = await self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        deserialized = self._deserialize('CropVariety', pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized
    get_crop_variety.metadata = {'url': '/cropVarieties/{cropVarietyId}'}  # type: ignore

    async def update_crop_variety(
        self,
        crop_variety_id: str,
        body: Optional["_models.CropVariety"] = None,
        **kwargs
    ) -> "_models.CropVariety":
        """Updates CropVariety for given cropVariety Id.

        :param crop_variety_id: Id of cropVariety that need to be updated (system-generated).
        :type crop_variety_id: str
        :param body: New state of cropVariety.
        :type body: ~dpsclient.models.CropVariety
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: CropVariety, or the result of cls(response)
        :rtype: ~dpsclient.models.CropVariety
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType["_models.CropVariety"]
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}))
        api_version = "2020-12-31-preview"
        content_type = kwargs.pop("content_type", "application/json")
        accept = "application/json"

        # Construct URL
        url = self.update_crop_variety.metadata['url']  # type: ignore
        path_format_arguments = {
            'cropVarietyId': self._serialize.url("crop_variety_id", crop_variety_id, 'str'),
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]
        query_parameters['api-version'] = self._serialize.query("api_version", api_version, 'str')

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]
        header_parameters['Content-Type'] = self._serialize.header("content_type", content_type, 'str')
        header_parameters['Accept'] = self._serialize.header("accept", accept, 'str')

        body_content_kwargs = {}  # type: Dict[str, Any]
        if body is not None:
            body_content = self._serialize.body(body, 'CropVariety')
        else:
            body_content = None
        body_content_kwargs['content'] = body_content
        request = self._client.patch(url, query_parameters, header_parameters, **body_content_kwargs)
        pipeline_response = await self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        deserialized = self._deserialize('CropVariety', pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized
    update_crop_variety.metadata = {'url': '/cropVarieties/{cropVarietyId}'}  # type: ignore

    async def delete_crop_variety(
        self,
        crop_variety_id: str,
        **kwargs
    ) -> None:
        """Deletes CropVariety for given cropVariety id.

        :param crop_variety_id: Id of cropVariety to be deleted.
        :type crop_variety_id: str
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: None, or the result of cls(response)
        :rtype: None
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType[None]
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}))
        api_version = "2020-12-31-preview"

        # Construct URL
        url = self.delete_crop_variety.metadata['url']  # type: ignore
        path_format_arguments = {
            'cropVarietyId': self._serialize.url("crop_variety_id", crop_variety_id, 'str'),
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]
        query_parameters['api-version'] = self._serialize.query("api_version", api_version, 'str')

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]

        request = self._client.delete(url, query_parameters, header_parameters)
        pipeline_response = await self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if cls:
            return cls(pipeline_response, None, {})

    delete_crop_variety.metadata = {'url': '/cropVarieties/{cropVarietyId}'}  # type: ignore

    async def get_crop_varieties(
        self,
        crop_ids: Optional[List[str]] = None,
        brands: Optional[List[str]] = None,
        products: Optional[List[str]] = None,
        ids: Optional[List[str]] = None,
        names: Optional[List[str]] = None,
        property_filters: Optional[List[str]] = None,
        statuses: Optional[List[str]] = None,
        min_created_date_time: Optional[datetime.datetime] = None,
        max_created_date_time: Optional[datetime.datetime] = None,
        min_last_modified_date_time: Optional[datetime.datetime] = None,
        max_last_modified_date_time: Optional[datetime.datetime] = None,
        max_page_size: Optional[int] = 50,
        skip_token: Optional[str] = None,
        **kwargs
    ) -> "_models.CropVarietyListResponse":
        """Returns a list of cropVariety.

        :param crop_ids: CropIds of the resource.
        :type crop_ids: list[str]
        :param brands: Brands of the resource.
        :type brands: list[str]
        :param products: Products of the resource.
        :type products: list[str]
        :param ids: Ids of the resource.
        :type ids: list[str]
        :param names: Names of the resource.
        :type names: list[str]
        :param property_filters: Filters on key-value pairs within the Properties object.
         eg. "{testkey} eq {testvalue}".
        :type property_filters: list[str]
        :param statuses: Statuses of the resource.
        :type statuses: list[str]
        :param min_created_date_time: Minimum creation date of resource (inclusive).
        :type min_created_date_time: ~datetime.datetime
        :param max_created_date_time: Maximum creation date of resource (inclusive).
        :type max_created_date_time: ~datetime.datetime
        :param min_last_modified_date_time: Minimum last modified date of resource (inclusive).
        :type min_last_modified_date_time: ~datetime.datetime
        :param max_last_modified_date_time: Maximum last modified date of resource (inclusive).
        :type max_last_modified_date_time: ~datetime.datetime
        :param max_page_size: Maximum number of items needed (inclusive).
         Minimum = 10, Maximum = 1000, Default value = 50.
        :type max_page_size: int
        :param skip_token: Skip token for getting next set of results.
        :type skip_token: str
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: CropVarietyListResponse, or the result of cls(response)
        :rtype: ~dpsclient.models.CropVarietyListResponse
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType["_models.CropVarietyListResponse"]
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}))
        api_version = "2020-12-31-preview"
        accept = "application/json"

        # Construct URL
        url = self.get_crop_varieties.metadata['url']  # type: ignore

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]
        if crop_ids is not None:
            query_parameters['cropIds'] = [self._serialize.query("crop_ids", q, 'str') if q is not None else '' for q in crop_ids]
        if brands is not None:
            query_parameters['brands'] = [self._serialize.query("brands", q, 'str') if q is not None else '' for q in brands]
        if products is not None:
            query_parameters['products'] = [self._serialize.query("products", q, 'str') if q is not None else '' for q in products]
        if ids is not None:
            query_parameters['ids'] = [self._serialize.query("ids", q, 'str') if q is not None else '' for q in ids]
        if names is not None:
            query_parameters['names'] = [self._serialize.query("names", q, 'str') if q is not None else '' for q in names]
        if property_filters is not None:
            query_parameters['propertyFilters'] = [self._serialize.query("property_filters", q, 'str') if q is not None else '' for q in property_filters]
        if statuses is not None:
            query_parameters['statuses'] = [self._serialize.query("statuses", q, 'str') if q is not None else '' for q in statuses]
        if min_created_date_time is not None:
            query_parameters['minCreatedDateTime'] = self._serialize.query("min_created_date_time", min_created_date_time, 'iso-8601')
        if max_created_date_time is not None:
            query_parameters['maxCreatedDateTime'] = self._serialize.query("max_created_date_time", max_created_date_time, 'iso-8601')
        if min_last_modified_date_time is not None:
            query_parameters['minLastModifiedDateTime'] = self._serialize.query("min_last_modified_date_time", min_last_modified_date_time, 'iso-8601')
        if max_last_modified_date_time is not None:
            query_parameters['maxLastModifiedDateTime'] = self._serialize.query("max_last_modified_date_time", max_last_modified_date_time, 'iso-8601')
        if max_page_size is not None:
            query_parameters['$maxPageSize'] = self._serialize.query("max_page_size", max_page_size, 'int', maximum=1000, minimum=10)
        if skip_token is not None:
            query_parameters['$skipToken'] = self._serialize.query("skip_token", skip_token, 'str')
        query_parameters['api-version'] = self._serialize.query("api_version", api_version, 'str')

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]
        header_parameters['Accept'] = self._serialize.header("accept", accept, 'str')

        request = self._client.get(url, query_parameters, header_parameters)
        pipeline_response = await self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        deserialized = self._deserialize('CropVarietyListResponse', pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized
    get_crop_varieties.metadata = {'url': '/cropVarieties'}  # type: ignore

    async def get_farms(
        self,
        farmer_id: str,
        ids: Optional[List[str]] = None,
        names: Optional[List[str]] = None,
        property_filters: Optional[List[str]] = None,
        statuses: Optional[List[str]] = None,
        min_created_date_time: Optional[datetime.datetime] = None,
        max_created_date_time: Optional[datetime.datetime] = None,
        min_last_modified_date_time: Optional[datetime.datetime] = None,
        max_last_modified_date_time: Optional[datetime.datetime] = None,
        max_page_size: Optional[int] = 50,
        skip_token: Optional[str] = None,
        **kwargs
    ) -> "_models.FarmListResponse":
        """Returns a list of farms.

        :param farmer_id: Id of the farmer.
        :type farmer_id: str
        :param ids: Ids of the resource.
        :type ids: list[str]
        :param names: Names of the resource.
        :type names: list[str]
        :param property_filters: Filters on key-value pairs within the Properties object.
         eg. "{testkey} eq {testvalue}".
        :type property_filters: list[str]
        :param statuses: Statuses of the resource.
        :type statuses: list[str]
        :param min_created_date_time: Minimum creation date of resource (inclusive).
        :type min_created_date_time: ~datetime.datetime
        :param max_created_date_time: Maximum creation date of resource (inclusive).
        :type max_created_date_time: ~datetime.datetime
        :param min_last_modified_date_time: Minimum last modified date of resource (inclusive).
        :type min_last_modified_date_time: ~datetime.datetime
        :param max_last_modified_date_time: Maximum last modified date of resource (inclusive).
        :type max_last_modified_date_time: ~datetime.datetime
        :param max_page_size: Maximum number of items needed (inclusive).
         Minimum = 10, Maximum = 1000, Default value = 50.
        :type max_page_size: int
        :param skip_token: Skip token for getting next set of results.
        :type skip_token: str
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: FarmListResponse, or the result of cls(response)
        :rtype: ~dpsclient.models.FarmListResponse
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType["_models.FarmListResponse"]
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}))
        api_version = "2020-12-31-preview"
        accept = "application/json"

        # Construct URL
        url = self.get_farms.metadata['url']  # type: ignore
        path_format_arguments = {
            'farmerId': self._serialize.url("farmer_id", farmer_id, 'str'),
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]
        if ids is not None:
            query_parameters['ids'] = [self._serialize.query("ids", q, 'str') if q is not None else '' for q in ids]
        if names is not None:
            query_parameters['names'] = [self._serialize.query("names", q, 'str') if q is not None else '' for q in names]
        if property_filters is not None:
            query_parameters['propertyFilters'] = [self._serialize.query("property_filters", q, 'str') if q is not None else '' for q in property_filters]
        if statuses is not None:
            query_parameters['statuses'] = [self._serialize.query("statuses", q, 'str') if q is not None else '' for q in statuses]
        if min_created_date_time is not None:
            query_parameters['minCreatedDateTime'] = self._serialize.query("min_created_date_time", min_created_date_time, 'iso-8601')
        if max_created_date_time is not None:
            query_parameters['maxCreatedDateTime'] = self._serialize.query("max_created_date_time", max_created_date_time, 'iso-8601')
        if min_last_modified_date_time is not None:
            query_parameters['minLastModifiedDateTime'] = self._serialize.query("min_last_modified_date_time", min_last_modified_date_time, 'iso-8601')
        if max_last_modified_date_time is not None:
            query_parameters['maxLastModifiedDateTime'] = self._serialize.query("max_last_modified_date_time", max_last_modified_date_time, 'iso-8601')
        if max_page_size is not None:
            query_parameters['$maxPageSize'] = self._serialize.query("max_page_size", max_page_size, 'int', maximum=1000, minimum=10)
        if skip_token is not None:
            query_parameters['$skipToken'] = self._serialize.query("skip_token", skip_token, 'str')
        query_parameters['api-version'] = self._serialize.query("api_version", api_version, 'str')

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]
        header_parameters['Accept'] = self._serialize.header("accept", accept, 'str')

        request = self._client.get(url, query_parameters, header_parameters)
        pipeline_response = await self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        deserialized = self._deserialize('FarmListResponse', pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized
    get_farms.metadata = {'url': '/farmers/{farmerId}/farms'}  # type: ignore

    async def get_all_farms(
        self,
        ids: Optional[List[str]] = None,
        names: Optional[List[str]] = None,
        property_filters: Optional[List[str]] = None,
        statuses: Optional[List[str]] = None,
        min_created_date_time: Optional[datetime.datetime] = None,
        max_created_date_time: Optional[datetime.datetime] = None,
        min_last_modified_date_time: Optional[datetime.datetime] = None,
        max_last_modified_date_time: Optional[datetime.datetime] = None,
        max_page_size: Optional[int] = 50,
        skip_token: Optional[str] = None,
        **kwargs
    ) -> "_models.FarmListResponse":
        """Returns a list of farms across all farmers.

        :param ids: Ids of the resource.
        :type ids: list[str]
        :param names: Names of the resource.
        :type names: list[str]
        :param property_filters: Filters on key-value pairs within the Properties object.
         eg. "{testkey} eq {testvalue}".
        :type property_filters: list[str]
        :param statuses: Statuses of the resource.
        :type statuses: list[str]
        :param min_created_date_time: Minimum creation date of resource (inclusive).
        :type min_created_date_time: ~datetime.datetime
        :param max_created_date_time: Maximum creation date of resource (inclusive).
        :type max_created_date_time: ~datetime.datetime
        :param min_last_modified_date_time: Minimum last modified date of resource (inclusive).
        :type min_last_modified_date_time: ~datetime.datetime
        :param max_last_modified_date_time: Maximum last modified date of resource (inclusive).
        :type max_last_modified_date_time: ~datetime.datetime
        :param max_page_size: Maximum number of items needed (inclusive).
         Minimum = 10, Maximum = 1000, Default value = 50.
        :type max_page_size: int
        :param skip_token: Skip token for getting next set of results.
        :type skip_token: str
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: FarmListResponse, or the result of cls(response)
        :rtype: ~dpsclient.models.FarmListResponse
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType["_models.FarmListResponse"]
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}))
        api_version = "2020-12-31-preview"
        accept = "application/json"

        # Construct URL
        url = self.get_all_farms.metadata['url']  # type: ignore

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]
        if ids is not None:
            query_parameters['ids'] = [self._serialize.query("ids", q, 'str') if q is not None else '' for q in ids]
        if names is not None:
            query_parameters['names'] = [self._serialize.query("names", q, 'str') if q is not None else '' for q in names]
        if property_filters is not None:
            query_parameters['propertyFilters'] = [self._serialize.query("property_filters", q, 'str') if q is not None else '' for q in property_filters]
        if statuses is not None:
            query_parameters['statuses'] = [self._serialize.query("statuses", q, 'str') if q is not None else '' for q in statuses]
        if min_created_date_time is not None:
            query_parameters['minCreatedDateTime'] = self._serialize.query("min_created_date_time", min_created_date_time, 'iso-8601')
        if max_created_date_time is not None:
            query_parameters['maxCreatedDateTime'] = self._serialize.query("max_created_date_time", max_created_date_time, 'iso-8601')
        if min_last_modified_date_time is not None:
            query_parameters['minLastModifiedDateTime'] = self._serialize.query("min_last_modified_date_time", min_last_modified_date_time, 'iso-8601')
        if max_last_modified_date_time is not None:
            query_parameters['maxLastModifiedDateTime'] = self._serialize.query("max_last_modified_date_time", max_last_modified_date_time, 'iso-8601')
        if max_page_size is not None:
            query_parameters['$maxPageSize'] = self._serialize.query("max_page_size", max_page_size, 'int', maximum=1000, minimum=10)
        if skip_token is not None:
            query_parameters['$skipToken'] = self._serialize.query("skip_token", skip_token, 'str')
        query_parameters['api-version'] = self._serialize.query("api_version", api_version, 'str')

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]
        header_parameters['Accept'] = self._serialize.header("accept", accept, 'str')

        request = self._client.get(url, query_parameters, header_parameters)
        pipeline_response = await self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        deserialized = self._deserialize('FarmListResponse', pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized
    get_all_farms.metadata = {'url': '/farms'}  # type: ignore

    async def get_farm(
        self,
        farmer_id: str,
        farm_id: str,
        **kwargs
    ) -> "_models.Farm":
        """Returns farm for the given id.

        :param farmer_id: Id of the farmer.
        :type farmer_id: str
        :param farm_id: Id of the farm.
        :type farm_id: str
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: Farm, or the result of cls(response)
        :rtype: ~dpsclient.models.Farm
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType["_models.Farm"]
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}))
        api_version = "2020-12-31-preview"
        accept = "application/json"

        # Construct URL
        url = self.get_farm.metadata['url']  # type: ignore
        path_format_arguments = {
            'farmerId': self._serialize.url("farmer_id", farmer_id, 'str'),
            'farmId': self._serialize.url("farm_id", farm_id, 'str'),
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]
        query_parameters['api-version'] = self._serialize.query("api_version", api_version, 'str')

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]
        header_parameters['Accept'] = self._serialize.header("accept", accept, 'str')

        request = self._client.get(url, query_parameters, header_parameters)
        pipeline_response = await self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        deserialized = self._deserialize('Farm', pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized
    get_farm.metadata = {'url': '/farmers/{farmerId}/farms/{farmId}'}  # type: ignore

    async def create_farm(
        self,
        farmer_id: str,
        farm_id: str,
        body: Optional["_models.Farm"] = None,
        **kwargs
    ) -> "_models.Farm":
        """Creates new farm with given request body.

        :param farmer_id: Id of the associated farmer.
        :type farmer_id: str
        :param farm_id: Farm id.
        :type farm_id: str
        :param body: Farm object.
        :type body: ~dpsclient.models.Farm
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: Farm, or the result of cls(response)
        :rtype: ~dpsclient.models.Farm
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType["_models.Farm"]
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}))
        api_version = "2020-12-31-preview"
        content_type = kwargs.pop("content_type", "application/json")
        accept = "application/json"

        # Construct URL
        url = self.create_farm.metadata['url']  # type: ignore
        path_format_arguments = {
            'farmerId': self._serialize.url("farmer_id", farmer_id, 'str'),
            'farmId': self._serialize.url("farm_id", farm_id, 'str'),
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]
        query_parameters['api-version'] = self._serialize.query("api_version", api_version, 'str')

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]
        header_parameters['Content-Type'] = self._serialize.header("content_type", content_type, 'str')
        header_parameters['Accept'] = self._serialize.header("accept", accept, 'str')

        body_content_kwargs = {}  # type: Dict[str, Any]
        if body is not None:
            body_content = self._serialize.body(body, 'Farm')
        else:
            body_content = None
        body_content_kwargs['content'] = body_content
        request = self._client.put(url, query_parameters, header_parameters, **body_content_kwargs)
        pipeline_response = await self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [201]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        deserialized = self._deserialize('Farm', pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized
    create_farm.metadata = {'url': '/farmers/{farmerId}/farms/{farmId}'}  # type: ignore

    async def update_farm(
        self,
        farmer_id: str,
        farm_id: str,
        body: Optional["_models.Farm"] = None,
        **kwargs
    ) -> "_models.Farm":
        """Updates Farm for given farm Id.

        :param farmer_id: Id of the farmer.
        :type farmer_id: str
        :param farm_id: Id of the farm.
        :type farm_id: str
        :param body: New state of farm.
        :type body: ~dpsclient.models.Farm
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: Farm, or the result of cls(response)
        :rtype: ~dpsclient.models.Farm
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType["_models.Farm"]
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}))
        api_version = "2020-12-31-preview"
        content_type = kwargs.pop("content_type", "application/json")
        accept = "application/json"

        # Construct URL
        url = self.update_farm.metadata['url']  # type: ignore
        path_format_arguments = {
            'farmerId': self._serialize.url("farmer_id", farmer_id, 'str'),
            'farmId': self._serialize.url("farm_id", farm_id, 'str'),
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]
        query_parameters['api-version'] = self._serialize.query("api_version", api_version, 'str')

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]
        header_parameters['Content-Type'] = self._serialize.header("content_type", content_type, 'str')
        header_parameters['Accept'] = self._serialize.header("accept", accept, 'str')

        body_content_kwargs = {}  # type: Dict[str, Any]
        if body is not None:
            body_content = self._serialize.body(body, 'Farm')
        else:
            body_content = None
        body_content_kwargs['content'] = body_content
        request = self._client.patch(url, query_parameters, header_parameters, **body_content_kwargs)
        pipeline_response = await self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        deserialized = self._deserialize('Farm', pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized
    update_farm.metadata = {'url': '/farmers/{farmerId}/farms/{farmId}'}  # type: ignore

    async def delete_farm(
        self,
        farmer_id: str,
        farm_id: str,
        **kwargs
    ) -> None:
        """Deletes Farm for given farm id.

        :param farmer_id: Id of the farmer.
        :type farmer_id: str
        :param farm_id: Id of the farm.
        :type farm_id: str
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: None, or the result of cls(response)
        :rtype: None
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType[None]
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}))
        api_version = "2020-12-31-preview"

        # Construct URL
        url = self.delete_farm.metadata['url']  # type: ignore
        path_format_arguments = {
            'farmerId': self._serialize.url("farmer_id", farmer_id, 'str'),
            'farmId': self._serialize.url("farm_id", farm_id, 'str'),
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]
        query_parameters['api-version'] = self._serialize.query("api_version", api_version, 'str')

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]

        request = self._client.delete(url, query_parameters, header_parameters)
        pipeline_response = await self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if cls:
            return cls(pipeline_response, None, {})

    delete_farm.metadata = {'url': '/farmers/{farmerId}/farms/{farmId}'}  # type: ignore

    async def create_farmer(
        self,
        farmer_id: str,
        body: Optional["_models.Farmer"] = None,
        **kwargs
    ) -> "_models.Farmer":
        """Creates new farmer object with given request body.

        :param farmer_id: Farmer id.
        :type farmer_id: str
        :param body: Farmer object.
        :type body: ~dpsclient.models.Farmer
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: Farmer, or the result of cls(response)
        :rtype: ~dpsclient.models.Farmer
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType["_models.Farmer"]
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}))
        api_version = "2020-12-31-preview"
        content_type = kwargs.pop("content_type", "application/json")
        accept = "application/json"

        # Construct URL
        url = self.create_farmer.metadata['url']  # type: ignore
        path_format_arguments = {
            'farmerId': self._serialize.url("farmer_id", farmer_id, 'str'),
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]
        query_parameters['api-version'] = self._serialize.query("api_version", api_version, 'str')

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]
        header_parameters['Content-Type'] = self._serialize.header("content_type", content_type, 'str')
        header_parameters['Accept'] = self._serialize.header("accept", accept, 'str')

        body_content_kwargs = {}  # type: Dict[str, Any]
        if body is not None:
            body_content = self._serialize.body(body, 'Farmer')
        else:
            body_content = None
        body_content_kwargs['content'] = body_content
        request = self._client.put(url, query_parameters, header_parameters, **body_content_kwargs)
        pipeline_response = await self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [201]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        deserialized = self._deserialize('Farmer', pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized
    create_farmer.metadata = {'url': '/farmers/{farmerId}'}  # type: ignore

    async def get_farmer(
        self,
        farmer_id: str,
        **kwargs
    ) -> "_models.Farmer":
        """Get farmer object with given farmer id.

        :param farmer_id: Farmer Id.
        :type farmer_id: str
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: Farmer, or the result of cls(response)
        :rtype: ~dpsclient.models.Farmer
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType["_models.Farmer"]
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}))
        api_version = "2020-12-31-preview"
        accept = "application/json"

        # Construct URL
        url = self.get_farmer.metadata['url']  # type: ignore
        path_format_arguments = {
            'farmerId': self._serialize.url("farmer_id", farmer_id, 'str'),
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]
        query_parameters['api-version'] = self._serialize.query("api_version", api_version, 'str')

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]
        header_parameters['Accept'] = self._serialize.header("accept", accept, 'str')

        request = self._client.get(url, query_parameters, header_parameters)
        pipeline_response = await self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        deserialized = self._deserialize('Farmer', pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized
    get_farmer.metadata = {'url': '/farmers/{farmerId}'}  # type: ignore

    async def update_farmer(
        self,
        farmer_id: str,
        body: Optional["_models.Farmer"] = None,
        **kwargs
    ) -> "_models.Farmer":
        """Updates Farmer for given farmer Id.

        :param farmer_id: Id of farmer that need to be updated (system-generated).
        :type farmer_id: str
        :param body: New state of farmer.
        :type body: ~dpsclient.models.Farmer
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: Farmer, or the result of cls(response)
        :rtype: ~dpsclient.models.Farmer
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType["_models.Farmer"]
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}))
        api_version = "2020-12-31-preview"
        content_type = kwargs.pop("content_type", "application/json")
        accept = "application/json"

        # Construct URL
        url = self.update_farmer.metadata['url']  # type: ignore
        path_format_arguments = {
            'farmerId': self._serialize.url("farmer_id", farmer_id, 'str'),
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]
        query_parameters['api-version'] = self._serialize.query("api_version", api_version, 'str')

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]
        header_parameters['Content-Type'] = self._serialize.header("content_type", content_type, 'str')
        header_parameters['Accept'] = self._serialize.header("accept", accept, 'str')

        body_content_kwargs = {}  # type: Dict[str, Any]
        if body is not None:
            body_content = self._serialize.body(body, 'Farmer')
        else:
            body_content = None
        body_content_kwargs['content'] = body_content
        request = self._client.patch(url, query_parameters, header_parameters, **body_content_kwargs)
        pipeline_response = await self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        deserialized = self._deserialize('Farmer', pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized
    update_farmer.metadata = {'url': '/farmers/{farmerId}'}  # type: ignore

    async def delete_farmer(
        self,
        farmer_id: str,
        **kwargs
    ) -> None:
        """Deletes Farmer for given farmer id.

        :param farmer_id: Id of farmer to be deleted.
        :type farmer_id: str
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: None, or the result of cls(response)
        :rtype: None
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType[None]
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}))
        api_version = "2020-12-31-preview"

        # Construct URL
        url = self.delete_farmer.metadata['url']  # type: ignore
        path_format_arguments = {
            'farmerId': self._serialize.url("farmer_id", farmer_id, 'str'),
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]
        query_parameters['api-version'] = self._serialize.query("api_version", api_version, 'str')

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]

        request = self._client.delete(url, query_parameters, header_parameters)
        pipeline_response = await self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if cls:
            return cls(pipeline_response, None, {})

    delete_farmer.metadata = {'url': '/farmers/{farmerId}'}  # type: ignore

    async def get_farmers(
        self,
        ids: Optional[List[str]] = None,
        names: Optional[List[str]] = None,
        property_filters: Optional[List[str]] = None,
        statuses: Optional[List[str]] = None,
        min_created_date_time: Optional[datetime.datetime] = None,
        max_created_date_time: Optional[datetime.datetime] = None,
        min_last_modified_date_time: Optional[datetime.datetime] = None,
        max_last_modified_date_time: Optional[datetime.datetime] = None,
        max_page_size: Optional[int] = 50,
        skip_token: Optional[str] = None,
        **kwargs
    ) -> "_models.FarmerListResponse":
        """Returns a list of farmers.

        :param ids: Ids of the resource.
        :type ids: list[str]
        :param names: Names of the resource.
        :type names: list[str]
        :param property_filters: Filters on key-value pairs within the Properties object.
         eg. "{testkey} eq {testvalue}".
        :type property_filters: list[str]
        :param statuses: Statuses of the resource.
        :type statuses: list[str]
        :param min_created_date_time: Minimum creation date of resource (inclusive).
        :type min_created_date_time: ~datetime.datetime
        :param max_created_date_time: Maximum creation date of resource (inclusive).
        :type max_created_date_time: ~datetime.datetime
        :param min_last_modified_date_time: Minimum last modified date of resource (inclusive).
        :type min_last_modified_date_time: ~datetime.datetime
        :param max_last_modified_date_time: Maximum last modified date of resource (inclusive).
        :type max_last_modified_date_time: ~datetime.datetime
        :param max_page_size: Maximum number of items needed (inclusive).
         Minimum = 10, Maximum = 1000, Default value = 50.
        :type max_page_size: int
        :param skip_token: Skip token for getting next set of results.
        :type skip_token: str
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: FarmerListResponse, or the result of cls(response)
        :rtype: ~dpsclient.models.FarmerListResponse
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType["_models.FarmerListResponse"]
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}))
        api_version = "2020-12-31-preview"
        accept = "application/json"

        # Construct URL
        url = self.get_farmers.metadata['url']  # type: ignore

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]
        if ids is not None:
            query_parameters['ids'] = [self._serialize.query("ids", q, 'str') if q is not None else '' for q in ids]
        if names is not None:
            query_parameters['names'] = [self._serialize.query("names", q, 'str') if q is not None else '' for q in names]
        if property_filters is not None:
            query_parameters['propertyFilters'] = [self._serialize.query("property_filters", q, 'str') if q is not None else '' for q in property_filters]
        if statuses is not None:
            query_parameters['statuses'] = [self._serialize.query("statuses", q, 'str') if q is not None else '' for q in statuses]
        if min_created_date_time is not None:
            query_parameters['minCreatedDateTime'] = self._serialize.query("min_created_date_time", min_created_date_time, 'iso-8601')
        if max_created_date_time is not None:
            query_parameters['maxCreatedDateTime'] = self._serialize.query("max_created_date_time", max_created_date_time, 'iso-8601')
        if min_last_modified_date_time is not None:
            query_parameters['minLastModifiedDateTime'] = self._serialize.query("min_last_modified_date_time", min_last_modified_date_time, 'iso-8601')
        if max_last_modified_date_time is not None:
            query_parameters['maxLastModifiedDateTime'] = self._serialize.query("max_last_modified_date_time", max_last_modified_date_time, 'iso-8601')
        if max_page_size is not None:
            query_parameters['$maxPageSize'] = self._serialize.query("max_page_size", max_page_size, 'int', maximum=1000, minimum=10)
        if skip_token is not None:
            query_parameters['$skipToken'] = self._serialize.query("skip_token", skip_token, 'str')
        query_parameters['api-version'] = self._serialize.query("api_version", api_version, 'str')

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]
        header_parameters['Accept'] = self._serialize.header("accept", accept, 'str')

        request = self._client.get(url, query_parameters, header_parameters)
        pipeline_response = await self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        deserialized = self._deserialize('FarmerListResponse', pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized
    get_farmers.metadata = {'url': '/farmers'}  # type: ignore

    async def get_field(
        self,
        farmer_id: str,
        field_id: str,
        **kwargs
    ) -> "_models.Field":
        """Get field object with given fieldId.

        :param farmer_id: Id of the farmer.
        :type farmer_id: str
        :param field_id: Id of the field.
        :type field_id: str
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: Field, or the result of cls(response)
        :rtype: ~dpsclient.models.Field
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType["_models.Field"]
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}))
        api_version = "2020-12-31-preview"
        accept = "application/json"

        # Construct URL
        url = self.get_field.metadata['url']  # type: ignore
        path_format_arguments = {
            'farmerId': self._serialize.url("farmer_id", farmer_id, 'str'),
            'fieldId': self._serialize.url("field_id", field_id, 'str'),
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]
        query_parameters['api-version'] = self._serialize.query("api_version", api_version, 'str')

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]
        header_parameters['Accept'] = self._serialize.header("accept", accept, 'str')

        request = self._client.get(url, query_parameters, header_parameters)
        pipeline_response = await self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        deserialized = self._deserialize('Field', pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized
    get_field.metadata = {'url': '/farmers/{farmerId}/fields/{fieldId}'}  # type: ignore

    async def create_field(
        self,
        farmer_id: str,
        field_id: str,
        body: Optional["_models.Field"] = None,
        **kwargs
    ) -> "_models.Field":
        """Creates new field object with given request body.

        :param farmer_id: Id of the associated farmer.
        :type farmer_id: str
        :param field_id: Field id.
        :type field_id: str
        :param body: Field Create object.
        :type body: ~dpsclient.models.Field
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: Field, or the result of cls(response)
        :rtype: ~dpsclient.models.Field
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType["_models.Field"]
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}))
        api_version = "2020-12-31-preview"
        content_type = kwargs.pop("content_type", "application/json")
        accept = "application/json"

        # Construct URL
        url = self.create_field.metadata['url']  # type: ignore
        path_format_arguments = {
            'farmerId': self._serialize.url("farmer_id", farmer_id, 'str'),
            'fieldId': self._serialize.url("field_id", field_id, 'str'),
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]
        query_parameters['api-version'] = self._serialize.query("api_version", api_version, 'str')

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]
        header_parameters['Content-Type'] = self._serialize.header("content_type", content_type, 'str')
        header_parameters['Accept'] = self._serialize.header("accept", accept, 'str')

        body_content_kwargs = {}  # type: Dict[str, Any]
        if body is not None:
            body_content = self._serialize.body(body, 'Field')
        else:
            body_content = None
        body_content_kwargs['content'] = body_content
        request = self._client.put(url, query_parameters, header_parameters, **body_content_kwargs)
        pipeline_response = await self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [201]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        deserialized = self._deserialize('Field', pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized
    create_field.metadata = {'url': '/farmers/{farmerId}/fields/{fieldId}'}  # type: ignore

    async def update_field(
        self,
        farmer_id: str,
        field_id: str,
        body: Optional["_models.Field"] = None,
        **kwargs
    ) -> "_models.Field":
        """Updates Field for given field Id.

        :param farmer_id: Id of the farmer.
        :type farmer_id: str
        :param field_id: Id of the field.
        :type field_id: str
        :param body: New state of field.
        :type body: ~dpsclient.models.Field
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: Field, or the result of cls(response)
        :rtype: ~dpsclient.models.Field
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType["_models.Field"]
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}))
        api_version = "2020-12-31-preview"
        content_type = kwargs.pop("content_type", "application/json")
        accept = "application/json"

        # Construct URL
        url = self.update_field.metadata['url']  # type: ignore
        path_format_arguments = {
            'farmerId': self._serialize.url("farmer_id", farmer_id, 'str'),
            'fieldId': self._serialize.url("field_id", field_id, 'str'),
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]
        query_parameters['api-version'] = self._serialize.query("api_version", api_version, 'str')

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]
        header_parameters['Content-Type'] = self._serialize.header("content_type", content_type, 'str')
        header_parameters['Accept'] = self._serialize.header("accept", accept, 'str')

        body_content_kwargs = {}  # type: Dict[str, Any]
        if body is not None:
            body_content = self._serialize.body(body, 'Field')
        else:
            body_content = None
        body_content_kwargs['content'] = body_content
        request = self._client.patch(url, query_parameters, header_parameters, **body_content_kwargs)
        pipeline_response = await self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        deserialized = self._deserialize('Field', pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized
    update_field.metadata = {'url': '/farmers/{farmerId}/fields/{fieldId}'}  # type: ignore

    async def delete_field(
        self,
        farmer_id: str,
        field_id: str,
        **kwargs
    ) -> None:
        """Deletes Field for given id.

        :param farmer_id: Id of the farmer.
        :type farmer_id: str
        :param field_id: Id of the field.
        :type field_id: str
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: None, or the result of cls(response)
        :rtype: None
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType[None]
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}))
        api_version = "2020-12-31-preview"

        # Construct URL
        url = self.delete_field.metadata['url']  # type: ignore
        path_format_arguments = {
            'farmerId': self._serialize.url("farmer_id", farmer_id, 'str'),
            'fieldId': self._serialize.url("field_id", field_id, 'str'),
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]
        query_parameters['api-version'] = self._serialize.query("api_version", api_version, 'str')

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]

        request = self._client.delete(url, query_parameters, header_parameters)
        pipeline_response = await self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if cls:
            return cls(pipeline_response, None, {})

    delete_field.metadata = {'url': '/farmers/{farmerId}/fields/{fieldId}'}  # type: ignore

    async def get_fields(
        self,
        farmer_id: str,
        farm_ids: Optional[List[str]] = None,
        ids: Optional[List[str]] = None,
        names: Optional[List[str]] = None,
        property_filters: Optional[List[str]] = None,
        statuses: Optional[List[str]] = None,
        min_created_date_time: Optional[datetime.datetime] = None,
        max_created_date_time: Optional[datetime.datetime] = None,
        min_last_modified_date_time: Optional[datetime.datetime] = None,
        max_last_modified_date_time: Optional[datetime.datetime] = None,
        max_page_size: Optional[int] = 50,
        skip_token: Optional[str] = None,
        **kwargs
    ) -> "_models.FieldListResponse":
        """Returns a list of fields.

        :param farmer_id: Id of the Farmer.
        :type farmer_id: str
        :param farm_ids: Farm Ids of the resource.
        :type farm_ids: list[str]
        :param ids: Ids of the resource.
        :type ids: list[str]
        :param names: Names of the resource.
        :type names: list[str]
        :param property_filters: Filters on key-value pairs within the Properties object.
         eg. "{testkey} eq {testvalue}".
        :type property_filters: list[str]
        :param statuses: Statuses of the resource.
        :type statuses: list[str]
        :param min_created_date_time: Minimum creation date of resource (inclusive).
        :type min_created_date_time: ~datetime.datetime
        :param max_created_date_time: Maximum creation date of resource (inclusive).
        :type max_created_date_time: ~datetime.datetime
        :param min_last_modified_date_time: Minimum last modified date of resource (inclusive).
        :type min_last_modified_date_time: ~datetime.datetime
        :param max_last_modified_date_time: Maximum last modified date of resource (inclusive).
        :type max_last_modified_date_time: ~datetime.datetime
        :param max_page_size: Maximum number of items needed (inclusive).
         Minimum = 10, Maximum = 1000, Default value = 50.
        :type max_page_size: int
        :param skip_token: Skip token for getting next set of results.
        :type skip_token: str
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: FieldListResponse, or the result of cls(response)
        :rtype: ~dpsclient.models.FieldListResponse
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType["_models.FieldListResponse"]
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}))
        api_version = "2020-12-31-preview"
        accept = "application/json"

        # Construct URL
        url = self.get_fields.metadata['url']  # type: ignore
        path_format_arguments = {
            'farmerId': self._serialize.url("farmer_id", farmer_id, 'str'),
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]
        if farm_ids is not None:
            query_parameters['farmIds'] = [self._serialize.query("farm_ids", q, 'str') if q is not None else '' for q in farm_ids]
        if ids is not None:
            query_parameters['ids'] = [self._serialize.query("ids", q, 'str') if q is not None else '' for q in ids]
        if names is not None:
            query_parameters['names'] = [self._serialize.query("names", q, 'str') if q is not None else '' for q in names]
        if property_filters is not None:
            query_parameters['propertyFilters'] = [self._serialize.query("property_filters", q, 'str') if q is not None else '' for q in property_filters]
        if statuses is not None:
            query_parameters['statuses'] = [self._serialize.query("statuses", q, 'str') if q is not None else '' for q in statuses]
        if min_created_date_time is not None:
            query_parameters['minCreatedDateTime'] = self._serialize.query("min_created_date_time", min_created_date_time, 'iso-8601')
        if max_created_date_time is not None:
            query_parameters['maxCreatedDateTime'] = self._serialize.query("max_created_date_time", max_created_date_time, 'iso-8601')
        if min_last_modified_date_time is not None:
            query_parameters['minLastModifiedDateTime'] = self._serialize.query("min_last_modified_date_time", min_last_modified_date_time, 'iso-8601')
        if max_last_modified_date_time is not None:
            query_parameters['maxLastModifiedDateTime'] = self._serialize.query("max_last_modified_date_time", max_last_modified_date_time, 'iso-8601')
        if max_page_size is not None:
            query_parameters['$maxPageSize'] = self._serialize.query("max_page_size", max_page_size, 'int', maximum=1000, minimum=10)
        if skip_token is not None:
            query_parameters['$skipToken'] = self._serialize.query("skip_token", skip_token, 'str')
        query_parameters['api-version'] = self._serialize.query("api_version", api_version, 'str')

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]
        header_parameters['Accept'] = self._serialize.header("accept", accept, 'str')

        request = self._client.get(url, query_parameters, header_parameters)
        pipeline_response = await self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        deserialized = self._deserialize('FieldListResponse', pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized
    get_fields.metadata = {'url': '/farmers/{farmerId}/fields'}  # type: ignore

    async def get_all_fields(
        self,
        farm_ids: Optional[List[str]] = None,
        ids: Optional[List[str]] = None,
        names: Optional[List[str]] = None,
        property_filters: Optional[List[str]] = None,
        statuses: Optional[List[str]] = None,
        min_created_date_time: Optional[datetime.datetime] = None,
        max_created_date_time: Optional[datetime.datetime] = None,
        min_last_modified_date_time: Optional[datetime.datetime] = None,
        max_last_modified_date_time: Optional[datetime.datetime] = None,
        max_page_size: Optional[int] = 50,
        skip_token: Optional[str] = None,
        **kwargs
    ) -> "_models.FieldListResponse":
        """Returns a list of fields across all farmers.

        :param farm_ids: Farm Ids of the resource.
        :type farm_ids: list[str]
        :param ids: Ids of the resource.
        :type ids: list[str]
        :param names: Names of the resource.
        :type names: list[str]
        :param property_filters: Filters on key-value pairs within the Properties object.
         eg. "{testkey} eq {testvalue}".
        :type property_filters: list[str]
        :param statuses: Statuses of the resource.
        :type statuses: list[str]
        :param min_created_date_time: Minimum creation date of resource (inclusive).
        :type min_created_date_time: ~datetime.datetime
        :param max_created_date_time: Maximum creation date of resource (inclusive).
        :type max_created_date_time: ~datetime.datetime
        :param min_last_modified_date_time: Minimum last modified date of resource (inclusive).
        :type min_last_modified_date_time: ~datetime.datetime
        :param max_last_modified_date_time: Maximum last modified date of resource (inclusive).
        :type max_last_modified_date_time: ~datetime.datetime
        :param max_page_size: Maximum number of items needed (inclusive).
         Minimum = 10, Maximum = 1000, Default value = 50.
        :type max_page_size: int
        :param skip_token: Skip token for getting next set of results.
        :type skip_token: str
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: FieldListResponse, or the result of cls(response)
        :rtype: ~dpsclient.models.FieldListResponse
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType["_models.FieldListResponse"]
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}))
        api_version = "2020-12-31-preview"
        accept = "application/json"

        # Construct URL
        url = self.get_all_fields.metadata['url']  # type: ignore

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]
        if farm_ids is not None:
            query_parameters['farmIds'] = [self._serialize.query("farm_ids", q, 'str') if q is not None else '' for q in farm_ids]
        if ids is not None:
            query_parameters['ids'] = [self._serialize.query("ids", q, 'str') if q is not None else '' for q in ids]
        if names is not None:
            query_parameters['names'] = [self._serialize.query("names", q, 'str') if q is not None else '' for q in names]
        if property_filters is not None:
            query_parameters['propertyFilters'] = [self._serialize.query("property_filters", q, 'str') if q is not None else '' for q in property_filters]
        if statuses is not None:
            query_parameters['statuses'] = [self._serialize.query("statuses", q, 'str') if q is not None else '' for q in statuses]
        if min_created_date_time is not None:
            query_parameters['minCreatedDateTime'] = self._serialize.query("min_created_date_time", min_created_date_time, 'iso-8601')
        if max_created_date_time is not None:
            query_parameters['maxCreatedDateTime'] = self._serialize.query("max_created_date_time", max_created_date_time, 'iso-8601')
        if min_last_modified_date_time is not None:
            query_parameters['minLastModifiedDateTime'] = self._serialize.query("min_last_modified_date_time", min_last_modified_date_time, 'iso-8601')
        if max_last_modified_date_time is not None:
            query_parameters['maxLastModifiedDateTime'] = self._serialize.query("max_last_modified_date_time", max_last_modified_date_time, 'iso-8601')
        if max_page_size is not None:
            query_parameters['$maxPageSize'] = self._serialize.query("max_page_size", max_page_size, 'int', maximum=1000, minimum=10)
        if skip_token is not None:
            query_parameters['$skipToken'] = self._serialize.query("skip_token", skip_token, 'str')
        query_parameters['api-version'] = self._serialize.query("api_version", api_version, 'str')

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]
        header_parameters['Accept'] = self._serialize.header("accept", accept, 'str')

        request = self._client.get(url, query_parameters, header_parameters)
        pipeline_response = await self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        deserialized = self._deserialize('FieldListResponse', pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized
    get_all_fields.metadata = {'url': '/fields'}  # type: ignore

    async def create_satellite_job(
        self,
        body: Optional["_models.SatelliteIngestionJobRequest"] = None,
        **kwargs
    ) -> "_models.SatelliteIngestionJobResponse":
        """Create a satellite job, controller.

        :param body: Job parameters supplied by user.
        :type body: ~dpsclient.models.SatelliteIngestionJobRequest
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: SatelliteIngestionJobResponse, or the result of cls(response)
        :rtype: ~dpsclient.models.SatelliteIngestionJobResponse
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType["_models.SatelliteIngestionJobResponse"]
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}))
        api_version = "2020-12-31-preview"
        content_type = kwargs.pop("content_type", "application/json")
        accept = "application/json"

        # Construct URL
        url = self.create_satellite_job.metadata['url']  # type: ignore

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]
        query_parameters['api-version'] = self._serialize.query("api_version", api_version, 'str')

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]
        header_parameters['Content-Type'] = self._serialize.header("content_type", content_type, 'str')
        header_parameters['Accept'] = self._serialize.header("accept", accept, 'str')

        body_content_kwargs = {}  # type: Dict[str, Any]
        if body is not None:
            body_content = self._serialize.body(body, 'SatelliteIngestionJobRequest')
        else:
            body_content = None
        body_content_kwargs['content'] = body_content
        request = self._client.post(url, query_parameters, header_parameters, **body_content_kwargs)
        pipeline_response = await self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [202]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        deserialized = self._deserialize('SatelliteIngestionJobResponse', pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized
    create_satellite_job.metadata = {'url': '/jobs/satelliteData'}  # type: ignore

    async def create_weather_job(
        self,
        x_ms_farm_beats_data_provider_key: str,
        x_ms_farm_beats_data_provider_id: Optional[str] = None,
        body: Optional["_models.WeatherIngestionJobRequest"] = None,
        **kwargs
    ) -> "_models.WeatherIngestionJobResponse":
        """Create a weather job.

        :param x_ms_farm_beats_data_provider_key: Weather data provider api key.
        :type x_ms_farm_beats_data_provider_key: str
        :param x_ms_farm_beats_data_provider_id: Weather data provider app id.
        :type x_ms_farm_beats_data_provider_id: str
        :param body: Job parameters supplied by user.
        :type body: ~dpsclient.models.WeatherIngestionJobRequest
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: WeatherIngestionJobResponse, or the result of cls(response)
        :rtype: ~dpsclient.models.WeatherIngestionJobResponse
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType["_models.WeatherIngestionJobResponse"]
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}))
        api_version = "2020-12-31-preview"
        content_type = kwargs.pop("content_type", "application/json")
        accept = "application/json"

        # Construct URL
        url = self.create_weather_job.metadata['url']  # type: ignore

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]
        query_parameters['api-version'] = self._serialize.query("api_version", api_version, 'str')

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]
        if x_ms_farm_beats_data_provider_id is not None:
            header_parameters['x-ms-farmBeats-data-provider-id'] = self._serialize.header("x_ms_farm_beats_data_provider_id", x_ms_farm_beats_data_provider_id, 'str', max_length=200, min_length=2)
        header_parameters['x-ms-farmBeats-data-provider-key'] = self._serialize.header("x_ms_farm_beats_data_provider_key", x_ms_farm_beats_data_provider_key, 'str', max_length=200, min_length=2)
        header_parameters['Content-Type'] = self._serialize.header("content_type", content_type, 'str')
        header_parameters['Accept'] = self._serialize.header("accept", accept, 'str')

        body_content_kwargs = {}  # type: Dict[str, Any]
        if body is not None:
            body_content = self._serialize.body(body, 'WeatherIngestionJobRequest')
        else:
            body_content = None
        body_content_kwargs['content'] = body_content
        request = self._client.post(url, query_parameters, header_parameters, **body_content_kwargs)
        pipeline_response = await self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [202]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        deserialized = self._deserialize('WeatherIngestionJobResponse', pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized
    create_weather_job.metadata = {'url': '/jobs/weatherData'}  # type: ignore

    async def create_cascade_delete_job(
        self,
        body: Optional["_models.CascadeDeleteJobRequest"] = None,
        **kwargs
    ) -> "_models.CascadeDeleteJobResponse":
        """Create a cascade delete job.

        :param body: Job parameters supplied by user.
        :type body: ~dpsclient.models.CascadeDeleteJobRequest
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: CascadeDeleteJobResponse, or the result of cls(response)
        :rtype: ~dpsclient.models.CascadeDeleteJobResponse
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType["_models.CascadeDeleteJobResponse"]
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}))
        api_version = "2020-12-31-preview"
        content_type = kwargs.pop("content_type", "application/json")
        accept = "application/json"

        # Construct URL
        url = self.create_cascade_delete_job.metadata['url']  # type: ignore

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]
        query_parameters['api-version'] = self._serialize.query("api_version", api_version, 'str')

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]
        header_parameters['Content-Type'] = self._serialize.header("content_type", content_type, 'str')
        header_parameters['Accept'] = self._serialize.header("accept", accept, 'str')

        body_content_kwargs = {}  # type: Dict[str, Any]
        if body is not None:
            body_content = self._serialize.body(body, 'CascadeDeleteJobRequest')
        else:
            body_content = None
        body_content_kwargs['content'] = body_content
        request = self._client.post(url, query_parameters, header_parameters, **body_content_kwargs)
        pipeline_response = await self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        deserialized = self._deserialize('CascadeDeleteJobResponse', pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized
    create_cascade_delete_job.metadata = {'url': '/jobs/cascadeDelete'}  # type: ignore

    async def create_cascade_status_update_job(
        self,
        body: Optional["_models.CascadeStatusUpdateJobRequest"] = None,
        **kwargs
    ) -> "_models.CascadeStatusUpdateJobResponse":
        """Create a cascade update status job.

        :param body: Job parameters supplied by user.
        :type body: ~dpsclient.models.CascadeStatusUpdateJobRequest
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: CascadeStatusUpdateJobResponse, or the result of cls(response)
        :rtype: ~dpsclient.models.CascadeStatusUpdateJobResponse
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType["_models.CascadeStatusUpdateJobResponse"]
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}))
        api_version = "2020-12-31-preview"
        content_type = kwargs.pop("content_type", "application/json")
        accept = "application/json"

        # Construct URL
        url = self.create_cascade_status_update_job.metadata['url']  # type: ignore

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]
        query_parameters['api-version'] = self._serialize.query("api_version", api_version, 'str')

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]
        header_parameters['Content-Type'] = self._serialize.header("content_type", content_type, 'str')
        header_parameters['Accept'] = self._serialize.header("accept", accept, 'str')

        body_content_kwargs = {}  # type: Dict[str, Any]
        if body is not None:
            body_content = self._serialize.body(body, 'CascadeStatusUpdateJobRequest')
        else:
            body_content = None
        body_content_kwargs['content'] = body_content
        request = self._client.post(url, query_parameters, header_parameters, **body_content_kwargs)
        pipeline_response = await self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        deserialized = self._deserialize('CascadeStatusUpdateJobResponse', pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized
    create_cascade_status_update_job.metadata = {'url': '/jobs/cascadeUpdateStatus'}  # type: ignore

    async def get_job(
        self,
        job_id: str,
        **kwargs
    ) -> "_models.JobResponse":
        """Get a job's details.

        :param job_id: Id of the job.
        :type job_id: str
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: JobResponse, or the result of cls(response)
        :rtype: ~dpsclient.models.JobResponse
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType["_models.JobResponse"]
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}))
        api_version = "2020-12-31-preview"
        accept = "application/json"

        # Construct URL
        url = self.get_job.metadata['url']  # type: ignore
        path_format_arguments = {
            'jobId': self._serialize.url("job_id", job_id, 'str'),
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]
        query_parameters['api-version'] = self._serialize.query("api_version", api_version, 'str')

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]
        header_parameters['Accept'] = self._serialize.header("accept", accept, 'str')

        request = self._client.get(url, query_parameters, header_parameters)
        pipeline_response = await self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        deserialized = self._deserialize('JobResponse', pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized
    get_job.metadata = {'url': '/jobs/{jobId}'}  # type: ignore

    async def cancel_job(
        self,
        job_id: str,
        **kwargs
    ) -> "_models.JobResponse":
        """Cancel a job.

        :param job_id: Id of the job.
        :type job_id: str
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: JobResponse, or the result of cls(response)
        :rtype: ~dpsclient.models.JobResponse
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType["_models.JobResponse"]
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}))
        api_version = "2020-12-31-preview"
        accept = "application/json"

        # Construct URL
        url = self.cancel_job.metadata['url']  # type: ignore
        path_format_arguments = {
            'jobId': self._serialize.url("job_id", job_id, 'str'),
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]
        query_parameters['api-version'] = self._serialize.query("api_version", api_version, 'str')

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]
        header_parameters['Accept'] = self._serialize.header("accept", accept, 'str')

        request = self._client.put(url, query_parameters, header_parameters)
        pipeline_response = await self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        deserialized = self._deserialize('JobResponse', pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized
    cancel_job.metadata = {'url': '/jobs/{jobId}/cancel'}  # type: ignore

    async def get_scenes(
        self,
        farmer_id: str,
        boundary_id: str,
        provider: str = "Microsoft",
        source: Optional[str] = "Sentinel_2_L2A",
        start_date: Optional[datetime.datetime] = None,
        end_date: Optional[datetime.datetime] = None,
        max_cloud_coverage_percentage: Optional[float] = 100,
        max_dark_pixel_coverage_percentage: Optional[float] = 100,
        image_names: Optional[List[Union[str, "_models.ImageName"]]] = None,
        image_resolutions: Optional[List[Union[str, "_models.ImageResolution"]]] = None,
        image_formats: Optional[List[Union[str, "_models.ImageFormat"]]] = None,
        max_page_size: Optional[int] = 50,
        skip_token: Optional[str] = None,
        **kwargs
    ) -> "_models.SceneEntityResponseListResponse":
        """Returns a list of scenes for given query filter.

        :param farmer_id: FarmerId.
        :type farmer_id: str
        :param boundary_id: BoundaryId.
        :type boundary_id: str
        :param provider: Provider name of scene data.
        :type provider: str
        :param source: Source name of scene data, default value Sentinel_2_L2A (Sentinel 2 L2A).
        :type source: str
        :param start_date: Scene start UTC date (inclusive), sample format: yyyy-Mm-ddZ.
        :type start_date: ~datetime.datetime
        :param end_date: Scene end UTC date (inclusive), sample format: yyyy-Mm-ddZ.
        :type end_date: ~datetime.datetime
        :param max_cloud_coverage_percentage: Filter scenes with cloud coverage percentage less than
         max value. Range [0 to 100.0].
        :type max_cloud_coverage_percentage: float
        :param max_dark_pixel_coverage_percentage: Filter scenes with dark pixel coverage percentage
         less than max value. Range [0 to 100.0].
        :type max_dark_pixel_coverage_percentage: float
        :param image_names: List of image names to be filtered (Default: AllImages).
        :type image_names: list[str or ~dpsclient.models.ImageName]
        :param image_resolutions: List of image resolutions in meters to be filtered (Default: 10).
        :type image_resolutions: list[str or ~dpsclient.models.ImageResolution]
        :param image_formats: List of image formats to be filtered (Default: TIF).
        :type image_formats: list[str or ~dpsclient.models.ImageFormat]
        :param max_page_size: Maximum number of items needed (inclusive).
         Minimum = 10, Maximum = 1000, Default value = 50.
        :type max_page_size: int
        :param skip_token: Skip token for getting next set of results.
        :type skip_token: str
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: SceneEntityResponseListResponse, or the result of cls(response)
        :rtype: ~dpsclient.models.SceneEntityResponseListResponse
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType["_models.SceneEntityResponseListResponse"]
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}))
        api_version = "2020-12-31-preview"
        accept = "application/json"

        # Construct URL
        url = self.get_scenes.metadata['url']  # type: ignore

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]
        query_parameters['provider'] = self._serialize.query("provider", provider, 'str')
        query_parameters['farmerId'] = self._serialize.query("farmer_id", farmer_id, 'str')
        query_parameters['boundaryId'] = self._serialize.query("boundary_id", boundary_id, 'str')
        if source is not None:
            query_parameters['source'] = self._serialize.query("source", source, 'str')
        if start_date is not None:
            query_parameters['startDate'] = self._serialize.query("start_date", start_date, 'iso-8601')
        if end_date is not None:
            query_parameters['endDate'] = self._serialize.query("end_date", end_date, 'iso-8601')
        if max_cloud_coverage_percentage is not None:
            query_parameters['maxCloudCoveragePercentage'] = self._serialize.query("max_cloud_coverage_percentage", max_cloud_coverage_percentage, 'float', maximum=100, minimum=0)
        if max_dark_pixel_coverage_percentage is not None:
            query_parameters['maxDarkPixelCoveragePercentage'] = self._serialize.query("max_dark_pixel_coverage_percentage", max_dark_pixel_coverage_percentage, 'float', maximum=100, minimum=0)
        if image_names is not None:
            query_parameters['imageNames'] = [self._serialize.query("image_names", q, 'str') if q is not None else '' for q in image_names]
        if image_resolutions is not None:
            query_parameters['imageResolutions'] = [self._serialize.query("image_resolutions", q, 'str') if q is not None else '' for q in image_resolutions]
        if image_formats is not None:
            query_parameters['imageFormats'] = [self._serialize.query("image_formats", q, 'str') if q is not None else '' for q in image_formats]
        if max_page_size is not None:
            query_parameters['$maxPageSize'] = self._serialize.query("max_page_size", max_page_size, 'int', maximum=1000, minimum=10)
        if skip_token is not None:
            query_parameters['$skipToken'] = self._serialize.query("skip_token", skip_token, 'str')
        query_parameters['api-version'] = self._serialize.query("api_version", api_version, 'str')

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]
        header_parameters['Accept'] = self._serialize.header("accept", accept, 'str')

        request = self._client.get(url, query_parameters, header_parameters)
        pipeline_response = await self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        deserialized = self._deserialize('SceneEntityResponseListResponse', pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized
    get_scenes.metadata = {'url': '/scenes'}  # type: ignore

    async def download_file(
        self,
        file_path: str,
        **kwargs
    ) -> None:
        """Downloads and returns file content as response for the given input filePath.

        :param file_path: cloud storage path of scene file.
        :type file_path: str
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: None, or the result of cls(response)
        :rtype: None
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType[None]
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}))
        api_version = "2020-12-31-preview"

        # Construct URL
        url = self.download_file.metadata['url']  # type: ignore

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]
        query_parameters['filePath'] = self._serialize.query("file_path", file_path, 'str')
        query_parameters['api-version'] = self._serialize.query("api_version", api_version, 'str')

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]

        request = self._client.get(url, query_parameters, header_parameters)
        pipeline_response = await self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if cls:
            return cls(pipeline_response, None, {})

    download_file.metadata = {'url': '/scenes/downloadFiles'}  # type: ignore

    async def create_season(
        self,
        season_id: str,
        body: Optional["_models.Season"] = None,
        **kwargs
    ) -> "_models.Season":
        """Creates new season object with given request body.

        :param season_id: Season id.
        :type season_id: str
        :param body: Season object.
        :type body: ~dpsclient.models.Season
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: Season, or the result of cls(response)
        :rtype: ~dpsclient.models.Season
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType["_models.Season"]
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}))
        api_version = "2020-12-31-preview"
        content_type = kwargs.pop("content_type", "application/json")
        accept = "application/json"

        # Construct URL
        url = self.create_season.metadata['url']  # type: ignore
        path_format_arguments = {
            'seasonId': self._serialize.url("season_id", season_id, 'str'),
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]
        query_parameters['api-version'] = self._serialize.query("api_version", api_version, 'str')

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]
        header_parameters['Content-Type'] = self._serialize.header("content_type", content_type, 'str')
        header_parameters['Accept'] = self._serialize.header("accept", accept, 'str')

        body_content_kwargs = {}  # type: Dict[str, Any]
        if body is not None:
            body_content = self._serialize.body(body, 'Season')
        else:
            body_content = None
        body_content_kwargs['content'] = body_content
        request = self._client.put(url, query_parameters, header_parameters, **body_content_kwargs)
        pipeline_response = await self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [201]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        deserialized = self._deserialize('Season', pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized
    create_season.metadata = {'url': '/seasons/{seasonId}'}  # type: ignore

    async def get_season(
        self,
        season_id: str,
        **kwargs
    ) -> "_models.Season":
        """Get season object with given season id.

        :param season_id: Season Id.
        :type season_id: str
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: Season, or the result of cls(response)
        :rtype: ~dpsclient.models.Season
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType["_models.Season"]
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}))
        api_version = "2020-12-31-preview"
        accept = "application/json"

        # Construct URL
        url = self.get_season.metadata['url']  # type: ignore
        path_format_arguments = {
            'seasonId': self._serialize.url("season_id", season_id, 'str'),
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]
        query_parameters['api-version'] = self._serialize.query("api_version", api_version, 'str')

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]
        header_parameters['Accept'] = self._serialize.header("accept", accept, 'str')

        request = self._client.get(url, query_parameters, header_parameters)
        pipeline_response = await self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        deserialized = self._deserialize('Season', pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized
    get_season.metadata = {'url': '/seasons/{seasonId}'}  # type: ignore

    async def update_season(
        self,
        season_id: str,
        body: Optional["_models.Season"] = None,
        **kwargs
    ) -> "_models.Season":
        """Updates Season for given season Id.

        :param season_id: Id of season that need to be updated (system-generated).
        :type season_id: str
        :param body: New state of season.
        :type body: ~dpsclient.models.Season
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: Season, or the result of cls(response)
        :rtype: ~dpsclient.models.Season
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType["_models.Season"]
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}))
        api_version = "2020-12-31-preview"
        content_type = kwargs.pop("content_type", "application/json")
        accept = "application/json"

        # Construct URL
        url = self.update_season.metadata['url']  # type: ignore
        path_format_arguments = {
            'seasonId': self._serialize.url("season_id", season_id, 'str'),
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]
        query_parameters['api-version'] = self._serialize.query("api_version", api_version, 'str')

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]
        header_parameters['Content-Type'] = self._serialize.header("content_type", content_type, 'str')
        header_parameters['Accept'] = self._serialize.header("accept", accept, 'str')

        body_content_kwargs = {}  # type: Dict[str, Any]
        if body is not None:
            body_content = self._serialize.body(body, 'Season')
        else:
            body_content = None
        body_content_kwargs['content'] = body_content
        request = self._client.patch(url, query_parameters, header_parameters, **body_content_kwargs)
        pipeline_response = await self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        deserialized = self._deserialize('Season', pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized
    update_season.metadata = {'url': '/seasons/{seasonId}'}  # type: ignore

    async def delete_season(
        self,
        season_id: str,
        **kwargs
    ) -> None:
        """Deletes Season for given season id.

        :param season_id: Id of season to be deleted.
        :type season_id: str
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: None, or the result of cls(response)
        :rtype: None
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType[None]
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}))
        api_version = "2020-12-31-preview"

        # Construct URL
        url = self.delete_season.metadata['url']  # type: ignore
        path_format_arguments = {
            'seasonId': self._serialize.url("season_id", season_id, 'str'),
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]
        query_parameters['api-version'] = self._serialize.query("api_version", api_version, 'str')

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]

        request = self._client.delete(url, query_parameters, header_parameters)
        pipeline_response = await self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if cls:
            return cls(pipeline_response, None, {})

    delete_season.metadata = {'url': '/seasons/{seasonId}'}  # type: ignore

    async def get_seasons(
        self,
        min_start_date: Optional[str] = None,
        max_start_date: Optional[str] = None,
        min_end_date: Optional[str] = None,
        max_end_date: Optional[str] = None,
        years: Optional[List[str]] = None,
        ids: Optional[List[str]] = None,
        names: Optional[List[str]] = None,
        property_filters: Optional[List[str]] = None,
        statuses: Optional[List[str]] = None,
        min_created_date_time: Optional[datetime.datetime] = None,
        max_created_date_time: Optional[datetime.datetime] = None,
        min_last_modified_date_time: Optional[datetime.datetime] = None,
        max_last_modified_date_time: Optional[datetime.datetime] = None,
        max_page_size: Optional[int] = 50,
        skip_token: Optional[str] = None,
        **kwargs
    ) -> "_models.SeasonListResponse":
        """Returns a list of seasons.

        :param min_start_date: Minimum season start date in yyyy-MM-dd format.
        :type min_start_date: str
        :param max_start_date: Maximum season start date in yyyy-MM-dd format.
        :type max_start_date: str
        :param min_end_date: Minimum season end date in yyyy-MM-dd format.
        :type min_end_date: str
        :param max_end_date: Maximum season end date in yyyy-MM-dd format.
        :type max_end_date: str
        :param years: Years of the resource.
        :type years: list[str]
        :param ids: Ids of the resource.
        :type ids: list[str]
        :param names: Names of the resource.
        :type names: list[str]
        :param property_filters: Filters on key-value pairs within the Properties object.
         eg. "{testkey} eq {testvalue}".
        :type property_filters: list[str]
        :param statuses: Statuses of the resource.
        :type statuses: list[str]
        :param min_created_date_time: Minimum creation date of resource (inclusive).
        :type min_created_date_time: ~datetime.datetime
        :param max_created_date_time: Maximum creation date of resource (inclusive).
        :type max_created_date_time: ~datetime.datetime
        :param min_last_modified_date_time: Minimum last modified date of resource (inclusive).
        :type min_last_modified_date_time: ~datetime.datetime
        :param max_last_modified_date_time: Maximum last modified date of resource (inclusive).
        :type max_last_modified_date_time: ~datetime.datetime
        :param max_page_size: Maximum number of items needed (inclusive).
         Minimum = 10, Maximum = 1000, Default value = 50.
        :type max_page_size: int
        :param skip_token: Skip token for getting next set of results.
        :type skip_token: str
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: SeasonListResponse, or the result of cls(response)
        :rtype: ~dpsclient.models.SeasonListResponse
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType["_models.SeasonListResponse"]
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}))
        api_version = "2020-12-31-preview"
        accept = "application/json"

        # Construct URL
        url = self.get_seasons.metadata['url']  # type: ignore

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]
        if min_start_date is not None:
            query_parameters['minStartDate'] = self._serialize.query("min_start_date", min_start_date, 'str')
        if max_start_date is not None:
            query_parameters['maxStartDate'] = self._serialize.query("max_start_date", max_start_date, 'str')
        if min_end_date is not None:
            query_parameters['minEndDate'] = self._serialize.query("min_end_date", min_end_date, 'str')
        if max_end_date is not None:
            query_parameters['maxEndDate'] = self._serialize.query("max_end_date", max_end_date, 'str')
        if years is not None:
            query_parameters['years'] = [self._serialize.query("years", q, 'str') if q is not None else '' for q in years]
        if ids is not None:
            query_parameters['ids'] = [self._serialize.query("ids", q, 'str') if q is not None else '' for q in ids]
        if names is not None:
            query_parameters['names'] = [self._serialize.query("names", q, 'str') if q is not None else '' for q in names]
        if property_filters is not None:
            query_parameters['propertyFilters'] = [self._serialize.query("property_filters", q, 'str') if q is not None else '' for q in property_filters]
        if statuses is not None:
            query_parameters['statuses'] = [self._serialize.query("statuses", q, 'str') if q is not None else '' for q in statuses]
        if min_created_date_time is not None:
            query_parameters['minCreatedDateTime'] = self._serialize.query("min_created_date_time", min_created_date_time, 'iso-8601')
        if max_created_date_time is not None:
            query_parameters['maxCreatedDateTime'] = self._serialize.query("max_created_date_time", max_created_date_time, 'iso-8601')
        if min_last_modified_date_time is not None:
            query_parameters['minLastModifiedDateTime'] = self._serialize.query("min_last_modified_date_time", min_last_modified_date_time, 'iso-8601')
        if max_last_modified_date_time is not None:
            query_parameters['maxLastModifiedDateTime'] = self._serialize.query("max_last_modified_date_time", max_last_modified_date_time, 'iso-8601')
        if max_page_size is not None:
            query_parameters['$maxPageSize'] = self._serialize.query("max_page_size", max_page_size, 'int', maximum=1000, minimum=10)
        if skip_token is not None:
            query_parameters['$skipToken'] = self._serialize.query("skip_token", skip_token, 'str')
        query_parameters['api-version'] = self._serialize.query("api_version", api_version, 'str')

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]
        header_parameters['Accept'] = self._serialize.header("accept", accept, 'str')

        request = self._client.get(url, query_parameters, header_parameters)
        pipeline_response = await self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        deserialized = self._deserialize('SeasonListResponse', pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized
    get_seasons.metadata = {'url': '/seasons'}  # type: ignore

    async def get_seasonal_field(
        self,
        farmer_id: str,
        seasonal_field_id: str,
        **kwargs
    ) -> "_models.SeasonalField":
        """Get field object with given fieldId.

        :param farmer_id: Id of the farmer.
        :type farmer_id: str
        :param seasonal_field_id: Id of the seasonalField.
        :type seasonal_field_id: str
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: SeasonalField, or the result of cls(response)
        :rtype: ~dpsclient.models.SeasonalField
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType["_models.SeasonalField"]
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}))
        api_version = "2020-12-31-preview"
        accept = "application/json"

        # Construct URL
        url = self.get_seasonal_field.metadata['url']  # type: ignore
        path_format_arguments = {
            'farmerId': self._serialize.url("farmer_id", farmer_id, 'str'),
            'seasonalFieldId': self._serialize.url("seasonal_field_id", seasonal_field_id, 'str'),
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]
        query_parameters['api-version'] = self._serialize.query("api_version", api_version, 'str')

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]
        header_parameters['Accept'] = self._serialize.header("accept", accept, 'str')

        request = self._client.get(url, query_parameters, header_parameters)
        pipeline_response = await self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        deserialized = self._deserialize('SeasonalField', pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized
    get_seasonal_field.metadata = {'url': '/farmers/{farmerId}/seasonalFields/{seasonalFieldId}'}  # type: ignore

    async def create_seasonal_field(
        self,
        farmer_id: str,
        seasonal_field_id: str,
        body: Optional["_models.SeasonalField"] = None,
        **kwargs
    ) -> "_models.SeasonalField":
        """Creates new field object with given request body.

        :param farmer_id: Id of the associated farmer.
        :type farmer_id: str
        :param seasonal_field_id: SeasonalField id.
        :type seasonal_field_id: str
        :param body: Field object.
        :type body: ~dpsclient.models.SeasonalField
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: SeasonalField, or the result of cls(response)
        :rtype: ~dpsclient.models.SeasonalField
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType["_models.SeasonalField"]
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}))
        api_version = "2020-12-31-preview"
        content_type = kwargs.pop("content_type", "application/json")
        accept = "application/json"

        # Construct URL
        url = self.create_seasonal_field.metadata['url']  # type: ignore
        path_format_arguments = {
            'farmerId': self._serialize.url("farmer_id", farmer_id, 'str'),
            'seasonalFieldId': self._serialize.url("seasonal_field_id", seasonal_field_id, 'str'),
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]
        query_parameters['api-version'] = self._serialize.query("api_version", api_version, 'str')

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]
        header_parameters['Content-Type'] = self._serialize.header("content_type", content_type, 'str')
        header_parameters['Accept'] = self._serialize.header("accept", accept, 'str')

        body_content_kwargs = {}  # type: Dict[str, Any]
        if body is not None:
            body_content = self._serialize.body(body, 'SeasonalField')
        else:
            body_content = None
        body_content_kwargs['content'] = body_content
        request = self._client.put(url, query_parameters, header_parameters, **body_content_kwargs)
        pipeline_response = await self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [201]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        deserialized = self._deserialize('SeasonalField', pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized
    create_seasonal_field.metadata = {'url': '/farmers/{farmerId}/seasonalFields/{seasonalFieldId}'}  # type: ignore

    async def update_seasonal_field(
        self,
        farmer_id: str,
        seasonal_field_id: str,
        body: Optional["_models.SeasonalField"] = None,
        **kwargs
    ) -> "_models.SeasonalField":
        """Updates SeasonalField for given field Id.

        :param farmer_id: Id of the farmer.
        :type farmer_id: str
        :param seasonal_field_id: Id of the seasonalField.
        :type seasonal_field_id: str
        :param body: New state of seasonal field.
        :type body: ~dpsclient.models.SeasonalField
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: SeasonalField, or the result of cls(response)
        :rtype: ~dpsclient.models.SeasonalField
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType["_models.SeasonalField"]
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}))
        api_version = "2020-12-31-preview"
        content_type = kwargs.pop("content_type", "application/json")
        accept = "application/json"

        # Construct URL
        url = self.update_seasonal_field.metadata['url']  # type: ignore
        path_format_arguments = {
            'farmerId': self._serialize.url("farmer_id", farmer_id, 'str'),
            'seasonalFieldId': self._serialize.url("seasonal_field_id", seasonal_field_id, 'str'),
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]
        query_parameters['api-version'] = self._serialize.query("api_version", api_version, 'str')

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]
        header_parameters['Content-Type'] = self._serialize.header("content_type", content_type, 'str')
        header_parameters['Accept'] = self._serialize.header("accept", accept, 'str')

        body_content_kwargs = {}  # type: Dict[str, Any]
        if body is not None:
            body_content = self._serialize.body(body, 'SeasonalField')
        else:
            body_content = None
        body_content_kwargs['content'] = body_content
        request = self._client.patch(url, query_parameters, header_parameters, **body_content_kwargs)
        pipeline_response = await self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        deserialized = self._deserialize('SeasonalField', pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized
    update_seasonal_field.metadata = {'url': '/farmers/{farmerId}/seasonalFields/{seasonalFieldId}'}  # type: ignore

    async def delete_seasonal_field(
        self,
        farmer_id: str,
        seasonal_field_id: str,
        **kwargs
    ) -> None:
        """Deletes SeasonalField for given id.

        :param farmer_id: Id of the farmer.
        :type farmer_id: str
        :param seasonal_field_id: Id of the seasonalField.
        :type seasonal_field_id: str
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: None, or the result of cls(response)
        :rtype: None
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType[None]
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}))
        api_version = "2020-12-31-preview"

        # Construct URL
        url = self.delete_seasonal_field.metadata['url']  # type: ignore
        path_format_arguments = {
            'farmerId': self._serialize.url("farmer_id", farmer_id, 'str'),
            'seasonalFieldId': self._serialize.url("seasonal_field_id", seasonal_field_id, 'str'),
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]
        query_parameters['api-version'] = self._serialize.query("api_version", api_version, 'str')

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]

        request = self._client.delete(url, query_parameters, header_parameters)
        pipeline_response = await self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if cls:
            return cls(pipeline_response, None, {})

    delete_seasonal_field.metadata = {'url': '/farmers/{farmerId}/seasonalFields/{seasonalFieldId}'}  # type: ignore

    async def get_seasonal_fields(
        self,
        farmer_id: str,
        farm_ids: Optional[List[str]] = None,
        field_ids: Optional[List[str]] = None,
        season_ids: Optional[List[str]] = None,
        crop_variety_ids: Optional[List[str]] = None,
        crop_ids: Optional[List[str]] = None,
        min_avg_yield_value: Optional[float] = None,
        max_avg_yield_value: Optional[float] = None,
        avg_yield_unit: Optional[str] = None,
        min_avg_seed_population_value: Optional[float] = None,
        max_avg_seed_population_value: Optional[float] = None,
        avg_seed_population_unit: Optional[str] = None,
        min_planting_date: Optional[str] = None,
        max_planting_date: Optional[str] = None,
        ids: Optional[List[str]] = None,
        names: Optional[List[str]] = None,
        property_filters: Optional[List[str]] = None,
        statuses: Optional[List[str]] = None,
        min_created_date_time: Optional[datetime.datetime] = None,
        max_created_date_time: Optional[datetime.datetime] = None,
        min_last_modified_date_time: Optional[datetime.datetime] = None,
        max_last_modified_date_time: Optional[datetime.datetime] = None,
        max_page_size: Optional[int] = 50,
        skip_token: Optional[str] = None,
        **kwargs
    ) -> "_models.SeasonalFieldListResponse":
        """Returns a list of seasonalFields.

        :param farmer_id: Id of the farmer.
        :type farmer_id: str
        :param farm_ids: Farm Ids of the resource.
        :type farm_ids: list[str]
        :param field_ids: Field Ids of the resource.
        :type field_ids: list[str]
        :param season_ids: Season Ids of the resource.
        :type season_ids: list[str]
        :param crop_variety_ids: CropVarietyIds of the resource.
        :type crop_variety_ids: list[str]
        :param crop_ids: Ids of the crop it belongs to.
        :type crop_ids: list[str]
        :param min_avg_yield_value: Minimum average yield value of the seasonal field(inclusive).
        :type min_avg_yield_value: float
        :param max_avg_yield_value: Maximum average yield value of the seasonal field(inclusive).
        :type max_avg_yield_value: float
        :param avg_yield_unit: Unit of the average yield value attribute.
        :type avg_yield_unit: str
        :param min_avg_seed_population_value: Minimum average seed population value of the seasonal
         field(inclusive).
        :type min_avg_seed_population_value: float
        :param max_avg_seed_population_value: Maximum average seed population value of the seasonal
         field(inclusive).
        :type max_avg_seed_population_value: float
        :param avg_seed_population_unit: Unit of average seed population value attribute.
        :type avg_seed_population_unit: str
        :param min_planting_date: Minimum planting date in yyyy-MM-dd format.
        :type min_planting_date: str
        :param max_planting_date: Maximum planting date in yyyy-MM-dd format.
        :type max_planting_date: str
        :param ids: Ids of the resource.
        :type ids: list[str]
        :param names: Names of the resource.
        :type names: list[str]
        :param property_filters: Filters on key-value pairs within the Properties object.
         eg. "{testkey} eq {testvalue}".
        :type property_filters: list[str]
        :param statuses: Statuses of the resource.
        :type statuses: list[str]
        :param min_created_date_time: Minimum creation date of resource (inclusive).
        :type min_created_date_time: ~datetime.datetime
        :param max_created_date_time: Maximum creation date of resource (inclusive).
        :type max_created_date_time: ~datetime.datetime
        :param min_last_modified_date_time: Minimum last modified date of resource (inclusive).
        :type min_last_modified_date_time: ~datetime.datetime
        :param max_last_modified_date_time: Maximum last modified date of resource (inclusive).
        :type max_last_modified_date_time: ~datetime.datetime
        :param max_page_size: Maximum number of items needed (inclusive).
         Minimum = 10, Maximum = 1000, Default value = 50.
        :type max_page_size: int
        :param skip_token: Skip token for getting next set of results.
        :type skip_token: str
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: SeasonalFieldListResponse, or the result of cls(response)
        :rtype: ~dpsclient.models.SeasonalFieldListResponse
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType["_models.SeasonalFieldListResponse"]
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}))
        api_version = "2020-12-31-preview"
        accept = "application/json"

        # Construct URL
        url = self.get_seasonal_fields.metadata['url']  # type: ignore
        path_format_arguments = {
            'farmerId': self._serialize.url("farmer_id", farmer_id, 'str'),
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]
        if farm_ids is not None:
            query_parameters['farmIds'] = [self._serialize.query("farm_ids", q, 'str') if q is not None else '' for q in farm_ids]
        if field_ids is not None:
            query_parameters['fieldIds'] = [self._serialize.query("field_ids", q, 'str') if q is not None else '' for q in field_ids]
        if season_ids is not None:
            query_parameters['seasonIds'] = [self._serialize.query("season_ids", q, 'str') if q is not None else '' for q in season_ids]
        if crop_variety_ids is not None:
            query_parameters['cropVarietyIds'] = [self._serialize.query("crop_variety_ids", q, 'str') if q is not None else '' for q in crop_variety_ids]
        if crop_ids is not None:
            query_parameters['cropIds'] = [self._serialize.query("crop_ids", q, 'str') if q is not None else '' for q in crop_ids]
        if min_avg_yield_value is not None:
            query_parameters['minAvgYieldValue'] = self._serialize.query("min_avg_yield_value", min_avg_yield_value, 'float')
        if max_avg_yield_value is not None:
            query_parameters['maxAvgYieldValue'] = self._serialize.query("max_avg_yield_value", max_avg_yield_value, 'float')
        if avg_yield_unit is not None:
            query_parameters['avgYieldUnit'] = self._serialize.query("avg_yield_unit", avg_yield_unit, 'str')
        if min_avg_seed_population_value is not None:
            query_parameters['minAvgSeedPopulationValue'] = self._serialize.query("min_avg_seed_population_value", min_avg_seed_population_value, 'float')
        if max_avg_seed_population_value is not None:
            query_parameters['maxAvgSeedPopulationValue'] = self._serialize.query("max_avg_seed_population_value", max_avg_seed_population_value, 'float')
        if avg_seed_population_unit is not None:
            query_parameters['avgSeedPopulationUnit'] = self._serialize.query("avg_seed_population_unit", avg_seed_population_unit, 'str')
        if min_planting_date is not None:
            query_parameters['minPlantingDate'] = self._serialize.query("min_planting_date", min_planting_date, 'str')
        if max_planting_date is not None:
            query_parameters['maxPlantingDate'] = self._serialize.query("max_planting_date", max_planting_date, 'str')
        if ids is not None:
            query_parameters['ids'] = [self._serialize.query("ids", q, 'str') if q is not None else '' for q in ids]
        if names is not None:
            query_parameters['names'] = [self._serialize.query("names", q, 'str') if q is not None else '' for q in names]
        if property_filters is not None:
            query_parameters['propertyFilters'] = [self._serialize.query("property_filters", q, 'str') if q is not None else '' for q in property_filters]
        if statuses is not None:
            query_parameters['statuses'] = [self._serialize.query("statuses", q, 'str') if q is not None else '' for q in statuses]
        if min_created_date_time is not None:
            query_parameters['minCreatedDateTime'] = self._serialize.query("min_created_date_time", min_created_date_time, 'iso-8601')
        if max_created_date_time is not None:
            query_parameters['maxCreatedDateTime'] = self._serialize.query("max_created_date_time", max_created_date_time, 'iso-8601')
        if min_last_modified_date_time is not None:
            query_parameters['minLastModifiedDateTime'] = self._serialize.query("min_last_modified_date_time", min_last_modified_date_time, 'iso-8601')
        if max_last_modified_date_time is not None:
            query_parameters['maxLastModifiedDateTime'] = self._serialize.query("max_last_modified_date_time", max_last_modified_date_time, 'iso-8601')
        if max_page_size is not None:
            query_parameters['$maxPageSize'] = self._serialize.query("max_page_size", max_page_size, 'int', maximum=1000, minimum=10)
        if skip_token is not None:
            query_parameters['$skipToken'] = self._serialize.query("skip_token", skip_token, 'str')
        query_parameters['api-version'] = self._serialize.query("api_version", api_version, 'str')

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]
        header_parameters['Accept'] = self._serialize.header("accept", accept, 'str')

        request = self._client.get(url, query_parameters, header_parameters)
        pipeline_response = await self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        deserialized = self._deserialize('SeasonalFieldListResponse', pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized
    get_seasonal_fields.metadata = {'url': '/farmers/{farmerId}/seasonalFields'}  # type: ignore

    async def get_all_seasonal_fields(
        self,
        farm_ids: Optional[List[str]] = None,
        field_ids: Optional[List[str]] = None,
        season_ids: Optional[List[str]] = None,
        crop_variety_ids: Optional[List[str]] = None,
        crop_ids: Optional[List[str]] = None,
        min_avg_yield_value: Optional[float] = None,
        max_avg_yield_value: Optional[float] = None,
        avg_yield_unit: Optional[str] = None,
        min_avg_seed_population_value: Optional[float] = None,
        max_avg_seed_population_value: Optional[float] = None,
        avg_seed_population_unit: Optional[str] = None,
        min_planting_date: Optional[str] = None,
        max_planting_date: Optional[str] = None,
        ids: Optional[List[str]] = None,
        names: Optional[List[str]] = None,
        property_filters: Optional[List[str]] = None,
        statuses: Optional[List[str]] = None,
        min_created_date_time: Optional[datetime.datetime] = None,
        max_created_date_time: Optional[datetime.datetime] = None,
        min_last_modified_date_time: Optional[datetime.datetime] = None,
        max_last_modified_date_time: Optional[datetime.datetime] = None,
        max_page_size: Optional[int] = 50,
        skip_token: Optional[str] = None,
        **kwargs
    ) -> "_models.SeasonalFieldListResponse":
        """Returns a list of seasonalFields across all farmers.

        :param farm_ids: Farm Ids of the resource.
        :type farm_ids: list[str]
        :param field_ids: Field Ids of the resource.
        :type field_ids: list[str]
        :param season_ids: Season Ids of the resource.
        :type season_ids: list[str]
        :param crop_variety_ids: CropVarietyIds of the resource.
        :type crop_variety_ids: list[str]
        :param crop_ids: Ids of the crop it belongs to.
        :type crop_ids: list[str]
        :param min_avg_yield_value: Minimum average yield value of the seasonal field(inclusive).
        :type min_avg_yield_value: float
        :param max_avg_yield_value: Maximum average yield value of the seasonal field(inclusive).
        :type max_avg_yield_value: float
        :param avg_yield_unit: Unit of the average yield value attribute.
        :type avg_yield_unit: str
        :param min_avg_seed_population_value: Minimum average seed population value of the seasonal
         field(inclusive).
        :type min_avg_seed_population_value: float
        :param max_avg_seed_population_value: Maximum average seed population value of the seasonal
         field(inclusive).
        :type max_avg_seed_population_value: float
        :param avg_seed_population_unit: Unit of average seed population value attribute.
        :type avg_seed_population_unit: str
        :param min_planting_date: Minimum planting date in yyyy-MM-dd format.
        :type min_planting_date: str
        :param max_planting_date: Maximum planting date in yyyy-MM-dd format.
        :type max_planting_date: str
        :param ids: Ids of the resource.
        :type ids: list[str]
        :param names: Names of the resource.
        :type names: list[str]
        :param property_filters: Filters on key-value pairs within the Properties object.
         eg. "{testkey} eq {testvalue}".
        :type property_filters: list[str]
        :param statuses: Statuses of the resource.
        :type statuses: list[str]
        :param min_created_date_time: Minimum creation date of resource (inclusive).
        :type min_created_date_time: ~datetime.datetime
        :param max_created_date_time: Maximum creation date of resource (inclusive).
        :type max_created_date_time: ~datetime.datetime
        :param min_last_modified_date_time: Minimum last modified date of resource (inclusive).
        :type min_last_modified_date_time: ~datetime.datetime
        :param max_last_modified_date_time: Maximum last modified date of resource (inclusive).
        :type max_last_modified_date_time: ~datetime.datetime
        :param max_page_size: Maximum number of items needed (inclusive).
         Minimum = 10, Maximum = 1000, Default value = 50.
        :type max_page_size: int
        :param skip_token: Skip token for getting next set of results.
        :type skip_token: str
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: SeasonalFieldListResponse, or the result of cls(response)
        :rtype: ~dpsclient.models.SeasonalFieldListResponse
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType["_models.SeasonalFieldListResponse"]
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}))
        api_version = "2020-12-31-preview"
        accept = "application/json"

        # Construct URL
        url = self.get_all_seasonal_fields.metadata['url']  # type: ignore

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]
        if farm_ids is not None:
            query_parameters['farmIds'] = [self._serialize.query("farm_ids", q, 'str') if q is not None else '' for q in farm_ids]
        if field_ids is not None:
            query_parameters['fieldIds'] = [self._serialize.query("field_ids", q, 'str') if q is not None else '' for q in field_ids]
        if season_ids is not None:
            query_parameters['seasonIds'] = [self._serialize.query("season_ids", q, 'str') if q is not None else '' for q in season_ids]
        if crop_variety_ids is not None:
            query_parameters['cropVarietyIds'] = [self._serialize.query("crop_variety_ids", q, 'str') if q is not None else '' for q in crop_variety_ids]
        if crop_ids is not None:
            query_parameters['cropIds'] = [self._serialize.query("crop_ids", q, 'str') if q is not None else '' for q in crop_ids]
        if min_avg_yield_value is not None:
            query_parameters['minAvgYieldValue'] = self._serialize.query("min_avg_yield_value", min_avg_yield_value, 'float')
        if max_avg_yield_value is not None:
            query_parameters['maxAvgYieldValue'] = self._serialize.query("max_avg_yield_value", max_avg_yield_value, 'float')
        if avg_yield_unit is not None:
            query_parameters['avgYieldUnit'] = self._serialize.query("avg_yield_unit", avg_yield_unit, 'str')
        if min_avg_seed_population_value is not None:
            query_parameters['minAvgSeedPopulationValue'] = self._serialize.query("min_avg_seed_population_value", min_avg_seed_population_value, 'float')
        if max_avg_seed_population_value is not None:
            query_parameters['maxAvgSeedPopulationValue'] = self._serialize.query("max_avg_seed_population_value", max_avg_seed_population_value, 'float')
        if avg_seed_population_unit is not None:
            query_parameters['avgSeedPopulationUnit'] = self._serialize.query("avg_seed_population_unit", avg_seed_population_unit, 'str')
        if min_planting_date is not None:
            query_parameters['minPlantingDate'] = self._serialize.query("min_planting_date", min_planting_date, 'str')
        if max_planting_date is not None:
            query_parameters['maxPlantingDate'] = self._serialize.query("max_planting_date", max_planting_date, 'str')
        if ids is not None:
            query_parameters['ids'] = [self._serialize.query("ids", q, 'str') if q is not None else '' for q in ids]
        if names is not None:
            query_parameters['names'] = [self._serialize.query("names", q, 'str') if q is not None else '' for q in names]
        if property_filters is not None:
            query_parameters['propertyFilters'] = [self._serialize.query("property_filters", q, 'str') if q is not None else '' for q in property_filters]
        if statuses is not None:
            query_parameters['statuses'] = [self._serialize.query("statuses", q, 'str') if q is not None else '' for q in statuses]
        if min_created_date_time is not None:
            query_parameters['minCreatedDateTime'] = self._serialize.query("min_created_date_time", min_created_date_time, 'iso-8601')
        if max_created_date_time is not None:
            query_parameters['maxCreatedDateTime'] = self._serialize.query("max_created_date_time", max_created_date_time, 'iso-8601')
        if min_last_modified_date_time is not None:
            query_parameters['minLastModifiedDateTime'] = self._serialize.query("min_last_modified_date_time", min_last_modified_date_time, 'iso-8601')
        if max_last_modified_date_time is not None:
            query_parameters['maxLastModifiedDateTime'] = self._serialize.query("max_last_modified_date_time", max_last_modified_date_time, 'iso-8601')
        if max_page_size is not None:
            query_parameters['$maxPageSize'] = self._serialize.query("max_page_size", max_page_size, 'int', maximum=1000, minimum=10)
        if skip_token is not None:
            query_parameters['$skipToken'] = self._serialize.query("skip_token", skip_token, 'str')
        query_parameters['api-version'] = self._serialize.query("api_version", api_version, 'str')

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]
        header_parameters['Accept'] = self._serialize.header("accept", accept, 'str')

        request = self._client.get(url, query_parameters, header_parameters)
        pipeline_response = await self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        deserialized = self._deserialize('SeasonalFieldListResponse', pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized
    get_all_seasonal_fields.metadata = {'url': '/seasonalFields'}  # type: ignore

    async def get_weather_data(
        self,
        farmer_id: str,
        field_id: str,
        extension_id: str,
        weather_data_type: str,
        granularity: str,
        start_date_time: Optional[datetime.datetime] = None,
        end_date_time: Optional[datetime.datetime] = None,
        max_page_size: Optional[int] = 50,
        skip_token: Optional[str] = None,
        **kwargs
    ) -> "_models.WeatherDataListResponse":
        """Returns a list of weather data for the given query filter.

        :param farmer_id: Farmer Id.
        :type farmer_id: str
        :param field_id: Field Id.
        :type field_id: str
        :param extension_id: Id of the weather extension.
        :type extension_id: str
        :param weather_data_type: Type of weather data (forecast/historical).
        :type weather_data_type: str
        :param granularity: Granularity of weather data (daily/hourly).
        :type granularity: str
        :param start_date_time: Weather data start UTC date-time (inclusive), sample format: yyyy-Mm-
         ddTHH:mm:ssZ.
        :type start_date_time: ~datetime.datetime
        :param end_date_time: Weather data end UTC date-time (inclusive), sample format: yyyy-Mm-
         ddTHH:mm:ssZ.
        :type end_date_time: ~datetime.datetime
        :param max_page_size: Maximum number of items needed (inclusive).
         Minimum = 10, Maximum = 1000, Default value = 50.
        :type max_page_size: int
        :param skip_token: Skip token for getting next set of results.
        :type skip_token: str
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: WeatherDataListResponse, or the result of cls(response)
        :rtype: ~dpsclient.models.WeatherDataListResponse
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType["_models.WeatherDataListResponse"]
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}))
        api_version = "2020-12-31-preview"
        accept = "application/json"

        # Construct URL
        url = self.get_weather_data.metadata['url']  # type: ignore

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]
        query_parameters['farmerId'] = self._serialize.query("farmer_id", farmer_id, 'str')
        query_parameters['fieldId'] = self._serialize.query("field_id", field_id, 'str')
        query_parameters['extensionId'] = self._serialize.query("extension_id", extension_id, 'str')
        query_parameters['weatherDataType'] = self._serialize.query("weather_data_type", weather_data_type, 'str', max_length=50, min_length=0)
        query_parameters['granularity'] = self._serialize.query("granularity", granularity, 'str', max_length=50, min_length=0)
        if start_date_time is not None:
            query_parameters['startDateTime'] = self._serialize.query("start_date_time", start_date_time, 'iso-8601')
        if end_date_time is not None:
            query_parameters['endDateTime'] = self._serialize.query("end_date_time", end_date_time, 'iso-8601')
        if max_page_size is not None:
            query_parameters['$maxPageSize'] = self._serialize.query("max_page_size", max_page_size, 'int', maximum=1000, minimum=10)
        if skip_token is not None:
            query_parameters['$skipToken'] = self._serialize.query("skip_token", skip_token, 'str')
        query_parameters['api-version'] = self._serialize.query("api_version", api_version, 'str')

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]
        header_parameters['Accept'] = self._serialize.header("accept", accept, 'str')

        request = self._client.get(url, query_parameters, header_parameters)
        pipeline_response = await self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        deserialized = self._deserialize('WeatherDataListResponse', pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized
    get_weather_data.metadata = {'url': '/weather'}  # type: ignore
