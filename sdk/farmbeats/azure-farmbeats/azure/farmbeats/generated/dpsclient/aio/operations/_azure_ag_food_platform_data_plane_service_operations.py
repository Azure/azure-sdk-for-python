# coding=utf-8
# --------------------------------------------------------------------------
# Code generated by Microsoft (R) AutoRest Code Generator (autorest: 3.1.3, generator: {generator})
# Changes may cause incorrect behavior and will be lost if the code is regenerated.
# --------------------------------------------------------------------------
import datetime
from typing import Any, Callable, Dict, Generic, IO, List, Optional, TypeVar, Union
import warnings

from azure.core.exceptions import ClientAuthenticationError, HttpResponseError, ResourceExistsError, ResourceNotFoundError, map_error
from azure.core.pipeline import PipelineResponse
from azure.core.pipeline.transport import AsyncHttpResponse, HttpRequest

from ... import models as _models

T = TypeVar('T')
ClsType = Optional[Callable[[PipelineResponse[HttpRequest, AsyncHttpResponse], T, Dict[str, Any]], Any]]

class AzureAgFoodPlatformDataPlaneServiceOperationsMixin:

    async def get_application_data(
        self,
        application_data_id: str,
        farmer_id: str,
        **kwargs
    ) -> "_models.ApplicationData":
        """Get ApplicationData object with given id and farmer id.

        :param application_data_id: ApplicationData id.
        :type application_data_id: str
        :param farmer_id: Farmer id.
        :type farmer_id: str
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: ApplicationData, or the result of cls(response)
        :rtype: ~dpsclient.models.ApplicationData
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType["_models.ApplicationData"]
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}))
        api_version = "2020-12-31-preview"
        accept = "application/json"

        # Construct URL
        url = self.get_application_data.metadata['url']  # type: ignore
        path_format_arguments = {
            'applicationDataId': self._serialize.url("application_data_id", application_data_id, 'str'),
            'farmerId': self._serialize.url("farmer_id", farmer_id, 'str'),
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]
        query_parameters['api-version'] = self._serialize.query("api_version", api_version, 'str')

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]
        header_parameters['Accept'] = self._serialize.header("accept", accept, 'str')

        request = self._client.get(url, query_parameters, header_parameters)
        pipeline_response = await self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        deserialized = self._deserialize('ApplicationData', pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized
    get_application_data.metadata = {'url': '/farmers/{farmerId}/applicationData/{applicationDataId}'}  # type: ignore

    async def create_application_data(
        self,
        farmer_id: str,
        application_data_id: str,
        body: Optional["_models.ApplicationData"] = None,
        **kwargs
    ) -> "_models.ApplicationData":
        """Creates new ApplicationData object with given request body.

        :param farmer_id: Id of the associated farmer.
        :type farmer_id: str
        :param application_data_id: ApplicationData id.
        :type application_data_id: str
        :param body: ApplicationData object.
        :type body: ~dpsclient.models.ApplicationData
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: ApplicationData, or the result of cls(response)
        :rtype: ~dpsclient.models.ApplicationData
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType["_models.ApplicationData"]
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}))
        api_version = "2020-12-31-preview"
        content_type = kwargs.pop("content_type", "application/json")
        accept = "application/json"

        # Construct URL
        url = self.create_application_data.metadata['url']  # type: ignore
        path_format_arguments = {
            'farmerId': self._serialize.url("farmer_id", farmer_id, 'str'),
            'applicationDataId': self._serialize.url("application_data_id", application_data_id, 'str'),
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]
        query_parameters['api-version'] = self._serialize.query("api_version", api_version, 'str')

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]
        header_parameters['Content-Type'] = self._serialize.header("content_type", content_type, 'str')
        header_parameters['Accept'] = self._serialize.header("accept", accept, 'str')

        body_content_kwargs = {}  # type: Dict[str, Any]
        if body is not None:
            body_content = self._serialize.body(body, 'ApplicationData')
        else:
            body_content = None
        body_content_kwargs['content'] = body_content
        request = self._client.put(url, query_parameters, header_parameters, **body_content_kwargs)
        pipeline_response = await self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [201]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        deserialized = self._deserialize('ApplicationData', pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized
    create_application_data.metadata = {'url': '/farmers/{farmerId}/applicationData/{applicationDataId}'}  # type: ignore

    async def update_application_data(
        self,
        farmer_id: str,
        application_data_id: str,
        body: Optional["_models.ApplicationData"] = None,
        **kwargs
    ) -> "_models.ApplicationData":
        """Updates ApplicationData object with given request body.

        :param farmer_id: Id of the farmer.
        :type farmer_id: str
        :param application_data_id: Id of the ApplicationData.
        :type application_data_id: str
        :param body: ApplicationData object.
        :type body: ~dpsclient.models.ApplicationData
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: ApplicationData, or the result of cls(response)
        :rtype: ~dpsclient.models.ApplicationData
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType["_models.ApplicationData"]
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}))
        api_version = "2020-12-31-preview"
        content_type = kwargs.pop("content_type", "application/json")
        accept = "application/json"

        # Construct URL
        url = self.update_application_data.metadata['url']  # type: ignore
        path_format_arguments = {
            'farmerId': self._serialize.url("farmer_id", farmer_id, 'str'),
            'applicationDataId': self._serialize.url("application_data_id", application_data_id, 'str'),
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]
        query_parameters['api-version'] = self._serialize.query("api_version", api_version, 'str')

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]
        header_parameters['Content-Type'] = self._serialize.header("content_type", content_type, 'str')
        header_parameters['Accept'] = self._serialize.header("accept", accept, 'str')

        body_content_kwargs = {}  # type: Dict[str, Any]
        if body is not None:
            body_content = self._serialize.body(body, 'ApplicationData')
        else:
            body_content = None
        body_content_kwargs['content'] = body_content
        request = self._client.patch(url, query_parameters, header_parameters, **body_content_kwargs)
        pipeline_response = await self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        deserialized = self._deserialize('ApplicationData', pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized
    update_application_data.metadata = {'url': '/farmers/{farmerId}/applicationData/{applicationDataId}'}  # type: ignore

    async def delete_application_data(
        self,
        farmer_id: str,
        application_data_id: str,
        **kwargs
    ) -> None:
        """Deletes ApplicationData object associated with given id.

        :param farmer_id: Id of the associated farmer.
        :type farmer_id: str
        :param application_data_id: Id of the ApplicationData.
        :type application_data_id: str
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: None, or the result of cls(response)
        :rtype: None
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType[None]
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}))
        api_version = "2020-12-31-preview"

        # Construct URL
        url = self.delete_application_data.metadata['url']  # type: ignore
        path_format_arguments = {
            'farmerId': self._serialize.url("farmer_id", farmer_id, 'str'),
            'applicationDataId': self._serialize.url("application_data_id", application_data_id, 'str'),
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]
        query_parameters['api-version'] = self._serialize.query("api_version", api_version, 'str')

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]

        request = self._client.delete(url, query_parameters, header_parameters)
        pipeline_response = await self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if cls:
            return cls(pipeline_response, None, {})

    delete_application_data.metadata = {'url': '/farmers/{farmerId}/applicationData/{applicationDataId}'}  # type: ignore

    async def get_all_application_data(
        self,
        farmer_id: str,
        min_avg_material: Optional[float] = None,
        max_avg_material: Optional[float] = None,
        min_total_material: Optional[float] = None,
        max_total_material: Optional[float] = None,
        sources: Optional[List[str]] = None,
        associated_boundary_ids: Optional[List[str]] = None,
        operation_boundary_ids: Optional[List[str]] = None,
        min_operation_start_date_time: Optional[datetime.datetime] = None,
        max_operation_start_date_time: Optional[datetime.datetime] = None,
        min_operation_end_date_time: Optional[datetime.datetime] = None,
        max_operation_end_date_time: Optional[datetime.datetime] = None,
        min_operation_modified_date_time: Optional[datetime.datetime] = None,
        max_operation_modified_date_time: Optional[datetime.datetime] = None,
        min_area: Optional[float] = None,
        max_area: Optional[float] = None,
        ids: Optional[List[str]] = None,
        names: Optional[List[str]] = None,
        property_filters: Optional[List[str]] = None,
        statuses: Optional[List[str]] = None,
        min_created_date_time: Optional[datetime.datetime] = None,
        max_created_date_time: Optional[datetime.datetime] = None,
        min_last_modified_date_time: Optional[datetime.datetime] = None,
        max_last_modified_date_time: Optional[datetime.datetime] = None,
        max_page_size: Optional[int] = 50,
        skip_token: Optional[str] = None,
        **kwargs
    ) -> "_models.ApplicationDataListResponse":
        """Returns a list of ApplicationData documents.

        :param farmer_id: Id of the associated farmer.
        :type farmer_id: str
        :param min_avg_material: Minimum AvgMaterial value(inclusive).
        :type min_avg_material: float
        :param max_avg_material: Maximum AvgMaterial value (inclusive).
        :type max_avg_material: float
        :param min_total_material: Minimum TotalMaterial value(inclusive).
        :type min_total_material: float
        :param max_total_material: Maximum TotalMaterial value (inclusive).
        :type max_total_material: float
        :param sources: Source of the operation data.
        :type sources: list[str]
        :param associated_boundary_ids: Boundary ids associated with operation data.
        :type associated_boundary_ids: list[str]
        :param operation_boundary_ids: Operation boundary ids associated with operation data.
        :type operation_boundary_ids: list[str]
        :param min_operation_start_date_time: Minimum operation StartDateTime (inclusive).
        :type min_operation_start_date_time: ~datetime.datetime
        :param max_operation_start_date_time: Maximum operation StartDateTime (inclusive).
        :type max_operation_start_date_time: ~datetime.datetime
        :param min_operation_end_date_time: Minimum operation EndDateTime (inclusive).
        :type min_operation_end_date_time: ~datetime.datetime
        :param max_operation_end_date_time: Maximum operation EndDateTime (inclusive).
        :type max_operation_end_date_time: ~datetime.datetime
        :param min_operation_modified_date_time: Minimum OperationModifiedDateTime (inclusive).
        :type min_operation_modified_date_time: ~datetime.datetime
        :param max_operation_modified_date_time: Maximum OperationModifiedDateTime (inclusive).
        :type max_operation_modified_date_time: ~datetime.datetime
        :param min_area: Minimum Area value(inclusive).
        :type min_area: float
        :param max_area: Maximum Area value (inclusive).
        :type max_area: float
        :param ids: Ids of the resource.
        :type ids: list[str]
        :param names: Names of the resource.
        :type names: list[str]
        :param property_filters: Filters on key-value pairs within the Properties object.
         eg. "{testkey} eq {testvalue}".
        :type property_filters: list[str]
        :param statuses: Statuses of the resource.
        :type statuses: list[str]
        :param min_created_date_time: Minimum creation date of resource (inclusive).
        :type min_created_date_time: ~datetime.datetime
        :param max_created_date_time: Maximum creation date of resource (inclusive).
        :type max_created_date_time: ~datetime.datetime
        :param min_last_modified_date_time: Minimum last modified date of resource (inclusive).
        :type min_last_modified_date_time: ~datetime.datetime
        :param max_last_modified_date_time: Maximum last modified date of resource (inclusive).
        :type max_last_modified_date_time: ~datetime.datetime
        :param max_page_size: Maximum number of items needed (inclusive).
         Minimum = 10, Maximum = 1000, Default value = 50.
        :type max_page_size: int
        :param skip_token: Skip token for getting next set of results.
        :type skip_token: str
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: ApplicationDataListResponse, or the result of cls(response)
        :rtype: ~dpsclient.models.ApplicationDataListResponse
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType["_models.ApplicationDataListResponse"]
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}))
        api_version = "2020-12-31-preview"
        accept = "application/json"

        # Construct URL
        url = self.get_all_application_data.metadata['url']  # type: ignore
        path_format_arguments = {
            'farmerId': self._serialize.url("farmer_id", farmer_id, 'str'),
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]
        if min_avg_material is not None:
            query_parameters['minAvgMaterial'] = self._serialize.query("min_avg_material", min_avg_material, 'float')
        if max_avg_material is not None:
            query_parameters['maxAvgMaterial'] = self._serialize.query("max_avg_material", max_avg_material, 'float')
        if min_total_material is not None:
            query_parameters['minTotalMaterial'] = self._serialize.query("min_total_material", min_total_material, 'float')
        if max_total_material is not None:
            query_parameters['maxTotalMaterial'] = self._serialize.query("max_total_material", max_total_material, 'float')
        if sources is not None:
            query_parameters['sources'] = [self._serialize.query("sources", q, 'str') if q is not None else '' for q in sources]
        if associated_boundary_ids is not None:
            query_parameters['associatedBoundaryIds'] = [self._serialize.query("associated_boundary_ids", q, 'str') if q is not None else '' for q in associated_boundary_ids]
        if operation_boundary_ids is not None:
            query_parameters['operationBoundaryIds'] = [self._serialize.query("operation_boundary_ids", q, 'str') if q is not None else '' for q in operation_boundary_ids]
        if min_operation_start_date_time is not None:
            query_parameters['minOperationStartDateTime'] = self._serialize.query("min_operation_start_date_time", min_operation_start_date_time, 'iso-8601')
        if max_operation_start_date_time is not None:
            query_parameters['maxOperationStartDateTime'] = self._serialize.query("max_operation_start_date_time", max_operation_start_date_time, 'iso-8601')
        if min_operation_end_date_time is not None:
            query_parameters['minOperationEndDateTime'] = self._serialize.query("min_operation_end_date_time", min_operation_end_date_time, 'iso-8601')
        if max_operation_end_date_time is not None:
            query_parameters['maxOperationEndDateTime'] = self._serialize.query("max_operation_end_date_time", max_operation_end_date_time, 'iso-8601')
        if min_operation_modified_date_time is not None:
            query_parameters['minOperationModifiedDateTime'] = self._serialize.query("min_operation_modified_date_time", min_operation_modified_date_time, 'iso-8601')
        if max_operation_modified_date_time is not None:
            query_parameters['maxOperationModifiedDateTime'] = self._serialize.query("max_operation_modified_date_time", max_operation_modified_date_time, 'iso-8601')
        if min_area is not None:
            query_parameters['minArea'] = self._serialize.query("min_area", min_area, 'float')
        if max_area is not None:
            query_parameters['maxArea'] = self._serialize.query("max_area", max_area, 'float')
        if ids is not None:
            query_parameters['ids'] = [self._serialize.query("ids", q, 'str') if q is not None else '' for q in ids]
        if names is not None:
            query_parameters['names'] = [self._serialize.query("names", q, 'str') if q is not None else '' for q in names]
        if property_filters is not None:
            query_parameters['propertyFilters'] = [self._serialize.query("property_filters", q, 'str') if q is not None else '' for q in property_filters]
        if statuses is not None:
            query_parameters['statuses'] = [self._serialize.query("statuses", q, 'str') if q is not None else '' for q in statuses]
        if min_created_date_time is not None:
            query_parameters['minCreatedDateTime'] = self._serialize.query("min_created_date_time", min_created_date_time, 'iso-8601')
        if max_created_date_time is not None:
            query_parameters['maxCreatedDateTime'] = self._serialize.query("max_created_date_time", max_created_date_time, 'iso-8601')
        if min_last_modified_date_time is not None:
            query_parameters['minLastModifiedDateTime'] = self._serialize.query("min_last_modified_date_time", min_last_modified_date_time, 'iso-8601')
        if max_last_modified_date_time is not None:
            query_parameters['maxLastModifiedDateTime'] = self._serialize.query("max_last_modified_date_time", max_last_modified_date_time, 'iso-8601')
        if max_page_size is not None:
            query_parameters['$maxPageSize'] = self._serialize.query("max_page_size", max_page_size, 'int', maximum=1000, minimum=10)
        if skip_token is not None:
            query_parameters['$skipToken'] = self._serialize.query("skip_token", skip_token, 'str')
        query_parameters['api-version'] = self._serialize.query("api_version", api_version, 'str')

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]
        header_parameters['Accept'] = self._serialize.header("accept", accept, 'str')

        request = self._client.get(url, query_parameters, header_parameters)
        pipeline_response = await self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        deserialized = self._deserialize('ApplicationDataListResponse', pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized
    get_all_application_data.metadata = {'url': '/farmers/{farmerId}/applicationData'}  # type: ignore

    async def get_all_application_data_across_farmers(
        self,
        min_avg_material: Optional[float] = None,
        max_avg_material: Optional[float] = None,
        min_total_material: Optional[float] = None,
        max_total_material: Optional[float] = None,
        sources: Optional[List[str]] = None,
        associated_boundary_ids: Optional[List[str]] = None,
        operation_boundary_ids: Optional[List[str]] = None,
        min_operation_start_date_time: Optional[datetime.datetime] = None,
        max_operation_start_date_time: Optional[datetime.datetime] = None,
        min_operation_end_date_time: Optional[datetime.datetime] = None,
        max_operation_end_date_time: Optional[datetime.datetime] = None,
        min_operation_modified_date_time: Optional[datetime.datetime] = None,
        max_operation_modified_date_time: Optional[datetime.datetime] = None,
        min_area: Optional[float] = None,
        max_area: Optional[float] = None,
        ids: Optional[List[str]] = None,
        names: Optional[List[str]] = None,
        property_filters: Optional[List[str]] = None,
        statuses: Optional[List[str]] = None,
        min_created_date_time: Optional[datetime.datetime] = None,
        max_created_date_time: Optional[datetime.datetime] = None,
        min_last_modified_date_time: Optional[datetime.datetime] = None,
        max_last_modified_date_time: Optional[datetime.datetime] = None,
        max_page_size: Optional[int] = 50,
        skip_token: Optional[str] = None,
        **kwargs
    ) -> "_models.ApplicationDataListResponse":
        """Returns a list of ApplicationData documents.

        :param min_avg_material: Minimum AvgMaterial value(inclusive).
        :type min_avg_material: float
        :param max_avg_material: Maximum AvgMaterial value (inclusive).
        :type max_avg_material: float
        :param min_total_material: Minimum TotalMaterial value(inclusive).
        :type min_total_material: float
        :param max_total_material: Maximum TotalMaterial value (inclusive).
        :type max_total_material: float
        :param sources: Source of the operation data.
        :type sources: list[str]
        :param associated_boundary_ids: Boundary ids associated with operation data.
        :type associated_boundary_ids: list[str]
        :param operation_boundary_ids: Operation boundary ids associated with operation data.
        :type operation_boundary_ids: list[str]
        :param min_operation_start_date_time: Minimum operation StartDateTime (inclusive).
        :type min_operation_start_date_time: ~datetime.datetime
        :param max_operation_start_date_time: Maximum operation StartDateTime (inclusive).
        :type max_operation_start_date_time: ~datetime.datetime
        :param min_operation_end_date_time: Minimum operation EndDateTime (inclusive).
        :type min_operation_end_date_time: ~datetime.datetime
        :param max_operation_end_date_time: Maximum operation EndDateTime (inclusive).
        :type max_operation_end_date_time: ~datetime.datetime
        :param min_operation_modified_date_time: Minimum OperationModifiedDateTime (inclusive).
        :type min_operation_modified_date_time: ~datetime.datetime
        :param max_operation_modified_date_time: Maximum OperationModifiedDateTime (inclusive).
        :type max_operation_modified_date_time: ~datetime.datetime
        :param min_area: Minimum Area value(inclusive).
        :type min_area: float
        :param max_area: Maximum Area value (inclusive).
        :type max_area: float
        :param ids: Ids of the resource.
        :type ids: list[str]
        :param names: Names of the resource.
        :type names: list[str]
        :param property_filters: Filters on key-value pairs within the Properties object.
         eg. "{testkey} eq {testvalue}".
        :type property_filters: list[str]
        :param statuses: Statuses of the resource.
        :type statuses: list[str]
        :param min_created_date_time: Minimum creation date of resource (inclusive).
        :type min_created_date_time: ~datetime.datetime
        :param max_created_date_time: Maximum creation date of resource (inclusive).
        :type max_created_date_time: ~datetime.datetime
        :param min_last_modified_date_time: Minimum last modified date of resource (inclusive).
        :type min_last_modified_date_time: ~datetime.datetime
        :param max_last_modified_date_time: Maximum last modified date of resource (inclusive).
        :type max_last_modified_date_time: ~datetime.datetime
        :param max_page_size: Maximum number of items needed (inclusive).
         Minimum = 10, Maximum = 1000, Default value = 50.
        :type max_page_size: int
        :param skip_token: Skip token for getting next set of results.
        :type skip_token: str
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: ApplicationDataListResponse, or the result of cls(response)
        :rtype: ~dpsclient.models.ApplicationDataListResponse
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType["_models.ApplicationDataListResponse"]
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}))
        api_version = "2020-12-31-preview"
        accept = "application/json"

        # Construct URL
        url = self.get_all_application_data_across_farmers.metadata['url']  # type: ignore

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]
        if min_avg_material is not None:
            query_parameters['minAvgMaterial'] = self._serialize.query("min_avg_material", min_avg_material, 'float')
        if max_avg_material is not None:
            query_parameters['maxAvgMaterial'] = self._serialize.query("max_avg_material", max_avg_material, 'float')
        if min_total_material is not None:
            query_parameters['minTotalMaterial'] = self._serialize.query("min_total_material", min_total_material, 'float')
        if max_total_material is not None:
            query_parameters['maxTotalMaterial'] = self._serialize.query("max_total_material", max_total_material, 'float')
        if sources is not None:
            query_parameters['sources'] = [self._serialize.query("sources", q, 'str') if q is not None else '' for q in sources]
        if associated_boundary_ids is not None:
            query_parameters['associatedBoundaryIds'] = [self._serialize.query("associated_boundary_ids", q, 'str') if q is not None else '' for q in associated_boundary_ids]
        if operation_boundary_ids is not None:
            query_parameters['operationBoundaryIds'] = [self._serialize.query("operation_boundary_ids", q, 'str') if q is not None else '' for q in operation_boundary_ids]
        if min_operation_start_date_time is not None:
            query_parameters['minOperationStartDateTime'] = self._serialize.query("min_operation_start_date_time", min_operation_start_date_time, 'iso-8601')
        if max_operation_start_date_time is not None:
            query_parameters['maxOperationStartDateTime'] = self._serialize.query("max_operation_start_date_time", max_operation_start_date_time, 'iso-8601')
        if min_operation_end_date_time is not None:
            query_parameters['minOperationEndDateTime'] = self._serialize.query("min_operation_end_date_time", min_operation_end_date_time, 'iso-8601')
        if max_operation_end_date_time is not None:
            query_parameters['maxOperationEndDateTime'] = self._serialize.query("max_operation_end_date_time", max_operation_end_date_time, 'iso-8601')
        if min_operation_modified_date_time is not None:
            query_parameters['minOperationModifiedDateTime'] = self._serialize.query("min_operation_modified_date_time", min_operation_modified_date_time, 'iso-8601')
        if max_operation_modified_date_time is not None:
            query_parameters['maxOperationModifiedDateTime'] = self._serialize.query("max_operation_modified_date_time", max_operation_modified_date_time, 'iso-8601')
        if min_area is not None:
            query_parameters['minArea'] = self._serialize.query("min_area", min_area, 'float')
        if max_area is not None:
            query_parameters['maxArea'] = self._serialize.query("max_area", max_area, 'float')
        if ids is not None:
            query_parameters['ids'] = [self._serialize.query("ids", q, 'str') if q is not None else '' for q in ids]
        if names is not None:
            query_parameters['names'] = [self._serialize.query("names", q, 'str') if q is not None else '' for q in names]
        if property_filters is not None:
            query_parameters['propertyFilters'] = [self._serialize.query("property_filters", q, 'str') if q is not None else '' for q in property_filters]
        if statuses is not None:
            query_parameters['statuses'] = [self._serialize.query("statuses", q, 'str') if q is not None else '' for q in statuses]
        if min_created_date_time is not None:
            query_parameters['minCreatedDateTime'] = self._serialize.query("min_created_date_time", min_created_date_time, 'iso-8601')
        if max_created_date_time is not None:
            query_parameters['maxCreatedDateTime'] = self._serialize.query("max_created_date_time", max_created_date_time, 'iso-8601')
        if min_last_modified_date_time is not None:
            query_parameters['minLastModifiedDateTime'] = self._serialize.query("min_last_modified_date_time", min_last_modified_date_time, 'iso-8601')
        if max_last_modified_date_time is not None:
            query_parameters['maxLastModifiedDateTime'] = self._serialize.query("max_last_modified_date_time", max_last_modified_date_time, 'iso-8601')
        if max_page_size is not None:
            query_parameters['$maxPageSize'] = self._serialize.query("max_page_size", max_page_size, 'int', maximum=1000, minimum=10)
        if skip_token is not None:
            query_parameters['$skipToken'] = self._serialize.query("skip_token", skip_token, 'str')
        query_parameters['api-version'] = self._serialize.query("api_version", api_version, 'str')

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]
        header_parameters['Accept'] = self._serialize.header("accept", accept, 'str')

        request = self._client.get(url, query_parameters, header_parameters)
        pipeline_response = await self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        deserialized = self._deserialize('ApplicationDataListResponse', pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized
    get_all_application_data_across_farmers.metadata = {'url': '/applicationData'}  # type: ignore

    async def get_attachments(
        self,
        farmer_id: str,
        resource_ids: Optional[List[str]] = None,
        resource_types: Optional[List[str]] = None,
        ids: Optional[List[str]] = None,
        names: Optional[List[str]] = None,
        property_filters: Optional[List[str]] = None,
        statuses: Optional[List[str]] = None,
        min_created_date_time: Optional[datetime.datetime] = None,
        max_created_date_time: Optional[datetime.datetime] = None,
        min_last_modified_date_time: Optional[datetime.datetime] = None,
        max_last_modified_date_time: Optional[datetime.datetime] = None,
        max_page_size: Optional[int] = 50,
        skip_token: Optional[str] = None,
        **kwargs
    ) -> "_models.AttachmentListResponse":
        """Returns a list of attachments.

        :param farmer_id: Id of the associated farmer.
        :type farmer_id: str
        :param resource_ids: Resource Ids of the resource.
        :type resource_ids: list[str]
        :param resource_types: Resource Types of the resource.
        :type resource_types: list[str]
        :param ids: Ids of the resource.
        :type ids: list[str]
        :param names: Names of the resource.
        :type names: list[str]
        :param property_filters: Filters on key-value pairs within the Properties object.
         eg. "{testkey} eq {testvalue}".
        :type property_filters: list[str]
        :param statuses: Statuses of the resource.
        :type statuses: list[str]
        :param min_created_date_time: Minimum creation date of resource (inclusive).
        :type min_created_date_time: ~datetime.datetime
        :param max_created_date_time: Maximum creation date of resource (inclusive).
        :type max_created_date_time: ~datetime.datetime
        :param min_last_modified_date_time: Minimum last modified date of resource (inclusive).
        :type min_last_modified_date_time: ~datetime.datetime
        :param max_last_modified_date_time: Maximum last modified date of resource (inclusive).
        :type max_last_modified_date_time: ~datetime.datetime
        :param max_page_size: Maximum number of items needed (inclusive).
         Minimum = 10, Maximum = 1000, Default value = 50.
        :type max_page_size: int
        :param skip_token: Skip token for getting next set of results.
        :type skip_token: str
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: AttachmentListResponse, or the result of cls(response)
        :rtype: ~dpsclient.models.AttachmentListResponse
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType["_models.AttachmentListResponse"]
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}))
        api_version = "2020-12-31-preview"
        accept = "application/json"

        # Construct URL
        url = self.get_attachments.metadata['url']  # type: ignore
        path_format_arguments = {
            'farmerId': self._serialize.url("farmer_id", farmer_id, 'str'),
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]
        if resource_ids is not None:
            query_parameters['resourceIds'] = [self._serialize.query("resource_ids", q, 'str') if q is not None else '' for q in resource_ids]
        if resource_types is not None:
            query_parameters['resourceTypes'] = [self._serialize.query("resource_types", q, 'str') if q is not None else '' for q in resource_types]
        if ids is not None:
            query_parameters['ids'] = [self._serialize.query("ids", q, 'str') if q is not None else '' for q in ids]
        if names is not None:
            query_parameters['names'] = [self._serialize.query("names", q, 'str') if q is not None else '' for q in names]
        if property_filters is not None:
            query_parameters['propertyFilters'] = [self._serialize.query("property_filters", q, 'str') if q is not None else '' for q in property_filters]
        if statuses is not None:
            query_parameters['statuses'] = [self._serialize.query("statuses", q, 'str') if q is not None else '' for q in statuses]
        if min_created_date_time is not None:
            query_parameters['minCreatedDateTime'] = self._serialize.query("min_created_date_time", min_created_date_time, 'iso-8601')
        if max_created_date_time is not None:
            query_parameters['maxCreatedDateTime'] = self._serialize.query("max_created_date_time", max_created_date_time, 'iso-8601')
        if min_last_modified_date_time is not None:
            query_parameters['minLastModifiedDateTime'] = self._serialize.query("min_last_modified_date_time", min_last_modified_date_time, 'iso-8601')
        if max_last_modified_date_time is not None:
            query_parameters['maxLastModifiedDateTime'] = self._serialize.query("max_last_modified_date_time", max_last_modified_date_time, 'iso-8601')
        if max_page_size is not None:
            query_parameters['$maxPageSize'] = self._serialize.query("max_page_size", max_page_size, 'int', maximum=1000, minimum=10)
        if skip_token is not None:
            query_parameters['$skipToken'] = self._serialize.query("skip_token", skip_token, 'str')
        query_parameters['api-version'] = self._serialize.query("api_version", api_version, 'str')

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]
        header_parameters['Accept'] = self._serialize.header("accept", accept, 'str')

        request = self._client.get(url, query_parameters, header_parameters)
        pipeline_response = await self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        deserialized = self._deserialize('AttachmentListResponse', pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized
    get_attachments.metadata = {'url': '/farmers/{farmerId}/attachments'}  # type: ignore

    async def get_attachment(
        self,
        farmer_id: str,
        attachment_id: str,
        **kwargs
    ) -> "_models.Attachment":
        """Returns attachment for the given id.

        :param farmer_id: Id of the associated farmer.
        :type farmer_id: str
        :param attachment_id: Id of the attachment object.
        :type attachment_id: str
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: Attachment, or the result of cls(response)
        :rtype: ~dpsclient.models.Attachment
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType["_models.Attachment"]
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}))
        api_version = "2020-12-31-preview"
        accept = "application/json"

        # Construct URL
        url = self.get_attachment.metadata['url']  # type: ignore
        path_format_arguments = {
            'farmerId': self._serialize.url("farmer_id", farmer_id, 'str'),
            'attachmentId': self._serialize.url("attachment_id", attachment_id, 'str'),
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]
        query_parameters['api-version'] = self._serialize.query("api_version", api_version, 'str')

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]
        header_parameters['Accept'] = self._serialize.header("accept", accept, 'str')

        request = self._client.get(url, query_parameters, header_parameters)
        pipeline_response = await self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        deserialized = self._deserialize('Attachment', pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized
    get_attachment.metadata = {'url': '/farmers/{farmerId}/attachments/{attachmentId}'}  # type: ignore

    async def create_attachment(
        self,
        farmer_id: str,
        attachment_id: str,
        file: IO,
        farmer_id1: Optional[str] = None,
        resource_id: Optional[str] = None,
        resource_type: Optional[str] = None,
        original_file_name: Optional[str] = None,
        id: Optional[str] = None,
        status: Optional[str] = None,
        created_date_time: Optional[str] = None,
        modified_date_time: Optional[str] = None,
        name: Optional[str] = None,
        description: Optional[str] = None,
        e_tag: Optional[str] = None,
        **kwargs
    ) -> "_models.Attachment":
        """Creates new attachment with given request body.

        :param farmer_id: Id of the associated farmer.
        :type farmer_id: str
        :param attachment_id: Attachment id.
        :type attachment_id: str
        :param file: File of size upto 5mb.
        :type file: IO
        :param farmer_id1: Farmer id for this attachment.
        :type farmer_id1: str
        :param resource_id: Associated Resource id for this attachment.
        :type resource_id: str
        :param resource_type: Associated Resource type for this attachment
         i.e. Farmer, Farm, Field, SeasonalField, Boundary, FarmOperationApplicationData, HarvestData,
         TillageData, PlantingData.
        :type resource_type: str
        :param original_file_name: Original File Name for this attachment.
        :type original_file_name: str
        :param id: Unique id.
        :type id: str
        :param status: Status of the resource.
        :type status: str
        :param created_date_time: Date when resource was created.
        :type created_date_time: str
        :param modified_date_time: Date when resource was last modified.
        :type modified_date_time: str
        :param name: Name to identify resource.
        :type name: str
        :param description: Textual description of resource.
        :type description: str
        :param e_tag: The ETag value to implement optimistic concurrency.
        :type e_tag: str
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: Attachment, or the result of cls(response)
        :rtype: ~dpsclient.models.Attachment
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType["_models.Attachment"]
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}))
        api_version = "2020-12-31-preview"
        content_type = kwargs.pop("content_type", "multipart/form-data")
        accept = "application/json"

        # Construct URL
        url = self.create_attachment.metadata['url']  # type: ignore
        path_format_arguments = {
            'farmerId': self._serialize.url("farmer_id", farmer_id, 'str'),
            'attachmentId': self._serialize.url("attachment_id", attachment_id, 'str'),
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]
        query_parameters['api-version'] = self._serialize.query("api_version", api_version, 'str')

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]
        header_parameters['Content-Type'] = self._serialize.header("content_type", content_type, 'str')
        header_parameters['Accept'] = self._serialize.header("accept", accept, 'str')

        # Construct form data
        _form_content = {
            'file': file,
            'FarmerId': farmer_id1,
            'ResourceId': resource_id,
            'ResourceType': resource_type,
            'OriginalFileName': original_file_name,
            'Id': id,
            'Status': status,
            'CreatedDateTime': created_date_time,
            'ModifiedDateTime': modified_date_time,
            'Name': name,
            'Description': description,
            'ETag': e_tag,
        }
        request = self._client.put(url, query_parameters, header_parameters, form_content=_form_content)
        pipeline_response = await self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [201]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        deserialized = self._deserialize('Attachment', pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized
    create_attachment.metadata = {'url': '/farmers/{farmerId}/attachments/{attachmentId}'}  # type: ignore

    async def update_attachment(
        self,
        farmer_id: str,
        attachment_id: str,
        file: Optional[IO] = None,
        farmer_id1: Optional[str] = None,
        resource_id: Optional[str] = None,
        resource_type: Optional[str] = None,
        original_file_name: Optional[str] = None,
        id: Optional[str] = None,
        status: Optional[str] = None,
        created_date_time: Optional[str] = None,
        modified_date_time: Optional[str] = None,
        name: Optional[str] = None,
        description: Optional[str] = None,
        e_tag: Optional[str] = None,
        **kwargs
    ) -> "_models.Attachment":
        """Updates Attachment for given attachment Id.

        :param farmer_id: Id of the associated farmer.
        :type farmer_id: str
        :param attachment_id: Id of attachment that need to be updated.
        :type attachment_id: str
        :param file: File of size upto 5mb.
        :type file: IO
        :param farmer_id1: Farmer id for this attachment.
        :type farmer_id1: str
        :param resource_id: Associated Resource id for this attachment.
        :type resource_id: str
        :param resource_type: Associated Resource type for this attachment
         i.e. Farmer, Farm, Field, SeasonalField, Boundary, FarmOperationApplicationData, HarvestData,
         TillageData, PlantingData.
        :type resource_type: str
        :param original_file_name: Original File Name for this attachment.
        :type original_file_name: str
        :param id: Unique id.
        :type id: str
        :param status: Status of the resource.
        :type status: str
        :param created_date_time: Date when resource was created.
        :type created_date_time: str
        :param modified_date_time: Date when resource was last modified.
        :type modified_date_time: str
        :param name: Name to identify resource.
        :type name: str
        :param description: Textual description of resource.
        :type description: str
        :param e_tag: The ETag value to implement optimistic concurrency.
        :type e_tag: str
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: Attachment, or the result of cls(response)
        :rtype: ~dpsclient.models.Attachment
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType["_models.Attachment"]
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}))
        api_version = "2020-12-31-preview"
        content_type = kwargs.pop("content_type", "multipart/form-data")
        accept = "application/json"

        # Construct URL
        url = self.update_attachment.metadata['url']  # type: ignore
        path_format_arguments = {
            'farmerId': self._serialize.url("farmer_id", farmer_id, 'str'),
            'attachmentId': self._serialize.url("attachment_id", attachment_id, 'str'),
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]
        query_parameters['api-version'] = self._serialize.query("api_version", api_version, 'str')

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]
        header_parameters['Content-Type'] = self._serialize.header("content_type", content_type, 'str')
        header_parameters['Accept'] = self._serialize.header("accept", accept, 'str')

        # Construct form data
        _form_content = {
            'file': file,
            'FarmerId': farmer_id1,
            'ResourceId': resource_id,
            'ResourceType': resource_type,
            'OriginalFileName': original_file_name,
            'Id': id,
            'Status': status,
            'CreatedDateTime': created_date_time,
            'ModifiedDateTime': modified_date_time,
            'Name': name,
            'Description': description,
            'ETag': e_tag,
        }
        request = self._client.patch(url, query_parameters, header_parameters, form_content=_form_content)
        pipeline_response = await self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        deserialized = self._deserialize('Attachment', pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized
    update_attachment.metadata = {'url': '/farmers/{farmerId}/attachments/{attachmentId}'}  # type: ignore

    async def delete_attachment(
        self,
        farmer_id: str,
        attachment_id: str,
        **kwargs
    ) -> None:
        """Deletes Attachment for given attachment id.

        :param farmer_id: Id of the associated farmer.
        :type farmer_id: str
        :param attachment_id: Id of attachment to be deleted.
        :type attachment_id: str
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: None, or the result of cls(response)
        :rtype: None
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType[None]
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}))
        api_version = "2020-12-31-preview"

        # Construct URL
        url = self.delete_attachment.metadata['url']  # type: ignore
        path_format_arguments = {
            'farmerId': self._serialize.url("farmer_id", farmer_id, 'str'),
            'attachmentId': self._serialize.url("attachment_id", attachment_id, 'str'),
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]
        query_parameters['api-version'] = self._serialize.query("api_version", api_version, 'str')

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]

        request = self._client.delete(url, query_parameters, header_parameters)
        pipeline_response = await self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if cls:
            return cls(pipeline_response, None, {})

    delete_attachment.metadata = {'url': '/farmers/{farmerId}/attachments/{attachmentId}'}  # type: ignore

    async def download_attachment(
        self,
        farmer_id: str,
        attachment_id: str,
        **kwargs
    ) -> IO:
        """Downloads and returns attachment as response for the given input filePath.

        :param farmer_id: Id of the associated farmer.
        :type farmer_id: str
        :param attachment_id: Id of attachment to be downloaded.
        :type attachment_id: str
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: IO, or the result of cls(response)
        :rtype: IO
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType[IO]
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}))
        api_version = "2020-12-31-preview"
        accept = "application/json"

        # Construct URL
        url = self.download_attachment.metadata['url']  # type: ignore
        path_format_arguments = {
            'farmerId': self._serialize.url("farmer_id", farmer_id, 'str'),
            'attachmentId': self._serialize.url("attachment_id", attachment_id, 'str'),
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]
        query_parameters['api-version'] = self._serialize.query("api_version", api_version, 'str')

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]
        header_parameters['Accept'] = self._serialize.header("accept", accept, 'str')

        request = self._client.get(url, query_parameters, header_parameters)
        pipeline_response = await self._client._pipeline.run(request, stream=True, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize.failsafe_deserialize(_models.ErrorResponse, response)
            raise HttpResponseError(response=response, model=error)

        deserialized = response.stream_download(self._client._pipeline)

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized
    download_attachment.metadata = {'url': '/farmers/{farmerId}/attachments/{attachmentId}/:download'}  # type: ignore

    async def get_boundaries(
        self,
        farmer_id: str,
        is_primary: Optional[bool] = None,
        parent_type: Optional[str] = None,
        parent_ids: Optional[List[str]] = None,
        min_acreage: Optional[float] = None,
        max_acreage: Optional[float] = None,
        ids: Optional[List[str]] = None,
        names: Optional[List[str]] = None,
        property_filters: Optional[List[str]] = None,
        statuses: Optional[List[str]] = None,
        min_created_date_time: Optional[datetime.datetime] = None,
        max_created_date_time: Optional[datetime.datetime] = None,
        min_last_modified_date_time: Optional[datetime.datetime] = None,
        max_last_modified_date_time: Optional[datetime.datetime] = None,
        max_page_size: Optional[int] = 50,
        skip_token: Optional[str] = None,
        **kwargs
    ) -> "_models.BoundaryListResponse":
        """Returns a list of boundaries.

        :param farmer_id: Id of the farmer.
        :type farmer_id: str
        :param is_primary: Is the boundary primary.
        :type is_primary: bool
        :param parent_type: Type of the parent it belongs to.
        :type parent_type: str
        :param parent_ids: Parent Ids of the resource.
        :type parent_ids: list[str]
        :param min_acreage: Minimum acreage of the boundary (inclusive).
        :type min_acreage: float
        :param max_acreage: Maximum acreage of the boundary (inclusive).
        :type max_acreage: float
        :param ids: Ids of the resource.
        :type ids: list[str]
        :param names: Names of the resource.
        :type names: list[str]
        :param property_filters: Filters on key-value pairs within the Properties object.
         eg. "{testkey} eq {testvalue}".
        :type property_filters: list[str]
        :param statuses: Statuses of the resource.
        :type statuses: list[str]
        :param min_created_date_time: Minimum creation date of resource (inclusive).
        :type min_created_date_time: ~datetime.datetime
        :param max_created_date_time: Maximum creation date of resource (inclusive).
        :type max_created_date_time: ~datetime.datetime
        :param min_last_modified_date_time: Minimum last modified date of resource (inclusive).
        :type min_last_modified_date_time: ~datetime.datetime
        :param max_last_modified_date_time: Maximum last modified date of resource (inclusive).
        :type max_last_modified_date_time: ~datetime.datetime
        :param max_page_size: Maximum number of items needed (inclusive).
         Minimum = 10, Maximum = 1000, Default value = 50.
        :type max_page_size: int
        :param skip_token: Skip token for getting next set of results.
        :type skip_token: str
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: BoundaryListResponse, or the result of cls(response)
        :rtype: ~dpsclient.models.BoundaryListResponse
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType["_models.BoundaryListResponse"]
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}))
        api_version = "2020-12-31-preview"
        accept = "application/json"

        # Construct URL
        url = self.get_boundaries.metadata['url']  # type: ignore
        path_format_arguments = {
            'farmerId': self._serialize.url("farmer_id", farmer_id, 'str'),
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]
        if is_primary is not None:
            query_parameters['isPrimary'] = self._serialize.query("is_primary", is_primary, 'bool')
        if parent_type is not None:
            query_parameters['parentType'] = self._serialize.query("parent_type", parent_type, 'str')
        if parent_ids is not None:
            query_parameters['parentIds'] = [self._serialize.query("parent_ids", q, 'str') if q is not None else '' for q in parent_ids]
        if min_acreage is not None:
            query_parameters['minAcreage'] = self._serialize.query("min_acreage", min_acreage, 'float')
        if max_acreage is not None:
            query_parameters['maxAcreage'] = self._serialize.query("max_acreage", max_acreage, 'float')
        if ids is not None:
            query_parameters['ids'] = [self._serialize.query("ids", q, 'str') if q is not None else '' for q in ids]
        if names is not None:
            query_parameters['names'] = [self._serialize.query("names", q, 'str') if q is not None else '' for q in names]
        if property_filters is not None:
            query_parameters['propertyFilters'] = [self._serialize.query("property_filters", q, 'str') if q is not None else '' for q in property_filters]
        if statuses is not None:
            query_parameters['statuses'] = [self._serialize.query("statuses", q, 'str') if q is not None else '' for q in statuses]
        if min_created_date_time is not None:
            query_parameters['minCreatedDateTime'] = self._serialize.query("min_created_date_time", min_created_date_time, 'iso-8601')
        if max_created_date_time is not None:
            query_parameters['maxCreatedDateTime'] = self._serialize.query("max_created_date_time", max_created_date_time, 'iso-8601')
        if min_last_modified_date_time is not None:
            query_parameters['minLastModifiedDateTime'] = self._serialize.query("min_last_modified_date_time", min_last_modified_date_time, 'iso-8601')
        if max_last_modified_date_time is not None:
            query_parameters['maxLastModifiedDateTime'] = self._serialize.query("max_last_modified_date_time", max_last_modified_date_time, 'iso-8601')
        if max_page_size is not None:
            query_parameters['$maxPageSize'] = self._serialize.query("max_page_size", max_page_size, 'int', maximum=1000, minimum=10)
        if skip_token is not None:
            query_parameters['$skipToken'] = self._serialize.query("skip_token", skip_token, 'str')
        query_parameters['api-version'] = self._serialize.query("api_version", api_version, 'str')

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]
        header_parameters['Accept'] = self._serialize.header("accept", accept, 'str')

        request = self._client.get(url, query_parameters, header_parameters)
        pipeline_response = await self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        deserialized = self._deserialize('BoundaryListResponse', pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized
    get_boundaries.metadata = {'url': '/farmers/{farmerId}/boundaries'}  # type: ignore

    async def search_boundaries(
        self,
        farmer_id: str,
        body: Optional["_models.SearchBoundaryQuery"] = None,
        **kwargs
    ) -> "_models.BoundaryListResponse":
        """Search for boundaries by fields and intersecting geometry.

        :param farmer_id: Id of the farmer.
        :type farmer_id: str
        :param body: Farm query filters.
        :type body: ~dpsclient.models.SearchBoundaryQuery
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: BoundaryListResponse, or the result of cls(response)
        :rtype: ~dpsclient.models.BoundaryListResponse
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType["_models.BoundaryListResponse"]
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}))
        api_version = "2020-12-31-preview"
        content_type = kwargs.pop("content_type", "application/json")
        accept = "application/json"

        # Construct URL
        url = self.search_boundaries.metadata['url']  # type: ignore
        path_format_arguments = {
            'farmerId': self._serialize.url("farmer_id", farmer_id, 'str'),
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]
        query_parameters['api-version'] = self._serialize.query("api_version", api_version, 'str')

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]
        header_parameters['Content-Type'] = self._serialize.header("content_type", content_type, 'str')
        header_parameters['Accept'] = self._serialize.header("accept", accept, 'str')

        body_content_kwargs = {}  # type: Dict[str, Any]
        if body is not None:
            body_content = self._serialize.body(body, 'SearchBoundaryQuery')
        else:
            body_content = None
        body_content_kwargs['content'] = body_content
        request = self._client.post(url, query_parameters, header_parameters, **body_content_kwargs)
        pipeline_response = await self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        deserialized = self._deserialize('BoundaryListResponse', pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized
    search_boundaries.metadata = {'url': '/farmers/{farmerId}/boundaries'}  # type: ignore

    async def get_all_boundaries(
        self,
        is_primary: Optional[bool] = None,
        parent_type: Optional[str] = None,
        parent_ids: Optional[List[str]] = None,
        min_acreage: Optional[float] = None,
        max_acreage: Optional[float] = None,
        ids: Optional[List[str]] = None,
        names: Optional[List[str]] = None,
        property_filters: Optional[List[str]] = None,
        statuses: Optional[List[str]] = None,
        min_created_date_time: Optional[datetime.datetime] = None,
        max_created_date_time: Optional[datetime.datetime] = None,
        min_last_modified_date_time: Optional[datetime.datetime] = None,
        max_last_modified_date_time: Optional[datetime.datetime] = None,
        max_page_size: Optional[int] = 50,
        skip_token: Optional[str] = None,
        **kwargs
    ) -> "_models.BoundaryListResponse":
        """Returns a list of boundaries across all farmers.

        :param is_primary: Is the boundary primary.
        :type is_primary: bool
        :param parent_type: Type of the parent it belongs to.
        :type parent_type: str
        :param parent_ids: Parent Ids of the resource.
        :type parent_ids: list[str]
        :param min_acreage: Minimum acreage of the boundary (inclusive).
        :type min_acreage: float
        :param max_acreage: Maximum acreage of the boundary (inclusive).
        :type max_acreage: float
        :param ids: Ids of the resource.
        :type ids: list[str]
        :param names: Names of the resource.
        :type names: list[str]
        :param property_filters: Filters on key-value pairs within the Properties object.
         eg. "{testkey} eq {testvalue}".
        :type property_filters: list[str]
        :param statuses: Statuses of the resource.
        :type statuses: list[str]
        :param min_created_date_time: Minimum creation date of resource (inclusive).
        :type min_created_date_time: ~datetime.datetime
        :param max_created_date_time: Maximum creation date of resource (inclusive).
        :type max_created_date_time: ~datetime.datetime
        :param min_last_modified_date_time: Minimum last modified date of resource (inclusive).
        :type min_last_modified_date_time: ~datetime.datetime
        :param max_last_modified_date_time: Maximum last modified date of resource (inclusive).
        :type max_last_modified_date_time: ~datetime.datetime
        :param max_page_size: Maximum number of items needed (inclusive).
         Minimum = 10, Maximum = 1000, Default value = 50.
        :type max_page_size: int
        :param skip_token: Skip token for getting next set of results.
        :type skip_token: str
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: BoundaryListResponse, or the result of cls(response)
        :rtype: ~dpsclient.models.BoundaryListResponse
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType["_models.BoundaryListResponse"]
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}))
        api_version = "2020-12-31-preview"
        accept = "application/json"

        # Construct URL
        url = self.get_all_boundaries.metadata['url']  # type: ignore

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]
        if is_primary is not None:
            query_parameters['isPrimary'] = self._serialize.query("is_primary", is_primary, 'bool')
        if parent_type is not None:
            query_parameters['parentType'] = self._serialize.query("parent_type", parent_type, 'str')
        if parent_ids is not None:
            query_parameters['parentIds'] = [self._serialize.query("parent_ids", q, 'str') if q is not None else '' for q in parent_ids]
        if min_acreage is not None:
            query_parameters['minAcreage'] = self._serialize.query("min_acreage", min_acreage, 'float')
        if max_acreage is not None:
            query_parameters['maxAcreage'] = self._serialize.query("max_acreage", max_acreage, 'float')
        if ids is not None:
            query_parameters['ids'] = [self._serialize.query("ids", q, 'str') if q is not None else '' for q in ids]
        if names is not None:
            query_parameters['names'] = [self._serialize.query("names", q, 'str') if q is not None else '' for q in names]
        if property_filters is not None:
            query_parameters['propertyFilters'] = [self._serialize.query("property_filters", q, 'str') if q is not None else '' for q in property_filters]
        if statuses is not None:
            query_parameters['statuses'] = [self._serialize.query("statuses", q, 'str') if q is not None else '' for q in statuses]
        if min_created_date_time is not None:
            query_parameters['minCreatedDateTime'] = self._serialize.query("min_created_date_time", min_created_date_time, 'iso-8601')
        if max_created_date_time is not None:
            query_parameters['maxCreatedDateTime'] = self._serialize.query("max_created_date_time", max_created_date_time, 'iso-8601')
        if min_last_modified_date_time is not None:
            query_parameters['minLastModifiedDateTime'] = self._serialize.query("min_last_modified_date_time", min_last_modified_date_time, 'iso-8601')
        if max_last_modified_date_time is not None:
            query_parameters['maxLastModifiedDateTime'] = self._serialize.query("max_last_modified_date_time", max_last_modified_date_time, 'iso-8601')
        if max_page_size is not None:
            query_parameters['$maxPageSize'] = self._serialize.query("max_page_size", max_page_size, 'int', maximum=1000, minimum=10)
        if skip_token is not None:
            query_parameters['$skipToken'] = self._serialize.query("skip_token", skip_token, 'str')
        query_parameters['api-version'] = self._serialize.query("api_version", api_version, 'str')

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]
        header_parameters['Accept'] = self._serialize.header("accept", accept, 'str')

        request = self._client.get(url, query_parameters, header_parameters)
        pipeline_response = await self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        deserialized = self._deserialize('BoundaryListResponse', pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized
    get_all_boundaries.metadata = {'url': '/boundaries'}  # type: ignore

    async def search_all_boundaries(
        self,
        body: Optional["_models.SearchBoundaryQuery"] = None,
        **kwargs
    ) -> "_models.BoundaryListResponse":
        """Search for boundaries across all farmers by fields and intersecting geometry.

        :param body: Farm query filters.
        :type body: ~dpsclient.models.SearchBoundaryQuery
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: BoundaryListResponse, or the result of cls(response)
        :rtype: ~dpsclient.models.BoundaryListResponse
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType["_models.BoundaryListResponse"]
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}))
        api_version = "2020-12-31-preview"
        content_type = kwargs.pop("content_type", "application/json")
        accept = "application/json"

        # Construct URL
        url = self.search_all_boundaries.metadata['url']  # type: ignore

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]
        query_parameters['api-version'] = self._serialize.query("api_version", api_version, 'str')

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]
        header_parameters['Content-Type'] = self._serialize.header("content_type", content_type, 'str')
        header_parameters['Accept'] = self._serialize.header("accept", accept, 'str')

        body_content_kwargs = {}  # type: Dict[str, Any]
        if body is not None:
            body_content = self._serialize.body(body, 'SearchBoundaryQuery')
        else:
            body_content = None
        body_content_kwargs['content'] = body_content
        request = self._client.post(url, query_parameters, header_parameters, **body_content_kwargs)
        pipeline_response = await self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        deserialized = self._deserialize('BoundaryListResponse', pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized
    search_all_boundaries.metadata = {'url': '/boundaries'}  # type: ignore

    async def get_boundary(
        self,
        farmer_id: str,
        boundary_id: str,
        **kwargs
    ) -> "_models.Boundary":
        """Returns field for the given id.

        :param farmer_id: Id of the farmer.
        :type farmer_id: str
        :param boundary_id: Id of the boundary.
        :type boundary_id: str
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: Boundary, or the result of cls(response)
        :rtype: ~dpsclient.models.Boundary
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType["_models.Boundary"]
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}))
        api_version = "2020-12-31-preview"
        accept = "application/json"

        # Construct URL
        url = self.get_boundary.metadata['url']  # type: ignore
        path_format_arguments = {
            'farmerId': self._serialize.url("farmer_id", farmer_id, 'str'),
            'boundaryId': self._serialize.url("boundary_id", boundary_id, 'str'),
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]
        query_parameters['api-version'] = self._serialize.query("api_version", api_version, 'str')

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]
        header_parameters['Accept'] = self._serialize.header("accept", accept, 'str')

        request = self._client.get(url, query_parameters, header_parameters)
        pipeline_response = await self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        deserialized = self._deserialize('Boundary', pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized
    get_boundary.metadata = {'url': '/farmers/{farmerId}/boundaries/{boundaryId}'}  # type: ignore

    async def create_boundary(
        self,
        farmer_id: str,
        boundary_id: str,
        body: Optional["_models.Boundary"] = None,
        **kwargs
    ) -> "_models.Boundary":
        """Creates new field with given request body.

        :param farmer_id: Id of the associated farmer.
        :type farmer_id: str
        :param boundary_id: Boundary id.
        :type boundary_id: str
        :param body: Boundary object.
        :type body: ~dpsclient.models.Boundary
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: Boundary, or the result of cls(response)
        :rtype: ~dpsclient.models.Boundary
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType["_models.Boundary"]
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}))
        api_version = "2020-12-31-preview"
        content_type = kwargs.pop("content_type", "application/json")
        accept = "application/json"

        # Construct URL
        url = self.create_boundary.metadata['url']  # type: ignore
        path_format_arguments = {
            'farmerId': self._serialize.url("farmer_id", farmer_id, 'str'),
            'boundaryId': self._serialize.url("boundary_id", boundary_id, 'str'),
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]
        query_parameters['api-version'] = self._serialize.query("api_version", api_version, 'str')

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]
        header_parameters['Content-Type'] = self._serialize.header("content_type", content_type, 'str')
        header_parameters['Accept'] = self._serialize.header("accept", accept, 'str')

        body_content_kwargs = {}  # type: Dict[str, Any]
        if body is not None:
            body_content = self._serialize.body(body, 'Boundary')
        else:
            body_content = None
        body_content_kwargs['content'] = body_content
        request = self._client.put(url, query_parameters, header_parameters, **body_content_kwargs)
        pipeline_response = await self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [201]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        deserialized = self._deserialize('Boundary', pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized
    create_boundary.metadata = {'url': '/farmers/{farmerId}/boundaries/{boundaryId}'}  # type: ignore

    async def update_boundary(
        self,
        farmer_id: str,
        boundary_id: str,
        body: Optional["_models.Boundary"] = None,
        **kwargs
    ) -> "_models.Boundary":
        """Creates new field with given request body.

        :param farmer_id: Id of the farmer.
        :type farmer_id: str
        :param boundary_id: Id of the boundary.
        :type boundary_id: str
        :param body: Boundary object.
        :type body: ~dpsclient.models.Boundary
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: Boundary, or the result of cls(response)
        :rtype: ~dpsclient.models.Boundary
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType["_models.Boundary"]
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}))
        api_version = "2020-12-31-preview"
        content_type = kwargs.pop("content_type", "application/json")
        accept = "application/json"

        # Construct URL
        url = self.update_boundary.metadata['url']  # type: ignore
        path_format_arguments = {
            'farmerId': self._serialize.url("farmer_id", farmer_id, 'str'),
            'boundaryId': self._serialize.url("boundary_id", boundary_id, 'str'),
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]
        query_parameters['api-version'] = self._serialize.query("api_version", api_version, 'str')

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]
        header_parameters['Content-Type'] = self._serialize.header("content_type", content_type, 'str')
        header_parameters['Accept'] = self._serialize.header("accept", accept, 'str')

        body_content_kwargs = {}  # type: Dict[str, Any]
        if body is not None:
            body_content = self._serialize.body(body, 'Boundary')
        else:
            body_content = None
        body_content_kwargs['content'] = body_content
        request = self._client.patch(url, query_parameters, header_parameters, **body_content_kwargs)
        pipeline_response = await self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        deserialized = self._deserialize('Boundary', pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized
    update_boundary.metadata = {'url': '/farmers/{farmerId}/boundaries/{boundaryId}'}  # type: ignore

    async def delete_boundary(
        self,
        farmer_id: str,
        boundary_id: str,
        **kwargs
    ) -> None:
        """Creates new field with given request body.

        :param farmer_id: Id of the farmer.
        :type farmer_id: str
        :param boundary_id: Id of the boundary.
        :type boundary_id: str
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: None, or the result of cls(response)
        :rtype: None
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType[None]
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}))
        api_version = "2020-12-31-preview"

        # Construct URL
        url = self.delete_boundary.metadata['url']  # type: ignore
        path_format_arguments = {
            'farmerId': self._serialize.url("farmer_id", farmer_id, 'str'),
            'boundaryId': self._serialize.url("boundary_id", boundary_id, 'str'),
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]
        query_parameters['api-version'] = self._serialize.query("api_version", api_version, 'str')

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]

        request = self._client.delete(url, query_parameters, header_parameters)
        pipeline_response = await self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if cls:
            return cls(pipeline_response, None, {})

    delete_boundary.metadata = {'url': '/farmers/{farmerId}/boundaries/{boundaryId}'}  # type: ignore

    async def get_boundary_overlap(
        self,
        farmer_id: str,
        boundary_id: str,
        overlapping_farmer_id: str,
        overlapping_boundary_id: str,
        **kwargs
    ) -> "_models.BoundaryOverlapResponse":
        """Returns overlapping acreage between two boundary IDs.

        :param farmer_id: Id of the farmer.
        :type farmer_id: str
        :param boundary_id: Id of the boundary.
        :type boundary_id: str
        :param overlapping_farmer_id: FarmerId of the overlapping field.
        :type overlapping_farmer_id: str
        :param overlapping_boundary_id: Id of the overlapping boundary.
        :type overlapping_boundary_id: str
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: BoundaryOverlapResponse, or the result of cls(response)
        :rtype: ~dpsclient.models.BoundaryOverlapResponse
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType["_models.BoundaryOverlapResponse"]
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}))
        api_version = "2020-12-31-preview"
        accept = "application/json"

        # Construct URL
        url = self.get_boundary_overlap.metadata['url']  # type: ignore
        path_format_arguments = {
            'farmerId': self._serialize.url("farmer_id", farmer_id, 'str'),
            'boundaryId': self._serialize.url("boundary_id", boundary_id, 'str'),
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]
        query_parameters['overlappingFarmerId'] = self._serialize.query("overlapping_farmer_id", overlapping_farmer_id, 'str')
        query_parameters['overlappingBoundaryId'] = self._serialize.query("overlapping_boundary_id", overlapping_boundary_id, 'str')
        query_parameters['api-version'] = self._serialize.query("api_version", api_version, 'str')

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]
        header_parameters['Accept'] = self._serialize.header("accept", accept, 'str')

        request = self._client.get(url, query_parameters, header_parameters)
        pipeline_response = await self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        deserialized = self._deserialize('BoundaryOverlapResponse', pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized
    get_boundary_overlap.metadata = {'url': '/farmers/{farmerId}/boundaries/{boundaryId}/overlap'}  # type: ignore

    async def create_crop(
        self,
        crop_id: str,
        body: Optional["_models.Crop"] = None,
        **kwargs
    ) -> "_models.Crop":
        """Creates new crop object with given request body.

        :param crop_id: Crop id.
        :type crop_id: str
        :param body: Crop object.
        :type body: ~dpsclient.models.Crop
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: Crop, or the result of cls(response)
        :rtype: ~dpsclient.models.Crop
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType["_models.Crop"]
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}))
        api_version = "2020-12-31-preview"
        content_type = kwargs.pop("content_type", "application/json")
        accept = "application/json"

        # Construct URL
        url = self.create_crop.metadata['url']  # type: ignore
        path_format_arguments = {
            'cropId': self._serialize.url("crop_id", crop_id, 'str'),
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]
        query_parameters['api-version'] = self._serialize.query("api_version", api_version, 'str')

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]
        header_parameters['Content-Type'] = self._serialize.header("content_type", content_type, 'str')
        header_parameters['Accept'] = self._serialize.header("accept", accept, 'str')

        body_content_kwargs = {}  # type: Dict[str, Any]
        if body is not None:
            body_content = self._serialize.body(body, 'Crop')
        else:
            body_content = None
        body_content_kwargs['content'] = body_content
        request = self._client.put(url, query_parameters, header_parameters, **body_content_kwargs)
        pipeline_response = await self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [201]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        deserialized = self._deserialize('Crop', pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized
    create_crop.metadata = {'url': '/crops/{cropId}'}  # type: ignore

    async def get_crop(
        self,
        crop_id: str,
        **kwargs
    ) -> "_models.Crop":
        """Get crop object with given crop id.

        :param crop_id: Crop Id.
        :type crop_id: str
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: Crop, or the result of cls(response)
        :rtype: ~dpsclient.models.Crop
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType["_models.Crop"]
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}))
        api_version = "2020-12-31-preview"
        accept = "application/json"

        # Construct URL
        url = self.get_crop.metadata['url']  # type: ignore
        path_format_arguments = {
            'cropId': self._serialize.url("crop_id", crop_id, 'str'),
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]
        query_parameters['api-version'] = self._serialize.query("api_version", api_version, 'str')

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]
        header_parameters['Accept'] = self._serialize.header("accept", accept, 'str')

        request = self._client.get(url, query_parameters, header_parameters)
        pipeline_response = await self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        deserialized = self._deserialize('Crop', pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized
    get_crop.metadata = {'url': '/crops/{cropId}'}  # type: ignore

    async def update_crop(
        self,
        crop_id: str,
        body: Optional["_models.Crop"] = None,
        **kwargs
    ) -> "_models.Crop":
        """Updates Crop for given crop Id.

        :param crop_id: Id of crop that need to be updated (system-generated).
        :type crop_id: str
        :param body: New state of crop.
        :type body: ~dpsclient.models.Crop
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: Crop, or the result of cls(response)
        :rtype: ~dpsclient.models.Crop
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType["_models.Crop"]
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}))
        api_version = "2020-12-31-preview"
        content_type = kwargs.pop("content_type", "application/json")
        accept = "application/json"

        # Construct URL
        url = self.update_crop.metadata['url']  # type: ignore
        path_format_arguments = {
            'cropId': self._serialize.url("crop_id", crop_id, 'str'),
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]
        query_parameters['api-version'] = self._serialize.query("api_version", api_version, 'str')

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]
        header_parameters['Content-Type'] = self._serialize.header("content_type", content_type, 'str')
        header_parameters['Accept'] = self._serialize.header("accept", accept, 'str')

        body_content_kwargs = {}  # type: Dict[str, Any]
        if body is not None:
            body_content = self._serialize.body(body, 'Crop')
        else:
            body_content = None
        body_content_kwargs['content'] = body_content
        request = self._client.patch(url, query_parameters, header_parameters, **body_content_kwargs)
        pipeline_response = await self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        deserialized = self._deserialize('Crop', pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized
    update_crop.metadata = {'url': '/crops/{cropId}'}  # type: ignore

    async def delete_crop(
        self,
        crop_id: str,
        **kwargs
    ) -> None:
        """Deletes Crop for given crop id.

        :param crop_id: Id of crop to be deleted.
        :type crop_id: str
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: None, or the result of cls(response)
        :rtype: None
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType[None]
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}))
        api_version = "2020-12-31-preview"

        # Construct URL
        url = self.delete_crop.metadata['url']  # type: ignore
        path_format_arguments = {
            'cropId': self._serialize.url("crop_id", crop_id, 'str'),
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]
        query_parameters['api-version'] = self._serialize.query("api_version", api_version, 'str')

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]

        request = self._client.delete(url, query_parameters, header_parameters)
        pipeline_response = await self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if cls:
            return cls(pipeline_response, None, {})

    delete_crop.metadata = {'url': '/crops/{cropId}'}  # type: ignore

    async def get_crops(
        self,
        phenotypes: Optional[List[str]] = None,
        ids: Optional[List[str]] = None,
        names: Optional[List[str]] = None,
        property_filters: Optional[List[str]] = None,
        statuses: Optional[List[str]] = None,
        min_created_date_time: Optional[datetime.datetime] = None,
        max_created_date_time: Optional[datetime.datetime] = None,
        min_last_modified_date_time: Optional[datetime.datetime] = None,
        max_last_modified_date_time: Optional[datetime.datetime] = None,
        max_page_size: Optional[int] = 50,
        skip_token: Optional[str] = None,
        **kwargs
    ) -> "_models.CropListResponse":
        """Returns a list of crops.

        :param phenotypes: Crop phenotypes of the resource.
        :type phenotypes: list[str]
        :param ids: Ids of the resource.
        :type ids: list[str]
        :param names: Names of the resource.
        :type names: list[str]
        :param property_filters: Filters on key-value pairs within the Properties object.
         eg. "{testkey} eq {testvalue}".
        :type property_filters: list[str]
        :param statuses: Statuses of the resource.
        :type statuses: list[str]
        :param min_created_date_time: Minimum creation date of resource (inclusive).
        :type min_created_date_time: ~datetime.datetime
        :param max_created_date_time: Maximum creation date of resource (inclusive).
        :type max_created_date_time: ~datetime.datetime
        :param min_last_modified_date_time: Minimum last modified date of resource (inclusive).
        :type min_last_modified_date_time: ~datetime.datetime
        :param max_last_modified_date_time: Maximum last modified date of resource (inclusive).
        :type max_last_modified_date_time: ~datetime.datetime
        :param max_page_size: Maximum number of items needed (inclusive).
         Minimum = 10, Maximum = 1000, Default value = 50.
        :type max_page_size: int
        :param skip_token: Skip token for getting next set of results.
        :type skip_token: str
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: CropListResponse, or the result of cls(response)
        :rtype: ~dpsclient.models.CropListResponse
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType["_models.CropListResponse"]
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}))
        api_version = "2020-12-31-preview"
        accept = "application/json"

        # Construct URL
        url = self.get_crops.metadata['url']  # type: ignore

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]
        if phenotypes is not None:
            query_parameters['phenotypes'] = [self._serialize.query("phenotypes", q, 'str') if q is not None else '' for q in phenotypes]
        if ids is not None:
            query_parameters['ids'] = [self._serialize.query("ids", q, 'str') if q is not None else '' for q in ids]
        if names is not None:
            query_parameters['names'] = [self._serialize.query("names", q, 'str') if q is not None else '' for q in names]
        if property_filters is not None:
            query_parameters['propertyFilters'] = [self._serialize.query("property_filters", q, 'str') if q is not None else '' for q in property_filters]
        if statuses is not None:
            query_parameters['statuses'] = [self._serialize.query("statuses", q, 'str') if q is not None else '' for q in statuses]
        if min_created_date_time is not None:
            query_parameters['minCreatedDateTime'] = self._serialize.query("min_created_date_time", min_created_date_time, 'iso-8601')
        if max_created_date_time is not None:
            query_parameters['maxCreatedDateTime'] = self._serialize.query("max_created_date_time", max_created_date_time, 'iso-8601')
        if min_last_modified_date_time is not None:
            query_parameters['minLastModifiedDateTime'] = self._serialize.query("min_last_modified_date_time", min_last_modified_date_time, 'iso-8601')
        if max_last_modified_date_time is not None:
            query_parameters['maxLastModifiedDateTime'] = self._serialize.query("max_last_modified_date_time", max_last_modified_date_time, 'iso-8601')
        if max_page_size is not None:
            query_parameters['$maxPageSize'] = self._serialize.query("max_page_size", max_page_size, 'int', maximum=1000, minimum=10)
        if skip_token is not None:
            query_parameters['$skipToken'] = self._serialize.query("skip_token", skip_token, 'str')
        query_parameters['api-version'] = self._serialize.query("api_version", api_version, 'str')

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]
        header_parameters['Accept'] = self._serialize.header("accept", accept, 'str')

        request = self._client.get(url, query_parameters, header_parameters)
        pipeline_response = await self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        deserialized = self._deserialize('CropListResponse', pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized
    get_crops.metadata = {'url': '/crops'}  # type: ignore

    async def create_crop_variety(
        self,
        crop_variety_id: str,
        body: Optional["_models.CropVariety"] = None,
        **kwargs
    ) -> "_models.CropVariety":
        """Creates new cropVariety object with given request body.

        :param crop_variety_id: CropVariety id.
        :type crop_variety_id: str
        :param body: CropVariety object.
        :type body: ~dpsclient.models.CropVariety
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: CropVariety, or the result of cls(response)
        :rtype: ~dpsclient.models.CropVariety
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType["_models.CropVariety"]
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}))
        api_version = "2020-12-31-preview"
        content_type = kwargs.pop("content_type", "application/json")
        accept = "application/json"

        # Construct URL
        url = self.create_crop_variety.metadata['url']  # type: ignore
        path_format_arguments = {
            'cropVarietyId': self._serialize.url("crop_variety_id", crop_variety_id, 'str'),
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]
        query_parameters['api-version'] = self._serialize.query("api_version", api_version, 'str')

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]
        header_parameters['Content-Type'] = self._serialize.header("content_type", content_type, 'str')
        header_parameters['Accept'] = self._serialize.header("accept", accept, 'str')

        body_content_kwargs = {}  # type: Dict[str, Any]
        if body is not None:
            body_content = self._serialize.body(body, 'CropVariety')
        else:
            body_content = None
        body_content_kwargs['content'] = body_content
        request = self._client.put(url, query_parameters, header_parameters, **body_content_kwargs)
        pipeline_response = await self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [201]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        deserialized = self._deserialize('CropVariety', pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized
    create_crop_variety.metadata = {'url': '/cropVarieties/{cropVarietyId}'}  # type: ignore

    async def get_crop_variety(
        self,
        crop_variety_id: str,
        **kwargs
    ) -> "_models.CropVariety":
        """Get cropVariety object with given cropVariety id.

        :param crop_variety_id: CropVariety Id.
        :type crop_variety_id: str
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: CropVariety, or the result of cls(response)
        :rtype: ~dpsclient.models.CropVariety
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType["_models.CropVariety"]
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}))
        api_version = "2020-12-31-preview"
        accept = "application/json"

        # Construct URL
        url = self.get_crop_variety.metadata['url']  # type: ignore
        path_format_arguments = {
            'cropVarietyId': self._serialize.url("crop_variety_id", crop_variety_id, 'str'),
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]
        query_parameters['api-version'] = self._serialize.query("api_version", api_version, 'str')

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]
        header_parameters['Accept'] = self._serialize.header("accept", accept, 'str')

        request = self._client.get(url, query_parameters, header_parameters)
        pipeline_response = await self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        deserialized = self._deserialize('CropVariety', pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized
    get_crop_variety.metadata = {'url': '/cropVarieties/{cropVarietyId}'}  # type: ignore

    async def update_crop_variety(
        self,
        crop_variety_id: str,
        body: Optional["_models.CropVariety"] = None,
        **kwargs
    ) -> "_models.CropVariety":
        """Updates CropVariety for given cropVariety Id.

        :param crop_variety_id: Id of cropVariety that need to be updated (system-generated).
        :type crop_variety_id: str
        :param body: New state of cropVariety.
        :type body: ~dpsclient.models.CropVariety
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: CropVariety, or the result of cls(response)
        :rtype: ~dpsclient.models.CropVariety
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType["_models.CropVariety"]
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}))
        api_version = "2020-12-31-preview"
        content_type = kwargs.pop("content_type", "application/json")
        accept = "application/json"

        # Construct URL
        url = self.update_crop_variety.metadata['url']  # type: ignore
        path_format_arguments = {
            'cropVarietyId': self._serialize.url("crop_variety_id", crop_variety_id, 'str'),
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]
        query_parameters['api-version'] = self._serialize.query("api_version", api_version, 'str')

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]
        header_parameters['Content-Type'] = self._serialize.header("content_type", content_type, 'str')
        header_parameters['Accept'] = self._serialize.header("accept", accept, 'str')

        body_content_kwargs = {}  # type: Dict[str, Any]
        if body is not None:
            body_content = self._serialize.body(body, 'CropVariety')
        else:
            body_content = None
        body_content_kwargs['content'] = body_content
        request = self._client.patch(url, query_parameters, header_parameters, **body_content_kwargs)
        pipeline_response = await self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        deserialized = self._deserialize('CropVariety', pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized
    update_crop_variety.metadata = {'url': '/cropVarieties/{cropVarietyId}'}  # type: ignore

    async def delete_crop_variety(
        self,
        crop_variety_id: str,
        **kwargs
    ) -> None:
        """Deletes CropVariety for given cropVariety id.

        :param crop_variety_id: Id of cropVariety to be deleted.
        :type crop_variety_id: str
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: None, or the result of cls(response)
        :rtype: None
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType[None]
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}))
        api_version = "2020-12-31-preview"

        # Construct URL
        url = self.delete_crop_variety.metadata['url']  # type: ignore
        path_format_arguments = {
            'cropVarietyId': self._serialize.url("crop_variety_id", crop_variety_id, 'str'),
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]
        query_parameters['api-version'] = self._serialize.query("api_version", api_version, 'str')

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]

        request = self._client.delete(url, query_parameters, header_parameters)
        pipeline_response = await self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if cls:
            return cls(pipeline_response, None, {})

    delete_crop_variety.metadata = {'url': '/cropVarieties/{cropVarietyId}'}  # type: ignore

    async def get_crop_varieties(
        self,
        crop_ids: Optional[List[str]] = None,
        brands: Optional[List[str]] = None,
        products: Optional[List[str]] = None,
        ids: Optional[List[str]] = None,
        names: Optional[List[str]] = None,
        property_filters: Optional[List[str]] = None,
        statuses: Optional[List[str]] = None,
        min_created_date_time: Optional[datetime.datetime] = None,
        max_created_date_time: Optional[datetime.datetime] = None,
        min_last_modified_date_time: Optional[datetime.datetime] = None,
        max_last_modified_date_time: Optional[datetime.datetime] = None,
        max_page_size: Optional[int] = 50,
        skip_token: Optional[str] = None,
        **kwargs
    ) -> "_models.CropVarietyListResponse":
        """Returns a list of cropVariety.

        :param crop_ids: CropIds of the resource.
        :type crop_ids: list[str]
        :param brands: Brands of the resource.
        :type brands: list[str]
        :param products: Products of the resource.
        :type products: list[str]
        :param ids: Ids of the resource.
        :type ids: list[str]
        :param names: Names of the resource.
        :type names: list[str]
        :param property_filters: Filters on key-value pairs within the Properties object.
         eg. "{testkey} eq {testvalue}".
        :type property_filters: list[str]
        :param statuses: Statuses of the resource.
        :type statuses: list[str]
        :param min_created_date_time: Minimum creation date of resource (inclusive).
        :type min_created_date_time: ~datetime.datetime
        :param max_created_date_time: Maximum creation date of resource (inclusive).
        :type max_created_date_time: ~datetime.datetime
        :param min_last_modified_date_time: Minimum last modified date of resource (inclusive).
        :type min_last_modified_date_time: ~datetime.datetime
        :param max_last_modified_date_time: Maximum last modified date of resource (inclusive).
        :type max_last_modified_date_time: ~datetime.datetime
        :param max_page_size: Maximum number of items needed (inclusive).
         Minimum = 10, Maximum = 1000, Default value = 50.
        :type max_page_size: int
        :param skip_token: Skip token for getting next set of results.
        :type skip_token: str
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: CropVarietyListResponse, or the result of cls(response)
        :rtype: ~dpsclient.models.CropVarietyListResponse
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType["_models.CropVarietyListResponse"]
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}))
        api_version = "2020-12-31-preview"
        accept = "application/json"

        # Construct URL
        url = self.get_crop_varieties.metadata['url']  # type: ignore

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]
        if crop_ids is not None:
            query_parameters['cropIds'] = [self._serialize.query("crop_ids", q, 'str') if q is not None else '' for q in crop_ids]
        if brands is not None:
            query_parameters['brands'] = [self._serialize.query("brands", q, 'str') if q is not None else '' for q in brands]
        if products is not None:
            query_parameters['products'] = [self._serialize.query("products", q, 'str') if q is not None else '' for q in products]
        if ids is not None:
            query_parameters['ids'] = [self._serialize.query("ids", q, 'str') if q is not None else '' for q in ids]
        if names is not None:
            query_parameters['names'] = [self._serialize.query("names", q, 'str') if q is not None else '' for q in names]
        if property_filters is not None:
            query_parameters['propertyFilters'] = [self._serialize.query("property_filters", q, 'str') if q is not None else '' for q in property_filters]
        if statuses is not None:
            query_parameters['statuses'] = [self._serialize.query("statuses", q, 'str') if q is not None else '' for q in statuses]
        if min_created_date_time is not None:
            query_parameters['minCreatedDateTime'] = self._serialize.query("min_created_date_time", min_created_date_time, 'iso-8601')
        if max_created_date_time is not None:
            query_parameters['maxCreatedDateTime'] = self._serialize.query("max_created_date_time", max_created_date_time, 'iso-8601')
        if min_last_modified_date_time is not None:
            query_parameters['minLastModifiedDateTime'] = self._serialize.query("min_last_modified_date_time", min_last_modified_date_time, 'iso-8601')
        if max_last_modified_date_time is not None:
            query_parameters['maxLastModifiedDateTime'] = self._serialize.query("max_last_modified_date_time", max_last_modified_date_time, 'iso-8601')
        if max_page_size is not None:
            query_parameters['$maxPageSize'] = self._serialize.query("max_page_size", max_page_size, 'int', maximum=1000, minimum=10)
        if skip_token is not None:
            query_parameters['$skipToken'] = self._serialize.query("skip_token", skip_token, 'str')
        query_parameters['api-version'] = self._serialize.query("api_version", api_version, 'str')

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]
        header_parameters['Accept'] = self._serialize.header("accept", accept, 'str')

        request = self._client.get(url, query_parameters, header_parameters)
        pipeline_response = await self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        deserialized = self._deserialize('CropVarietyListResponse', pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized
    get_crop_varieties.metadata = {'url': '/cropVarieties'}  # type: ignore

    async def handle_john_deere_event(
        self,
        body: Optional[object] = None,
        **kwargs
    ) -> None:
        """Callback endpoint to handle John Deere events.

        :param body: event data object.
        :type body: object
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: None, or the result of cls(response)
        :rtype: None
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType[None]
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}))
        content_type = kwargs.pop("content_type", "application/json")
        accept = "application/json"

        # Construct URL
        url = self.handle_john_deere_event.metadata['url']  # type: ignore

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]
        header_parameters['Content-Type'] = self._serialize.header("content_type", content_type, 'str')
        header_parameters['Accept'] = self._serialize.header("accept", accept, 'str')

        body_content_kwargs = {}  # type: Dict[str, Any]
        if body is not None:
            body_content = self._serialize.body(body, 'object')
        else:
            body_content = None
        body_content_kwargs['content'] = body_content
        request = self._client.post(url, query_parameters, header_parameters, **body_content_kwargs)
        pipeline_response = await self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [204]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize.failsafe_deserialize(_models.ErrorResponse, response)
            raise HttpResponseError(response=response, model=error)

        if cls:
            return cls(pipeline_response, None, {})

    handle_john_deere_event.metadata = {'url': '/events/johndeere/handler'}  # type: ignore

    async def get_farms(
        self,
        farmer_id: str,
        ids: Optional[List[str]] = None,
        names: Optional[List[str]] = None,
        property_filters: Optional[List[str]] = None,
        statuses: Optional[List[str]] = None,
        min_created_date_time: Optional[datetime.datetime] = None,
        max_created_date_time: Optional[datetime.datetime] = None,
        min_last_modified_date_time: Optional[datetime.datetime] = None,
        max_last_modified_date_time: Optional[datetime.datetime] = None,
        max_page_size: Optional[int] = 50,
        skip_token: Optional[str] = None,
        **kwargs
    ) -> "_models.FarmListResponse":
        """Returns a list of farms.

        :param farmer_id: Id of the farmer.
        :type farmer_id: str
        :param ids: Ids of the resource.
        :type ids: list[str]
        :param names: Names of the resource.
        :type names: list[str]
        :param property_filters: Filters on key-value pairs within the Properties object.
         eg. "{testkey} eq {testvalue}".
        :type property_filters: list[str]
        :param statuses: Statuses of the resource.
        :type statuses: list[str]
        :param min_created_date_time: Minimum creation date of resource (inclusive).
        :type min_created_date_time: ~datetime.datetime
        :param max_created_date_time: Maximum creation date of resource (inclusive).
        :type max_created_date_time: ~datetime.datetime
        :param min_last_modified_date_time: Minimum last modified date of resource (inclusive).
        :type min_last_modified_date_time: ~datetime.datetime
        :param max_last_modified_date_time: Maximum last modified date of resource (inclusive).
        :type max_last_modified_date_time: ~datetime.datetime
        :param max_page_size: Maximum number of items needed (inclusive).
         Minimum = 10, Maximum = 1000, Default value = 50.
        :type max_page_size: int
        :param skip_token: Skip token for getting next set of results.
        :type skip_token: str
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: FarmListResponse, or the result of cls(response)
        :rtype: ~dpsclient.models.FarmListResponse
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType["_models.FarmListResponse"]
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}))
        api_version = "2020-12-31-preview"
        accept = "application/json"

        # Construct URL
        url = self.get_farms.metadata['url']  # type: ignore
        path_format_arguments = {
            'farmerId': self._serialize.url("farmer_id", farmer_id, 'str'),
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]
        if ids is not None:
            query_parameters['ids'] = [self._serialize.query("ids", q, 'str') if q is not None else '' for q in ids]
        if names is not None:
            query_parameters['names'] = [self._serialize.query("names", q, 'str') if q is not None else '' for q in names]
        if property_filters is not None:
            query_parameters['propertyFilters'] = [self._serialize.query("property_filters", q, 'str') if q is not None else '' for q in property_filters]
        if statuses is not None:
            query_parameters['statuses'] = [self._serialize.query("statuses", q, 'str') if q is not None else '' for q in statuses]
        if min_created_date_time is not None:
            query_parameters['minCreatedDateTime'] = self._serialize.query("min_created_date_time", min_created_date_time, 'iso-8601')
        if max_created_date_time is not None:
            query_parameters['maxCreatedDateTime'] = self._serialize.query("max_created_date_time", max_created_date_time, 'iso-8601')
        if min_last_modified_date_time is not None:
            query_parameters['minLastModifiedDateTime'] = self._serialize.query("min_last_modified_date_time", min_last_modified_date_time, 'iso-8601')
        if max_last_modified_date_time is not None:
            query_parameters['maxLastModifiedDateTime'] = self._serialize.query("max_last_modified_date_time", max_last_modified_date_time, 'iso-8601')
        if max_page_size is not None:
            query_parameters['$maxPageSize'] = self._serialize.query("max_page_size", max_page_size, 'int', maximum=1000, minimum=10)
        if skip_token is not None:
            query_parameters['$skipToken'] = self._serialize.query("skip_token", skip_token, 'str')
        query_parameters['api-version'] = self._serialize.query("api_version", api_version, 'str')

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]
        header_parameters['Accept'] = self._serialize.header("accept", accept, 'str')

        request = self._client.get(url, query_parameters, header_parameters)
        pipeline_response = await self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        deserialized = self._deserialize('FarmListResponse', pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized
    get_farms.metadata = {'url': '/farmers/{farmerId}/farms'}  # type: ignore

    async def get_all_farms(
        self,
        ids: Optional[List[str]] = None,
        names: Optional[List[str]] = None,
        property_filters: Optional[List[str]] = None,
        statuses: Optional[List[str]] = None,
        min_created_date_time: Optional[datetime.datetime] = None,
        max_created_date_time: Optional[datetime.datetime] = None,
        min_last_modified_date_time: Optional[datetime.datetime] = None,
        max_last_modified_date_time: Optional[datetime.datetime] = None,
        max_page_size: Optional[int] = 50,
        skip_token: Optional[str] = None,
        **kwargs
    ) -> "_models.FarmListResponse":
        """Returns a list of farms across all farmers.

        :param ids: Ids of the resource.
        :type ids: list[str]
        :param names: Names of the resource.
        :type names: list[str]
        :param property_filters: Filters on key-value pairs within the Properties object.
         eg. "{testkey} eq {testvalue}".
        :type property_filters: list[str]
        :param statuses: Statuses of the resource.
        :type statuses: list[str]
        :param min_created_date_time: Minimum creation date of resource (inclusive).
        :type min_created_date_time: ~datetime.datetime
        :param max_created_date_time: Maximum creation date of resource (inclusive).
        :type max_created_date_time: ~datetime.datetime
        :param min_last_modified_date_time: Minimum last modified date of resource (inclusive).
        :type min_last_modified_date_time: ~datetime.datetime
        :param max_last_modified_date_time: Maximum last modified date of resource (inclusive).
        :type max_last_modified_date_time: ~datetime.datetime
        :param max_page_size: Maximum number of items needed (inclusive).
         Minimum = 10, Maximum = 1000, Default value = 50.
        :type max_page_size: int
        :param skip_token: Skip token for getting next set of results.
        :type skip_token: str
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: FarmListResponse, or the result of cls(response)
        :rtype: ~dpsclient.models.FarmListResponse
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType["_models.FarmListResponse"]
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}))
        api_version = "2020-12-31-preview"
        accept = "application/json"

        # Construct URL
        url = self.get_all_farms.metadata['url']  # type: ignore

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]
        if ids is not None:
            query_parameters['ids'] = [self._serialize.query("ids", q, 'str') if q is not None else '' for q in ids]
        if names is not None:
            query_parameters['names'] = [self._serialize.query("names", q, 'str') if q is not None else '' for q in names]
        if property_filters is not None:
            query_parameters['propertyFilters'] = [self._serialize.query("property_filters", q, 'str') if q is not None else '' for q in property_filters]
        if statuses is not None:
            query_parameters['statuses'] = [self._serialize.query("statuses", q, 'str') if q is not None else '' for q in statuses]
        if min_created_date_time is not None:
            query_parameters['minCreatedDateTime'] = self._serialize.query("min_created_date_time", min_created_date_time, 'iso-8601')
        if max_created_date_time is not None:
            query_parameters['maxCreatedDateTime'] = self._serialize.query("max_created_date_time", max_created_date_time, 'iso-8601')
        if min_last_modified_date_time is not None:
            query_parameters['minLastModifiedDateTime'] = self._serialize.query("min_last_modified_date_time", min_last_modified_date_time, 'iso-8601')
        if max_last_modified_date_time is not None:
            query_parameters['maxLastModifiedDateTime'] = self._serialize.query("max_last_modified_date_time", max_last_modified_date_time, 'iso-8601')
        if max_page_size is not None:
            query_parameters['$maxPageSize'] = self._serialize.query("max_page_size", max_page_size, 'int', maximum=1000, minimum=10)
        if skip_token is not None:
            query_parameters['$skipToken'] = self._serialize.query("skip_token", skip_token, 'str')
        query_parameters['api-version'] = self._serialize.query("api_version", api_version, 'str')

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]
        header_parameters['Accept'] = self._serialize.header("accept", accept, 'str')

        request = self._client.get(url, query_parameters, header_parameters)
        pipeline_response = await self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        deserialized = self._deserialize('FarmListResponse', pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized
    get_all_farms.metadata = {'url': '/farms'}  # type: ignore

    async def get_farm(
        self,
        farmer_id: str,
        farm_id: str,
        **kwargs
    ) -> "_models.Farm":
        """Returns farm for the given id.

        :param farmer_id: Id of the farmer.
        :type farmer_id: str
        :param farm_id: Id of the farm.
        :type farm_id: str
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: Farm, or the result of cls(response)
        :rtype: ~dpsclient.models.Farm
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType["_models.Farm"]
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}))
        api_version = "2020-12-31-preview"
        accept = "application/json"

        # Construct URL
        url = self.get_farm.metadata['url']  # type: ignore
        path_format_arguments = {
            'farmerId': self._serialize.url("farmer_id", farmer_id, 'str'),
            'farmId': self._serialize.url("farm_id", farm_id, 'str'),
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]
        query_parameters['api-version'] = self._serialize.query("api_version", api_version, 'str')

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]
        header_parameters['Accept'] = self._serialize.header("accept", accept, 'str')

        request = self._client.get(url, query_parameters, header_parameters)
        pipeline_response = await self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        deserialized = self._deserialize('Farm', pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized
    get_farm.metadata = {'url': '/farmers/{farmerId}/farms/{farmId}'}  # type: ignore

    async def create_farm(
        self,
        farmer_id: str,
        farm_id: str,
        body: Optional["_models.Farm"] = None,
        **kwargs
    ) -> "_models.Farm":
        """Creates new farm with given request body.

        :param farmer_id: Id of the associated farmer.
        :type farmer_id: str
        :param farm_id: Farm id.
        :type farm_id: str
        :param body: Farm object.
        :type body: ~dpsclient.models.Farm
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: Farm, or the result of cls(response)
        :rtype: ~dpsclient.models.Farm
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType["_models.Farm"]
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}))
        api_version = "2020-12-31-preview"
        content_type = kwargs.pop("content_type", "application/json")
        accept = "application/json"

        # Construct URL
        url = self.create_farm.metadata['url']  # type: ignore
        path_format_arguments = {
            'farmerId': self._serialize.url("farmer_id", farmer_id, 'str'),
            'farmId': self._serialize.url("farm_id", farm_id, 'str'),
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]
        query_parameters['api-version'] = self._serialize.query("api_version", api_version, 'str')

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]
        header_parameters['Content-Type'] = self._serialize.header("content_type", content_type, 'str')
        header_parameters['Accept'] = self._serialize.header("accept", accept, 'str')

        body_content_kwargs = {}  # type: Dict[str, Any]
        if body is not None:
            body_content = self._serialize.body(body, 'Farm')
        else:
            body_content = None
        body_content_kwargs['content'] = body_content
        request = self._client.put(url, query_parameters, header_parameters, **body_content_kwargs)
        pipeline_response = await self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [201]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        deserialized = self._deserialize('Farm', pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized
    create_farm.metadata = {'url': '/farmers/{farmerId}/farms/{farmId}'}  # type: ignore

    async def update_farm(
        self,
        farmer_id: str,
        farm_id: str,
        body: Optional["_models.Farm"] = None,
        **kwargs
    ) -> "_models.Farm":
        """Updates Farm for given farm Id.

        :param farmer_id: Id of the farmer.
        :type farmer_id: str
        :param farm_id: Id of the farm.
        :type farm_id: str
        :param body: New state of farm.
        :type body: ~dpsclient.models.Farm
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: Farm, or the result of cls(response)
        :rtype: ~dpsclient.models.Farm
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType["_models.Farm"]
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}))
        api_version = "2020-12-31-preview"
        content_type = kwargs.pop("content_type", "application/json")
        accept = "application/json"

        # Construct URL
        url = self.update_farm.metadata['url']  # type: ignore
        path_format_arguments = {
            'farmerId': self._serialize.url("farmer_id", farmer_id, 'str'),
            'farmId': self._serialize.url("farm_id", farm_id, 'str'),
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]
        query_parameters['api-version'] = self._serialize.query("api_version", api_version, 'str')

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]
        header_parameters['Content-Type'] = self._serialize.header("content_type", content_type, 'str')
        header_parameters['Accept'] = self._serialize.header("accept", accept, 'str')

        body_content_kwargs = {}  # type: Dict[str, Any]
        if body is not None:
            body_content = self._serialize.body(body, 'Farm')
        else:
            body_content = None
        body_content_kwargs['content'] = body_content
        request = self._client.patch(url, query_parameters, header_parameters, **body_content_kwargs)
        pipeline_response = await self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        deserialized = self._deserialize('Farm', pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized
    update_farm.metadata = {'url': '/farmers/{farmerId}/farms/{farmId}'}  # type: ignore

    async def delete_farm(
        self,
        farmer_id: str,
        farm_id: str,
        **kwargs
    ) -> None:
        """Deletes Farm for given farm id.

        :param farmer_id: Id of the farmer.
        :type farmer_id: str
        :param farm_id: Id of the farm.
        :type farm_id: str
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: None, or the result of cls(response)
        :rtype: None
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType[None]
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}))
        api_version = "2020-12-31-preview"

        # Construct URL
        url = self.delete_farm.metadata['url']  # type: ignore
        path_format_arguments = {
            'farmerId': self._serialize.url("farmer_id", farmer_id, 'str'),
            'farmId': self._serialize.url("farm_id", farm_id, 'str'),
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]
        query_parameters['api-version'] = self._serialize.query("api_version", api_version, 'str')

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]

        request = self._client.delete(url, query_parameters, header_parameters)
        pipeline_response = await self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if cls:
            return cls(pipeline_response, None, {})

    delete_farm.metadata = {'url': '/farmers/{farmerId}/farms/{farmId}'}  # type: ignore

    async def create_farmer(
        self,
        farmer_id: str,
        body: Optional["_models.Farmer"] = None,
        **kwargs
    ) -> "_models.Farmer":
        """Creates new farmer object with given request body.

        :param farmer_id: Farmer id.
        :type farmer_id: str
        :param body: Farmer object.
        :type body: ~dpsclient.models.Farmer
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: Farmer, or the result of cls(response)
        :rtype: ~dpsclient.models.Farmer
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType["_models.Farmer"]
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}))
        api_version = "2020-12-31-preview"
        content_type = kwargs.pop("content_type", "application/json")
        accept = "application/json"

        # Construct URL
        url = self.create_farmer.metadata['url']  # type: ignore
        path_format_arguments = {
            'farmerId': self._serialize.url("farmer_id", farmer_id, 'str'),
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]
        query_parameters['api-version'] = self._serialize.query("api_version", api_version, 'str')

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]
        header_parameters['Content-Type'] = self._serialize.header("content_type", content_type, 'str')
        header_parameters['Accept'] = self._serialize.header("accept", accept, 'str')

        body_content_kwargs = {}  # type: Dict[str, Any]
        if body is not None:
            body_content = self._serialize.body(body, 'Farmer')
        else:
            body_content = None
        body_content_kwargs['content'] = body_content
        request = self._client.put(url, query_parameters, header_parameters, **body_content_kwargs)
        pipeline_response = await self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [201]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        deserialized = self._deserialize('Farmer', pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized
    create_farmer.metadata = {'url': '/farmers/{farmerId}'}  # type: ignore

    async def get_farmer(
        self,
        farmer_id: str,
        **kwargs
    ) -> "_models.Farmer":
        """Get farmer object with given farmer id.

        :param farmer_id: Farmer Id.
        :type farmer_id: str
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: Farmer, or the result of cls(response)
        :rtype: ~dpsclient.models.Farmer
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType["_models.Farmer"]
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}))
        api_version = "2020-12-31-preview"
        accept = "application/json"

        # Construct URL
        url = self.get_farmer.metadata['url']  # type: ignore
        path_format_arguments = {
            'farmerId': self._serialize.url("farmer_id", farmer_id, 'str'),
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]
        query_parameters['api-version'] = self._serialize.query("api_version", api_version, 'str')

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]
        header_parameters['Accept'] = self._serialize.header("accept", accept, 'str')

        request = self._client.get(url, query_parameters, header_parameters)
        pipeline_response = await self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        deserialized = self._deserialize('Farmer', pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized
    get_farmer.metadata = {'url': '/farmers/{farmerId}'}  # type: ignore

    async def update_farmer(
        self,
        farmer_id: str,
        body: Optional["_models.Farmer"] = None,
        **kwargs
    ) -> "_models.Farmer":
        """Updates Farmer for given farmer Id.

        :param farmer_id: Id of farmer that need to be updated (system-generated).
        :type farmer_id: str
        :param body: New state of farmer.
        :type body: ~dpsclient.models.Farmer
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: Farmer, or the result of cls(response)
        :rtype: ~dpsclient.models.Farmer
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType["_models.Farmer"]
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}))
        api_version = "2020-12-31-preview"
        content_type = kwargs.pop("content_type", "application/json")
        accept = "application/json"

        # Construct URL
        url = self.update_farmer.metadata['url']  # type: ignore
        path_format_arguments = {
            'farmerId': self._serialize.url("farmer_id", farmer_id, 'str'),
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]
        query_parameters['api-version'] = self._serialize.query("api_version", api_version, 'str')

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]
        header_parameters['Content-Type'] = self._serialize.header("content_type", content_type, 'str')
        header_parameters['Accept'] = self._serialize.header("accept", accept, 'str')

        body_content_kwargs = {}  # type: Dict[str, Any]
        if body is not None:
            body_content = self._serialize.body(body, 'Farmer')
        else:
            body_content = None
        body_content_kwargs['content'] = body_content
        request = self._client.patch(url, query_parameters, header_parameters, **body_content_kwargs)
        pipeline_response = await self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        deserialized = self._deserialize('Farmer', pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized
    update_farmer.metadata = {'url': '/farmers/{farmerId}'}  # type: ignore

    async def delete_farmer(
        self,
        farmer_id: str,
        **kwargs
    ) -> None:
        """Deletes Farmer for given farmer id.

        :param farmer_id: Id of farmer to be deleted.
        :type farmer_id: str
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: None, or the result of cls(response)
        :rtype: None
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType[None]
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}))
        api_version = "2020-12-31-preview"

        # Construct URL
        url = self.delete_farmer.metadata['url']  # type: ignore
        path_format_arguments = {
            'farmerId': self._serialize.url("farmer_id", farmer_id, 'str'),
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]
        query_parameters['api-version'] = self._serialize.query("api_version", api_version, 'str')

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]

        request = self._client.delete(url, query_parameters, header_parameters)
        pipeline_response = await self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if cls:
            return cls(pipeline_response, None, {})

    delete_farmer.metadata = {'url': '/farmers/{farmerId}'}  # type: ignore

    async def get_farmers(
        self,
        ids: Optional[List[str]] = None,
        names: Optional[List[str]] = None,
        property_filters: Optional[List[str]] = None,
        statuses: Optional[List[str]] = None,
        min_created_date_time: Optional[datetime.datetime] = None,
        max_created_date_time: Optional[datetime.datetime] = None,
        min_last_modified_date_time: Optional[datetime.datetime] = None,
        max_last_modified_date_time: Optional[datetime.datetime] = None,
        max_page_size: Optional[int] = 50,
        skip_token: Optional[str] = None,
        **kwargs
    ) -> "_models.FarmerListResponse":
        """Returns a list of farmers.

        :param ids: Ids of the resource.
        :type ids: list[str]
        :param names: Names of the resource.
        :type names: list[str]
        :param property_filters: Filters on key-value pairs within the Properties object.
         eg. "{testkey} eq {testvalue}".
        :type property_filters: list[str]
        :param statuses: Statuses of the resource.
        :type statuses: list[str]
        :param min_created_date_time: Minimum creation date of resource (inclusive).
        :type min_created_date_time: ~datetime.datetime
        :param max_created_date_time: Maximum creation date of resource (inclusive).
        :type max_created_date_time: ~datetime.datetime
        :param min_last_modified_date_time: Minimum last modified date of resource (inclusive).
        :type min_last_modified_date_time: ~datetime.datetime
        :param max_last_modified_date_time: Maximum last modified date of resource (inclusive).
        :type max_last_modified_date_time: ~datetime.datetime
        :param max_page_size: Maximum number of items needed (inclusive).
         Minimum = 10, Maximum = 1000, Default value = 50.
        :type max_page_size: int
        :param skip_token: Skip token for getting next set of results.
        :type skip_token: str
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: FarmerListResponse, or the result of cls(response)
        :rtype: ~dpsclient.models.FarmerListResponse
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType["_models.FarmerListResponse"]
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}))
        api_version = "2020-12-31-preview"
        accept = "application/json"

        # Construct URL
        url = self.get_farmers.metadata['url']  # type: ignore

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]
        if ids is not None:
            query_parameters['ids'] = [self._serialize.query("ids", q, 'str') if q is not None else '' for q in ids]
        if names is not None:
            query_parameters['names'] = [self._serialize.query("names", q, 'str') if q is not None else '' for q in names]
        if property_filters is not None:
            query_parameters['propertyFilters'] = [self._serialize.query("property_filters", q, 'str') if q is not None else '' for q in property_filters]
        if statuses is not None:
            query_parameters['statuses'] = [self._serialize.query("statuses", q, 'str') if q is not None else '' for q in statuses]
        if min_created_date_time is not None:
            query_parameters['minCreatedDateTime'] = self._serialize.query("min_created_date_time", min_created_date_time, 'iso-8601')
        if max_created_date_time is not None:
            query_parameters['maxCreatedDateTime'] = self._serialize.query("max_created_date_time", max_created_date_time, 'iso-8601')
        if min_last_modified_date_time is not None:
            query_parameters['minLastModifiedDateTime'] = self._serialize.query("min_last_modified_date_time", min_last_modified_date_time, 'iso-8601')
        if max_last_modified_date_time is not None:
            query_parameters['maxLastModifiedDateTime'] = self._serialize.query("max_last_modified_date_time", max_last_modified_date_time, 'iso-8601')
        if max_page_size is not None:
            query_parameters['$maxPageSize'] = self._serialize.query("max_page_size", max_page_size, 'int', maximum=1000, minimum=10)
        if skip_token is not None:
            query_parameters['$skipToken'] = self._serialize.query("skip_token", skip_token, 'str')
        query_parameters['api-version'] = self._serialize.query("api_version", api_version, 'str')

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]
        header_parameters['Accept'] = self._serialize.header("accept", accept, 'str')

        request = self._client.get(url, query_parameters, header_parameters)
        pipeline_response = await self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        deserialized = self._deserialize('FarmerListResponse', pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized
    get_farmers.metadata = {'url': '/farmers'}  # type: ignore

    async def get_field(
        self,
        farmer_id: str,
        field_id: str,
        **kwargs
    ) -> "_models.Field":
        """Get field object with given fieldId.

        :param farmer_id: Id of the farmer.
        :type farmer_id: str
        :param field_id: Id of the field.
        :type field_id: str
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: Field, or the result of cls(response)
        :rtype: ~dpsclient.models.Field
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType["_models.Field"]
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}))
        api_version = "2020-12-31-preview"
        accept = "application/json"

        # Construct URL
        url = self.get_field.metadata['url']  # type: ignore
        path_format_arguments = {
            'farmerId': self._serialize.url("farmer_id", farmer_id, 'str'),
            'fieldId': self._serialize.url("field_id", field_id, 'str'),
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]
        query_parameters['api-version'] = self._serialize.query("api_version", api_version, 'str')

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]
        header_parameters['Accept'] = self._serialize.header("accept", accept, 'str')

        request = self._client.get(url, query_parameters, header_parameters)
        pipeline_response = await self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        deserialized = self._deserialize('Field', pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized
    get_field.metadata = {'url': '/farmers/{farmerId}/fields/{fieldId}'}  # type: ignore

    async def create_field(
        self,
        farmer_id: str,
        field_id: str,
        body: Optional["_models.Field"] = None,
        **kwargs
    ) -> "_models.Field":
        """Creates new field object with given request body.

        :param farmer_id: Id of the associated farmer.
        :type farmer_id: str
        :param field_id: Field id.
        :type field_id: str
        :param body: Field Create object.
        :type body: ~dpsclient.models.Field
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: Field, or the result of cls(response)
        :rtype: ~dpsclient.models.Field
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType["_models.Field"]
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}))
        api_version = "2020-12-31-preview"
        content_type = kwargs.pop("content_type", "application/json")
        accept = "application/json"

        # Construct URL
        url = self.create_field.metadata['url']  # type: ignore
        path_format_arguments = {
            'farmerId': self._serialize.url("farmer_id", farmer_id, 'str'),
            'fieldId': self._serialize.url("field_id", field_id, 'str'),
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]
        query_parameters['api-version'] = self._serialize.query("api_version", api_version, 'str')

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]
        header_parameters['Content-Type'] = self._serialize.header("content_type", content_type, 'str')
        header_parameters['Accept'] = self._serialize.header("accept", accept, 'str')

        body_content_kwargs = {}  # type: Dict[str, Any]
        if body is not None:
            body_content = self._serialize.body(body, 'Field')
        else:
            body_content = None
        body_content_kwargs['content'] = body_content
        request = self._client.put(url, query_parameters, header_parameters, **body_content_kwargs)
        pipeline_response = await self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [201]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        deserialized = self._deserialize('Field', pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized
    create_field.metadata = {'url': '/farmers/{farmerId}/fields/{fieldId}'}  # type: ignore

    async def update_field(
        self,
        farmer_id: str,
        field_id: str,
        body: Optional["_models.Field"] = None,
        **kwargs
    ) -> "_models.Field":
        """Updates Field for given field Id.

        :param farmer_id: Id of the farmer.
        :type farmer_id: str
        :param field_id: Id of the field.
        :type field_id: str
        :param body: New state of field.
        :type body: ~dpsclient.models.Field
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: Field, or the result of cls(response)
        :rtype: ~dpsclient.models.Field
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType["_models.Field"]
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}))
        api_version = "2020-12-31-preview"
        content_type = kwargs.pop("content_type", "application/json")
        accept = "application/json"

        # Construct URL
        url = self.update_field.metadata['url']  # type: ignore
        path_format_arguments = {
            'farmerId': self._serialize.url("farmer_id", farmer_id, 'str'),
            'fieldId': self._serialize.url("field_id", field_id, 'str'),
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]
        query_parameters['api-version'] = self._serialize.query("api_version", api_version, 'str')

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]
        header_parameters['Content-Type'] = self._serialize.header("content_type", content_type, 'str')
        header_parameters['Accept'] = self._serialize.header("accept", accept, 'str')

        body_content_kwargs = {}  # type: Dict[str, Any]
        if body is not None:
            body_content = self._serialize.body(body, 'Field')
        else:
            body_content = None
        body_content_kwargs['content'] = body_content
        request = self._client.patch(url, query_parameters, header_parameters, **body_content_kwargs)
        pipeline_response = await self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        deserialized = self._deserialize('Field', pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized
    update_field.metadata = {'url': '/farmers/{farmerId}/fields/{fieldId}'}  # type: ignore

    async def delete_field(
        self,
        farmer_id: str,
        field_id: str,
        **kwargs
    ) -> None:
        """Deletes Field for given id.

        :param farmer_id: Id of the farmer.
        :type farmer_id: str
        :param field_id: Id of the field.
        :type field_id: str
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: None, or the result of cls(response)
        :rtype: None
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType[None]
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}))
        api_version = "2020-12-31-preview"

        # Construct URL
        url = self.delete_field.metadata['url']  # type: ignore
        path_format_arguments = {
            'farmerId': self._serialize.url("farmer_id", farmer_id, 'str'),
            'fieldId': self._serialize.url("field_id", field_id, 'str'),
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]
        query_parameters['api-version'] = self._serialize.query("api_version", api_version, 'str')

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]

        request = self._client.delete(url, query_parameters, header_parameters)
        pipeline_response = await self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if cls:
            return cls(pipeline_response, None, {})

    delete_field.metadata = {'url': '/farmers/{farmerId}/fields/{fieldId}'}  # type: ignore

    async def get_fields(
        self,
        farmer_id: str,
        farm_ids: Optional[List[str]] = None,
        ids: Optional[List[str]] = None,
        names: Optional[List[str]] = None,
        property_filters: Optional[List[str]] = None,
        statuses: Optional[List[str]] = None,
        min_created_date_time: Optional[datetime.datetime] = None,
        max_created_date_time: Optional[datetime.datetime] = None,
        min_last_modified_date_time: Optional[datetime.datetime] = None,
        max_last_modified_date_time: Optional[datetime.datetime] = None,
        max_page_size: Optional[int] = 50,
        skip_token: Optional[str] = None,
        **kwargs
    ) -> "_models.FieldListResponse":
        """Returns a list of fields.

        :param farmer_id: Id of the Farmer.
        :type farmer_id: str
        :param farm_ids: Farm Ids of the resource.
        :type farm_ids: list[str]
        :param ids: Ids of the resource.
        :type ids: list[str]
        :param names: Names of the resource.
        :type names: list[str]
        :param property_filters: Filters on key-value pairs within the Properties object.
         eg. "{testkey} eq {testvalue}".
        :type property_filters: list[str]
        :param statuses: Statuses of the resource.
        :type statuses: list[str]
        :param min_created_date_time: Minimum creation date of resource (inclusive).
        :type min_created_date_time: ~datetime.datetime
        :param max_created_date_time: Maximum creation date of resource (inclusive).
        :type max_created_date_time: ~datetime.datetime
        :param min_last_modified_date_time: Minimum last modified date of resource (inclusive).
        :type min_last_modified_date_time: ~datetime.datetime
        :param max_last_modified_date_time: Maximum last modified date of resource (inclusive).
        :type max_last_modified_date_time: ~datetime.datetime
        :param max_page_size: Maximum number of items needed (inclusive).
         Minimum = 10, Maximum = 1000, Default value = 50.
        :type max_page_size: int
        :param skip_token: Skip token for getting next set of results.
        :type skip_token: str
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: FieldListResponse, or the result of cls(response)
        :rtype: ~dpsclient.models.FieldListResponse
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType["_models.FieldListResponse"]
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}))
        api_version = "2020-12-31-preview"
        accept = "application/json"

        # Construct URL
        url = self.get_fields.metadata['url']  # type: ignore
        path_format_arguments = {
            'farmerId': self._serialize.url("farmer_id", farmer_id, 'str'),
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]
        if farm_ids is not None:
            query_parameters['farmIds'] = [self._serialize.query("farm_ids", q, 'str') if q is not None else '' for q in farm_ids]
        if ids is not None:
            query_parameters['ids'] = [self._serialize.query("ids", q, 'str') if q is not None else '' for q in ids]
        if names is not None:
            query_parameters['names'] = [self._serialize.query("names", q, 'str') if q is not None else '' for q in names]
        if property_filters is not None:
            query_parameters['propertyFilters'] = [self._serialize.query("property_filters", q, 'str') if q is not None else '' for q in property_filters]
        if statuses is not None:
            query_parameters['statuses'] = [self._serialize.query("statuses", q, 'str') if q is not None else '' for q in statuses]
        if min_created_date_time is not None:
            query_parameters['minCreatedDateTime'] = self._serialize.query("min_created_date_time", min_created_date_time, 'iso-8601')
        if max_created_date_time is not None:
            query_parameters['maxCreatedDateTime'] = self._serialize.query("max_created_date_time", max_created_date_time, 'iso-8601')
        if min_last_modified_date_time is not None:
            query_parameters['minLastModifiedDateTime'] = self._serialize.query("min_last_modified_date_time", min_last_modified_date_time, 'iso-8601')
        if max_last_modified_date_time is not None:
            query_parameters['maxLastModifiedDateTime'] = self._serialize.query("max_last_modified_date_time", max_last_modified_date_time, 'iso-8601')
        if max_page_size is not None:
            query_parameters['$maxPageSize'] = self._serialize.query("max_page_size", max_page_size, 'int', maximum=1000, minimum=10)
        if skip_token is not None:
            query_parameters['$skipToken'] = self._serialize.query("skip_token", skip_token, 'str')
        query_parameters['api-version'] = self._serialize.query("api_version", api_version, 'str')

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]
        header_parameters['Accept'] = self._serialize.header("accept", accept, 'str')

        request = self._client.get(url, query_parameters, header_parameters)
        pipeline_response = await self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        deserialized = self._deserialize('FieldListResponse', pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized
    get_fields.metadata = {'url': '/farmers/{farmerId}/fields'}  # type: ignore

    async def get_all_fields(
        self,
        farm_ids: Optional[List[str]] = None,
        ids: Optional[List[str]] = None,
        names: Optional[List[str]] = None,
        property_filters: Optional[List[str]] = None,
        statuses: Optional[List[str]] = None,
        min_created_date_time: Optional[datetime.datetime] = None,
        max_created_date_time: Optional[datetime.datetime] = None,
        min_last_modified_date_time: Optional[datetime.datetime] = None,
        max_last_modified_date_time: Optional[datetime.datetime] = None,
        max_page_size: Optional[int] = 50,
        skip_token: Optional[str] = None,
        **kwargs
    ) -> "_models.FieldListResponse":
        """Returns a list of fields across all farmers.

        :param farm_ids: Farm Ids of the resource.
        :type farm_ids: list[str]
        :param ids: Ids of the resource.
        :type ids: list[str]
        :param names: Names of the resource.
        :type names: list[str]
        :param property_filters: Filters on key-value pairs within the Properties object.
         eg. "{testkey} eq {testvalue}".
        :type property_filters: list[str]
        :param statuses: Statuses of the resource.
        :type statuses: list[str]
        :param min_created_date_time: Minimum creation date of resource (inclusive).
        :type min_created_date_time: ~datetime.datetime
        :param max_created_date_time: Maximum creation date of resource (inclusive).
        :type max_created_date_time: ~datetime.datetime
        :param min_last_modified_date_time: Minimum last modified date of resource (inclusive).
        :type min_last_modified_date_time: ~datetime.datetime
        :param max_last_modified_date_time: Maximum last modified date of resource (inclusive).
        :type max_last_modified_date_time: ~datetime.datetime
        :param max_page_size: Maximum number of items needed (inclusive).
         Minimum = 10, Maximum = 1000, Default value = 50.
        :type max_page_size: int
        :param skip_token: Skip token for getting next set of results.
        :type skip_token: str
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: FieldListResponse, or the result of cls(response)
        :rtype: ~dpsclient.models.FieldListResponse
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType["_models.FieldListResponse"]
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}))
        api_version = "2020-12-31-preview"
        accept = "application/json"

        # Construct URL
        url = self.get_all_fields.metadata['url']  # type: ignore

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]
        if farm_ids is not None:
            query_parameters['farmIds'] = [self._serialize.query("farm_ids", q, 'str') if q is not None else '' for q in farm_ids]
        if ids is not None:
            query_parameters['ids'] = [self._serialize.query("ids", q, 'str') if q is not None else '' for q in ids]
        if names is not None:
            query_parameters['names'] = [self._serialize.query("names", q, 'str') if q is not None else '' for q in names]
        if property_filters is not None:
            query_parameters['propertyFilters'] = [self._serialize.query("property_filters", q, 'str') if q is not None else '' for q in property_filters]
        if statuses is not None:
            query_parameters['statuses'] = [self._serialize.query("statuses", q, 'str') if q is not None else '' for q in statuses]
        if min_created_date_time is not None:
            query_parameters['minCreatedDateTime'] = self._serialize.query("min_created_date_time", min_created_date_time, 'iso-8601')
        if max_created_date_time is not None:
            query_parameters['maxCreatedDateTime'] = self._serialize.query("max_created_date_time", max_created_date_time, 'iso-8601')
        if min_last_modified_date_time is not None:
            query_parameters['minLastModifiedDateTime'] = self._serialize.query("min_last_modified_date_time", min_last_modified_date_time, 'iso-8601')
        if max_last_modified_date_time is not None:
            query_parameters['maxLastModifiedDateTime'] = self._serialize.query("max_last_modified_date_time", max_last_modified_date_time, 'iso-8601')
        if max_page_size is not None:
            query_parameters['$maxPageSize'] = self._serialize.query("max_page_size", max_page_size, 'int', maximum=1000, minimum=10)
        if skip_token is not None:
            query_parameters['$skipToken'] = self._serialize.query("skip_token", skip_token, 'str')
        query_parameters['api-version'] = self._serialize.query("api_version", api_version, 'str')

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]
        header_parameters['Accept'] = self._serialize.header("accept", accept, 'str')

        request = self._client.get(url, query_parameters, header_parameters)
        pipeline_response = await self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        deserialized = self._deserialize('FieldListResponse', pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized
    get_all_fields.metadata = {'url': '/fields'}  # type: ignore

    async def get_harvest_data(
        self,
        harvest_data_id: str,
        farmer_id: str,
        **kwargs
    ) -> "_models.HarvestData":
        """Get HarvestData object with given id and farmer id.

        :param harvest_data_id: HarvestData id.
        :type harvest_data_id: str
        :param farmer_id: Farmer id.
        :type farmer_id: str
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: HarvestData, or the result of cls(response)
        :rtype: ~dpsclient.models.HarvestData
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType["_models.HarvestData"]
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}))
        api_version = "2020-12-31-preview"
        accept = "application/json"

        # Construct URL
        url = self.get_harvest_data.metadata['url']  # type: ignore
        path_format_arguments = {
            'harvestDataId': self._serialize.url("harvest_data_id", harvest_data_id, 'str'),
            'farmerId': self._serialize.url("farmer_id", farmer_id, 'str'),
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]
        query_parameters['api-version'] = self._serialize.query("api_version", api_version, 'str')

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]
        header_parameters['Accept'] = self._serialize.header("accept", accept, 'str')

        request = self._client.get(url, query_parameters, header_parameters)
        pipeline_response = await self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        deserialized = self._deserialize('HarvestData', pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized
    get_harvest_data.metadata = {'url': '/farmers/{farmerId}/harvestData/{harvestDataId}'}  # type: ignore

    async def create_harvest_data(
        self,
        farmer_id: str,
        harvest_data_id: str,
        body: Optional["_models.HarvestData"] = None,
        **kwargs
    ) -> "_models.HarvestData":
        """Creates new HarvestData object with given request body.

        :param farmer_id: Id of the associated farmer.
        :type farmer_id: str
        :param harvest_data_id: HarvestData id.
        :type harvest_data_id: str
        :param body: HarvestData object.
        :type body: ~dpsclient.models.HarvestData
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: HarvestData, or the result of cls(response)
        :rtype: ~dpsclient.models.HarvestData
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType["_models.HarvestData"]
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}))
        api_version = "2020-12-31-preview"
        content_type = kwargs.pop("content_type", "application/json")
        accept = "application/json"

        # Construct URL
        url = self.create_harvest_data.metadata['url']  # type: ignore
        path_format_arguments = {
            'farmerId': self._serialize.url("farmer_id", farmer_id, 'str'),
            'harvestDataId': self._serialize.url("harvest_data_id", harvest_data_id, 'str'),
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]
        query_parameters['api-version'] = self._serialize.query("api_version", api_version, 'str')

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]
        header_parameters['Content-Type'] = self._serialize.header("content_type", content_type, 'str')
        header_parameters['Accept'] = self._serialize.header("accept", accept, 'str')

        body_content_kwargs = {}  # type: Dict[str, Any]
        if body is not None:
            body_content = self._serialize.body(body, 'HarvestData')
        else:
            body_content = None
        body_content_kwargs['content'] = body_content
        request = self._client.put(url, query_parameters, header_parameters, **body_content_kwargs)
        pipeline_response = await self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [201]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        deserialized = self._deserialize('HarvestData', pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized
    create_harvest_data.metadata = {'url': '/farmers/{farmerId}/harvestData/{harvestDataId}'}  # type: ignore

    async def update_harvest_data(
        self,
        farmer_id: str,
        harvest_data_id: str,
        body: Optional["_models.HarvestData"] = None,
        **kwargs
    ) -> "_models.HarvestData":
        """Updates HarvestData object with given request body.

        :param farmer_id: Id of the farmer.
        :type farmer_id: str
        :param harvest_data_id: Id of the HarvestData.
        :type harvest_data_id: str
        :param body: HarvestData object.
        :type body: ~dpsclient.models.HarvestData
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: HarvestData, or the result of cls(response)
        :rtype: ~dpsclient.models.HarvestData
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType["_models.HarvestData"]
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}))
        api_version = "2020-12-31-preview"
        content_type = kwargs.pop("content_type", "application/json")
        accept = "application/json"

        # Construct URL
        url = self.update_harvest_data.metadata['url']  # type: ignore
        path_format_arguments = {
            'farmerId': self._serialize.url("farmer_id", farmer_id, 'str'),
            'harvestDataId': self._serialize.url("harvest_data_id", harvest_data_id, 'str'),
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]
        query_parameters['api-version'] = self._serialize.query("api_version", api_version, 'str')

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]
        header_parameters['Content-Type'] = self._serialize.header("content_type", content_type, 'str')
        header_parameters['Accept'] = self._serialize.header("accept", accept, 'str')

        body_content_kwargs = {}  # type: Dict[str, Any]
        if body is not None:
            body_content = self._serialize.body(body, 'HarvestData')
        else:
            body_content = None
        body_content_kwargs['content'] = body_content
        request = self._client.patch(url, query_parameters, header_parameters, **body_content_kwargs)
        pipeline_response = await self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        deserialized = self._deserialize('HarvestData', pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized
    update_harvest_data.metadata = {'url': '/farmers/{farmerId}/harvestData/{harvestDataId}'}  # type: ignore

    async def delete_harvest_data(
        self,
        farmer_id: str,
        harvest_data_id: str,
        **kwargs
    ) -> None:
        """Deletes HarvestData object associated with given id.

        :param farmer_id: Id of the associated farmer.
        :type farmer_id: str
        :param harvest_data_id: Id of the HarvestData.
        :type harvest_data_id: str
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: None, or the result of cls(response)
        :rtype: None
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType[None]
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}))
        api_version = "2020-12-31-preview"

        # Construct URL
        url = self.delete_harvest_data.metadata['url']  # type: ignore
        path_format_arguments = {
            'farmerId': self._serialize.url("farmer_id", farmer_id, 'str'),
            'harvestDataId': self._serialize.url("harvest_data_id", harvest_data_id, 'str'),
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]
        query_parameters['api-version'] = self._serialize.query("api_version", api_version, 'str')

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]

        request = self._client.delete(url, query_parameters, header_parameters)
        pipeline_response = await self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if cls:
            return cls(pipeline_response, None, {})

    delete_harvest_data.metadata = {'url': '/farmers/{farmerId}/harvestData/{harvestDataId}'}  # type: ignore

    async def get_all_harvest_data(
        self,
        farmer_id: str,
        min_total_yield: Optional[float] = None,
        max_total_yield: Optional[float] = None,
        min_avg_yield: Optional[float] = None,
        max_avg_yield: Optional[float] = None,
        min_wet_mass: Optional[float] = None,
        max_wet_mass: Optional[float] = None,
        min_avg_wet_mass: Optional[float] = None,
        max_avg_wet_mass: Optional[float] = None,
        min_avg_moisture: Optional[float] = None,
        max_avg_moisture: Optional[float] = None,
        min_avg_speed: Optional[float] = None,
        max_avg_speed: Optional[float] = None,
        sources: Optional[List[str]] = None,
        associated_boundary_ids: Optional[List[str]] = None,
        operation_boundary_ids: Optional[List[str]] = None,
        min_operation_start_date_time: Optional[datetime.datetime] = None,
        max_operation_start_date_time: Optional[datetime.datetime] = None,
        min_operation_end_date_time: Optional[datetime.datetime] = None,
        max_operation_end_date_time: Optional[datetime.datetime] = None,
        min_operation_modified_date_time: Optional[datetime.datetime] = None,
        max_operation_modified_date_time: Optional[datetime.datetime] = None,
        min_area: Optional[float] = None,
        max_area: Optional[float] = None,
        ids: Optional[List[str]] = None,
        names: Optional[List[str]] = None,
        property_filters: Optional[List[str]] = None,
        statuses: Optional[List[str]] = None,
        min_created_date_time: Optional[datetime.datetime] = None,
        max_created_date_time: Optional[datetime.datetime] = None,
        min_last_modified_date_time: Optional[datetime.datetime] = None,
        max_last_modified_date_time: Optional[datetime.datetime] = None,
        max_page_size: Optional[int] = 50,
        skip_token: Optional[str] = None,
        **kwargs
    ) -> "_models.HarvestDataListResponse":
        """Returns a list of HarvestData documents.

        :param farmer_id: Id of the associated farmer.
        :type farmer_id: str
        :param min_total_yield: Minimum Yield value(inclusive).
        :type min_total_yield: float
        :param max_total_yield: Maximum Yield value (inclusive).
        :type max_total_yield: float
        :param min_avg_yield: Minimum AvgYield value(inclusive).
        :type min_avg_yield: float
        :param max_avg_yield: Maximum AvgYield value (inclusive).
        :type max_avg_yield: float
        :param min_wet_mass: Minimum WetMass value(inclusive).
        :type min_wet_mass: float
        :param max_wet_mass: Maximum WetMass value (inclusive).
        :type max_wet_mass: float
        :param min_avg_wet_mass: Minimum AvgWetMass value(inclusive).
        :type min_avg_wet_mass: float
        :param max_avg_wet_mass: Maximum AvgWetMass value (inclusive).
        :type max_avg_wet_mass: float
        :param min_avg_moisture: Minimum AvgMoisture value(inclusive).
        :type min_avg_moisture: float
        :param max_avg_moisture: Maximum AvgMoisture value (inclusive).
        :type max_avg_moisture: float
        :param min_avg_speed: Minimum AvgSpeed value(inclusive).
        :type min_avg_speed: float
        :param max_avg_speed: Maximum AvgSpeed value (inclusive).
        :type max_avg_speed: float
        :param sources: Source of the operation data.
        :type sources: list[str]
        :param associated_boundary_ids: Boundary ids associated with operation data.
        :type associated_boundary_ids: list[str]
        :param operation_boundary_ids: Operation boundary ids associated with operation data.
        :type operation_boundary_ids: list[str]
        :param min_operation_start_date_time: Minimum operation StartDateTime (inclusive).
        :type min_operation_start_date_time: ~datetime.datetime
        :param max_operation_start_date_time: Maximum operation StartDateTime (inclusive).
        :type max_operation_start_date_time: ~datetime.datetime
        :param min_operation_end_date_time: Minimum operation EndDateTime (inclusive).
        :type min_operation_end_date_time: ~datetime.datetime
        :param max_operation_end_date_time: Maximum operation EndDateTime (inclusive).
        :type max_operation_end_date_time: ~datetime.datetime
        :param min_operation_modified_date_time: Minimum OperationModifiedDateTime (inclusive).
        :type min_operation_modified_date_time: ~datetime.datetime
        :param max_operation_modified_date_time: Maximum OperationModifiedDateTime (inclusive).
        :type max_operation_modified_date_time: ~datetime.datetime
        :param min_area: Minimum Area value(inclusive).
        :type min_area: float
        :param max_area: Maximum Area value (inclusive).
        :type max_area: float
        :param ids: Ids of the resource.
        :type ids: list[str]
        :param names: Names of the resource.
        :type names: list[str]
        :param property_filters: Filters on key-value pairs within the Properties object.
         eg. "{testkey} eq {testvalue}".
        :type property_filters: list[str]
        :param statuses: Statuses of the resource.
        :type statuses: list[str]
        :param min_created_date_time: Minimum creation date of resource (inclusive).
        :type min_created_date_time: ~datetime.datetime
        :param max_created_date_time: Maximum creation date of resource (inclusive).
        :type max_created_date_time: ~datetime.datetime
        :param min_last_modified_date_time: Minimum last modified date of resource (inclusive).
        :type min_last_modified_date_time: ~datetime.datetime
        :param max_last_modified_date_time: Maximum last modified date of resource (inclusive).
        :type max_last_modified_date_time: ~datetime.datetime
        :param max_page_size: Maximum number of items needed (inclusive).
         Minimum = 10, Maximum = 1000, Default value = 50.
        :type max_page_size: int
        :param skip_token: Skip token for getting next set of results.
        :type skip_token: str
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: HarvestDataListResponse, or the result of cls(response)
        :rtype: ~dpsclient.models.HarvestDataListResponse
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType["_models.HarvestDataListResponse"]
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}))
        api_version = "2020-12-31-preview"
        accept = "application/json"

        # Construct URL
        url = self.get_all_harvest_data.metadata['url']  # type: ignore
        path_format_arguments = {
            'farmerId': self._serialize.url("farmer_id", farmer_id, 'str'),
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]
        if min_total_yield is not None:
            query_parameters['minTotalYield'] = self._serialize.query("min_total_yield", min_total_yield, 'float')
        if max_total_yield is not None:
            query_parameters['maxTotalYield'] = self._serialize.query("max_total_yield", max_total_yield, 'float')
        if min_avg_yield is not None:
            query_parameters['minAvgYield'] = self._serialize.query("min_avg_yield", min_avg_yield, 'float')
        if max_avg_yield is not None:
            query_parameters['maxAvgYield'] = self._serialize.query("max_avg_yield", max_avg_yield, 'float')
        if min_wet_mass is not None:
            query_parameters['minWetMass'] = self._serialize.query("min_wet_mass", min_wet_mass, 'float')
        if max_wet_mass is not None:
            query_parameters['maxWetMass'] = self._serialize.query("max_wet_mass", max_wet_mass, 'float')
        if min_avg_wet_mass is not None:
            query_parameters['minAvgWetMass'] = self._serialize.query("min_avg_wet_mass", min_avg_wet_mass, 'float')
        if max_avg_wet_mass is not None:
            query_parameters['maxAvgWetMass'] = self._serialize.query("max_avg_wet_mass", max_avg_wet_mass, 'float')
        if min_avg_moisture is not None:
            query_parameters['minAvgMoisture'] = self._serialize.query("min_avg_moisture", min_avg_moisture, 'float')
        if max_avg_moisture is not None:
            query_parameters['maxAvgMoisture'] = self._serialize.query("max_avg_moisture", max_avg_moisture, 'float')
        if min_avg_speed is not None:
            query_parameters['minAvgSpeed'] = self._serialize.query("min_avg_speed", min_avg_speed, 'float')
        if max_avg_speed is not None:
            query_parameters['maxAvgSpeed'] = self._serialize.query("max_avg_speed", max_avg_speed, 'float')
        if sources is not None:
            query_parameters['sources'] = [self._serialize.query("sources", q, 'str') if q is not None else '' for q in sources]
        if associated_boundary_ids is not None:
            query_parameters['associatedBoundaryIds'] = [self._serialize.query("associated_boundary_ids", q, 'str') if q is not None else '' for q in associated_boundary_ids]
        if operation_boundary_ids is not None:
            query_parameters['operationBoundaryIds'] = [self._serialize.query("operation_boundary_ids", q, 'str') if q is not None else '' for q in operation_boundary_ids]
        if min_operation_start_date_time is not None:
            query_parameters['minOperationStartDateTime'] = self._serialize.query("min_operation_start_date_time", min_operation_start_date_time, 'iso-8601')
        if max_operation_start_date_time is not None:
            query_parameters['maxOperationStartDateTime'] = self._serialize.query("max_operation_start_date_time", max_operation_start_date_time, 'iso-8601')
        if min_operation_end_date_time is not None:
            query_parameters['minOperationEndDateTime'] = self._serialize.query("min_operation_end_date_time", min_operation_end_date_time, 'iso-8601')
        if max_operation_end_date_time is not None:
            query_parameters['maxOperationEndDateTime'] = self._serialize.query("max_operation_end_date_time", max_operation_end_date_time, 'iso-8601')
        if min_operation_modified_date_time is not None:
            query_parameters['minOperationModifiedDateTime'] = self._serialize.query("min_operation_modified_date_time", min_operation_modified_date_time, 'iso-8601')
        if max_operation_modified_date_time is not None:
            query_parameters['maxOperationModifiedDateTime'] = self._serialize.query("max_operation_modified_date_time", max_operation_modified_date_time, 'iso-8601')
        if min_area is not None:
            query_parameters['minArea'] = self._serialize.query("min_area", min_area, 'float')
        if max_area is not None:
            query_parameters['maxArea'] = self._serialize.query("max_area", max_area, 'float')
        if ids is not None:
            query_parameters['ids'] = [self._serialize.query("ids", q, 'str') if q is not None else '' for q in ids]
        if names is not None:
            query_parameters['names'] = [self._serialize.query("names", q, 'str') if q is not None else '' for q in names]
        if property_filters is not None:
            query_parameters['propertyFilters'] = [self._serialize.query("property_filters", q, 'str') if q is not None else '' for q in property_filters]
        if statuses is not None:
            query_parameters['statuses'] = [self._serialize.query("statuses", q, 'str') if q is not None else '' for q in statuses]
        if min_created_date_time is not None:
            query_parameters['minCreatedDateTime'] = self._serialize.query("min_created_date_time", min_created_date_time, 'iso-8601')
        if max_created_date_time is not None:
            query_parameters['maxCreatedDateTime'] = self._serialize.query("max_created_date_time", max_created_date_time, 'iso-8601')
        if min_last_modified_date_time is not None:
            query_parameters['minLastModifiedDateTime'] = self._serialize.query("min_last_modified_date_time", min_last_modified_date_time, 'iso-8601')
        if max_last_modified_date_time is not None:
            query_parameters['maxLastModifiedDateTime'] = self._serialize.query("max_last_modified_date_time", max_last_modified_date_time, 'iso-8601')
        if max_page_size is not None:
            query_parameters['$maxPageSize'] = self._serialize.query("max_page_size", max_page_size, 'int', maximum=1000, minimum=10)
        if skip_token is not None:
            query_parameters['$skipToken'] = self._serialize.query("skip_token", skip_token, 'str')
        query_parameters['api-version'] = self._serialize.query("api_version", api_version, 'str')

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]
        header_parameters['Accept'] = self._serialize.header("accept", accept, 'str')

        request = self._client.get(url, query_parameters, header_parameters)
        pipeline_response = await self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        deserialized = self._deserialize('HarvestDataListResponse', pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized
    get_all_harvest_data.metadata = {'url': '/farmers/{farmerId}/harvestData'}  # type: ignore

    async def get_all_harvest_data_across_farmers(
        self,
        min_total_yield: Optional[float] = None,
        max_total_yield: Optional[float] = None,
        min_avg_yield: Optional[float] = None,
        max_avg_yield: Optional[float] = None,
        min_wet_mass: Optional[float] = None,
        max_wet_mass: Optional[float] = None,
        min_avg_wet_mass: Optional[float] = None,
        max_avg_wet_mass: Optional[float] = None,
        min_avg_moisture: Optional[float] = None,
        max_avg_moisture: Optional[float] = None,
        min_avg_speed: Optional[float] = None,
        max_avg_speed: Optional[float] = None,
        sources: Optional[List[str]] = None,
        associated_boundary_ids: Optional[List[str]] = None,
        operation_boundary_ids: Optional[List[str]] = None,
        min_operation_start_date_time: Optional[datetime.datetime] = None,
        max_operation_start_date_time: Optional[datetime.datetime] = None,
        min_operation_end_date_time: Optional[datetime.datetime] = None,
        max_operation_end_date_time: Optional[datetime.datetime] = None,
        min_operation_modified_date_time: Optional[datetime.datetime] = None,
        max_operation_modified_date_time: Optional[datetime.datetime] = None,
        min_area: Optional[float] = None,
        max_area: Optional[float] = None,
        ids: Optional[List[str]] = None,
        names: Optional[List[str]] = None,
        property_filters: Optional[List[str]] = None,
        statuses: Optional[List[str]] = None,
        min_created_date_time: Optional[datetime.datetime] = None,
        max_created_date_time: Optional[datetime.datetime] = None,
        min_last_modified_date_time: Optional[datetime.datetime] = None,
        max_last_modified_date_time: Optional[datetime.datetime] = None,
        max_page_size: Optional[int] = 50,
        skip_token: Optional[str] = None,
        **kwargs
    ) -> "_models.HarvestDataListResponse":
        """Returns a list of HarvestData documents.

        :param min_total_yield: Minimum Yield value(inclusive).
        :type min_total_yield: float
        :param max_total_yield: Maximum Yield value (inclusive).
        :type max_total_yield: float
        :param min_avg_yield: Minimum AvgYield value(inclusive).
        :type min_avg_yield: float
        :param max_avg_yield: Maximum AvgYield value (inclusive).
        :type max_avg_yield: float
        :param min_wet_mass: Minimum WetMass value(inclusive).
        :type min_wet_mass: float
        :param max_wet_mass: Maximum WetMass value (inclusive).
        :type max_wet_mass: float
        :param min_avg_wet_mass: Minimum AvgWetMass value(inclusive).
        :type min_avg_wet_mass: float
        :param max_avg_wet_mass: Maximum AvgWetMass value (inclusive).
        :type max_avg_wet_mass: float
        :param min_avg_moisture: Minimum AvgMoisture value(inclusive).
        :type min_avg_moisture: float
        :param max_avg_moisture: Maximum AvgMoisture value (inclusive).
        :type max_avg_moisture: float
        :param min_avg_speed: Minimum AvgSpeed value(inclusive).
        :type min_avg_speed: float
        :param max_avg_speed: Maximum AvgSpeed value (inclusive).
        :type max_avg_speed: float
        :param sources: Source of the operation data.
        :type sources: list[str]
        :param associated_boundary_ids: Boundary ids associated with operation data.
        :type associated_boundary_ids: list[str]
        :param operation_boundary_ids: Operation boundary ids associated with operation data.
        :type operation_boundary_ids: list[str]
        :param min_operation_start_date_time: Minimum operation StartDateTime (inclusive).
        :type min_operation_start_date_time: ~datetime.datetime
        :param max_operation_start_date_time: Maximum operation StartDateTime (inclusive).
        :type max_operation_start_date_time: ~datetime.datetime
        :param min_operation_end_date_time: Minimum operation EndDateTime (inclusive).
        :type min_operation_end_date_time: ~datetime.datetime
        :param max_operation_end_date_time: Maximum operation EndDateTime (inclusive).
        :type max_operation_end_date_time: ~datetime.datetime
        :param min_operation_modified_date_time: Minimum OperationModifiedDateTime (inclusive).
        :type min_operation_modified_date_time: ~datetime.datetime
        :param max_operation_modified_date_time: Maximum OperationModifiedDateTime (inclusive).
        :type max_operation_modified_date_time: ~datetime.datetime
        :param min_area: Minimum Area value(inclusive).
        :type min_area: float
        :param max_area: Maximum Area value (inclusive).
        :type max_area: float
        :param ids: Ids of the resource.
        :type ids: list[str]
        :param names: Names of the resource.
        :type names: list[str]
        :param property_filters: Filters on key-value pairs within the Properties object.
         eg. "{testkey} eq {testvalue}".
        :type property_filters: list[str]
        :param statuses: Statuses of the resource.
        :type statuses: list[str]
        :param min_created_date_time: Minimum creation date of resource (inclusive).
        :type min_created_date_time: ~datetime.datetime
        :param max_created_date_time: Maximum creation date of resource (inclusive).
        :type max_created_date_time: ~datetime.datetime
        :param min_last_modified_date_time: Minimum last modified date of resource (inclusive).
        :type min_last_modified_date_time: ~datetime.datetime
        :param max_last_modified_date_time: Maximum last modified date of resource (inclusive).
        :type max_last_modified_date_time: ~datetime.datetime
        :param max_page_size: Maximum number of items needed (inclusive).
         Minimum = 10, Maximum = 1000, Default value = 50.
        :type max_page_size: int
        :param skip_token: Skip token for getting next set of results.
        :type skip_token: str
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: HarvestDataListResponse, or the result of cls(response)
        :rtype: ~dpsclient.models.HarvestDataListResponse
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType["_models.HarvestDataListResponse"]
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}))
        api_version = "2020-12-31-preview"
        accept = "application/json"

        # Construct URL
        url = self.get_all_harvest_data_across_farmers.metadata['url']  # type: ignore

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]
        if min_total_yield is not None:
            query_parameters['minTotalYield'] = self._serialize.query("min_total_yield", min_total_yield, 'float')
        if max_total_yield is not None:
            query_parameters['maxTotalYield'] = self._serialize.query("max_total_yield", max_total_yield, 'float')
        if min_avg_yield is not None:
            query_parameters['minAvgYield'] = self._serialize.query("min_avg_yield", min_avg_yield, 'float')
        if max_avg_yield is not None:
            query_parameters['maxAvgYield'] = self._serialize.query("max_avg_yield", max_avg_yield, 'float')
        if min_wet_mass is not None:
            query_parameters['minWetMass'] = self._serialize.query("min_wet_mass", min_wet_mass, 'float')
        if max_wet_mass is not None:
            query_parameters['maxWetMass'] = self._serialize.query("max_wet_mass", max_wet_mass, 'float')
        if min_avg_wet_mass is not None:
            query_parameters['minAvgWetMass'] = self._serialize.query("min_avg_wet_mass", min_avg_wet_mass, 'float')
        if max_avg_wet_mass is not None:
            query_parameters['maxAvgWetMass'] = self._serialize.query("max_avg_wet_mass", max_avg_wet_mass, 'float')
        if min_avg_moisture is not None:
            query_parameters['minAvgMoisture'] = self._serialize.query("min_avg_moisture", min_avg_moisture, 'float')
        if max_avg_moisture is not None:
            query_parameters['maxAvgMoisture'] = self._serialize.query("max_avg_moisture", max_avg_moisture, 'float')
        if min_avg_speed is not None:
            query_parameters['minAvgSpeed'] = self._serialize.query("min_avg_speed", min_avg_speed, 'float')
        if max_avg_speed is not None:
            query_parameters['maxAvgSpeed'] = self._serialize.query("max_avg_speed", max_avg_speed, 'float')
        if sources is not None:
            query_parameters['sources'] = [self._serialize.query("sources", q, 'str') if q is not None else '' for q in sources]
        if associated_boundary_ids is not None:
            query_parameters['associatedBoundaryIds'] = [self._serialize.query("associated_boundary_ids", q, 'str') if q is not None else '' for q in associated_boundary_ids]
        if operation_boundary_ids is not None:
            query_parameters['operationBoundaryIds'] = [self._serialize.query("operation_boundary_ids", q, 'str') if q is not None else '' for q in operation_boundary_ids]
        if min_operation_start_date_time is not None:
            query_parameters['minOperationStartDateTime'] = self._serialize.query("min_operation_start_date_time", min_operation_start_date_time, 'iso-8601')
        if max_operation_start_date_time is not None:
            query_parameters['maxOperationStartDateTime'] = self._serialize.query("max_operation_start_date_time", max_operation_start_date_time, 'iso-8601')
        if min_operation_end_date_time is not None:
            query_parameters['minOperationEndDateTime'] = self._serialize.query("min_operation_end_date_time", min_operation_end_date_time, 'iso-8601')
        if max_operation_end_date_time is not None:
            query_parameters['maxOperationEndDateTime'] = self._serialize.query("max_operation_end_date_time", max_operation_end_date_time, 'iso-8601')
        if min_operation_modified_date_time is not None:
            query_parameters['minOperationModifiedDateTime'] = self._serialize.query("min_operation_modified_date_time", min_operation_modified_date_time, 'iso-8601')
        if max_operation_modified_date_time is not None:
            query_parameters['maxOperationModifiedDateTime'] = self._serialize.query("max_operation_modified_date_time", max_operation_modified_date_time, 'iso-8601')
        if min_area is not None:
            query_parameters['minArea'] = self._serialize.query("min_area", min_area, 'float')
        if max_area is not None:
            query_parameters['maxArea'] = self._serialize.query("max_area", max_area, 'float')
        if ids is not None:
            query_parameters['ids'] = [self._serialize.query("ids", q, 'str') if q is not None else '' for q in ids]
        if names is not None:
            query_parameters['names'] = [self._serialize.query("names", q, 'str') if q is not None else '' for q in names]
        if property_filters is not None:
            query_parameters['propertyFilters'] = [self._serialize.query("property_filters", q, 'str') if q is not None else '' for q in property_filters]
        if statuses is not None:
            query_parameters['statuses'] = [self._serialize.query("statuses", q, 'str') if q is not None else '' for q in statuses]
        if min_created_date_time is not None:
            query_parameters['minCreatedDateTime'] = self._serialize.query("min_created_date_time", min_created_date_time, 'iso-8601')
        if max_created_date_time is not None:
            query_parameters['maxCreatedDateTime'] = self._serialize.query("max_created_date_time", max_created_date_time, 'iso-8601')
        if min_last_modified_date_time is not None:
            query_parameters['minLastModifiedDateTime'] = self._serialize.query("min_last_modified_date_time", min_last_modified_date_time, 'iso-8601')
        if max_last_modified_date_time is not None:
            query_parameters['maxLastModifiedDateTime'] = self._serialize.query("max_last_modified_date_time", max_last_modified_date_time, 'iso-8601')
        if max_page_size is not None:
            query_parameters['$maxPageSize'] = self._serialize.query("max_page_size", max_page_size, 'int', maximum=1000, minimum=10)
        if skip_token is not None:
            query_parameters['$skipToken'] = self._serialize.query("skip_token", skip_token, 'str')
        query_parameters['api-version'] = self._serialize.query("api_version", api_version, 'str')

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]
        header_parameters['Accept'] = self._serialize.header("accept", accept, 'str')

        request = self._client.get(url, query_parameters, header_parameters)
        pipeline_response = await self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        deserialized = self._deserialize('HarvestDataListResponse', pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized
    get_all_harvest_data_across_farmers.metadata = {'url': '/harvestData'}  # type: ignore

    async def create_satellite_job(
        self,
        body: Optional["_models.SatelliteIngestionJobRequest"] = None,
        **kwargs
    ) -> "_models.SatelliteIngestionJobResponse":
        """Create a satellite job, controller.

        :param body: Job parameters supplied by user.
        :type body: ~dpsclient.models.SatelliteIngestionJobRequest
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: SatelliteIngestionJobResponse, or the result of cls(response)
        :rtype: ~dpsclient.models.SatelliteIngestionJobResponse
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType["_models.SatelliteIngestionJobResponse"]
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}))
        api_version = "2020-12-31-preview"
        content_type = kwargs.pop("content_type", "application/json")
        accept = "application/json"

        # Construct URL
        url = self.create_satellite_job.metadata['url']  # type: ignore

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]
        query_parameters['api-version'] = self._serialize.query("api_version", api_version, 'str')

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]
        header_parameters['Content-Type'] = self._serialize.header("content_type", content_type, 'str')
        header_parameters['Accept'] = self._serialize.header("accept", accept, 'str')

        body_content_kwargs = {}  # type: Dict[str, Any]
        if body is not None:
            body_content = self._serialize.body(body, 'SatelliteIngestionJobRequest')
        else:
            body_content = None
        body_content_kwargs['content'] = body_content
        request = self._client.post(url, query_parameters, header_parameters, **body_content_kwargs)
        pipeline_response = await self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [202]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        deserialized = self._deserialize('SatelliteIngestionJobResponse', pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized
    create_satellite_job.metadata = {'url': '/jobs/satelliteData'}  # type: ignore

    async def create_weather_job(
        self,
        x_ms_farm_beats_data_provider_id: Optional[str] = None,
        x_ms_farm_beats_data_provider_key: Optional[str] = None,
        body: Optional["_models.WeatherIngestionJobRequest"] = None,
        **kwargs
    ) -> "_models.WeatherIngestionJobResponse":
        """Create a weather job.

        :param x_ms_farm_beats_data_provider_id: Weather data provider app id.
        :type x_ms_farm_beats_data_provider_id: str
        :param x_ms_farm_beats_data_provider_key: Weather data provider api key.
        :type x_ms_farm_beats_data_provider_key: str
        :param body: Job parameters supplied by user.
        :type body: ~dpsclient.models.WeatherIngestionJobRequest
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: WeatherIngestionJobResponse, or the result of cls(response)
        :rtype: ~dpsclient.models.WeatherIngestionJobResponse
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType["_models.WeatherIngestionJobResponse"]
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}))
        api_version = "2020-12-31-preview"
        content_type = kwargs.pop("content_type", "application/json")
        accept = "application/json"

        # Construct URL
        url = self.create_weather_job.metadata['url']  # type: ignore

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]
        query_parameters['api-version'] = self._serialize.query("api_version", api_version, 'str')

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]
        if x_ms_farm_beats_data_provider_id is not None:
            header_parameters['x-ms-farmBeats-data-provider-id'] = self._serialize.header("x_ms_farm_beats_data_provider_id", x_ms_farm_beats_data_provider_id, 'str', max_length=200, min_length=2)
        if x_ms_farm_beats_data_provider_key is not None:
            header_parameters['x-ms-farmBeats-data-provider-key'] = self._serialize.header("x_ms_farm_beats_data_provider_key", x_ms_farm_beats_data_provider_key, 'str', max_length=200, min_length=2)
        header_parameters['Content-Type'] = self._serialize.header("content_type", content_type, 'str')
        header_parameters['Accept'] = self._serialize.header("accept", accept, 'str')

        body_content_kwargs = {}  # type: Dict[str, Any]
        if body is not None:
            body_content = self._serialize.body(body, 'WeatherIngestionJobRequest')
        else:
            body_content = None
        body_content_kwargs['content'] = body_content
        request = self._client.post(url, query_parameters, header_parameters, **body_content_kwargs)
        pipeline_response = await self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [202]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        deserialized = self._deserialize('WeatherIngestionJobResponse', pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized
    create_weather_job.metadata = {'url': '/jobs/weatherData'}  # type: ignore

    async def create_cascade_delete_job(
        self,
        body: Optional["_models.CascadeDeleteJobRequest"] = None,
        **kwargs
    ) -> "_models.CascadeDeleteJobResponse":
        """Create a cascade delete job.

        :param body: Job parameters supplied by user.
        :type body: ~dpsclient.models.CascadeDeleteJobRequest
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: CascadeDeleteJobResponse, or the result of cls(response)
        :rtype: ~dpsclient.models.CascadeDeleteJobResponse
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType["_models.CascadeDeleteJobResponse"]
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}))
        api_version = "2020-12-31-preview"
        content_type = kwargs.pop("content_type", "application/json")
        accept = "application/json"

        # Construct URL
        url = self.create_cascade_delete_job.metadata['url']  # type: ignore

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]
        query_parameters['api-version'] = self._serialize.query("api_version", api_version, 'str')

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]
        header_parameters['Content-Type'] = self._serialize.header("content_type", content_type, 'str')
        header_parameters['Accept'] = self._serialize.header("accept", accept, 'str')

        body_content_kwargs = {}  # type: Dict[str, Any]
        if body is not None:
            body_content = self._serialize.body(body, 'CascadeDeleteJobRequest')
        else:
            body_content = None
        body_content_kwargs['content'] = body_content
        request = self._client.post(url, query_parameters, header_parameters, **body_content_kwargs)
        pipeline_response = await self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        deserialized = self._deserialize('CascadeDeleteJobResponse', pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized
    create_cascade_delete_job.metadata = {'url': '/jobs/cascadeDelete'}  # type: ignore

    async def create_cascade_status_update_job(
        self,
        body: Optional["_models.CascadeStatusUpdateJobRequest"] = None,
        **kwargs
    ) -> "_models.CascadeStatusUpdateJobResponse":
        """Create a cascade update status job.

        :param body: Job parameters supplied by user.
        :type body: ~dpsclient.models.CascadeStatusUpdateJobRequest
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: CascadeStatusUpdateJobResponse, or the result of cls(response)
        :rtype: ~dpsclient.models.CascadeStatusUpdateJobResponse
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType["_models.CascadeStatusUpdateJobResponse"]
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}))
        api_version = "2020-12-31-preview"
        content_type = kwargs.pop("content_type", "application/json")
        accept = "application/json"

        # Construct URL
        url = self.create_cascade_status_update_job.metadata['url']  # type: ignore

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]
        query_parameters['api-version'] = self._serialize.query("api_version", api_version, 'str')

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]
        header_parameters['Content-Type'] = self._serialize.header("content_type", content_type, 'str')
        header_parameters['Accept'] = self._serialize.header("accept", accept, 'str')

        body_content_kwargs = {}  # type: Dict[str, Any]
        if body is not None:
            body_content = self._serialize.body(body, 'CascadeStatusUpdateJobRequest')
        else:
            body_content = None
        body_content_kwargs['content'] = body_content
        request = self._client.post(url, query_parameters, header_parameters, **body_content_kwargs)
        pipeline_response = await self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        deserialized = self._deserialize('CascadeStatusUpdateJobResponse', pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized
    create_cascade_status_update_job.metadata = {'url': '/jobs/cascadeUpdateStatus'}  # type: ignore

    async def create_farm_operation_data_ingestion_job(
        self,
        body: Optional["_models.FarmOperationDataIngestionJobRequest"] = None,
        **kwargs
    ) -> "_models.FarmOperationDataIngestionJobResponse":
        """Create a farm operation data ingestion job.

        :param body: Job parameters supplied by user.
        :type body: ~dpsclient.models.FarmOperationDataIngestionJobRequest
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: FarmOperationDataIngestionJobResponse, or the result of cls(response)
        :rtype: ~dpsclient.models.FarmOperationDataIngestionJobResponse
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType["_models.FarmOperationDataIngestionJobResponse"]
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}))
        api_version = "2020-12-31-preview"
        content_type = kwargs.pop("content_type", "application/json")
        accept = "application/json"

        # Construct URL
        url = self.create_farm_operation_data_ingestion_job.metadata['url']  # type: ignore

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]
        query_parameters['api-version'] = self._serialize.query("api_version", api_version, 'str')

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]
        header_parameters['Content-Type'] = self._serialize.header("content_type", content_type, 'str')
        header_parameters['Accept'] = self._serialize.header("accept", accept, 'str')

        body_content_kwargs = {}  # type: Dict[str, Any]
        if body is not None:
            body_content = self._serialize.body(body, 'FarmOperationDataIngestionJobRequest')
        else:
            body_content = None
        body_content_kwargs['content'] = body_content
        request = self._client.post(url, query_parameters, header_parameters, **body_content_kwargs)
        pipeline_response = await self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [202]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        deserialized = self._deserialize('FarmOperationDataIngestionJobResponse', pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized
    create_farm_operation_data_ingestion_job.metadata = {'url': '/jobs/farmOperationData'}  # type: ignore

    async def create_weather_data_delete_job(
        self,
        body: Optional["_models.WeatherDataDeleteJobRequest"] = None,
        **kwargs
    ) -> "_models.WeatherDataDeleteJobResponse":
        """Create a weather data delete job.

        :param body: Job parameters supplied by user.
        :type body: ~dpsclient.models.WeatherDataDeleteJobRequest
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: WeatherDataDeleteJobResponse, or the result of cls(response)
        :rtype: ~dpsclient.models.WeatherDataDeleteJobResponse
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType["_models.WeatherDataDeleteJobResponse"]
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}))
        api_version = "2020-12-31-preview"
        content_type = kwargs.pop("content_type", "application/json")
        accept = "application/json"

        # Construct URL
        url = self.create_weather_data_delete_job.metadata['url']  # type: ignore

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]
        query_parameters['api-version'] = self._serialize.query("api_version", api_version, 'str')

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]
        header_parameters['Content-Type'] = self._serialize.header("content_type", content_type, 'str')
        header_parameters['Accept'] = self._serialize.header("accept", accept, 'str')

        body_content_kwargs = {}  # type: Dict[str, Any]
        if body is not None:
            body_content = self._serialize.body(body, 'WeatherDataDeleteJobRequest')
        else:
            body_content = None
        body_content_kwargs['content'] = body_content
        request = self._client.post(url, query_parameters, header_parameters, **body_content_kwargs)
        pipeline_response = await self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [202]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        deserialized = self._deserialize('WeatherDataDeleteJobResponse', pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized
    create_weather_data_delete_job.metadata = {'url': '/jobs/weatherDataDelete'}  # type: ignore

    async def get_job(
        self,
        job_id: str,
        **kwargs
    ) -> "_models.JobResponse":
        """Get a job's details.

        :param job_id: Id of the job.
        :type job_id: str
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: JobResponse, or the result of cls(response)
        :rtype: ~dpsclient.models.JobResponse
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType["_models.JobResponse"]
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}))
        api_version = "2020-12-31-preview"
        accept = "application/json"

        # Construct URL
        url = self.get_job.metadata['url']  # type: ignore
        path_format_arguments = {
            'jobId': self._serialize.url("job_id", job_id, 'str'),
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]
        query_parameters['api-version'] = self._serialize.query("api_version", api_version, 'str')

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]
        header_parameters['Accept'] = self._serialize.header("accept", accept, 'str')

        request = self._client.get(url, query_parameters, header_parameters)
        pipeline_response = await self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        deserialized = self._deserialize('JobResponse', pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized
    get_job.metadata = {'url': '/jobs/{jobId}'}  # type: ignore

    async def cancel_job(
        self,
        job_id: str,
        **kwargs
    ) -> "_models.JobResponse":
        """Cancel a job.

        :param job_id: Id of the job.
        :type job_id: str
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: JobResponse, or the result of cls(response)
        :rtype: ~dpsclient.models.JobResponse
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType["_models.JobResponse"]
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}))
        api_version = "2020-12-31-preview"
        accept = "application/json"

        # Construct URL
        url = self.cancel_job.metadata['url']  # type: ignore
        path_format_arguments = {
            'jobId': self._serialize.url("job_id", job_id, 'str'),
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]
        query_parameters['api-version'] = self._serialize.query("api_version", api_version, 'str')

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]
        header_parameters['Accept'] = self._serialize.header("accept", accept, 'str')

        request = self._client.post(url, query_parameters, header_parameters)
        pipeline_response = await self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        deserialized = self._deserialize('JobResponse', pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized
    cancel_job.metadata = {'url': '/jobs/{jobId}/cancel'}  # type: ignore

    async def o_auth_callback(
        self,
        code: str,
        state: str,
        **kwargs
    ) -> None:
        """Handles oauth callback and redirects to user redirect link provided.

        :param code: Authorization code used to fetch tokens.
        :type code: str
        :param state: State used to validate the request.
        :type state: str
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: None, or the result of cls(response)
        :rtype: None
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType[None]
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}))

        # Construct URL
        url = self.o_auth_callback.metadata['url']  # type: ignore

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]
        query_parameters['code'] = self._serialize.query("code", code, 'str', max_length=200, min_length=0)
        query_parameters['state'] = self._serialize.query("state", state, 'str', max_length=200, min_length=0)

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]

        request = self._client.get(url, query_parameters, header_parameters)
        pipeline_response = await self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [302]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if cls:
            return cls(pipeline_response, None, {})

    o_auth_callback.metadata = {'url': '/oauth/callback'}  # type: ignore

    async def get_o_auth_transient_config(
        self,
        body: Optional["_models.OAuthConfigQuery"] = None,
        **kwargs
    ) -> "_models.OAuthConfig":
        """Returns configuration needed in the OAuth flow.

        :param body: OAuth config query object.
        :type body: ~dpsclient.models.OAuthConfigQuery
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: OAuthConfig, or the result of cls(response)
        :rtype: ~dpsclient.models.OAuthConfig
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType["_models.OAuthConfig"]
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}))
        api_version = "2020-12-31-preview"
        content_type = kwargs.pop("content_type", "application/json")
        accept = "application/json"

        # Construct URL
        url = self.get_o_auth_transient_config.metadata['url']  # type: ignore

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]
        query_parameters['api-version'] = self._serialize.query("api_version", api_version, 'str')

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]
        header_parameters['Content-Type'] = self._serialize.header("content_type", content_type, 'str')
        header_parameters['Accept'] = self._serialize.header("accept", accept, 'str')

        body_content_kwargs = {}  # type: Dict[str, Any]
        if body is not None:
            body_content = self._serialize.body(body, 'OAuthConfigQuery')
        else:
            body_content = None
        body_content_kwargs['content'] = body_content
        request = self._client.post(url, query_parameters, header_parameters, **body_content_kwargs)
        pipeline_response = await self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        deserialized = self._deserialize('OAuthConfig', pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized
    get_o_auth_transient_config.metadata = {'url': '/oauth/config'}  # type: ignore

    async def create_o_auth_provider(
        self,
        oauth_provider_id: str,
        x_ms_farm_beats_oauth_provider_app_secret: str,
        body: Optional["_models.OAuthProvider"] = None,
        **kwargs
    ) -> "_models.OAuthProvider":
        """Creates new oauthProvider object with given request body.

        :param oauth_provider_id: OAuthProvider id.
        :type oauth_provider_id: str
        :param x_ms_farm_beats_oauth_provider_app_secret: Provider app's app secret.
        :type x_ms_farm_beats_oauth_provider_app_secret: str
        :param body: OAuthProvider object.
        :type body: ~dpsclient.models.OAuthProvider
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: OAuthProvider, or the result of cls(response)
        :rtype: ~dpsclient.models.OAuthProvider
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType["_models.OAuthProvider"]
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}))
        api_version = "2020-12-31-preview"
        content_type = kwargs.pop("content_type", "application/json")
        accept = "application/json"

        # Construct URL
        url = self.create_o_auth_provider.metadata['url']  # type: ignore
        path_format_arguments = {
            'oauthProviderId': self._serialize.url("oauth_provider_id", oauth_provider_id, 'str'),
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]
        query_parameters['api-version'] = self._serialize.query("api_version", api_version, 'str')

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]
        header_parameters['x-ms-farmBeats-oauth-provider-app-secret'] = self._serialize.header("x_ms_farm_beats_oauth_provider_app_secret", x_ms_farm_beats_oauth_provider_app_secret, 'str', max_length=200, min_length=2)
        header_parameters['Content-Type'] = self._serialize.header("content_type", content_type, 'str')
        header_parameters['Accept'] = self._serialize.header("accept", accept, 'str')

        body_content_kwargs = {}  # type: Dict[str, Any]
        if body is not None:
            body_content = self._serialize.body(body, 'OAuthProvider')
        else:
            body_content = None
        body_content_kwargs['content'] = body_content
        request = self._client.put(url, query_parameters, header_parameters, **body_content_kwargs)
        pipeline_response = await self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [201]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        deserialized = self._deserialize('OAuthProvider', pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized
    create_o_auth_provider.metadata = {'url': '/oauth/providers/{oauthProviderId}'}  # type: ignore

    async def get_o_auth_provider(
        self,
        oauth_provider_id: str,
        **kwargs
    ) -> "_models.OAuthProvider":
        """Get oauthProvider object with given oauthProvider id.

        :param oauth_provider_id: OAuthProvider Id.
        :type oauth_provider_id: str
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: OAuthProvider, or the result of cls(response)
        :rtype: ~dpsclient.models.OAuthProvider
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType["_models.OAuthProvider"]
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}))
        api_version = "2020-12-31-preview"
        accept = "application/json"

        # Construct URL
        url = self.get_o_auth_provider.metadata['url']  # type: ignore
        path_format_arguments = {
            'oauthProviderId': self._serialize.url("oauth_provider_id", oauth_provider_id, 'str'),
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]
        query_parameters['api-version'] = self._serialize.query("api_version", api_version, 'str')

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]
        header_parameters['Accept'] = self._serialize.header("accept", accept, 'str')

        request = self._client.get(url, query_parameters, header_parameters)
        pipeline_response = await self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        deserialized = self._deserialize('OAuthProvider', pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized
    get_o_auth_provider.metadata = {'url': '/oauth/providers/{oauthProviderId}'}  # type: ignore

    async def update_o_auth_provider(
        self,
        oauth_provider_id: str,
        x_ms_farm_beats_oauth_provider_app_secret: Optional[str] = None,
        body: Optional["_models.OAuthProvider"] = None,
        **kwargs
    ) -> "_models.OAuthProvider":
        """Updates OAuthProvider for given oauthProvider Id.

        :param oauth_provider_id: Id of oauthProvider that need to be updated (system-generated).
        :type oauth_provider_id: str
        :param x_ms_farm_beats_oauth_provider_app_secret: Provider app's app secret.
        :type x_ms_farm_beats_oauth_provider_app_secret: str
        :param body: New state of oauthProvider.
        :type body: ~dpsclient.models.OAuthProvider
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: OAuthProvider, or the result of cls(response)
        :rtype: ~dpsclient.models.OAuthProvider
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType["_models.OAuthProvider"]
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}))
        api_version = "2020-12-31-preview"
        content_type = kwargs.pop("content_type", "application/json")
        accept = "application/json"

        # Construct URL
        url = self.update_o_auth_provider.metadata['url']  # type: ignore
        path_format_arguments = {
            'oauthProviderId': self._serialize.url("oauth_provider_id", oauth_provider_id, 'str'),
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]
        query_parameters['api-version'] = self._serialize.query("api_version", api_version, 'str')

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]
        if x_ms_farm_beats_oauth_provider_app_secret is not None:
            header_parameters['x-ms-farmBeats-oauth-provider-app-secret'] = self._serialize.header("x_ms_farm_beats_oauth_provider_app_secret", x_ms_farm_beats_oauth_provider_app_secret, 'str', max_length=200, min_length=2)
        header_parameters['Content-Type'] = self._serialize.header("content_type", content_type, 'str')
        header_parameters['Accept'] = self._serialize.header("accept", accept, 'str')

        body_content_kwargs = {}  # type: Dict[str, Any]
        if body is not None:
            body_content = self._serialize.body(body, 'OAuthProvider')
        else:
            body_content = None
        body_content_kwargs['content'] = body_content
        request = self._client.patch(url, query_parameters, header_parameters, **body_content_kwargs)
        pipeline_response = await self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        deserialized = self._deserialize('OAuthProvider', pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized
    update_o_auth_provider.metadata = {'url': '/oauth/providers/{oauthProviderId}'}  # type: ignore

    async def delete_o_auth_provider(
        self,
        oauth_provider_id: str,
        **kwargs
    ) -> None:
        """Deletes OAuthProvider for given oauthProvider id.

        :param oauth_provider_id: Id of oauthProvider to be deleted.
        :type oauth_provider_id: str
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: None, or the result of cls(response)
        :rtype: None
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType[None]
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}))
        api_version = "2020-12-31-preview"

        # Construct URL
        url = self.delete_o_auth_provider.metadata['url']  # type: ignore
        path_format_arguments = {
            'oauthProviderId': self._serialize.url("oauth_provider_id", oauth_provider_id, 'str'),
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]
        query_parameters['api-version'] = self._serialize.query("api_version", api_version, 'str')

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]

        request = self._client.delete(url, query_parameters, header_parameters)
        pipeline_response = await self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if cls:
            return cls(pipeline_response, None, {})

    delete_o_auth_provider.metadata = {'url': '/oauth/providers/{oauthProviderId}'}  # type: ignore

    async def get_o_auth_providers(
        self,
        ids: Optional[List[str]] = None,
        names: Optional[List[str]] = None,
        property_filters: Optional[List[str]] = None,
        statuses: Optional[List[str]] = None,
        min_created_date_time: Optional[datetime.datetime] = None,
        max_created_date_time: Optional[datetime.datetime] = None,
        min_last_modified_date_time: Optional[datetime.datetime] = None,
        max_last_modified_date_time: Optional[datetime.datetime] = None,
        max_page_size: Optional[int] = 50,
        skip_token: Optional[str] = None,
        **kwargs
    ) -> "_models.OAuthProviderListResponse":
        """Returns a list of oauthProvider.

        :param ids: Ids of the resource.
        :type ids: list[str]
        :param names: Names of the resource.
        :type names: list[str]
        :param property_filters: Filters on key-value pairs within the Properties object.
         eg. "{testkey} eq {testvalue}".
        :type property_filters: list[str]
        :param statuses: Statuses of the resource.
        :type statuses: list[str]
        :param min_created_date_time: Minimum creation date of resource (inclusive).
        :type min_created_date_time: ~datetime.datetime
        :param max_created_date_time: Maximum creation date of resource (inclusive).
        :type max_created_date_time: ~datetime.datetime
        :param min_last_modified_date_time: Minimum last modified date of resource (inclusive).
        :type min_last_modified_date_time: ~datetime.datetime
        :param max_last_modified_date_time: Maximum last modified date of resource (inclusive).
        :type max_last_modified_date_time: ~datetime.datetime
        :param max_page_size: Maximum number of items needed (inclusive).
         Minimum = 10, Maximum = 1000, Default value = 50.
        :type max_page_size: int
        :param skip_token: Skip token for getting next set of results.
        :type skip_token: str
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: OAuthProviderListResponse, or the result of cls(response)
        :rtype: ~dpsclient.models.OAuthProviderListResponse
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType["_models.OAuthProviderListResponse"]
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}))
        api_version = "2020-12-31-preview"
        accept = "application/json"

        # Construct URL
        url = self.get_o_auth_providers.metadata['url']  # type: ignore

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]
        if ids is not None:
            query_parameters['ids'] = [self._serialize.query("ids", q, 'str') if q is not None else '' for q in ids]
        if names is not None:
            query_parameters['names'] = [self._serialize.query("names", q, 'str') if q is not None else '' for q in names]
        if property_filters is not None:
            query_parameters['propertyFilters'] = [self._serialize.query("property_filters", q, 'str') if q is not None else '' for q in property_filters]
        if statuses is not None:
            query_parameters['statuses'] = [self._serialize.query("statuses", q, 'str') if q is not None else '' for q in statuses]
        if min_created_date_time is not None:
            query_parameters['minCreatedDateTime'] = self._serialize.query("min_created_date_time", min_created_date_time, 'iso-8601')
        if max_created_date_time is not None:
            query_parameters['maxCreatedDateTime'] = self._serialize.query("max_created_date_time", max_created_date_time, 'iso-8601')
        if min_last_modified_date_time is not None:
            query_parameters['minLastModifiedDateTime'] = self._serialize.query("min_last_modified_date_time", min_last_modified_date_time, 'iso-8601')
        if max_last_modified_date_time is not None:
            query_parameters['maxLastModifiedDateTime'] = self._serialize.query("max_last_modified_date_time", max_last_modified_date_time, 'iso-8601')
        if max_page_size is not None:
            query_parameters['$maxPageSize'] = self._serialize.query("max_page_size", max_page_size, 'int', maximum=1000, minimum=10)
        if skip_token is not None:
            query_parameters['$skipToken'] = self._serialize.query("skip_token", skip_token, 'str')
        query_parameters['api-version'] = self._serialize.query("api_version", api_version, 'str')

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]
        header_parameters['Accept'] = self._serialize.header("accept", accept, 'str')

        request = self._client.get(url, query_parameters, header_parameters)
        pipeline_response = await self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        deserialized = self._deserialize('OAuthProviderListResponse', pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized
    get_o_auth_providers.metadata = {'url': '/oauth/providers'}  # type: ignore

    async def get_all_o_auth_token_info(
        self,
        farmer_id: str,
        auth_provider_ids: Optional[List[str]] = None,
        is_valid: Optional[bool] = None,
        ids: Optional[List[str]] = None,
        names: Optional[List[str]] = None,
        property_filters: Optional[List[str]] = None,
        statuses: Optional[List[str]] = None,
        min_created_date_time: Optional[datetime.datetime] = None,
        max_created_date_time: Optional[datetime.datetime] = None,
        min_last_modified_date_time: Optional[datetime.datetime] = None,
        max_last_modified_date_time: Optional[datetime.datetime] = None,
        max_page_size: Optional[int] = 50,
        skip_token: Optional[str] = None,
        **kwargs
    ) -> "_models.OAuthTokenInfoListResponse":
        """Returns a list of OAuthTokenInfo documents.

        :param farmer_id: Id of the associated farmer.
        :type farmer_id: str
        :param auth_provider_ids: Name of AuthProvider.
        :type auth_provider_ids: list[str]
        :param is_valid: If the token object is valid.
        :type is_valid: bool
        :param ids: Ids of the resource.
        :type ids: list[str]
        :param names: Names of the resource.
        :type names: list[str]
        :param property_filters: Filters on key-value pairs within the Properties object.
         eg. "{testkey} eq {testvalue}".
        :type property_filters: list[str]
        :param statuses: Statuses of the resource.
        :type statuses: list[str]
        :param min_created_date_time: Minimum creation date of resource (inclusive).
        :type min_created_date_time: ~datetime.datetime
        :param max_created_date_time: Maximum creation date of resource (inclusive).
        :type max_created_date_time: ~datetime.datetime
        :param min_last_modified_date_time: Minimum last modified date of resource (inclusive).
        :type min_last_modified_date_time: ~datetime.datetime
        :param max_last_modified_date_time: Maximum last modified date of resource (inclusive).
        :type max_last_modified_date_time: ~datetime.datetime
        :param max_page_size: Maximum number of items needed (inclusive).
         Minimum = 10, Maximum = 1000, Default value = 50.
        :type max_page_size: int
        :param skip_token: Skip token for getting next set of results.
        :type skip_token: str
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: OAuthTokenInfoListResponse, or the result of cls(response)
        :rtype: ~dpsclient.models.OAuthTokenInfoListResponse
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType["_models.OAuthTokenInfoListResponse"]
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}))
        api_version = "2020-12-31-preview"
        accept = "application/json"

        # Construct URL
        url = self.get_all_o_auth_token_info.metadata['url']  # type: ignore

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]
        query_parameters['farmerId'] = self._serialize.query("farmer_id", farmer_id, 'str')
        if auth_provider_ids is not None:
            query_parameters['authProviderIds'] = [self._serialize.query("auth_provider_ids", q, 'str') if q is not None else '' for q in auth_provider_ids]
        if is_valid is not None:
            query_parameters['isValid'] = self._serialize.query("is_valid", is_valid, 'bool')
        if ids is not None:
            query_parameters['ids'] = [self._serialize.query("ids", q, 'str') if q is not None else '' for q in ids]
        if names is not None:
            query_parameters['names'] = [self._serialize.query("names", q, 'str') if q is not None else '' for q in names]
        if property_filters is not None:
            query_parameters['propertyFilters'] = [self._serialize.query("property_filters", q, 'str') if q is not None else '' for q in property_filters]
        if statuses is not None:
            query_parameters['statuses'] = [self._serialize.query("statuses", q, 'str') if q is not None else '' for q in statuses]
        if min_created_date_time is not None:
            query_parameters['minCreatedDateTime'] = self._serialize.query("min_created_date_time", min_created_date_time, 'iso-8601')
        if max_created_date_time is not None:
            query_parameters['maxCreatedDateTime'] = self._serialize.query("max_created_date_time", max_created_date_time, 'iso-8601')
        if min_last_modified_date_time is not None:
            query_parameters['minLastModifiedDateTime'] = self._serialize.query("min_last_modified_date_time", min_last_modified_date_time, 'iso-8601')
        if max_last_modified_date_time is not None:
            query_parameters['maxLastModifiedDateTime'] = self._serialize.query("max_last_modified_date_time", max_last_modified_date_time, 'iso-8601')
        if max_page_size is not None:
            query_parameters['$maxPageSize'] = self._serialize.query("max_page_size", max_page_size, 'int', maximum=1000, minimum=10)
        if skip_token is not None:
            query_parameters['$skipToken'] = self._serialize.query("skip_token", skip_token, 'str')
        query_parameters['api-version'] = self._serialize.query("api_version", api_version, 'str')

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]
        header_parameters['Accept'] = self._serialize.header("accept", accept, 'str')

        request = self._client.get(url, query_parameters, header_parameters)
        pipeline_response = await self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        deserialized = self._deserialize('OAuthTokenInfoListResponse', pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized
    get_all_o_auth_token_info.metadata = {'url': '/oauth/tokensinfo'}  # type: ignore

    async def delete_o_auth_token_info(
        self,
        farmer_id: str,
        oauth_provider_id: str,
        **kwargs
    ) -> None:
        """Deletes OAuth Token Info info for given oauth provider Id and farmer Id.

        :param farmer_id: Id of the associated farmer.
        :type farmer_id: str
        :param oauth_provider_id: Id of the associated oauth provider.
        :type oauth_provider_id: str
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: None, or the result of cls(response)
        :rtype: None
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType[None]
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}))
        api_version = "2020-12-31-preview"

        # Construct URL
        url = self.delete_o_auth_token_info.metadata['url']  # type: ignore

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]
        query_parameters['farmerId'] = self._serialize.query("farmer_id", farmer_id, 'str')
        query_parameters['oauthProviderId'] = self._serialize.query("oauth_provider_id", oauth_provider_id, 'str')
        query_parameters['api-version'] = self._serialize.query("api_version", api_version, 'str')

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]

        request = self._client.post(url, query_parameters, header_parameters)
        pipeline_response = await self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if cls:
            return cls(pipeline_response, None, {})

    delete_o_auth_token_info.metadata = {'url': '/oauth/tokensinfo/:remove'}  # type: ignore

    async def get_planting_data(
        self,
        planting_data_id: str,
        farmer_id: str,
        **kwargs
    ) -> "_models.PlantingData":
        """Get PlantingData object with given id and farmer id.

        :param planting_data_id: PlantingData id.
        :type planting_data_id: str
        :param farmer_id: Farmer id.
        :type farmer_id: str
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: PlantingData, or the result of cls(response)
        :rtype: ~dpsclient.models.PlantingData
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType["_models.PlantingData"]
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}))
        api_version = "2020-12-31-preview"
        accept = "application/json"

        # Construct URL
        url = self.get_planting_data.metadata['url']  # type: ignore
        path_format_arguments = {
            'plantingDataId': self._serialize.url("planting_data_id", planting_data_id, 'str'),
            'farmerId': self._serialize.url("farmer_id", farmer_id, 'str'),
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]
        query_parameters['api-version'] = self._serialize.query("api_version", api_version, 'str')

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]
        header_parameters['Accept'] = self._serialize.header("accept", accept, 'str')

        request = self._client.get(url, query_parameters, header_parameters)
        pipeline_response = await self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        deserialized = self._deserialize('PlantingData', pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized
    get_planting_data.metadata = {'url': '/farmers/{farmerId}/plantingData/{plantingDataId}'}  # type: ignore

    async def create_planting_data(
        self,
        farmer_id: str,
        planting_data_id: str,
        body: Optional["_models.PlantingData"] = None,
        **kwargs
    ) -> "_models.PlantingData":
        """Creates new PlantingData object with given request body.

        :param farmer_id: Id of the associated farmer.
        :type farmer_id: str
        :param planting_data_id: PlantingData id.
        :type planting_data_id: str
        :param body: PlantingData object.
        :type body: ~dpsclient.models.PlantingData
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: PlantingData, or the result of cls(response)
        :rtype: ~dpsclient.models.PlantingData
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType["_models.PlantingData"]
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}))
        api_version = "2020-12-31-preview"
        content_type = kwargs.pop("content_type", "application/json")
        accept = "application/json"

        # Construct URL
        url = self.create_planting_data.metadata['url']  # type: ignore
        path_format_arguments = {
            'farmerId': self._serialize.url("farmer_id", farmer_id, 'str'),
            'plantingDataId': self._serialize.url("planting_data_id", planting_data_id, 'str'),
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]
        query_parameters['api-version'] = self._serialize.query("api_version", api_version, 'str')

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]
        header_parameters['Content-Type'] = self._serialize.header("content_type", content_type, 'str')
        header_parameters['Accept'] = self._serialize.header("accept", accept, 'str')

        body_content_kwargs = {}  # type: Dict[str, Any]
        if body is not None:
            body_content = self._serialize.body(body, 'PlantingData')
        else:
            body_content = None
        body_content_kwargs['content'] = body_content
        request = self._client.put(url, query_parameters, header_parameters, **body_content_kwargs)
        pipeline_response = await self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [201]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        deserialized = self._deserialize('PlantingData', pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized
    create_planting_data.metadata = {'url': '/farmers/{farmerId}/plantingData/{plantingDataId}'}  # type: ignore

    async def update_planting_data(
        self,
        farmer_id: str,
        planting_data_id: str,
        body: Optional["_models.PlantingData"] = None,
        **kwargs
    ) -> "_models.PlantingData":
        """Updates PlantingData object with given request body.

        :param farmer_id: Id of the farmer.
        :type farmer_id: str
        :param planting_data_id: Id of the PlantingData.
        :type planting_data_id: str
        :param body: PlantingData object.
        :type body: ~dpsclient.models.PlantingData
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: PlantingData, or the result of cls(response)
        :rtype: ~dpsclient.models.PlantingData
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType["_models.PlantingData"]
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}))
        api_version = "2020-12-31-preview"
        content_type = kwargs.pop("content_type", "application/json")
        accept = "application/json"

        # Construct URL
        url = self.update_planting_data.metadata['url']  # type: ignore
        path_format_arguments = {
            'farmerId': self._serialize.url("farmer_id", farmer_id, 'str'),
            'plantingDataId': self._serialize.url("planting_data_id", planting_data_id, 'str'),
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]
        query_parameters['api-version'] = self._serialize.query("api_version", api_version, 'str')

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]
        header_parameters['Content-Type'] = self._serialize.header("content_type", content_type, 'str')
        header_parameters['Accept'] = self._serialize.header("accept", accept, 'str')

        body_content_kwargs = {}  # type: Dict[str, Any]
        if body is not None:
            body_content = self._serialize.body(body, 'PlantingData')
        else:
            body_content = None
        body_content_kwargs['content'] = body_content
        request = self._client.patch(url, query_parameters, header_parameters, **body_content_kwargs)
        pipeline_response = await self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        deserialized = self._deserialize('PlantingData', pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized
    update_planting_data.metadata = {'url': '/farmers/{farmerId}/plantingData/{plantingDataId}'}  # type: ignore

    async def delete_planting_data(
        self,
        farmer_id: str,
        planting_data_id: str,
        **kwargs
    ) -> None:
        """Deletes PlantingData object associated with given id.

        :param farmer_id: Id of the associated farmer.
        :type farmer_id: str
        :param planting_data_id: Id of the PlantingData.
        :type planting_data_id: str
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: None, or the result of cls(response)
        :rtype: None
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType[None]
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}))
        api_version = "2020-12-31-preview"

        # Construct URL
        url = self.delete_planting_data.metadata['url']  # type: ignore
        path_format_arguments = {
            'farmerId': self._serialize.url("farmer_id", farmer_id, 'str'),
            'plantingDataId': self._serialize.url("planting_data_id", planting_data_id, 'str'),
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]
        query_parameters['api-version'] = self._serialize.query("api_version", api_version, 'str')

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]

        request = self._client.delete(url, query_parameters, header_parameters)
        pipeline_response = await self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if cls:
            return cls(pipeline_response, None, {})

    delete_planting_data.metadata = {'url': '/farmers/{farmerId}/plantingData/{plantingDataId}'}  # type: ignore

    async def get_all_planting_data(
        self,
        farmer_id: str,
        min_avg_seeding_rate: Optional[float] = None,
        max_avg_seeding_rate: Optional[float] = None,
        min_total_material: Optional[float] = None,
        max_total_material: Optional[float] = None,
        min_avg_material: Optional[float] = None,
        max_avg_material: Optional[float] = None,
        sources: Optional[List[str]] = None,
        associated_boundary_ids: Optional[List[str]] = None,
        operation_boundary_ids: Optional[List[str]] = None,
        min_operation_start_date_time: Optional[datetime.datetime] = None,
        max_operation_start_date_time: Optional[datetime.datetime] = None,
        min_operation_end_date_time: Optional[datetime.datetime] = None,
        max_operation_end_date_time: Optional[datetime.datetime] = None,
        min_operation_modified_date_time: Optional[datetime.datetime] = None,
        max_operation_modified_date_time: Optional[datetime.datetime] = None,
        min_area: Optional[float] = None,
        max_area: Optional[float] = None,
        ids: Optional[List[str]] = None,
        names: Optional[List[str]] = None,
        property_filters: Optional[List[str]] = None,
        statuses: Optional[List[str]] = None,
        min_created_date_time: Optional[datetime.datetime] = None,
        max_created_date_time: Optional[datetime.datetime] = None,
        min_last_modified_date_time: Optional[datetime.datetime] = None,
        max_last_modified_date_time: Optional[datetime.datetime] = None,
        max_page_size: Optional[int] = 50,
        skip_token: Optional[str] = None,
        **kwargs
    ) -> "_models.PlantingDataListResponse":
        """Returns a list of PlantingData documents.

        :param farmer_id: Id of the associated farmer.
        :type farmer_id: str
        :param min_avg_seeding_rate: Minimum AvgSeedingRate value(inclusive).
        :type min_avg_seeding_rate: float
        :param max_avg_seeding_rate: Maximum AvgSeedingRate value (inclusive).
        :type max_avg_seeding_rate: float
        :param min_total_material: Minimum TotalMaterial value(inclusive).
        :type min_total_material: float
        :param max_total_material: Maximum TotalMaterial value (inclusive).
        :type max_total_material: float
        :param min_avg_material: Minimum AvgMaterial value(inclusive).
        :type min_avg_material: float
        :param max_avg_material: Maximum AvgMaterial value (inclusive).
        :type max_avg_material: float
        :param sources: Source of the operation data.
        :type sources: list[str]
        :param associated_boundary_ids: Boundary ids associated with operation data.
        :type associated_boundary_ids: list[str]
        :param operation_boundary_ids: Operation boundary ids associated with operation data.
        :type operation_boundary_ids: list[str]
        :param min_operation_start_date_time: Minimum operation StartDateTime (inclusive).
        :type min_operation_start_date_time: ~datetime.datetime
        :param max_operation_start_date_time: Maximum operation StartDateTime (inclusive).
        :type max_operation_start_date_time: ~datetime.datetime
        :param min_operation_end_date_time: Minimum operation EndDateTime (inclusive).
        :type min_operation_end_date_time: ~datetime.datetime
        :param max_operation_end_date_time: Maximum operation EndDateTime (inclusive).
        :type max_operation_end_date_time: ~datetime.datetime
        :param min_operation_modified_date_time: Minimum OperationModifiedDateTime (inclusive).
        :type min_operation_modified_date_time: ~datetime.datetime
        :param max_operation_modified_date_time: Maximum OperationModifiedDateTime (inclusive).
        :type max_operation_modified_date_time: ~datetime.datetime
        :param min_area: Minimum Area value(inclusive).
        :type min_area: float
        :param max_area: Maximum Area value (inclusive).
        :type max_area: float
        :param ids: Ids of the resource.
        :type ids: list[str]
        :param names: Names of the resource.
        :type names: list[str]
        :param property_filters: Filters on key-value pairs within the Properties object.
         eg. "{testkey} eq {testvalue}".
        :type property_filters: list[str]
        :param statuses: Statuses of the resource.
        :type statuses: list[str]
        :param min_created_date_time: Minimum creation date of resource (inclusive).
        :type min_created_date_time: ~datetime.datetime
        :param max_created_date_time: Maximum creation date of resource (inclusive).
        :type max_created_date_time: ~datetime.datetime
        :param min_last_modified_date_time: Minimum last modified date of resource (inclusive).
        :type min_last_modified_date_time: ~datetime.datetime
        :param max_last_modified_date_time: Maximum last modified date of resource (inclusive).
        :type max_last_modified_date_time: ~datetime.datetime
        :param max_page_size: Maximum number of items needed (inclusive).
         Minimum = 10, Maximum = 1000, Default value = 50.
        :type max_page_size: int
        :param skip_token: Skip token for getting next set of results.
        :type skip_token: str
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: PlantingDataListResponse, or the result of cls(response)
        :rtype: ~dpsclient.models.PlantingDataListResponse
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType["_models.PlantingDataListResponse"]
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}))
        api_version = "2020-12-31-preview"
        accept = "application/json"

        # Construct URL
        url = self.get_all_planting_data.metadata['url']  # type: ignore
        path_format_arguments = {
            'farmerId': self._serialize.url("farmer_id", farmer_id, 'str'),
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]
        if min_avg_seeding_rate is not None:
            query_parameters['minAvgSeedingRate'] = self._serialize.query("min_avg_seeding_rate", min_avg_seeding_rate, 'float')
        if max_avg_seeding_rate is not None:
            query_parameters['maxAvgSeedingRate'] = self._serialize.query("max_avg_seeding_rate", max_avg_seeding_rate, 'float')
        if min_total_material is not None:
            query_parameters['minTotalMaterial'] = self._serialize.query("min_total_material", min_total_material, 'float')
        if max_total_material is not None:
            query_parameters['maxTotalMaterial'] = self._serialize.query("max_total_material", max_total_material, 'float')
        if min_avg_material is not None:
            query_parameters['minAvgMaterial'] = self._serialize.query("min_avg_material", min_avg_material, 'float')
        if max_avg_material is not None:
            query_parameters['maxAvgMaterial'] = self._serialize.query("max_avg_material", max_avg_material, 'float')
        if sources is not None:
            query_parameters['sources'] = [self._serialize.query("sources", q, 'str') if q is not None else '' for q in sources]
        if associated_boundary_ids is not None:
            query_parameters['associatedBoundaryIds'] = [self._serialize.query("associated_boundary_ids", q, 'str') if q is not None else '' for q in associated_boundary_ids]
        if operation_boundary_ids is not None:
            query_parameters['operationBoundaryIds'] = [self._serialize.query("operation_boundary_ids", q, 'str') if q is not None else '' for q in operation_boundary_ids]
        if min_operation_start_date_time is not None:
            query_parameters['minOperationStartDateTime'] = self._serialize.query("min_operation_start_date_time", min_operation_start_date_time, 'iso-8601')
        if max_operation_start_date_time is not None:
            query_parameters['maxOperationStartDateTime'] = self._serialize.query("max_operation_start_date_time", max_operation_start_date_time, 'iso-8601')
        if min_operation_end_date_time is not None:
            query_parameters['minOperationEndDateTime'] = self._serialize.query("min_operation_end_date_time", min_operation_end_date_time, 'iso-8601')
        if max_operation_end_date_time is not None:
            query_parameters['maxOperationEndDateTime'] = self._serialize.query("max_operation_end_date_time", max_operation_end_date_time, 'iso-8601')
        if min_operation_modified_date_time is not None:
            query_parameters['minOperationModifiedDateTime'] = self._serialize.query("min_operation_modified_date_time", min_operation_modified_date_time, 'iso-8601')
        if max_operation_modified_date_time is not None:
            query_parameters['maxOperationModifiedDateTime'] = self._serialize.query("max_operation_modified_date_time", max_operation_modified_date_time, 'iso-8601')
        if min_area is not None:
            query_parameters['minArea'] = self._serialize.query("min_area", min_area, 'float')
        if max_area is not None:
            query_parameters['maxArea'] = self._serialize.query("max_area", max_area, 'float')
        if ids is not None:
            query_parameters['ids'] = [self._serialize.query("ids", q, 'str') if q is not None else '' for q in ids]
        if names is not None:
            query_parameters['names'] = [self._serialize.query("names", q, 'str') if q is not None else '' for q in names]
        if property_filters is not None:
            query_parameters['propertyFilters'] = [self._serialize.query("property_filters", q, 'str') if q is not None else '' for q in property_filters]
        if statuses is not None:
            query_parameters['statuses'] = [self._serialize.query("statuses", q, 'str') if q is not None else '' for q in statuses]
        if min_created_date_time is not None:
            query_parameters['minCreatedDateTime'] = self._serialize.query("min_created_date_time", min_created_date_time, 'iso-8601')
        if max_created_date_time is not None:
            query_parameters['maxCreatedDateTime'] = self._serialize.query("max_created_date_time", max_created_date_time, 'iso-8601')
        if min_last_modified_date_time is not None:
            query_parameters['minLastModifiedDateTime'] = self._serialize.query("min_last_modified_date_time", min_last_modified_date_time, 'iso-8601')
        if max_last_modified_date_time is not None:
            query_parameters['maxLastModifiedDateTime'] = self._serialize.query("max_last_modified_date_time", max_last_modified_date_time, 'iso-8601')
        if max_page_size is not None:
            query_parameters['$maxPageSize'] = self._serialize.query("max_page_size", max_page_size, 'int', maximum=1000, minimum=10)
        if skip_token is not None:
            query_parameters['$skipToken'] = self._serialize.query("skip_token", skip_token, 'str')
        query_parameters['api-version'] = self._serialize.query("api_version", api_version, 'str')

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]
        header_parameters['Accept'] = self._serialize.header("accept", accept, 'str')

        request = self._client.get(url, query_parameters, header_parameters)
        pipeline_response = await self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        deserialized = self._deserialize('PlantingDataListResponse', pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized
    get_all_planting_data.metadata = {'url': '/farmers/{farmerId}/plantingData'}  # type: ignore

    async def get_all_planting_data_across_farmers(
        self,
        min_avg_seeding_rate: Optional[float] = None,
        max_avg_seeding_rate: Optional[float] = None,
        min_total_material: Optional[float] = None,
        max_total_material: Optional[float] = None,
        min_avg_material: Optional[float] = None,
        max_avg_material: Optional[float] = None,
        sources: Optional[List[str]] = None,
        associated_boundary_ids: Optional[List[str]] = None,
        operation_boundary_ids: Optional[List[str]] = None,
        min_operation_start_date_time: Optional[datetime.datetime] = None,
        max_operation_start_date_time: Optional[datetime.datetime] = None,
        min_operation_end_date_time: Optional[datetime.datetime] = None,
        max_operation_end_date_time: Optional[datetime.datetime] = None,
        min_operation_modified_date_time: Optional[datetime.datetime] = None,
        max_operation_modified_date_time: Optional[datetime.datetime] = None,
        min_area: Optional[float] = None,
        max_area: Optional[float] = None,
        ids: Optional[List[str]] = None,
        names: Optional[List[str]] = None,
        property_filters: Optional[List[str]] = None,
        statuses: Optional[List[str]] = None,
        min_created_date_time: Optional[datetime.datetime] = None,
        max_created_date_time: Optional[datetime.datetime] = None,
        min_last_modified_date_time: Optional[datetime.datetime] = None,
        max_last_modified_date_time: Optional[datetime.datetime] = None,
        max_page_size: Optional[int] = 50,
        skip_token: Optional[str] = None,
        **kwargs
    ) -> "_models.PlantingDataListResponse":
        """Returns a list of PlantingData documents.

        :param min_avg_seeding_rate: Minimum AvgSeedingRate value(inclusive).
        :type min_avg_seeding_rate: float
        :param max_avg_seeding_rate: Maximum AvgSeedingRate value (inclusive).
        :type max_avg_seeding_rate: float
        :param min_total_material: Minimum TotalMaterial value(inclusive).
        :type min_total_material: float
        :param max_total_material: Maximum TotalMaterial value (inclusive).
        :type max_total_material: float
        :param min_avg_material: Minimum AvgMaterial value(inclusive).
        :type min_avg_material: float
        :param max_avg_material: Maximum AvgMaterial value (inclusive).
        :type max_avg_material: float
        :param sources: Source of the operation data.
        :type sources: list[str]
        :param associated_boundary_ids: Boundary ids associated with operation data.
        :type associated_boundary_ids: list[str]
        :param operation_boundary_ids: Operation boundary ids associated with operation data.
        :type operation_boundary_ids: list[str]
        :param min_operation_start_date_time: Minimum operation StartDateTime (inclusive).
        :type min_operation_start_date_time: ~datetime.datetime
        :param max_operation_start_date_time: Maximum operation StartDateTime (inclusive).
        :type max_operation_start_date_time: ~datetime.datetime
        :param min_operation_end_date_time: Minimum operation EndDateTime (inclusive).
        :type min_operation_end_date_time: ~datetime.datetime
        :param max_operation_end_date_time: Maximum operation EndDateTime (inclusive).
        :type max_operation_end_date_time: ~datetime.datetime
        :param min_operation_modified_date_time: Minimum OperationModifiedDateTime (inclusive).
        :type min_operation_modified_date_time: ~datetime.datetime
        :param max_operation_modified_date_time: Maximum OperationModifiedDateTime (inclusive).
        :type max_operation_modified_date_time: ~datetime.datetime
        :param min_area: Minimum Area value(inclusive).
        :type min_area: float
        :param max_area: Maximum Area value (inclusive).
        :type max_area: float
        :param ids: Ids of the resource.
        :type ids: list[str]
        :param names: Names of the resource.
        :type names: list[str]
        :param property_filters: Filters on key-value pairs within the Properties object.
         eg. "{testkey} eq {testvalue}".
        :type property_filters: list[str]
        :param statuses: Statuses of the resource.
        :type statuses: list[str]
        :param min_created_date_time: Minimum creation date of resource (inclusive).
        :type min_created_date_time: ~datetime.datetime
        :param max_created_date_time: Maximum creation date of resource (inclusive).
        :type max_created_date_time: ~datetime.datetime
        :param min_last_modified_date_time: Minimum last modified date of resource (inclusive).
        :type min_last_modified_date_time: ~datetime.datetime
        :param max_last_modified_date_time: Maximum last modified date of resource (inclusive).
        :type max_last_modified_date_time: ~datetime.datetime
        :param max_page_size: Maximum number of items needed (inclusive).
         Minimum = 10, Maximum = 1000, Default value = 50.
        :type max_page_size: int
        :param skip_token: Skip token for getting next set of results.
        :type skip_token: str
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: PlantingDataListResponse, or the result of cls(response)
        :rtype: ~dpsclient.models.PlantingDataListResponse
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType["_models.PlantingDataListResponse"]
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}))
        api_version = "2020-12-31-preview"
        accept = "application/json"

        # Construct URL
        url = self.get_all_planting_data_across_farmers.metadata['url']  # type: ignore

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]
        if min_avg_seeding_rate is not None:
            query_parameters['minAvgSeedingRate'] = self._serialize.query("min_avg_seeding_rate", min_avg_seeding_rate, 'float')
        if max_avg_seeding_rate is not None:
            query_parameters['maxAvgSeedingRate'] = self._serialize.query("max_avg_seeding_rate", max_avg_seeding_rate, 'float')
        if min_total_material is not None:
            query_parameters['minTotalMaterial'] = self._serialize.query("min_total_material", min_total_material, 'float')
        if max_total_material is not None:
            query_parameters['maxTotalMaterial'] = self._serialize.query("max_total_material", max_total_material, 'float')
        if min_avg_material is not None:
            query_parameters['minAvgMaterial'] = self._serialize.query("min_avg_material", min_avg_material, 'float')
        if max_avg_material is not None:
            query_parameters['maxAvgMaterial'] = self._serialize.query("max_avg_material", max_avg_material, 'float')
        if sources is not None:
            query_parameters['sources'] = [self._serialize.query("sources", q, 'str') if q is not None else '' for q in sources]
        if associated_boundary_ids is not None:
            query_parameters['associatedBoundaryIds'] = [self._serialize.query("associated_boundary_ids", q, 'str') if q is not None else '' for q in associated_boundary_ids]
        if operation_boundary_ids is not None:
            query_parameters['operationBoundaryIds'] = [self._serialize.query("operation_boundary_ids", q, 'str') if q is not None else '' for q in operation_boundary_ids]
        if min_operation_start_date_time is not None:
            query_parameters['minOperationStartDateTime'] = self._serialize.query("min_operation_start_date_time", min_operation_start_date_time, 'iso-8601')
        if max_operation_start_date_time is not None:
            query_parameters['maxOperationStartDateTime'] = self._serialize.query("max_operation_start_date_time", max_operation_start_date_time, 'iso-8601')
        if min_operation_end_date_time is not None:
            query_parameters['minOperationEndDateTime'] = self._serialize.query("min_operation_end_date_time", min_operation_end_date_time, 'iso-8601')
        if max_operation_end_date_time is not None:
            query_parameters['maxOperationEndDateTime'] = self._serialize.query("max_operation_end_date_time", max_operation_end_date_time, 'iso-8601')
        if min_operation_modified_date_time is not None:
            query_parameters['minOperationModifiedDateTime'] = self._serialize.query("min_operation_modified_date_time", min_operation_modified_date_time, 'iso-8601')
        if max_operation_modified_date_time is not None:
            query_parameters['maxOperationModifiedDateTime'] = self._serialize.query("max_operation_modified_date_time", max_operation_modified_date_time, 'iso-8601')
        if min_area is not None:
            query_parameters['minArea'] = self._serialize.query("min_area", min_area, 'float')
        if max_area is not None:
            query_parameters['maxArea'] = self._serialize.query("max_area", max_area, 'float')
        if ids is not None:
            query_parameters['ids'] = [self._serialize.query("ids", q, 'str') if q is not None else '' for q in ids]
        if names is not None:
            query_parameters['names'] = [self._serialize.query("names", q, 'str') if q is not None else '' for q in names]
        if property_filters is not None:
            query_parameters['propertyFilters'] = [self._serialize.query("property_filters", q, 'str') if q is not None else '' for q in property_filters]
        if statuses is not None:
            query_parameters['statuses'] = [self._serialize.query("statuses", q, 'str') if q is not None else '' for q in statuses]
        if min_created_date_time is not None:
            query_parameters['minCreatedDateTime'] = self._serialize.query("min_created_date_time", min_created_date_time, 'iso-8601')
        if max_created_date_time is not None:
            query_parameters['maxCreatedDateTime'] = self._serialize.query("max_created_date_time", max_created_date_time, 'iso-8601')
        if min_last_modified_date_time is not None:
            query_parameters['minLastModifiedDateTime'] = self._serialize.query("min_last_modified_date_time", min_last_modified_date_time, 'iso-8601')
        if max_last_modified_date_time is not None:
            query_parameters['maxLastModifiedDateTime'] = self._serialize.query("max_last_modified_date_time", max_last_modified_date_time, 'iso-8601')
        if max_page_size is not None:
            query_parameters['$maxPageSize'] = self._serialize.query("max_page_size", max_page_size, 'int', maximum=1000, minimum=10)
        if skip_token is not None:
            query_parameters['$skipToken'] = self._serialize.query("skip_token", skip_token, 'str')
        query_parameters['api-version'] = self._serialize.query("api_version", api_version, 'str')

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]
        header_parameters['Accept'] = self._serialize.header("accept", accept, 'str')

        request = self._client.get(url, query_parameters, header_parameters)
        pipeline_response = await self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        deserialized = self._deserialize('PlantingDataListResponse', pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized
    get_all_planting_data_across_farmers.metadata = {'url': '/plantingData'}  # type: ignore

    async def get_scenes(
        self,
        farmer_id: str,
        boundary_id: str,
        provider: str = "Microsoft",
        source: Optional[str] = "Sentinel_2_L2A",
        start_date: Optional[datetime.datetime] = None,
        end_date: Optional[datetime.datetime] = None,
        max_cloud_coverage_percentage: Optional[float] = 100,
        max_dark_pixel_coverage_percentage: Optional[float] = 100,
        image_names: Optional[List[Union[str, "_models.ImageName"]]] = None,
        image_resolutions: Optional[List[Union[str, "_models.ImageResolution"]]] = None,
        image_formats: Optional[List[Union[str, "_models.ImageFormat"]]] = None,
        max_page_size: Optional[int] = 50,
        skip_token: Optional[str] = None,
        **kwargs
    ) -> "_models.SceneEntityResponseListResponse":
        """Returns a list of scenes for given query filter.

        :param farmer_id: FarmerId.
        :type farmer_id: str
        :param boundary_id: BoundaryId.
        :type boundary_id: str
        :param provider: Provider name of scene data.
        :type provider: str
        :param source: Source name of scene data, default value Sentinel_2_L2A (Sentinel 2 L2A).
        :type source: str
        :param start_date: Scene start UTC date (inclusive), sample format: yyyy-Mm-ddZ.
        :type start_date: ~datetime.datetime
        :param end_date: Scene end UTC date (inclusive), sample format: yyyy-Mm-ddZ.
        :type end_date: ~datetime.datetime
        :param max_cloud_coverage_percentage: Filter scenes with cloud coverage percentage less than
         max value. Range [0 to 100.0].
        :type max_cloud_coverage_percentage: float
        :param max_dark_pixel_coverage_percentage: Filter scenes with dark pixel coverage percentage
         less than max value. Range [0 to 100.0].
        :type max_dark_pixel_coverage_percentage: float
        :param image_names: List of image names to be filtered (Default: AllImages).
        :type image_names: list[str or ~dpsclient.models.ImageName]
        :param image_resolutions: List of image resolutions in meters to be filtered (Default: 10).
        :type image_resolutions: list[str or ~dpsclient.models.ImageResolution]
        :param image_formats: List of image formats to be filtered (Default: TIF).
        :type image_formats: list[str or ~dpsclient.models.ImageFormat]
        :param max_page_size: Maximum number of items needed (inclusive).
         Minimum = 10, Maximum = 1000, Default value = 50.
        :type max_page_size: int
        :param skip_token: Skip token for getting next set of results.
        :type skip_token: str
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: SceneEntityResponseListResponse, or the result of cls(response)
        :rtype: ~dpsclient.models.SceneEntityResponseListResponse
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType["_models.SceneEntityResponseListResponse"]
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}))
        api_version = "2020-12-31-preview"
        accept = "application/json"

        # Construct URL
        url = self.get_scenes.metadata['url']  # type: ignore

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]
        query_parameters['provider'] = self._serialize.query("provider", provider, 'str')
        query_parameters['farmerId'] = self._serialize.query("farmer_id", farmer_id, 'str')
        query_parameters['boundaryId'] = self._serialize.query("boundary_id", boundary_id, 'str')
        if source is not None:
            query_parameters['source'] = self._serialize.query("source", source, 'str')
        if start_date is not None:
            query_parameters['startDate'] = self._serialize.query("start_date", start_date, 'iso-8601')
        if end_date is not None:
            query_parameters['endDate'] = self._serialize.query("end_date", end_date, 'iso-8601')
        if max_cloud_coverage_percentage is not None:
            query_parameters['maxCloudCoveragePercentage'] = self._serialize.query("max_cloud_coverage_percentage", max_cloud_coverage_percentage, 'float', maximum=100, minimum=0)
        if max_dark_pixel_coverage_percentage is not None:
            query_parameters['maxDarkPixelCoveragePercentage'] = self._serialize.query("max_dark_pixel_coverage_percentage", max_dark_pixel_coverage_percentage, 'float', maximum=100, minimum=0)
        if image_names is not None:
            query_parameters['imageNames'] = [self._serialize.query("image_names", q, 'str') if q is not None else '' for q in image_names]
        if image_resolutions is not None:
            query_parameters['imageResolutions'] = [self._serialize.query("image_resolutions", q, 'str') if q is not None else '' for q in image_resolutions]
        if image_formats is not None:
            query_parameters['imageFormats'] = [self._serialize.query("image_formats", q, 'str') if q is not None else '' for q in image_formats]
        if max_page_size is not None:
            query_parameters['$maxPageSize'] = self._serialize.query("max_page_size", max_page_size, 'int', maximum=1000, minimum=10)
        if skip_token is not None:
            query_parameters['$skipToken'] = self._serialize.query("skip_token", skip_token, 'str')
        query_parameters['api-version'] = self._serialize.query("api_version", api_version, 'str')

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]
        header_parameters['Accept'] = self._serialize.header("accept", accept, 'str')

        request = self._client.get(url, query_parameters, header_parameters)
        pipeline_response = await self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        deserialized = self._deserialize('SceneEntityResponseListResponse', pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized
    get_scenes.metadata = {'url': '/scenes'}  # type: ignore

    async def download_file(
        self,
        file_path: str,
        **kwargs
    ) -> None:
        """Downloads and returns file content as response for the given input filePath.

        :param file_path: cloud storage path of scene file.
        :type file_path: str
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: None, or the result of cls(response)
        :rtype: None
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType[None]
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}))
        api_version = "2020-12-31-preview"

        # Construct URL
        url = self.download_file.metadata['url']  # type: ignore

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]
        query_parameters['filePath'] = self._serialize.query("file_path", file_path, 'str')
        query_parameters['api-version'] = self._serialize.query("api_version", api_version, 'str')

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]

        request = self._client.get(url, query_parameters, header_parameters)
        pipeline_response = await self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if cls:
            return cls(pipeline_response, None, {})

    download_file.metadata = {'url': '/scenes/downloadFiles'}  # type: ignore

    async def create_season(
        self,
        season_id: str,
        body: Optional["_models.Season"] = None,
        **kwargs
    ) -> "_models.Season":
        """Creates new season object with given request body.

        :param season_id: Season id.
        :type season_id: str
        :param body: Season object.
        :type body: ~dpsclient.models.Season
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: Season, or the result of cls(response)
        :rtype: ~dpsclient.models.Season
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType["_models.Season"]
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}))
        api_version = "2020-12-31-preview"
        content_type = kwargs.pop("content_type", "application/json")
        accept = "application/json"

        # Construct URL
        url = self.create_season.metadata['url']  # type: ignore
        path_format_arguments = {
            'seasonId': self._serialize.url("season_id", season_id, 'str'),
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]
        query_parameters['api-version'] = self._serialize.query("api_version", api_version, 'str')

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]
        header_parameters['Content-Type'] = self._serialize.header("content_type", content_type, 'str')
        header_parameters['Accept'] = self._serialize.header("accept", accept, 'str')

        body_content_kwargs = {}  # type: Dict[str, Any]
        if body is not None:
            body_content = self._serialize.body(body, 'Season')
        else:
            body_content = None
        body_content_kwargs['content'] = body_content
        request = self._client.put(url, query_parameters, header_parameters, **body_content_kwargs)
        pipeline_response = await self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [201]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        deserialized = self._deserialize('Season', pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized
    create_season.metadata = {'url': '/seasons/{seasonId}'}  # type: ignore

    async def get_season(
        self,
        season_id: str,
        **kwargs
    ) -> "_models.Season":
        """Get season object with given season id.

        :param season_id: Season Id.
        :type season_id: str
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: Season, or the result of cls(response)
        :rtype: ~dpsclient.models.Season
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType["_models.Season"]
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}))
        api_version = "2020-12-31-preview"
        accept = "application/json"

        # Construct URL
        url = self.get_season.metadata['url']  # type: ignore
        path_format_arguments = {
            'seasonId': self._serialize.url("season_id", season_id, 'str'),
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]
        query_parameters['api-version'] = self._serialize.query("api_version", api_version, 'str')

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]
        header_parameters['Accept'] = self._serialize.header("accept", accept, 'str')

        request = self._client.get(url, query_parameters, header_parameters)
        pipeline_response = await self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        deserialized = self._deserialize('Season', pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized
    get_season.metadata = {'url': '/seasons/{seasonId}'}  # type: ignore

    async def update_season(
        self,
        season_id: str,
        body: Optional["_models.Season"] = None,
        **kwargs
    ) -> "_models.Season":
        """Updates Season for given season Id.

        :param season_id: Id of season that need to be updated (system-generated).
        :type season_id: str
        :param body: New state of season.
        :type body: ~dpsclient.models.Season
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: Season, or the result of cls(response)
        :rtype: ~dpsclient.models.Season
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType["_models.Season"]
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}))
        api_version = "2020-12-31-preview"
        content_type = kwargs.pop("content_type", "application/json")
        accept = "application/json"

        # Construct URL
        url = self.update_season.metadata['url']  # type: ignore
        path_format_arguments = {
            'seasonId': self._serialize.url("season_id", season_id, 'str'),
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]
        query_parameters['api-version'] = self._serialize.query("api_version", api_version, 'str')

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]
        header_parameters['Content-Type'] = self._serialize.header("content_type", content_type, 'str')
        header_parameters['Accept'] = self._serialize.header("accept", accept, 'str')

        body_content_kwargs = {}  # type: Dict[str, Any]
        if body is not None:
            body_content = self._serialize.body(body, 'Season')
        else:
            body_content = None
        body_content_kwargs['content'] = body_content
        request = self._client.patch(url, query_parameters, header_parameters, **body_content_kwargs)
        pipeline_response = await self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        deserialized = self._deserialize('Season', pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized
    update_season.metadata = {'url': '/seasons/{seasonId}'}  # type: ignore

    async def delete_season(
        self,
        season_id: str,
        **kwargs
    ) -> None:
        """Deletes Season for given season id.

        :param season_id: Id of season to be deleted.
        :type season_id: str
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: None, or the result of cls(response)
        :rtype: None
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType[None]
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}))
        api_version = "2020-12-31-preview"

        # Construct URL
        url = self.delete_season.metadata['url']  # type: ignore
        path_format_arguments = {
            'seasonId': self._serialize.url("season_id", season_id, 'str'),
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]
        query_parameters['api-version'] = self._serialize.query("api_version", api_version, 'str')

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]

        request = self._client.delete(url, query_parameters, header_parameters)
        pipeline_response = await self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if cls:
            return cls(pipeline_response, None, {})

    delete_season.metadata = {'url': '/seasons/{seasonId}'}  # type: ignore

    async def get_seasons(
        self,
        min_start_date: Optional[str] = None,
        max_start_date: Optional[str] = None,
        min_end_date: Optional[str] = None,
        max_end_date: Optional[str] = None,
        years: Optional[List[str]] = None,
        ids: Optional[List[str]] = None,
        names: Optional[List[str]] = None,
        property_filters: Optional[List[str]] = None,
        statuses: Optional[List[str]] = None,
        min_created_date_time: Optional[datetime.datetime] = None,
        max_created_date_time: Optional[datetime.datetime] = None,
        min_last_modified_date_time: Optional[datetime.datetime] = None,
        max_last_modified_date_time: Optional[datetime.datetime] = None,
        max_page_size: Optional[int] = 50,
        skip_token: Optional[str] = None,
        **kwargs
    ) -> "_models.SeasonListResponse":
        """Returns a list of seasons.

        :param min_start_date: Minimum season start date in yyyy-MM-dd format.
        :type min_start_date: str
        :param max_start_date: Maximum season start date in yyyy-MM-dd format.
        :type max_start_date: str
        :param min_end_date: Minimum season end date in yyyy-MM-dd format.
        :type min_end_date: str
        :param max_end_date: Maximum season end date in yyyy-MM-dd format.
        :type max_end_date: str
        :param years: Years of the resource.
        :type years: list[str]
        :param ids: Ids of the resource.
        :type ids: list[str]
        :param names: Names of the resource.
        :type names: list[str]
        :param property_filters: Filters on key-value pairs within the Properties object.
         eg. "{testkey} eq {testvalue}".
        :type property_filters: list[str]
        :param statuses: Statuses of the resource.
        :type statuses: list[str]
        :param min_created_date_time: Minimum creation date of resource (inclusive).
        :type min_created_date_time: ~datetime.datetime
        :param max_created_date_time: Maximum creation date of resource (inclusive).
        :type max_created_date_time: ~datetime.datetime
        :param min_last_modified_date_time: Minimum last modified date of resource (inclusive).
        :type min_last_modified_date_time: ~datetime.datetime
        :param max_last_modified_date_time: Maximum last modified date of resource (inclusive).
        :type max_last_modified_date_time: ~datetime.datetime
        :param max_page_size: Maximum number of items needed (inclusive).
         Minimum = 10, Maximum = 1000, Default value = 50.
        :type max_page_size: int
        :param skip_token: Skip token for getting next set of results.
        :type skip_token: str
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: SeasonListResponse, or the result of cls(response)
        :rtype: ~dpsclient.models.SeasonListResponse
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType["_models.SeasonListResponse"]
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}))
        api_version = "2020-12-31-preview"
        accept = "application/json"

        # Construct URL
        url = self.get_seasons.metadata['url']  # type: ignore

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]
        if min_start_date is not None:
            query_parameters['minStartDate'] = self._serialize.query("min_start_date", min_start_date, 'str')
        if max_start_date is not None:
            query_parameters['maxStartDate'] = self._serialize.query("max_start_date", max_start_date, 'str')
        if min_end_date is not None:
            query_parameters['minEndDate'] = self._serialize.query("min_end_date", min_end_date, 'str')
        if max_end_date is not None:
            query_parameters['maxEndDate'] = self._serialize.query("max_end_date", max_end_date, 'str')
        if years is not None:
            query_parameters['years'] = [self._serialize.query("years", q, 'str') if q is not None else '' for q in years]
        if ids is not None:
            query_parameters['ids'] = [self._serialize.query("ids", q, 'str') if q is not None else '' for q in ids]
        if names is not None:
            query_parameters['names'] = [self._serialize.query("names", q, 'str') if q is not None else '' for q in names]
        if property_filters is not None:
            query_parameters['propertyFilters'] = [self._serialize.query("property_filters", q, 'str') if q is not None else '' for q in property_filters]
        if statuses is not None:
            query_parameters['statuses'] = [self._serialize.query("statuses", q, 'str') if q is not None else '' for q in statuses]
        if min_created_date_time is not None:
            query_parameters['minCreatedDateTime'] = self._serialize.query("min_created_date_time", min_created_date_time, 'iso-8601')
        if max_created_date_time is not None:
            query_parameters['maxCreatedDateTime'] = self._serialize.query("max_created_date_time", max_created_date_time, 'iso-8601')
        if min_last_modified_date_time is not None:
            query_parameters['minLastModifiedDateTime'] = self._serialize.query("min_last_modified_date_time", min_last_modified_date_time, 'iso-8601')
        if max_last_modified_date_time is not None:
            query_parameters['maxLastModifiedDateTime'] = self._serialize.query("max_last_modified_date_time", max_last_modified_date_time, 'iso-8601')
        if max_page_size is not None:
            query_parameters['$maxPageSize'] = self._serialize.query("max_page_size", max_page_size, 'int', maximum=1000, minimum=10)
        if skip_token is not None:
            query_parameters['$skipToken'] = self._serialize.query("skip_token", skip_token, 'str')
        query_parameters['api-version'] = self._serialize.query("api_version", api_version, 'str')

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]
        header_parameters['Accept'] = self._serialize.header("accept", accept, 'str')

        request = self._client.get(url, query_parameters, header_parameters)
        pipeline_response = await self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        deserialized = self._deserialize('SeasonListResponse', pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized
    get_seasons.metadata = {'url': '/seasons'}  # type: ignore

    async def get_seasonal_field(
        self,
        farmer_id: str,
        seasonal_field_id: str,
        **kwargs
    ) -> "_models.SeasonalField":
        """Get field object with given fieldId.

        :param farmer_id: Id of the farmer.
        :type farmer_id: str
        :param seasonal_field_id: Id of the seasonalField.
        :type seasonal_field_id: str
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: SeasonalField, or the result of cls(response)
        :rtype: ~dpsclient.models.SeasonalField
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType["_models.SeasonalField"]
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}))
        api_version = "2020-12-31-preview"
        accept = "application/json"

        # Construct URL
        url = self.get_seasonal_field.metadata['url']  # type: ignore
        path_format_arguments = {
            'farmerId': self._serialize.url("farmer_id", farmer_id, 'str'),
            'seasonalFieldId': self._serialize.url("seasonal_field_id", seasonal_field_id, 'str'),
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]
        query_parameters['api-version'] = self._serialize.query("api_version", api_version, 'str')

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]
        header_parameters['Accept'] = self._serialize.header("accept", accept, 'str')

        request = self._client.get(url, query_parameters, header_parameters)
        pipeline_response = await self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        deserialized = self._deserialize('SeasonalField', pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized
    get_seasonal_field.metadata = {'url': '/farmers/{farmerId}/seasonalFields/{seasonalFieldId}'}  # type: ignore

    async def create_seasonal_field(
        self,
        farmer_id: str,
        seasonal_field_id: str,
        body: Optional["_models.SeasonalField"] = None,
        **kwargs
    ) -> "_models.SeasonalField":
        """Creates new field object with given request body.

        :param farmer_id: Id of the associated farmer.
        :type farmer_id: str
        :param seasonal_field_id: SeasonalField id.
        :type seasonal_field_id: str
        :param body: Field object.
        :type body: ~dpsclient.models.SeasonalField
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: SeasonalField, or the result of cls(response)
        :rtype: ~dpsclient.models.SeasonalField
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType["_models.SeasonalField"]
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}))
        api_version = "2020-12-31-preview"
        content_type = kwargs.pop("content_type", "application/json")
        accept = "application/json"

        # Construct URL
        url = self.create_seasonal_field.metadata['url']  # type: ignore
        path_format_arguments = {
            'farmerId': self._serialize.url("farmer_id", farmer_id, 'str'),
            'seasonalFieldId': self._serialize.url("seasonal_field_id", seasonal_field_id, 'str'),
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]
        query_parameters['api-version'] = self._serialize.query("api_version", api_version, 'str')

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]
        header_parameters['Content-Type'] = self._serialize.header("content_type", content_type, 'str')
        header_parameters['Accept'] = self._serialize.header("accept", accept, 'str')

        body_content_kwargs = {}  # type: Dict[str, Any]
        if body is not None:
            body_content = self._serialize.body(body, 'SeasonalField')
        else:
            body_content = None
        body_content_kwargs['content'] = body_content
        request = self._client.put(url, query_parameters, header_parameters, **body_content_kwargs)
        pipeline_response = await self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [201]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        deserialized = self._deserialize('SeasonalField', pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized
    create_seasonal_field.metadata = {'url': '/farmers/{farmerId}/seasonalFields/{seasonalFieldId}'}  # type: ignore

    async def update_seasonal_field(
        self,
        farmer_id: str,
        seasonal_field_id: str,
        body: Optional["_models.SeasonalField"] = None,
        **kwargs
    ) -> "_models.SeasonalField":
        """Updates SeasonalField for given field Id.

        :param farmer_id: Id of the farmer.
        :type farmer_id: str
        :param seasonal_field_id: Id of the seasonalField.
        :type seasonal_field_id: str
        :param body: New state of seasonal field.
        :type body: ~dpsclient.models.SeasonalField
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: SeasonalField, or the result of cls(response)
        :rtype: ~dpsclient.models.SeasonalField
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType["_models.SeasonalField"]
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}))
        api_version = "2020-12-31-preview"
        content_type = kwargs.pop("content_type", "application/json")
        accept = "application/json"

        # Construct URL
        url = self.update_seasonal_field.metadata['url']  # type: ignore
        path_format_arguments = {
            'farmerId': self._serialize.url("farmer_id", farmer_id, 'str'),
            'seasonalFieldId': self._serialize.url("seasonal_field_id", seasonal_field_id, 'str'),
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]
        query_parameters['api-version'] = self._serialize.query("api_version", api_version, 'str')

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]
        header_parameters['Content-Type'] = self._serialize.header("content_type", content_type, 'str')
        header_parameters['Accept'] = self._serialize.header("accept", accept, 'str')

        body_content_kwargs = {}  # type: Dict[str, Any]
        if body is not None:
            body_content = self._serialize.body(body, 'SeasonalField')
        else:
            body_content = None
        body_content_kwargs['content'] = body_content
        request = self._client.patch(url, query_parameters, header_parameters, **body_content_kwargs)
        pipeline_response = await self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        deserialized = self._deserialize('SeasonalField', pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized
    update_seasonal_field.metadata = {'url': '/farmers/{farmerId}/seasonalFields/{seasonalFieldId}'}  # type: ignore

    async def delete_seasonal_field(
        self,
        farmer_id: str,
        seasonal_field_id: str,
        **kwargs
    ) -> None:
        """Deletes SeasonalField for given id.

        :param farmer_id: Id of the farmer.
        :type farmer_id: str
        :param seasonal_field_id: Id of the seasonalField.
        :type seasonal_field_id: str
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: None, or the result of cls(response)
        :rtype: None
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType[None]
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}))
        api_version = "2020-12-31-preview"

        # Construct URL
        url = self.delete_seasonal_field.metadata['url']  # type: ignore
        path_format_arguments = {
            'farmerId': self._serialize.url("farmer_id", farmer_id, 'str'),
            'seasonalFieldId': self._serialize.url("seasonal_field_id", seasonal_field_id, 'str'),
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]
        query_parameters['api-version'] = self._serialize.query("api_version", api_version, 'str')

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]

        request = self._client.delete(url, query_parameters, header_parameters)
        pipeline_response = await self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if cls:
            return cls(pipeline_response, None, {})

    delete_seasonal_field.metadata = {'url': '/farmers/{farmerId}/seasonalFields/{seasonalFieldId}'}  # type: ignore

    async def get_seasonal_fields(
        self,
        farmer_id: str,
        farm_ids: Optional[List[str]] = None,
        field_ids: Optional[List[str]] = None,
        season_ids: Optional[List[str]] = None,
        crop_variety_ids: Optional[List[str]] = None,
        crop_ids: Optional[List[str]] = None,
        min_avg_yield_value: Optional[float] = None,
        max_avg_yield_value: Optional[float] = None,
        avg_yield_unit: Optional[str] = None,
        min_avg_seed_population_value: Optional[float] = None,
        max_avg_seed_population_value: Optional[float] = None,
        avg_seed_population_unit: Optional[str] = None,
        min_planting_date: Optional[str] = None,
        max_planting_date: Optional[str] = None,
        ids: Optional[List[str]] = None,
        names: Optional[List[str]] = None,
        property_filters: Optional[List[str]] = None,
        statuses: Optional[List[str]] = None,
        min_created_date_time: Optional[datetime.datetime] = None,
        max_created_date_time: Optional[datetime.datetime] = None,
        min_last_modified_date_time: Optional[datetime.datetime] = None,
        max_last_modified_date_time: Optional[datetime.datetime] = None,
        max_page_size: Optional[int] = 50,
        skip_token: Optional[str] = None,
        **kwargs
    ) -> "_models.SeasonalFieldListResponse":
        """Returns a list of seasonalFields.

        :param farmer_id: Id of the farmer.
        :type farmer_id: str
        :param farm_ids: Farm Ids of the resource.
        :type farm_ids: list[str]
        :param field_ids: Field Ids of the resource.
        :type field_ids: list[str]
        :param season_ids: Season Ids of the resource.
        :type season_ids: list[str]
        :param crop_variety_ids: CropVarietyIds of the resource.
        :type crop_variety_ids: list[str]
        :param crop_ids: Ids of the crop it belongs to.
        :type crop_ids: list[str]
        :param min_avg_yield_value: Minimum average yield value of the seasonal field(inclusive).
        :type min_avg_yield_value: float
        :param max_avg_yield_value: Maximum average yield value of the seasonal field(inclusive).
        :type max_avg_yield_value: float
        :param avg_yield_unit: Unit of the average yield value attribute.
        :type avg_yield_unit: str
        :param min_avg_seed_population_value: Minimum average seed population value of the seasonal
         field(inclusive).
        :type min_avg_seed_population_value: float
        :param max_avg_seed_population_value: Maximum average seed population value of the seasonal
         field(inclusive).
        :type max_avg_seed_population_value: float
        :param avg_seed_population_unit: Unit of average seed population value attribute.
        :type avg_seed_population_unit: str
        :param min_planting_date: Minimum planting date in yyyy-MM-dd format.
        :type min_planting_date: str
        :param max_planting_date: Maximum planting date in yyyy-MM-dd format.
        :type max_planting_date: str
        :param ids: Ids of the resource.
        :type ids: list[str]
        :param names: Names of the resource.
        :type names: list[str]
        :param property_filters: Filters on key-value pairs within the Properties object.
         eg. "{testkey} eq {testvalue}".
        :type property_filters: list[str]
        :param statuses: Statuses of the resource.
        :type statuses: list[str]
        :param min_created_date_time: Minimum creation date of resource (inclusive).
        :type min_created_date_time: ~datetime.datetime
        :param max_created_date_time: Maximum creation date of resource (inclusive).
        :type max_created_date_time: ~datetime.datetime
        :param min_last_modified_date_time: Minimum last modified date of resource (inclusive).
        :type min_last_modified_date_time: ~datetime.datetime
        :param max_last_modified_date_time: Maximum last modified date of resource (inclusive).
        :type max_last_modified_date_time: ~datetime.datetime
        :param max_page_size: Maximum number of items needed (inclusive).
         Minimum = 10, Maximum = 1000, Default value = 50.
        :type max_page_size: int
        :param skip_token: Skip token for getting next set of results.
        :type skip_token: str
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: SeasonalFieldListResponse, or the result of cls(response)
        :rtype: ~dpsclient.models.SeasonalFieldListResponse
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType["_models.SeasonalFieldListResponse"]
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}))
        api_version = "2020-12-31-preview"
        accept = "application/json"

        # Construct URL
        url = self.get_seasonal_fields.metadata['url']  # type: ignore
        path_format_arguments = {
            'farmerId': self._serialize.url("farmer_id", farmer_id, 'str'),
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]
        if farm_ids is not None:
            query_parameters['farmIds'] = [self._serialize.query("farm_ids", q, 'str') if q is not None else '' for q in farm_ids]
        if field_ids is not None:
            query_parameters['fieldIds'] = [self._serialize.query("field_ids", q, 'str') if q is not None else '' for q in field_ids]
        if season_ids is not None:
            query_parameters['seasonIds'] = [self._serialize.query("season_ids", q, 'str') if q is not None else '' for q in season_ids]
        if crop_variety_ids is not None:
            query_parameters['cropVarietyIds'] = [self._serialize.query("crop_variety_ids", q, 'str') if q is not None else '' for q in crop_variety_ids]
        if crop_ids is not None:
            query_parameters['cropIds'] = [self._serialize.query("crop_ids", q, 'str') if q is not None else '' for q in crop_ids]
        if min_avg_yield_value is not None:
            query_parameters['minAvgYieldValue'] = self._serialize.query("min_avg_yield_value", min_avg_yield_value, 'float')
        if max_avg_yield_value is not None:
            query_parameters['maxAvgYieldValue'] = self._serialize.query("max_avg_yield_value", max_avg_yield_value, 'float')
        if avg_yield_unit is not None:
            query_parameters['avgYieldUnit'] = self._serialize.query("avg_yield_unit", avg_yield_unit, 'str')
        if min_avg_seed_population_value is not None:
            query_parameters['minAvgSeedPopulationValue'] = self._serialize.query("min_avg_seed_population_value", min_avg_seed_population_value, 'float')
        if max_avg_seed_population_value is not None:
            query_parameters['maxAvgSeedPopulationValue'] = self._serialize.query("max_avg_seed_population_value", max_avg_seed_population_value, 'float')
        if avg_seed_population_unit is not None:
            query_parameters['avgSeedPopulationUnit'] = self._serialize.query("avg_seed_population_unit", avg_seed_population_unit, 'str')
        if min_planting_date is not None:
            query_parameters['minPlantingDate'] = self._serialize.query("min_planting_date", min_planting_date, 'str')
        if max_planting_date is not None:
            query_parameters['maxPlantingDate'] = self._serialize.query("max_planting_date", max_planting_date, 'str')
        if ids is not None:
            query_parameters['ids'] = [self._serialize.query("ids", q, 'str') if q is not None else '' for q in ids]
        if names is not None:
            query_parameters['names'] = [self._serialize.query("names", q, 'str') if q is not None else '' for q in names]
        if property_filters is not None:
            query_parameters['propertyFilters'] = [self._serialize.query("property_filters", q, 'str') if q is not None else '' for q in property_filters]
        if statuses is not None:
            query_parameters['statuses'] = [self._serialize.query("statuses", q, 'str') if q is not None else '' for q in statuses]
        if min_created_date_time is not None:
            query_parameters['minCreatedDateTime'] = self._serialize.query("min_created_date_time", min_created_date_time, 'iso-8601')
        if max_created_date_time is not None:
            query_parameters['maxCreatedDateTime'] = self._serialize.query("max_created_date_time", max_created_date_time, 'iso-8601')
        if min_last_modified_date_time is not None:
            query_parameters['minLastModifiedDateTime'] = self._serialize.query("min_last_modified_date_time", min_last_modified_date_time, 'iso-8601')
        if max_last_modified_date_time is not None:
            query_parameters['maxLastModifiedDateTime'] = self._serialize.query("max_last_modified_date_time", max_last_modified_date_time, 'iso-8601')
        if max_page_size is not None:
            query_parameters['$maxPageSize'] = self._serialize.query("max_page_size", max_page_size, 'int', maximum=1000, minimum=10)
        if skip_token is not None:
            query_parameters['$skipToken'] = self._serialize.query("skip_token", skip_token, 'str')
        query_parameters['api-version'] = self._serialize.query("api_version", api_version, 'str')

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]
        header_parameters['Accept'] = self._serialize.header("accept", accept, 'str')

        request = self._client.get(url, query_parameters, header_parameters)
        pipeline_response = await self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        deserialized = self._deserialize('SeasonalFieldListResponse', pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized
    get_seasonal_fields.metadata = {'url': '/farmers/{farmerId}/seasonalFields'}  # type: ignore

    async def get_all_seasonal_fields(
        self,
        farm_ids: Optional[List[str]] = None,
        field_ids: Optional[List[str]] = None,
        season_ids: Optional[List[str]] = None,
        crop_variety_ids: Optional[List[str]] = None,
        crop_ids: Optional[List[str]] = None,
        min_avg_yield_value: Optional[float] = None,
        max_avg_yield_value: Optional[float] = None,
        avg_yield_unit: Optional[str] = None,
        min_avg_seed_population_value: Optional[float] = None,
        max_avg_seed_population_value: Optional[float] = None,
        avg_seed_population_unit: Optional[str] = None,
        min_planting_date: Optional[str] = None,
        max_planting_date: Optional[str] = None,
        ids: Optional[List[str]] = None,
        names: Optional[List[str]] = None,
        property_filters: Optional[List[str]] = None,
        statuses: Optional[List[str]] = None,
        min_created_date_time: Optional[datetime.datetime] = None,
        max_created_date_time: Optional[datetime.datetime] = None,
        min_last_modified_date_time: Optional[datetime.datetime] = None,
        max_last_modified_date_time: Optional[datetime.datetime] = None,
        max_page_size: Optional[int] = 50,
        skip_token: Optional[str] = None,
        **kwargs
    ) -> "_models.SeasonalFieldListResponse":
        """Returns a list of seasonalFields across all farmers.

        :param farm_ids: Farm Ids of the resource.
        :type farm_ids: list[str]
        :param field_ids: Field Ids of the resource.
        :type field_ids: list[str]
        :param season_ids: Season Ids of the resource.
        :type season_ids: list[str]
        :param crop_variety_ids: CropVarietyIds of the resource.
        :type crop_variety_ids: list[str]
        :param crop_ids: Ids of the crop it belongs to.
        :type crop_ids: list[str]
        :param min_avg_yield_value: Minimum average yield value of the seasonal field(inclusive).
        :type min_avg_yield_value: float
        :param max_avg_yield_value: Maximum average yield value of the seasonal field(inclusive).
        :type max_avg_yield_value: float
        :param avg_yield_unit: Unit of the average yield value attribute.
        :type avg_yield_unit: str
        :param min_avg_seed_population_value: Minimum average seed population value of the seasonal
         field(inclusive).
        :type min_avg_seed_population_value: float
        :param max_avg_seed_population_value: Maximum average seed population value of the seasonal
         field(inclusive).
        :type max_avg_seed_population_value: float
        :param avg_seed_population_unit: Unit of average seed population value attribute.
        :type avg_seed_population_unit: str
        :param min_planting_date: Minimum planting date in yyyy-MM-dd format.
        :type min_planting_date: str
        :param max_planting_date: Maximum planting date in yyyy-MM-dd format.
        :type max_planting_date: str
        :param ids: Ids of the resource.
        :type ids: list[str]
        :param names: Names of the resource.
        :type names: list[str]
        :param property_filters: Filters on key-value pairs within the Properties object.
         eg. "{testkey} eq {testvalue}".
        :type property_filters: list[str]
        :param statuses: Statuses of the resource.
        :type statuses: list[str]
        :param min_created_date_time: Minimum creation date of resource (inclusive).
        :type min_created_date_time: ~datetime.datetime
        :param max_created_date_time: Maximum creation date of resource (inclusive).
        :type max_created_date_time: ~datetime.datetime
        :param min_last_modified_date_time: Minimum last modified date of resource (inclusive).
        :type min_last_modified_date_time: ~datetime.datetime
        :param max_last_modified_date_time: Maximum last modified date of resource (inclusive).
        :type max_last_modified_date_time: ~datetime.datetime
        :param max_page_size: Maximum number of items needed (inclusive).
         Minimum = 10, Maximum = 1000, Default value = 50.
        :type max_page_size: int
        :param skip_token: Skip token for getting next set of results.
        :type skip_token: str
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: SeasonalFieldListResponse, or the result of cls(response)
        :rtype: ~dpsclient.models.SeasonalFieldListResponse
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType["_models.SeasonalFieldListResponse"]
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}))
        api_version = "2020-12-31-preview"
        accept = "application/json"

        # Construct URL
        url = self.get_all_seasonal_fields.metadata['url']  # type: ignore

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]
        if farm_ids is not None:
            query_parameters['farmIds'] = [self._serialize.query("farm_ids", q, 'str') if q is not None else '' for q in farm_ids]
        if field_ids is not None:
            query_parameters['fieldIds'] = [self._serialize.query("field_ids", q, 'str') if q is not None else '' for q in field_ids]
        if season_ids is not None:
            query_parameters['seasonIds'] = [self._serialize.query("season_ids", q, 'str') if q is not None else '' for q in season_ids]
        if crop_variety_ids is not None:
            query_parameters['cropVarietyIds'] = [self._serialize.query("crop_variety_ids", q, 'str') if q is not None else '' for q in crop_variety_ids]
        if crop_ids is not None:
            query_parameters['cropIds'] = [self._serialize.query("crop_ids", q, 'str') if q is not None else '' for q in crop_ids]
        if min_avg_yield_value is not None:
            query_parameters['minAvgYieldValue'] = self._serialize.query("min_avg_yield_value", min_avg_yield_value, 'float')
        if max_avg_yield_value is not None:
            query_parameters['maxAvgYieldValue'] = self._serialize.query("max_avg_yield_value", max_avg_yield_value, 'float')
        if avg_yield_unit is not None:
            query_parameters['avgYieldUnit'] = self._serialize.query("avg_yield_unit", avg_yield_unit, 'str')
        if min_avg_seed_population_value is not None:
            query_parameters['minAvgSeedPopulationValue'] = self._serialize.query("min_avg_seed_population_value", min_avg_seed_population_value, 'float')
        if max_avg_seed_population_value is not None:
            query_parameters['maxAvgSeedPopulationValue'] = self._serialize.query("max_avg_seed_population_value", max_avg_seed_population_value, 'float')
        if avg_seed_population_unit is not None:
            query_parameters['avgSeedPopulationUnit'] = self._serialize.query("avg_seed_population_unit", avg_seed_population_unit, 'str')
        if min_planting_date is not None:
            query_parameters['minPlantingDate'] = self._serialize.query("min_planting_date", min_planting_date, 'str')
        if max_planting_date is not None:
            query_parameters['maxPlantingDate'] = self._serialize.query("max_planting_date", max_planting_date, 'str')
        if ids is not None:
            query_parameters['ids'] = [self._serialize.query("ids", q, 'str') if q is not None else '' for q in ids]
        if names is not None:
            query_parameters['names'] = [self._serialize.query("names", q, 'str') if q is not None else '' for q in names]
        if property_filters is not None:
            query_parameters['propertyFilters'] = [self._serialize.query("property_filters", q, 'str') if q is not None else '' for q in property_filters]
        if statuses is not None:
            query_parameters['statuses'] = [self._serialize.query("statuses", q, 'str') if q is not None else '' for q in statuses]
        if min_created_date_time is not None:
            query_parameters['minCreatedDateTime'] = self._serialize.query("min_created_date_time", min_created_date_time, 'iso-8601')
        if max_created_date_time is not None:
            query_parameters['maxCreatedDateTime'] = self._serialize.query("max_created_date_time", max_created_date_time, 'iso-8601')
        if min_last_modified_date_time is not None:
            query_parameters['minLastModifiedDateTime'] = self._serialize.query("min_last_modified_date_time", min_last_modified_date_time, 'iso-8601')
        if max_last_modified_date_time is not None:
            query_parameters['maxLastModifiedDateTime'] = self._serialize.query("max_last_modified_date_time", max_last_modified_date_time, 'iso-8601')
        if max_page_size is not None:
            query_parameters['$maxPageSize'] = self._serialize.query("max_page_size", max_page_size, 'int', maximum=1000, minimum=10)
        if skip_token is not None:
            query_parameters['$skipToken'] = self._serialize.query("skip_token", skip_token, 'str')
        query_parameters['api-version'] = self._serialize.query("api_version", api_version, 'str')

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]
        header_parameters['Accept'] = self._serialize.header("accept", accept, 'str')

        request = self._client.get(url, query_parameters, header_parameters)
        pipeline_response = await self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        deserialized = self._deserialize('SeasonalFieldListResponse', pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized
    get_all_seasonal_fields.metadata = {'url': '/seasonalFields'}  # type: ignore

    async def get_tillage_data(
        self,
        tillage_data_id: str,
        farmer_id: str,
        **kwargs
    ) -> "_models.TillageData":
        """Get TillageData object with given id and farmer id.

        :param tillage_data_id: TillageData id.
        :type tillage_data_id: str
        :param farmer_id: Farmer id.
        :type farmer_id: str
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: TillageData, or the result of cls(response)
        :rtype: ~dpsclient.models.TillageData
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType["_models.TillageData"]
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}))
        api_version = "2020-12-31-preview"
        accept = "application/json"

        # Construct URL
        url = self.get_tillage_data.metadata['url']  # type: ignore
        path_format_arguments = {
            'tillageDataId': self._serialize.url("tillage_data_id", tillage_data_id, 'str'),
            'farmerId': self._serialize.url("farmer_id", farmer_id, 'str'),
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]
        query_parameters['api-version'] = self._serialize.query("api_version", api_version, 'str')

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]
        header_parameters['Accept'] = self._serialize.header("accept", accept, 'str')

        request = self._client.get(url, query_parameters, header_parameters)
        pipeline_response = await self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        deserialized = self._deserialize('TillageData', pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized
    get_tillage_data.metadata = {'url': '/farmers/{farmerId}/tillageData/{tillageDataId}'}  # type: ignore

    async def create_tillage_data(
        self,
        farmer_id: str,
        tillage_data_id: str,
        body: Optional["_models.TillageData"] = None,
        **kwargs
    ) -> "_models.TillageData":
        """Creates new TillageData object with given request body.

        :param farmer_id: Id of the associated farmer.
        :type farmer_id: str
        :param tillage_data_id: TillageData id.
        :type tillage_data_id: str
        :param body: TillageData object.
        :type body: ~dpsclient.models.TillageData
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: TillageData, or the result of cls(response)
        :rtype: ~dpsclient.models.TillageData
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType["_models.TillageData"]
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}))
        api_version = "2020-12-31-preview"
        content_type = kwargs.pop("content_type", "application/json")
        accept = "application/json"

        # Construct URL
        url = self.create_tillage_data.metadata['url']  # type: ignore
        path_format_arguments = {
            'farmerId': self._serialize.url("farmer_id", farmer_id, 'str'),
            'tillageDataId': self._serialize.url("tillage_data_id", tillage_data_id, 'str'),
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]
        query_parameters['api-version'] = self._serialize.query("api_version", api_version, 'str')

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]
        header_parameters['Content-Type'] = self._serialize.header("content_type", content_type, 'str')
        header_parameters['Accept'] = self._serialize.header("accept", accept, 'str')

        body_content_kwargs = {}  # type: Dict[str, Any]
        if body is not None:
            body_content = self._serialize.body(body, 'TillageData')
        else:
            body_content = None
        body_content_kwargs['content'] = body_content
        request = self._client.put(url, query_parameters, header_parameters, **body_content_kwargs)
        pipeline_response = await self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [201]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        deserialized = self._deserialize('TillageData', pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized
    create_tillage_data.metadata = {'url': '/farmers/{farmerId}/tillageData/{tillageDataId}'}  # type: ignore

    async def update_tillage_data(
        self,
        farmer_id: str,
        tillage_data_id: str,
        body: Optional["_models.TillageData"] = None,
        **kwargs
    ) -> "_models.TillageData":
        """Updates TillageData object with given request body.

        :param farmer_id: Id of the farmer.
        :type farmer_id: str
        :param tillage_data_id: Id of the TillageData.
        :type tillage_data_id: str
        :param body: TillageData object.
        :type body: ~dpsclient.models.TillageData
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: TillageData, or the result of cls(response)
        :rtype: ~dpsclient.models.TillageData
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType["_models.TillageData"]
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}))
        api_version = "2020-12-31-preview"
        content_type = kwargs.pop("content_type", "application/json")
        accept = "application/json"

        # Construct URL
        url = self.update_tillage_data.metadata['url']  # type: ignore
        path_format_arguments = {
            'farmerId': self._serialize.url("farmer_id", farmer_id, 'str'),
            'tillageDataId': self._serialize.url("tillage_data_id", tillage_data_id, 'str'),
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]
        query_parameters['api-version'] = self._serialize.query("api_version", api_version, 'str')

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]
        header_parameters['Content-Type'] = self._serialize.header("content_type", content_type, 'str')
        header_parameters['Accept'] = self._serialize.header("accept", accept, 'str')

        body_content_kwargs = {}  # type: Dict[str, Any]
        if body is not None:
            body_content = self._serialize.body(body, 'TillageData')
        else:
            body_content = None
        body_content_kwargs['content'] = body_content
        request = self._client.patch(url, query_parameters, header_parameters, **body_content_kwargs)
        pipeline_response = await self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        deserialized = self._deserialize('TillageData', pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized
    update_tillage_data.metadata = {'url': '/farmers/{farmerId}/tillageData/{tillageDataId}'}  # type: ignore

    async def delete_tillage_data(
        self,
        farmer_id: str,
        tillage_data_id: str,
        **kwargs
    ) -> None:
        """Deletes TillageData object associated with given id.

        :param farmer_id: Id of the associated farmer.
        :type farmer_id: str
        :param tillage_data_id: Id of the TillageData.
        :type tillage_data_id: str
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: None, or the result of cls(response)
        :rtype: None
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType[None]
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}))
        api_version = "2020-12-31-preview"

        # Construct URL
        url = self.delete_tillage_data.metadata['url']  # type: ignore
        path_format_arguments = {
            'farmerId': self._serialize.url("farmer_id", farmer_id, 'str'),
            'tillageDataId': self._serialize.url("tillage_data_id", tillage_data_id, 'str'),
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]
        query_parameters['api-version'] = self._serialize.query("api_version", api_version, 'str')

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]

        request = self._client.delete(url, query_parameters, header_parameters)
        pipeline_response = await self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if cls:
            return cls(pipeline_response, None, {})

    delete_tillage_data.metadata = {'url': '/farmers/{farmerId}/tillageData/{tillageDataId}'}  # type: ignore

    async def get_all_tillage_data(
        self,
        farmer_id: str,
        min_tillage_depth: Optional[float] = None,
        max_tillage_depth: Optional[float] = None,
        min_tillage_pressure: Optional[float] = None,
        max_tillage_pressure: Optional[float] = None,
        sources: Optional[List[str]] = None,
        associated_boundary_ids: Optional[List[str]] = None,
        operation_boundary_ids: Optional[List[str]] = None,
        min_operation_start_date_time: Optional[datetime.datetime] = None,
        max_operation_start_date_time: Optional[datetime.datetime] = None,
        min_operation_end_date_time: Optional[datetime.datetime] = None,
        max_operation_end_date_time: Optional[datetime.datetime] = None,
        min_operation_modified_date_time: Optional[datetime.datetime] = None,
        max_operation_modified_date_time: Optional[datetime.datetime] = None,
        min_area: Optional[float] = None,
        max_area: Optional[float] = None,
        ids: Optional[List[str]] = None,
        names: Optional[List[str]] = None,
        property_filters: Optional[List[str]] = None,
        statuses: Optional[List[str]] = None,
        min_created_date_time: Optional[datetime.datetime] = None,
        max_created_date_time: Optional[datetime.datetime] = None,
        min_last_modified_date_time: Optional[datetime.datetime] = None,
        max_last_modified_date_time: Optional[datetime.datetime] = None,
        max_page_size: Optional[int] = 50,
        skip_token: Optional[str] = None,
        **kwargs
    ) -> "_models.TillageDataListResponse":
        """Returns a list of TillageData documents.

        :param farmer_id: Id of the associated farmer.
        :type farmer_id: str
        :param min_tillage_depth: Minimum TillageDepth value(inclusive).
        :type min_tillage_depth: float
        :param max_tillage_depth: Maximum TillageDepth value (inclusive).
        :type max_tillage_depth: float
        :param min_tillage_pressure: Minimum TillagePressure value(inclusive).
        :type min_tillage_pressure: float
        :param max_tillage_pressure: Maximum TillagePressure value (inclusive).
        :type max_tillage_pressure: float
        :param sources: Source of the operation data.
        :type sources: list[str]
        :param associated_boundary_ids: Boundary ids associated with operation data.
        :type associated_boundary_ids: list[str]
        :param operation_boundary_ids: Operation boundary ids associated with operation data.
        :type operation_boundary_ids: list[str]
        :param min_operation_start_date_time: Minimum operation StartDateTime (inclusive).
        :type min_operation_start_date_time: ~datetime.datetime
        :param max_operation_start_date_time: Maximum operation StartDateTime (inclusive).
        :type max_operation_start_date_time: ~datetime.datetime
        :param min_operation_end_date_time: Minimum operation EndDateTime (inclusive).
        :type min_operation_end_date_time: ~datetime.datetime
        :param max_operation_end_date_time: Maximum operation EndDateTime (inclusive).
        :type max_operation_end_date_time: ~datetime.datetime
        :param min_operation_modified_date_time: Minimum OperationModifiedDateTime (inclusive).
        :type min_operation_modified_date_time: ~datetime.datetime
        :param max_operation_modified_date_time: Maximum OperationModifiedDateTime (inclusive).
        :type max_operation_modified_date_time: ~datetime.datetime
        :param min_area: Minimum Area value(inclusive).
        :type min_area: float
        :param max_area: Maximum Area value (inclusive).
        :type max_area: float
        :param ids: Ids of the resource.
        :type ids: list[str]
        :param names: Names of the resource.
        :type names: list[str]
        :param property_filters: Filters on key-value pairs within the Properties object.
         eg. "{testkey} eq {testvalue}".
        :type property_filters: list[str]
        :param statuses: Statuses of the resource.
        :type statuses: list[str]
        :param min_created_date_time: Minimum creation date of resource (inclusive).
        :type min_created_date_time: ~datetime.datetime
        :param max_created_date_time: Maximum creation date of resource (inclusive).
        :type max_created_date_time: ~datetime.datetime
        :param min_last_modified_date_time: Minimum last modified date of resource (inclusive).
        :type min_last_modified_date_time: ~datetime.datetime
        :param max_last_modified_date_time: Maximum last modified date of resource (inclusive).
        :type max_last_modified_date_time: ~datetime.datetime
        :param max_page_size: Maximum number of items needed (inclusive).
         Minimum = 10, Maximum = 1000, Default value = 50.
        :type max_page_size: int
        :param skip_token: Skip token for getting next set of results.
        :type skip_token: str
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: TillageDataListResponse, or the result of cls(response)
        :rtype: ~dpsclient.models.TillageDataListResponse
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType["_models.TillageDataListResponse"]
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}))
        api_version = "2020-12-31-preview"
        accept = "application/json"

        # Construct URL
        url = self.get_all_tillage_data.metadata['url']  # type: ignore
        path_format_arguments = {
            'farmerId': self._serialize.url("farmer_id", farmer_id, 'str'),
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]
        if min_tillage_depth is not None:
            query_parameters['minTillageDepth'] = self._serialize.query("min_tillage_depth", min_tillage_depth, 'float')
        if max_tillage_depth is not None:
            query_parameters['maxTillageDepth'] = self._serialize.query("max_tillage_depth", max_tillage_depth, 'float')
        if min_tillage_pressure is not None:
            query_parameters['minTillagePressure'] = self._serialize.query("min_tillage_pressure", min_tillage_pressure, 'float')
        if max_tillage_pressure is not None:
            query_parameters['maxTillagePressure'] = self._serialize.query("max_tillage_pressure", max_tillage_pressure, 'float')
        if sources is not None:
            query_parameters['sources'] = [self._serialize.query("sources", q, 'str') if q is not None else '' for q in sources]
        if associated_boundary_ids is not None:
            query_parameters['associatedBoundaryIds'] = [self._serialize.query("associated_boundary_ids", q, 'str') if q is not None else '' for q in associated_boundary_ids]
        if operation_boundary_ids is not None:
            query_parameters['operationBoundaryIds'] = [self._serialize.query("operation_boundary_ids", q, 'str') if q is not None else '' for q in operation_boundary_ids]
        if min_operation_start_date_time is not None:
            query_parameters['minOperationStartDateTime'] = self._serialize.query("min_operation_start_date_time", min_operation_start_date_time, 'iso-8601')
        if max_operation_start_date_time is not None:
            query_parameters['maxOperationStartDateTime'] = self._serialize.query("max_operation_start_date_time", max_operation_start_date_time, 'iso-8601')
        if min_operation_end_date_time is not None:
            query_parameters['minOperationEndDateTime'] = self._serialize.query("min_operation_end_date_time", min_operation_end_date_time, 'iso-8601')
        if max_operation_end_date_time is not None:
            query_parameters['maxOperationEndDateTime'] = self._serialize.query("max_operation_end_date_time", max_operation_end_date_time, 'iso-8601')
        if min_operation_modified_date_time is not None:
            query_parameters['minOperationModifiedDateTime'] = self._serialize.query("min_operation_modified_date_time", min_operation_modified_date_time, 'iso-8601')
        if max_operation_modified_date_time is not None:
            query_parameters['maxOperationModifiedDateTime'] = self._serialize.query("max_operation_modified_date_time", max_operation_modified_date_time, 'iso-8601')
        if min_area is not None:
            query_parameters['minArea'] = self._serialize.query("min_area", min_area, 'float')
        if max_area is not None:
            query_parameters['maxArea'] = self._serialize.query("max_area", max_area, 'float')
        if ids is not None:
            query_parameters['ids'] = [self._serialize.query("ids", q, 'str') if q is not None else '' for q in ids]
        if names is not None:
            query_parameters['names'] = [self._serialize.query("names", q, 'str') if q is not None else '' for q in names]
        if property_filters is not None:
            query_parameters['propertyFilters'] = [self._serialize.query("property_filters", q, 'str') if q is not None else '' for q in property_filters]
        if statuses is not None:
            query_parameters['statuses'] = [self._serialize.query("statuses", q, 'str') if q is not None else '' for q in statuses]
        if min_created_date_time is not None:
            query_parameters['minCreatedDateTime'] = self._serialize.query("min_created_date_time", min_created_date_time, 'iso-8601')
        if max_created_date_time is not None:
            query_parameters['maxCreatedDateTime'] = self._serialize.query("max_created_date_time", max_created_date_time, 'iso-8601')
        if min_last_modified_date_time is not None:
            query_parameters['minLastModifiedDateTime'] = self._serialize.query("min_last_modified_date_time", min_last_modified_date_time, 'iso-8601')
        if max_last_modified_date_time is not None:
            query_parameters['maxLastModifiedDateTime'] = self._serialize.query("max_last_modified_date_time", max_last_modified_date_time, 'iso-8601')
        if max_page_size is not None:
            query_parameters['$maxPageSize'] = self._serialize.query("max_page_size", max_page_size, 'int', maximum=1000, minimum=10)
        if skip_token is not None:
            query_parameters['$skipToken'] = self._serialize.query("skip_token", skip_token, 'str')
        query_parameters['api-version'] = self._serialize.query("api_version", api_version, 'str')

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]
        header_parameters['Accept'] = self._serialize.header("accept", accept, 'str')

        request = self._client.get(url, query_parameters, header_parameters)
        pipeline_response = await self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        deserialized = self._deserialize('TillageDataListResponse', pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized
    get_all_tillage_data.metadata = {'url': '/farmers/{farmerId}/tillageData'}  # type: ignore

    async def get_all_tillage_data_across_farmers(
        self,
        min_tillage_depth: Optional[float] = None,
        max_tillage_depth: Optional[float] = None,
        min_tillage_pressure: Optional[float] = None,
        max_tillage_pressure: Optional[float] = None,
        sources: Optional[List[str]] = None,
        associated_boundary_ids: Optional[List[str]] = None,
        operation_boundary_ids: Optional[List[str]] = None,
        min_operation_start_date_time: Optional[datetime.datetime] = None,
        max_operation_start_date_time: Optional[datetime.datetime] = None,
        min_operation_end_date_time: Optional[datetime.datetime] = None,
        max_operation_end_date_time: Optional[datetime.datetime] = None,
        min_operation_modified_date_time: Optional[datetime.datetime] = None,
        max_operation_modified_date_time: Optional[datetime.datetime] = None,
        min_area: Optional[float] = None,
        max_area: Optional[float] = None,
        ids: Optional[List[str]] = None,
        names: Optional[List[str]] = None,
        property_filters: Optional[List[str]] = None,
        statuses: Optional[List[str]] = None,
        min_created_date_time: Optional[datetime.datetime] = None,
        max_created_date_time: Optional[datetime.datetime] = None,
        min_last_modified_date_time: Optional[datetime.datetime] = None,
        max_last_modified_date_time: Optional[datetime.datetime] = None,
        max_page_size: Optional[int] = 50,
        skip_token: Optional[str] = None,
        **kwargs
    ) -> "_models.TillageDataListResponse":
        """Returns a list of TillageData documents.

        :param min_tillage_depth: Minimum TillageDepth value(inclusive).
        :type min_tillage_depth: float
        :param max_tillage_depth: Maximum TillageDepth value (inclusive).
        :type max_tillage_depth: float
        :param min_tillage_pressure: Minimum TillagePressure value(inclusive).
        :type min_tillage_pressure: float
        :param max_tillage_pressure: Maximum TillagePressure value (inclusive).
        :type max_tillage_pressure: float
        :param sources: Source of the operation data.
        :type sources: list[str]
        :param associated_boundary_ids: Boundary ids associated with operation data.
        :type associated_boundary_ids: list[str]
        :param operation_boundary_ids: Operation boundary ids associated with operation data.
        :type operation_boundary_ids: list[str]
        :param min_operation_start_date_time: Minimum operation StartDateTime (inclusive).
        :type min_operation_start_date_time: ~datetime.datetime
        :param max_operation_start_date_time: Maximum operation StartDateTime (inclusive).
        :type max_operation_start_date_time: ~datetime.datetime
        :param min_operation_end_date_time: Minimum operation EndDateTime (inclusive).
        :type min_operation_end_date_time: ~datetime.datetime
        :param max_operation_end_date_time: Maximum operation EndDateTime (inclusive).
        :type max_operation_end_date_time: ~datetime.datetime
        :param min_operation_modified_date_time: Minimum OperationModifiedDateTime (inclusive).
        :type min_operation_modified_date_time: ~datetime.datetime
        :param max_operation_modified_date_time: Maximum OperationModifiedDateTime (inclusive).
        :type max_operation_modified_date_time: ~datetime.datetime
        :param min_area: Minimum Area value(inclusive).
        :type min_area: float
        :param max_area: Maximum Area value (inclusive).
        :type max_area: float
        :param ids: Ids of the resource.
        :type ids: list[str]
        :param names: Names of the resource.
        :type names: list[str]
        :param property_filters: Filters on key-value pairs within the Properties object.
         eg. "{testkey} eq {testvalue}".
        :type property_filters: list[str]
        :param statuses: Statuses of the resource.
        :type statuses: list[str]
        :param min_created_date_time: Minimum creation date of resource (inclusive).
        :type min_created_date_time: ~datetime.datetime
        :param max_created_date_time: Maximum creation date of resource (inclusive).
        :type max_created_date_time: ~datetime.datetime
        :param min_last_modified_date_time: Minimum last modified date of resource (inclusive).
        :type min_last_modified_date_time: ~datetime.datetime
        :param max_last_modified_date_time: Maximum last modified date of resource (inclusive).
        :type max_last_modified_date_time: ~datetime.datetime
        :param max_page_size: Maximum number of items needed (inclusive).
         Minimum = 10, Maximum = 1000, Default value = 50.
        :type max_page_size: int
        :param skip_token: Skip token for getting next set of results.
        :type skip_token: str
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: TillageDataListResponse, or the result of cls(response)
        :rtype: ~dpsclient.models.TillageDataListResponse
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType["_models.TillageDataListResponse"]
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}))
        api_version = "2020-12-31-preview"
        accept = "application/json"

        # Construct URL
        url = self.get_all_tillage_data_across_farmers.metadata['url']  # type: ignore

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]
        if min_tillage_depth is not None:
            query_parameters['minTillageDepth'] = self._serialize.query("min_tillage_depth", min_tillage_depth, 'float')
        if max_tillage_depth is not None:
            query_parameters['maxTillageDepth'] = self._serialize.query("max_tillage_depth", max_tillage_depth, 'float')
        if min_tillage_pressure is not None:
            query_parameters['minTillagePressure'] = self._serialize.query("min_tillage_pressure", min_tillage_pressure, 'float')
        if max_tillage_pressure is not None:
            query_parameters['maxTillagePressure'] = self._serialize.query("max_tillage_pressure", max_tillage_pressure, 'float')
        if sources is not None:
            query_parameters['sources'] = [self._serialize.query("sources", q, 'str') if q is not None else '' for q in sources]
        if associated_boundary_ids is not None:
            query_parameters['associatedBoundaryIds'] = [self._serialize.query("associated_boundary_ids", q, 'str') if q is not None else '' for q in associated_boundary_ids]
        if operation_boundary_ids is not None:
            query_parameters['operationBoundaryIds'] = [self._serialize.query("operation_boundary_ids", q, 'str') if q is not None else '' for q in operation_boundary_ids]
        if min_operation_start_date_time is not None:
            query_parameters['minOperationStartDateTime'] = self._serialize.query("min_operation_start_date_time", min_operation_start_date_time, 'iso-8601')
        if max_operation_start_date_time is not None:
            query_parameters['maxOperationStartDateTime'] = self._serialize.query("max_operation_start_date_time", max_operation_start_date_time, 'iso-8601')
        if min_operation_end_date_time is not None:
            query_parameters['minOperationEndDateTime'] = self._serialize.query("min_operation_end_date_time", min_operation_end_date_time, 'iso-8601')
        if max_operation_end_date_time is not None:
            query_parameters['maxOperationEndDateTime'] = self._serialize.query("max_operation_end_date_time", max_operation_end_date_time, 'iso-8601')
        if min_operation_modified_date_time is not None:
            query_parameters['minOperationModifiedDateTime'] = self._serialize.query("min_operation_modified_date_time", min_operation_modified_date_time, 'iso-8601')
        if max_operation_modified_date_time is not None:
            query_parameters['maxOperationModifiedDateTime'] = self._serialize.query("max_operation_modified_date_time", max_operation_modified_date_time, 'iso-8601')
        if min_area is not None:
            query_parameters['minArea'] = self._serialize.query("min_area", min_area, 'float')
        if max_area is not None:
            query_parameters['maxArea'] = self._serialize.query("max_area", max_area, 'float')
        if ids is not None:
            query_parameters['ids'] = [self._serialize.query("ids", q, 'str') if q is not None else '' for q in ids]
        if names is not None:
            query_parameters['names'] = [self._serialize.query("names", q, 'str') if q is not None else '' for q in names]
        if property_filters is not None:
            query_parameters['propertyFilters'] = [self._serialize.query("property_filters", q, 'str') if q is not None else '' for q in property_filters]
        if statuses is not None:
            query_parameters['statuses'] = [self._serialize.query("statuses", q, 'str') if q is not None else '' for q in statuses]
        if min_created_date_time is not None:
            query_parameters['minCreatedDateTime'] = self._serialize.query("min_created_date_time", min_created_date_time, 'iso-8601')
        if max_created_date_time is not None:
            query_parameters['maxCreatedDateTime'] = self._serialize.query("max_created_date_time", max_created_date_time, 'iso-8601')
        if min_last_modified_date_time is not None:
            query_parameters['minLastModifiedDateTime'] = self._serialize.query("min_last_modified_date_time", min_last_modified_date_time, 'iso-8601')
        if max_last_modified_date_time is not None:
            query_parameters['maxLastModifiedDateTime'] = self._serialize.query("max_last_modified_date_time", max_last_modified_date_time, 'iso-8601')
        if max_page_size is not None:
            query_parameters['$maxPageSize'] = self._serialize.query("max_page_size", max_page_size, 'int', maximum=1000, minimum=10)
        if skip_token is not None:
            query_parameters['$skipToken'] = self._serialize.query("skip_token", skip_token, 'str')
        query_parameters['api-version'] = self._serialize.query("api_version", api_version, 'str')

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]
        header_parameters['Accept'] = self._serialize.header("accept", accept, 'str')

        request = self._client.get(url, query_parameters, header_parameters)
        pipeline_response = await self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        deserialized = self._deserialize('TillageDataListResponse', pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized
    get_all_tillage_data_across_farmers.metadata = {'url': '/tillageData'}  # type: ignore

    async def get_weather_data(
        self,
        farmer_id: str,
        field_id: str,
        extension_id: str,
        weather_data_type: str,
        granularity: str,
        start_date_time: Optional[datetime.datetime] = None,
        end_date_time: Optional[datetime.datetime] = None,
        max_page_size: Optional[int] = 50,
        skip_token: Optional[str] = None,
        **kwargs
    ) -> "_models.WeatherDataListResponse":
        """Returns a list of weather data for the given query filter.

        :param farmer_id: Farmer Id.
        :type farmer_id: str
        :param field_id: Field Id.
        :type field_id: str
        :param extension_id: Id of the weather extension.
        :type extension_id: str
        :param weather_data_type: Type of weather data (forecast/historical).
        :type weather_data_type: str
        :param granularity: Granularity of weather data (daily/hourly).
        :type granularity: str
        :param start_date_time: Weather data start UTC date-time (inclusive), sample format: yyyy-Mm-
         ddTHH:mm:ssZ.
        :type start_date_time: ~datetime.datetime
        :param end_date_time: Weather data end UTC date-time (inclusive), sample format: yyyy-Mm-
         ddTHH:mm:ssZ.
        :type end_date_time: ~datetime.datetime
        :param max_page_size: Maximum number of items needed (inclusive).
         Minimum = 10, Maximum = 1000, Default value = 50.
        :type max_page_size: int
        :param skip_token: Skip token for getting next set of results.
        :type skip_token: str
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: WeatherDataListResponse, or the result of cls(response)
        :rtype: ~dpsclient.models.WeatherDataListResponse
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType["_models.WeatherDataListResponse"]
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}))
        api_version = "2020-12-31-preview"
        accept = "application/json"

        # Construct URL
        url = self.get_weather_data.metadata['url']  # type: ignore

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]
        query_parameters['farmerId'] = self._serialize.query("farmer_id", farmer_id, 'str')
        query_parameters['fieldId'] = self._serialize.query("field_id", field_id, 'str')
        query_parameters['extensionId'] = self._serialize.query("extension_id", extension_id, 'str')
        query_parameters['weatherDataType'] = self._serialize.query("weather_data_type", weather_data_type, 'str', max_length=50, min_length=0)
        query_parameters['granularity'] = self._serialize.query("granularity", granularity, 'str', max_length=50, min_length=0)
        if start_date_time is not None:
            query_parameters['startDateTime'] = self._serialize.query("start_date_time", start_date_time, 'iso-8601')
        if end_date_time is not None:
            query_parameters['endDateTime'] = self._serialize.query("end_date_time", end_date_time, 'iso-8601')
        if max_page_size is not None:
            query_parameters['$maxPageSize'] = self._serialize.query("max_page_size", max_page_size, 'int', maximum=1000, minimum=10)
        if skip_token is not None:
            query_parameters['$skipToken'] = self._serialize.query("skip_token", skip_token, 'str')
        query_parameters['api-version'] = self._serialize.query("api_version", api_version, 'str')

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]
        header_parameters['Accept'] = self._serialize.header("accept", accept, 'str')

        request = self._client.get(url, query_parameters, header_parameters)
        pipeline_response = await self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        deserialized = self._deserialize('WeatherDataListResponse', pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized
    get_weather_data.metadata = {'url': '/weather'}  # type: ignore
