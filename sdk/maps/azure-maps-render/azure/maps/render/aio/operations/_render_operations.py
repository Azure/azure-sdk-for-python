# coding=utf-8
# --------------------------------------------------------------------------
# Copyright (c) Microsoft Corporation. All rights reserved.
# Licensed under the MIT License. See License.txt in the project root for license information.
# Code generated by Microsoft (R) AutoRest Code Generator.
# Changes may cause incorrect behavior and will be lost if the code is regenerated.
# --------------------------------------------------------------------------
from typing import Any, Callable, Dict, Generic, IO, List, Optional, TypeVar, Union
import warnings

from azure.core.exceptions import ClientAuthenticationError, HttpResponseError, ResourceExistsError, ResourceNotFoundError, map_error
from azure.core.pipeline import PipelineResponse
from azure.core.pipeline.transport import AsyncHttpResponse, HttpRequest

from ... import models as _models

T = TypeVar('T')
ClsType = Optional[Callable[[PipelineResponse[HttpRequest, AsyncHttpResponse], T, Dict[str, Any]], Any]]

class RenderOperations:
    """RenderOperations async operations.

    You should not instantiate this class directly. Instead, you should create a Client instance that
    instantiates it for you and attaches it as an attribute.

    :ivar models: Alias to model classes used in this operation group.
    :type models: ~azure.maps.render.models
    :param client: Client for service requests.
    :param config: Configuration of service client.
    :param serializer: An object model serializer.
    :param deserializer: An object model deserializer.
    """

    models = _models

    def __init__(self, client, config, serializer, deserializer) -> None:
        self._client = client
        self._serialize = serializer
        self._deserialize = deserializer
        self._config = config

    async def get_map_static_image(
        self,
        format: Union[str, "_models.RasterTileFormat"],
        layer: Optional[Union[str, "_models.StaticMapLayer"]] = None,
        style: Optional[Union[str, "_models.MapImageStyle"]] = None,
        zoom: Optional[int] = None,
        center: Optional[str] = None,
        bbox: Optional[str] = None,
        height: Optional[int] = None,
        width: Optional[int] = None,
        language: Optional[str] = None,
        view: Optional[str] = None,
        pins: Optional[List[str]] = None,
        path: Optional[List[str]] = None,
        **kwargs: Any
    ) -> IO:
        """**Applies to**\ : S0 and S1 pricing tiers.

        The static image service renders a user-defined, rectangular image containing a map section
        using a zoom level from 0 to 20. The static image service renders a user-defined, rectangular
        image containing a map section using a zoom level from 0 to 20. The supported resolution range
        for the map image is from 1x1 to 8192x8192. If you are deciding when to use the static image
        service over the map tile service, you may want to consider how you would like to interact with
        the rendered map. If the map contents will be relatively unchanging, a static map is a good
        choice. If you want to support a lot of zooming, panning and changing of the map content, the
        map tile service would be a better choice.

        Service also provides Image Composition functionality to get a static image back with
        additional data like; pushpins and geometry overlays with following S0 and S1 capabilities.

        In S0 you can:


        * Render up to 5 pushpins specified in the request
        * Provide one custom image for the pins referenced in the request
        * Add labels to the pushpins

        In S1 you can:


        * Render pushpins through `Azure Maps Data Service <https://aka.ms/AzureMapsMapDataService>`_
        * Specify multiple pushpin styles
        * Provide custom pushpin images stored in `Azure Maps Data Service
        <https://aka.ms/AzureMapsMapDataService>`_
        * Render circle, polyline and polygon geometry types.
        * Render of supported GeoJSON geometry types uploaded through `Azure Maps Data Service
        <https://aka.ms/AzureMapsMapDataService>`_

        Please see `How-to-Guide <https://aka.ms/AzureMapsHowToGuideImageCompositor>`_ for detailed
        examples.

        *Note* : Either **center** or **bbox** parameter must be supplied to the
        API.
        :code:`<br>`:code:`<br>`
        The supported Lat and Lon ranges when using the **bbox** parameter, are as follows:
        :code:`<br>`:code:`<br>`

        .. list-table::
           :header-rows: 1

           * - Zoom Level
             - Max Lon Range
             - Max Lat Range
           * - 0
             - 360.0
             - 170.0
           * - 1
             - 360.0
             - 170.0
           * - 2
             - 360.0
             - 170.0
           * - 3
             - 360.0
             - 170.0
           * - 4
             - 360.0
             - 170.0
           * - 5
             - 180.0
             - 85.0
           * - 6
             - 90.0
             - 42.5
           * - 7
             - 45.0
             - 21.25
           * - 8
             - 22.5
             - 10.625
           * - 9
             - 11.25
             - 5.3125
           * - 10
             - 5.625
             - 2.62625
           * - 11
             - 2.8125
             - 1.328125
           * - 12
             - 1.40625
             - 0.6640625
           * - 13
             - 0.703125
             - 0.33203125
           * - 14
             - 0.3515625
             - 0.166015625
           * - 15
             - 0.17578125
             - 0.0830078125
           * - 16
             - 0.087890625
             - 0.0415039063
           * - 17
             - 0.0439453125
             - 0.0207519531
           * - 18
             - 0.0219726563
             - 0.0103759766
           * - 19
             - 0.0109863281
             - 0.0051879883
           * - 20
             - 0.0054931641
             - 0.0025939941.

        :param format: Desired format of the response. Possible value: png.
        :type format: str or ~azure.maps.render.models.RasterTileFormat
        :param layer: Map layer requested. If layer is set to labels or hybrid, the format should be
         png.
        :type layer: str or ~azure.maps.render.models.StaticMapLayer
        :param style: Map style to be returned. Possible values are main and dark.
        :type style: str or ~azure.maps.render.models.MapImageStyle
        :param zoom: Desired zoom level of the map. Zoom value must be in the range: 0-20 (inclusive).
         Default value is 12.:code:`<br>`:code:`<br>`Please see `Zoom Levels and Tile Grid
         <https://docs.microsoft.com/en-us/azure/location-based-services/zoom-levels-and-tile-grid>`_
         for details.
        :type zoom: int
        :param center: Coordinates of the center point. Format: 'lon,lat'. Projection used


         * EPSG:3857. Longitude range: -180 to 180. Latitude range: -85 to 85.

         Note: Either center or bbox are required parameters. They are
         mutually exclusive.
        :type center: str
        :param bbox: Bounding box. Projection used - EPSG:3857. Format : 'minLon, minLat,
         maxLon, maxLat'.

         Note: Either bbox or center are required
         parameters. They are mutually exclusive. It shouldn’t be used with
         height or width.

         The maximum allowed ranges for Lat and Lon are defined for each zoom level
         in the table at the top of this page.
        :type bbox: str
        :param height: Height of the resulting image in pixels. Range is 1 to 8192. Default
         is 512. It shouldn’t be used with bbox.
        :type height: int
        :param width: Width of the resulting image in pixels. Range is 1 to 8192. Default is 512. It
         shouldn’t be used with bbox.
        :type width: int
        :param language: Language in which search results should be returned. Should be one of
         supported IETF language tags, case insensitive. When data in specified language is not
         available for a specific field, default language is used.

         Please refer to `Supported Languages
         <https://docs.microsoft.com/en-us/azure/azure-maps/supported-languages>`_ for details.
        :type language: str
        :param view: The View parameter specifies which set of geopolitically disputed content is
         returned via Azure Maps services, including  borders and labels displayed on the map. The View
         parameter (also referred to as “user region parameter”) will show the  correct maps for that
         country/region. By default, the View parameter is set to “Unified” even if you haven’t defined
         it in  the request. It is your responsibility to determine the location of your users, and then
         set the View parameter correctly  for that location. Alternatively, you have the option to set
         ‘View=Auto’, which will return the map data based on the IP  address of the request. The View
         parameter in Azure Maps must be used in compliance with applicable laws, including those
         regarding mapping, of the country where maps, images and other data and third party content
         that you are authorized to  access via Azure Maps is made available. Example: view=IN.

         Please refer to `Supported Views <https://aka.ms/AzureMapsLocalizationViews>`_ for details and
         to see the available Views.
        :type view: str
        :param pins: Pushpin style and instances. Use this parameter to optionally add pushpins to the
         image.
         The pushpin style describes the appearance of the pushpins, and the instances specify
         the coordinates of the pushpins and optional labels for each pin. (Be sure to properly
         URL-encode values of this
         parameter since it will contain reserved characters such as pipes and punctuation.)

         The Azure Maps account S0 SKU only supports a single instance of the pins parameter. Other
         SKUs
         allow multiple instances of the pins parameter to specify multiple pin styles.

         To render a pushpin at latitude 45°N and longitude 122°W using the default built-in pushpin
         style, add the
         querystring parameter

         ``pins=default||-122 45``

         Note that the longitude comes before the latitude.
         After URL encoding this will look like

         ``pins=default%7C%7C-122+45``

         All of the examples here show the pins
         parameter without URL encoding, for clarity.

         To render a pin at multiple locations, separate each location with a pipe character. For
         example, use

         ``pins=default||-122 45|-119.5 43.2|-121.67 47.12``

         The S0 Azure Maps account SKU only allows five pushpins. Other account SKUs do not have this
         limitation.

         Style Modifiers
         ^^^^^^^^^^^^^^^

         You can modify the appearance of the pins by adding style modifiers. These are added after the
         style but before
         the locations and labels. Style modifiers each have a two-letter name. These abbreviated names
         are used to help
         reduce the length of the URL.

         To change the color of the pushpin, use the 'co' style modifier and specify the color using
         the HTML/CSS RGB color
         format which is a six-digit hexadecimal number (the three-digit form is not supported). For
         example, to use
         a deep pink color which you would specify as #FF1493 in CSS, use

         ``pins=default|coFF1493||-122 45``

         Pushpin Labels
         ^^^^^^^^^^^^^^

         To add a label to the pins, put the label in single quotes just before the coordinates. For
         example, to label
         three pins with the values '1', '2', and '3', use

         ``pins=default||'1'-122 45|'2'-119.5 43.2|'3'-121.67 47.12``

         There is a built in pushpin style called 'none' that does not display a pushpin image. You can
         use this if
         you want to display labels without any pin image. For example,

         ``pins=none||'A'-122 45|'B'-119.5 43.2``

         To change the color of the pushpin labels, use the 'lc' label color style modifier. For
         example, to use pink
         pushpins with black labels, use

         ``pins=default|coFF1493|lc000000||-122 45``

         To change the size of the labels, use the 'ls' label size style modifier. The label size
         represents the approximate
         height of the label text in pixels. For example, to increase the label size to 12, use

         ``pins=default|ls12||'A'-122 45|'B'-119 43``

         The labels are centered at the pushpin 'label anchor.' The anchor location is predefined for
         built-in pushpins and
         is at the top center of custom pushpins (see below). To override the label anchor, using the
         'la' style modifier
         and provide X and Y pixel coordinates for the anchor. These coordinates are relative to the
         top left corner of the
         pushpin image. Positive X values move the anchor to the right, and positive Y values move the
         anchor down. For example,
         to position the label anchor 10 pixels right and 4 pixels above the top left corner of the
         pushpin image,
         use

         ``pins=default|la10 -4||'A'-122 45|'B'-119 43``

         Custom Pushpins
         ^^^^^^^^^^^^^^^

         To use a custom pushpin image, use the word 'custom' as the pin style name, and then specify a
         URL after the
         location and label information. Use two pipe characters to indicate that you're done
         specifying locations and are
         starting the URL. For example,

         ``pins=custom||-122 45||http://contoso.com/pushpins/red.png``

         After URL encoding, this would look like

         ``pins=custom%7C%7C-122+45%7C%7Chttp%3A%2F%2Fcontoso.com%2Fpushpins%2Fred.png``

         By default, custom pushpin images are drawn centered at the pin coordinates. This usually
         isn't ideal as it obscures
         the location that you're trying to highlight. To override the anchor location of the pin
         image, use the 'an'
         style modifier. This uses the same format as the 'la' label anchor style modifier. For
         example, if your custom
         pin image has the tip of the pin at the top left corner of the image, you can set the anchor
         to that spot by
         using

         ``pins=custom|an0 0||-122 45||http://contoso.com/pushpins/red.png``

         Note: If you use the 'co' color modifier with a custom pushpin image, the specified color will
         replace the RGB
         channels of the pixels in the image but will leave the alpha (opacity) channel unchanged. This
         would usually
         only be done with a solid-color custom image.

         Getting Pushpins from Azure Maps Data Storage
         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

         For all Azure Maps account SKUs other than S0,
         the pushpin image and location information can be obtained from Azure Maps Data Storage. After
         uploading a pushpin image
         or a GeoJSON document containing pin locations, the Data Storage service returns a Unique Data
         ID (UDID) that you can use
         to reference the data in the pins parameter.

         To use a custom pushpin image from Azure Maps Data Storage, specify the UDID prefixed by
         'udid-' as the name of the
         pushpin style. For example,

         ``pins=udid-fe22c504-3a81-4fcd-adc6-a3507ce866c1||-122 45``

         To use the point geometry from an uploaded GeoJSON document as the pin locations, specify the
         UDID in the locations
         section of the pins parameter. For example,

         ``pins=default||udid-29dc105a-dee7-409f-a3f9-22b066ae4713``

         Note that
         only point and multipoint geometry, points and multipoints from geometry collections, and
         point geometry from features
         will be used. Linestring and polygon geometry will be ignored. If the point comes from a
         feature and the feature
         has a string property called "label", the value of that property will be used as the label for
         the pin.

         You can mix pin locations from Data Storage and pin locations specified in the pins parameter.
         Any of the pipe-delimited
         pin locations can be a longitude and latitude or a UDID. For example,

         ``pins=default||-122 45|udid-29dc105a-dee7-409f-a3f9-22b066ae4713|-119 43``

         Scale, Rotation, and Opacity
         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^

         You can make pushpins and their labels larger or smaller by using the 'sc' scale style
         modifier. This is a
         value greater than zero. A value of 1 is the standard scale. Values larger than 1 will make
         the pins larger, and
         values smaller than 1 will make them smaller. For example, to draw the pushpins 50% larger
         than normal, use

         ``pins=default|sc1.5||-122 45``

         You can rotate pushpins and their labels by using the 'ro' rotation style modifier. This is a
         number of degrees
         of clockwise rotation. Use a negative number to rotate counter-clockwise. For example, to
         rotate the pushpins
         90 degrees clockwise and double their size, use

         ``pins=default|ro90|sc2||-122 45``

         You can make pushpins and their labels partially transparent by specifying the 'al' alpha
         style modifier.
         This is a number between 0 and 1 indicating the opacity of the pushpins. Zero makes them
         completely transparent
         (and not visible) and 1 makes them completely opaque (which is the default). For example, to
         make pushpins
         and their labels only 67% opaque, use

         ``pins=default|al.67||-122 45``

         Style Modifier Summary
         ^^^^^^^^^^^^^^^^^^^^^^

         .. list-table::
            :header-rows: 1

            * - Modifier
              - Description
              - Range
            * - al
              - Alpha (opacity)
              - 0 to 1
            * - an
              - Pin anchor
              - *
            * - co
              - Pin color
              - 000000 to FFFFFF
            * - la
              - Label anchor
              - *
            * - lc
              - Label color
              - 000000 to FFFFFF
            * - ls
              - Label size
              - Greater than 0
            * - ro
              - Rotation
              - -360 to 360
            * - sc
              - Scale
              - Greater than 0



         * X and Y coordinates can be anywhere within pin image or a margin around it.
           The margin size is the minimum of the pin width and height.
        :type pins: list[str]
        :param path: Path style and locations. Use this parameter to optionally add lines, polygons or
         circles to the image.
         The path style describes the appearance of the line and fill. (Be sure to properly URL-encode
         values of this
         parameter since it will contain reserved characters such as pipes and punctuation.)

         Path parameter is supported in Azure Maps account SKU starting with S1. Multiple instances of
         the path parameter
         allow to specify multiple geometries with their styles. Number of parameters per request is
         limited to 10 and
         number of locations is limited to 100 per path.

         To render a circle with radius 100 meters and center point at latitude 45°N and longitude
         122°W using the default style, add the
         querystring parameter

         ``path=ra100||-122 45``

         Note that the longitude comes before the latitude.
         After URL encoding this will look like

         ``path=ra100%7C%7C-122+45``

         All of the examples here show the path parameter without URL encoding, for clarity.

         To render a line, separate each location with a pipe character. For example, use

         ``path=||-122 45|-119.5 43.2|-121.67 47.12``

         To render a polygon, last location must be equal to the start location. For example, use

         ``path=||-122 45|-119.5 43.2|-121.67 47.12|-122 45``

         Longitude and latitude values for locations of lines and polygons can be in the range from
         -360 to 360 to allow for rendering of geometries crossing the anti-meridian.

         Style Modifiers
         ^^^^^^^^^^^^^^^

         You can modify the appearance of the path by adding style modifiers. These are added before
         the locations.
         Style modifiers each have a two-letter name. These abbreviated names are used to help reduce
         the length
         of the URL.

         To change the color of the outline, use the 'lc' style modifier and specify the color using
         the HTML/CSS RGB color
         format which is a six-digit hexadecimal number (the three-digit form is not supported). For
         example, to use
         a deep pink color which you would specify as #FF1493 in CSS, use

         ``path=lcFF1493||-122 45|-119.5 43.2``

         Multiple style modifiers may be combined together to create a more complex visual style.

         ``lc0000FF|lw3|la0.60|fa0.50||-122.2 47.6|-122.2 47.7|-122.3 47.7|-122.3 47.6|-122.2 47.6``

         Getting Path locations from Azure Maps Data Storage
         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

         For all Azure Maps account SKUs other than S0, the path location information can be obtained
         from Azure Maps Data Storage.
         After uploading a GeoJSON document containing path locations, the Data Storage service returns
         a Unique Data ID (UDID) that you can use
         to reference the data in the path parameter.

         To use the point geometry from an uploaded GeoJSON document as the path locations, specify the
         UDID in the locations
         section of the path parameter. For example,

         ``path=||udid-29dc105a-dee7-409f-a3f9-22b066ae4713``

         Note the it is not allowed to mix path locations from Data Storage with locations specified in
         the path parameter.

         Style Modifier Summary
         ^^^^^^^^^^^^^^^^^^^^^^

         .. list-table::
            :header-rows: 1

            * - Modifier
              - Description
              - Range
            * - lc
              - Line color
              - 000000 to FFFFFF
            * - fc
              - Fill color
              - 000000 to FFFFFF
            * - la
              - Line alpha (opacity)
              - 0 to 1
            * - fa
              - Fill alpha (opacity)
              - 0 to 1
            * - lw
              - Line width
              - Greater than 0
            * - ra
              - Circle radius (meters)
              - Greater than 0.
        :type path: list[str]
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: IO, or the result of cls(response)
        :rtype: IO
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType[IO]
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}))
        api_version = "1.0"
        accept = "application/json, image/jpeg, image/png, image/pbf, application/vnd.mapbox-vector-tile"

        # Construct URL
        url = self.get_map_static_image.metadata['url']  # type: ignore
        path_format_arguments = {
            'geography': self._serialize.url("self._config.geography", self._config.geography, 'str'),
            'format': self._serialize.url("format", format, 'str'),
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]
        query_parameters['api-version'] = self._serialize.query("api_version", api_version, 'str')
        if layer is not None:
            query_parameters['layer'] = self._serialize.query("layer", layer, 'str')
        if style is not None:
            query_parameters['style'] = self._serialize.query("style", style, 'str')
        if zoom is not None:
            query_parameters['zoom'] = self._serialize.query("zoom", zoom, 'int', maximum=20, minimum=0)
        if center is not None:
            query_parameters['center'] = self._serialize.query("center", center, 'str')
        if bbox is not None:
            query_parameters['bbox'] = self._serialize.query("bbox", bbox, 'str')
        if height is not None:
            query_parameters['height'] = self._serialize.query("height", height, 'int', maximum=8192, minimum=1)
        if width is not None:
            query_parameters['width'] = self._serialize.query("width", width, 'int', maximum=8192, minimum=1)
        if language is not None:
            query_parameters['language'] = self._serialize.query("language", language, 'str')
        if view is not None:
            query_parameters['view'] = self._serialize.query("view", view, 'str')
        if pins is not None:
            query_parameters['pins'] = [self._serialize.query("pins", q, 'str') if q is not None else '' for q in pins]
        if path is not None:
            query_parameters['path'] = [self._serialize.query("path", q, 'str') if q is not None else '' for q in path]

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]
        if self._config.x_ms_client_id is not None:
            header_parameters['x-ms-client-id'] = self._serialize.header("self._config.x_ms_client_id", self._config.x_ms_client_id, 'str')
        header_parameters['Accept'] = self._serialize.header("accept", accept, 'str')

        request = self._client.get(url, query_parameters, header_parameters)
        pipeline_response = await self._client._pipeline.run(request, stream=True, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize.failsafe_deserialize(_models.ErrorResponse, response)
            raise HttpResponseError(response=response, model=error)

        response_headers = {}
        response_headers['Content-Type']=self._deserialize('str', response.headers.get('Content-Type'))
        deserialized = response.stream_download(self._client._pipeline)

        if cls:
            return cls(pipeline_response, deserialized, response_headers)

        return deserialized
    get_map_static_image.metadata = {'url': '/map/static/{format}'}  # type: ignore

    async def get_map_tile(
        self,
        format: Union[str, "_models.TileFormat"],
        layer: Union[str, "_models.MapTileLayer"],
        style: Union[str, "_models.MapTileStyle"],
        zoom: int,
        x_tile_index: int,
        y_tile_index: int,
        tile_size: Optional[Union[str, "_models.MapTileSize"]] = None,
        language: Optional[str] = None,
        view: Optional[str] = None,
        **kwargs: Any
    ) -> IO:
        """**Applies to**\ : S0 and S1 pricing tiers.

        Fetches map tiles in vector or raster format typically to be integrated into a new map control
        or SDK. By default, Azure uses vector map tiles for its web map control (see `Zoom Levels and
        Tile Grid
        <https://docs.microsoft.com/en-us/azure/location-based-services/zoom-levels-and-tile-grid>`_\ )

        **Note**\ : Weather tiles are only available via `Get Map Tile V2 API
        <https://aka.ms/AzureMapsWeatherTiles>`_. We recommend to start to use the new `Get Map Tile V2
        API <https://aka.ms/GetMapTileV2>`_.

        :param format: Desired format of the response. Possible values are png & pbf.
        :type format: str or ~azure.maps.render.models.TileFormat
        :param layer: Map layer requested. Possible values are basic, hybrid, labels and terra.
        :type layer: str or ~azure.maps.render.models.MapTileLayer
        :param style: Map style to be returned. Possible values are main, dark, and shaded_relief.
        :type style: str or ~azure.maps.render.models.MapTileStyle
        :param zoom: Zoom level for the desired tile. For *raster* tiles, value must be in the range:
         0-18 (inclusive). Terra raster tiles, values must be in the range 0-6 (inclusive). For *vector*
         tiles, value must be in the range: 0-22 (inclusive).
         Please see `Zoom Levels and Tile Grid
         <https://docs.microsoft.com/en-us/azure/location-based-services/zoom-levels-and-tile-grid>`_
         for details.
        :type zoom: int
        :param x_tile_index: X coordinate of the tile on zoom grid. Value must be in the range [0,
         2:code:`<sup>`zoom`</sup>` -1].

         Please see `Zoom Levels and Tile Grid
         <https://docs.microsoft.com/en-us/azure/location-based-services/zoom-levels-and-tile-grid>`_
         for details.
        :type x_tile_index: int
        :param y_tile_index: Y coordinate of the tile on zoom grid. Value must be in the range [0,
         2:code:`<sup>`zoom`</sup>` -1].

         Please see `Zoom Levels and Tile Grid
         <https://docs.microsoft.com/en-us/azure/location-based-services/zoom-levels-and-tile-grid>`_
         for details.
        :type y_tile_index: int
        :param tile_size: The size of the returned map tile in pixels.
        :type tile_size: str or ~azure.maps.render.models.MapTileSize
        :param language: Language in which search results should be returned. Should be one of
         supported IETF language tags, case insensitive. When data in specified language is not
         available for a specific field, default language is used.

         Please refer to `Supported Languages
         <https://docs.microsoft.com/en-us/azure/azure-maps/supported-languages>`_ for details.
        :type language: str
        :param view: The View parameter specifies which set of geopolitically disputed content is
         returned via Azure Maps services, including  borders and labels displayed on the map. The View
         parameter (also referred to as “user region parameter”) will show the  correct maps for that
         country/region. By default, the View parameter is set to “Unified” even if you haven’t defined
         it in  the request. It is your responsibility to determine the location of your users, and then
         set the View parameter correctly  for that location. Alternatively, you have the option to set
         ‘View=Auto’, which will return the map data based on the IP  address of the request. The View
         parameter in Azure Maps must be used in compliance with applicable laws, including those
         regarding mapping, of the country where maps, images and other data and third party content
         that you are authorized to  access via Azure Maps is made available. Example: view=IN.

         Please refer to `Supported Views <https://aka.ms/AzureMapsLocalizationViews>`_ for details and
         to see the available Views.
        :type view: str
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: IO, or the result of cls(response)
        :rtype: IO
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType[IO]
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}))
        api_version = "1.0"
        accept = "application/json, image/jpeg, image/png, image/pbf, application/vnd.mapbox-vector-tile"

        # Construct URL
        url = self.get_map_tile.metadata['url']  # type: ignore
        path_format_arguments = {
            'geography': self._serialize.url("self._config.geography", self._config.geography, 'str'),
            'format': self._serialize.url("format", format, 'str'),
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]
        query_parameters['api-version'] = self._serialize.query("api_version", api_version, 'str')
        query_parameters['layer'] = self._serialize.query("layer", layer, 'str')
        query_parameters['style'] = self._serialize.query("style", style, 'str')
        query_parameters['zoom'] = self._serialize.query("zoom", zoom, 'int')
        query_parameters['x'] = self._serialize.query("x_tile_index", x_tile_index, 'int')
        query_parameters['y'] = self._serialize.query("y_tile_index", y_tile_index, 'int')
        if tile_size is not None:
            query_parameters['tileSize'] = self._serialize.query("tile_size", tile_size, 'str')
        if language is not None:
            query_parameters['language'] = self._serialize.query("language", language, 'str')
        if view is not None:
            query_parameters['view'] = self._serialize.query("view", view, 'str')

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]
        if self._config.x_ms_client_id is not None:
            header_parameters['x-ms-client-id'] = self._serialize.header("self._config.x_ms_client_id", self._config.x_ms_client_id, 'str')
        header_parameters['Accept'] = self._serialize.header("accept", accept, 'str')

        request = self._client.get(url, query_parameters, header_parameters)
        pipeline_response = await self._client._pipeline.run(request, stream=True, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize.failsafe_deserialize(_models.ErrorResponse, response)
            raise HttpResponseError(response=response, model=error)

        response_headers = {}
        response_headers['Content-Type']=self._deserialize('str', response.headers.get('Content-Type'))
        deserialized = response.stream_download(self._client._pipeline)

        if cls:
            return cls(pipeline_response, deserialized, response_headers)

        return deserialized
    get_map_tile.metadata = {'url': '/map/tile/{format}'}  # type: ignore

    async def get_map_state_tile_preview(
        self,
        zoom: int,
        x_tile_index: int,
        y_tile_index: int,
        stateset_id: str,
        **kwargs: Any
    ) -> IO:
        """**Applies to**\ : S0 and S1 pricing tiers.

        Fetches state tiles in vector format typically to be integrated into indoor maps module of map
        control or SDK. The map control will call this API after user turns on dynamic styling (see
        `Zoom Levels and Tile Grid
        <https://docs.microsoft.com/en-us/azure/location-based-services/zoom-levels-and-tile-grid>`_\
        ).

        :param zoom: Zoom level for the desired tile. Zoom value must be in the range: 0-20
         (inclusive).

         Please see `Zoom Levels and Tile Grid
         <https://docs.microsoft.com/en-us/azure/location-based-services/zoom-levels-and-tile-grid>`_
         for details.
        :type zoom: int
        :param x_tile_index: X coordinate of the tile on zoom grid. Value must be in the range [0,
         2:code:`<sup>`zoom`</sup>` -1].

         Please see `Zoom Levels and Tile Grid
         <https://docs.microsoft.com/en-us/azure/location-based-services/zoom-levels-and-tile-grid>`_
         for details.
        :type x_tile_index: int
        :param y_tile_index: Y coordinate of the tile on zoom grid. Value must be in the range [0,
         2:code:`<sup>`zoom`</sup>` -1].

         Please see `Zoom Levels and Tile Grid
         <https://docs.microsoft.com/en-us/azure/location-based-services/zoom-levels-and-tile-grid>`_
         for details.
        :type y_tile_index: int
        :param stateset_id: The stateset id.
        :type stateset_id: str
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: IO, or the result of cls(response)
        :rtype: IO
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType[IO]
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}))
        api_version = "1.0"
        accept = "application/vnd.mapbox-vector-tile, application/json"

        # Construct URL
        url = self.get_map_state_tile_preview.metadata['url']  # type: ignore
        path_format_arguments = {
            'geography': self._serialize.url("self._config.geography", self._config.geography, 'str'),
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]
        query_parameters['api-version'] = self._serialize.query("api_version", api_version, 'str')
        query_parameters['zoom'] = self._serialize.query("zoom", zoom, 'int')
        query_parameters['x'] = self._serialize.query("x_tile_index", x_tile_index, 'int')
        query_parameters['y'] = self._serialize.query("y_tile_index", y_tile_index, 'int')
        query_parameters['statesetId'] = self._serialize.query("stateset_id", stateset_id, 'str')

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]
        if self._config.x_ms_client_id is not None:
            header_parameters['x-ms-client-id'] = self._serialize.header("self._config.x_ms_client_id", self._config.x_ms_client_id, 'str')
        header_parameters['Accept'] = self._serialize.header("accept", accept, 'str')

        request = self._client.get(url, query_parameters, header_parameters)
        pipeline_response = await self._client._pipeline.run(request, stream=True, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize.failsafe_deserialize(_models.ErrorResponse, response)
            raise HttpResponseError(response=response, model=error)

        response_headers = {}
        response_headers['Content-Type']=self._deserialize('str', response.headers.get('Content-Type'))
        deserialized = response.stream_download(self._client._pipeline)

        if cls:
            return cls(pipeline_response, deserialized, response_headers)

        return deserialized
    get_map_state_tile_preview.metadata = {'url': '/map/statetile'}  # type: ignore

    async def get_copyright_caption(
        self,
        format: Union[str, "_models.TextFormat"],
        **kwargs: Any
    ) -> "_models.GetCopyrightCaptionResult":
        """**Applies to**\ : S0 and S1 pricing tiers.

        Copyrights API is designed to serve copyright information for Render Tile
        service. In addition to basic copyright for the whole map, API is serving
        specific groups of copyrights for some countries.

        As an alternative to copyrights for map request, one can receive captions
        for displaying the map provider information on the map.

        :param format: Desired format of the response. Value can be either *json* or *xml*.
        :type format: str or ~azure.maps.render.models.TextFormat
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: GetCopyrightCaptionResult, or the result of cls(response)
        :rtype: ~azure.maps.render.models.GetCopyrightCaptionResult
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType["_models.GetCopyrightCaptionResult"]
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}))
        api_version = "1.0"
        accept = "application/json"

        # Construct URL
        url = self.get_copyright_caption.metadata['url']  # type: ignore
        path_format_arguments = {
            'geography': self._serialize.url("self._config.geography", self._config.geography, 'str'),
            'format': self._serialize.url("format", format, 'str'),
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]
        query_parameters['api-version'] = self._serialize.query("api_version", api_version, 'str')

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]
        if self._config.x_ms_client_id is not None:
            header_parameters['x-ms-client-id'] = self._serialize.header("self._config.x_ms_client_id", self._config.x_ms_client_id, 'str')
        header_parameters['Accept'] = self._serialize.header("accept", accept, 'str')

        request = self._client.get(url, query_parameters, header_parameters)
        pipeline_response = await self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize.failsafe_deserialize(_models.ErrorResponse, response)
            raise HttpResponseError(response=response, model=error)

        deserialized = self._deserialize('GetCopyrightCaptionResult', pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized
    get_copyright_caption.metadata = {'url': '/map/copyright/caption/{format}'}  # type: ignore

    async def get_map_imagery_tile(
        self,
        format: Union[str, "_models.RasterTileFormat"],
        style: Union[str, "_models.MapImageryStyle"],
        zoom: int,
        x_tile_index: int,
        y_tile_index: int,
        **kwargs: Any
    ) -> IO:
        """**Applies to:** S1 pricing tier.

        This service returns a map image tile with size 256x256, given the x and y coordinates and zoom
        level. Zoom level ranges from 1 to 19. The current available style value is 'satellite' which
        provides satellite
        imagery alone.

        **Note**\ : We recommend to start to use the new `Get Map Tile V2 API
        <https://aka.ms/GetMapTileV2>`_.

        :param format: Desired format of the response. Possible value: png.
        :type format: str or ~azure.maps.render.models.RasterTileFormat
        :param style: Map style to be returned. **Possible values:** satellite.
        :type style: str or ~azure.maps.render.models.MapImageryStyle
        :param zoom: Zoom level for the desired tile. Zoom value must be in the range: 1-19
         (inclusive).
         Please see `Zoom Levels and Tile Grid
         <https://docs.microsoft.com/en-us/azure/location-based-services/zoom-levels-and-tile-grid>`_
         for details.
        :type zoom: int
        :param x_tile_index: X coordinate of the tile on zoom grid. Value must be in the range [0,
         2:code:`<sup>`zoom`</sup>` -1].

         Please see `Zoom Levels and Tile Grid
         <https://docs.microsoft.com/en-us/azure/location-based-services/zoom-levels-and-tile-grid>`_
         for details.
        :type x_tile_index: int
        :param y_tile_index: Y coordinate of the tile on zoom grid. Value must be in the range [0,
         2:code:`<sup>`zoom`</sup>` -1].

         Please see `Zoom Levels and Tile Grid
         <https://docs.microsoft.com/en-us/azure/location-based-services/zoom-levels-and-tile-grid>`_
         for details.
        :type y_tile_index: int
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: IO, or the result of cls(response)
        :rtype: IO
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType[IO]
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}))
        api_version = "1.0"
        accept = "application/json, image/jpeg, image/png"

        # Construct URL
        url = self.get_map_imagery_tile.metadata['url']  # type: ignore
        path_format_arguments = {
            'geography': self._serialize.url("self._config.geography", self._config.geography, 'str'),
            'format': self._serialize.url("format", format, 'str'),
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]
        query_parameters['api-version'] = self._serialize.query("api_version", api_version, 'str')
        query_parameters['style'] = self._serialize.query("style", style, 'str')
        query_parameters['zoom'] = self._serialize.query("zoom", zoom, 'int')
        query_parameters['x'] = self._serialize.query("x_tile_index", x_tile_index, 'int')
        query_parameters['y'] = self._serialize.query("y_tile_index", y_tile_index, 'int')

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]
        if self._config.x_ms_client_id is not None:
            header_parameters['x-ms-client-id'] = self._serialize.header("self._config.x_ms_client_id", self._config.x_ms_client_id, 'str')
        header_parameters['Accept'] = self._serialize.header("accept", accept, 'str')

        request = self._client.get(url, query_parameters, header_parameters)
        pipeline_response = await self._client._pipeline.run(request, stream=True, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize.failsafe_deserialize(_models.ErrorResponse, response)
            raise HttpResponseError(response=response, model=error)

        response_headers = {}
        response_headers['Content-Type']=self._deserialize('str', response.headers.get('Content-Type'))
        deserialized = response.stream_download(self._client._pipeline)

        if cls:
            return cls(pipeline_response, deserialized, response_headers)

        return deserialized
    get_map_imagery_tile.metadata = {'url': '/map/imagery/{format}'}  # type: ignore

    async def get_copyright_from_bounding_box(
        self,
        format: Union[str, "_models.TextFormat"],
        mincoordinates: str,
        maxcoordinates: str,
        text: Optional[Union[str, "_models.IncludeText"]] = None,
        **kwargs: Any
    ) -> "_models.GetCopyrightFromBoundingBoxResult":
        """**Applies to**\ : S0 and S1 pricing tiers.

        Returns copyright information for a given bounding box. Bounding-box requests should specify
        the minimum and maximum longitude and latitude (EPSG-3857) coordinates.

        :param format: Desired format of the response. Value can be either *json* or *xml*.
        :type format: str or ~azure.maps.render.models.TextFormat
        :param mincoordinates: Minimum coordinates of bounding box in latitude longitude coordinate
         system. E.g. 52.41064,4.84228.
        :type mincoordinates: str
        :param maxcoordinates: Maximum coordinates of bounding box in latitude longitude coordinate
         system. E.g. 52.41064,4.84228.
        :type maxcoordinates: str
        :param text: Yes/no value to exclude textual data from response. Only images and country names
         will be in response.
        :type text: str or ~azure.maps.render.models.IncludeText
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: GetCopyrightFromBoundingBoxResult, or the result of cls(response)
        :rtype: ~azure.maps.render.models.GetCopyrightFromBoundingBoxResult
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType["_models.GetCopyrightFromBoundingBoxResult"]
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}))
        api_version = "1.0"
        accept = "application/json"

        # Construct URL
        url = self.get_copyright_from_bounding_box.metadata['url']  # type: ignore
        path_format_arguments = {
            'geography': self._serialize.url("self._config.geography", self._config.geography, 'str'),
            'format': self._serialize.url("format", format, 'str'),
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]
        query_parameters['api-version'] = self._serialize.query("api_version", api_version, 'str')
        query_parameters['mincoordinates'] = self._serialize.query("mincoordinates", mincoordinates, 'str')
        query_parameters['maxcoordinates'] = self._serialize.query("maxcoordinates", maxcoordinates, 'str')
        if text is not None:
            query_parameters['text'] = self._serialize.query("text", text, 'str')

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]
        if self._config.x_ms_client_id is not None:
            header_parameters['x-ms-client-id'] = self._serialize.header("self._config.x_ms_client_id", self._config.x_ms_client_id, 'str')
        header_parameters['Accept'] = self._serialize.header("accept", accept, 'str')

        request = self._client.get(url, query_parameters, header_parameters)
        pipeline_response = await self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize.failsafe_deserialize(_models.ErrorResponse, response)
            raise HttpResponseError(response=response, model=error)

        deserialized = self._deserialize('GetCopyrightFromBoundingBoxResult', pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized
    get_copyright_from_bounding_box.metadata = {'url': '/map/copyright/bounding/{format}'}  # type: ignore

    async def get_copyright_for_tile(
        self,
        format: Union[str, "_models.TextFormat"],
        zoom: int,
        x_tile_index: int,
        y_tile_index: int,
        text: Optional[Union[str, "_models.IncludeText"]] = None,
        **kwargs: Any
    ) -> "_models.GetCopyrightForTileResult":
        """**Applies to**\ : S0 and S1 pricing tiers.

        Copyrights API is designed to serve copyright information for Render Tile  service. In addition
        to basic copyright for the whole map, API is serving  specific groups of copyrights for some
        countries.
        Returns the copyright information for a given tile. To obtain the copyright information for a
        particular tile, the request should specify the tile's zoom level and x and y coordinates (see:
        Zoom Levels and Tile Grid).

        :param format: Desired format of the response. Value can be either *json* or *xml*.
        :type format: str or ~azure.maps.render.models.TextFormat
        :param zoom: Zoom level for the desired tile. Zoom value must be in the range: 0-18
         (inclusive).

         Please see `Zoom Levels and Tile Grid
         <https://docs.microsoft.com/en-us/azure/location-based-services/zoom-levels-and-tile-grid>`_
         for details.
        :type zoom: int
        :param x_tile_index: X coordinate of the tile on zoom grid. Value must be in the range [0,
         2:code:`<sup>`zoom`</sup>` -1].

         Please see `Zoom Levels and Tile Grid
         <https://docs.microsoft.com/en-us/azure/location-based-services/zoom-levels-and-tile-grid>`_
         for details.
        :type x_tile_index: int
        :param y_tile_index: Y coordinate of the tile on zoom grid. Value must be in the range [0,
         2:code:`<sup>`zoom`</sup>` -1].

         Please see `Zoom Levels and Tile Grid
         <https://docs.microsoft.com/en-us/azure/location-based-services/zoom-levels-and-tile-grid>`_
         for details.
        :type y_tile_index: int
        :param text: Yes/no value to exclude textual data from response. Only images and country names
         will be in response.
        :type text: str or ~azure.maps.render.models.IncludeText
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: GetCopyrightForTileResult, or the result of cls(response)
        :rtype: ~azure.maps.render.models.GetCopyrightForTileResult
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType["_models.GetCopyrightForTileResult"]
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}))
        api_version = "1.0"
        accept = "application/json"

        # Construct URL
        url = self.get_copyright_for_tile.metadata['url']  # type: ignore
        path_format_arguments = {
            'geography': self._serialize.url("self._config.geography", self._config.geography, 'str'),
            'format': self._serialize.url("format", format, 'str'),
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]
        query_parameters['api-version'] = self._serialize.query("api_version", api_version, 'str')
        query_parameters['zoom'] = self._serialize.query("zoom", zoom, 'int')
        query_parameters['x'] = self._serialize.query("x_tile_index", x_tile_index, 'int')
        query_parameters['y'] = self._serialize.query("y_tile_index", y_tile_index, 'int')
        if text is not None:
            query_parameters['text'] = self._serialize.query("text", text, 'str')

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]
        if self._config.x_ms_client_id is not None:
            header_parameters['x-ms-client-id'] = self._serialize.header("self._config.x_ms_client_id", self._config.x_ms_client_id, 'str')
        header_parameters['Accept'] = self._serialize.header("accept", accept, 'str')

        request = self._client.get(url, query_parameters, header_parameters)
        pipeline_response = await self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize.failsafe_deserialize(_models.ErrorResponse, response)
            raise HttpResponseError(response=response, model=error)

        deserialized = self._deserialize('GetCopyrightForTileResult', pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized
    get_copyright_for_tile.metadata = {'url': '/map/copyright/tile/{format}'}  # type: ignore

    async def get_copyright_for_world(
        self,
        format: Union[str, "_models.TextFormat"],
        text: Optional[Union[str, "_models.IncludeText"]] = None,
        **kwargs: Any
    ) -> "_models.GetCopyrightForWorldResult":
        """**Applies to**\ : S0 and S1 pricing tiers.

        Copyrights API is designed to serve copyright information for Render Tile  service. In addition
        to basic copyright for the whole map, API is serving  specific groups of copyrights for some
        countries.
        Returns the copyright information for the world. To obtain the default copyright information
        for the whole world, do not specify a tile or bounding box.

        :param format: Desired format of the response. Value can be either *json* or *xml*.
        :type format: str or ~azure.maps.render.models.TextFormat
        :param text: Yes/no value to exclude textual data from response. Only images and country names
         will be in response.
        :type text: str or ~azure.maps.render.models.IncludeText
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: GetCopyrightForWorldResult, or the result of cls(response)
        :rtype: ~azure.maps.render.models.GetCopyrightForWorldResult
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType["_models.GetCopyrightForWorldResult"]
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}))
        api_version = "1.0"
        accept = "application/json"

        # Construct URL
        url = self.get_copyright_for_world.metadata['url']  # type: ignore
        path_format_arguments = {
            'geography': self._serialize.url("self._config.geography", self._config.geography, 'str'),
            'format': self._serialize.url("format", format, 'str'),
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]
        query_parameters['api-version'] = self._serialize.query("api_version", api_version, 'str')
        if text is not None:
            query_parameters['text'] = self._serialize.query("text", text, 'str')

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]
        if self._config.x_ms_client_id is not None:
            header_parameters['x-ms-client-id'] = self._serialize.header("self._config.x_ms_client_id", self._config.x_ms_client_id, 'str')
        header_parameters['Accept'] = self._serialize.header("accept", accept, 'str')

        request = self._client.get(url, query_parameters, header_parameters)
        pipeline_response = await self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize.failsafe_deserialize(_models.ErrorResponse, response)
            raise HttpResponseError(response=response, model=error)

        deserialized = self._deserialize('GetCopyrightForWorldResult', pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized
    get_copyright_for_world.metadata = {'url': '/map/copyright/world/{format}'}  # type: ignore
