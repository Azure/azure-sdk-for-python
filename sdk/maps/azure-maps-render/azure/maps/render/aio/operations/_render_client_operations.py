# coding=utf-8
# --------------------------------------------------------------------------
# Copyright (c) Microsoft Corporation. All rights reserved.
# Licensed under the MIT License. See License.txt in the project root for license information.
# Code generated by Microsoft (R) AutoRest Code Generator.
# Changes may cause incorrect behavior and will be lost if the code is regenerated.
# --------------------------------------------------------------------------
import datetime
from typing import Any, Callable, Dict, Generic, IO, List, Optional, TypeVar, Union
import warnings

from azure.core.exceptions import ClientAuthenticationError, HttpResponseError, ResourceExistsError, ResourceNotFoundError, map_error
from azure.core.pipeline import PipelineResponse
from azure.core.pipeline.transport import AsyncHttpResponse, HttpRequest

from ... import models

T = TypeVar('T')
ClsType = Optional[Callable[[PipelineResponse[HttpRequest, AsyncHttpResponse], T, Dict[str, Any]], Any]]

class RenderClientOperationsMixin:

    async def get_map_tile_v2(
        self,
        tileset_id: Union[str, "models.TilesetID"],
        tile_index: "models.TileIndex",
        time_stamp: Optional[datetime.datetime] = None,
        tile_size: Optional[Union[str, "models.MapTileSize"]] = None,
        language: Optional[str] = None,
        localized_map_view: Optional[Union[str, "models.LocalizedMapView"]] = None,
        **kwargs
    ) -> IO:
        """**Applies to**\ : S0 and S1 pricing tiers.

        The Get Map Tiles API allows users to request map tiles in vector or raster formats typically
        to be integrated  into a map control or SDK. Some example tiles that can be requested are Azure
        Maps road tiles, real-time  Weather Radar tiles or the map tiles created using `Azure Maps
        Creator <https://aka.ms/amcreator>`_. By default,  Azure Maps uses vector tiles for its web map
        control (Web SDK) and Android SDK.

        :param tileset_id: A tileset is a collection of raster or vector data broken up into a uniform
         grid of square tiles at preset  zoom levels. Every tileset has a **tilesetId** to use when
         making requests. The **tilesetId** for tilesets created using `Azure Maps Creator
         <https://aka.ms/amcreator>`_ are generated through the  `Tileset Create API
         <https://docs.microsoft.com/en-us/rest/api/maps/tileset>`_. The ready-to-use tilesets supplied
         by Azure Maps are listed below. For example, microsoft.base.
        :type tileset_id: str or ~azure.maps.render.models.TilesetID
        :param tile_index: Parameter group.
        :type tile_index: ~azure.maps.render.models.TileIndex
        :param time_stamp: The desired date and time of the requested tile. This parameter must be
         specified in the standard date-time format (e.g. 2019-11-14T16:03:00-08:00), as defined by `ISO
         8601 <https://en.wikipedia.org/wiki/ISO_8601>`_. This parameter is only supported when
         tilesetId parameter is set to one of the values below.


         * microsoft.weather.infrared.main: We provide tiles up to 3 hours in the past. Tiles are
         available in 10-minute intervals. We round the timeStamp value to the nearest 10-minute time
         frame.
         * microsoft.weather.radar.main: We provide tiles up to 1.5 hours in the past and up to 2 hours
         in the future. Tiles are available in 5-minute intervals. We round the timeStamp value to the
         nearest 5-minute time frame.
        :type time_stamp: ~datetime.datetime
        :param tile_size: The size of the returned map tile in pixels.
        :type tile_size: str or ~azure.maps.render.models.MapTileSize
        :param language: Language in which search results should be returned. Should be one of
         supported IETF language tags, case insensitive. When data in specified language is not
         available for a specific field, default language is used.

         Please refer to `Supported Languages <https://docs.microsoft.com/azure/azure-maps/supported-
         languages>`_ for details.
        :type language: str
        :param localized_map_view: The View parameter (also called the "user region" parameter) allows
         you to show the correct maps for a certain country/region for geopolitically disputed regions.
         Different countries have different views of such regions, and the View parameter allows your
         application to comply with the view required by the country your application will be serving.
         By default, the View parameter is set to “Unified” even if you haven’t defined it in  the
         request. It is your responsibility to determine the location of your users, and then set the
         View parameter correctly for that location. Alternatively, you have the option to set
         ‘View=Auto’, which will return the map data based on the IP  address of the request. The View
         parameter in Azure Maps must be used in compliance with applicable laws, including those
         regarding mapping, of the country where maps, images and other data and third party content
         that you are authorized to  access via Azure Maps is made available. Example: view=IN.

         Please refer to `Supported Views <https://aka.ms/AzureMapsLocalizationViews>`_ for details and
         to see the available Views.
        :type localized_map_view: str or ~azure.maps.render.models.LocalizedMapView
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: IO, or the result of cls(response)
        :rtype: IO
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType[IO]
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}))
        
        _z = None
        _x = None
        _y = None
        if tile_index is not None:
            _z = tile_index.z
            _x = tile_index.x
            _y = tile_index.y
        api_version = "2.1"
        accept = "image/jpeg, image/png, image/pbf, application/vnd.mapbox-vector-tile, application/json"

        # Construct URL
        url = self.get_map_tile_v2.metadata['url']  # type: ignore

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]
        query_parameters['api-version'] = self._serialize.query("api_version", api_version, 'str')
        query_parameters['tilesetId'] = self._serialize.query("tileset_id", tileset_id, 'str')
        query_parameters['zoom'] = self._serialize.query("z", _z, 'int')
        query_parameters['x'] = self._serialize.query("x", _x, 'int')
        query_parameters['y'] = self._serialize.query("y", _y, 'int')
        if time_stamp is not None:
            query_parameters['timeStamp'] = self._serialize.query("time_stamp", time_stamp, 'iso-8601')
        if tile_size is not None:
            query_parameters['tileSize'] = self._serialize.query("tile_size", tile_size, 'str')
        if language is not None:
            query_parameters['language'] = self._serialize.query("language", language, 'str')
        if localized_map_view is not None:
            query_parameters['view'] = self._serialize.query("localized_map_view", localized_map_view, 'str')

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]
        if self._config.client_id is not None:
            header_parameters['x-ms-client-id'] = self._serialize.header("self._config.client_id", self._config.client_id, 'str')
        header_parameters['Accept'] = self._serialize.header("accept", accept, 'str')

        request = self._client.get(url, query_parameters, header_parameters)
        pipeline_response = await self._client._pipeline.run(request, stream=True, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize(models.ErrorResponse, response)
            raise HttpResponseError(response=response, model=error)

        response_headers = {}
        response_headers['Content-Type']=self._deserialize('str', response.headers.get('Content-Type'))
        deserialized = response.stream_download(self._client._pipeline)

        if cls:
            return cls(pipeline_response, deserialized, response_headers)

        return deserialized
    get_map_tile_v2.metadata = {'url': '/map/tile'}  # type: ignore

    async def get_map_tileset(
        self,
        tileset_id: Union[str, "models.TilesetID"],
        **kwargs
    ) -> "models.MapTileset":
        """**Applies to**\ : S0 and S1 pricing tiers.

        The Get Map Tileset API allows users to request metadata for a tileset.

        :param tileset_id: A tileset is a collection of raster or vector data broken up into a uniform
         grid of square tiles at preset  zoom levels. Every tileset has a **tilesetId** to use when
         making requests. The **tilesetId** for tilesets created using `Azure Maps Creator
         <https://aka.ms/amcreator>`_ are generated through the  `Tileset Create API
         <https://docs.microsoft.com/en-us/rest/api/maps/tileset>`_. The ready-to-use tilesets supplied
         by Azure Maps are listed below. For example, microsoft.base.
        :type tileset_id: str or ~azure.maps.render.models.TilesetID
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: MapTileset, or the result of cls(response)
        :rtype: ~azure.maps.render.models.MapTileset
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType["models.MapTileset"]
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}))
        api_version = "2.1"
        accept = "application/json"

        # Construct URL
        url = self.get_map_tileset.metadata['url']  # type: ignore

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]
        query_parameters['api-version'] = self._serialize.query("api_version", api_version, 'str')
        query_parameters['tilesetId'] = self._serialize.query("tileset_id", tileset_id, 'str')

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]
        if self._config.client_id is not None:
            header_parameters['x-ms-client-id'] = self._serialize.header("self._config.client_id", self._config.client_id, 'str')
        header_parameters['Accept'] = self._serialize.header("accept", accept, 'str')

        request = self._client.get(url, query_parameters, header_parameters)
        pipeline_response = await self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize(models.ErrorResponse, response)
            raise HttpResponseError(response=response, model=error)

        deserialized = self._deserialize('MapTileset', pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized
    get_map_tileset.metadata = {'url': '/map/tileset'}  # type: ignore

    async def get_map_attribution(
        self,
        tileset_id: Union[str, "models.TilesetID"],
        zoom: int,
        bounds: List[float],
        **kwargs
    ) -> "models.MapAttribution":
        """**Applies to**\ : S0 and S1 pricing tiers.

        The Get Map Attribution API allows users to request map copyright attribution information for a
        section of a tileset.

        :param tileset_id: A tileset is a collection of raster or vector data broken up into a uniform
         grid of square tiles at preset  zoom levels. Every tileset has a **tilesetId** to use when
         making requests. The **tilesetId** for tilesets created using `Azure Maps Creator
         <https://aka.ms/amcreator>`_ are generated through the  `Tileset Create API
         <https://docs.microsoft.com/en-us/rest/api/maps/tileset>`_. The ready-to-use tilesets supplied
         by Azure Maps are listed below. For example, microsoft.base.
        :type tileset_id: str or ~azure.maps.render.models.TilesetID
        :param zoom: Zoom level for the desired map attribution.
        :type zoom: int
        :param bounds: The string that represents the rectangular area of a bounding box. The bounds
         parameter is defined by the 4 bounding box coordinates, with WGS84 longitude and latitude of
         the southwest corner followed by  WGS84 longitude and latitude of the northeast corner. The
         string is presented in the following  format: ``[SouthwestCorner_Longitude,
         SouthwestCorner_Latitude, NortheastCorner_Longitude,  NortheastCorner_Latitude]``.
        :type bounds: list[float]
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: MapAttribution, or the result of cls(response)
        :rtype: ~azure.maps.render.models.MapAttribution
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType["models.MapAttribution"]
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}))
        api_version = "2.1"
        accept = "application/json"

        # Construct URL
        url = self.get_map_attribution.metadata['url']  # type: ignore

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]
        query_parameters['api-version'] = self._serialize.query("api_version", api_version, 'str')
        query_parameters['tilesetId'] = self._serialize.query("tileset_id", tileset_id, 'str')
        query_parameters['zoom'] = self._serialize.query("zoom", zoom, 'int')
        query_parameters['bounds'] = self._serialize.query("bounds", bounds, '[float]', div=',')

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]
        if self._config.client_id is not None:
            header_parameters['x-ms-client-id'] = self._serialize.header("self._config.client_id", self._config.client_id, 'str')
        header_parameters['Accept'] = self._serialize.header("accept", accept, 'str')

        request = self._client.get(url, query_parameters, header_parameters)
        pipeline_response = await self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize(models.ErrorResponse, response)
            raise HttpResponseError(response=response, model=error)

        deserialized = self._deserialize('MapAttribution', pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized
    get_map_attribution.metadata = {'url': '/map/attribution'}  # type: ignore

    async def get_map_state_tile(
        self,
        stateset_id: str,
        tile_index: "models.TileIndex",
        **kwargs
    ) -> IO:
        """**Applies to**\ : S0 and S1 pricing tiers.

        Fetches state tiles in vector format typically to be integrated into indoor maps module of map
        control or SDK. The map control will call this API after user turns on dynamic styling (see
        `Zoom Levels and Tile Grid <https://docs.microsoft.com/en-us/azure/location-based-
        services/zoom-levels-and-tile-grid>`_\ ).

        :param stateset_id: The stateset id.
        :type stateset_id: str
        :param tile_index: Parameter group.
        :type tile_index: ~azure.maps.render.models.TileIndex
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: IO, or the result of cls(response)
        :rtype: IO
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType[IO]
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}))
        
        _z = None
        _x = None
        _y = None
        if tile_index is not None:
            _z = tile_index.z
            _x = tile_index.x
            _y = tile_index.y
        api_version = "2.1"
        accept = "application/vnd.mapbox-vector-tile, application/json"

        # Construct URL
        url = self.get_map_state_tile.metadata['url']  # type: ignore

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]
        query_parameters['api-version'] = self._serialize.query("api_version", api_version, 'str')
        query_parameters['zoom'] = self._serialize.query("z", _z, 'int')
        query_parameters['x'] = self._serialize.query("x", _x, 'int')
        query_parameters['y'] = self._serialize.query("y", _y, 'int')
        query_parameters['statesetId'] = self._serialize.query("stateset_id", stateset_id, 'str')

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]
        if self._config.client_id is not None:
            header_parameters['x-ms-client-id'] = self._serialize.header("self._config.client_id", self._config.client_id, 'str')
        header_parameters['Accept'] = self._serialize.header("accept", accept, 'str')

        request = self._client.get(url, query_parameters, header_parameters)
        pipeline_response = await self._client._pipeline.run(request, stream=True, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize(models.ErrorResponse, response)
            raise HttpResponseError(response=response, model=error)

        response_headers = {}
        response_headers['Content-Type']=self._deserialize('str', response.headers.get('Content-Type'))
        deserialized = response.stream_download(self._client._pipeline)

        if cls:
            return cls(pipeline_response, deserialized, response_headers)

        return deserialized
    get_map_state_tile.metadata = {'url': '/map/statetile'}  # type: ignore

    async def get_copyright_caption(
        self,
        format: Union[str, "models.ResponseFormat"] = "json",
        **kwargs
    ) -> "models.CopyrightCaption":
        """**Applies to**\ : S0 and S1 pricing tiers.

        Copyrights API is designed to serve copyright information for Render Tile
        service. In addition to basic copyright for the whole map, API is serving
        specific groups of copyrights for some countries.

        As an alternative to copyrights for map request, one can receive captions
        for displaying the map provider information on the map.

        :param format: Desired format of the response. Value can be either *json* or *xml*.
        :type format: str or ~azure.maps.render.models.ResponseFormat
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: CopyrightCaption, or the result of cls(response)
        :rtype: ~azure.maps.render.models.CopyrightCaption
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType["models.CopyrightCaption"]
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}))
        api_version = "2.1"
        accept = "application/json"

        # Construct URL
        url = self.get_copyright_caption.metadata['url']  # type: ignore
        path_format_arguments = {
            'format': self._serialize.url("format", format, 'str'),
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]
        query_parameters['api-version'] = self._serialize.query("api_version", api_version, 'str')

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]
        if self._config.client_id is not None:
            header_parameters['x-ms-client-id'] = self._serialize.header("self._config.client_id", self._config.client_id, 'str')
        header_parameters['Accept'] = self._serialize.header("accept", accept, 'str')

        request = self._client.get(url, query_parameters, header_parameters)
        pipeline_response = await self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize(models.ErrorResponse, response)
            raise HttpResponseError(response=response, model=error)

        deserialized = self._deserialize('CopyrightCaption', pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized
    get_copyright_caption.metadata = {'url': '/map/copyright/caption/{format}'}  # type: ignore

    async def get_map_static_image(
        self,
        format: Union[str, "models.RasterTileFormat"] = "png",
        layer: Optional[Union[str, "models.StaticMapLayer"]] = None,
        style: Optional[Union[str, "models.MapImageStyle"]] = None,
        zoom: Optional[int] = None,
        center: Optional[List[float]] = None,
        bounding_box: Optional[List[float]] = None,
        height: Optional[int] = None,
        width: Optional[int] = None,
        language: Optional[str] = None,
        localized_map_view: Optional[Union[str, "models.LocalizedMapView"]] = None,
        pins: Optional[List[str]] = None,
        path: Optional[List[str]] = None,
        **kwargs
    ) -> IO:
        """**Applies to**\ : S0 and S1 pricing tiers.

        The static image service renders a user-defined, rectangular image containing a map section
        using a zoom level from 0 to 20. The static image service renders a user-defined, rectangular
        image containing a map section using a zoom level from 0 to 20. The supported resolution range
        for the map image is from 1x1 to 8192x8192. If you are deciding when to use the static image
        service over the map tile service, you may want to consider how you would like to interact with
        the rendered map. If the map contents will be relatively unchanging, a static map is a good
        choice. If you want to support a lot of zooming, panning and changing of the map content, the
        map tile service would be a better choice.

        Service also provides Image Composition functionality to get a static image back with
        additional data like; pushpins and geometry overlays with following S0 and S1 capabilities.

        In S0 you can:


        * Render up to 5 pushpins specified in the request
        * Provide one custom image for the pins referenced in the request
        * Add labels to the pushpins

        In S1 you can:


        * Render pushpins through `Azure Maps Data Service <https://aka.ms/AzureMapsMapDataService>`_
        * Specify multiple pushpin styles
        * Render circle, polyline and polygon geometry types.
        * Render of supported GeoJSON geometry types uploaded through `Azure Maps Data Service
        <https://aka.ms/AzureMapsMapDataService>`_

        Please see `How-to-Guide <https://aka.ms/AzureMapsHowToGuideImageCompositor>`_ for detailed
        examples.

        *Note* : Either **center** or **bbox** parameter must be supplied to the
        API.
        :code:`<br>`:code:`<br>`
        The supported Lat and Lon ranges when using the **bbox** parameter, are as follows:
        :code:`<br>`:code:`<br>`

        .. list-table::
           :header-rows: 1

           * - Zoom Level
             - Max Lon Range
             - Max Lat Range
           * - 0
             - 360.0
             - 170.0
           * - 1
             - 360.0
             - 170.0
           * - 2
             - 360.0
             - 170.0
           * - 3
             - 360.0
             - 170.0
           * - 4
             - 360.0
             - 170.0
           * - 5
             - 180.0
             - 85.0
           * - 6
             - 90.0
             - 42.5
           * - 7
             - 45.0
             - 21.25
           * - 8
             - 22.5
             - 10.625
           * - 9
             - 11.25
             - 5.3125
           * - 10
             - 5.625
             - 2.62625
           * - 11
             - 2.8125
             - 1.328125
           * - 12
             - 1.40625
             - 0.6640625
           * - 13
             - 0.703125
             - 0.33203125
           * - 14
             - 0.3515625
             - 0.166015625
           * - 15
             - 0.17578125
             - 0.0830078125
           * - 16
             - 0.087890625
             - 0.0415039063
           * - 17
             - 0.0439453125
             - 0.0207519531
           * - 18
             - 0.0219726563
             - 0.0103759766
           * - 19
             - 0.0109863281
             - 0.0051879883
           * - 20
             - 0.0054931641
             - 0.0025939941.

        :param format: Desired format of the response. Possible value: png.
        :type format: str or ~azure.maps.render.models.RasterTileFormat
        :param layer: Map layer requested. If layer is set to labels or hybrid, the format should be
         png.
        :type layer: str or ~azure.maps.render.models.StaticMapLayer
        :param style: Map style to be returned. Possible values are main and dark.
        :type style: str or ~azure.maps.render.models.MapImageStyle
        :param zoom: Desired zoom level of the map. Zoom value must be in the range: 0-20 (inclusive).
         Default value is 12.:code:`<br>`:code:`<br>`Please see `Zoom Levels and Tile Grid
         <https://docs.microsoft.com/en-us/azure/location-based-services/zoom-levels-and-tile-grid>`_
         for details.
        :type zoom: int
        :param center: Coordinates of the center point. Format: 'lon,lat'. Projection used


         * EPSG:3857. Longitude range: -180 to 180. Latitude range: -85 to 85.

         Note: Either center or bbox are required parameters. They are
         mutually exclusive.
        :type center: list[float]
        :param bounding_box: Bounding box. Projection used - EPSG:3857. Format : 'minLon, minLat,
         maxLon, maxLat'.

         Note: Either bbox or center are required
         parameters. They are mutually exclusive. It shouldn’t be used with
         height or width.

         The maximum allowed ranges for Lat and Lon are defined for each zoom level
         in the table at the top of this page.
        :type bounding_box: list[float]
        :param height: Height of the resulting image in pixels. Range is 1 to 8192. Default
         is 512. It shouldn’t be used with bbox.
        :type height: int
        :param width: Width of the resulting image in pixels. Range is 1 to 8192. Default is 512. It
         shouldn’t be used with bbox.
        :type width: int
        :param language: Language in which search results should be returned. Should be one of
         supported IETF language tags, case insensitive. When data in specified language is not
         available for a specific field, default language is used.

         Please refer to `Supported Languages <https://docs.microsoft.com/azure/azure-maps/supported-
         languages>`_ for details.
        :type language: str
        :param localized_map_view: The View parameter (also called the "user region" parameter) allows
         you to show the correct maps for a certain country/region for geopolitically disputed regions.
         Different countries have different views of such regions, and the View parameter allows your
         application to comply with the view required by the country your application will be serving.
         By default, the View parameter is set to “Unified” even if you haven’t defined it in  the
         request. It is your responsibility to determine the location of your users, and then set the
         View parameter correctly for that location. Alternatively, you have the option to set
         ‘View=Auto’, which will return the map data based on the IP  address of the request. The View
         parameter in Azure Maps must be used in compliance with applicable laws, including those
         regarding mapping, of the country where maps, images and other data and third party content
         that you are authorized to  access via Azure Maps is made available. Example: view=IN.

         Please refer to `Supported Views <https://aka.ms/AzureMapsLocalizationViews>`_ for details and
         to see the available Views.
        :type localized_map_view: str or ~azure.maps.render.models.LocalizedMapView
        :param pins: Pushpin style and instances. Use this parameter to optionally add pushpins to the
         image.
         The pushpin style describes the appearance of the pushpins, and the instances specify
         the coordinates of the pushpins and optional labels for each pin. (Be sure to properly URL-
         encode values of this
         parameter since it will contain reserved characters such as pipes and punctuation.)

         The Azure Maps account S0 SKU only supports a single instance of the pins parameter. Other
         SKUs
         allow multiple instances of the pins parameter to specify multiple pin styles.

         To render a pushpin at latitude 45°N and longitude 122°W using the default built-in pushpin
         style, add the
         querystring parameter

         ``pins=default||-122 45``

         Note that the longitude comes before the latitude.
         After URL encoding this will look like

         ``pins=default%7C%7C-122+45``

         All of the examples here show the pins
         parameter without URL encoding, for clarity.

         To render a pin at multiple locations, separate each location with a pipe character. For
         example, use

         ``pins=default||-122 45|-119.5 43.2|-121.67 47.12``

         The S0 Azure Maps account SKU only allows five pushpins. Other account SKUs do not have this
         limitation.

         Style Modifiers
         ^^^^^^^^^^^^^^^

         You can modify the appearance of the pins by adding style modifiers. These are added after the
         style but before
         the locations and labels. Style modifiers each have a two-letter name. These abbreviated names
         are used to help
         reduce the length of the URL.

         To change the color of the pushpin, use the 'co' style modifier and specify the color using
         the HTML/CSS RGB color
         format which is a six-digit hexadecimal number (the three-digit form is not supported). For
         example, to use
         a deep pink color which you would specify as #FF1493 in CSS, use

         ``pins=default|coFF1493||-122 45``

         Pushpin Labels
         ^^^^^^^^^^^^^^

         To add a label to the pins, put the label in single quotes just before the coordinates. For
         example, to label
         three pins with the values '1', '2', and '3', use

         ``pins=default||'1'-122 45|'2'-119.5 43.2|'3'-121.67 47.12``

         There is a built in pushpin style called 'none' that does not display a pushpin image. You can
         use this if
         you want to display labels without any pin image. For example,

         ``pins=none||'A'-122 45|'B'-119.5 43.2``

         To change the color of the pushpin labels, use the 'lc' label color style modifier. For
         example, to use pink
         pushpins with black labels, use

         ``pins=default|coFF1493|lc000000||-122 45``

         To change the size of the labels, use the 'ls' label size style modifier. The label size
         represents the approximate
         height of the label text in pixels. For example, to increase the label size to 12, use

         ``pins=default|ls12||'A'-122 45|'B'-119 43``

         The labels are centered at the pushpin 'label anchor.' The anchor location is predefined for
         built-in pushpins and
         is at the top center of custom pushpins (see below). To override the label anchor, using the
         'la' style modifier
         and provide X and Y pixel coordinates for the anchor. These coordinates are relative to the
         top left corner of the
         pushpin image. Positive X values move the anchor to the right, and positive Y values move the
         anchor down. For example,
         to position the label anchor 10 pixels right and 4 pixels above the top left corner of the
         pushpin image,
         use

         ``pins=default|la10 -4||'A'-122 45|'B'-119 43``

         Custom Pushpins
         ^^^^^^^^^^^^^^^

         To use a custom pushpin image, use the word 'custom' as the pin style name, and then specify a
         URL after the
         location and label information. Use two pipe characters to indicate that you're done
         specifying locations and are
         starting the URL. For example,

         ``pins=custom||-122 45||http://contoso.com/pushpins/red.png``

         After URL encoding, this would look like

         ``pins=custom%7C%7C-122+45%7C%7Chttp%3A%2F%2Fcontoso.com%2Fpushpins%2Fred.png``

         By default, custom pushpin images are drawn centered at the pin coordinates. This usually
         isn't ideal as it obscures
         the location that you're trying to highlight. To override the anchor location of the pin
         image, use the 'an'
         style modifier. This uses the same format as the 'la' label anchor style modifier. For
         example, if your custom
         pin image has the tip of the pin at the top left corner of the image, you can set the anchor
         to that spot by
         using

         ``pins=custom|an0 0||-122 45||http://contoso.com/pushpins/red.png``

         Note: If you use the 'co' color modifier with a custom pushpin image, the specified color will
         replace the RGB
         channels of the pixels in the image but will leave the alpha (opacity) channel unchanged. This
         would usually
         only be done with a solid-color custom image.

         Getting Pushpins from Azure Maps Data Storage
         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

         For all Azure Maps account SKUs other than S0,
         the pushpin location information can be obtained from Azure Maps Data Storage. After uploading
         a GeoJSON document containing pin locations, the Data Storage service returns a Unique Data ID
         (UDID) that you can use
         to reference the data in the pins parameter.

         To use the point geometry from an uploaded GeoJSON document as the pin locations, specify the
         UDID in the locations
         section of the pins parameter. For example,

         ``pins=default||udid-29dc105a-dee7-409f-a3f9-22b066ae4713``

         Note that
         only point and multipoint geometry, points and multipoints from geometry collections, and
         point geometry from features
         will be used. Linestring and polygon geometry will be ignored. If the point comes from a
         feature and the feature
         has a string property called "label", the value of that property will be used as the label for
         the pin.

         You can mix pin locations from Data Storage and pin locations specified in the pins parameter.
         Any of the pipe-delimited
         pin locations can be a longitude and latitude or a UDID. For example,

         ``pins=default||-122 45|udid-29dc105a-dee7-409f-a3f9-22b066ae4713|-119 43``

         Scale, Rotation, and Opacity
         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^

         You can make pushpins and their labels larger or smaller by using the 'sc' scale style
         modifier. This is a
         value greater than zero. A value of 1 is the standard scale. Values larger than 1 will make
         the pins larger, and
         values smaller than 1 will make them smaller. For example, to draw the pushpins 50% larger
         than normal, use

         ``pins=default|sc1.5||-122 45``

         You can rotate pushpins and their labels by using the 'ro' rotation style modifier. This is a
         number of degrees
         of clockwise rotation. Use a negative number to rotate counter-clockwise. For example, to
         rotate the pushpins
         90 degrees clockwise and double their size, use

         ``pins=default|ro90|sc2||-122 45``

         You can make pushpins and their labels partially transparent by specifying the 'al' alpha
         style modifier.
         This is a number between 0 and 1 indicating the opacity of the pushpins. Zero makes them
         completely transparent
         (and not visible) and 1 makes them completely opaque (which is the default). For example, to
         make pushpins
         and their labels only 67% opaque, use

         ``pins=default|al.67||-122 45``

         Style Modifier Summary
         ^^^^^^^^^^^^^^^^^^^^^^

         .. list-table::
            :header-rows: 1

            * - Modifier
              - Description
              - Range
            * - al
              - Alpha (opacity)
              - 0 to 1
            * - an
              - Pin anchor
              - *
            * - co
              - Pin color
              - 000000 to FFFFFF
            * - la
              - Label anchor
              - *
            * - lc
              - Label color
              - 000000 to FFFFFF
            * - ls
              - Label size
              - Greater than 0
            * - ro
              - Rotation
              - -360 to 360
            * - sc
              - Scale
              - Greater than 0



         * X and Y coordinates can be anywhere within pin image or a margin around it.
           The margin size is the minimum of the pin width and height.
        :type pins: list[str]
        :param path: Path style and locations. Use this parameter to optionally add lines, polygons or
         circles to the image.
         The path style describes the appearance of the line and fill. (Be sure to properly URL-encode
         values of this
         parameter since it will contain reserved characters such as pipes and punctuation.)

         Path parameter is supported in Azure Maps account SKU starting with S1. Multiple instances of
         the path parameter
         allow to specify multiple geometries with their styles. Number of parameters per request is
         limited to 10 and
         number of locations is limited to 100 per path.

         To render a circle with radius 100 meters and center point at latitude 45°N and longitude
         122°W using the default style, add the
         querystring parameter

         ``path=ra100||-122 45``

         Note that the longitude comes before the latitude.
         After URL encoding this will look like

         ``path=ra100%7C%7C-122+45``

         All of the examples here show the path parameter without URL encoding, for clarity.

         To render a line, separate each location with a pipe character. For example, use

         ``path=||-122 45|-119.5 43.2|-121.67 47.12``

         To render a polygon, last location must be equal to the start location. For example, use

         ``path=||-122 45|-119.5 43.2|-121.67 47.12|-122 45``

         Longitude and latitude values for locations of lines and polygons can be in the range from
         -360 to 360 to allow for rendering of geometries crossing the anti-meridian.

         Style Modifiers
         ^^^^^^^^^^^^^^^

         You can modify the appearance of the path by adding style modifiers. These are added before
         the locations.
         Style modifiers each have a two-letter name. These abbreviated names are used to help reduce
         the length
         of the URL.

         To change the color of the outline, use the 'lc' style modifier and specify the color using
         the HTML/CSS RGB color
         format which is a six-digit hexadecimal number (the three-digit form is not supported). For
         example, to use
         a deep pink color which you would specify as #FF1493 in CSS, use

         ``path=lcFF1493||-122 45|-119.5 43.2``

         Multiple style modifiers may be combined together to create a more complex visual style.

         ``lc0000FF|lw3|la0.60|fa0.50||-122.2 47.6|-122.2 47.7|-122.3 47.7|-122.3 47.6|-122.2 47.6``

         Getting Path locations from Azure Maps Data Storage
         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

         For all Azure Maps account SKUs other than S0, the path location information can be obtained
         from Azure Maps Data Storage.
         After uploading a GeoJSON document containing path locations, the Data Storage service returns
         a Unique Data ID (UDID) that you can use
         to reference the data in the path parameter.

         To use the point geometry from an uploaded GeoJSON document as the path locations, specify the
         UDID in the locations
         section of the path parameter. For example,

         ``path=||udid-29dc105a-dee7-409f-a3f9-22b066ae4713``

         Note the it is not allowed to mix path locations from Data Storage with locations specified in
         the path parameter.

         Style Modifier Summary
         ^^^^^^^^^^^^^^^^^^^^^^

         .. list-table::
            :header-rows: 1

            * - Modifier
              - Description
              - Range
            * - lc
              - Line color
              - 000000 to FFFFFF
            * - fc
              - Fill color
              - 000000 to FFFFFF
            * - la
              - Line alpha (opacity)
              - 0 to 1
            * - fa
              - Fill alpha (opacity)
              - 0 to 1
            * - lw
              - Line width
              - Greater than 0
            * - ra
              - Circle radius (meters)
              - Greater than 0.
        :type path: list[str]
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: IO, or the result of cls(response)
        :rtype: IO
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType[IO]
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}))
        api_version = "2.1"
        accept = "image/jpeg, image/png, image/pbf, application/vnd.mapbox-vector-tile, application/json"

        # Construct URL
        url = self.get_map_static_image.metadata['url']  # type: ignore
        path_format_arguments = {
            'format': self._serialize.url("format", format, 'str'),
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]
        query_parameters['api-version'] = self._serialize.query("api_version", api_version, 'str')
        if layer is not None:
            query_parameters['layer'] = self._serialize.query("layer", layer, 'str')
        if style is not None:
            query_parameters['style'] = self._serialize.query("style", style, 'str')
        if zoom is not None:
            query_parameters['zoom'] = self._serialize.query("zoom", zoom, 'int', maximum=20, minimum=0)
        if center is not None:
            query_parameters['center'] = self._serialize.query("center", center, '[float]', div=',')
        if bounding_box is not None:
            query_parameters['bbox'] = self._serialize.query("bounding_box", bounding_box, '[float]', div=',')
        if height is not None:
            query_parameters['height'] = self._serialize.query("height", height, 'int', maximum=8192, minimum=1)
        if width is not None:
            query_parameters['width'] = self._serialize.query("width", width, 'int', maximum=8192, minimum=1)
        if language is not None:
            query_parameters['language'] = self._serialize.query("language", language, 'str')
        if localized_map_view is not None:
            query_parameters['view'] = self._serialize.query("localized_map_view", localized_map_view, 'str')
        if pins is not None:
            query_parameters['pins'] = [self._serialize.query("pins", q, 'str') if q is not None else '' for q in pins]
        if path is not None:
            query_parameters['path'] = [self._serialize.query("path", q, 'str') if q is not None else '' for q in path]

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]
        if self._config.client_id is not None:
            header_parameters['x-ms-client-id'] = self._serialize.header("self._config.client_id", self._config.client_id, 'str')
        header_parameters['Accept'] = self._serialize.header("accept", accept, 'str')

        request = self._client.get(url, query_parameters, header_parameters)
        pipeline_response = await self._client._pipeline.run(request, stream=True, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize(models.ErrorResponse, response)
            raise HttpResponseError(response=response, model=error)

        response_headers = {}
        response_headers['Content-Type']=self._deserialize('str', response.headers.get('Content-Type'))
        deserialized = response.stream_download(self._client._pipeline)

        if cls:
            return cls(pipeline_response, deserialized, response_headers)

        return deserialized
    get_map_static_image.metadata = {'url': '/map/static/{format}'}  # type: ignore

    async def get_copyright_from_bounding_box(
        self,
        bounding_box: "models.BoundingBox",
        format: Union[str, "models.ResponseFormat"] = "json",
        include_text: Optional[Union[str, "models.IncludeText"]] = None,
        **kwargs
    ) -> "models.Copyright":
        """**Applies to**\ : S0 and S1 pricing tiers.

        Returns copyright information for a given bounding box. Bounding-box requests should specify
        the minimum and maximum longitude and latitude (EPSG-3857) coordinates.

        :param bounding_box: Parameter group.
        :type bounding_box: ~azure.maps.render.models.BoundingBox
        :param format: Desired format of the response. Value can be either *json* or *xml*.
        :type format: str or ~azure.maps.render.models.ResponseFormat
        :param include_text: Yes/no value to exclude textual data from response. Only images and
         country names will be in response.
        :type include_text: str or ~azure.maps.render.models.IncludeText
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: Copyright, or the result of cls(response)
        :rtype: ~azure.maps.render.models.Copyright
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType["models.Copyright"]
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}))
        
        _south_west = None
        _north_east = None
        if bounding_box is not None:
            _south_west = bounding_box.south_west
            _north_east = bounding_box.north_east
        api_version = "2.1"
        accept = "application/json"

        # Construct URL
        url = self.get_copyright_from_bounding_box.metadata['url']  # type: ignore
        path_format_arguments = {
            'format': self._serialize.url("format", format, 'str'),
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]
        query_parameters['api-version'] = self._serialize.query("api_version", api_version, 'str')
        query_parameters['mincoordinates'] = self._serialize.query("south_west", _south_west, '[float]', div=',')
        query_parameters['maxcoordinates'] = self._serialize.query("north_east", _north_east, '[float]', div=',')
        if include_text is not None:
            query_parameters['text'] = self._serialize.query("include_text", include_text, 'str')

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]
        if self._config.client_id is not None:
            header_parameters['x-ms-client-id'] = self._serialize.header("self._config.client_id", self._config.client_id, 'str')
        header_parameters['Accept'] = self._serialize.header("accept", accept, 'str')

        request = self._client.get(url, query_parameters, header_parameters)
        pipeline_response = await self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize(models.ErrorResponse, response)
            raise HttpResponseError(response=response, model=error)

        deserialized = self._deserialize('Copyright', pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized
    get_copyright_from_bounding_box.metadata = {'url': '/map/copyright/bounding/{format}'}  # type: ignore

    async def get_copyright_for_tile(
        self,
        tile_index: "models.TileIndex",
        format: Union[str, "models.ResponseFormat"] = "json",
        include_text: Optional[Union[str, "models.IncludeText"]] = None,
        **kwargs
    ) -> "models.Copyright":
        """**Applies to**\ : S0 and S1 pricing tiers.

        Copyrights API is designed to serve copyright information for Render Tile  service. In addition
        to basic copyright for the whole map, API is serving  specific groups of copyrights for some
        countries.
        Returns the copyright information for a given tile. To obtain the copyright information for a
        particular tile, the request should specify the tile's zoom level and x and y coordinates (see:
        Zoom Levels and Tile Grid).

        :param tile_index: Parameter group.
        :type tile_index: ~azure.maps.render.models.TileIndex
        :param format: Desired format of the response. Value can be either *json* or *xml*.
        :type format: str or ~azure.maps.render.models.ResponseFormat
        :param include_text: Yes/no value to exclude textual data from response. Only images and
         country names will be in response.
        :type include_text: str or ~azure.maps.render.models.IncludeText
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: Copyright, or the result of cls(response)
        :rtype: ~azure.maps.render.models.Copyright
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType["models.Copyright"]
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}))
        
        _z = None
        _x = None
        _y = None
        if tile_index is not None:
            _z = tile_index.z
            _x = tile_index.x
            _y = tile_index.y
        api_version = "2.1"
        accept = "application/json"

        # Construct URL
        url = self.get_copyright_for_tile.metadata['url']  # type: ignore
        path_format_arguments = {
            'format': self._serialize.url("format", format, 'str'),
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]
        query_parameters['api-version'] = self._serialize.query("api_version", api_version, 'str')
        query_parameters['zoom'] = self._serialize.query("z", _z, 'int')
        query_parameters['x'] = self._serialize.query("x", _x, 'int')
        query_parameters['y'] = self._serialize.query("y", _y, 'int')
        if include_text is not None:
            query_parameters['text'] = self._serialize.query("include_text", include_text, 'str')

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]
        if self._config.client_id is not None:
            header_parameters['x-ms-client-id'] = self._serialize.header("self._config.client_id", self._config.client_id, 'str')
        header_parameters['Accept'] = self._serialize.header("accept", accept, 'str')

        request = self._client.get(url, query_parameters, header_parameters)
        pipeline_response = await self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize(models.ErrorResponse, response)
            raise HttpResponseError(response=response, model=error)

        deserialized = self._deserialize('Copyright', pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized
    get_copyright_for_tile.metadata = {'url': '/map/copyright/tile/{format}'}  # type: ignore

    async def get_copyright_for_world(
        self,
        format: Union[str, "models.ResponseFormat"] = "json",
        include_text: Optional[Union[str, "models.IncludeText"]] = None,
        **kwargs
    ) -> "models.Copyright":
        """**Applies to**\ : S0 and S1 pricing tiers.

        Copyrights API is designed to serve copyright information for Render Tile  service. In addition
        to basic copyright for the whole map, API is serving  specific groups of copyrights for some
        countries.
        Returns the copyright information for the world. To obtain the default copyright information
        for the whole world, do not specify a tile or bounding box.

        :param format: Desired format of the response. Value can be either *json* or *xml*.
        :type format: str or ~azure.maps.render.models.ResponseFormat
        :param include_text: Yes/no value to exclude textual data from response. Only images and
         country names will be in response.
        :type include_text: str or ~azure.maps.render.models.IncludeText
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: Copyright, or the result of cls(response)
        :rtype: ~azure.maps.render.models.Copyright
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType["models.Copyright"]
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}))
        api_version = "2.1"
        accept = "application/json"

        # Construct URL
        url = self.get_copyright_for_world.metadata['url']  # type: ignore
        path_format_arguments = {
            'format': self._serialize.url("format", format, 'str'),
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]
        query_parameters['api-version'] = self._serialize.query("api_version", api_version, 'str')
        if include_text is not None:
            query_parameters['text'] = self._serialize.query("include_text", include_text, 'str')

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]
        if self._config.client_id is not None:
            header_parameters['x-ms-client-id'] = self._serialize.header("self._config.client_id", self._config.client_id, 'str')
        header_parameters['Accept'] = self._serialize.header("accept", accept, 'str')

        request = self._client.get(url, query_parameters, header_parameters)
        pipeline_response = await self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize(models.ErrorResponse, response)
            raise HttpResponseError(response=response, model=error)

        deserialized = self._deserialize('Copyright', pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized
    get_copyright_for_world.metadata = {'url': '/map/copyright/world/{format}'}  # type: ignore
