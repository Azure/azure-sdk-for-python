# coding=utf-8
# --------------------------------------------------------------------------
# Copyright (c) Microsoft Corporation. All rights reserved.
# Licensed under the MIT License. See License.txt in the project root for license information.
# Code generated by Microsoft (R) AutoRest Code Generator.
# Changes may cause incorrect behavior and will be lost if the code is regenerated.
# --------------------------------------------------------------------------
from typing import TYPE_CHECKING
import warnings

from azure.core.exceptions import ClientAuthenticationError, HttpResponseError, ResourceExistsError, ResourceNotFoundError, map_error
from azure.core.pipeline import PipelineResponse
from azure.core.pipeline.transport import HttpRequest, HttpResponse

from .. import models

if TYPE_CHECKING:
    # pylint: disable=unused-import,ungrouped-imports
    from typing import Any, Callable, Dict, Generic, List, Optional, TypeVar, Union

    T = TypeVar('T')
    ClsType = Optional[Callable[[PipelineResponse[HttpRequest, HttpResponse], T, Dict[str, Any]], Any]]

class WFSOperations(object):
    """WFSOperations operations.

    You should not instantiate this class directly. Instead, you should create a Client instance that
    instantiates it for you and attaches it as an attribute.

    :ivar models: Alias to model classes used in this operation group.
    :type models: ~azure.maps.creator.models
    :param client: Client for service requests.
    :param config: Configuration of service client.
    :param serializer: An object model serializer.
    :param deserializer: An object model deserializer.
    """

    models = models

    def __init__(self, client, config, serializer, deserializer):
        self._client = client
        self._serialize = serializer
        self._deserialize = deserializer
        self._config = config

    def get_landing_page(
        self,
        dataset_id,  # type: str
        **kwargs  # type: Any
    ):
        # type: (...) -> "models.LandingPageResult"
        """**Applies to:** see pricing `tiers <https://aka.ms/AzureMapsPricingTier>`_.

        Creator makes it possible to develop applications based on your private indoor map data using
        Azure Maps API and SDK. `This <https://docs.microsoft.com/azure/azure-maps/creator-indoor-
        maps>`_ article introduces concepts and tools that apply to Azure Maps Creator.

         The Web Feature Service (WFS) API is part of  Creator. WFS API follows the `Open Geospatial
        Consortium API standard for Features
        <http://docs.opengeospatial.org/is/17-069r3/17-069r3.html>`_ to query `Datasets
        <https://docs.microsoft.com/en-us/rest/api/maps/v2/dataset/create>`_.
        A dataset consists of multiple feature collections. A feature collection is a collection of
        features of a similar type, based on a common schema.
        The Get Landing Page API provides links to the API definition, the Conformance statements  and
        the metadata about the feature data in this dataset.

        :param dataset_id: The identifier for the dataset to query from.
        :type dataset_id: str
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: LandingPageResult, or the result of cls(response)
        :rtype: ~azure.maps.creator.models.LandingPageResult
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType["models.LandingPageResult"]
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}))
        api_version = "2.0"
        accept = "application/json"

        # Construct URL
        url = self.get_landing_page.metadata['url']  # type: ignore
        path_format_arguments = {
            'geography': self._serialize.url("self._config.geography", self._config.geography, 'str'),
            'datasetId': self._serialize.url("dataset_id", dataset_id, 'str'),
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]
        query_parameters['api-version'] = self._serialize.query("api_version", api_version, 'str')

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]
        if self._config.client_id is not None:
            header_parameters['x-ms-client-id'] = self._serialize.header("self._config.client_id", self._config.client_id, 'str')
        header_parameters['Accept'] = self._serialize.header("accept", accept, 'str')

        request = self._client.get(url, query_parameters, header_parameters)
        pipeline_response = self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize(models.ErrorResponse, response)
            raise HttpResponseError(response=response, model=error)

        deserialized = self._deserialize('LandingPageResult', pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized
    get_landing_page.metadata = {'url': '/wfs/datasets/{datasetId}/'}  # type: ignore

    def list_conformance(
        self,
        dataset_id,  # type: str
        **kwargs  # type: Any
    ):
        # type: (...) -> "models.ConformanceResult"
        """**Applies to:** see pricing `tiers <https://aka.ms/AzureMapsPricingTier>`_.

        Creator makes it possible to develop applications based on your private indoor map data using
        Azure Maps API and SDK. `This <https://docs.microsoft.com/azure/azure-maps/creator-indoor-
        maps>`_ article introduces concepts and tools that apply to Azure Maps Creator.

        The Web Feature Service (WFS) API is part of  Creator. WFS API follows the `Open Geospatial
        Consortium API standard for Features
        <http://docs.opengeospatial.org/is/17-069r3/17-069r3.html>`_ to query `Datasets
        <https://docs.microsoft.com/en-us/rest/api/maps/v2/dataset/create>`_.
        A dataset consists of multiple feature collections. A feature collection is a collection of
        features of a similar type, based on a common schema.
        The Get Requirements Classes lists all requirements classes specified in the standard that the
        server conforms to.

        :param dataset_id: The identifier for the dataset to query from.
        :type dataset_id: str
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: ConformanceResult, or the result of cls(response)
        :rtype: ~azure.maps.creator.models.ConformanceResult
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType["models.ConformanceResult"]
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}))
        api_version = "2.0"
        accept = "application/json"

        # Construct URL
        url = self.list_conformance.metadata['url']  # type: ignore
        path_format_arguments = {
            'geography': self._serialize.url("self._config.geography", self._config.geography, 'str'),
            'datasetId': self._serialize.url("dataset_id", dataset_id, 'str'),
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]
        query_parameters['api-version'] = self._serialize.query("api_version", api_version, 'str')

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]
        if self._config.client_id is not None:
            header_parameters['x-ms-client-id'] = self._serialize.header("self._config.client_id", self._config.client_id, 'str')
        header_parameters['Accept'] = self._serialize.header("accept", accept, 'str')

        request = self._client.get(url, query_parameters, header_parameters)
        pipeline_response = self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize(models.ErrorResponse, response)
            raise HttpResponseError(response=response, model=error)

        deserialized = self._deserialize('ConformanceResult', pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized
    list_conformance.metadata = {'url': '/wfs/datasets/{datasetId}/conformance'}  # type: ignore

    def get_collections(
        self,
        dataset_id,  # type: str
        **kwargs  # type: Any
    ):
        # type: (...) -> "models.CollectionsResponse"
        """**Applies to:** see pricing `tiers <https://aka.ms/AzureMapsPricingTier>`_.

        Creator makes it possible to develop applications based on your private indoor map data using
        Azure Maps API and SDK. `This <https://docs.microsoft.com/azure/azure-maps/creator-indoor-
        maps>`_ article introduces concepts and tools that apply to Azure Maps Creator.

         The Web Feature Service (WFS) API is part of  Creator. WFS API follows the `Open Geospatial
        Consortium API standard for Features
        <http://docs.opengeospatial.org/is/17-069r3/17-069r3.html>`_ to query `Datasets
        <https://docs.microsoft.com/en-us/rest/api/maps/v2/dataset/create>`_.
        A dataset consists of multiple feature collections. A feature collection is a collection of
        features of a similar type, based on a common schema.
        The Collections Description API provides descriptions of all the collections in a given
        dataset.

        :param dataset_id: The identifier for the dataset to query from.
        :type dataset_id: str
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: CollectionsResponse, or the result of cls(response)
        :rtype: ~azure.maps.creator.models.CollectionsResponse
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType["models.CollectionsResponse"]
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}))
        api_version = "2.0"
        accept = "application/json"

        # Construct URL
        url = self.get_collections.metadata['url']  # type: ignore
        path_format_arguments = {
            'geography': self._serialize.url("self._config.geography", self._config.geography, 'str'),
            'datasetId': self._serialize.url("dataset_id", dataset_id, 'str'),
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]
        query_parameters['api-version'] = self._serialize.query("api_version", api_version, 'str')

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]
        if self._config.client_id is not None:
            header_parameters['x-ms-client-id'] = self._serialize.header("self._config.client_id", self._config.client_id, 'str')
        header_parameters['Accept'] = self._serialize.header("accept", accept, 'str')

        request = self._client.get(url, query_parameters, header_parameters)
        pipeline_response = self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize(models.ErrorResponse, response)
            raise HttpResponseError(response=response, model=error)

        deserialized = self._deserialize('CollectionsResponse', pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized
    get_collections.metadata = {'url': '/wfs/datasets/{datasetId}/collections'}  # type: ignore

    def get_collection(
        self,
        dataset_id,  # type: str
        collection_id,  # type: str
        **kwargs  # type: Any
    ):
        # type: (...) -> "models.Collection"
        """**Applies to:** see pricing `tiers <https://aka.ms/AzureMapsPricingTier>`_.

        Creator makes it possible to develop applications based on your private indoor map data using
        Azure Maps API and SDK. `This <https://docs.microsoft.com/azure/azure-maps/creator-indoor-
        maps>`_ article introduces concepts and tools that apply to Azure Maps Creator.

         The Web Feature Service (WFS) API is part of  Creator. WFS API follows the `Open Geospatial
        Consortium API standard for Features
        <http://docs.opengeospatial.org/is/17-069r3/17-069r3.html>`_ to query `Datasets
        <https://docs.microsoft.com/en-us/rest/api/maps/v2/dataset/create>`_.
        A dataset consists of multiple feature collections. A feature collection is a collection of
        features of a similar type, based on a common schema.

        The Collection Description API provides the description of a given collection. It includes the
        links to the operations that can be performed on the collection.

        :param dataset_id: The identifier for the dataset to query from.
        :type dataset_id: str
        :param collection_id: Identifier (name) of a specific collection.
        :type collection_id: str
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: Collection, or the result of cls(response)
        :rtype: ~azure.maps.creator.models.Collection
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType["models.Collection"]
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}))
        api_version = "2.0"
        accept = "application/json"

        # Construct URL
        url = self.get_collection.metadata['url']  # type: ignore
        path_format_arguments = {
            'geography': self._serialize.url("self._config.geography", self._config.geography, 'str'),
            'datasetId': self._serialize.url("dataset_id", dataset_id, 'str'),
            'collectionId': self._serialize.url("collection_id", collection_id, 'str'),
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]
        query_parameters['api-version'] = self._serialize.query("api_version", api_version, 'str')

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]
        if self._config.client_id is not None:
            header_parameters['x-ms-client-id'] = self._serialize.header("self._config.client_id", self._config.client_id, 'str')
        header_parameters['Accept'] = self._serialize.header("accept", accept, 'str')

        request = self._client.get(url, query_parameters, header_parameters)
        pipeline_response = self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize(models.ErrorResponse, response)
            raise HttpResponseError(response=response, model=error)

        deserialized = self._deserialize('Collection', pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized
    get_collection.metadata = {'url': '/wfs/datasets/{datasetId}/collections/{collectionId}'}  # type: ignore

    def get_collection_definition(
        self,
        dataset_id,  # type: str
        collection_id,  # type: str
        **kwargs  # type: Any
    ):
        # type: (...) -> "models.CollectionDefinition"
        """**Applies to:** see pricing `tiers <https://aka.ms/AzureMapsPricingTier>`_.

        Creator makes it possible to develop applications based on your private indoor map data using
        Azure Maps API and SDK. `This <https://docs.microsoft.com/azure/azure-maps/creator-indoor-
        maps>`_ article introduces concepts and tools that apply to Azure Maps Creator.

         `This <https://docs.microsoft.com/en-us/azure/azure-maps/creator-indoor-maps>`_ article
        introduces concepts and tools that apply to Azure Maps Creator. WFS API follows the `Open
        Geospatial Consortium API standard for Features
        <http://docs.opengeospatial.org/is/17-069r3/17-069r3.html>`_ to query `Datasets
        <https://docs.microsoft.com/en-us/rest/api/maps/v2/dataset/create>`_.
        A dataset consists of multiple feature collections. A feature collection is a collection of
        features of a similar type, based on a common schema.

        The Collection Definition API provides the detailed data model of a given collection.

        :param dataset_id: The identifier for the dataset to query from.
        :type dataset_id: str
        :param collection_id: Identifier (name) of a specific collection.
        :type collection_id: str
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: CollectionDefinition, or the result of cls(response)
        :rtype: ~azure.maps.creator.models.CollectionDefinition
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType["models.CollectionDefinition"]
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}))
        api_version = "2.0"
        accept = "application/json"

        # Construct URL
        url = self.get_collection_definition.metadata['url']  # type: ignore
        path_format_arguments = {
            'geography': self._serialize.url("self._config.geography", self._config.geography, 'str'),
            'datasetId': self._serialize.url("dataset_id", dataset_id, 'str'),
            'collectionId': self._serialize.url("collection_id", collection_id, 'str'),
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]
        query_parameters['api-version'] = self._serialize.query("api_version", api_version, 'str')

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]
        if self._config.client_id is not None:
            header_parameters['x-ms-client-id'] = self._serialize.header("self._config.client_id", self._config.client_id, 'str')
        header_parameters['Accept'] = self._serialize.header("accept", accept, 'str')

        request = self._client.get(url, query_parameters, header_parameters)
        pipeline_response = self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize(models.ErrorResponse, response)
            raise HttpResponseError(response=response, model=error)

        deserialized = self._deserialize('CollectionDefinition', pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized
    get_collection_definition.metadata = {'url': '/wfs/datasets/{datasetId}/collections/{collectionId}/definition'}  # type: ignore

    def get_features(
        self,
        dataset_id,  # type: str
        collection_id,  # type: str
        limit=None,  # type: Optional[int]
        bounding_box=None,  # type: Optional[List[float]]
        filter=None,  # type: Optional[str]
        **kwargs  # type: Any
    ):
        # type: (...) -> "models.ExtendedGeoJsonFeatureCollection"
        """**Applies to:** see pricing `tiers <https://aka.ms/AzureMapsPricingTier>`_.

        Creator makes it possible to develop applications based on your private indoor map data using
        Azure Maps API and SDK. `This <https://docs.microsoft.com/azure/azure-maps/creator-indoor-
        maps>`_ article introduces concepts and tools that apply to Azure Maps Creator.

         The Web Feature Service (WFS) API is part of  Creator. WFS API follows the `Open Geospatial
        Consortium API standard for Features
        <http://docs.opengeospatial.org/is/17-069r3/17-069r3.html>`_ to query `Datasets
        <https://docs.microsoft.com/en-us/rest/api/maps/v2/dataset/create>`_.
        A dataset consists of multiple feature collections. A feature collection is a collection of
        features of a similar type, based on a common schema.
        The Get Features API returns the list of features in the given collection.

        :param dataset_id: The identifier for the dataset to query from.
        :type dataset_id: str
        :param collection_id: Identifier (name) of a specific collection.
        :type collection_id: str
        :param limit: The optional limit parameter limits the number of features that are presented in
         the response document.
         Only features that are on the first level of the collection in the response document are
         counted. Nested objects contained within the explicitly requested features shall not be
         counted.


         * Minimum = 1 * Maximum = 500 * Default = 10.
        :type limit: int
        :param bounding_box: Only features that have a geometry that intersects the supplied bounding
         box are selected.


         * Lower left corner, coordinate axis 1 * Lower left corner, coordinate axis 2 * Upper right
         corner, coordinate axis 1 * Upper right corner, coordinate axis 2
           The coordinate reference system of the values is WGS84 longitude/latitude
         (http://www.opengis.net/def/crs/OGC/1.3/CRS84) unless a different coordinate reference system
         is specified in the parameter ``bbox-crs``.
           For WGS84 longitude/latitude the values are in most cases the sequence of minimum longitude,
         minimum latitude, maximum longitude and maximum latitude. However, in cases where the box spans
         the antimeridian the first value (west-most box edge) is larger than the third value (east-most
         box edge).
        :type bounding_box: list[float]
        :param filter: Filter expression to search for features with specific property values in a
         given collection. Only feature properties of scalar type and equals operator are supported.
         This is a special parameter where the parameter name is a case sensitive property name. The
         scheme for this parameter is {property name}={property value}. Unless "filter" is one of the
         property names in the collection, "filter" should not be used as a parameter name. To search
         for features with "name" property value "21N13", use "name=21N13".
         Multiple filters are supported and should be represented as multiple query parameters. E.g.,
         :code:`<property1>`=:code:`<value1>`&:code:`<property2>`=:code:`<value2>` String values are
         case sensitive.
        :type filter: str
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: ExtendedGeoJsonFeatureCollection, or the result of cls(response)
        :rtype: ~azure.maps.creator.models.ExtendedGeoJsonFeatureCollection
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType["models.ExtendedGeoJsonFeatureCollection"]
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}))
        api_version = "2.0"
        accept = "application/json"

        # Construct URL
        url = self.get_features.metadata['url']  # type: ignore
        path_format_arguments = {
            'geography': self._serialize.url("self._config.geography", self._config.geography, 'str'),
            'datasetId': self._serialize.url("dataset_id", dataset_id, 'str'),
            'collectionId': self._serialize.url("collection_id", collection_id, 'str'),
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]
        query_parameters['api-version'] = self._serialize.query("api_version", api_version, 'str')
        if limit is not None:
            query_parameters['limit'] = self._serialize.query("limit", limit, 'int', maximum=500, minimum=1)
        if bounding_box is not None:
            query_parameters['bbox'] = self._serialize.query("bounding_box", bounding_box, '[float]', div=',')
        if filter is not None:
            query_parameters['filter'] = self._serialize.query("filter", filter, 'str')

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]
        if self._config.client_id is not None:
            header_parameters['x-ms-client-id'] = self._serialize.header("self._config.client_id", self._config.client_id, 'str')
        header_parameters['Accept'] = self._serialize.header("accept", accept, 'str')

        request = self._client.get(url, query_parameters, header_parameters)
        pipeline_response = self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize(models.ErrorResponse, response)
            raise HttpResponseError(response=response, model=error)

        deserialized = self._deserialize('ExtendedGeoJsonFeatureCollection', pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized
    get_features.metadata = {'url': '/wfs/datasets/{datasetId}/collections/{collectionId}/items'}  # type: ignore

    def get_feature(
        self,
        dataset_id,  # type: str
        collection_id,  # type: str
        feature_id,  # type: str
        **kwargs  # type: Any
    ):
        # type: (...) -> "models.FeatureResult"
        """**Applies to:** see pricing `tiers <https://aka.ms/AzureMapsPricingTier>`_.

        Creator makes it possible to develop applications based on your private indoor map data using
        Azure Maps API and SDK. `This <https://docs.microsoft.com/azure/azure-maps/creator-indoor-
        maps>`_ article introduces concepts and tools that apply to Azure Maps Creator.

         The Web Feature Service (WFS) API is part of  Creator. WFS API follows the `Open Geospatial
        Consortium API standard for Features
        <http://docs.opengeospatial.org/is/17-069r3/17-069r3.html>`_ to query `Datasets
        <https://docs.microsoft.com/en-us/rest/api/maps/v2/dataset/create>`_.
        A dataset consists of multiple feature collections. A feature collection is a collection of
        features of a similar type, based on a common schema.
        The Get Feature API returns the feature identified by the provided id in the given collection.

        :param dataset_id: The identifier for the dataset to query from.
        :type dataset_id: str
        :param collection_id: Identifier (name) of a specific collection.
        :type collection_id: str
        :param feature_id: Local identifier of a specific feature.
        :type feature_id: str
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: FeatureResult, or the result of cls(response)
        :rtype: ~azure.maps.creator.models.FeatureResult
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType["models.FeatureResult"]
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}))
        api_version = "2.0"
        accept = "application/json"

        # Construct URL
        url = self.get_feature.metadata['url']  # type: ignore
        path_format_arguments = {
            'geography': self._serialize.url("self._config.geography", self._config.geography, 'str'),
            'datasetId': self._serialize.url("dataset_id", dataset_id, 'str'),
            'collectionId': self._serialize.url("collection_id", collection_id, 'str'),
            'featureId': self._serialize.url("feature_id", feature_id, 'str'),
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]
        query_parameters['api-version'] = self._serialize.query("api_version", api_version, 'str')

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]
        header_parameters['Accept'] = self._serialize.header("accept", accept, 'str')

        request = self._client.get(url, query_parameters, header_parameters)
        pipeline_response = self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize(models.ErrorResponse, response)
            raise HttpResponseError(response=response, model=error)

        deserialized = self._deserialize('FeatureResult', pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized
    get_feature.metadata = {'url': '/wfs/datasets/{datasetId}/collections/{collectionId}/items/{featureId}'}  # type: ignore

    def delete_feature(
        self,
        dataset_id,  # type: str
        collection_id,  # type: str
        feature_id,  # type: str
        **kwargs  # type: Any
    ):
        # type: (...) -> None
        """**Applies to:** see pricing `tiers <https://aka.ms/AzureMapsPricingTier>`_.

        Creator makes it possible to develop applications based on your private indoor map data using
        Azure Maps API and SDK. `This <https://docs.microsoft.com/azure/azure-maps/creator-indoor-
        maps>`_ article introduces concepts and tools that apply to Azure Maps Creator.

         The Web Feature Service (WFS) API is part of  Creator. WFS API follows the `Open Geospatial
        Consortium API standard for Features
        <http://docs.opengeospatial.org/is/17-069r3/17-069r3.html>`_ to query `Datasets
        <https://docs.microsoft.com/en-us/rest/api/maps/v2/dataset/create>`_.
        A dataset consists of multiple feature collections. A feature collection is a collection of
        features of a similar type, based on a common schema.
        The Delete Feature API deletes the feature identified by the provided id in the given
        collection. At this point this API supports only facility features. Deleting a facility feature
        deletes all the child features of that facility recursively.

        :param dataset_id: The identifier for the dataset to query from.
        :type dataset_id: str
        :param collection_id: Identifier (name) of a specific collection.
        :type collection_id: str
        :param feature_id: Local identifier of a specific feature.
        :type feature_id: str
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: None, or the result of cls(response)
        :rtype: None
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType[None]
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}))
        api_version = "2.0"
        accept = "application/json"

        # Construct URL
        url = self.delete_feature.metadata['url']  # type: ignore
        path_format_arguments = {
            'geography': self._serialize.url("self._config.geography", self._config.geography, 'str'),
            'datasetId': self._serialize.url("dataset_id", dataset_id, 'str'),
            'collectionId': self._serialize.url("collection_id", collection_id, 'str'),
            'featureId': self._serialize.url("feature_id", feature_id, 'str'),
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]
        query_parameters['api-version'] = self._serialize.query("api_version", api_version, 'str')

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]
        header_parameters['Accept'] = self._serialize.header("accept", accept, 'str')

        request = self._client.delete(url, query_parameters, header_parameters)
        pipeline_response = self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [204]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize(models.ErrorResponse, response)
            raise HttpResponseError(response=response, model=error)

        if cls:
            return cls(pipeline_response, None, {})

    delete_feature.metadata = {'url': '/wfs/datasets/{datasetId}/collections/{collectionId}/items/{featureId}'}  # type: ignore
