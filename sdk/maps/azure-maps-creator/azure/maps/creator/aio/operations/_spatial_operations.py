# coding=utf-8
# --------------------------------------------------------------------------
# Copyright (c) Microsoft Corporation. All rights reserved.
# Licensed under the MIT License. See License.txt in the project root for license information.
# Code generated by Microsoft (R) AutoRest Code Generator.
# Changes may cause incorrect behavior and will be lost if the code is regenerated.
# --------------------------------------------------------------------------
import datetime
from typing import Any, Callable, Dict, Generic, Optional, TypeVar, Union
import warnings

from azure.core.exceptions import ClientAuthenticationError, HttpResponseError, ResourceExistsError, ResourceNotFoundError, map_error
from azure.core.pipeline import PipelineResponse
from azure.core.pipeline.transport import AsyncHttpResponse, HttpRequest

from ... import models

T = TypeVar('T')
ClsType = Optional[Callable[[PipelineResponse[HttpRequest, AsyncHttpResponse], T, Dict[str, Any]], Any]]

class SpatialOperations:
    """SpatialOperations async operations.

    You should not instantiate this class directly. Instead, you should create a Client instance that
    instantiates it for you and attaches it as an attribute.

    :ivar models: Alias to model classes used in this operation group.
    :type models: ~azure.maps.creator.models
    :param client: Client for service requests.
    :param config: Configuration of service client.
    :param serializer: An object model serializer.
    :param deserializer: An object model deserializer.
    """

    models = models

    def __init__(self, client, config, serializer, deserializer) -> None:
        self._client = client
        self._serialize = serializer
        self._deserialize = deserializer
        self._config = config

    async def get_geofence(
        self,
        device_id: str,
        udid: str,
        position: "models.Position",
        format: Union[str, "models.JsonFormat"] = "json",
        altitude: Optional[float] = None,
        user_time: Optional[datetime.datetime] = None,
        search_buffer_in_meters: Optional[float] = None,
        is_async: Optional[bool] = None,
        mode: Optional[Union[str, "models.GeofenceMode"]] = None,
        **kwargs
    ) -> "models.Geofence":
        """**Search Geofence Get API**

        **Applies to:** S1 Pricing tier.

        The Geofence Get API allows you to retrieve the proximity of a coordinate to a
        geofence that has been uploaded to the Data service. You can use the
        `Data Upload API <https://docs.microsoft.com/en-us/rest/api/maps/data/uploadPreview>`_ to
        upload
        a geofence or set of fences. See `Geofencing GeoJSON data <https://docs.microsoft.com/en-
        us/azure/azure-maps/geofence-geojson>`_
        for more details on the geofence data format. To query the proximity of a coordinate, you
        supply the location of the object you are tracking as well
        as the ID for the fence or set of fences, and the response will contain information about
        the distance from the outer edge of the geofence. A negative value signifies that the
        coordinate is inside of the fence while a positive value means that it is outside of the
        fence.:code:`<br>`:code:`<br>`This API can be used for a variety of scenarios that include
        things like asset
        tracking, fleet management, or setting up alerts for moving objects.

        The API supports `integration with Event Grid <https://docs.microsoft.com/azure/azure-
        maps/azure-maps-event-grid-integration>`_. The isAsync parameter is used to enable integration
        with Event Grid (disabled by default).
        To test this API, you can upload the sample data from Post Geofence API examples(Request Body)
        via Data Upload API and replace the [udid] from the sample request below with the udid returned
        by Data Upload API.

        Geofencing InnerError code
        ^^^^^^^^^^^^^^^^^^^^^^^^^^

        In geofencing response error contract, ``innererror`` is  an object containing service specific
        information about the error. ``code`` is a property in ``innererror`` which can map to a
        specific geofencing error type. The table belows shows the code mapping between all the known
        client error type to the corresponding geofencing error ``message``.

        .. list-table::
           :header-rows: 1

           * - innererror.code
             - error.message
           * - NullDeviceId
             - Device Id should not be null.
           * - NullUdid
             - Udid should not be null.
           * - UdidWrongFormat
             - Udid should be acquired from user data ingestion API.
           * - InvalidUserTime
             - Usertime is invalid.
           * - InvalidSearchBuffer
             - Searchbuffer is invalid.
           * - InvalidSearchRange
             - The value range of searchbuffer should be from 0 to 500 meters.
           * - InvalidLatLon
             - Lat and/or lon parameters are invalid.
           * - InvalidIsAsyncValue
             - The IsAsync parameter is invalid.
           * - InvalidModeValue
             - The mode parameter invalid.
           * - InvalidJson
             - Geofencing data is not a valid json file.
           * - NotSupportedGeoJson
             - Geofencing data can't be read as a Feature or FeatureCollections.
           * - InvalidGeoJson
             - Geofencing data is invalid.
           * - NoUserDataWithAccountOrSubscription
             - Can't find user geofencing data with provided account-id and/or subscription-id.
           * - NoUserDataWithUdid
             - Can't find user geofencing data with provided udid.

        :param device_id: ID of the device.
        :type device_id: str
        :param udid: The unique id returned from `Data Upload API <https://docs.microsoft.com/en-
         us/rest/api/maps/data/uploadPreview>`_ after uploading a valid GeoJSON FeatureCollection
         object. Please refer to `RFC 7946 <https://tools.ietf.org/html/rfc7946#section-3.3>`_ for
         details. All the feature's  properties should contain ``geometryId``\ , which is used for
         identifying the geometry and is case-sensitive.
        :type udid: str
        :param position: Parameter group.
        :type position: ~azure.maps.creator.models.Position
        :param format: Desired format of the response. Only ``json`` format is supported.
        :type format: str or ~azure.maps.creator.models.JsonFormat
        :param altitude: The sea level in meter of the location being passed. If this parameter is
         presented, 2D extrusion is used. Example: 200.
        :type altitude: float
        :param user_time: The user request time. If not presented in the request, the default value is
         DateTime.Now.
        :type user_time: ~datetime.datetime
        :param search_buffer_in_meters: The radius of the buffer around the geofence in meters that
         defines how far to search inside and outside the border of the fence against the coordinate
         that was provided when calculating the result.  The minimum value is 0, and the maximum is 500.
         The default value is 50.
        :type search_buffer_in_meters: float
        :param is_async: If true, the request will use async event mechanism; if false, the request
         will be synchronized and do not trigger any event. The default value is false.
        :type is_async: bool
        :param mode: Mode of the geofencing async event mechanism.
        :type mode: str or ~azure.maps.creator.models.GeofenceMode
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: Geofence, or the result of cls(response)
        :rtype: ~azure.maps.creator.models.Geofence
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType["models.Geofence"]
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}))
        
        _latitude = None
        _longitude = None
        if position is not None:
            _latitude = position.latitude
            _longitude = position.longitude
        api_version = "1.0"
        accept = "application/json"

        # Construct URL
        url = self.get_geofence.metadata['url']  # type: ignore
        path_format_arguments = {
            'geography': self._serialize.url("self._config.geography", self._config.geography, 'str'),
            'format': self._serialize.url("format", format, 'str'),
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]
        query_parameters['api-version'] = self._serialize.query("api_version", api_version, 'str')
        query_parameters['deviceId'] = self._serialize.query("device_id", device_id, 'str')
        query_parameters['udid'] = self._serialize.query("udid", udid, 'str')
        query_parameters['lat'] = self._serialize.query("latitude", _latitude, 'float')
        query_parameters['lon'] = self._serialize.query("longitude", _longitude, 'float')
        if altitude is not None:
            query_parameters['z'] = self._serialize.query("altitude", altitude, 'float')
        if user_time is not None:
            query_parameters['userTime'] = self._serialize.query("user_time", user_time, 'iso-8601')
        if search_buffer_in_meters is not None:
            query_parameters['searchBuffer'] = self._serialize.query("search_buffer_in_meters", search_buffer_in_meters, 'float', maximum=500, minimum=0)
        if is_async is not None:
            query_parameters['isAsync'] = self._serialize.query("is_async", is_async, 'bool')
        if mode is not None:
            query_parameters['mode'] = self._serialize.query("mode", mode, 'str')

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]
        if self._config.client_id is not None:
            header_parameters['x-ms-client-id'] = self._serialize.header("self._config.client_id", self._config.client_id, 'str')
        header_parameters['Accept'] = self._serialize.header("accept", accept, 'str')

        request = self._client.get(url, query_parameters, header_parameters)
        pipeline_response = await self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize(models.ErrorResponse, response)
            raise HttpResponseError(response=response, model=error)

        response_headers = {}
        response_headers['X-Correlation-id']=self._deserialize('str', response.headers.get('X-Correlation-id'))
        deserialized = self._deserialize('Geofence', pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, response_headers)

        return deserialized
    get_geofence.metadata = {'url': '/spatial/geofence/{format}'}  # type: ignore

    async def post_geofence(
        self,
        device_id: str,
        search_geofence_request_body: "models.GeoJsonFeatureCollection",
        position: "models.Position",
        format: Union[str, "models.JsonFormat"] = "json",
        altitude: Optional[float] = None,
        user_time: Optional[datetime.datetime] = None,
        search_buffer: Optional[float] = None,
        is_async: Optional[bool] = None,
        mode: Optional[Union[str, "models.GeofenceMode"]] = None,
        **kwargs
    ) -> "models.Geofence":
        """**Search Geofence Post API**
        **Applies to:** S1 Pricing tier.
        The Geofence Post API allows you to retrieve the proximity of a coordinate to a  provided
        geofence or set of fences. With POST call, you do not have to upload the fence data in advance,
        instead you supply the location of the object you are tracking in query parameters as well as
        the fence or set of fences data in post request body. See `Geofencing GeoJSON data
        <https://docs.microsoft.com/en-us/azure/azure-maps/geofence-geojson>`_ for more details on the
        geofence data format. The response will contain information about the distance from the outer
        edge of the geofence. A negative value signifies that the  coordinate is inside of the fence
        while a positive value means that it is outside of the fence.:code:`<br>`:code:`<br>`This API
        can be used for a variety of scenarios that include things like asset  tracking, fleet
        management, or setting up alerts for moving objects.

        The API supports `integration with Event Grid <https://docs.microsoft.com/azure/azure-
        maps/azure-maps-event-grid-integration>`_.  The isAsync parameter is used to enable integration
        with Event Grid (disabled by default).

        :param device_id: ID of the device.
        :type device_id: str
        :param search_geofence_request_body: The geofencing GeoJSON data.
        :type search_geofence_request_body: ~azure.maps.creator.models.GeoJsonFeatureCollection
        :param position: Parameter group.
        :type position: ~azure.maps.creator.models.Position
        :param format: Desired format of the response. Only ``json`` format is supported.
        :type format: str or ~azure.maps.creator.models.JsonFormat
        :param altitude: The sea level in meter of the location being passed. If this parameter is
         presented, 2D extrusion geofencing is applied. Example: 200.
        :type altitude: float
        :param user_time: The user request time. If not presented in the request, the default value is
         DateTime.UtcNow.
        :type user_time: ~datetime.datetime
        :param search_buffer: The radius of the buffer around the geofence in meters that defines how
         far to search inside and outside the border of the fence against the coordinate that was
         provided when calculating the result.  The minimum value is 0, and the maximum is 500.  The
         default value is 50.
        :type search_buffer: float
        :param is_async: If true, the request will use async event mechanism; if false, the request
         will be synchronized and do not trigger any event. The default value is false.
        :type is_async: bool
        :param mode: Mode of the geofencing async event mechanism.
        :type mode: str or ~azure.maps.creator.models.GeofenceMode
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: Geofence, or the result of cls(response)
        :rtype: ~azure.maps.creator.models.Geofence
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType["models.Geofence"]
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}))
        
        _latitude = None
        _longitude = None
        if position is not None:
            _latitude = position.latitude
            _longitude = position.longitude
        api_version = "1.0"
        content_type = kwargs.pop("content_type", "application/json")
        accept = "application/json"

        # Construct URL
        url = self.post_geofence.metadata['url']  # type: ignore
        path_format_arguments = {
            'geography': self._serialize.url("self._config.geography", self._config.geography, 'str'),
            'format': self._serialize.url("format", format, 'str'),
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]
        query_parameters['api-version'] = self._serialize.query("api_version", api_version, 'str')
        query_parameters['deviceId'] = self._serialize.query("device_id", device_id, 'str')
        query_parameters['lat'] = self._serialize.query("latitude", _latitude, 'float')
        query_parameters['lon'] = self._serialize.query("longitude", _longitude, 'float')
        if altitude is not None:
            query_parameters['z'] = self._serialize.query("altitude", altitude, 'float')
        if user_time is not None:
            query_parameters['userTime'] = self._serialize.query("user_time", user_time, 'iso-8601')
        if search_buffer is not None:
            query_parameters['searchBuffer'] = self._serialize.query("search_buffer", search_buffer, 'float', maximum=500, minimum=0)
        if is_async is not None:
            query_parameters['isAsync'] = self._serialize.query("is_async", is_async, 'bool')
        if mode is not None:
            query_parameters['mode'] = self._serialize.query("mode", mode, 'str')

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]
        if self._config.client_id is not None:
            header_parameters['x-ms-client-id'] = self._serialize.header("self._config.client_id", self._config.client_id, 'str')
        header_parameters['Content-Type'] = self._serialize.header("content_type", content_type, 'str')
        header_parameters['Accept'] = self._serialize.header("accept", accept, 'str')

        body_content_kwargs = {}  # type: Dict[str, Any]
        body_content = self._serialize.body(search_geofence_request_body, 'GeoJsonFeatureCollection')
        body_content_kwargs['content'] = body_content
        request = self._client.post(url, query_parameters, header_parameters, **body_content_kwargs)
        pipeline_response = await self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize(models.ErrorResponse, response)
            raise HttpResponseError(response=response, model=error)

        response_headers = {}
        response_headers['X-Correlation-id']=self._deserialize('str', response.headers.get('X-Correlation-id'))
        deserialized = self._deserialize('Geofence', pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, response_headers)

        return deserialized
    post_geofence.metadata = {'url': '/spatial/geofence/{format}'}  # type: ignore

    async def post_buffer(
        self,
        buffer_request_body: "models.BufferRequestBody",
        format: Union[str, "models.JsonFormat"] = "json",
        **kwargs
    ) -> "models.BufferResult":
        """**Applies to**\ : S1 pricing tier.

        This API returns a FeatureCollection where each Feature is a buffer around the corresponding
        indexed Feature of the input. The buffer could be either on the outside or the inside of the
        provided Feature, depending on the distance provided in the input. There must be either one
        distance provided per Feature in the FeatureCollection  input, or if only one distance is
        provided, then that distance is applied to every Feature in the collection. The positive (or
        negative) buffer of a geometry is defined as the Minkowski sum (or difference) of the geometry
        with a circle of radius equal to the absolute value of the buffer distance. The buffer API
        always returns a polygonal result. The negative or zero-distance buffer of lines and points is
        always an empty polygon. The input may contain a collection of Point, MultiPoint, Polygon,
        MultiPolygon, LineString and MultiLineString. GeometryCollection will be ignored if provided.

        :param buffer_request_body: The FeatureCollection and the list of distances (one per feature or
         one for all features).
        :type buffer_request_body: ~azure.maps.creator.models.BufferRequestBody
        :param format: Desired format of the response. Only ``json`` format is supported.
        :type format: str or ~azure.maps.creator.models.JsonFormat
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: BufferResult, or the result of cls(response)
        :rtype: ~azure.maps.creator.models.BufferResult
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType["models.BufferResult"]
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}))
        api_version = "1.0"
        content_type = kwargs.pop("content_type", "application/json")
        accept = "application/json"

        # Construct URL
        url = self.post_buffer.metadata['url']  # type: ignore
        path_format_arguments = {
            'geography': self._serialize.url("self._config.geography", self._config.geography, 'str'),
            'format': self._serialize.url("format", format, 'str'),
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]
        query_parameters['api-version'] = self._serialize.query("api_version", api_version, 'str')

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]
        if self._config.client_id is not None:
            header_parameters['x-ms-client-id'] = self._serialize.header("self._config.client_id", self._config.client_id, 'str')
        header_parameters['Content-Type'] = self._serialize.header("content_type", content_type, 'str')
        header_parameters['Accept'] = self._serialize.header("accept", accept, 'str')

        body_content_kwargs = {}  # type: Dict[str, Any]
        body_content = self._serialize.body(buffer_request_body, 'BufferRequestBody')
        body_content_kwargs['content'] = body_content
        request = self._client.post(url, query_parameters, header_parameters, **body_content_kwargs)
        pipeline_response = await self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize(models.ErrorResponse, response)
            raise HttpResponseError(response=response, model=error)

        deserialized = self._deserialize('BufferResult', pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized
    post_buffer.metadata = {'url': '/spatial/buffer/{format}'}  # type: ignore

    async def get_buffer(
        self,
        udid: str,
        distances: str,
        format: Union[str, "models.JsonFormat"] = "json",
        **kwargs
    ) -> "models.BufferResult":
        """**Applies to**\ : S1 pricing tier.

        This API returns a FeatureCollection where each Feature is a buffer around the corresponding
        indexed Feature of the input. The buffer could be either on the outside or the inside of the
        provided Feature, depending on the distance provided in the input. There must be either one
        distance provided per Feature in the FeatureCollection  input, or if only one distance is
        provided, then that distance is applied to every Feature in the collection. The positive (or
        negative) buffer of a geometry is defined as the Minkowski sum (or difference) of the geometry
        with a circle of radius equal to the absolute value of the buffer distance. The buffer API
        always returns a polygonal result. The negative or zero-distance buffer of lines and points is
        always an empty polygon. The input features are provided by a GeoJSON file which is uploaded
        via `Data Upload API <https://docs.microsoft.com/en-us/rest/api/maps/data/uploadPreview>`_ and
        referenced by a unique udid. The GeoJSON file may contain a collection of Point, MultiPoint,
        Polygon, MultiPolygon, LineString and MultiLineString. GeometryCollection will be ignored if
        provided.

        To test this API, you can upload the sample data from `Post Buffer API
        <https://docs.microsoft.com/en-us/rest/api/maps/spatial/postbuffer#examples>`_ examples(Request
        Body without distances array) via `Data Upload API <https://docs.microsoft.com/en-
        us/rest/api/maps/data/uploadPreview>`_ and replace the [udid] from the `sample request below
        <https://docs.microsoft.com/en-us/rest/api/maps/spatial/getbuffer#examples>`_ with the udid
        returned by Data Upload API.

        :param udid: The unique id returned from `Data Upload API <https://docs.microsoft.com/en-
         us/rest/api/maps/data/uploadPreview>`_ after uploading a valid GeoJSON FeatureCollection
         object.  Please refer to `RFC 7946 <https://tools.ietf.org/html/rfc7946#section-3.3>`_ for
         details. All the feature's properties should contain ``geometryId``\ , which is used for
         identifying the geometry and is case-sensitive.
        :type udid: str
        :param distances: The list of distances (one per feature or one for all features), delimited by
         semicolons. For example, 12.34;-56.78. Positive distance will generate a buffer outside of the
         feature, whereas negative distance will generate a buffer inside of the feature. If the
         negative distance larger than the geometry itself, an empty polygon will be returned.
        :type distances: str
        :param format: Desired format of the response. Only ``json`` format is supported.
        :type format: str or ~azure.maps.creator.models.JsonFormat
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: BufferResult, or the result of cls(response)
        :rtype: ~azure.maps.creator.models.BufferResult
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType["models.BufferResult"]
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}))
        api_version = "1.0"
        accept = "application/json"

        # Construct URL
        url = self.get_buffer.metadata['url']  # type: ignore
        path_format_arguments = {
            'geography': self._serialize.url("self._config.geography", self._config.geography, 'str'),
            'format': self._serialize.url("format", format, 'str'),
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]
        query_parameters['api-version'] = self._serialize.query("api_version", api_version, 'str')
        query_parameters['udid'] = self._serialize.query("udid", udid, 'str')
        query_parameters['distances'] = self._serialize.query("distances", distances, 'str')

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]
        if self._config.client_id is not None:
            header_parameters['x-ms-client-id'] = self._serialize.header("self._config.client_id", self._config.client_id, 'str')
        header_parameters['Accept'] = self._serialize.header("accept", accept, 'str')

        request = self._client.get(url, query_parameters, header_parameters)
        pipeline_response = await self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize(models.ErrorResponse, response)
            raise HttpResponseError(response=response, model=error)

        deserialized = self._deserialize('BufferResult', pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized
    get_buffer.metadata = {'url': '/spatial/buffer/{format}'}  # type: ignore

    async def post_closest_point(
        self,
        closest_point_request_body: "models.GeoJsonFeatureCollection",
        position: "models.Position",
        format: Union[str, "models.JsonFormat"] = "json",
        number_of_closest_points: Optional[int] = None,
        **kwargs
    ) -> "models.ClosestPointResponse":
        """**Applies to**\ : S1 pricing tier.

        This API returns the closest point between a base point and a given set of target points. The
        set of target points is provided by user data in post request body. The user data may only
        contain a collection of Point geometry. MultiPoint or other geometries will be ignored if
        provided. The algorithm does not take into account routing or traffic. The maximum number of
        points accepted is 100,000. Information returned includes closest point latitude, longitude,
        and distance in meters from the closest point.

        :param closest_point_request_body: The FeatureCollection of Point geometries from which closest
         point to source point should be determined. All the feature's properties should contain
         ``geometryId``\ , which is used for identifying the geometry and is case-sensitive.
        :type closest_point_request_body: ~azure.maps.creator.models.GeoJsonFeatureCollection
        :param position: Parameter group.
        :type position: ~azure.maps.creator.models.Position
        :param format: Desired format of the response. Only ``json`` format is supported.
        :type format: str or ~azure.maps.creator.models.JsonFormat
        :param number_of_closest_points: The number of closest points expected from response. Default:
         1, minimum: 1 and maximum: 50.
        :type number_of_closest_points: int
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: ClosestPointResponse, or the result of cls(response)
        :rtype: ~azure.maps.creator.models.ClosestPointResponse
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType["models.ClosestPointResponse"]
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}))
        
        _latitude = None
        _longitude = None
        if position is not None:
            _latitude = position.latitude
            _longitude = position.longitude
        api_version = "1.0"
        content_type = kwargs.pop("content_type", "application/json")
        accept = "application/json"

        # Construct URL
        url = self.post_closest_point.metadata['url']  # type: ignore
        path_format_arguments = {
            'geography': self._serialize.url("self._config.geography", self._config.geography, 'str'),
            'format': self._serialize.url("format", format, 'str'),
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]
        query_parameters['api-version'] = self._serialize.query("api_version", api_version, 'str')
        query_parameters['lat'] = self._serialize.query("latitude", _latitude, 'float')
        query_parameters['lon'] = self._serialize.query("longitude", _longitude, 'float')
        if number_of_closest_points is not None:
            query_parameters['numberOfClosestPoints'] = self._serialize.query("number_of_closest_points", number_of_closest_points, 'int')

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]
        if self._config.client_id is not None:
            header_parameters['x-ms-client-id'] = self._serialize.header("self._config.client_id", self._config.client_id, 'str')
        header_parameters['Content-Type'] = self._serialize.header("content_type", content_type, 'str')
        header_parameters['Accept'] = self._serialize.header("accept", accept, 'str')

        body_content_kwargs = {}  # type: Dict[str, Any]
        body_content = self._serialize.body(closest_point_request_body, 'GeoJsonFeatureCollection')
        body_content_kwargs['content'] = body_content
        request = self._client.post(url, query_parameters, header_parameters, **body_content_kwargs)
        pipeline_response = await self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize(models.ErrorResponse, response)
            raise HttpResponseError(response=response, model=error)

        deserialized = self._deserialize('ClosestPointResponse', pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized
    post_closest_point.metadata = {'url': '/spatial/closestPoint/{format}'}  # type: ignore

    async def get_closest_point(
        self,
        udid: str,
        position: "models.Position",
        format: Union[str, "models.JsonFormat"] = "json",
        number_of_closest_points: Optional[int] = None,
        **kwargs
    ) -> "models.ClosestPointResponse":
        """**Applies to**\ : S1 pricing tier.

        This API returns the closest point between a base point and a given set of points in the user
        uploaded data set identified by udid. The set of target points is provided by a GeoJSON file
        which is uploaded via `Data Upload API <https://docs.microsoft.com/en-
        us/rest/api/maps/data/uploadPreview>`_ and referenced by a unique udid. The GeoJSON file may
        only contain a collection of Point geometry. MultiPoint or other geometries will be ignored if
        provided. The maximum number of points accepted is 100,000. The algorithm does not take into
        account routing or traffic. Information returned includes closest point latitude, longitude,
        and distance in meters from the closest point.

        To test this API, you can upload the sample data from `Post Closest Point API
        <https://docs.microsoft.com/en-us/rest/api/maps/spatial/postclosestpoint#examples>`_
        examples(Request Body) via `Data Upload API <https://docs.microsoft.com/en-
        us/rest/api/maps/data/uploadPreview>`_ and replace the [udid] from the `sample request below
        <https://docs.microsoft.com/en-us/rest/api/maps/spatial/getclosestpoint#examples>`_ with the
        udid returned by Data Upload API.

        :param udid: The unique id returned from `Data Upload API <https://docs.microsoft.com/en-
         us/rest/api/maps/data/uploadPreview>`_ after uploading a valid GeoJSON FeatureCollection
         object.  Please refer to `RFC 7946 <https://tools.ietf.org/html/rfc7946#section-3.3>`_ for
         details. All the feature's properties should contain ``geometryId``\ , which is used for
         identifying the geometry and is case-sensitive.
        :type udid: str
        :param position: Parameter group.
        :type position: ~azure.maps.creator.models.Position
        :param format: Desired format of the response. Only ``json`` format is supported.
        :type format: str or ~azure.maps.creator.models.JsonFormat
        :param number_of_closest_points: The number of closest points expected from response. Default:
         1, minimum: 1 and maximum: 50.
        :type number_of_closest_points: int
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: ClosestPointResponse, or the result of cls(response)
        :rtype: ~azure.maps.creator.models.ClosestPointResponse
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType["models.ClosestPointResponse"]
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}))
        
        _latitude = None
        _longitude = None
        if position is not None:
            _latitude = position.latitude
            _longitude = position.longitude
        api_version = "1.0"
        accept = "application/json"

        # Construct URL
        url = self.get_closest_point.metadata['url']  # type: ignore
        path_format_arguments = {
            'geography': self._serialize.url("self._config.geography", self._config.geography, 'str'),
            'format': self._serialize.url("format", format, 'str'),
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]
        query_parameters['api-version'] = self._serialize.query("api_version", api_version, 'str')
        query_parameters['udid'] = self._serialize.query("udid", udid, 'str')
        query_parameters['lat'] = self._serialize.query("latitude", _latitude, 'float')
        query_parameters['lon'] = self._serialize.query("longitude", _longitude, 'float')
        if number_of_closest_points is not None:
            query_parameters['numberOfClosestPoints'] = self._serialize.query("number_of_closest_points", number_of_closest_points, 'int')

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]
        if self._config.client_id is not None:
            header_parameters['x-ms-client-id'] = self._serialize.header("self._config.client_id", self._config.client_id, 'str')
        header_parameters['Accept'] = self._serialize.header("accept", accept, 'str')

        request = self._client.get(url, query_parameters, header_parameters)
        pipeline_response = await self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize(models.ErrorResponse, response)
            raise HttpResponseError(response=response, model=error)

        deserialized = self._deserialize('ClosestPointResponse', pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized
    get_closest_point.metadata = {'url': '/spatial/closestPoint/{format}'}  # type: ignore

    async def post_point_in_polygon(
        self,
        point_in_polygon_request_body: "models.GeoJsonFeatureCollection",
        position: "models.Position",
        format: Union[str, "models.JsonFormat"] = "json",
        **kwargs
    ) -> "models.PointInPolygonResult":
        """**Applies to**\ : S1 pricing tier.

        This API returns a boolean value indicating whether a point is inside a set of polygons. The
        user data may contain Polygon and MultiPolygon geometries, other geometries will be ignored if
        provided. If the point is inside or on the boundary of one of these polygons, the value
        returned is true. In all other cases, the value returned is false. When the point is inside
        multiple polygons, the result will give intersecting geometries section to show all valid
        geometries (referenced by geometryId) in user data. The maximum number of vertices accepted to
        form a Polygon is 10,000.

        :param point_in_polygon_request_body: A FeatureCollection with a set of Polygon/MultiPolygon
         geometries. The maximum number of vertices accepted to form a Polygon is 10,000. All the
         feature's properties should contain ``geometryId``\ , which is used for identifying the
         geometry and is case-sensitive.
        :type point_in_polygon_request_body: ~azure.maps.creator.models.GeoJsonFeatureCollection
        :param position: Parameter group.
        :type position: ~azure.maps.creator.models.Position
        :param format: Desired format of the response. Only ``json`` format is supported.
        :type format: str or ~azure.maps.creator.models.JsonFormat
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: PointInPolygonResult, or the result of cls(response)
        :rtype: ~azure.maps.creator.models.PointInPolygonResult
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType["models.PointInPolygonResult"]
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}))
        
        _latitude = None
        _longitude = None
        if position is not None:
            _latitude = position.latitude
            _longitude = position.longitude
        api_version = "1.0"
        content_type = kwargs.pop("content_type", "application/json")
        accept = "application/json"

        # Construct URL
        url = self.post_point_in_polygon.metadata['url']  # type: ignore
        path_format_arguments = {
            'geography': self._serialize.url("self._config.geography", self._config.geography, 'str'),
            'format': self._serialize.url("format", format, 'str'),
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]
        query_parameters['api-version'] = self._serialize.query("api_version", api_version, 'str')
        query_parameters['lat'] = self._serialize.query("latitude", _latitude, 'float')
        query_parameters['lon'] = self._serialize.query("longitude", _longitude, 'float')

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]
        if self._config.client_id is not None:
            header_parameters['x-ms-client-id'] = self._serialize.header("self._config.client_id", self._config.client_id, 'str')
        header_parameters['Content-Type'] = self._serialize.header("content_type", content_type, 'str')
        header_parameters['Accept'] = self._serialize.header("accept", accept, 'str')

        body_content_kwargs = {}  # type: Dict[str, Any]
        body_content = self._serialize.body(point_in_polygon_request_body, 'GeoJsonFeatureCollection')
        body_content_kwargs['content'] = body_content
        request = self._client.post(url, query_parameters, header_parameters, **body_content_kwargs)
        pipeline_response = await self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize(models.ErrorResponse, response)
            raise HttpResponseError(response=response, model=error)

        deserialized = self._deserialize('PointInPolygonResult', pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized
    post_point_in_polygon.metadata = {'url': '/spatial/pointInPolygon/{format}'}  # type: ignore

    async def evaluate_point_in_polygon(
        self,
        udid: str,
        position: "models.Position",
        format: Union[str, "models.JsonFormat"] = "json",
        **kwargs
    ) -> "models.PointInPolygonResult":
        """**Applies to**\ : S1 pricing tier.

        This API returns a boolean value indicating whether a point is inside a set of polygons. The
        set of polygons is provided by a GeoJSON file which is uploaded via `Data Upload API
        <https://docs.microsoft.com/en-us/rest/api/maps/data/uploadPreview>`_ and referenced by a
        unique udid. The GeoJSON file may contain Polygon and MultiPolygon geometries, other geometries
        will be ignored if provided. If the point is inside or on the boundary of one of these
        polygons, the value returned is true. In all other cases, the value returned is false. When the
        point is inside multiple polygons, the result will give intersecting geometries section to show
        all valid geometries(referenced by geometryId) in user data. The maximum number of vertices
        accepted to form a Polygon is 10,000.

        To test this API, you can upload the sample data from `Post Point In Polygon API
        <https://docs.microsoft.com/en-us/rest/api/maps/spatial/postpointinpolygon#examples>`_
        examples(Request Body) via `Data Upload API <https://docs.microsoft.com/en-
        us/rest/api/maps/data/uploadPreview>`_ and replace the [udid] from the `sample request below
        <https://docs.microsoft.com/en-us/rest/api/maps/spatial/getpointinpolygon#examples>`_ with the
        udid returned by Data Upload API.

        :param udid: The unique id returned from `Data Upload API <https://docs.microsoft.com/en-
         us/rest/api/maps/data/uploadPreview>`_ after uploading a valid GeoJSON FeatureCollection
         object.  Please refer to `RFC 7946 <https://tools.ietf.org/html/rfc7946#section-3.3>`_ for
         details. All the feature's properties should contain ``geometryId``\ , which is used for
         identifying the geometry and is case-sensitive.
        :type udid: str
        :param position: Parameter group.
        :type position: ~azure.maps.creator.models.Position
        :param format: Desired format of the response. Only ``json`` format is supported.
        :type format: str or ~azure.maps.creator.models.JsonFormat
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: PointInPolygonResult, or the result of cls(response)
        :rtype: ~azure.maps.creator.models.PointInPolygonResult
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType["models.PointInPolygonResult"]
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}))
        
        _latitude = None
        _longitude = None
        if position is not None:
            _latitude = position.latitude
            _longitude = position.longitude
        api_version = "1.0"
        accept = "application/json"

        # Construct URL
        url = self.evaluate_point_in_polygon.metadata['url']  # type: ignore
        path_format_arguments = {
            'geography': self._serialize.url("self._config.geography", self._config.geography, 'str'),
            'format': self._serialize.url("format", format, 'str'),
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]
        query_parameters['api-version'] = self._serialize.query("api_version", api_version, 'str')
        query_parameters['udid'] = self._serialize.query("udid", udid, 'str')
        query_parameters['lat'] = self._serialize.query("latitude", _latitude, 'float')
        query_parameters['lon'] = self._serialize.query("longitude", _longitude, 'float')

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]
        if self._config.client_id is not None:
            header_parameters['x-ms-client-id'] = self._serialize.header("self._config.client_id", self._config.client_id, 'str')
        header_parameters['Accept'] = self._serialize.header("accept", accept, 'str')

        request = self._client.get(url, query_parameters, header_parameters)
        pipeline_response = await self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize(models.ErrorResponse, response)
            raise HttpResponseError(response=response, model=error)

        deserialized = self._deserialize('PointInPolygonResult', pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized
    evaluate_point_in_polygon.metadata = {'url': '/spatial/pointInPolygon/{format}'}  # type: ignore

    async def get_great_circle_distance(
        self,
        query: str,
        format: Union[str, "models.JsonFormat"] = "json",
        **kwargs
    ) -> "models.GreatCircleDistanceResult":
        """**Applies to**\ : S1 pricing tier.

        This API will return the great-circle or shortest distance between two points on the surface of
        a sphere, measured along the surface of the sphere.  This differs from calculating a straight
        line through the sphere's interior. This method is helpful for estimating travel distances for
        airplanes by calculating the shortest distance between airports.

        :param query: The Coordinates through which the distance is calculated, delimited by a colon.
         Two coordinates are required.  The first one is the source point coordinate and the last is the
         target point coordinate. For example, 47.622942,122.316456:57.673988,127.121513.
        :type query: str
        :param format: Desired format of the response. Only ``json`` format is supported.
        :type format: str or ~azure.maps.creator.models.JsonFormat
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: GreatCircleDistanceResult, or the result of cls(response)
        :rtype: ~azure.maps.creator.models.GreatCircleDistanceResult
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType["models.GreatCircleDistanceResult"]
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}))
        api_version = "1.0"
        accept = "application/json"

        # Construct URL
        url = self.get_great_circle_distance.metadata['url']  # type: ignore
        path_format_arguments = {
            'geography': self._serialize.url("self._config.geography", self._config.geography, 'str'),
            'format': self._serialize.url("format", format, 'str'),
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]
        query_parameters['api-version'] = self._serialize.query("api_version", api_version, 'str')
        query_parameters['query'] = self._serialize.query("query", query, 'str')

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]
        if self._config.client_id is not None:
            header_parameters['x-ms-client-id'] = self._serialize.header("self._config.client_id", self._config.client_id, 'str')
        header_parameters['Accept'] = self._serialize.header("accept", accept, 'str')

        request = self._client.get(url, query_parameters, header_parameters)
        pipeline_response = await self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize(models.ErrorResponse, response)
            raise HttpResponseError(response=response, model=error)

        deserialized = self._deserialize('GreatCircleDistanceResult', pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized
    get_great_circle_distance.metadata = {'url': '/spatial/greatCircleDistance/{format}'}  # type: ignore
