# coding=utf-8
# --------------------------------------------------------------------------
# Copyright (c) Microsoft Corporation. All rights reserved.
# Licensed under the MIT License. See License.txt in the project root for license information.
# Code generated by Microsoft (R) AutoRest Code Generator.
# Changes may cause incorrect behavior and will be lost if the code is regenerated.
# --------------------------------------------------------------------------
from typing import Any, Callable, Dict, Generic, IO, Optional, TypeVar, Union
import warnings

from azure.core.exceptions import ClientAuthenticationError, HttpResponseError, ResourceExistsError, ResourceNotFoundError, map_error
from azure.core.pipeline import PipelineResponse
from azure.core.pipeline.transport import AsyncHttpResponse, HttpRequest
from azure.core.polling import AsyncLROPoller, AsyncNoPolling, AsyncPollingMethod
from azure.core.polling.async_base_polling import AsyncLROBasePolling

from ... import models as _models

T = TypeVar('T')
ClsType = Optional[Callable[[PipelineResponse[HttpRequest, AsyncHttpResponse], T, Dict[str, Any]], Any]]

class DataOperations:
    """DataOperations async operations.

    You should not instantiate this class directly. Instead, you should create a Client instance that
    instantiates it for you and attaches it as an attribute.

    :ivar models: Alias to model classes used in this operation group.
    :type models: ~azure.maps.creator.models
    :param client: Client for service requests.
    :param config: Configuration of service client.
    :param serializer: An object model serializer.
    :param deserializer: An object model deserializer.
    """

    models = _models

    def __init__(self, client, config, serializer, deserializer) -> None:
        self._client = client
        self._serialize = serializer
        self._deserialize = deserializer
        self._config = config

    async def _upload_preview_initial(
        self,
        upload_data_format: Union[str, "_models.UploadDataFormat"],
        upload_content: Union[IO, Any],
        upload_data_description: Optional[str] = None,
        **kwargs: Any
    ) -> Optional["_models.LongRunningOperationResult"]:
        cls = kwargs.pop('cls', None)  # type: ClsType[Optional["_models.LongRunningOperationResult"]]
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: lambda response: ResourceExistsError(response=response, model=self._deserialize(_models.ErrorResponse, response)),
        }
        error_map.update(kwargs.pop('error_map', {}))
        api_version = "2.0"
        content_type = kwargs.pop("content_type", "application/octet-stream")
        accept = "application/json"

        # Construct URL
        url = self._upload_preview_initial.metadata['url']  # type: ignore
        path_format_arguments = {
            'geography': self._serialize.url("self._config.geography", self._config.geography, 'str'),
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]
        query_parameters['api-version'] = self._serialize.query("api_version", api_version, 'str')
        if upload_data_description is not None:
            query_parameters['description'] = self._serialize.query("upload_data_description", upload_data_description, 'str')
        query_parameters['dataFormat'] = self._serialize.query("upload_data_format", upload_data_format, 'str')

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]
        if self._config.x_ms_client_id is not None:
            header_parameters['x-ms-client-id'] = self._serialize.header("self._config.x_ms_client_id", self._config.x_ms_client_id, 'str')
        header_parameters['Content-Type'] = self._serialize.header("content_type", content_type, 'str')
        header_parameters['Accept'] = self._serialize.header("accept", accept, 'str')

        body_content_kwargs = {}  # type: Dict[str, Any]
        if header_parameters['Content-Type'].split(";")[0] in ['application/octet-stream']:
            body_content_kwargs['stream_content'] = upload_content
        elif header_parameters['Content-Type'].split(";")[0] in ['application/json']:
            body_content = self._serialize.body(upload_content, 'object')
            body_content_kwargs['content'] = body_content
        else:
            raise ValueError(
                "The content_type '{}' is not one of the allowed values: "
                "['application/octet-stream', 'application/json']".format(header_parameters['Content-Type'])
            )
        request = self._client.post(url, query_parameters, header_parameters, **body_content_kwargs)
        pipeline_response = await self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [200, 202]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize.failsafe_deserialize(_models.ErrorResponse, response)
            raise HttpResponseError(response=response, model=error)

        response_headers = {}
        deserialized = None
        if response.status_code == 200:
            response_headers['Resource-Location']=self._deserialize('str', response.headers.get('Resource-Location'))
            deserialized = self._deserialize('LongRunningOperationResult', pipeline_response)

        if response.status_code == 202:
            response_headers['Operation-Location']=self._deserialize('str', response.headers.get('Operation-Location'))

        if cls:
            return cls(pipeline_response, deserialized, response_headers)

        return deserialized
    _upload_preview_initial.metadata = {'url': '/mapData'}  # type: ignore

    async def begin_upload_preview(
        self,
        upload_data_format: Union[str, "_models.UploadDataFormat"],
        upload_content: Union[IO, Any],
        upload_data_description: Optional[str] = None,
        **kwargs: Any
    ) -> AsyncLROPoller["_models.LongRunningOperationResult"]:
        """**Applies to:** see pricing `tiers <https://aka.ms/AzureMapsPricingTier>`_.

        The Data Upload API allows the caller to upload data content to the Azure Maps service.
        You can use this API in a scenario like uploading a collection of Geofences in ``GeoJSON``
        format, for use in our `Azure Maps Geofencing Service
        <https://docs.microsoft.com/rest/api/maps/spatial>`_.

        Submit Upload Request
        ---------------------

        To upload your content you will use a ``POST`` request. The request body will contain the data
        to upload. The
        ``dataFormat`` query parameter will contain the format for the data, the ``dataSharingLevel``
        query parameter
        can contain the sharing level for the data. The ``Content-Type`` header will be set to the
        content type of the
        data.

        For example, to upload a collection of geofences  in ``GeoJSON`` format, set the request body
        to the geofence
        content. Set the ``dataFormat`` query parameter to *geojson*\ , and set the ``Content-Type``
        header to either one
        of the following media types:


        * ``application/json``
        * ``application/vnd.geo+json``
        * ``application/octet-stream``

        Here's a sample request body for uploading a simple Geofence represented as a circle geometry
        using a center
        point and a radius. The sample below is in ``GeoJSON``\ :

        .. code-block:: json

           {
               "type": "FeatureCollection",
               "features": [{
                   "type": "Feature",
                   "geometry": {
                       "type": "Point",
                       "coordinates": [-122.126986, 47.639754]
                   },
                   "properties": {
                       "geometryId": "001",
                       "radius": 500
                   }
               }]
           }

        The Data Upload API performs a
        `long-running request <https://aka.ms/am-creator-lrt-v2>`_.

        Data Upload Limits
        ------------------

        Please, be aware that currently every Azure Maps account has a `data storage limit
        <https://docs.microsoft.com/en-us/azure/azure-resource-manager/management/azure-subscription-service-limits#azure-maps-limits>`_.
        Once the storage limit is reached, all the new upload API calls will return a ``409 Conflict``
        http error response.
        You can always use the `Data Delete API
        <https://docs.microsoft.com/rest/api/maps/data%20v2/deletepreview>`_ to
        delete old/unused content and create space for new uploads.

        :param upload_data_format: Data format of the content being uploaded.
        :type upload_data_format: str or ~azure.maps.creator.models.UploadDataFormat
        :param upload_content: The content to upload.
        :type upload_content: IO or any
        :param upload_data_description: The description to be given to the upload.
        :type upload_data_description: str
        :keyword str content_type: Media type of the body sent to the API. Default value is "application/octet-stream".
         Allowed values are: "application/octet-stream", "application/json".
        :keyword callable cls: A custom type or function that will be passed the direct response
        :keyword str continuation_token: A continuation token to restart a poller from a saved state.
        :keyword polling: By default, your polling method will be AsyncLROBasePolling.
         Pass in False for this operation to not poll, or pass in your own initialized polling object for a personal polling strategy.
        :paramtype polling: bool or ~azure.core.polling.AsyncPollingMethod
        :keyword int polling_interval: Default waiting time between two polls for LRO operations if no Retry-After header is present.
        :return: An instance of AsyncLROPoller that returns either LongRunningOperationResult or the result of cls(response)
        :rtype: ~azure.core.polling.AsyncLROPoller[~azure.maps.creator.models.LongRunningOperationResult]
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        polling = kwargs.pop('polling', True)  # type: Union[bool, AsyncPollingMethod]
        cls = kwargs.pop('cls', None)  # type: ClsType["_models.LongRunningOperationResult"]
        lro_delay = kwargs.pop(
            'polling_interval',
            self._config.polling_interval
        )
        cont_token = kwargs.pop('continuation_token', None)  # type: Optional[str]
        if cont_token is None:
            raw_result = await self._upload_preview_initial(
                upload_data_format=upload_data_format,
                upload_content=upload_content,
                upload_data_description=upload_data_description,
                cls=lambda x,y,z: x,
                **kwargs
            )

        kwargs.pop('error_map', None)
        kwargs.pop('content_type', None)

        def get_long_running_output(pipeline_response):
            response_headers = {}
            response = pipeline_response.http_response
            response_headers['Resource-Location']=self._deserialize('str', response.headers.get('Resource-Location'))
            deserialized = self._deserialize('LongRunningOperationResult', pipeline_response)

            if cls:
                return cls(pipeline_response, deserialized, response_headers)
            return deserialized

        path_format_arguments = {
            'geography': self._serialize.url("self._config.geography", self._config.geography, 'str'),
        }

        if polling is True: polling_method = AsyncLROBasePolling(lro_delay, lro_options={'final-state-via': 'location'}, path_format_arguments=path_format_arguments,  **kwargs)
        elif polling is False: polling_method = AsyncNoPolling()
        else: polling_method = polling
        if cont_token:
            return AsyncLROPoller.from_continuation_token(
                polling_method=polling_method,
                continuation_token=cont_token,
                client=self._client,
                deserialization_callback=get_long_running_output
            )
        else:
            return AsyncLROPoller(self._client, raw_result, get_long_running_output, polling_method)
    begin_upload_preview.metadata = {'url': '/mapData'}  # type: ignore

    async def list_preview(
        self,
        **kwargs: Any
    ) -> "_models.MapDataListResponse":
        """**Applies to:** see pricing `tiers <https://aka.ms/AzureMapsPricingTier>`_.

        This API allows the caller to fetch a list of all content uploaded previously using the `Data
        Upload API <https://docs.microsoft.com/en-us/rest/api/maps/data%20v2/uploadpreview>`_.

        Submit List Request
        ^^^^^^^^^^^^^^^^^^^

        To list all your map data content you will issue a ``GET`` request with no additional
        parameters.

        List Data Response
        ^^^^^^^^^^^^^^^^^^

        The Data List API returns the complete list of all data in ``json`` format. The response
        contains the following details for each data resource:

        ..

           udid - The unique data id for the data resource.

           location - The location of the data resource. Execute a HTTP ``GET`` on this location to
        download the data.


        Here's a sample response returning the ``udid`` and ``location`` of 3 data resources:

        :code:`<br>`

        .. code-block:: json

           {
               "mapDataList":
               [
                   {
                       "udid": "9a1288fa-1858-4a3b-b68d-13a8j5af7d7c",
                       "location":
        "https://us.atlas.microsoft.com/mapData/9a1288fa-1858-4a3b-b68d-13a8j5af7d7c?api-version=1.0",
                       "sizeInBytes": 29920,
                       "uploadStatus": "Completed"
                   },
                   {
                       "udid": "8b1288fa-1958-4a2b-b68e-13a7i5af7d7c",
                       "location":
        "https://us.atlas.microsoft.com/mapData/8b1288fa-1958-4a2b-b68e-13a7i5af7d7c?api-version=1.0",
                       "sizeInBytes": 1339,
                       "uploadStatus": "Completed"
                   },
                   {
                       "udid": "7c1288fa-2058-4a1b-b68f-13a6h5af7d7c",
                       "location":
        "https://us.atlas.microsoft.com/mapData/7c1288fa-2058-4a1b-b68f-13a6h5af7d7c?api-version=1.0",
                       "sizeInBytes": 1650,
                       "uploadStatus": "Pending"
                   }]
           }

        :code:`<br>`.

        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: MapDataListResponse, or the result of cls(response)
        :rtype: ~azure.maps.creator.models.MapDataListResponse
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType["_models.MapDataListResponse"]
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}))
        api_version = "2.0"
        accept = "application/json"

        # Construct URL
        url = self.list_preview.metadata['url']  # type: ignore
        path_format_arguments = {
            'geography': self._serialize.url("self._config.geography", self._config.geography, 'str'),
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]
        query_parameters['api-version'] = self._serialize.query("api_version", api_version, 'str')

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]
        if self._config.x_ms_client_id is not None:
            header_parameters['x-ms-client-id'] = self._serialize.header("self._config.x_ms_client_id", self._config.x_ms_client_id, 'str')
        header_parameters['Accept'] = self._serialize.header("accept", accept, 'str')

        request = self._client.get(url, query_parameters, header_parameters)
        pipeline_response = await self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize.failsafe_deserialize(_models.ErrorResponse, response)
            raise HttpResponseError(response=response, model=error)

        deserialized = self._deserialize('MapDataListResponse', pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized
    list_preview.metadata = {'url': '/mapData'}  # type: ignore

    async def _update_preview_initial(
        self,
        unique_data_id: str,
        update_content: Any,
        upload_data_description: Optional[str] = None,
        **kwargs: Any
    ) -> Optional["_models.LongRunningOperationResult"]:
        cls = kwargs.pop('cls', None)  # type: ClsType[Optional["_models.LongRunningOperationResult"]]
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: lambda response: ResourceExistsError(response=response, model=self._deserialize(_models.ErrorResponse, response)),
        }
        error_map.update(kwargs.pop('error_map', {}))
        api_version = "2.0"
        content_type = kwargs.pop("content_type", "application/json")
        accept = "application/json"

        # Construct URL
        url = self._update_preview_initial.metadata['url']  # type: ignore
        path_format_arguments = {
            'geography': self._serialize.url("self._config.geography", self._config.geography, 'str'),
            'udid': self._serialize.url("unique_data_id", unique_data_id, 'str'),
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]
        query_parameters['api-version'] = self._serialize.query("api_version", api_version, 'str')
        if upload_data_description is not None:
            query_parameters['description'] = self._serialize.query("upload_data_description", upload_data_description, 'str')

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]
        if self._config.x_ms_client_id is not None:
            header_parameters['x-ms-client-id'] = self._serialize.header("self._config.x_ms_client_id", self._config.x_ms_client_id, 'str')
        header_parameters['Content-Type'] = self._serialize.header("content_type", content_type, 'str')
        header_parameters['Accept'] = self._serialize.header("accept", accept, 'str')

        body_content_kwargs = {}  # type: Dict[str, Any]
        body_content = self._serialize.body(update_content, 'object')
        body_content_kwargs['content'] = body_content
        request = self._client.put(url, query_parameters, header_parameters, **body_content_kwargs)
        pipeline_response = await self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [200, 202]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize.failsafe_deserialize(_models.ErrorResponse, response)
            raise HttpResponseError(response=response, model=error)

        response_headers = {}
        deserialized = None
        if response.status_code == 200:
            response_headers['Resource-Location']=self._deserialize('str', response.headers.get('Resource-Location'))
            deserialized = self._deserialize('LongRunningOperationResult', pipeline_response)

        if response.status_code == 202:
            response_headers['Operation-Location']=self._deserialize('str', response.headers.get('Operation-Location'))

        if cls:
            return cls(pipeline_response, deserialized, response_headers)

        return deserialized
    _update_preview_initial.metadata = {'url': '/mapData/{udid}'}  # type: ignore

    async def begin_update_preview(
        self,
        unique_data_id: str,
        update_content: Any,
        upload_data_description: Optional[str] = None,
        **kwargs: Any
    ) -> AsyncLROPoller["_models.LongRunningOperationResult"]:
        """**Applies to:** see pricing `tiers <https://aka.ms/AzureMapsPricingTier>`_.

        The Data Update API allows the caller to update a previously uploaded data content.

        You can use this API in a scenario like adding or removing geofences to or from an existing
        collection of geofences.
        Geofences are uploaded using the `Data Upload API
        <https://docs.microsoft.com/rest/api/maps/data%20v2/uploadpreview>`_\ , for
        use in the `Azure Maps Geofencing Service <https://docs.microsoft.com/rest/api/maps/spatial>`_.

        Please note that the Update API will *replace* and *override* the existing data content.

        Submit Update Request
        ---------------------

        To update your content you will use a ``PUT`` request. The request body will contain the new
        data that will replace
        the existing data. The ``Content-Type`` header will be set to the content type of the data, and
        the path will contain
        the ``udid`` of the data to be update.

        For example, to update a collection of geofences that were previously uploaded using the Upload
        API, place the new
        geofence content in the request body. Set the ``udid`` parameter in the path to the ``udid`` of
        the data received
        previously in the upload API response. And set the ``Content-Type`` header to one of the
        following media types:


        * ``application/json``
        * ``application/vnd.geo+json``
        * ``application/octet-stream``

        Here's a sample request body for updating a simple Geofence. It's represented as a circle
        geometry using a center
        point and a radius. The sample below is in ``GeoJSON``\ :

        .. code-block:: json

           {
               "type": "FeatureCollection",
               "features": [{
                   "type": "Feature",
                   "geometry": {
                       "type": "Point",
                       "coordinates": [-122.126986, 47.639754]
                   },
                   "properties": {
                       "geometryId": "001",
                       "radius": 500
                   }
               }]
           }

        The previously uploaded geofence had a radius of 100m. The above request will update it to
        500m.

        The Data Update API performs a
        `long-running request <https://aka.ms/am-creator-lrt-v2>`_.

        Data Update Limits
        ------------------

        Please, be aware that currently every Azure Maps account has a `data storage limit
        <https://docs.microsoft.com/en-us/azure/azure-resource-manager/management/azure-subscription-service-limits#azure-maps-limits>`_.
        Once the storage limit is reached, all the new upload API calls will return a ``409 Conflict``
        http error response.
        You can always use the `Data Delete API
        <https://docs.microsoft.com/rest/api/maps/data%20v2/deletepreview>`_ to
        delete old/unused content and create space for new uploads.

        :param unique_data_id: The unique data id for the content. The ``udid`` must have been obtained
         from a successful `Data Upload API
         <https://docs.microsoft.com/en-us/rest/api/maps/data%20v2/uploadpreview>`_ call.
        :type unique_data_id: str
        :param update_content: The new content that will update/replace the previously uploaded
         content.
        :type update_content: any
        :param upload_data_description: The description to be given to the upload.
        :type upload_data_description: str
        :keyword callable cls: A custom type or function that will be passed the direct response
        :keyword str continuation_token: A continuation token to restart a poller from a saved state.
        :keyword polling: By default, your polling method will be AsyncLROBasePolling.
         Pass in False for this operation to not poll, or pass in your own initialized polling object for a personal polling strategy.
        :paramtype polling: bool or ~azure.core.polling.AsyncPollingMethod
        :keyword int polling_interval: Default waiting time between two polls for LRO operations if no Retry-After header is present.
        :return: An instance of AsyncLROPoller that returns either LongRunningOperationResult or the result of cls(response)
        :rtype: ~azure.core.polling.AsyncLROPoller[~azure.maps.creator.models.LongRunningOperationResult]
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        polling = kwargs.pop('polling', True)  # type: Union[bool, AsyncPollingMethod]
        cls = kwargs.pop('cls', None)  # type: ClsType["_models.LongRunningOperationResult"]
        lro_delay = kwargs.pop(
            'polling_interval',
            self._config.polling_interval
        )
        cont_token = kwargs.pop('continuation_token', None)  # type: Optional[str]
        if cont_token is None:
            raw_result = await self._update_preview_initial(
                unique_data_id=unique_data_id,
                update_content=update_content,
                upload_data_description=upload_data_description,
                cls=lambda x,y,z: x,
                **kwargs
            )

        kwargs.pop('error_map', None)
        kwargs.pop('content_type', None)

        def get_long_running_output(pipeline_response):
            response_headers = {}
            response = pipeline_response.http_response
            response_headers['Resource-Location']=self._deserialize('str', response.headers.get('Resource-Location'))
            deserialized = self._deserialize('LongRunningOperationResult', pipeline_response)

            if cls:
                return cls(pipeline_response, deserialized, response_headers)
            return deserialized

        path_format_arguments = {
            'geography': self._serialize.url("self._config.geography", self._config.geography, 'str'),
            'udid': self._serialize.url("unique_data_id", unique_data_id, 'str'),
        }

        if polling is True: polling_method = AsyncLROBasePolling(lro_delay, lro_options={'final-state-via': 'location'}, path_format_arguments=path_format_arguments,  **kwargs)
        elif polling is False: polling_method = AsyncNoPolling()
        else: polling_method = polling
        if cont_token:
            return AsyncLROPoller.from_continuation_token(
                polling_method=polling_method,
                continuation_token=cont_token,
                client=self._client,
                deserialization_callback=get_long_running_output
            )
        else:
            return AsyncLROPoller(self._client, raw_result, get_long_running_output, polling_method)
    begin_update_preview.metadata = {'url': '/mapData/{udid}'}  # type: ignore

    async def download_preview(
        self,
        unique_data_id: str,
        **kwargs: Any
    ) -> IO:
        """.. role:: raw-html-m2r(raw)
           :format: html


        **Applies to:** see pricing `tiers <https://aka.ms/AzureMapsPricingTier>`_.

        This API allows the caller to download a previously uploaded data content.:code:`<br>`\
        :raw-html-m2r:`<br>`
        You can use this API in a scenario like downloading an existing collection of geofences
        uploaded previously using the `Data Upload API
        <https://docs.microsoft.com/en-us/rest/api/maps/data%20v2/uploadpreview>`_ for use in our
        `Azure Maps Geofencing Service <https://docs.microsoft.com/en-us/rest/api/maps/spatial>`_.

        Submit Download Request
        ^^^^^^^^^^^^^^^^^^^^^^^

        To download your content you will use a ``GET`` request where the path will contain the
        ``udid`` of the data to download. Optionally, you can also pass in an ``Accept`` header to
        specify a preference for the ``Content-Type`` of the data response. :code:`<br>`
        For example, to download a collection of geofences previously uploaded using the Upload API,
        set the ``udid`` parameter in the path to the ``udid`` of the data received previously in the
        upload API response and set the ``Accept`` header to either one of the following media types:


        * ``application/json``
        * ``application/vnd.geo+json``
        * ``application/octet-stream``

        Download Data Response
        ^^^^^^^^^^^^^^^^^^^^^^

        The Download API will return a HTTP ``200 OK`` response if the data resource with the passed-in
        ``udid`` is found, where the response body will contain the content of the data
        resource.:code:`<br>`
        A HTTP ``400 Bad Request`` error response will be returned if the data resource with the
        passed-in ``udid`` is not found.:code:`<br>`

        Here's a sample response body for a simple geofence represented in ``GeoJSON`` uploaded
        previously using the Upload API:
        :code:`<br>`

        .. code-block:: json

           {
               "type": "FeatureCollection",
               "features": [{
                   "type": "Feature",
                   "geometry": {
                       "type": "Point",
                       "coordinates": [-122.126986, 47.639754]
                   },
                   "properties": {
                       "geometryId": "001",
                       "radius": 500
                   }
               }]
           }.

        :param unique_data_id: The unique data id for the content. The ``udid`` must have been obtained
         from a successful `Data Upload API
         <https://docs.microsoft.com/en-us/rest/api/maps/data%20v2/uploadpreview>`_ call.
        :type unique_data_id: str
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: IO, or the result of cls(response)
        :rtype: IO
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType[IO]
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}))
        api_version = "2.0"
        accept = "application/json, application/vnd.geo+json, application/octet-stream"

        # Construct URL
        url = self.download_preview.metadata['url']  # type: ignore
        path_format_arguments = {
            'geography': self._serialize.url("self._config.geography", self._config.geography, 'str'),
            'udid': self._serialize.url("unique_data_id", unique_data_id, 'str'),
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]
        query_parameters['api-version'] = self._serialize.query("api_version", api_version, 'str')

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]
        if self._config.x_ms_client_id is not None:
            header_parameters['x-ms-client-id'] = self._serialize.header("self._config.x_ms_client_id", self._config.x_ms_client_id, 'str')
        header_parameters['Accept'] = self._serialize.header("accept", accept, 'str')

        request = self._client.get(url, query_parameters, header_parameters)
        pipeline_response = await self._client._pipeline.run(request, stream=True, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize.failsafe_deserialize(_models.ErrorResponse, response)
            raise HttpResponseError(response=response, model=error)

        response_headers = {}
        response_headers['Content-Type']=self._deserialize('str', response.headers.get('Content-Type'))
        deserialized = response.stream_download(self._client._pipeline)

        if cls:
            return cls(pipeline_response, deserialized, response_headers)

        return deserialized
    download_preview.metadata = {'url': '/mapData/{udid}'}  # type: ignore

    async def delete_preview(
        self,
        unique_data_id: str,
        **kwargs: Any
    ) -> None:
        """.. role:: raw-html-m2r(raw)
           :format: html


        **Applies to:** see pricing `tiers <https://aka.ms/AzureMapsPricingTier>`_.

        This API allows the caller to delete a previously uploaded data content.:code:`<br>`\
        :raw-html-m2r:`<br>`
        You can use this API in a scenario like removing geofences previously uploaded using the `Data
        Upload API <https://docs.microsoft.com/en-us/rest/api/maps/data%20v2/uploadpreview>`_ for use
        in our `Azure Maps Geofencing Service
        <https://docs.microsoft.com/en-us/rest/api/maps/spatial>`_. You can also use this API to delete
        old/unused uploaded content and create space for new content.

        Submit Delete Request
        ^^^^^^^^^^^^^^^^^^^^^

        To delete your content you will issue a ``DELETE`` request where the path will contain the
        ``udid`` of the data to delete.:code:`<br>`\ :raw-html-m2r:`<br>`
        For example, to delete a collection of geofences previously uploaded using the Upload API, set
        the ``udid`` parameter in the path to the ``udid`` of the data received previously in the
        upload API response.

        Delete Data Response
        ^^^^^^^^^^^^^^^^^^^^

        The Data Delete API returns a HTTP ``204 No Content`` response with an empty body, if the data
        resource was deleted successfully.:code:`<br>`\ :raw-html-m2r:`<br>`
        A HTTP ``400 Bad Request`` error response will be returned if the data resource with the
        passed-in ``udid`` is not found.

        :param unique_data_id: The unique data id for the content. The ``udid`` must have been obtained
         from a successful `Data Upload API
         <https://docs.microsoft.com/en-us/rest/api/maps/data%20v2/uploadpreview>`_ call.
        :type unique_data_id: str
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: None, or the result of cls(response)
        :rtype: None
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType[None]
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}))
        api_version = "2.0"
        accept = "application/json"

        # Construct URL
        url = self.delete_preview.metadata['url']  # type: ignore
        path_format_arguments = {
            'geography': self._serialize.url("self._config.geography", self._config.geography, 'str'),
            'udid': self._serialize.url("unique_data_id", unique_data_id, 'str'),
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]
        query_parameters['api-version'] = self._serialize.query("api_version", api_version, 'str')

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]
        if self._config.x_ms_client_id is not None:
            header_parameters['x-ms-client-id'] = self._serialize.header("self._config.x_ms_client_id", self._config.x_ms_client_id, 'str')
        header_parameters['Accept'] = self._serialize.header("accept", accept, 'str')

        request = self._client.delete(url, query_parameters, header_parameters)
        pipeline_response = await self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [204]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize.failsafe_deserialize(_models.ErrorResponse, response)
            raise HttpResponseError(response=response, model=error)

        if cls:
            return cls(pipeline_response, None, {})

    delete_preview.metadata = {'url': '/mapData/{udid}'}  # type: ignore

    async def get_operation_preview(
        self,
        operation_id: str,
        **kwargs: Any
    ) -> "_models.LongRunningOperationResult":
        """This path will be obtained from a call to POST /mapData.  While in progress, an http200 will be
        returned with no extra headers -  followed by an http200 with Resource-Location header once
        completed.

        :param operation_id: The ID to query the status for the data upload request.
        :type operation_id: str
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: LongRunningOperationResult, or the result of cls(response)
        :rtype: ~azure.maps.creator.models.LongRunningOperationResult
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType["_models.LongRunningOperationResult"]
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}))
        api_version = "2.0"
        accept = "application/json"

        # Construct URL
        url = self.get_operation_preview.metadata['url']  # type: ignore
        path_format_arguments = {
            'geography': self._serialize.url("self._config.geography", self._config.geography, 'str'),
            'operationId': self._serialize.url("operation_id", operation_id, 'str'),
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]
        query_parameters['api-version'] = self._serialize.query("api_version", api_version, 'str')

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]
        header_parameters['Accept'] = self._serialize.header("accept", accept, 'str')

        request = self._client.get(url, query_parameters, header_parameters)
        pipeline_response = await self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize.failsafe_deserialize(_models.ErrorResponse, response)
            raise HttpResponseError(response=response, model=error)

        response_headers = {}
        response_headers['Resource-Location']=self._deserialize('str', response.headers.get('Resource-Location'))
        deserialized = self._deserialize('LongRunningOperationResult', pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, response_headers)

        return deserialized
    get_operation_preview.metadata = {'url': '/mapData/operations/{operationId}'}  # type: ignore
