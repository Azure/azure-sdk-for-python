# coding=utf-8
# --------------------------------------------------------------------------
# Copyright (c) Microsoft Corporation. All rights reserved.
# Licensed under the MIT License. See License.txt in the project root for license information.
# Code generated by Microsoft (R) AutoRest Code Generator.
# Changes may cause incorrect behavior and will be lost if the code is regenerated.
# --------------------------------------------------------------------------
from typing import Any, AsyncIterable, Callable, Dict, Generic, Optional, TypeVar, Union
import warnings

from azure.core.async_paging import AsyncItemPaged, AsyncList
from azure.core.exceptions import ClientAuthenticationError, HttpResponseError, ResourceExistsError, ResourceNotFoundError, map_error
from azure.core.pipeline import PipelineResponse
from azure.core.pipeline.transport import AsyncHttpResponse, HttpRequest

from ... import models as _models

T = TypeVar('T')
ClsType = Optional[Callable[[PipelineResponse[HttpRequest, AsyncHttpResponse], T, Dict[str, Any]], Any]]

class FeatureStateOperations:
    """FeatureStateOperations async operations.

    You should not instantiate this class directly. Instead, you should create a Client instance that
    instantiates it for you and attaches it as an attribute.

    :ivar models: Alias to model classes used in this operation group.
    :type models: ~azure.maps.creator.models
    :param client: Client for service requests.
    :param config: Configuration of service client.
    :param serializer: An object model serializer.
    :param deserializer: An object model deserializer.
    """

    models = _models

    def __init__(self, client, config, serializer, deserializer) -> None:
        self._client = client
        self._serialize = serializer
        self._deserialize = deserializer
        self._config = config

    async def create_stateset(
        self,
        dataset_id: str,
        stateset_create_request_body: "_models.StylesObject",
        description: Optional[str] = None,
        **kwargs: Any
    ) -> "_models.StatesetCreatedResponse":
        """**Applies to:** see pricing `tiers <https://aka.ms/AzureMapsPricingTier>`_.

        Creator makes it possible to develop applications based on your private indoor map data using
        Azure Maps API and SDK. `This
        <https://docs.microsoft.com/azure/azure-maps/creator-indoor-maps>`_ article introduces concepts
        and tools that apply to Azure Maps Creator.

        This POST API allows the user to create a new Stateset and define stateset style using request
        body.

        Creator makes it possible to develop applications based on your private indoor map data using
        Azure Maps API and SDK. The Feature State API is part of Creator.

        The Feature State service allows the user to update the states of a feature and query them to
        be used in other services. The dynamic properties of a feature that don't belong to the dataset
        are referred to as *states* here.

        This Feature State service pivot on the Stateset. Like Tileset, Stateset encapsulates the
        storage mechanism for feature states for a dataset.

        Once the stateset is created, users can use that statesetId to post feature state updates and
        retrieve the current feature states. A feature can have only one state at a given point in
        time.

        Feature state is defined by the key name, value and the timestamp. When a feature state update
        is posted to Azure Maps, the state value gets updated only if the provided stateâ€™s timestamp is
        later than the stored timestamp.

        Azure Maps MapControl provides a way to use these feature states to style the features. Please
        refer to the State Tile documentation for more information.

        :param dataset_id: The datasetId must have been obtained from a successful `Dataset Create API
         <https://docs.microsoft.com/en-us/rest/api/maps/v2/dataset/create>`_ call.
        :type dataset_id: str
        :param stateset_create_request_body: The stateset style JSON data.
        :type stateset_create_request_body: ~azure.maps.creator.models.StylesObject
        :param description: Description for the stateset. Max length allowed is 1000.
        :type description: str
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: StatesetCreatedResponse, or the result of cls(response)
        :rtype: ~azure.maps.creator.models.StatesetCreatedResponse
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType["_models.StatesetCreatedResponse"]
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}))
        api_version = "2.0"
        content_type = kwargs.pop("content_type", "application/json")
        accept = "application/json"

        # Construct URL
        url = self.create_stateset.metadata['url']  # type: ignore
        path_format_arguments = {
            'geography': self._serialize.url("self._config.geography", self._config.geography, 'str'),
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]
        query_parameters['api-version'] = self._serialize.query("api_version", api_version, 'str')
        query_parameters['datasetId'] = self._serialize.query("dataset_id", dataset_id, 'str')
        if description is not None:
            query_parameters['description'] = self._serialize.query("description", description, 'str')

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]
        header_parameters['Content-Type'] = self._serialize.header("content_type", content_type, 'str')
        header_parameters['Accept'] = self._serialize.header("accept", accept, 'str')

        body_content_kwargs = {}  # type: Dict[str, Any]
        body_content = self._serialize.body(stateset_create_request_body, 'StylesObject')
        body_content_kwargs['content'] = body_content
        request = self._client.post(url, query_parameters, header_parameters, **body_content_kwargs)
        pipeline_response = await self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize.failsafe_deserialize(_models.ErrorResponse, response)
            raise HttpResponseError(response=response, model=error)

        deserialized = self._deserialize('StatesetCreatedResponse', pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized
    create_stateset.metadata = {'url': '/featureStateSets'}  # type: ignore

    def list_stateset(
        self,
        **kwargs: Any
    ) -> AsyncIterable["_models.StatesetListResponse"]:
        """**Applies to:** see pricing `tiers <https://aka.ms/AzureMapsPricingTier>`_.

        Creator makes it possible to develop applications based on your private indoor map data using
        Azure Maps API and SDK. `This
        <https://docs.microsoft.com/azure/azure-maps/creator-indoor-maps>`_ article introduces concepts
        and tools that apply to Azure Maps Creator.

         This API allows the caller to fetch a list of all previously successfully created statesets.

        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: An iterator like instance of either StatesetListResponse or the result of cls(response)
        :rtype: ~azure.core.async_paging.AsyncItemPaged[~azure.maps.creator.models.StatesetListResponse]
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType["_models.StatesetListResponse"]
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}))
        api_version = "2.0"
        accept = "application/json"

        def prepare_request(next_link=None):
            # Construct headers
            header_parameters = {}  # type: Dict[str, Any]
            header_parameters['Accept'] = self._serialize.header("accept", accept, 'str')

            if not next_link:
                # Construct URL
                url = self.list_stateset.metadata['url']  # type: ignore
                path_format_arguments = {
                    'geography': self._serialize.url("self._config.geography", self._config.geography, 'str'),
                }
                url = self._client.format_url(url, **path_format_arguments)
                # Construct parameters
                query_parameters = {}  # type: Dict[str, Any]
                query_parameters['api-version'] = self._serialize.query("api_version", api_version, 'str')

                request = self._client.get(url, query_parameters, header_parameters)
            else:
                url = next_link
                query_parameters = {}  # type: Dict[str, Any]
                path_format_arguments = {
                    'geography': self._serialize.url("self._config.geography", self._config.geography, 'str'),
                }
                url = self._client.format_url(url, **path_format_arguments)
                request = self._client.get(url, query_parameters, header_parameters)
            return request

        async def extract_data(pipeline_response):
            deserialized = self._deserialize('StatesetListResponse', pipeline_response)
            list_of_elem = deserialized.statesets
            if cls:
                list_of_elem = cls(list_of_elem)
            return deserialized.next_link or None, AsyncList(list_of_elem)

        async def get_next(next_link=None):
            request = prepare_request(next_link)

            pipeline_response = await self._client._pipeline.run(request, stream=False, **kwargs)
            response = pipeline_response.http_response

            if response.status_code not in [200]:
                error = self._deserialize.failsafe_deserialize(_models.ErrorResponse, response)
                map_error(status_code=response.status_code, response=response, error_map=error_map)
                raise HttpResponseError(response=response, model=error)

            return pipeline_response

        return AsyncItemPaged(
            get_next, extract_data
        )
    list_stateset.metadata = {'url': '/featureStateSets'}  # type: ignore

    async def put_stateset(
        self,
        stateset_id: str,
        stateset_style_update_request_body: "_models.StylesObject",
        **kwargs: Any
    ) -> None:
        """**Applies to:** see pricing `tiers <https://aka.ms/AzureMapsPricingTier>`_.

        Creator makes it possible to develop applications based on your private indoor map data using
        Azure Maps API and SDK. `This
        <https://docs.microsoft.com/azure/azure-maps/creator-indoor-maps>`_ article introduces concepts
        and tools that apply to Azure Maps Creator.

        This PUT API allows the user to update the stateset style rules.

        :param stateset_id: The stateset id that was created.
        :type stateset_id: str
        :param stateset_style_update_request_body: The stateset style JSON data. Only style rules are
         allowed to be updated, update on keyname and type is not allowed.
        :type stateset_style_update_request_body: ~azure.maps.creator.models.StylesObject
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: None, or the result of cls(response)
        :rtype: None
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType[None]
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}))
        api_version = "2.0"
        content_type = kwargs.pop("content_type", "application/json")
        accept = "application/json"

        # Construct URL
        url = self.put_stateset.metadata['url']  # type: ignore
        path_format_arguments = {
            'geography': self._serialize.url("self._config.geography", self._config.geography, 'str'),
            'statesetId': self._serialize.url("stateset_id", stateset_id, 'str'),
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]
        query_parameters['api-version'] = self._serialize.query("api_version", api_version, 'str')

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]
        header_parameters['Content-Type'] = self._serialize.header("content_type", content_type, 'str')
        header_parameters['Accept'] = self._serialize.header("accept", accept, 'str')

        body_content_kwargs = {}  # type: Dict[str, Any]
        body_content = self._serialize.body(stateset_style_update_request_body, 'StylesObject')
        body_content_kwargs['content'] = body_content
        request = self._client.put(url, query_parameters, header_parameters, **body_content_kwargs)
        pipeline_response = await self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize.failsafe_deserialize(_models.ErrorResponse, response)
            raise HttpResponseError(response=response, model=error)

        if cls:
            return cls(pipeline_response, None, {})

    put_stateset.metadata = {'url': '/featureStateSets/{statesetId}'}  # type: ignore

    async def delete_stateset(
        self,
        stateset_id: str,
        **kwargs: Any
    ) -> None:
        """**Applies to:** see pricing `tiers <https://aka.ms/AzureMapsPricingTier>`_.

        Creator makes it possible to develop applications based on your private indoor map data using
        Azure Maps API and SDK. `This
        <https://docs.microsoft.com/azure/azure-maps/creator-indoor-maps>`_ article introduces concepts
        and tools that apply to Azure Maps Creator.

         This DELETE API allows the user to delete the stateset and the associated data.

        :param stateset_id: The stateset id that was created.
        :type stateset_id: str
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: None, or the result of cls(response)
        :rtype: None
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType[None]
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}))
        api_version = "2.0"
        accept = "application/json"

        # Construct URL
        url = self.delete_stateset.metadata['url']  # type: ignore
        path_format_arguments = {
            'geography': self._serialize.url("self._config.geography", self._config.geography, 'str'),
            'statesetId': self._serialize.url("stateset_id", stateset_id, 'str'),
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]
        query_parameters['api-version'] = self._serialize.query("api_version", api_version, 'str')

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]
        header_parameters['Accept'] = self._serialize.header("accept", accept, 'str')

        request = self._client.delete(url, query_parameters, header_parameters)
        pipeline_response = await self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [204]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize.failsafe_deserialize(_models.ErrorResponse, response)
            raise HttpResponseError(response=response, model=error)

        if cls:
            return cls(pipeline_response, None, {})

    delete_stateset.metadata = {'url': '/featureStateSets/{statesetId}'}  # type: ignore

    async def get_stateset(
        self,
        stateset_id: str,
        **kwargs: Any
    ) -> "_models.StatesetGetResponse":
        """**Applies to:** see pricing `tiers <https://aka.ms/AzureMapsPricingTier>`_.

        Creator makes it possible to develop applications based on your private indoor map data using
        Azure Maps API and SDK. `This
        <https://docs.microsoft.com/azure/azure-maps/creator-indoor-maps>`_ article introduces concepts
        and tools that apply to Azure Maps Creator.

        This GET API allows the user to get the stateset Information.

        The stateset Information includes the datasetId associated to the stateset, and the styles of
        that stateset.

        :param stateset_id: The stateset id that was created.
        :type stateset_id: str
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: StatesetGetResponse, or the result of cls(response)
        :rtype: ~azure.maps.creator.models.StatesetGetResponse
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType["_models.StatesetGetResponse"]
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}))
        api_version = "2.0"
        accept = "application/json"

        # Construct URL
        url = self.get_stateset.metadata['url']  # type: ignore
        path_format_arguments = {
            'geography': self._serialize.url("self._config.geography", self._config.geography, 'str'),
            'statesetId': self._serialize.url("stateset_id", stateset_id, 'str'),
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]
        query_parameters['api-version'] = self._serialize.query("api_version", api_version, 'str')

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]
        header_parameters['Accept'] = self._serialize.header("accept", accept, 'str')

        request = self._client.get(url, query_parameters, header_parameters)
        pipeline_response = await self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize.failsafe_deserialize(_models.ErrorResponse, response)
            raise HttpResponseError(response=response, model=error)

        deserialized = self._deserialize('StatesetGetResponse', pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized
    get_stateset.metadata = {'url': '/featureStateSets/{statesetId}'}  # type: ignore

    async def update_states(
        self,
        stateset_id: str,
        feature_id: str,
        feature_state_update_request_body: "_models.FeatureStatesStructure",
        **kwargs: Any
    ) -> None:
        """**Applies to:** see pricing `tiers <https://aka.ms/AzureMapsPricingTier>`_.

        Creator makes it possible to develop applications based on your private indoor map data using
        Azure Maps API and SDK. `This
        <https://docs.microsoft.com/azure/azure-maps/creator-indoor-maps>`_ article introduces concepts
        and tools that apply to Azure Maps Creator.

        This PUT API allows the user to update the state of the given feature in the given stateset.

        :param stateset_id: The stateset id that was created.
        :type stateset_id: str
        :param feature_id: The id of a feature in the given dataset. If the featureId is not present in
         the dataset, Bad Request response will be returned.
        :type feature_id: str
        :param feature_state_update_request_body: The feature state JSON data. A feature can have only
         one state at a given point in time. The specified state keyname must have been defined during
         the stateset creation.
        :type feature_state_update_request_body: ~azure.maps.creator.models.FeatureStatesStructure
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: None, or the result of cls(response)
        :rtype: None
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType[None]
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}))
        api_version = "2.0"
        content_type = kwargs.pop("content_type", "application/json")
        accept = "application/json"

        # Construct URL
        url = self.update_states.metadata['url']  # type: ignore
        path_format_arguments = {
            'geography': self._serialize.url("self._config.geography", self._config.geography, 'str'),
            'statesetId': self._serialize.url("stateset_id", stateset_id, 'str'),
            'featureId': self._serialize.url("feature_id", feature_id, 'str'),
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]
        query_parameters['api-version'] = self._serialize.query("api_version", api_version, 'str')

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]
        header_parameters['Content-Type'] = self._serialize.header("content_type", content_type, 'str')
        header_parameters['Accept'] = self._serialize.header("accept", accept, 'str')

        body_content_kwargs = {}  # type: Dict[str, Any]
        body_content = self._serialize.body(feature_state_update_request_body, 'FeatureStatesStructure')
        body_content_kwargs['content'] = body_content
        request = self._client.put(url, query_parameters, header_parameters, **body_content_kwargs)
        pipeline_response = await self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize.failsafe_deserialize(_models.ErrorResponse, response)
            raise HttpResponseError(response=response, model=error)

        if cls:
            return cls(pipeline_response, None, {})

    update_states.metadata = {'url': '/featureStateSets/{statesetId}/featureStates/{featureId}'}  # type: ignore

    async def delete_state(
        self,
        stateset_id: str,
        feature_id: str,
        state_key_name: str,
        **kwargs: Any
    ) -> None:
        """**Applies to:** see pricing `tiers <https://aka.ms/AzureMapsPricingTier>`_.

        Creator makes it possible to develop applications based on your private indoor map data using
        Azure Maps API and SDK. `This
        <https://docs.microsoft.com/azure/azure-maps/creator-indoor-maps>`_ article introduces concepts
        and tools that apply to Azure Maps Creator.

         This API deletes the state information identified by the StateKeyName parameter for the
        feature identified by the FeatureId parameter in the the stateset.

        :param stateset_id: The stateset id that was created.
        :type stateset_id: str
        :param feature_id: The id of a feature in the given stateset. If no state was set for the
         featureId in the stateset earlier, Bad Request response will be returned.
        :type feature_id: str
        :param state_key_name: The Name of the state to be deleted.
        :type state_key_name: str
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: None, or the result of cls(response)
        :rtype: None
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType[None]
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}))
        api_version = "2.0"
        accept = "application/json"

        # Construct URL
        url = self.delete_state.metadata['url']  # type: ignore
        path_format_arguments = {
            'geography': self._serialize.url("self._config.geography", self._config.geography, 'str'),
            'statesetId': self._serialize.url("stateset_id", stateset_id, 'str'),
            'featureId': self._serialize.url("feature_id", feature_id, 'str'),
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]
        query_parameters['api-version'] = self._serialize.query("api_version", api_version, 'str')
        query_parameters['stateKeyName'] = self._serialize.query("state_key_name", state_key_name, 'str')

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]
        header_parameters['Accept'] = self._serialize.header("accept", accept, 'str')

        request = self._client.delete(url, query_parameters, header_parameters)
        pipeline_response = await self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [204]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize.failsafe_deserialize(_models.ErrorResponse, response)
            raise HttpResponseError(response=response, model=error)

        if cls:
            return cls(pipeline_response, None, {})

    delete_state.metadata = {'url': '/featureStateSets/{statesetId}/featureStates/{featureId}'}  # type: ignore

    async def get_states(
        self,
        stateset_id: str,
        feature_id: str,
        **kwargs: Any
    ) -> "_models.FeatureStatesStructure":
        """**Applies to:** see pricing `tiers <https://aka.ms/AzureMapsPricingTier>`_.

        Creator makes it possible to develop applications based on your private indoor map data using
        Azure Maps API and SDK. `This
        <https://docs.microsoft.com/azure/azure-maps/creator-indoor-maps>`_ article introduces concepts
        and tools that apply to Azure Maps Creator.

         This API returns the current state information associated with the given feature in the given
        stateset.

        :param stateset_id: The stateset id that was created.
        :type stateset_id: str
        :param feature_id: The id of a feature in the given stateset. If no state was set for the
         featureId in the stateset earlier, Bad Request response will be returned.
        :type feature_id: str
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: FeatureStatesStructure, or the result of cls(response)
        :rtype: ~azure.maps.creator.models.FeatureStatesStructure
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType["_models.FeatureStatesStructure"]
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}))
        api_version = "2.0"
        accept = "application/json"

        # Construct URL
        url = self.get_states.metadata['url']  # type: ignore
        path_format_arguments = {
            'geography': self._serialize.url("self._config.geography", self._config.geography, 'str'),
            'statesetId': self._serialize.url("stateset_id", stateset_id, 'str'),
            'featureId': self._serialize.url("feature_id", feature_id, 'str'),
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]
        query_parameters['api-version'] = self._serialize.query("api_version", api_version, 'str')

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]
        header_parameters['Accept'] = self._serialize.header("accept", accept, 'str')

        request = self._client.get(url, query_parameters, header_parameters)
        pipeline_response = await self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize.failsafe_deserialize(_models.ErrorResponse, response)
            raise HttpResponseError(response=response, model=error)

        deserialized = self._deserialize('FeatureStatesStructure', pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized
    get_states.metadata = {'url': '/featureStateSets/{statesetId}/featureStates/{featureId}'}  # type: ignore
