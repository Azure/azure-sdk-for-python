# coding=utf-8
# --------------------------------------------------------------------------
# Copyright (c) Microsoft Corporation. All rights reserved.
# Licensed under the MIT License. See License.txt in the project root for license information.
# Code generated by Microsoft (R) AutoRest Code Generator.
# Changes may cause incorrect behavior and will be lost if the code is regenerated.
# --------------------------------------------------------------------------
from typing import Any, Callable, Dict, Generic, Optional, TypeVar, Union
import warnings

from azure.core.exceptions import ClientAuthenticationError, HttpResponseError, ResourceExistsError, ResourceNotFoundError, map_error
from azure.core.pipeline import PipelineResponse
from azure.core.pipeline.transport import AsyncHttpResponse, HttpRequest

from ... import models as _models

T = TypeVar('T')
ClsType = Optional[Callable[[PipelineResponse[HttpRequest, AsyncHttpResponse], T, Dict[str, Any]], Any]]

class WFSOperations:
    """WFSOperations async operations.

    You should not instantiate this class directly. Instead, you should create a Client instance that
    instantiates it for you and attaches it as an attribute.

    :ivar models: Alias to model classes used in this operation group.
    :type models: ~azure.maps.creator.models
    :param client: Client for service requests.
    :param config: Configuration of service client.
    :param serializer: An object model serializer.
    :param deserializer: An object model deserializer.
    """

    models = _models

    def __init__(self, client, config, serializer, deserializer) -> None:
        self._client = client
        self._serialize = serializer
        self._deserialize = deserializer
        self._config = config

    async def get_landing_page(
        self,
        dataset_id: str,
        **kwargs: Any
    ) -> "_models.LandingPageResponse":
        """**Applies to:** see pricing `tiers <https://aka.ms/AzureMapsPricingTier>`_.

        Creator makes it possible to develop applications based on your private indoor map data using
        Azure Maps API and SDK. `This
        <https://docs.microsoft.com/azure/azure-maps/creator-indoor-maps>`_ article introduces concepts
        and tools that apply to Azure Maps Creator.

         The Web Feature Service (WFS) API is part of  Creator. WFS API follows the `Open Geospatial
        Consortium API standard for Features
        <http://docs.opengeospatial.org/is/17-069r3/17-069r3.html>`_ to query `Datasets
        <https://docs.microsoft.com/en-us/rest/api/maps/dataset/createpreview>`_.
        A dataset consists of multiple feature collections. A feature collection is a collection of
        features of a similar type, based on a common schema.
        The Get Landing Page API provides links to the API definition, the Conformance statements  and
        the metadata about the feature data in this dataset.

        :param dataset_id: The identifier for the dataset to query from.
        :type dataset_id: str
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: LandingPageResponse, or the result of cls(response)
        :rtype: ~azure.maps.creator.models.LandingPageResponse
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType["_models.LandingPageResponse"]
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}))
        api_version = "2.0"
        accept = "application/json"

        # Construct URL
        url = self.get_landing_page.metadata['url']  # type: ignore
        path_format_arguments = {
            'geography': self._serialize.url("self._config.geography", self._config.geography, 'str'),
            'datasetId': self._serialize.url("dataset_id", dataset_id, 'str'),
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]
        query_parameters['api-version'] = self._serialize.query("api_version", api_version, 'str')

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]
        if self._config.x_ms_client_id is not None:
            header_parameters['x-ms-client-id'] = self._serialize.header("self._config.x_ms_client_id", self._config.x_ms_client_id, 'str')
        header_parameters['Accept'] = self._serialize.header("accept", accept, 'str')

        request = self._client.get(url, query_parameters, header_parameters)
        pipeline_response = await self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize.failsafe_deserialize(_models.ErrorResponse, response)
            raise HttpResponseError(response=response, model=error)

        deserialized = self._deserialize('LandingPageResponse', pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized
    get_landing_page.metadata = {'url': '/wfs/datasets/{datasetId}/'}  # type: ignore

    async def get_conformance(
        self,
        dataset_id: str,
        **kwargs: Any
    ) -> "_models.ConformanceResponse":
        """**Applies to:** see pricing `tiers <https://aka.ms/AzureMapsPricingTier>`_.

        Creator makes it possible to develop applications based on your private indoor map data using
        Azure Maps API and SDK. `This
        <https://docs.microsoft.com/azure/azure-maps/creator-indoor-maps>`_ article introduces concepts
        and tools that apply to Azure Maps Creator.

        The Web Feature Service (WFS) API is part of  Creator. WFS API follows the `Open Geospatial
        Consortium API standard for Features
        <http://docs.opengeospatial.org/is/17-069r3/17-069r3.html>`_ to query `Datasets
        <https://docs.microsoft.com/en-us/rest/api/maps/dataset/createpreview>`_.
        A dataset consists of multiple feature collections. A feature collection is a collection of
        features of a similar type, based on a common schema.
        The Get Requirements Classes lists all requirements classes specified in the standard that the
        server conforms to.

        :param dataset_id: The identifier for the dataset to query from.
        :type dataset_id: str
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: ConformanceResponse, or the result of cls(response)
        :rtype: ~azure.maps.creator.models.ConformanceResponse
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType["_models.ConformanceResponse"]
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}))
        api_version = "2.0"
        accept = "application/json"

        # Construct URL
        url = self.get_conformance.metadata['url']  # type: ignore
        path_format_arguments = {
            'geography': self._serialize.url("self._config.geography", self._config.geography, 'str'),
            'datasetId': self._serialize.url("dataset_id", dataset_id, 'str'),
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]
        query_parameters['api-version'] = self._serialize.query("api_version", api_version, 'str')

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]
        if self._config.x_ms_client_id is not None:
            header_parameters['x-ms-client-id'] = self._serialize.header("self._config.x_ms_client_id", self._config.x_ms_client_id, 'str')
        header_parameters['Accept'] = self._serialize.header("accept", accept, 'str')

        request = self._client.get(url, query_parameters, header_parameters)
        pipeline_response = await self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize.failsafe_deserialize(_models.ErrorResponse, response)
            raise HttpResponseError(response=response, model=error)

        deserialized = self._deserialize('ConformanceResponse', pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized
    get_conformance.metadata = {'url': '/wfs/datasets/{datasetId}/conformance'}  # type: ignore

    async def get_collections(
        self,
        dataset_id: str,
        **kwargs: Any
    ) -> "_models.CollectionsResponse":
        """**Applies to:** see pricing `tiers <https://aka.ms/AzureMapsPricingTier>`_.

        Creator makes it possible to develop applications based on your private indoor map data using
        Azure Maps API and SDK. `This
        <https://docs.microsoft.com/azure/azure-maps/creator-indoor-maps>`_ article introduces concepts
        and tools that apply to Azure Maps Creator.

         The Web Feature Service (WFS) API is part of  Creator. WFS API follows the `Open Geospatial
        Consortium API standard for Features
        <http://docs.opengeospatial.org/is/17-069r3/17-069r3.html>`_ to query `Datasets
        <https://docs.microsoft.com/en-us/rest/api/maps/dataset/createpreview>`_.
        A dataset consists of multiple feature collections. A feature collection is a collection of
        features of a similar type, based on a common schema.
        The Collections Description API provides descriptions of all the collections in a given
        dataset.

        :param dataset_id: The identifier for the dataset to query from.
        :type dataset_id: str
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: CollectionsResponse, or the result of cls(response)
        :rtype: ~azure.maps.creator.models.CollectionsResponse
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType["_models.CollectionsResponse"]
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}))
        api_version = "2.0"
        accept = "application/json"

        # Construct URL
        url = self.get_collections.metadata['url']  # type: ignore
        path_format_arguments = {
            'geography': self._serialize.url("self._config.geography", self._config.geography, 'str'),
            'datasetId': self._serialize.url("dataset_id", dataset_id, 'str'),
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]
        query_parameters['api-version'] = self._serialize.query("api_version", api_version, 'str')

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]
        if self._config.x_ms_client_id is not None:
            header_parameters['x-ms-client-id'] = self._serialize.header("self._config.x_ms_client_id", self._config.x_ms_client_id, 'str')
        header_parameters['Accept'] = self._serialize.header("accept", accept, 'str')

        request = self._client.get(url, query_parameters, header_parameters)
        pipeline_response = await self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize.failsafe_deserialize(_models.ErrorResponse, response)
            raise HttpResponseError(response=response, model=error)

        deserialized = self._deserialize('CollectionsResponse', pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized
    get_collections.metadata = {'url': '/wfs/datasets/{datasetId}/collections'}  # type: ignore

    async def get_collection(
        self,
        dataset_id: str,
        collection_id: str,
        **kwargs: Any
    ) -> "_models.CollectionInfo":
        """**Applies to:** see pricing `tiers <https://aka.ms/AzureMapsPricingTier>`_.

        Creator makes it possible to develop applications based on your private indoor map data using
        Azure Maps API and SDK. `This
        <https://docs.microsoft.com/azure/azure-maps/creator-indoor-maps>`_ article introduces concepts
        and tools that apply to Azure Maps Creator.

         The Web Feature Service (WFS) API is part of  Creator. WFS API follows the `Open Geospatial
        Consortium API standard for Features
        <http://docs.opengeospatial.org/is/17-069r3/17-069r3.html>`_ to query `Datasets
        <https://docs.microsoft.com/en-us/rest/api/maps/dataset/createpreview>`_.
        A dataset consists of multiple feature collections. A feature collection is a collection of
        features of a similar type, based on a common schema.

        The Collection Description API provides the description of a given collection. It includes the
        links to the operations that can be performed on the collection.

        :param dataset_id: The identifier for the dataset to query from.
        :type dataset_id: str
        :param collection_id: Identifier (name) of a specific collection.
        :type collection_id: str
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: CollectionInfo, or the result of cls(response)
        :rtype: ~azure.maps.creator.models.CollectionInfo
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType["_models.CollectionInfo"]
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}))
        api_version = "2.0"
        accept = "application/json"

        # Construct URL
        url = self.get_collection.metadata['url']  # type: ignore
        path_format_arguments = {
            'geography': self._serialize.url("self._config.geography", self._config.geography, 'str'),
            'datasetId': self._serialize.url("dataset_id", dataset_id, 'str'),
            'collectionId': self._serialize.url("collection_id", collection_id, 'str'),
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]
        query_parameters['api-version'] = self._serialize.query("api_version", api_version, 'str')

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]
        if self._config.x_ms_client_id is not None:
            header_parameters['x-ms-client-id'] = self._serialize.header("self._config.x_ms_client_id", self._config.x_ms_client_id, 'str')
        header_parameters['Accept'] = self._serialize.header("accept", accept, 'str')

        request = self._client.get(url, query_parameters, header_parameters)
        pipeline_response = await self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize.failsafe_deserialize(_models.ErrorResponse, response)
            raise HttpResponseError(response=response, model=error)

        deserialized = self._deserialize('CollectionInfo', pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized
    get_collection.metadata = {'url': '/wfs/datasets/{datasetId}/collections/{collectionId}'}  # type: ignore

    async def get_collection_definition(
        self,
        dataset_id: str,
        collection_id: str,
        **kwargs: Any
    ) -> "_models.CollectionDefinitionResponse":
        """**Applies to:** see pricing `tiers <https://aka.ms/AzureMapsPricingTier>`_.

        Creator makes it possible to develop applications based on your private indoor map data using
        Azure Maps API and SDK. `This
        <https://docs.microsoft.com/azure/azure-maps/creator-indoor-maps>`_ article introduces concepts
        and tools that apply to Azure Maps Creator.

         `This <https://docs.microsoft.com/en-us/azure/azure-maps/creator-indoor-maps>`_ article
        introduces concepts and tools that apply to Azure Maps Creator. WFS API follows the `Open
        Geospatial Consortium API standard for Features
        <http://docs.opengeospatial.org/is/17-069r3/17-069r3.html>`_ to query `Datasets
        <https://docs.microsoft.com/en-us/rest/api/maps/dataset/createpreview>`_.
        A dataset consists of multiple feature collections. A feature collection is a collection of
        features of a similar type, based on a common schema.

        The Collection Definition API provides the detailed data model of a given collection.

        :param dataset_id: The identifier for the dataset to query from.
        :type dataset_id: str
        :param collection_id: Identifier (name) of a specific collection.
        :type collection_id: str
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: CollectionDefinitionResponse, or the result of cls(response)
        :rtype: ~azure.maps.creator.models.CollectionDefinitionResponse
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType["_models.CollectionDefinitionResponse"]
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}))
        api_version = "2.0"
        accept = "application/json"

        # Construct URL
        url = self.get_collection_definition.metadata['url']  # type: ignore
        path_format_arguments = {
            'geography': self._serialize.url("self._config.geography", self._config.geography, 'str'),
            'datasetId': self._serialize.url("dataset_id", dataset_id, 'str'),
            'collectionId': self._serialize.url("collection_id", collection_id, 'str'),
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]
        query_parameters['api-version'] = self._serialize.query("api_version", api_version, 'str')

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]
        if self._config.x_ms_client_id is not None:
            header_parameters['x-ms-client-id'] = self._serialize.header("self._config.x_ms_client_id", self._config.x_ms_client_id, 'str')
        header_parameters['Accept'] = self._serialize.header("accept", accept, 'str')

        request = self._client.get(url, query_parameters, header_parameters)
        pipeline_response = await self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize.failsafe_deserialize(_models.ErrorResponse, response)
            raise HttpResponseError(response=response, model=error)

        deserialized = self._deserialize('CollectionDefinitionResponse', pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized
    get_collection_definition.metadata = {'url': '/wfs/datasets/{datasetId}/collections/{collectionId}/definition'}  # type: ignore

    async def get_features(
        self,
        dataset_id: str,
        collection_id: str,
        limit: Optional[int] = None,
        bbox: Optional[str] = None,
        filter: Optional[str] = None,
        **kwargs: Any
    ) -> "_models.ExtendedGeoJsonFeatureCollection":
        """**Applies to:** see pricing `tiers <https://aka.ms/AzureMapsPricingTier>`_.

        Creator makes it possible to develop applications based on your private indoor map data using
        Azure Maps API and SDK. `This
        <https://docs.microsoft.com/azure/azure-maps/creator-indoor-maps>`_ article introduces concepts
        and tools that apply to Azure Maps Creator.

         The Web Feature Service (WFS) API is part of  Creator. WFS API follows the `Open Geospatial
        Consortium API standard for Features
        <http://docs.opengeospatial.org/is/17-069r3/17-069r3.html>`_ to query `Datasets
        <https://docs.microsoft.com/en-us/rest/api/maps/dataset/createpreview>`_.
        A dataset consists of multiple feature collections. A feature collection is a collection of
        features of a similar type, based on a common schema.
        The Get Features API returns the list of features in the given collection.

        :param dataset_id: The identifier for the dataset to query from.
        :type dataset_id: str
        :param collection_id: Identifier (name) of a specific collection.
        :type collection_id: str
        :param limit: The optional limit parameter limits the number of features that are presented in
         the response document.
         Only features that are on the first level of the collection in the response document are
         counted. Nested objects contained within the explicitly requested features shall not be
         counted.


         * Minimum = 1 * Maximum = 50 * Default = 10.
        :type limit: int
        :param bbox: Only features that have a geometry that intersects the supplied bounding box are
         selected.


         * Lower left corner, coordinate axis 1 * Lower left corner, coordinate axis 2 * Upper right
         corner, coordinate axis 1 * Upper right corner, coordinate axis 2
           The coordinate reference system of the values is WGS84 longitude/latitude
         (http://www.opengis.net/def/crs/OGC/1.3/CRS84) unless a different coordinate reference system
         is specified in the parameter ``bbox-crs``.
           For WGS84 longitude/latitude the values are in most cases the sequence of minimum longitude,
         minimum latitude, maximum longitude and maximum latitude. However, in cases where the box spans
         the antimeridian the first value (west-most box edge) is larger than the third value (east-most
         box edge).
        :type bbox: str
        :param filter: Filter expression to search for features with specific property values in a
         given collection. Only feature properties of scalar type and equals operator are supported.
         This is a special parameter where the parameter name is a case sensitive property name. The
         scheme for this parameter is {property name}={property value}. Unless "filter" is one of the
         property names in the collection, "filter" should not be used as a parameter name. To search
         for features with "name" property value "21N13", use "name=21N13".
         Multiple filters are supported and should be represented as multiple query parameters. E.g.,
         :code:`<property1>`=:code:`<value1>`&:code:`<property2>`=:code:`<value2>` String values are
         case sensitive.
        :type filter: str
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: ExtendedGeoJsonFeatureCollection, or the result of cls(response)
        :rtype: ~azure.maps.creator.models.ExtendedGeoJsonFeatureCollection
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType["_models.ExtendedGeoJsonFeatureCollection"]
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}))
        api_version = "2.0"
        accept = "application/json"

        # Construct URL
        url = self.get_features.metadata['url']  # type: ignore
        path_format_arguments = {
            'geography': self._serialize.url("self._config.geography", self._config.geography, 'str'),
            'datasetId': self._serialize.url("dataset_id", dataset_id, 'str'),
            'collectionId': self._serialize.url("collection_id", collection_id, 'str'),
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]
        query_parameters['api-version'] = self._serialize.query("api_version", api_version, 'str')
        if limit is not None:
            query_parameters['limit'] = self._serialize.query("limit", limit, 'int', maximum=50, minimum=1)
        if bbox is not None:
            query_parameters['bbox'] = self._serialize.query("bbox", bbox, 'str')
        if filter is not None:
            query_parameters['filter'] = self._serialize.query("filter", filter, 'str')

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]
        if self._config.x_ms_client_id is not None:
            header_parameters['x-ms-client-id'] = self._serialize.header("self._config.x_ms_client_id", self._config.x_ms_client_id, 'str')
        header_parameters['Accept'] = self._serialize.header("accept", accept, 'str')

        request = self._client.get(url, query_parameters, header_parameters)
        pipeline_response = await self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize.failsafe_deserialize(_models.ErrorResponse, response)
            raise HttpResponseError(response=response, model=error)

        deserialized = self._deserialize('ExtendedGeoJsonFeatureCollection', pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized
    get_features.metadata = {'url': '/wfs/datasets/{datasetId}/collections/{collectionId}/items'}  # type: ignore

    async def get_feature(
        self,
        dataset_id: str,
        collection_id: str,
        feature_id: str,
        **kwargs: Any
    ) -> "_models.FeatureResponse":
        """**Applies to:** see pricing `tiers <https://aka.ms/AzureMapsPricingTier>`_.

        Creator makes it possible to develop applications based on your private indoor map data using
        Azure Maps API and SDK. `This
        <https://docs.microsoft.com/azure/azure-maps/creator-indoor-maps>`_ article introduces concepts
        and tools that apply to Azure Maps Creator.

         The Web Feature Service (WFS) API is part of  Creator. WFS API follows the `Open Geospatial
        Consortium API standard for Features
        <http://docs.opengeospatial.org/is/17-069r3/17-069r3.html>`_ to query `Datasets
        <https://docs.microsoft.com/en-us/rest/api/maps/dataset/createpreview>`_.
        A dataset consists of multiple feature collections. A feature collection is a collection of
        features of a similar type, based on a common schema.
        The Get Feature API returns the feature identified by the provided id in the given collection.

        :param dataset_id: The identifier for the dataset to query from.
        :type dataset_id: str
        :param collection_id: Identifier (name) of a specific collection.
        :type collection_id: str
        :param feature_id: Local identifier of a specific feature.
        :type feature_id: str
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: FeatureResponse, or the result of cls(response)
        :rtype: ~azure.maps.creator.models.FeatureResponse
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType["_models.FeatureResponse"]
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}))
        api_version = "2.0"
        accept = "application/json"

        # Construct URL
        url = self.get_feature.metadata['url']  # type: ignore
        path_format_arguments = {
            'geography': self._serialize.url("self._config.geography", self._config.geography, 'str'),
            'datasetId': self._serialize.url("dataset_id", dataset_id, 'str'),
            'collectionId': self._serialize.url("collection_id", collection_id, 'str'),
            'featureId': self._serialize.url("feature_id", feature_id, 'str'),
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]
        query_parameters['api-version'] = self._serialize.query("api_version", api_version, 'str')

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]
        header_parameters['Accept'] = self._serialize.header("accept", accept, 'str')

        request = self._client.get(url, query_parameters, header_parameters)
        pipeline_response = await self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize.failsafe_deserialize(_models.ErrorResponse, response)
            raise HttpResponseError(response=response, model=error)

        deserialized = self._deserialize('FeatureResponse', pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized
    get_feature.metadata = {'url': '/wfs/datasets/{datasetId}/collections/{collectionId}/items/{featureId}'}  # type: ignore

    async def delete_feature(
        self,
        dataset_id: str,
        collection_id: str,
        feature_id: str,
        **kwargs: Any
    ) -> None:
        """**Applies to:** see pricing `tiers <https://aka.ms/AzureMapsPricingTier>`_.

        Creator makes it possible to develop applications based on your private indoor map data using
        Azure Maps API and SDK. `This
        <https://docs.microsoft.com/azure/azure-maps/creator-indoor-maps>`_ article introduces concepts
        and tools that apply to Azure Maps Creator.

         The Web Feature Service (WFS) API is part of  Creator. WFS API follows the `Open Geospatial
        Consortium API standard for Features
        <http://docs.opengeospatial.org/is/17-069r3/17-069r3.html>`_ to query `Datasets
        <https://docs.microsoft.com/en-us/rest/api/maps/dataset/createpreview>`_.
        A dataset consists of multiple feature collections. A feature collection is a collection of
        features of a similar type, based on a common schema.
        The Delete Feature API deletes the feature identified by the provided id in the given
        collection. At this point this API supports only facility features. Deleting a facility feature
        deletes all the child features of that facility recursively.

        :param dataset_id: The identifier for the dataset to query from.
        :type dataset_id: str
        :param collection_id: Identifier (name) of a specific collection.
        :type collection_id: str
        :param feature_id: Local identifier of a specific feature.
        :type feature_id: str
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: None, or the result of cls(response)
        :rtype: None
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType[None]
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}))
        api_version = "2.0"
        accept = "application/json"

        # Construct URL
        url = self.delete_feature.metadata['url']  # type: ignore
        path_format_arguments = {
            'geography': self._serialize.url("self._config.geography", self._config.geography, 'str'),
            'datasetId': self._serialize.url("dataset_id", dataset_id, 'str'),
            'collectionId': self._serialize.url("collection_id", collection_id, 'str'),
            'featureId': self._serialize.url("feature_id", feature_id, 'str'),
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]
        query_parameters['api-version'] = self._serialize.query("api_version", api_version, 'str')

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]
        header_parameters['Accept'] = self._serialize.header("accept", accept, 'str')

        request = self._client.delete(url, query_parameters, header_parameters)
        pipeline_response = await self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [204]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize.failsafe_deserialize(_models.ErrorResponse, response)
            raise HttpResponseError(response=response, model=error)

        if cls:
            return cls(pipeline_response, None, {})

    delete_feature.metadata = {'url': '/wfs/datasets/{datasetId}/collections/{collectionId}/items/{featureId}'}  # type: ignore
