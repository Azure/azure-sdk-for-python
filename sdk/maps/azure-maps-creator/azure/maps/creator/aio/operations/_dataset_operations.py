# coding=utf-8
# --------------------------------------------------------------------------
# Copyright (c) Microsoft Corporation. All rights reserved.
# Licensed under the MIT License. See License.txt in the project root for license information.
# Code generated by Microsoft (R) AutoRest Code Generator.
# Changes may cause incorrect behavior and will be lost if the code is regenerated.
# --------------------------------------------------------------------------
from typing import Any, AsyncIterable, Callable, Dict, Generic, Optional, TypeVar, Union
import warnings

from azure.core.async_paging import AsyncItemPaged, AsyncList
from azure.core.exceptions import ClientAuthenticationError, HttpResponseError, ResourceExistsError, ResourceNotFoundError, map_error
from azure.core.pipeline import PipelineResponse
from azure.core.pipeline.transport import AsyncHttpResponse, HttpRequest
from azure.core.polling import AsyncLROPoller, AsyncNoPolling, AsyncPollingMethod
from azure.core.polling.async_base_polling import AsyncLROBasePolling

from ... import models as _models

T = TypeVar('T')
ClsType = Optional[Callable[[PipelineResponse[HttpRequest, AsyncHttpResponse], T, Dict[str, Any]], Any]]

class DatasetOperations:
    """DatasetOperations async operations.

    You should not instantiate this class directly. Instead, you should create a Client instance that
    instantiates it for you and attaches it as an attribute.

    :ivar models: Alias to model classes used in this operation group.
    :type models: ~azure.maps.creator.models
    :param client: Client for service requests.
    :param config: Configuration of service client.
    :param serializer: An object model serializer.
    :param deserializer: An object model deserializer.
    """

    models = _models

    def __init__(self, client, config, serializer, deserializer) -> None:
        self._client = client
        self._serialize = serializer
        self._deserialize = deserializer
        self._config = config

    async def _create_initial(
        self,
        conversion_id: str,
        dataset_id: Optional[str] = None,
        description_dataset: Optional[str] = None,
        **kwargs: Any
    ) -> Optional["_models.LongRunningOperationResult"]:
        cls = kwargs.pop('cls', None)  # type: ClsType[Optional["_models.LongRunningOperationResult"]]
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}))
        api_version = "2.0"
        accept = "application/json"

        # Construct URL
        url = self._create_initial.metadata['url']  # type: ignore
        path_format_arguments = {
            'geography': self._serialize.url("self._config.geography", self._config.geography, 'str'),
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]
        query_parameters['api-version'] = self._serialize.query("api_version", api_version, 'str')
        query_parameters['conversionId'] = self._serialize.query("conversion_id", conversion_id, 'str')
        if dataset_id is not None:
            query_parameters['datasetId'] = self._serialize.query("dataset_id", dataset_id, 'str')
        if description_dataset is not None:
            query_parameters['description'] = self._serialize.query("description_dataset", description_dataset, 'str')

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]
        header_parameters['Accept'] = self._serialize.header("accept", accept, 'str')

        request = self._client.post(url, query_parameters, header_parameters)
        pipeline_response = await self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [200, 202]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize.failsafe_deserialize(_models.ErrorResponse, response)
            raise HttpResponseError(response=response, model=error)

        response_headers = {}
        deserialized = None
        if response.status_code == 200:
            response_headers['Resource-Location']=self._deserialize('str', response.headers.get('Resource-Location'))
            deserialized = self._deserialize('LongRunningOperationResult', pipeline_response)

        if response.status_code == 202:
            response_headers['Operation-Location']=self._deserialize('str', response.headers.get('Operation-Location'))

        if cls:
            return cls(pipeline_response, deserialized, response_headers)

        return deserialized
    _create_initial.metadata = {'url': '/datasets'}  # type: ignore

    async def begin_create(
        self,
        conversion_id: str,
        dataset_id: Optional[str] = None,
        description_dataset: Optional[str] = None,
        **kwargs: Any
    ) -> AsyncLROPoller["_models.LongRunningOperationResult"]:
        """**Applies to:** see pricing `tiers <https://aka.ms/AzureMapsPricingTier>`_.

        Creator makes it possible to develop applications based on your private indoor map data using
        Azure Maps API and SDK. `This
        <https://docs.microsoft.com/azure/azure-maps/creator-indoor-maps>`_ article introduces concepts
        and tools that apply to Azure Maps Creator.

         This API allows the caller to create a dataset from data that was uploaded to the Azure Maps
        Data Service and converted using the Azure Maps Conversion Service.

        You can use this API in a scenario like uploading a DWG zip package for a building, converting
        the zip package using the Azure Maps Conversion Service, and creating a dataset from the
        converted zip package. The created dataset can be used to create tilesets using the Azure Maps
        Tileset Service and can be queried via the Azure Maps WFS Service.

        Submit Create Request
        ^^^^^^^^^^^^^^^^^^^^^

        To create your dataset, you will use a ``POST`` request where the ``conversionId`` query
        parameter is an ID that represents the converted DWG zip package, the ``datasetId`` parameter
        will be the ID of a previously created dataset to append with the current dataset and,
        optionally, the ``description`` query parameter will contain a description (if description is
        not provided a default description will be given).

        The Create API is a `long-running request <https://aka.ms/am-creator-lrt-v2>`_.

        :param conversion_id: The unique ID used to create the dataset. The ``conversionId`` must have
         been obtained from a successful call to the Conversion Service Convert API and may be provided
         with multiple query parameters with same name (if more than one is provided).
        :type conversion_id: str
        :param dataset_id: The ID for the dataset to append with. The dataset must originate from a
         previous dataset creation call that matches the datasetId.
        :type dataset_id: str
        :param description_dataset: The description to be given to the dataset.
        :type description_dataset: str
        :keyword callable cls: A custom type or function that will be passed the direct response
        :keyword str continuation_token: A continuation token to restart a poller from a saved state.
        :keyword polling: By default, your polling method will be AsyncLROBasePolling.
         Pass in False for this operation to not poll, or pass in your own initialized polling object for a personal polling strategy.
        :paramtype polling: bool or ~azure.core.polling.AsyncPollingMethod
        :keyword int polling_interval: Default waiting time between two polls for LRO operations if no Retry-After header is present.
        :return: An instance of AsyncLROPoller that returns either LongRunningOperationResult or the result of cls(response)
        :rtype: ~azure.core.polling.AsyncLROPoller[~azure.maps.creator.models.LongRunningOperationResult]
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        polling = kwargs.pop('polling', True)  # type: Union[bool, AsyncPollingMethod]
        cls = kwargs.pop('cls', None)  # type: ClsType["_models.LongRunningOperationResult"]
        lro_delay = kwargs.pop(
            'polling_interval',
            self._config.polling_interval
        )
        cont_token = kwargs.pop('continuation_token', None)  # type: Optional[str]
        if cont_token is None:
            raw_result = await self._create_initial(
                conversion_id=conversion_id,
                dataset_id=dataset_id,
                description_dataset=description_dataset,
                cls=lambda x,y,z: x,
                **kwargs
            )

        kwargs.pop('error_map', None)
        kwargs.pop('content_type', None)

        def get_long_running_output(pipeline_response):
            response_headers = {}
            response = pipeline_response.http_response
            response_headers['Resource-Location']=self._deserialize('str', response.headers.get('Resource-Location'))
            deserialized = self._deserialize('LongRunningOperationResult', pipeline_response)

            if cls:
                return cls(pipeline_response, deserialized, response_headers)
            return deserialized

        path_format_arguments = {
            'geography': self._serialize.url("self._config.geography", self._config.geography, 'str'),
        }

        if polling is True: polling_method = AsyncLROBasePolling(lro_delay, lro_options={'final-state-via': 'location'}, path_format_arguments=path_format_arguments,  **kwargs)
        elif polling is False: polling_method = AsyncNoPolling()
        else: polling_method = polling
        if cont_token:
            return AsyncLROPoller.from_continuation_token(
                polling_method=polling_method,
                continuation_token=cont_token,
                client=self._client,
                deserialization_callback=get_long_running_output
            )
        else:
            return AsyncLROPoller(self._client, raw_result, get_long_running_output, polling_method)
    begin_create.metadata = {'url': '/datasets'}  # type: ignore

    def list(
        self,
        **kwargs: Any
    ) -> AsyncIterable["_models.DatasetListResponse"]:
        """**Applies to:** see pricing `tiers <https://aka.ms/AzureMapsPricingTier>`_.

        Creator makes it possible to develop applications based on your private indoor map data using
        Azure Maps API and SDK. `This
        <https://docs.microsoft.com/azure/azure-maps/creator-indoor-maps>`_ article introduces concepts
        and tools that apply to Azure Maps Creator.

        This API allows the caller to fetch a list of all previously successfully created datasets.

        Submit List Request
        ^^^^^^^^^^^^^^^^^^^

        To list all your datasets, you will issue a ``GET`` request with no additional parameters.

        List Data Response
        ^^^^^^^^^^^^^^^^^^

        The List API returns the complete list of all datasets in ``json`` format. The response
        contains the following fields (if they are not null or empty):

        ..

           created - The timestamp the dataset was created.
           datasetId - The id for the dataset.
           description - The description for the dataset.
           datasetSources - The source data that was used when the create request was issued.
           ontology - The source `ontology
        <https://docs.microsoft.com/en-us/azure/azure-maps/creator-facility-ontology>`_ that was used
        in the conversion service for the input data.:code:`<br/>`


        The ``datasetSources`` describes the source data that was used when the create request was
        issued and contains the following elements (if they are not null or empty):

        ..

           conversionIds - The list of ``conversionId`` (null if none were provided).
           appendDatasetId - The ``datasetId`` that was used for an append operation (null if none was
        used).
           featureCounts - The counts for each feature type in the dataset.:code:`<br/>`


        Here's a sample response returning the ``timestamp``\ , ``datasetId``\ , ``description``\ ,
        ``datasetSources``\ , and ``ontology`` of 3 dataset resources:

        .. code-block:: json

           {
             "datasets": [
               {
                 "timestamp": "2020-01-01T22:50:48.123Z",
                 "datasetId": "f6495f62-94f8-0ec2-c252-45626f82fcb2",
                 "description": "Some description or comment for the dataset.",
                 "datasetSources": {
                   "conversionIds": [
                     "15d21452-c9bb-27b6-5e79-743ca5c3205d"
                   ],      },
                 "ontology": "facility-2.0",
                 "featureCounts": {
                   "directoryInfo": 2,
                   "category": 10,
                   "facility": 1,
                   "level": 3,
                   "unit": 183,
                   "zone": 3,
                   "verticalPenetration": 6,
                   "opening": 48,
                   "areaElement": 108
                 }
               },
               {
                 "timestamp": "2020-01-01T22:57:53.123Z",
                 "datasetId": "8b1288fa-1958-4a2b-b68e-13a7i5af7d7c",
                 "description": "Create from upload '0c1288fa-2058-4a1b-b68d-13a5f5af7d7c'.",
                 "datasetSources": {
                   "conversionIds": [
                     "0c1288fa-2058-4a1b-b68d-13a5f5af7d7c"
                   ],
                   "appendDatasetId": "46d1edb6-d29e-4786-9589-dbd4efd7a977"
                 },
                 "ontology": "facility-2.0",
                 "featureCounts": {
                   "directoryInfo": 2,
                   "category": 10,
                   "facility": 1,
                   "level": 3,
                   "unit": 183,
                   "zone": 3,
                   "verticalPenetration": 6,
                   "opening": 48,
                   "areaElement": 108
                 }
               }
             ]
           }.

        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: An iterator like instance of either DatasetListResponse or the result of cls(response)
        :rtype: ~azure.core.async_paging.AsyncItemPaged[~azure.maps.creator.models.DatasetListResponse]
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType["_models.DatasetListResponse"]
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}))
        api_version = "2.0"
        accept = "application/json"

        def prepare_request(next_link=None):
            # Construct headers
            header_parameters = {}  # type: Dict[str, Any]
            header_parameters['Accept'] = self._serialize.header("accept", accept, 'str')

            if not next_link:
                # Construct URL
                url = self.list.metadata['url']  # type: ignore
                path_format_arguments = {
                    'geography': self._serialize.url("self._config.geography", self._config.geography, 'str'),
                }
                url = self._client.format_url(url, **path_format_arguments)
                # Construct parameters
                query_parameters = {}  # type: Dict[str, Any]
                query_parameters['api-version'] = self._serialize.query("api_version", api_version, 'str')

                request = self._client.get(url, query_parameters, header_parameters)
            else:
                url = next_link
                query_parameters = {}  # type: Dict[str, Any]
                path_format_arguments = {
                    'geography': self._serialize.url("self._config.geography", self._config.geography, 'str'),
                }
                url = self._client.format_url(url, **path_format_arguments)
                request = self._client.get(url, query_parameters, header_parameters)
            return request

        async def extract_data(pipeline_response):
            deserialized = self._deserialize('DatasetListResponse', pipeline_response)
            list_of_elem = deserialized.datasets
            if cls:
                list_of_elem = cls(list_of_elem)
            return deserialized.next_link or None, AsyncList(list_of_elem)

        async def get_next(next_link=None):
            request = prepare_request(next_link)

            pipeline_response = await self._client._pipeline.run(request, stream=False, **kwargs)
            response = pipeline_response.http_response

            if response.status_code not in [200]:
                error = self._deserialize.failsafe_deserialize(_models.ErrorResponse, response)
                map_error(status_code=response.status_code, response=response, error_map=error_map)
                raise HttpResponseError(response=response, model=error)

            return pipeline_response

        return AsyncItemPaged(
            get_next, extract_data
        )
    list.metadata = {'url': '/datasets'}  # type: ignore

    async def get(
        self,
        dataset_id: str,
        **kwargs: Any
    ) -> "_models.DatasetDetailInfo":
        """**Applies to:** see pricing `tiers <https://aka.ms/AzureMapsPricingTier>`_.

        Creator makes it possible to develop applications based on your private indoor map data using
        Azure Maps API and SDK. `This
        <https://docs.microsoft.com/azure/azure-maps/creator-indoor-maps>`_ article introduces concepts
        and tools that apply to Azure Maps Creator.

        This API allows the caller to fetch a previously successfully created dataset.

        Submit Get Details Request
        ^^^^^^^^^^^^^^^^^^^^^^^^^^

        To get the details for a previously created dataset, you will issue a ``GET`` request with the
        ``datasetId`` in the path.

        Get Details Response
        ^^^^^^^^^^^^^^^^^^^^

        The Get Details API returns the details for a dataset in ``json`` format. The response contains
        the following fields (if they are not null or empty):

        ..

           created - The timestamp the dataset was created.
           datasetId - The id for the dataset.
           description - The description for the dataset.
           datasetSources - The source data that was used when the create request was issued.
           ontology - The source `ontology
        <https://docs.microsoft.com/en-us/azure/azure-maps/creator-facility-ontology>`_ that was used
        in the conversion service for the input data.:code:`<br/>`


        The ``datasetSources`` describes the source data that was used when the create request was
        issued and contains the following elements (if they are not null or empty):

        ..

           conversionIds - The list of ``conversionId`` (null if none were provided).
           appendDatasetId - The ``datasetId`` that was used for an append operation (null if none was
        used).
           featureCounts - The counts for each feature type in the dataset.:code:`<br/>`


        Here's a sample response returning the ``timestamp``\ , ``datasetId``\ , ``description``\ ,
        ``datasetSources``\ , and ``ontology`` of a dataset resource:

        .. code-block:: json

           {
              "timestamp": "2020-01-01T22:50:48.123Z",
              "datasetId": "f6495f62-94f8-0ec2-c252-45626f82fcb2",
              "description": "Some description or comment for the dataset.",
              "datasetSources": {
                "conversionIds": [
                  "15d21452-c9bb-27b6-5e79-743ca5c3205d"
                ],
              },
              "ontology": "facility-2.0",
              "featureCounts": {
                "directoryInfo": 2,
                "category": 10,
                "facility": 1,
                "level": 3,
                "unit": 183,
                "zone": 3,
                "verticalPenetration": 6,
                "opening": 48,
                "areaElement": 108
              }
            }.

        :param dataset_id: The identifier for the dataset to query from.
        :type dataset_id: str
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: DatasetDetailInfo, or the result of cls(response)
        :rtype: ~azure.maps.creator.models.DatasetDetailInfo
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType["_models.DatasetDetailInfo"]
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}))
        api_version = "2.0"
        accept = "application/json"

        # Construct URL
        url = self.get.metadata['url']  # type: ignore
        path_format_arguments = {
            'geography': self._serialize.url("self._config.geography", self._config.geography, 'str'),
            'datasetId': self._serialize.url("dataset_id", dataset_id, 'str'),
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]
        query_parameters['api-version'] = self._serialize.query("api_version", api_version, 'str')

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]
        header_parameters['Accept'] = self._serialize.header("accept", accept, 'str')

        request = self._client.get(url, query_parameters, header_parameters)
        pipeline_response = await self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize.failsafe_deserialize(_models.ErrorResponse, response)
            raise HttpResponseError(response=response, model=error)

        deserialized = self._deserialize('DatasetDetailInfo', pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized
    get.metadata = {'url': '/datasets/{datasetId}'}  # type: ignore

    async def delete(
        self,
        dataset_id: str,
        **kwargs: Any
    ) -> None:
        """**Applies to:** see pricing `tiers <https://aka.ms/AzureMapsPricingTier>`_.

        Creator makes it possible to develop applications based on your private indoor map data using
        Azure Maps API and SDK. `This
        <https://docs.microsoft.com/azure/azure-maps/creator-indoor-maps>`_ article introduces concepts
        and tools that apply to Azure Maps Creator.

        You can also use this API to delete old/unused datasets to create space for new Creator
        content.

        Submit Delete Request
        ^^^^^^^^^^^^^^^^^^^^^

        To delete your content you will issue a ``DELETE`` request where the path will contain the
        ``datasetId`` of the dataset to delete.

        :param dataset_id: The identifier for the dataset to query from.
        :type dataset_id: str
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: None, or the result of cls(response)
        :rtype: None
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType[None]
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}))
        api_version = "2.0"
        accept = "application/json"

        # Construct URL
        url = self.delete.metadata['url']  # type: ignore
        path_format_arguments = {
            'geography': self._serialize.url("self._config.geography", self._config.geography, 'str'),
            'datasetId': self._serialize.url("dataset_id", dataset_id, 'str'),
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]
        query_parameters['api-version'] = self._serialize.query("api_version", api_version, 'str')

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]
        header_parameters['Accept'] = self._serialize.header("accept", accept, 'str')

        request = self._client.delete(url, query_parameters, header_parameters)
        pipeline_response = await self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [204]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize.failsafe_deserialize(_models.ErrorResponse, response)
            raise HttpResponseError(response=response, model=error)

        if cls:
            return cls(pipeline_response, None, {})

    delete.metadata = {'url': '/datasets/{datasetId}'}  # type: ignore

    async def get_operation(
        self,
        operation_id: str,
        **kwargs: Any
    ) -> "_models.LongRunningOperationResult":
        """This API allows the caller to view the current progress of a dataset operation and the path is
        obtained from a call to the Create API.

        Submit Operations Request
        ^^^^^^^^^^^^^^^^^^^^^^^^^

        To view the current progress of a dataset operation, you will use a ``GET`` request where the
        ``operationId`` given the path is the ID that represents the operation.

        Operation Response
        ^^^^^^^^^^^^^^^^^^

        While in progress, a ``200-OK`` http status code will be returned with no extra headers. If the
        operation succeeds, a ``200-OK`` http status code with Resource-Location header will be
        returned.

        :param operation_id: The ID to query the status for the dataset create/import request.
        :type operation_id: str
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: LongRunningOperationResult, or the result of cls(response)
        :rtype: ~azure.maps.creator.models.LongRunningOperationResult
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType["_models.LongRunningOperationResult"]
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}))
        api_version = "2.0"
        accept = "application/json"

        # Construct URL
        url = self.get_operation.metadata['url']  # type: ignore
        path_format_arguments = {
            'geography': self._serialize.url("self._config.geography", self._config.geography, 'str'),
            'operationId': self._serialize.url("operation_id", operation_id, 'str'),
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]
        query_parameters['api-version'] = self._serialize.query("api_version", api_version, 'str')

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]
        header_parameters['Accept'] = self._serialize.header("accept", accept, 'str')

        request = self._client.get(url, query_parameters, header_parameters)
        pipeline_response = await self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize.failsafe_deserialize(_models.ErrorResponse, response)
            raise HttpResponseError(response=response, model=error)

        response_headers = {}
        response_headers['Resource-Location']=self._deserialize('str', response.headers.get('Resource-Location'))
        deserialized = self._deserialize('LongRunningOperationResult', pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, response_headers)

        return deserialized
    get_operation.metadata = {'url': '/datasets/operations/{operationId}'}  # type: ignore
