# coding=utf-8
# --------------------------------------------------------------------------
# Copyright (c) Microsoft Corporation. All rights reserved.
# Licensed under the MIT License. See License.txt in the project root for license information.
# Code generated by Microsoft (R) AutoRest Code Generator.
# Changes may cause incorrect behavior and will be lost if the code is regenerated.
# --------------------------------------------------------------------------

from typing import Any, Dict, List, Optional, Union

from azure.core.exceptions import HttpResponseError
import msrest.serialization

from ._creator_client_enums import *


class AliasesCreateResponse(msrest.serialization.Model):
    """The response model for the Alias Create API for the case when the alias was successfully created.

    Variables are only populated by the server, and will be ignored when sending a request.

    :ivar created_timestamp: The created timestamp for the alias.
    :vartype created_timestamp: str
    :ivar alias_id: The id for the alias.
    :vartype alias_id: str
    :ivar creator_data_item_id: The id for the creator data item that this alias references (could
     be null if the alias has not been assigned).
    :vartype creator_data_item_id: str
    :ivar last_updated_timestamp: The timestamp of the last time the alias was assigned.
    :vartype last_updated_timestamp: str
    """

    _validation = {
        'created_timestamp': {'readonly': True},
        'alias_id': {'readonly': True},
        'creator_data_item_id': {'readonly': True},
        'last_updated_timestamp': {'readonly': True},
    }

    _attribute_map = {
        'created_timestamp': {'key': 'createdTimestamp', 'type': 'str'},
        'alias_id': {'key': 'aliasId', 'type': 'str'},
        'creator_data_item_id': {'key': 'creatorDataItemId', 'type': 'str'},
        'last_updated_timestamp': {'key': 'lastUpdatedTimestamp', 'type': 'str'},
    }

    def __init__(
        self,
        **kwargs
    ):
        super(AliasesCreateResponse, self).__init__(**kwargs)
        self.created_timestamp = None
        self.alias_id = None
        self.creator_data_item_id = None
        self.last_updated_timestamp = None


class AliasListItem(msrest.serialization.Model):
    """Detailed information for the alias.

    Variables are only populated by the server, and will be ignored when sending a request.

    :ivar created_timestamp: The created timestamp for the alias.
    :vartype created_timestamp: str
    :ivar alias_id: The id for the alias.
    :vartype alias_id: str
    :ivar creator_data_item_id: The id for the creator data item that this alias references (could
     be null if the alias has not been assigned).
    :vartype creator_data_item_id: str
    :ivar last_updated_timestamp: The timestamp of the last time the alias was assigned.
    :vartype last_updated_timestamp: str
    """

    _validation = {
        'created_timestamp': {'readonly': True},
        'alias_id': {'readonly': True},
        'creator_data_item_id': {'readonly': True},
        'last_updated_timestamp': {'readonly': True},
    }

    _attribute_map = {
        'created_timestamp': {'key': 'createdTimestamp', 'type': 'str'},
        'alias_id': {'key': 'aliasId', 'type': 'str'},
        'creator_data_item_id': {'key': 'creatorDataItemId', 'type': 'str'},
        'last_updated_timestamp': {'key': 'lastUpdatedTimestamp', 'type': 'str'},
    }

    def __init__(
        self,
        **kwargs
    ):
        super(AliasListItem, self).__init__(**kwargs)
        self.created_timestamp = None
        self.alias_id = None
        self.creator_data_item_id = None
        self.last_updated_timestamp = None


class AliasListResponse(msrest.serialization.Model):
    """The response model for the List API. Returns a list of all the previously created aliases.

    Variables are only populated by the server, and will be ignored when sending a request.

    :ivar aliases: A list of all the previously created aliases.
    :vartype aliases: list[~azure.maps.creator.models.AliasListItem]
    :ivar next_link: If present, the location of the next page of data.
    :vartype next_link: str
    """

    _validation = {
        'aliases': {'readonly': True},
        'next_link': {'readonly': True},
    }

    _attribute_map = {
        'aliases': {'key': 'aliases', 'type': '[AliasListItem]'},
        'next_link': {'key': 'nextLink', 'type': 'str'},
    }

    def __init__(
        self,
        **kwargs
    ):
        super(AliasListResponse, self).__init__(**kwargs)
        self.aliases = None
        self.next_link = None


class BooleanRuleObject(msrest.serialization.Model):
    """The boolean rule. The color is selected based on the logic value of the key.

    :param true: The color when value is true. Color is a JSON string in a variety of permitted
     formats, HTML-style hex values, RGB ("#ff0", "#ffff00", "rgb(255, 255, 0)"), RGBA ("rgba(255,
     255, 0, 1)"), HSL("hsl(100, 50%, 50%)"), and HSLA("hsla(100, 50%, 50%, 1)"). Predefined HTML
     colors names, like yellow and blue, are also permitted.
    :type true: str
    :param false: The color when value is false. Color is a JSON string in a variety of permitted
     formats, HTML-style hex values, RGB ("#ff0", "#ffff00", "rgb(255, 255, 0)"), RGBA ("rgba(255,
     255, 0, 1)"), HSL("hsl(100, 50%, 50%)"), and HSLA("hsla(100, 50%, 50%, 1)"). Predefined HTML
     colors names, like yellow and blue, are also permitted.
    :type false: str
    """

    _attribute_map = {
        'true': {'key': 'true', 'type': 'str'},
        'false': {'key': 'false', 'type': 'str'},
    }

    def __init__(
        self,
        *,
        true: Optional[str] = None,
        false: Optional[str] = None,
        **kwargs
    ):
        super(BooleanRuleObject, self).__init__(**kwargs)
        self.true = true
        self.false = false


class StyleObject(msrest.serialization.Model):
    """The stateset style model. The style rule could be a numeric type style rule or a boolean type style rule.  Refer to NumberRuleObject, StringRuleObject and BooleanRuleObject definitions `here <https://aka.ms/AzureMapsStatesetStylesObject>`_.

    You probably want to use the sub-classes and not this class directly. Known
    sub-classes are: BooleanTypeStyleRule, NumberTypeStyleRule, StringTypeStyleRule.

    All required parameters must be populated in order to send to Azure.

    :param key_name: Required. Stateset style key name. Key names are random strings but they
     should be unique inside style array.
    :type key_name: str
    :param type: Required. The type of stateset style.Constant filled by server.  Possible values
     include: "boolean", "number", "string".
    :type type: str or ~azure.maps.creator.models.StyleObjectType
    """

    _validation = {
        'key_name': {'required': True},
        'type': {'required': True},
    }

    _attribute_map = {
        'key_name': {'key': 'keyName', 'type': 'str'},
        'type': {'key': 'type', 'type': 'str'},
    }

    _subtype_map = {
        'type': {'boolean': 'BooleanTypeStyleRule', 'number': 'NumberTypeStyleRule', 'string': 'StringTypeStyleRule'}
    }

    def __init__(
        self,
        *,
        key_name: str,
        **kwargs
    ):
        super(StyleObject, self).__init__(**kwargs)
        self.key_name = key_name
        self.type = None  # type: Optional[str]


class BooleanTypeStyleRule(StyleObject):
    """The boolean type style rule object.

    All required parameters must be populated in order to send to Azure.

    :param key_name: Required. Stateset style key name. Key names are random strings but they
     should be unique inside style array.
    :type key_name: str
    :param type: Required. The type of stateset style.Constant filled by server.  Possible values
     include: "boolean", "number", "string".
    :type type: str or ~azure.maps.creator.models.StyleObjectType
    :param rules: Required. Boolean style rules.
    :type rules: list[~azure.maps.creator.models.BooleanRuleObject]
    """

    _validation = {
        'key_name': {'required': True},
        'type': {'required': True},
        'rules': {'required': True},
    }

    _attribute_map = {
        'key_name': {'key': 'keyName', 'type': 'str'},
        'type': {'key': 'type', 'type': 'str'},
        'rules': {'key': 'rules', 'type': '[BooleanRuleObject]'},
    }

    def __init__(
        self,
        *,
        key_name: str,
        rules: List["BooleanRuleObject"],
        **kwargs
    ):
        super(BooleanTypeStyleRule, self).__init__(key_name=key_name, **kwargs)
        self.type = 'boolean'  # type: str
        self.rules = rules


class BufferRequestBody(msrest.serialization.Model):
    """An object with a FeatureCollection and a list of distances.  All the feature's properties should contain ``geometryId``\ , which is used for identifying the geometry and is case-sensitive.

    :param geometries: A valid ``GeoJSON FeatureCollection`` object type. Please refer to `RFC 7946
     <https://tools.ietf.org/html/rfc7946#section-3.3>`_ for details.
    :type geometries: ~azure.maps.creator.models.GeoJsonFeatureCollection
    :param distances: List of the distances to compute the buffer for, one-to-one per Feature in
     the collection, or one for all Features in the collection.
    :type distances: list[float]
    """

    _attribute_map = {
        'geometries': {'key': 'geometries', 'type': 'GeoJsonFeatureCollection'},
        'distances': {'key': 'distances', 'type': '[float]'},
    }

    def __init__(
        self,
        *,
        geometries: Optional["GeoJsonFeatureCollection"] = None,
        distances: Optional[List[float]] = None,
        **kwargs
    ):
        super(BufferRequestBody, self).__init__(**kwargs)
        self.geometries = geometries
        self.distances = distances


class BufferResponse(msrest.serialization.Model):
    """This object is returned from a successful Spatial Buffer call.

    Variables are only populated by the server, and will be ignored when sending a request.

    :ivar summary: Summary of the call.
    :vartype summary: ~azure.maps.creator.models.BufferResponseSummary
    :param result: The FeatureCollection of buffers for the input.
    :type result: ~azure.maps.creator.models.GeoJsonFeatureCollection
    """

    _validation = {
        'summary': {'readonly': True},
    }

    _attribute_map = {
        'summary': {'key': 'summary', 'type': 'BufferResponseSummary'},
        'result': {'key': 'result', 'type': 'GeoJsonFeatureCollection'},
    }

    def __init__(
        self,
        *,
        result: Optional["GeoJsonFeatureCollection"] = None,
        **kwargs
    ):
        super(BufferResponse, self).__init__(**kwargs)
        self.summary = None
        self.result = result


class BufferResponseSummary(msrest.serialization.Model):
    """Summary of the call.

    Variables are only populated by the server, and will be ignored when sending a request.

    :ivar udid: The udid for the user data if one exists.
    :vartype udid: str
    :ivar information: The information about what happened during the call.
    :vartype information: str
    """

    _validation = {
        'udid': {'readonly': True},
        'information': {'readonly': True},
    }

    _attribute_map = {
        'udid': {'key': 'udid', 'type': 'str'},
        'information': {'key': 'information', 'type': 'str'},
    }

    def __init__(
        self,
        **kwargs
    ):
        super(BufferResponseSummary, self).__init__(**kwargs)
        self.udid = None
        self.information = None


class ClosestPointResponse(msrest.serialization.Model):
    """This object is returned from a successful Spatial Closest Point call.

    Variables are only populated by the server, and will be ignored when sending a request.

    :ivar summary: Closest Point Summary object.
    :vartype summary: ~azure.maps.creator.models.ClosestPointSummary
    :param result: Closest Point Result Array.
    :type result: list[~azure.maps.creator.models.ClosestPointResultEntry]
    """

    _validation = {
        'summary': {'readonly': True},
    }

    _attribute_map = {
        'summary': {'key': 'summary', 'type': 'ClosestPointSummary'},
        'result': {'key': 'result', 'type': '[ClosestPointResultEntry]'},
    }

    def __init__(
        self,
        *,
        result: Optional[List["ClosestPointResultEntry"]] = None,
        **kwargs
    ):
        super(ClosestPointResponse, self).__init__(**kwargs)
        self.summary = None
        self.result = result


class ClosestPointResultEntry(msrest.serialization.Model):
    """Closest Point Result Entry Object.

    Variables are only populated by the server, and will be ignored when sending a request.

    :ivar distance_in_meters: The distance in meters from the source point to the closest point.
    :vartype distance_in_meters: float
    :param position: A location represented as a latitude and longitude.
    :type position: ~azure.maps.creator.models.SpatialCoordinate
    :ivar geometry_id: The unique id identifies a geometry.
    :vartype geometry_id: str
    """

    _validation = {
        'distance_in_meters': {'readonly': True},
        'geometry_id': {'readonly': True},
    }

    _attribute_map = {
        'distance_in_meters': {'key': 'distanceInMeters', 'type': 'float'},
        'position': {'key': 'position', 'type': 'SpatialCoordinate'},
        'geometry_id': {'key': 'geometryId', 'type': 'str'},
    }

    def __init__(
        self,
        *,
        position: Optional["SpatialCoordinate"] = None,
        **kwargs
    ):
        super(ClosestPointResultEntry, self).__init__(**kwargs)
        self.distance_in_meters = None
        self.position = position
        self.geometry_id = None


class ClosestPointSummary(msrest.serialization.Model):
    """Closest Point Summary object.

    Variables are only populated by the server, and will be ignored when sending a request.

    :param source_point: A location represented as a latitude and longitude.
    :type source_point: ~azure.maps.creator.models.SpatialCoordinate
    :ivar udid: A unique data id (udid) for the uploaded content.
    :vartype udid: str
    :ivar information: Processing information.
    :vartype information: str
    """

    _validation = {
        'udid': {'readonly': True},
        'information': {'readonly': True},
    }

    _attribute_map = {
        'source_point': {'key': 'sourcePoint', 'type': 'SpatialCoordinate'},
        'udid': {'key': 'udid', 'type': 'str'},
        'information': {'key': 'information', 'type': 'str'},
    }

    def __init__(
        self,
        *,
        source_point: Optional["SpatialCoordinate"] = None,
        **kwargs
    ):
        super(ClosestPointSummary, self).__init__(**kwargs)
        self.source_point = source_point
        self.udid = None
        self.information = None


class CollectionDefinitionResponse(msrest.serialization.Model):
    """collection of GeoJSON features.

    Variables are only populated by the server, and will be ignored when sending a request.

    All required parameters must be populated in order to send to Azure.

    :param description: describes the collection.
    :type description: str
    :param id_prefix: Required. prefix of the collection used.
    :type id_prefix: str
    :param name: Required. identifier of the collection used, for example, in URIs.
    :type name: str
    :param title: title of collection.
    :type title: str
    :ivar ontology: The ontology version of this dataset.
    :vartype ontology: str
    :param geometry_type: Required. type of geometry returned. Possible values include: "Point",
     "MultiPoint", "LineString", "MultiLineString", "Polygon", "MultiPolygon", "GeometryCollection".
    :type geometry_type: str or ~azure.maps.creator.models.GeoJsonGeometryType
    :param feature_types: Required. type of features returned.
    :type feature_types: list[str]
    :param properties: attributes of the collection used.
    :type properties: list[~azure.maps.creator.models.DefinitionProperties]
    :param links: Links to other WFS endpoints.
    :type links: list[~azure.maps.creator.models.WfsEndpointLink]
    """

    _validation = {
        'id_prefix': {'required': True},
        'name': {'required': True},
        'ontology': {'readonly': True},
        'geometry_type': {'required': True},
        'feature_types': {'required': True},
    }

    _attribute_map = {
        'description': {'key': 'description', 'type': 'str'},
        'id_prefix': {'key': 'idPrefix', 'type': 'str'},
        'name': {'key': 'name', 'type': 'str'},
        'title': {'key': 'title', 'type': 'str'},
        'ontology': {'key': 'ontology', 'type': 'str'},
        'geometry_type': {'key': 'geometryType', 'type': 'str'},
        'feature_types': {'key': 'featureTypes', 'type': '[str]'},
        'properties': {'key': 'properties', 'type': '[DefinitionProperties]'},
        'links': {'key': 'links', 'type': '[WfsEndpointLink]'},
    }

    def __init__(
        self,
        *,
        id_prefix: str,
        name: str,
        geometry_type: Union[str, "GeoJsonGeometryType"],
        feature_types: List[str],
        description: Optional[str] = None,
        title: Optional[str] = None,
        properties: Optional[List["DefinitionProperties"]] = None,
        links: Optional[List["WfsEndpointLink"]] = None,
        **kwargs
    ):
        super(CollectionDefinitionResponse, self).__init__(**kwargs)
        self.description = description
        self.id_prefix = id_prefix
        self.name = name
        self.title = title
        self.ontology = None
        self.geometry_type = geometry_type
        self.feature_types = feature_types
        self.properties = properties
        self.links = links


class CollectionInfo(msrest.serialization.Model):
    """CollectionInfo.

    Variables are only populated by the server, and will be ignored when sending a request.

    All required parameters must be populated in order to send to Azure.

    :param name: Required. identifier of the collection used, for example, in URIs.
    :type name: str
    :param title: human readable title of the collection.
    :type title: str
    :ivar ontology: The ontology version of this dataset.
    :vartype ontology: str
    :param description: a description of the features in the collection.
    :type description: str
    :param links: Required. Links to other WFS endpoints.
    :type links: list[~azure.maps.creator.models.WfsEndpointLink]
    """

    _validation = {
        'name': {'required': True},
        'ontology': {'readonly': True},
        'links': {'required': True},
    }

    _attribute_map = {
        'name': {'key': 'name', 'type': 'str'},
        'title': {'key': 'title', 'type': 'str'},
        'ontology': {'key': 'ontology', 'type': 'str'},
        'description': {'key': 'description', 'type': 'str'},
        'links': {'key': 'links', 'type': '[WfsEndpointLink]'},
    }

    def __init__(
        self,
        *,
        name: str,
        links: List["WfsEndpointLink"],
        title: Optional[str] = None,
        description: Optional[str] = None,
        **kwargs
    ):
        super(CollectionInfo, self).__init__(**kwargs)
        self.name = name
        self.title = title
        self.ontology = None
        self.description = description
        self.links = links


class CollectionsResponse(msrest.serialization.Model):
    """CollectionsResponse.

    Variables are only populated by the server, and will be ignored when sending a request.

    All required parameters must be populated in order to send to Azure.

    :ivar ontology: The ontology version of this dataset.
    :vartype ontology: str
    :param links: Required. Links to other WFS endpoints.
    :type links: list[~azure.maps.creator.models.WfsEndpointLink]
    :param collections: Required. All the collections in a given dataset.
    :type collections: list[~azure.maps.creator.models.CollectionInfo]
    """

    _validation = {
        'ontology': {'readonly': True},
        'links': {'required': True},
        'collections': {'required': True},
    }

    _attribute_map = {
        'ontology': {'key': 'ontology', 'type': 'str'},
        'links': {'key': 'links', 'type': '[WfsEndpointLink]'},
        'collections': {'key': 'collections', 'type': '[CollectionInfo]'},
    }

    def __init__(
        self,
        *,
        links: List["WfsEndpointLink"],
        collections: List["CollectionInfo"],
        **kwargs
    ):
        super(CollectionsResponse, self).__init__(**kwargs)
        self.ontology = None
        self.links = links
        self.collections = collections


class ConformanceResponse(msrest.serialization.Model):
    """ConformanceResponse.

    All required parameters must be populated in order to send to Azure.

    :param conforms_to: Required. List of requirements classes that the server conforms to.
    :type conforms_to: list[str]
    """

    _validation = {
        'conforms_to': {'required': True},
    }

    _attribute_map = {
        'conforms_to': {'key': 'conformsTo', 'type': '[str]'},
    }

    def __init__(
        self,
        *,
        conforms_to: List[str],
        **kwargs
    ):
        super(ConformanceResponse, self).__init__(**kwargs)
        self.conforms_to = conforms_to


class ConversionListDetailInfo(msrest.serialization.Model):
    """Detail information for the conversion requests.

    Variables are only populated by the server, and will be ignored when sending a request.

    :ivar conversion_id: A unique id that represents the artifact of a *successfully* completed
     conversion process.
    :vartype conversion_id: str
    :ivar ontology: The ontology version of this dataset.
    :vartype ontology: str
    :ivar udid: The unique id of the content provided to create this conversion.
    :vartype udid: str
    :ivar created: The date and time of this conversion.
    :vartype created: str
    :ivar description: User provided description of the content being converted.
    :vartype description: str
    :ivar feature_counts: A summary of feature counts in this conversion.
    :vartype feature_counts: any
    """

    _validation = {
        'conversion_id': {'readonly': True},
        'ontology': {'readonly': True},
        'udid': {'readonly': True},
        'created': {'readonly': True},
        'description': {'readonly': True},
        'feature_counts': {'readonly': True},
    }

    _attribute_map = {
        'conversion_id': {'key': 'conversionId', 'type': 'str'},
        'ontology': {'key': 'ontology', 'type': 'str'},
        'udid': {'key': 'udid', 'type': 'str'},
        'created': {'key': 'created', 'type': 'str'},
        'description': {'key': 'description', 'type': 'str'},
        'feature_counts': {'key': 'featureCounts', 'type': 'object'},
    }

    def __init__(
        self,
        **kwargs
    ):
        super(ConversionListDetailInfo, self).__init__(**kwargs)
        self.conversion_id = None
        self.ontology = None
        self.udid = None
        self.created = None
        self.description = None
        self.feature_counts = None


class ConversionListResponse(msrest.serialization.Model):
    """The response model for the Conversion List API.

    Variables are only populated by the server, and will be ignored when sending a request.

    :ivar conversions: A list of all the previously submitted conversion requests.
    :vartype conversions: list[~azure.maps.creator.models.ConversionListDetailInfo]
    :ivar next_link: If present, the location of the next page of data.
    :vartype next_link: str
    """

    _validation = {
        'conversions': {'readonly': True},
        'next_link': {'readonly': True},
    }

    _attribute_map = {
        'conversions': {'key': 'conversions', 'type': '[ConversionListDetailInfo]'},
        'next_link': {'key': 'nextLink', 'type': 'str'},
    }

    def __init__(
        self,
        **kwargs
    ):
        super(ConversionListResponse, self).__init__(**kwargs)
        self.conversions = None
        self.next_link = None


class DatasetDetailInfo(msrest.serialization.Model):
    """Detail information for the dataset.

    Variables are only populated by the server, and will be ignored when sending a request.

    :ivar created: The created timestamp for the dataset.
    :vartype created: str
    :ivar dataset_id: The id for the dataset.
    :vartype dataset_id: str
    :ivar ontology: The ontology version of this dataset.
    :vartype ontology: str
    :ivar description: The description for the dataset.
    :vartype description: str
    :param dataset_sources: Information about the details of the create request for the dataset.
    :type dataset_sources: ~azure.maps.creator.models.DatasetSources
    :ivar feature_counts: The feature counts for the dataset.
    :vartype feature_counts: any
    """

    _validation = {
        'created': {'readonly': True},
        'dataset_id': {'readonly': True},
        'ontology': {'readonly': True},
        'description': {'readonly': True},
        'feature_counts': {'readonly': True},
    }

    _attribute_map = {
        'created': {'key': 'created', 'type': 'str'},
        'dataset_id': {'key': 'datasetId', 'type': 'str'},
        'ontology': {'key': 'ontology', 'type': 'str'},
        'description': {'key': 'description', 'type': 'str'},
        'dataset_sources': {'key': 'datasetSources', 'type': 'DatasetSources'},
        'feature_counts': {'key': 'featureCounts', 'type': 'object'},
    }

    def __init__(
        self,
        *,
        dataset_sources: Optional["DatasetSources"] = None,
        **kwargs
    ):
        super(DatasetDetailInfo, self).__init__(**kwargs)
        self.created = None
        self.dataset_id = None
        self.ontology = None
        self.description = None
        self.dataset_sources = dataset_sources
        self.feature_counts = None


class DatasetListResponse(msrest.serialization.Model):
    """The response model for the Dataset List API. The response body will contain a list of all the previously created datasets.

    Variables are only populated by the server, and will be ignored when sending a request.

    :ivar datasets: A list of all the previously created datasets.
    :vartype datasets: list[~azure.maps.creator.models.DatasetDetailInfo]
    :ivar next_link: If present, the location of the next page of data.
    :vartype next_link: str
    """

    _validation = {
        'datasets': {'readonly': True},
        'next_link': {'readonly': True},
    }

    _attribute_map = {
        'datasets': {'key': 'datasets', 'type': '[DatasetDetailInfo]'},
        'next_link': {'key': 'nextLink', 'type': 'str'},
    }

    def __init__(
        self,
        **kwargs
    ):
        super(DatasetListResponse, self).__init__(**kwargs)
        self.datasets = None
        self.next_link = None


class DatasetSources(msrest.serialization.Model):
    """Information about the details of the create request for the dataset.

    Variables are only populated by the server, and will be ignored when sending a request.

    :ivar conversion_ids: The list of ``conversionId`` that were used to create the dataset.
    :vartype conversion_ids: list[str]
    :ivar append_dataset_id: The dataset that was appended to to create the current dataset.
    :vartype append_dataset_id: str
    """

    _validation = {
        'conversion_ids': {'readonly': True},
        'append_dataset_id': {'readonly': True},
    }

    _attribute_map = {
        'conversion_ids': {'key': 'conversionIds', 'type': '[str]'},
        'append_dataset_id': {'key': 'appendDatasetId', 'type': 'str'},
    }

    def __init__(
        self,
        **kwargs
    ):
        super(DatasetSources, self).__init__(**kwargs)
        self.conversion_ids = None
        self.append_dataset_id = None


class DefinitionProperties(msrest.serialization.Model):
    """DefinitionProperties.

    All required parameters must be populated in order to send to Azure.

    :param name: Required. name of attribute.
    :type name: str
    :param required: Required. is attribute required.
    :type required: bool
    :param type: Required. type of attribute.
    :type type: any
    """

    _validation = {
        'name': {'required': True},
        'required': {'required': True},
        'type': {'required': True},
    }

    _attribute_map = {
        'name': {'key': 'name', 'type': 'str'},
        'required': {'key': 'required', 'type': 'bool'},
        'type': {'key': 'type', 'type': 'object'},
    }

    def __init__(
        self,
        *,
        name: str,
        required: bool,
        type: Any,
        **kwargs
    ):
        super(DefinitionProperties, self).__init__(**kwargs)
        self.name = name
        self.required = required
        self.type = type


class ErrorAdditionalInfo(msrest.serialization.Model):
    """The resource management error additional info.

    Variables are only populated by the server, and will be ignored when sending a request.

    :ivar type: The additional info type.
    :vartype type: str
    :ivar info: The additional info.
    :vartype info: any
    """

    _validation = {
        'type': {'readonly': True},
        'info': {'readonly': True},
    }

    _attribute_map = {
        'type': {'key': 'type', 'type': 'str'},
        'info': {'key': 'info', 'type': 'object'},
    }

    def __init__(
        self,
        **kwargs
    ):
        super(ErrorAdditionalInfo, self).__init__(**kwargs)
        self.type = None
        self.info = None


class ErrorDetail(msrest.serialization.Model):
    """The error detail.

    Variables are only populated by the server, and will be ignored when sending a request.

    :ivar code: The error code.
    :vartype code: str
    :ivar message: The error message.
    :vartype message: str
    :ivar target: The error target.
    :vartype target: str
    :ivar details: The error details.
    :vartype details: list[~azure.maps.creator.models.ErrorDetail]
    :ivar additional_info: The error additional info.
    :vartype additional_info: list[~azure.maps.creator.models.ErrorAdditionalInfo]
    """

    _validation = {
        'code': {'readonly': True},
        'message': {'readonly': True},
        'target': {'readonly': True},
        'details': {'readonly': True},
        'additional_info': {'readonly': True},
    }

    _attribute_map = {
        'code': {'key': 'code', 'type': 'str'},
        'message': {'key': 'message', 'type': 'str'},
        'target': {'key': 'target', 'type': 'str'},
        'details': {'key': 'details', 'type': '[ErrorDetail]'},
        'additional_info': {'key': 'additionalInfo', 'type': '[ErrorAdditionalInfo]'},
    }

    def __init__(
        self,
        **kwargs
    ):
        super(ErrorDetail, self).__init__(**kwargs)
        self.code = None
        self.message = None
        self.target = None
        self.details = None
        self.additional_info = None


class ErrorResponse(msrest.serialization.Model):
    """Common error response for all Azure Resource Manager APIs to return error details for failed operations. (This also follows the OData error response format.).

    :param error: The error object.
    :type error: ~azure.maps.creator.models.ErrorDetail
    """

    _attribute_map = {
        'error': {'key': 'error', 'type': 'ErrorDetail'},
    }

    def __init__(
        self,
        *,
        error: Optional["ErrorDetail"] = None,
        **kwargs
    ):
        super(ErrorResponse, self).__init__(**kwargs)
        self.error = error


class ExtendedGeoJsonFeatureCollectionData(msrest.serialization.Model):
    """ExtendedGeoJsonFeatureCollectionData.

    Variables are only populated by the server, and will be ignored when sending a request.

    :ivar ontology: The ontology version of this dataset.
    :vartype ontology: str
    :param number_returned: Number of returned features.
    :type number_returned: int
    :param links: Links to other WFS endpoints.
    :type links: list[~azure.maps.creator.models.WfsEndpointLink]
    """

    _validation = {
        'ontology': {'readonly': True},
    }

    _attribute_map = {
        'ontology': {'key': 'ontology', 'type': 'str'},
        'number_returned': {'key': 'numberReturned', 'type': 'int'},
        'links': {'key': 'links', 'type': '[WfsEndpointLink]'},
    }

    def __init__(
        self,
        *,
        number_returned: Optional[int] = None,
        links: Optional[List["WfsEndpointLink"]] = None,
        **kwargs
    ):
        super(ExtendedGeoJsonFeatureCollectionData, self).__init__(**kwargs)
        self.ontology = None
        self.number_returned = number_returned
        self.links = links


class GeoJsonFeatureCollectionData(msrest.serialization.Model):
    """GeoJsonFeatureCollectionData.

    All required parameters must be populated in order to send to Azure.

    :param features: Required. Contains a list of valid ``GeoJSON Feature`` objects.
    :type features: list[~azure.maps.creator.models.GeoJsonFeature]
    """

    _validation = {
        'features': {'required': True},
    }

    _attribute_map = {
        'features': {'key': 'features', 'type': '[GeoJsonFeature]'},
    }

    def __init__(
        self,
        *,
        features: List["GeoJsonFeature"],
        **kwargs
    ):
        super(GeoJsonFeatureCollectionData, self).__init__(**kwargs)
        self.features = features


class GeoJsonObject(msrest.serialization.Model):
    """A valid ``GeoJSON`` object. Please refer to `RFC 7946 <https://tools.ietf.org/html/rfc7946#section-3>`_ for details.

    You probably want to use the sub-classes and not this class directly. Known
    sub-classes are: GeoJsonFeature, GeoJsonFeatureCollection, GeoJsonGeometry.

    All required parameters must be populated in order to send to Azure.

    :param type: Required. Specifies the ``GeoJSON`` type. Must be one of the nine valid GeoJSON
     object types - Point, MultiPoint, LineString, MultiLineString, Polygon, MultiPolygon,
     GeometryCollection, Feature and FeatureCollection.Constant filled by server.  Possible values
     include: "Point", "MultiPoint", "LineString", "MultiLineString", "Polygon", "MultiPolygon",
     "GeometryCollection", "Feature", "FeatureCollection".
    :type type: str or ~azure.maps.creator.models.GeoJsonObjectType
    """

    _validation = {
        'type': {'required': True},
    }

    _attribute_map = {
        'type': {'key': 'type', 'type': 'str'},
    }

    _subtype_map = {
        'type': {'Feature': 'GeoJsonFeature', 'FeatureCollection': 'GeoJsonFeatureCollection', 'GeoJsonGeometry': 'GeoJsonGeometry'}
    }

    def __init__(
        self,
        **kwargs
    ):
        super(GeoJsonObject, self).__init__(**kwargs)
        self.type = None  # type: Optional[str]


class GeoJsonFeatureCollection(GeoJsonObject, GeoJsonFeatureCollectionData):
    """A valid ``GeoJSON FeatureCollection`` object type. Please refer to `RFC 7946 <https://tools.ietf.org/html/rfc7946#section-3.3>`_ for details.

    You probably want to use the sub-classes and not this class directly. Known
    sub-classes are: ExtendedGeoJsonFeatureCollection.

    All required parameters must be populated in order to send to Azure.

    :param features: Required. Contains a list of valid ``GeoJSON Feature`` objects.
    :type features: list[~azure.maps.creator.models.GeoJsonFeature]
    :param type: Required. Specifies the ``GeoJSON`` type. Must be one of the nine valid GeoJSON
     object types - Point, MultiPoint, LineString, MultiLineString, Polygon, MultiPolygon,
     GeometryCollection, Feature and FeatureCollection.Constant filled by server.  Possible values
     include: "Point", "MultiPoint", "LineString", "MultiLineString", "Polygon", "MultiPolygon",
     "GeometryCollection", "Feature", "FeatureCollection".
    :type type: str or ~azure.maps.creator.models.GeoJsonObjectType
    """

    _validation = {
        'features': {'required': True},
        'type': {'required': True},
    }

    _attribute_map = {
        'features': {'key': 'features', 'type': '[GeoJsonFeature]'},
        'type': {'key': 'type', 'type': 'str'},
    }

    _subtype_map = {
        'type': {'FeatureCollection': 'ExtendedGeoJsonFeatureCollection'}
    }

    def __init__(
        self,
        *,
        features: List["GeoJsonFeature"],
        **kwargs
    ):
        super(GeoJsonFeatureCollection, self).__init__(features=features, **kwargs)
        self.features = features
        self.type = 'FeatureCollection'  # type: str
        self.type = 'FeatureCollection'  # type: str


class ExtendedGeoJsonFeatureCollection(GeoJsonFeatureCollection, ExtendedGeoJsonFeatureCollectionData):
    """A valid ``GeoJSON FeatureCollection`` object type extended with numberReturned and links array. Please refer to `RFC 7946 <https://tools.ietf.org/html/rfc7946#section-3.3>`_ for details.

    Variables are only populated by the server, and will be ignored when sending a request.

    All required parameters must be populated in order to send to Azure.

    :ivar ontology: The ontology version of this dataset.
    :vartype ontology: str
    :param number_returned: Number of returned features.
    :type number_returned: int
    :param links: Links to other WFS endpoints.
    :type links: list[~azure.maps.creator.models.WfsEndpointLink]
    :param features: Required. Contains a list of valid ``GeoJSON Feature`` objects.
    :type features: list[~azure.maps.creator.models.GeoJsonFeature]
    :param type: Required. Specifies the ``GeoJSON`` type. Must be one of the nine valid GeoJSON
     object types - Point, MultiPoint, LineString, MultiLineString, Polygon, MultiPolygon,
     GeometryCollection, Feature and FeatureCollection.Constant filled by server.  Possible values
     include: "Point", "MultiPoint", "LineString", "MultiLineString", "Polygon", "MultiPolygon",
     "GeometryCollection", "Feature", "FeatureCollection".
    :type type: str or ~azure.maps.creator.models.GeoJsonObjectType
    """

    _validation = {
        'ontology': {'readonly': True},
        'features': {'required': True},
        'type': {'required': True},
    }

    _attribute_map = {
        'ontology': {'key': 'ontology', 'type': 'str'},
        'number_returned': {'key': 'numberReturned', 'type': 'int'},
        'links': {'key': 'links', 'type': '[WfsEndpointLink]'},
        'features': {'key': 'features', 'type': '[GeoJsonFeature]'},
        'type': {'key': 'type', 'type': 'str'},
    }

    def __init__(
        self,
        *,
        features: List["GeoJsonFeature"],
        number_returned: Optional[int] = None,
        links: Optional[List["WfsEndpointLink"]] = None,
        **kwargs
    ):
        super(ExtendedGeoJsonFeatureCollection, self).__init__(features=features, number_returned=number_returned, links=links, **kwargs)
        self.ontology = None
        self.number_returned = number_returned
        self.links = links
        self.type = 'FeatureCollection'  # type: str
        self.features = features
        self.type = 'FeatureCollection'  # type: str


class FeatureResponse(msrest.serialization.Model):
    """FeatureResponse.

    Variables are only populated by the server, and will be ignored when sending a request.

    All required parameters must be populated in order to send to Azure.

    :ivar ontology: The ontology version of this dataset.
    :vartype ontology: str
    :param feature: Required. A valid ``GeoJSON Feature`` object type. Please refer to `RFC 7946
     <https://tools.ietf.org/html/rfc7946#section-3.2>`_ for details.
    :type feature: ~azure.maps.creator.models.GeoJsonFeature
    :param links: Links to other WFS endpoints.
    :type links: list[~azure.maps.creator.models.WfsEndpointLink]
    """

    _validation = {
        'ontology': {'readonly': True},
        'feature': {'required': True},
    }

    _attribute_map = {
        'ontology': {'key': 'ontology', 'type': 'str'},
        'feature': {'key': 'feature', 'type': 'GeoJsonFeature'},
        'links': {'key': 'links', 'type': '[WfsEndpointLink]'},
    }

    def __init__(
        self,
        *,
        feature: "GeoJsonFeature",
        links: Optional[List["WfsEndpointLink"]] = None,
        **kwargs
    ):
        super(FeatureResponse, self).__init__(**kwargs)
        self.ontology = None
        self.feature = feature
        self.links = links


class FeatureStateObject(msrest.serialization.Model):
    """Single feature state model.

    :param key_name: Feature state Keyname. Maximum length allowed is 1000.
    :type key_name: str
    :param value: Value for the feature state. Type should comply with the style definition
     attached to the featurestate. Maximum length allowed for string type is 1024.
    :type value: any
    :param event_timestamp: Valid Timestamp when the feature state was captured.
    :type event_timestamp: str
    """

    _attribute_map = {
        'key_name': {'key': 'keyName', 'type': 'str'},
        'value': {'key': 'value', 'type': 'object'},
        'event_timestamp': {'key': 'eventTimestamp', 'type': 'str'},
    }

    def __init__(
        self,
        *,
        key_name: Optional[str] = None,
        value: Optional[Any] = None,
        event_timestamp: Optional[str] = None,
        **kwargs
    ):
        super(FeatureStateObject, self).__init__(**kwargs)
        self.key_name = key_name
        self.value = value
        self.event_timestamp = event_timestamp


class FeatureStatesStructure(msrest.serialization.Model):
    """The feature states model for a feature.

    :param states: The feature states array.
    :type states: list[~azure.maps.creator.models.FeatureStateObject]
    """

    _attribute_map = {
        'states': {'key': 'states', 'type': '[FeatureStateObject]'},
    }

    def __init__(
        self,
        *,
        states: Optional[List["FeatureStateObject"]] = None,
        **kwargs
    ):
        super(FeatureStatesStructure, self).__init__(**kwargs)
        self.states = states


class GeofenceGeometry(msrest.serialization.Model):
    """The geofencing geometry.

    Variables are only populated by the server, and will be ignored when sending a request.

    :ivar device_id: ID of the device.
    :vartype device_id: str
    :ivar ud_id: The unique id returned from `Data Upload API
     <https://docs.microsoft.com/en-us/rest/api/maps/data/uploadPreview>`_ after uploading a valid
     GeoJSON FeatureCollection object. Please refer to  `RFC 7946
     <https://tools.ietf.org/html/rfc7946#section-3.3>`_ for details. All the feature's properties
     should  contain ``geometryId``\ , which is used for identifying the geometry and is
     case-sensitive.
    :vartype ud_id: str
    :ivar geometry_id: The unique id identifies a geometry.
    :vartype geometry_id: str
    :ivar distance: Distance from the coordinate to the closest border of the geofence. Positive
     means the  coordinate is outside of the geofence. If the coordinate is outside of the geofence,
     but more than the value of searchBuffer away from the closest geofence border, then the value
     is 999. Negative means the coordinate is inside of the geofence. If the coordinate is inside
     the polygon, but more than the value of searchBuffer away from the closest geofencing border,
     then the value is -999. A value of 999 means that there is great confidence the coordinate is
     well outside the geofence. A value of -999 means that there is great confidence the coordinate
     is well within the geofence.
    :vartype distance: float
    :ivar nearest_lat: Latitude of the nearest point of the geometry.
    :vartype nearest_lat: float
    :ivar nearest_lon: Longitude of the nearest point of the geometry.
    :vartype nearest_lon: float
    :ivar nearest_z: Sea level in meter of the nearest point on the 2D extrusion geometry. This
     will only be presented in response when value is provided for 'zInMeter' in the request.
    :vartype nearest_z: float
    """

    _validation = {
        'device_id': {'readonly': True},
        'ud_id': {'readonly': True},
        'geometry_id': {'readonly': True},
        'distance': {'readonly': True},
        'nearest_lat': {'readonly': True},
        'nearest_lon': {'readonly': True},
        'nearest_z': {'readonly': True},
    }

    _attribute_map = {
        'device_id': {'key': 'deviceId', 'type': 'str'},
        'ud_id': {'key': 'udId', 'type': 'str'},
        'geometry_id': {'key': 'geometryId', 'type': 'str'},
        'distance': {'key': 'distance', 'type': 'float'},
        'nearest_lat': {'key': 'nearestLat', 'type': 'float'},
        'nearest_lon': {'key': 'nearestLon', 'type': 'float'},
        'nearest_z': {'key': 'nearestZ', 'type': 'float'},
    }

    def __init__(
        self,
        **kwargs
    ):
        super(GeofenceGeometry, self).__init__(**kwargs)
        self.device_id = None
        self.ud_id = None
        self.geometry_id = None
        self.distance = None
        self.nearest_lat = None
        self.nearest_lon = None
        self.nearest_z = None


class GeofenceResponse(msrest.serialization.Model):
    """This object is returned from a geofence proximity call.

    Variables are only populated by the server, and will be ignored when sending a request.

    :ivar geometries: Lists the fence geometries that contain the coordinate position or overlap
     the searchBuffer around the position.
    :vartype geometries: list[~azure.maps.creator.models.GeofenceGeometry]
    :ivar expired_geofence_geometry_id: Lists of the geometry ID of the geofence which is expired
     relative to the user time in the request.
    :vartype expired_geofence_geometry_id: list[str]
    :ivar invalid_period_geofence_geometry_id: Lists of the geometry ID of the geofence which is in
     invalid period relative to the user time in the request.
    :vartype invalid_period_geofence_geometry_id: list[str]
    :ivar is_event_published: True if at least one event is published to the Azure Maps event
     subscriber, false if no event is published to the Azure Maps event subscriber. This will only
     be presented in response when 'isAsync' query parameter is set to true.
    :vartype is_event_published: bool
    """

    _validation = {
        'geometries': {'readonly': True},
        'expired_geofence_geometry_id': {'readonly': True},
        'invalid_period_geofence_geometry_id': {'readonly': True},
        'is_event_published': {'readonly': True},
    }

    _attribute_map = {
        'geometries': {'key': 'geometries', 'type': '[GeofenceGeometry]'},
        'expired_geofence_geometry_id': {'key': 'expiredGeofenceGeometryId', 'type': '[str]'},
        'invalid_period_geofence_geometry_id': {'key': 'invalidPeriodGeofenceGeometryId', 'type': '[str]'},
        'is_event_published': {'key': 'isEventPublished', 'type': 'bool'},
    }

    def __init__(
        self,
        **kwargs
    ):
        super(GeofenceResponse, self).__init__(**kwargs)
        self.geometries = None
        self.expired_geofence_geometry_id = None
        self.invalid_period_geofence_geometry_id = None
        self.is_event_published = None


class GeoJsonFeatureData(msrest.serialization.Model):
    """GeoJsonFeatureData.

    All required parameters must be populated in order to send to Azure.

    :param geometry: Required. A valid ``GeoJSON`` geometry object. The type must be one of the
     seven valid GeoJSON geometry types - Point, MultiPoint, LineString, MultiLineString, Polygon,
     MultiPolygon and GeometryCollection. Please refer to `RFC 7946
     <https://tools.ietf.org/html/rfc7946#section-3.1>`_ for details.
    :type geometry: ~azure.maps.creator.models.GeoJsonGeometry
    :param properties: Properties can contain any additional metadata about the ``Feature``. Value
     can be any JSON object or a JSON null value.
    :type properties: any
    :param id: Identifier for the feature.
    :type id: str
    :param feature_type: The type of the feature. The value depends on the data model the current
     feature is part of. Some data models may have an empty value.
    :type feature_type: str
    """

    _validation = {
        'geometry': {'required': True},
    }

    _attribute_map = {
        'geometry': {'key': 'geometry', 'type': 'GeoJsonGeometry'},
        'properties': {'key': 'properties', 'type': 'object'},
        'id': {'key': 'id', 'type': 'str'},
        'feature_type': {'key': 'featureType', 'type': 'str'},
    }

    def __init__(
        self,
        *,
        geometry: "GeoJsonGeometry",
        properties: Optional[Any] = None,
        id: Optional[str] = None,
        feature_type: Optional[str] = None,
        **kwargs
    ):
        super(GeoJsonFeatureData, self).__init__(**kwargs)
        self.geometry = geometry
        self.properties = properties
        self.id = id
        self.feature_type = feature_type


class GeoJsonFeature(GeoJsonObject, GeoJsonFeatureData):
    """A valid ``GeoJSON Feature`` object type. Please refer to `RFC 7946 <https://tools.ietf.org/html/rfc7946#section-3.2>`_ for details.

    All required parameters must be populated in order to send to Azure.

    :param geometry: Required. A valid ``GeoJSON`` geometry object. The type must be one of the
     seven valid GeoJSON geometry types - Point, MultiPoint, LineString, MultiLineString, Polygon,
     MultiPolygon and GeometryCollection. Please refer to `RFC 7946
     <https://tools.ietf.org/html/rfc7946#section-3.1>`_ for details.
    :type geometry: ~azure.maps.creator.models.GeoJsonGeometry
    :param properties: Properties can contain any additional metadata about the ``Feature``. Value
     can be any JSON object or a JSON null value.
    :type properties: any
    :param id: Identifier for the feature.
    :type id: str
    :param feature_type: The type of the feature. The value depends on the data model the current
     feature is part of. Some data models may have an empty value.
    :type feature_type: str
    :param type: Required. Specifies the ``GeoJSON`` type. Must be one of the nine valid GeoJSON
     object types - Point, MultiPoint, LineString, MultiLineString, Polygon, MultiPolygon,
     GeometryCollection, Feature and FeatureCollection.Constant filled by server.  Possible values
     include: "Point", "MultiPoint", "LineString", "MultiLineString", "Polygon", "MultiPolygon",
     "GeometryCollection", "Feature", "FeatureCollection".
    :type type: str or ~azure.maps.creator.models.GeoJsonObjectType
    """

    _validation = {
        'geometry': {'required': True},
        'type': {'required': True},
    }

    _attribute_map = {
        'geometry': {'key': 'geometry', 'type': 'GeoJsonGeometry'},
        'properties': {'key': 'properties', 'type': 'object'},
        'id': {'key': 'id', 'type': 'str'},
        'feature_type': {'key': 'featureType', 'type': 'str'},
        'type': {'key': 'type', 'type': 'str'},
    }

    def __init__(
        self,
        *,
        geometry: "GeoJsonGeometry",
        properties: Optional[Any] = None,
        id: Optional[str] = None,
        feature_type: Optional[str] = None,
        **kwargs
    ):
        super(GeoJsonFeature, self).__init__(geometry=geometry, properties=properties, id=id, feature_type=feature_type, **kwargs)
        self.geometry = geometry
        self.properties = properties
        self.id = id
        self.feature_type = feature_type
        self.type = 'Feature'  # type: str
        self.type = 'Feature'  # type: str


class GeoJsonGeometry(GeoJsonObject):
    """A valid ``GeoJSON`` geometry object. The type must be one of the seven valid GeoJSON geometry types - Point, MultiPoint, LineString, MultiLineString, Polygon, MultiPolygon and GeometryCollection. Please refer to `RFC 7946 <https://tools.ietf.org/html/rfc7946#section-3.1>`_ for details.

    You probably want to use the sub-classes and not this class directly. Known
    sub-classes are: GeoJsonGeometryCollection, GeoJsonLineString, GeoJsonMultiLineString, GeoJsonMultiPoint, GeoJsonMultiPolygon, GeoJsonPoint, GeoJsonPolygon.

    All required parameters must be populated in order to send to Azure.

    :param type: Required. Specifies the ``GeoJSON`` type. Must be one of the nine valid GeoJSON
     object types - Point, MultiPoint, LineString, MultiLineString, Polygon, MultiPolygon,
     GeometryCollection, Feature and FeatureCollection.Constant filled by server.  Possible values
     include: "Point", "MultiPoint", "LineString", "MultiLineString", "Polygon", "MultiPolygon",
     "GeometryCollection", "Feature", "FeatureCollection".
    :type type: str or ~azure.maps.creator.models.GeoJsonObjectType
    """

    _validation = {
        'type': {'required': True},
    }

    _attribute_map = {
        'type': {'key': 'type', 'type': 'str'},
    }

    _subtype_map = {
        'type': {'GeometryCollection': 'GeoJsonGeometryCollection', 'LineString': 'GeoJsonLineString', 'MultiLineString': 'GeoJsonMultiLineString', 'MultiPoint': 'GeoJsonMultiPoint', 'MultiPolygon': 'GeoJsonMultiPolygon', 'Point': 'GeoJsonPoint', 'Polygon': 'GeoJsonPolygon'}
    }

    def __init__(
        self,
        **kwargs
    ):
        super(GeoJsonGeometry, self).__init__(**kwargs)
        self.type = 'GeoJsonGeometry'  # type: str


class GeoJsonGeometryCollectionData(msrest.serialization.Model):
    """GeoJsonGeometryCollectionData.

    All required parameters must be populated in order to send to Azure.

    :param geometries: Required. Contains a list of valid ``GeoJSON`` geometry objects. **Note**
     that coordinates in GeoJSON are in x, y order (longitude, latitude).
    :type geometries: list[~azure.maps.creator.models.GeoJsonGeometry]
    """

    _validation = {
        'geometries': {'required': True},
    }

    _attribute_map = {
        'geometries': {'key': 'geometries', 'type': '[GeoJsonGeometry]'},
    }

    def __init__(
        self,
        *,
        geometries: List["GeoJsonGeometry"],
        **kwargs
    ):
        super(GeoJsonGeometryCollectionData, self).__init__(**kwargs)
        self.geometries = geometries


class GeoJsonGeometryCollection(GeoJsonGeometry, GeoJsonGeometryCollectionData):
    """A valid ``GeoJSON GeometryCollection`` object type. Please refer to `RFC 7946 <https://tools.ietf.org/html/rfc7946#section-3.1.8>`_ for details.

    All required parameters must be populated in order to send to Azure.

    :param geometries: Required. Contains a list of valid ``GeoJSON`` geometry objects. **Note**
     that coordinates in GeoJSON are in x, y order (longitude, latitude).
    :type geometries: list[~azure.maps.creator.models.GeoJsonGeometry]
    :param type: Required. Specifies the ``GeoJSON`` type. Must be one of the nine valid GeoJSON
     object types - Point, MultiPoint, LineString, MultiLineString, Polygon, MultiPolygon,
     GeometryCollection, Feature and FeatureCollection.Constant filled by server.  Possible values
     include: "Point", "MultiPoint", "LineString", "MultiLineString", "Polygon", "MultiPolygon",
     "GeometryCollection", "Feature", "FeatureCollection".
    :type type: str or ~azure.maps.creator.models.GeoJsonObjectType
    """

    _validation = {
        'geometries': {'required': True},
        'type': {'required': True},
    }

    _attribute_map = {
        'geometries': {'key': 'geometries', 'type': '[GeoJsonGeometry]'},
        'type': {'key': 'type', 'type': 'str'},
    }

    def __init__(
        self,
        *,
        geometries: List["GeoJsonGeometry"],
        **kwargs
    ):
        super(GeoJsonGeometryCollection, self).__init__(geometries=geometries, **kwargs)
        self.geometries = geometries
        self.type = 'GeometryCollection'  # type: str
        self.type = 'GeometryCollection'  # type: str


class GeoJsonLineStringData(msrest.serialization.Model):
    """GeoJsonLineStringData.

    All required parameters must be populated in order to send to Azure.

    :param coordinates: Required. Coordinates for the ``GeoJson LineString`` geometry.
    :type coordinates: list[list[float]]
    """

    _validation = {
        'coordinates': {'required': True},
    }

    _attribute_map = {
        'coordinates': {'key': 'coordinates', 'type': '[[float]]'},
    }

    def __init__(
        self,
        *,
        coordinates: List[List[float]],
        **kwargs
    ):
        super(GeoJsonLineStringData, self).__init__(**kwargs)
        self.coordinates = coordinates


class GeoJsonLineString(GeoJsonGeometry, GeoJsonLineStringData):
    """A valid ``GeoJSON LineString`` geometry type. Please refer to `RFC 7946 <https://tools.ietf.org/html/rfc7946#section-3.1.4>`_ for details.

    All required parameters must be populated in order to send to Azure.

    :param coordinates: Required. Coordinates for the ``GeoJson LineString`` geometry.
    :type coordinates: list[list[float]]
    :param type: Required. Specifies the ``GeoJSON`` type. Must be one of the nine valid GeoJSON
     object types - Point, MultiPoint, LineString, MultiLineString, Polygon, MultiPolygon,
     GeometryCollection, Feature and FeatureCollection.Constant filled by server.  Possible values
     include: "Point", "MultiPoint", "LineString", "MultiLineString", "Polygon", "MultiPolygon",
     "GeometryCollection", "Feature", "FeatureCollection".
    :type type: str or ~azure.maps.creator.models.GeoJsonObjectType
    """

    _validation = {
        'coordinates': {'required': True},
        'type': {'required': True},
    }

    _attribute_map = {
        'coordinates': {'key': 'coordinates', 'type': '[[float]]'},
        'type': {'key': 'type', 'type': 'str'},
    }

    def __init__(
        self,
        *,
        coordinates: List[List[float]],
        **kwargs
    ):
        super(GeoJsonLineString, self).__init__(coordinates=coordinates, **kwargs)
        self.coordinates = coordinates
        self.type = 'LineString'  # type: str
        self.type = 'LineString'  # type: str


class GeoJsonMultiLineStringData(msrest.serialization.Model):
    """GeoJsonMultiLineStringData.

    All required parameters must be populated in order to send to Azure.

    :param coordinates: Required. Coordinates for the ``GeoJson MultiLineString`` geometry.
    :type coordinates: list[list[list[float]]]
    """

    _validation = {
        'coordinates': {'required': True},
    }

    _attribute_map = {
        'coordinates': {'key': 'coordinates', 'type': '[[[float]]]'},
    }

    def __init__(
        self,
        *,
        coordinates: List[List[List[float]]],
        **kwargs
    ):
        super(GeoJsonMultiLineStringData, self).__init__(**kwargs)
        self.coordinates = coordinates


class GeoJsonMultiLineString(GeoJsonGeometry, GeoJsonMultiLineStringData):
    """A valid ``GeoJSON MultiLineString`` geometry type. Please refer to `RFC 7946 <https://tools.ietf.org/html/rfc7946#section-3.1.5>`_ for details.

    All required parameters must be populated in order to send to Azure.

    :param coordinates: Required. Coordinates for the ``GeoJson MultiLineString`` geometry.
    :type coordinates: list[list[list[float]]]
    :param type: Required. Specifies the ``GeoJSON`` type. Must be one of the nine valid GeoJSON
     object types - Point, MultiPoint, LineString, MultiLineString, Polygon, MultiPolygon,
     GeometryCollection, Feature and FeatureCollection.Constant filled by server.  Possible values
     include: "Point", "MultiPoint", "LineString", "MultiLineString", "Polygon", "MultiPolygon",
     "GeometryCollection", "Feature", "FeatureCollection".
    :type type: str or ~azure.maps.creator.models.GeoJsonObjectType
    """

    _validation = {
        'coordinates': {'required': True},
        'type': {'required': True},
    }

    _attribute_map = {
        'coordinates': {'key': 'coordinates', 'type': '[[[float]]]'},
        'type': {'key': 'type', 'type': 'str'},
    }

    def __init__(
        self,
        *,
        coordinates: List[List[List[float]]],
        **kwargs
    ):
        super(GeoJsonMultiLineString, self).__init__(coordinates=coordinates, **kwargs)
        self.coordinates = coordinates
        self.type = 'MultiLineString'  # type: str
        self.type = 'MultiLineString'  # type: str


class GeoJsonMultiPointData(msrest.serialization.Model):
    """Data contained by a ``GeoJson MultiPoint``.

    All required parameters must be populated in order to send to Azure.

    :param coordinates: Required. Coordinates for the ``GeoJson MultiPoint`` geometry.
    :type coordinates: list[list[float]]
    """

    _validation = {
        'coordinates': {'required': True},
    }

    _attribute_map = {
        'coordinates': {'key': 'coordinates', 'type': '[[float]]'},
    }

    def __init__(
        self,
        *,
        coordinates: List[List[float]],
        **kwargs
    ):
        super(GeoJsonMultiPointData, self).__init__(**kwargs)
        self.coordinates = coordinates


class GeoJsonMultiPoint(GeoJsonGeometry, GeoJsonMultiPointData):
    """A valid ``GeoJSON MultiPoint`` geometry type. Please refer to `RFC 7946 <https://tools.ietf.org/html/rfc7946#section-3.1.3>`_ for details.

    All required parameters must be populated in order to send to Azure.

    :param coordinates: Required. Coordinates for the ``GeoJson MultiPoint`` geometry.
    :type coordinates: list[list[float]]
    :param type: Required. Specifies the ``GeoJSON`` type. Must be one of the nine valid GeoJSON
     object types - Point, MultiPoint, LineString, MultiLineString, Polygon, MultiPolygon,
     GeometryCollection, Feature and FeatureCollection.Constant filled by server.  Possible values
     include: "Point", "MultiPoint", "LineString", "MultiLineString", "Polygon", "MultiPolygon",
     "GeometryCollection", "Feature", "FeatureCollection".
    :type type: str or ~azure.maps.creator.models.GeoJsonObjectType
    """

    _validation = {
        'coordinates': {'required': True},
        'type': {'required': True},
    }

    _attribute_map = {
        'coordinates': {'key': 'coordinates', 'type': '[[float]]'},
        'type': {'key': 'type', 'type': 'str'},
    }

    def __init__(
        self,
        *,
        coordinates: List[List[float]],
        **kwargs
    ):
        super(GeoJsonMultiPoint, self).__init__(coordinates=coordinates, **kwargs)
        self.coordinates = coordinates
        self.type = 'MultiPoint'  # type: str
        self.type = 'MultiPoint'  # type: str


class GeoJsonMultiPolygonData(msrest.serialization.Model):
    """GeoJsonMultiPolygonData.

    All required parameters must be populated in order to send to Azure.

    :param coordinates: Required. Contains a list of valid ``GeoJSON Polygon`` objects. **Note**
     that coordinates in GeoJSON are in x, y order (longitude, latitude).
    :type coordinates: list[list[list[list[float]]]]
    """

    _validation = {
        'coordinates': {'required': True},
    }

    _attribute_map = {
        'coordinates': {'key': 'coordinates', 'type': '[[[[float]]]]'},
    }

    def __init__(
        self,
        *,
        coordinates: List[List[List[List[float]]]],
        **kwargs
    ):
        super(GeoJsonMultiPolygonData, self).__init__(**kwargs)
        self.coordinates = coordinates


class GeoJsonMultiPolygon(GeoJsonGeometry, GeoJsonMultiPolygonData):
    """A valid ``GeoJSON MultiPolygon`` object type. Please refer to `RFC 7946 <https://tools.ietf.org/html/rfc7946#section-3.1.7>`_ for details.

    All required parameters must be populated in order to send to Azure.

    :param coordinates: Required. Contains a list of valid ``GeoJSON Polygon`` objects. **Note**
     that coordinates in GeoJSON are in x, y order (longitude, latitude).
    :type coordinates: list[list[list[list[float]]]]
    :param type: Required. Specifies the ``GeoJSON`` type. Must be one of the nine valid GeoJSON
     object types - Point, MultiPoint, LineString, MultiLineString, Polygon, MultiPolygon,
     GeometryCollection, Feature and FeatureCollection.Constant filled by server.  Possible values
     include: "Point", "MultiPoint", "LineString", "MultiLineString", "Polygon", "MultiPolygon",
     "GeometryCollection", "Feature", "FeatureCollection".
    :type type: str or ~azure.maps.creator.models.GeoJsonObjectType
    """

    _validation = {
        'coordinates': {'required': True},
        'type': {'required': True},
    }

    _attribute_map = {
        'coordinates': {'key': 'coordinates', 'type': '[[[[float]]]]'},
        'type': {'key': 'type', 'type': 'str'},
    }

    def __init__(
        self,
        *,
        coordinates: List[List[List[List[float]]]],
        **kwargs
    ):
        super(GeoJsonMultiPolygon, self).__init__(coordinates=coordinates, **kwargs)
        self.coordinates = coordinates
        self.type = 'MultiPolygon'  # type: str
        self.type = 'MultiPolygon'  # type: str


class GeoJsonPointData(msrest.serialization.Model):
    """Data contained by a ``GeoJson Point``.

    All required parameters must be populated in order to send to Azure.

    :param coordinates: Required. A ``Position`` is an array of numbers with two or more elements.
     The first two elements are *longitude* and *latitude*\ , precisely in that order.
     *Altitude/Elevation* is an optional third element. Please refer to `RFC 7946
     <https://tools.ietf.org/html/rfc7946#section-3.1.1>`_ for details.
    :type coordinates: list[float]
    """

    _validation = {
        'coordinates': {'required': True},
    }

    _attribute_map = {
        'coordinates': {'key': 'coordinates', 'type': '[float]'},
    }

    def __init__(
        self,
        *,
        coordinates: List[float],
        **kwargs
    ):
        super(GeoJsonPointData, self).__init__(**kwargs)
        self.coordinates = coordinates


class GeoJsonPoint(GeoJsonGeometry, GeoJsonPointData):
    """A valid ``GeoJSON Point`` geometry type. Please refer to `RFC 7946 <https://tools.ietf.org/html/rfc7946#section-3.1.2>`_ for details.

    All required parameters must be populated in order to send to Azure.

    :param coordinates: Required. A ``Position`` is an array of numbers with two or more elements.
     The first two elements are *longitude* and *latitude*\ , precisely in that order.
     *Altitude/Elevation* is an optional third element. Please refer to `RFC 7946
     <https://tools.ietf.org/html/rfc7946#section-3.1.1>`_ for details.
    :type coordinates: list[float]
    :param type: Required. Specifies the ``GeoJSON`` type. Must be one of the nine valid GeoJSON
     object types - Point, MultiPoint, LineString, MultiLineString, Polygon, MultiPolygon,
     GeometryCollection, Feature and FeatureCollection.Constant filled by server.  Possible values
     include: "Point", "MultiPoint", "LineString", "MultiLineString", "Polygon", "MultiPolygon",
     "GeometryCollection", "Feature", "FeatureCollection".
    :type type: str or ~azure.maps.creator.models.GeoJsonObjectType
    """

    _validation = {
        'coordinates': {'required': True},
        'type': {'required': True},
    }

    _attribute_map = {
        'coordinates': {'key': 'coordinates', 'type': '[float]'},
        'type': {'key': 'type', 'type': 'str'},
    }

    def __init__(
        self,
        *,
        coordinates: List[float],
        **kwargs
    ):
        super(GeoJsonPoint, self).__init__(coordinates=coordinates, **kwargs)
        self.coordinates = coordinates
        self.type = 'Point'  # type: str
        self.type = 'Point'  # type: str


class GeoJsonPolygonData(msrest.serialization.Model):
    """GeoJsonPolygonData.

    All required parameters must be populated in order to send to Azure.

    :param coordinates: Required. Coordinates for the ``GeoJson Polygon`` geometry type.
    :type coordinates: list[list[list[float]]]
    """

    _validation = {
        'coordinates': {'required': True},
    }

    _attribute_map = {
        'coordinates': {'key': 'coordinates', 'type': '[[[float]]]'},
    }

    def __init__(
        self,
        *,
        coordinates: List[List[List[float]]],
        **kwargs
    ):
        super(GeoJsonPolygonData, self).__init__(**kwargs)
        self.coordinates = coordinates


class GeoJsonPolygon(GeoJsonGeometry, GeoJsonPolygonData):
    """A valid ``GeoJSON Polygon`` geometry type. Please refer to `RFC 7946 <https://tools.ietf.org/html/rfc7946#section-3.1.6>`_ for details.

    All required parameters must be populated in order to send to Azure.

    :param coordinates: Required. Coordinates for the ``GeoJson Polygon`` geometry type.
    :type coordinates: list[list[list[float]]]
    :param type: Required. Specifies the ``GeoJSON`` type. Must be one of the nine valid GeoJSON
     object types - Point, MultiPoint, LineString, MultiLineString, Polygon, MultiPolygon,
     GeometryCollection, Feature and FeatureCollection.Constant filled by server.  Possible values
     include: "Point", "MultiPoint", "LineString", "MultiLineString", "Polygon", "MultiPolygon",
     "GeometryCollection", "Feature", "FeatureCollection".
    :type type: str or ~azure.maps.creator.models.GeoJsonObjectType
    """

    _validation = {
        'coordinates': {'required': True},
        'type': {'required': True},
    }

    _attribute_map = {
        'coordinates': {'key': 'coordinates', 'type': '[[[float]]]'},
        'type': {'key': 'type', 'type': 'str'},
    }

    def __init__(
        self,
        *,
        coordinates: List[List[List[float]]],
        **kwargs
    ):
        super(GeoJsonPolygon, self).__init__(coordinates=coordinates, **kwargs)
        self.coordinates = coordinates
        self.type = 'Polygon'  # type: str
        self.type = 'Polygon'  # type: str


class GreatCircleDistanceResponse(msrest.serialization.Model):
    """This object is returned from a successful Great Circle Distance call.

    Variables are only populated by the server, and will be ignored when sending a request.

    :ivar summary: Summary object.
    :vartype summary: ~azure.maps.creator.models.GreatCircleDistanceResponseSummary
    :ivar result: Result Object.
    :vartype result: ~azure.maps.creator.models.GreatCircleDistanceResponseResult
    """

    _validation = {
        'summary': {'readonly': True},
        'result': {'readonly': True},
    }

    _attribute_map = {
        'summary': {'key': 'summary', 'type': 'GreatCircleDistanceResponseSummary'},
        'result': {'key': 'result', 'type': 'GreatCircleDistanceResponseResult'},
    }

    def __init__(
        self,
        **kwargs
    ):
        super(GreatCircleDistanceResponse, self).__init__(**kwargs)
        self.summary = None
        self.result = None


class GreatCircleDistanceResponseResult(msrest.serialization.Model):
    """Result Object.

    Variables are only populated by the server, and will be ignored when sending a request.

    :ivar distance_in_meters: The great circle distance in meters from the source point to the
     target point.
    :vartype distance_in_meters: float
    """

    _validation = {
        'distance_in_meters': {'readonly': True},
    }

    _attribute_map = {
        'distance_in_meters': {'key': 'distanceInMeters', 'type': 'float'},
    }

    def __init__(
        self,
        **kwargs
    ):
        super(GreatCircleDistanceResponseResult, self).__init__(**kwargs)
        self.distance_in_meters = None


class GreatCircleDistanceResponseSummary(msrest.serialization.Model):
    """Summary object.

    :param source_point: A location represented as a latitude and longitude.
    :type source_point: ~azure.maps.creator.models.SpatialCoordinate
    :param target_point: A location represented as a latitude and longitude.
    :type target_point: ~azure.maps.creator.models.SpatialCoordinate
    """

    _attribute_map = {
        'source_point': {'key': 'sourcePoint', 'type': 'SpatialCoordinate'},
        'target_point': {'key': 'targetPoint', 'type': 'SpatialCoordinate'},
    }

    def __init__(
        self,
        *,
        source_point: Optional["SpatialCoordinate"] = None,
        target_point: Optional["SpatialCoordinate"] = None,
        **kwargs
    ):
        super(GreatCircleDistanceResponseSummary, self).__init__(**kwargs)
        self.source_point = source_point
        self.target_point = target_point


class LandingPageResponse(msrest.serialization.Model):
    """LandingPageResponse.

    Variables are only populated by the server, and will be ignored when sending a request.

    All required parameters must be populated in order to send to Azure.

    :ivar ontology: The ontology version of this dataset.
    :vartype ontology: str
    :param links: Required. Links to other WFS endpoints.
    :type links: list[~azure.maps.creator.models.WfsEndpointLink]
    """

    _validation = {
        'ontology': {'readonly': True},
        'links': {'required': True},
    }

    _attribute_map = {
        'ontology': {'key': 'ontology', 'type': 'str'},
        'links': {'key': 'links', 'type': '[WfsEndpointLink]'},
    }

    def __init__(
        self,
        *,
        links: List["WfsEndpointLink"],
        **kwargs
    ):
        super(LandingPageResponse, self).__init__(**kwargs)
        self.ontology = None
        self.links = links


class LongRunningOperationResult(msrest.serialization.Model):
    """The response model for a Long-Running Operations API.

    Variables are only populated by the server, and will be ignored when sending a request.

    :param operation_id: The Id for this long-running operation.
    :type operation_id: str
    :ivar status: The status state of the request. Possible values include: "NotStarted",
     "Running", "Failed", "Succeeded".
    :vartype status: str or ~azure.maps.creator.models.LroStatus
    :ivar created: The created timestamp.
    :vartype created: str
    :param error: The error detail.
    :type error: ~azure.maps.creator.models.ErrorDetail
    :param warning: The error detail.
    :type warning: ~azure.maps.creator.models.ErrorDetail
    """

    _validation = {
        'status': {'readonly': True},
        'created': {'readonly': True},
    }

    _attribute_map = {
        'operation_id': {'key': 'operationId', 'type': 'str'},
        'status': {'key': 'status', 'type': 'str'},
        'created': {'key': 'created', 'type': 'str'},
        'error': {'key': 'error', 'type': 'ErrorDetail'},
        'warning': {'key': 'warning', 'type': 'ErrorDetail'},
    }

    def __init__(
        self,
        *,
        operation_id: Optional[str] = None,
        error: Optional["ErrorDetail"] = None,
        warning: Optional["ErrorDetail"] = None,
        **kwargs
    ):
        super(LongRunningOperationResult, self).__init__(**kwargs)
        self.operation_id = operation_id
        self.status = None
        self.created = None
        self.error = error
        self.warning = warning


class MapDataDetailInfo(msrest.serialization.Model):
    """Detail information for the data.

    Variables are only populated by the server, and will be ignored when sending a request.

    :ivar udid: The unique data id for the data.
    :vartype udid: str
    :ivar location: The location of the data. Execute a HTTP ``GET`` on this location to download
     the data.
    :vartype location: str
    :ivar size_in_bytes: The size of the content in bytes.
    :vartype size_in_bytes: long
    :ivar upload_status: The current upload status of the content.
    :vartype upload_status: str
    :ivar data_format: The current data format.
    :vartype data_format: str
    :ivar description: The current description.
    :vartype description: str
    """

    _validation = {
        'udid': {'readonly': True},
        'location': {'readonly': True},
        'size_in_bytes': {'readonly': True},
        'upload_status': {'readonly': True},
        'data_format': {'readonly': True},
        'description': {'readonly': True},
    }

    _attribute_map = {
        'udid': {'key': 'udid', 'type': 'str'},
        'location': {'key': 'location', 'type': 'str'},
        'size_in_bytes': {'key': 'sizeInBytes', 'type': 'long'},
        'upload_status': {'key': 'uploadStatus', 'type': 'str'},
        'data_format': {'key': 'dataFormat', 'type': 'str'},
        'description': {'key': 'description', 'type': 'str'},
    }

    def __init__(
        self,
        **kwargs
    ):
        super(MapDataDetailInfo, self).__init__(**kwargs)
        self.udid = None
        self.location = None
        self.size_in_bytes = None
        self.upload_status = None
        self.data_format = None
        self.description = None


class MapDataListResponse(msrest.serialization.Model):
    """The response model for the Data List API. Returns a list of all the previously uploaded data.

    Variables are only populated by the server, and will be ignored when sending a request.

    :ivar map_data_list: A list of all the previously uploaded data.
    :vartype map_data_list: list[~azure.maps.creator.models.MapDataDetailInfo]
    """

    _validation = {
        'map_data_list': {'readonly': True},
    }

    _attribute_map = {
        'map_data_list': {'key': 'mapDataList', 'type': '[MapDataDetailInfo]'},
    }

    def __init__(
        self,
        **kwargs
    ):
        super(MapDataListResponse, self).__init__(**kwargs)
        self.map_data_list = None


class NumberRuleObject(msrest.serialization.Model):
    """The numeric rule. The color is selected from the first range it falls into.

    :param range: The numeric value range for this style rule. If the value is in the range, all
     the conditions must hold true.
    :type range: ~azure.maps.creator.models.RangeObject
    :param color: The color when value is within the range. Color is a JSON string in a variety of
     permitted formats, HTML-style hex values, RGB ("#ff0", "#ffff00", "rgb(255, 255, 0)"), RGBA
     ("rgba(255, 255, 0, 1)"), HSL("hsl(100, 50%, 50%)"), and HSLA("hsla(100, 50%, 50%, 1)").
     Predefined HTML colors names, like yellow and blue, are also permitted.
    :type color: str
    """

    _attribute_map = {
        'range': {'key': 'range', 'type': 'RangeObject'},
        'color': {'key': 'color', 'type': 'str'},
    }

    def __init__(
        self,
        *,
        range: Optional["RangeObject"] = None,
        color: Optional[str] = None,
        **kwargs
    ):
        super(NumberRuleObject, self).__init__(**kwargs)
        self.range = range
        self.color = color


class NumberTypeStyleRule(StyleObject):
    """The numeric type style rule object.

    All required parameters must be populated in order to send to Azure.

    :param key_name: Required. Stateset style key name. Key names are random strings but they
     should be unique inside style array.
    :type key_name: str
    :param type: Required. The type of stateset style.Constant filled by server.  Possible values
     include: "boolean", "number", "string".
    :type type: str or ~azure.maps.creator.models.StyleObjectType
    :param rules: Required. Numeric style rules.
    :type rules: list[~azure.maps.creator.models.NumberRuleObject]
    """

    _validation = {
        'key_name': {'required': True},
        'type': {'required': True},
        'rules': {'required': True},
    }

    _attribute_map = {
        'key_name': {'key': 'keyName', 'type': 'str'},
        'type': {'key': 'type', 'type': 'str'},
        'rules': {'key': 'rules', 'type': '[NumberRuleObject]'},
    }

    def __init__(
        self,
        *,
        key_name: str,
        rules: List["NumberRuleObject"],
        **kwargs
    ):
        super(NumberTypeStyleRule, self).__init__(key_name=key_name, **kwargs)
        self.type = 'number'  # type: str
        self.rules = rules


class PointInPolygonResponse(msrest.serialization.Model):
    """Returns true if point is within the polygon, false otherwise.

    Variables are only populated by the server, and will be ignored when sending a request.

    :ivar summary: Point In Polygon Summary object.
    :vartype summary: ~azure.maps.creator.models.PointInPolygonSummary
    :param result: Point In Polygon Result Object.
    :type result: ~azure.maps.creator.models.PointInPolygonResult
    """

    _validation = {
        'summary': {'readonly': True},
    }

    _attribute_map = {
        'summary': {'key': 'summary', 'type': 'PointInPolygonSummary'},
        'result': {'key': 'result', 'type': 'PointInPolygonResult'},
    }

    def __init__(
        self,
        *,
        result: Optional["PointInPolygonResult"] = None,
        **kwargs
    ):
        super(PointInPolygonResponse, self).__init__(**kwargs)
        self.summary = None
        self.result = result


class PointInPolygonResult(msrest.serialization.Model):
    """Point In Polygon Result Object.

    Variables are only populated by the server, and will be ignored when sending a request.

    :ivar point_in_polygons: Point In Polygons Property.
    :vartype point_in_polygons: bool
    :ivar intersecting_geometries: Geometries array.
    :vartype intersecting_geometries: list[str]
    """

    _validation = {
        'point_in_polygons': {'readonly': True},
        'intersecting_geometries': {'readonly': True},
    }

    _attribute_map = {
        'point_in_polygons': {'key': 'pointInPolygons', 'type': 'bool'},
        'intersecting_geometries': {'key': 'intersectingGeometries', 'type': '[str]'},
    }

    def __init__(
        self,
        **kwargs
    ):
        super(PointInPolygonResult, self).__init__(**kwargs)
        self.point_in_polygons = None
        self.intersecting_geometries = None


class PointInPolygonSummary(msrest.serialization.Model):
    """Point In Polygon Summary object.

    Variables are only populated by the server, and will be ignored when sending a request.

    :param source_point: A location represented as a latitude and longitude.
    :type source_point: ~azure.maps.creator.models.SpatialCoordinate
    :ivar udid: A unique data id (udid) for the uploaded content. Udid is not applicable for POST
     spatial operations(set to null).
    :vartype udid: str
    :ivar information: Processing information.
    :vartype information: str
    """

    _validation = {
        'udid': {'readonly': True},
        'information': {'readonly': True},
    }

    _attribute_map = {
        'source_point': {'key': 'sourcePoint', 'type': 'SpatialCoordinate'},
        'udid': {'key': 'udid', 'type': 'str'},
        'information': {'key': 'information', 'type': 'str'},
    }

    def __init__(
        self,
        *,
        source_point: Optional["SpatialCoordinate"] = None,
        **kwargs
    ):
        super(PointInPolygonSummary, self).__init__(**kwargs)
        self.source_point = source_point
        self.udid = None
        self.information = None


class RangeObject(msrest.serialization.Model):
    """The numeric value range for this style rule. If the value is in the range, all the conditions must hold true.

    :param minimum: All the number x that x ≥ minimum.
    :type minimum: float
    :param maximum: All the number x that x ≤ maximum.
    :type maximum: float
    :param exclusive_minimum: All the number x that x > exclusiveMinimum.
    :type exclusive_minimum: float
    :param exclusive_maximum: All the number x that x < exclusiveMaximum.
    :type exclusive_maximum: float
    """

    _attribute_map = {
        'minimum': {'key': 'minimum', 'type': 'float'},
        'maximum': {'key': 'maximum', 'type': 'float'},
        'exclusive_minimum': {'key': 'exclusiveMinimum', 'type': 'float'},
        'exclusive_maximum': {'key': 'exclusiveMaximum', 'type': 'float'},
    }

    def __init__(
        self,
        *,
        minimum: Optional[float] = None,
        maximum: Optional[float] = None,
        exclusive_minimum: Optional[float] = None,
        exclusive_maximum: Optional[float] = None,
        **kwargs
    ):
        super(RangeObject, self).__init__(**kwargs)
        self.minimum = minimum
        self.maximum = maximum
        self.exclusive_minimum = exclusive_minimum
        self.exclusive_maximum = exclusive_maximum


class SpatialCoordinate(msrest.serialization.Model):
    """A location represented as a latitude and longitude.

    Variables are only populated by the server, and will be ignored when sending a request.

    :ivar lat: Latitude property.
    :vartype lat: float
    :ivar lon: Longitude property.
    :vartype lon: float
    """

    _validation = {
        'lat': {'readonly': True},
        'lon': {'readonly': True},
    }

    _attribute_map = {
        'lat': {'key': 'lat', 'type': 'float'},
        'lon': {'key': 'lon', 'type': 'float'},
    }

    def __init__(
        self,
        **kwargs
    ):
        super(SpatialCoordinate, self).__init__(**kwargs)
        self.lat = None
        self.lon = None


class StatesetCreatedResponse(msrest.serialization.Model):
    """The response model for the successful Stateset Create API.

    Variables are only populated by the server, and will be ignored when sending a request.

    :ivar stateset_id: The ID for the new stateset created.
    :vartype stateset_id: str
    """

    _validation = {
        'stateset_id': {'readonly': True},
    }

    _attribute_map = {
        'stateset_id': {'key': 'statesetId', 'type': 'str'},
    }

    def __init__(
        self,
        **kwargs
    ):
        super(StatesetCreatedResponse, self).__init__(**kwargs)
        self.stateset_id = None


class StatesetGetResponse(msrest.serialization.Model):
    """The response model for the successful Stateset Get API.

    Variables are only populated by the server, and will be ignored when sending a request.

    :ivar description: Description associated with the stateset.
    :vartype description: str
    :param dataset_ids: Dataset ID associated with the stateset.
    :type dataset_ids: list[str]
    :param stateset_style: The styles model.
    :type stateset_style: ~azure.maps.creator.models.StylesObject
    """

    _validation = {
        'description': {'readonly': True},
    }

    _attribute_map = {
        'description': {'key': 'description', 'type': 'str'},
        'dataset_ids': {'key': 'datasetIds', 'type': '[str]'},
        'stateset_style': {'key': 'statesetStyle', 'type': 'StylesObject'},
    }

    def __init__(
        self,
        *,
        dataset_ids: Optional[List[str]] = None,
        stateset_style: Optional["StylesObject"] = None,
        **kwargs
    ):
        super(StatesetGetResponse, self).__init__(**kwargs)
        self.description = None
        self.dataset_ids = dataset_ids
        self.stateset_style = stateset_style


class StatesetInfoObject(msrest.serialization.Model):
    """The stateset information detail.

    Variables are only populated by the server, and will be ignored when sending a request.

    :param stateset_id: The stateset ID of this stateset.
    :type stateset_id: str
    :ivar description: Description associated with the stateset.
    :vartype description: str
    :param dataset_ids: Dataset ID associated with the stateset.
    :type dataset_ids: list[str]
    :param stateset_style: The styles model.
    :type stateset_style: ~azure.maps.creator.models.StylesObject
    """

    _validation = {
        'description': {'readonly': True},
    }

    _attribute_map = {
        'stateset_id': {'key': 'statesetId', 'type': 'str'},
        'description': {'key': 'description', 'type': 'str'},
        'dataset_ids': {'key': 'datasetIds', 'type': '[str]'},
        'stateset_style': {'key': 'statesetStyle', 'type': 'StylesObject'},
    }

    def __init__(
        self,
        *,
        stateset_id: Optional[str] = None,
        dataset_ids: Optional[List[str]] = None,
        stateset_style: Optional["StylesObject"] = None,
        **kwargs
    ):
        super(StatesetInfoObject, self).__init__(**kwargs)
        self.stateset_id = stateset_id
        self.description = None
        self.dataset_ids = dataset_ids
        self.stateset_style = stateset_style


class StatesetListResponse(msrest.serialization.Model):
    """The response model for the successful Stateset List API.

    Variables are only populated by the server, and will be ignored when sending a request.

    :param statesets: A list of statesets information.
    :type statesets: list[~azure.maps.creator.models.StatesetInfoObject]
    :ivar next_link: If present, the location of the next page of data.
    :vartype next_link: str
    """

    _validation = {
        'next_link': {'readonly': True},
    }

    _attribute_map = {
        'statesets': {'key': 'statesets', 'type': '[StatesetInfoObject]'},
        'next_link': {'key': 'nextLink', 'type': 'str'},
    }

    def __init__(
        self,
        *,
        statesets: Optional[List["StatesetInfoObject"]] = None,
        **kwargs
    ):
        super(StatesetListResponse, self).__init__(**kwargs)
        self.statesets = statesets
        self.next_link = None


class StringTypeStyleRule(StyleObject):
    """The string type style rule object.

    All required parameters must be populated in order to send to Azure.

    :param key_name: Required. Stateset style key name. Key names are random strings but they
     should be unique inside style array.
    :type key_name: str
    :param type: Required. The type of stateset style.Constant filled by server.  Possible values
     include: "boolean", "number", "string".
    :type type: str or ~azure.maps.creator.models.StyleObjectType
    :param rules: Required. String style rules.
    :type rules: list[dict[str, str]]
    """

    _validation = {
        'key_name': {'required': True},
        'type': {'required': True},
        'rules': {'required': True},
    }

    _attribute_map = {
        'key_name': {'key': 'keyName', 'type': 'str'},
        'type': {'key': 'type', 'type': 'str'},
        'rules': {'key': 'rules', 'type': '[{str}]'},
    }

    def __init__(
        self,
        *,
        key_name: str,
        rules: List[Dict[str, str]],
        **kwargs
    ):
        super(StringTypeStyleRule, self).__init__(key_name=key_name, **kwargs)
        self.type = 'string'  # type: str
        self.rules = rules


class StylesObject(msrest.serialization.Model):
    """The styles model.

    :param styles: An array of stateset styles. The style rule could be a numeric or string or a
     boolean type style rule.  Refer to NumberRuleObject, StringRuleObject and BooleanRuleObject
     definitions `here <https://aka.ms/AzureMapsStatesetStylesObject>`_.
    :type styles: list[~azure.maps.creator.models.StyleObject]
    """

    _attribute_map = {
        'styles': {'key': 'styles', 'type': '[StyleObject]'},
    }

    def __init__(
        self,
        *,
        styles: Optional[List["StyleObject"]] = None,
        **kwargs
    ):
        super(StylesObject, self).__init__(**kwargs)
        self.styles = styles


class TilesetDetailInfo(msrest.serialization.Model):
    """Detail information for the data.

    Variables are only populated by the server, and will be ignored when sending a request.

    :ivar tileset_id: The unique tileset id for the tileset.
    :vartype tileset_id: str
    :ivar ontology: The ontology version of this dataset.
    :vartype ontology: str
    :ivar dataset_id: The unique dataset Id used to create the tileset.
    :vartype dataset_id: str
    :ivar description: The description the caller provided when creating the tileset. Maximum
     length 1024 characters.
    :vartype description: str
    :ivar min_zoom: The lowest tile zoom level tile generated for the tileset.
    :vartype min_zoom: int
    :ivar max_zoom: The highest tile zoom level tile generated for the tileset.
    :vartype max_zoom: int
    :ivar bbox: Bounding box which all features of the tileset lay within. Projection used -
     EPSG:3857. Format : 'minLon, minLat, maxLon, maxLat'.
    :vartype bbox: list[float]
    """

    _validation = {
        'tileset_id': {'readonly': True},
        'ontology': {'readonly': True},
        'dataset_id': {'readonly': True},
        'description': {'readonly': True},
        'min_zoom': {'readonly': True},
        'max_zoom': {'readonly': True},
        'bbox': {'readonly': True},
    }

    _attribute_map = {
        'tileset_id': {'key': 'tilesetId', 'type': 'str'},
        'ontology': {'key': 'ontology', 'type': 'str'},
        'dataset_id': {'key': 'datasetId', 'type': 'str'},
        'description': {'key': 'description', 'type': 'str'},
        'min_zoom': {'key': 'minZoom', 'type': 'int'},
        'max_zoom': {'key': 'maxZoom', 'type': 'int'},
        'bbox': {'key': 'bbox', 'type': '[float]'},
    }

    def __init__(
        self,
        **kwargs
    ):
        super(TilesetDetailInfo, self).__init__(**kwargs)
        self.tileset_id = None
        self.ontology = None
        self.dataset_id = None
        self.description = None
        self.min_zoom = None
        self.max_zoom = None
        self.bbox = None


class TilesetListResponse(msrest.serialization.Model):
    """The response model for the Tileset List API. Returns a list of all tilesets.

    Variables are only populated by the server, and will be ignored when sending a request.

    :ivar tilesets: A list of all tilesets.
    :vartype tilesets: list[~azure.maps.creator.models.TilesetDetailInfo]
    :ivar next_link: If present, the location of the next page of data.
    :vartype next_link: str
    """

    _validation = {
        'tilesets': {'readonly': True},
        'next_link': {'readonly': True},
    }

    _attribute_map = {
        'tilesets': {'key': 'tilesets', 'type': '[TilesetDetailInfo]'},
        'next_link': {'key': 'nextLink', 'type': 'str'},
    }

    def __init__(
        self,
        **kwargs
    ):
        super(TilesetListResponse, self).__init__(**kwargs)
        self.tilesets = None
        self.next_link = None


class WfsEndpointLink(msrest.serialization.Model):
    """Links to other WFS endpoints.

    All required parameters must be populated in order to send to Azure.

    :param href: Required. The link target.
    :type href: str
    :param rel: The relation type.
    :type rel: str
    :param type: A hint indicating what the media type of the result of dereferencing the link
     should be.
    :type type: str
    :param hreflang: A hint indicating what the language of the result of dereferencing the link
     should be.
    :type hreflang: str
    :param title: Used to label the destination of a link such that it can be used as a
     human-readable identifier (e.g., a menu entry) in the language indicated by the
     Content-Language header field (if present).
    :type title: str
    """

    _validation = {
        'href': {'required': True},
    }

    _attribute_map = {
        'href': {'key': 'href', 'type': 'str'},
        'rel': {'key': 'rel', 'type': 'str'},
        'type': {'key': 'type', 'type': 'str'},
        'hreflang': {'key': 'hreflang', 'type': 'str'},
        'title': {'key': 'title', 'type': 'str'},
    }

    def __init__(
        self,
        *,
        href: str,
        rel: Optional[str] = None,
        type: Optional[str] = None,
        hreflang: Optional[str] = None,
        title: Optional[str] = None,
        **kwargs
    ):
        super(WfsEndpointLink, self).__init__(**kwargs)
        self.href = href
        self.rel = rel
        self.type = type
        self.hreflang = hreflang
        self.title = title
