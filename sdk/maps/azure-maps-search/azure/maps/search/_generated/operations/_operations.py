# pylint: disable=too-many-lines,too-many-statements
# coding=utf-8
# --------------------------------------------------------------------------
# Copyright (c) Microsoft Corporation. All rights reserved.
# Licensed under the MIT License. See License.txt in the project root for license information.
# Code generated by Microsoft (R) AutoRest Code Generator.
# Changes may cause incorrect behavior and will be lost if the code is regenerated.
# --------------------------------------------------------------------------
from io import IOBase
from typing import Any, Callable, Dict, IO, List, Optional, TypeVar, Union, cast, overload

from azure.core.exceptions import (
    ClientAuthenticationError,
    HttpResponseError,
    ResourceExistsError,
    ResourceNotFoundError,
    ResourceNotModifiedError,
    map_error,
)
from azure.core.pipeline import PipelineResponse
from azure.core.polling import LROPoller, NoPolling, PollingMethod
from azure.core.polling.base_polling import LROBasePolling
from azure.core.rest import HttpRequest, HttpResponse
from azure.core.tracing.decorator import distributed_trace
from azure.core.utils import case_insensitive_dict

from .. import models as _models
from .._serialization import Serializer

T = TypeVar("T")
ClsType = Optional[Callable[[PipelineResponse[HttpRequest, HttpResponse], T, Dict[str, Any]], Any]]

_SERIALIZER = Serializer()
_SERIALIZER.client_side_validation = False


def build_search_list_polygons_request(
    format: Union[str, _models.JsonFormat] = "json",
    *,
    geometry_ids: List[str],
    client_id: Optional[str] = None,
    **kwargs: Any
) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "1.0"))
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/search/polygon/{format}"
    path_format_arguments = {
        "format": _SERIALIZER.url("format", format, "str"),
    }

    _url: str = _url.format(**path_format_arguments)  # type: ignore

    # Construct parameters
    _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")
    _params["geometries"] = _SERIALIZER.query("geometry_ids", geometry_ids, "[str]", div=",")

    # Construct headers
    if client_id is not None:
        _headers["x-ms-client-id"] = _SERIALIZER.header("client_id", client_id, "str")
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="GET", url=_url, params=_params, headers=_headers, **kwargs)


def build_search_fuzzy_search_request(
    format: Union[str, _models.ResponseFormat] = "json",
    *,
    query: str,
    is_type_ahead: Optional[bool] = None,
    top: Optional[int] = None,
    skip: Optional[int] = None,
    category_filter: Optional[List[int]] = None,
    country_filter: Optional[List[str]] = None,
    lat: Optional[float] = None,
    lon: Optional[float] = None,
    radius_in_meters: Optional[int] = None,
    top_left: Optional[str] = None,
    btm_right: Optional[str] = None,
    language: Optional[str] = None,
    extended_postal_codes_for: Optional[List[Union[str, _models.SearchIndexes]]] = None,
    min_fuzzy_level: Optional[int] = None,
    max_fuzzy_level: Optional[int] = None,
    index_filter: Optional[List[Union[str, _models.SearchIndexes]]] = None,
    brand_filter: Optional[List[str]] = None,
    electric_vehicle_connector_filter: Optional[List[Union[str, _models.ElectricVehicleConnector]]] = None,
    entity_type: Optional[Union[str, _models.GeographicEntityType]] = None,
    localized_map_view: Optional[Union[str, _models.LocalizedMapView]] = None,
    operating_hours: Optional[Union[str, _models.OperatingHoursRange]] = None,
    client_id: Optional[str] = None,
    **kwargs: Any
) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "1.0"))
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/search/fuzzy/{format}"
    path_format_arguments = {
        "format": _SERIALIZER.url("format", format, "str"),
    }

    _url: str = _url.format(**path_format_arguments)  # type: ignore

    # Construct parameters
    _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")
    _params["query"] = _SERIALIZER.query("query", query, "str")
    if is_type_ahead is not None:
        _params["typeahead"] = _SERIALIZER.query("is_type_ahead", is_type_ahead, "bool")
    if top is not None:
        _params["limit"] = _SERIALIZER.query("top", top, "int", maximum=100, minimum=1)
    if skip is not None:
        _params["ofs"] = _SERIALIZER.query("skip", skip, "int", maximum=1900, minimum=0)
    if category_filter is not None:
        _params["categorySet"] = _SERIALIZER.query("category_filter", category_filter, "[int]", div=",")
    if country_filter is not None:
        _params["countrySet"] = _SERIALIZER.query("country_filter", country_filter, "[str]", div=",")
    if lat is not None:
        _params["lat"] = _SERIALIZER.query("lat", lat, "float")
    if lon is not None:
        _params["lon"] = _SERIALIZER.query("lon", lon, "float")
    if radius_in_meters is not None:
        _params["radius"] = _SERIALIZER.query("radius_in_meters", radius_in_meters, "int")
    if top_left is not None:
        _params["topLeft"] = _SERIALIZER.query("top_left", top_left, "str")
    if btm_right is not None:
        _params["btmRight"] = _SERIALIZER.query("btm_right", btm_right, "str")
    if language is not None:
        _params["language"] = _SERIALIZER.query("language", language, "str")
    if extended_postal_codes_for is not None:
        _params["extendedPostalCodesFor"] = _SERIALIZER.query(
            "extended_postal_codes_for", extended_postal_codes_for, "[str]", div=","
        )
    if min_fuzzy_level is not None:
        _params["minFuzzyLevel"] = _SERIALIZER.query("min_fuzzy_level", min_fuzzy_level, "int", maximum=4, minimum=1)
    if max_fuzzy_level is not None:
        _params["maxFuzzyLevel"] = _SERIALIZER.query("max_fuzzy_level", max_fuzzy_level, "int", maximum=4, minimum=1)
    if index_filter is not None:
        _params["idxSet"] = _SERIALIZER.query("index_filter", index_filter, "[str]", div=",")
    if brand_filter is not None:
        _params["brandSet"] = _SERIALIZER.query("brand_filter", brand_filter, "[str]", div=",")
    if electric_vehicle_connector_filter is not None:
        _params["connectorSet"] = _SERIALIZER.query(
            "electric_vehicle_connector_filter", electric_vehicle_connector_filter, "[str]", div=","
        )
    if entity_type is not None:
        _params["entityType"] = _SERIALIZER.query("entity_type", entity_type, "str")
    if localized_map_view is not None:
        _params["view"] = _SERIALIZER.query("localized_map_view", localized_map_view, "str")
    if operating_hours is not None:
        _params["openingHours"] = _SERIALIZER.query("operating_hours", operating_hours, "str")

    # Construct headers
    if client_id is not None:
        _headers["x-ms-client-id"] = _SERIALIZER.header("client_id", client_id, "str")
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="GET", url=_url, params=_params, headers=_headers, **kwargs)


def build_search_search_point_of_interest_request(  # pylint: disable=name-too-long
    format: Union[str, _models.ResponseFormat] = "json",
    *,
    query: str,
    is_type_ahead: Optional[bool] = None,
    top: Optional[int] = None,
    skip: Optional[int] = None,
    category_filter: Optional[List[int]] = None,
    country_filter: Optional[List[str]] = None,
    lat: Optional[float] = None,
    lon: Optional[float] = None,
    radius_in_meters: Optional[int] = None,
    top_left: Optional[str] = None,
    btm_right: Optional[str] = None,
    language: Optional[str] = None,
    extended_postal_codes_for: Optional[List[Union[str, _models.PointOfInterestExtendedPostalCodes]]] = None,
    brand_filter: Optional[List[str]] = None,
    electric_vehicle_connector_filter: Optional[List[Union[str, _models.ElectricVehicleConnector]]] = None,
    localized_map_view: Optional[Union[str, _models.LocalizedMapView]] = None,
    operating_hours: Optional[Union[str, _models.OperatingHoursRange]] = None,
    client_id: Optional[str] = None,
    **kwargs: Any
) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "1.0"))
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/search/poi/{format}"
    path_format_arguments = {
        "format": _SERIALIZER.url("format", format, "str"),
    }

    _url: str = _url.format(**path_format_arguments)  # type: ignore

    # Construct parameters
    _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")
    _params["query"] = _SERIALIZER.query("query", query, "str")
    if is_type_ahead is not None:
        _params["typeahead"] = _SERIALIZER.query("is_type_ahead", is_type_ahead, "bool")
    if top is not None:
        _params["limit"] = _SERIALIZER.query("top", top, "int", maximum=100, minimum=1)
    if skip is not None:
        _params["ofs"] = _SERIALIZER.query("skip", skip, "int", maximum=1900, minimum=0)
    if category_filter is not None:
        _params["categorySet"] = _SERIALIZER.query("category_filter", category_filter, "[int]", div=",")
    if country_filter is not None:
        _params["countrySet"] = _SERIALIZER.query("country_filter", country_filter, "[str]", div=",")
    if lat is not None:
        _params["lat"] = _SERIALIZER.query("lat", lat, "float")
    if lon is not None:
        _params["lon"] = _SERIALIZER.query("lon", lon, "float")
    if radius_in_meters is not None:
        _params["radius"] = _SERIALIZER.query("radius_in_meters", radius_in_meters, "int")
    if top_left is not None:
        _params["topLeft"] = _SERIALIZER.query("top_left", top_left, "str")
    if btm_right is not None:
        _params["btmRight"] = _SERIALIZER.query("btm_right", btm_right, "str")
    if language is not None:
        _params["language"] = _SERIALIZER.query("language", language, "str")
    if extended_postal_codes_for is not None:
        _params["extendedPostalCodesFor"] = _SERIALIZER.query(
            "extended_postal_codes_for", extended_postal_codes_for, "[str]", div=","
        )
    if brand_filter is not None:
        _params["brandSet"] = _SERIALIZER.query("brand_filter", brand_filter, "[str]", div=",")
    if electric_vehicle_connector_filter is not None:
        _params["connectorSet"] = _SERIALIZER.query(
            "electric_vehicle_connector_filter", electric_vehicle_connector_filter, "[str]", div=","
        )
    if localized_map_view is not None:
        _params["view"] = _SERIALIZER.query("localized_map_view", localized_map_view, "str")
    if operating_hours is not None:
        _params["openingHours"] = _SERIALIZER.query("operating_hours", operating_hours, "str")

    # Construct headers
    if client_id is not None:
        _headers["x-ms-client-id"] = _SERIALIZER.header("client_id", client_id, "str")
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="GET", url=_url, params=_params, headers=_headers, **kwargs)


def build_search_search_nearby_point_of_interest_request(  # pylint: disable=name-too-long
    format: Union[str, _models.ResponseFormat] = "json",
    *,
    lat: float,
    lon: float,
    top: Optional[int] = None,
    skip: Optional[int] = None,
    category_filter: Optional[List[int]] = None,
    country_filter: Optional[List[str]] = None,
    radius_in_meters: Optional[int] = None,
    language: Optional[str] = None,
    extended_postal_codes_for: Optional[List[Union[str, _models.SearchIndexes]]] = None,
    brand_filter: Optional[List[str]] = None,
    electric_vehicle_connector_filter: Optional[List[Union[str, _models.ElectricVehicleConnector]]] = None,
    localized_map_view: Optional[Union[str, _models.LocalizedMapView]] = None,
    client_id: Optional[str] = None,
    **kwargs: Any
) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "1.0"))
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/search/nearby/{format}"
    path_format_arguments = {
        "format": _SERIALIZER.url("format", format, "str"),
    }

    _url: str = _url.format(**path_format_arguments)  # type: ignore

    # Construct parameters
    _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")
    _params["lat"] = _SERIALIZER.query("lat", lat, "float")
    _params["lon"] = _SERIALIZER.query("lon", lon, "float")
    if top is not None:
        _params["limit"] = _SERIALIZER.query("top", top, "int", maximum=100, minimum=1)
    if skip is not None:
        _params["ofs"] = _SERIALIZER.query("skip", skip, "int", maximum=1900, minimum=0)
    if category_filter is not None:
        _params["categorySet"] = _SERIALIZER.query("category_filter", category_filter, "[int]", div=",")
    if country_filter is not None:
        _params["countrySet"] = _SERIALIZER.query("country_filter", country_filter, "[str]", div=",")
    if radius_in_meters is not None:
        _params["radius"] = _SERIALIZER.query("radius_in_meters", radius_in_meters, "int")
    if language is not None:
        _params["language"] = _SERIALIZER.query("language", language, "str")
    if extended_postal_codes_for is not None:
        _params["extendedPostalCodesFor"] = _SERIALIZER.query(
            "extended_postal_codes_for", extended_postal_codes_for, "[str]", div=","
        )
    if brand_filter is not None:
        _params["brandSet"] = _SERIALIZER.query("brand_filter", brand_filter, "[str]", div=",")
    if electric_vehicle_connector_filter is not None:
        _params["connectorSet"] = _SERIALIZER.query(
            "electric_vehicle_connector_filter", electric_vehicle_connector_filter, "[str]", div=","
        )
    if localized_map_view is not None:
        _params["view"] = _SERIALIZER.query("localized_map_view", localized_map_view, "str")

    # Construct headers
    if client_id is not None:
        _headers["x-ms-client-id"] = _SERIALIZER.header("client_id", client_id, "str")
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="GET", url=_url, params=_params, headers=_headers, **kwargs)


def build_search_search_point_of_interest_category_request(  # pylint: disable=name-too-long
    format: Union[str, _models.ResponseFormat] = "json",
    *,
    query: str,
    is_type_ahead: Optional[bool] = None,
    top: Optional[int] = None,
    skip: Optional[int] = None,
    category_filter: Optional[List[int]] = None,
    country_filter: Optional[List[str]] = None,
    lat: Optional[float] = None,
    lon: Optional[float] = None,
    radius_in_meters: Optional[int] = None,
    top_left: Optional[str] = None,
    btm_right: Optional[str] = None,
    language: Optional[str] = None,
    extended_postal_codes_for: Optional[List[Union[str, _models.SearchIndexes]]] = None,
    brand_filter: Optional[List[str]] = None,
    electric_vehicle_connector_filter: Optional[List[Union[str, _models.ElectricVehicleConnector]]] = None,
    localized_map_view: Optional[Union[str, _models.LocalizedMapView]] = None,
    operating_hours: Optional[Union[str, _models.OperatingHoursRange]] = None,
    client_id: Optional[str] = None,
    **kwargs: Any
) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "1.0"))
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/search/poi/category/{format}"
    path_format_arguments = {
        "format": _SERIALIZER.url("format", format, "str"),
    }

    _url: str = _url.format(**path_format_arguments)  # type: ignore

    # Construct parameters
    _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")
    _params["query"] = _SERIALIZER.query("query", query, "str")
    if is_type_ahead is not None:
        _params["typeahead"] = _SERIALIZER.query("is_type_ahead", is_type_ahead, "bool")
    if top is not None:
        _params["limit"] = _SERIALIZER.query("top", top, "int", maximum=100, minimum=1)
    if skip is not None:
        _params["ofs"] = _SERIALIZER.query("skip", skip, "int", maximum=1900, minimum=0)
    if category_filter is not None:
        _params["categorySet"] = _SERIALIZER.query("category_filter", category_filter, "[int]", div=",")
    if country_filter is not None:
        _params["countrySet"] = _SERIALIZER.query("country_filter", country_filter, "[str]", div=",")
    if lat is not None:
        _params["lat"] = _SERIALIZER.query("lat", lat, "float")
    if lon is not None:
        _params["lon"] = _SERIALIZER.query("lon", lon, "float")
    if radius_in_meters is not None:
        _params["radius"] = _SERIALIZER.query("radius_in_meters", radius_in_meters, "int")
    if top_left is not None:
        _params["topLeft"] = _SERIALIZER.query("top_left", top_left, "str")
    if btm_right is not None:
        _params["btmRight"] = _SERIALIZER.query("btm_right", btm_right, "str")
    if language is not None:
        _params["language"] = _SERIALIZER.query("language", language, "str")
    if extended_postal_codes_for is not None:
        _params["extendedPostalCodesFor"] = _SERIALIZER.query(
            "extended_postal_codes_for", extended_postal_codes_for, "[str]", div=","
        )
    if brand_filter is not None:
        _params["brandSet"] = _SERIALIZER.query("brand_filter", brand_filter, "[str]", div=",")
    if electric_vehicle_connector_filter is not None:
        _params["connectorSet"] = _SERIALIZER.query(
            "electric_vehicle_connector_filter", electric_vehicle_connector_filter, "[str]", div=","
        )
    if localized_map_view is not None:
        _params["view"] = _SERIALIZER.query("localized_map_view", localized_map_view, "str")
    if operating_hours is not None:
        _params["openingHours"] = _SERIALIZER.query("operating_hours", operating_hours, "str")

    # Construct headers
    if client_id is not None:
        _headers["x-ms-client-id"] = _SERIALIZER.header("client_id", client_id, "str")
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="GET", url=_url, params=_params, headers=_headers, **kwargs)


def build_search_get_point_of_interest_category_tree_request(  # pylint: disable=name-too-long
    format: Union[str, _models.JsonFormat] = "json",
    *,
    language: Optional[str] = None,
    client_id: Optional[str] = None,
    **kwargs: Any
) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "1.0"))
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/search/poi/category/tree/{format}"
    path_format_arguments = {
        "format": _SERIALIZER.url("format", format, "str"),
    }

    _url: str = _url.format(**path_format_arguments)  # type: ignore

    # Construct parameters
    _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")
    if language is not None:
        _params["language"] = _SERIALIZER.query("language", language, "str")

    # Construct headers
    if client_id is not None:
        _headers["x-ms-client-id"] = _SERIALIZER.header("client_id", client_id, "str")
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="GET", url=_url, params=_params, headers=_headers, **kwargs)


def build_search_search_address_request(
    format: Union[str, _models.ResponseFormat] = "json",
    *,
    query: str,
    is_type_ahead: Optional[bool] = None,
    top: Optional[int] = None,
    skip: Optional[int] = None,
    country_filter: Optional[List[str]] = None,
    lat: Optional[float] = None,
    lon: Optional[float] = None,
    radius_in_meters: Optional[int] = None,
    top_left: Optional[str] = None,
    btm_right: Optional[str] = None,
    language: Optional[str] = None,
    extended_postal_codes_for: Optional[List[Union[str, _models.SearchIndexes]]] = None,
    entity_type: Optional[Union[str, _models.GeographicEntityType]] = None,
    localized_map_view: Optional[Union[str, _models.LocalizedMapView]] = None,
    client_id: Optional[str] = None,
    **kwargs: Any
) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "1.0"))
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/search/address/{format}"
    path_format_arguments = {
        "format": _SERIALIZER.url("format", format, "str"),
    }

    _url: str = _url.format(**path_format_arguments)  # type: ignore

    # Construct parameters
    _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")
    _params["query"] = _SERIALIZER.query("query", query, "str")
    if is_type_ahead is not None:
        _params["typeahead"] = _SERIALIZER.query("is_type_ahead", is_type_ahead, "bool")
    if top is not None:
        _params["limit"] = _SERIALIZER.query("top", top, "int", maximum=100, minimum=1)
    if skip is not None:
        _params["ofs"] = _SERIALIZER.query("skip", skip, "int", maximum=1900, minimum=0)
    if country_filter is not None:
        _params["countrySet"] = _SERIALIZER.query("country_filter", country_filter, "[str]", div=",")
    if lat is not None:
        _params["lat"] = _SERIALIZER.query("lat", lat, "float")
    if lon is not None:
        _params["lon"] = _SERIALIZER.query("lon", lon, "float")
    if radius_in_meters is not None:
        _params["radius"] = _SERIALIZER.query("radius_in_meters", radius_in_meters, "int")
    if top_left is not None:
        _params["topLeft"] = _SERIALIZER.query("top_left", top_left, "str")
    if btm_right is not None:
        _params["btmRight"] = _SERIALIZER.query("btm_right", btm_right, "str")
    if language is not None:
        _params["language"] = _SERIALIZER.query("language", language, "str")
    if extended_postal_codes_for is not None:
        _params["extendedPostalCodesFor"] = _SERIALIZER.query(
            "extended_postal_codes_for", extended_postal_codes_for, "[str]", div=","
        )
    if entity_type is not None:
        _params["entityType"] = _SERIALIZER.query("entity_type", entity_type, "str")
    if localized_map_view is not None:
        _params["view"] = _SERIALIZER.query("localized_map_view", localized_map_view, "str")

    # Construct headers
    if client_id is not None:
        _headers["x-ms-client-id"] = _SERIALIZER.header("client_id", client_id, "str")
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="GET", url=_url, params=_params, headers=_headers, **kwargs)


def build_search_reverse_search_address_request(  # pylint: disable=name-too-long
    format: Union[str, _models.ResponseFormat] = "json",
    *,
    query: List[float],
    language: Optional[str] = None,
    include_speed_limit: Optional[bool] = None,
    heading: Optional[int] = None,
    radius_in_meters: Optional[int] = None,
    street_number: Optional[str] = None,
    include_road_use: Optional[bool] = None,
    road_use: Optional[List[Union[str, _models.RoadUseType]]] = None,
    allow_freeform_newline: Optional[bool] = None,
    include_match_type: Optional[bool] = None,
    entity_type: Optional[Union[str, _models.GeographicEntityType]] = None,
    localized_map_view: Optional[Union[str, _models.LocalizedMapView]] = None,
    client_id: Optional[str] = None,
    **kwargs: Any
) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "1.0"))
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/search/address/reverse/{format}"
    path_format_arguments = {
        "format": _SERIALIZER.url("format", format, "str"),
    }

    _url: str = _url.format(**path_format_arguments)  # type: ignore

    # Construct parameters
    _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")
    _params["query"] = _SERIALIZER.query("query", query, "[float]", div=",")
    if language is not None:
        _params["language"] = _SERIALIZER.query("language", language, "str")
    if include_speed_limit is not None:
        _params["returnSpeedLimit"] = _SERIALIZER.query("include_speed_limit", include_speed_limit, "bool")
    if heading is not None:
        _params["heading"] = _SERIALIZER.query("heading", heading, "int", maximum=360, minimum=-360)
    if radius_in_meters is not None:
        _params["radius"] = _SERIALIZER.query("radius_in_meters", radius_in_meters, "int")
    if street_number is not None:
        _params["number"] = _SERIALIZER.query("street_number", street_number, "str")
    if include_road_use is not None:
        _params["returnRoadUse"] = _SERIALIZER.query("include_road_use", include_road_use, "bool")
    if road_use is not None:
        _params["roadUse"] = _SERIALIZER.query("road_use", road_use, "[str]", div=",")
    if allow_freeform_newline is not None:
        _params["allowFreeformNewline"] = _SERIALIZER.query("allow_freeform_newline", allow_freeform_newline, "bool")
    if include_match_type is not None:
        _params["returnMatchType"] = _SERIALIZER.query("include_match_type", include_match_type, "bool")
    if entity_type is not None:
        _params["entityType"] = _SERIALIZER.query("entity_type", entity_type, "str")
    if localized_map_view is not None:
        _params["view"] = _SERIALIZER.query("localized_map_view", localized_map_view, "str")

    # Construct headers
    if client_id is not None:
        _headers["x-ms-client-id"] = _SERIALIZER.header("client_id", client_id, "str")
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="GET", url=_url, params=_params, headers=_headers, **kwargs)


def build_search_reverse_search_cross_street_address_request(  # pylint: disable=name-too-long
    format: Union[str, _models.ResponseFormat] = "json",
    *,
    query: List[float],
    top: Optional[int] = None,
    heading: Optional[int] = None,
    radius_in_meters: Optional[int] = None,
    language: Optional[str] = None,
    localized_map_view: Optional[Union[str, _models.LocalizedMapView]] = None,
    client_id: Optional[str] = None,
    **kwargs: Any
) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "1.0"))
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/search/address/reverse/crossStreet/{format}"
    path_format_arguments = {
        "format": _SERIALIZER.url("format", format, "str"),
    }

    _url: str = _url.format(**path_format_arguments)  # type: ignore

    # Construct parameters
    _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")
    _params["query"] = _SERIALIZER.query("query", query, "[float]", div=",")
    if top is not None:
        _params["limit"] = _SERIALIZER.query("top", top, "int", maximum=100, minimum=1)
    if heading is not None:
        _params["heading"] = _SERIALIZER.query("heading", heading, "int", maximum=360, minimum=-360)
    if radius_in_meters is not None:
        _params["radius"] = _SERIALIZER.query("radius_in_meters", radius_in_meters, "int")
    if language is not None:
        _params["language"] = _SERIALIZER.query("language", language, "str")
    if localized_map_view is not None:
        _params["view"] = _SERIALIZER.query("localized_map_view", localized_map_view, "str")

    # Construct headers
    if client_id is not None:
        _headers["x-ms-client-id"] = _SERIALIZER.header("client_id", client_id, "str")
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="GET", url=_url, params=_params, headers=_headers, **kwargs)


def build_search_search_structured_address_request(  # pylint: disable=name-too-long
    format: Union[str, _models.ResponseFormat] = "json",
    *,
    language: Optional[str] = None,
    country_code: str = "US",
    top: Optional[int] = None,
    skip: Optional[int] = None,
    street_number: Optional[str] = None,
    street_name: Optional[str] = None,
    cross_street: Optional[str] = None,
    municipality: Optional[str] = None,
    municipality_subdivision: Optional[str] = None,
    country_tertiary_subdivision: Optional[str] = None,
    country_secondary_subdivision: Optional[str] = None,
    country_subdivision: Optional[str] = None,
    postal_code: Optional[str] = None,
    extended_postal_codes_for: Optional[List[Union[str, _models.SearchIndexes]]] = None,
    entity_type: Optional[Union[str, _models.GeographicEntityType]] = None,
    localized_map_view: Optional[Union[str, _models.LocalizedMapView]] = None,
    client_id: Optional[str] = None,
    **kwargs: Any
) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "1.0"))
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/search/address/structured/{format}"
    path_format_arguments = {
        "format": _SERIALIZER.url("format", format, "str"),
    }

    _url: str = _url.format(**path_format_arguments)  # type: ignore

    # Construct parameters
    _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")
    if language is not None:
        _params["language"] = _SERIALIZER.query("language", language, "str")
    _params["countryCode"] = _SERIALIZER.query("country_code", country_code, "str")
    if top is not None:
        _params["limit"] = _SERIALIZER.query("top", top, "int", maximum=100, minimum=1)
    if skip is not None:
        _params["ofs"] = _SERIALIZER.query("skip", skip, "int", maximum=1900, minimum=0)
    if street_number is not None:
        _params["streetNumber"] = _SERIALIZER.query("street_number", street_number, "str")
    if street_name is not None:
        _params["streetName"] = _SERIALIZER.query("street_name", street_name, "str")
    if cross_street is not None:
        _params["crossStreet"] = _SERIALIZER.query("cross_street", cross_street, "str")
    if municipality is not None:
        _params["municipality"] = _SERIALIZER.query("municipality", municipality, "str")
    if municipality_subdivision is not None:
        _params["municipalitySubdivision"] = _SERIALIZER.query(
            "municipality_subdivision", municipality_subdivision, "str"
        )
    if country_tertiary_subdivision is not None:
        _params["countryTertiarySubdivision"] = _SERIALIZER.query(
            "country_tertiary_subdivision", country_tertiary_subdivision, "str"
        )
    if country_secondary_subdivision is not None:
        _params["countrySecondarySubdivision"] = _SERIALIZER.query(
            "country_secondary_subdivision", country_secondary_subdivision, "str"
        )
    if country_subdivision is not None:
        _params["countrySubdivision"] = _SERIALIZER.query("country_subdivision", country_subdivision, "str")
    if postal_code is not None:
        _params["postalCode"] = _SERIALIZER.query("postal_code", postal_code, "str")
    if extended_postal_codes_for is not None:
        _params["extendedPostalCodesFor"] = _SERIALIZER.query(
            "extended_postal_codes_for", extended_postal_codes_for, "[str]", div=","
        )
    if entity_type is not None:
        _params["entityType"] = _SERIALIZER.query("entity_type", entity_type, "str")
    if localized_map_view is not None:
        _params["view"] = _SERIALIZER.query("localized_map_view", localized_map_view, "str")

    # Construct headers
    if client_id is not None:
        _headers["x-ms-client-id"] = _SERIALIZER.header("client_id", client_id, "str")
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="GET", url=_url, params=_params, headers=_headers, **kwargs)


def build_search_search_inside_geometry_request(  # pylint: disable=name-too-long
    format: Union[str, _models.ResponseFormat] = "json",
    *,
    query: str,
    top: Optional[int] = None,
    language: Optional[str] = None,
    category_filter: Optional[List[int]] = None,
    extended_postal_codes_for: Optional[List[Union[str, _models.SearchIndexes]]] = None,
    index_filter: Optional[List[Union[str, _models.SearchIndexes]]] = None,
    localized_map_view: Optional[Union[str, _models.LocalizedMapView]] = None,
    operating_hours: Optional[Union[str, _models.OperatingHoursRange]] = None,
    client_id: Optional[str] = None,
    **kwargs: Any
) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "1.0"))
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/search/geometry/{format}"
    path_format_arguments = {
        "format": _SERIALIZER.url("format", format, "str"),
    }

    _url: str = _url.format(**path_format_arguments)  # type: ignore

    # Construct parameters
    _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")
    _params["query"] = _SERIALIZER.query("query", query, "str")
    if top is not None:
        _params["limit"] = _SERIALIZER.query("top", top, "int", maximum=100, minimum=1)
    if language is not None:
        _params["language"] = _SERIALIZER.query("language", language, "str")
    if category_filter is not None:
        _params["categorySet"] = _SERIALIZER.query("category_filter", category_filter, "[int]", div=",")
    if extended_postal_codes_for is not None:
        _params["extendedPostalCodesFor"] = _SERIALIZER.query(
            "extended_postal_codes_for", extended_postal_codes_for, "[str]", div=","
        )
    if index_filter is not None:
        _params["idxSet"] = _SERIALIZER.query("index_filter", index_filter, "[str]", div=",")
    if localized_map_view is not None:
        _params["view"] = _SERIALIZER.query("localized_map_view", localized_map_view, "str")
    if operating_hours is not None:
        _params["openingHours"] = _SERIALIZER.query("operating_hours", operating_hours, "str")

    # Construct headers
    if client_id is not None:
        _headers["x-ms-client-id"] = _SERIALIZER.header("client_id", client_id, "str")
    if content_type is not None:
        _headers["Content-Type"] = _SERIALIZER.header("content_type", content_type, "str")
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="POST", url=_url, params=_params, headers=_headers, **kwargs)


def build_search_search_along_route_request(
    format: Union[str, _models.ResponseFormat] = "json",
    *,
    query: str,
    max_detour_time: int,
    top: Optional[int] = None,
    brand_filter: Optional[List[str]] = None,
    category_filter: Optional[List[int]] = None,
    electric_vehicle_connector_filter: Optional[List[Union[str, _models.ElectricVehicleConnector]]] = None,
    localized_map_view: Optional[Union[str, _models.LocalizedMapView]] = None,
    operating_hours: Optional[Union[str, _models.OperatingHoursRange]] = None,
    client_id: Optional[str] = None,
    **kwargs: Any
) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "1.0"))
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/search/alongRoute/{format}"
    path_format_arguments = {
        "format": _SERIALIZER.url("format", format, "str"),
    }

    _url: str = _url.format(**path_format_arguments)  # type: ignore

    # Construct parameters
    _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")
    _params["query"] = _SERIALIZER.query("query", query, "str")
    _params["maxDetourTime"] = _SERIALIZER.query("max_detour_time", max_detour_time, "int", maximum=3600)
    if top is not None:
        _params["limit"] = _SERIALIZER.query("top", top, "int", maximum=20)
    if brand_filter is not None:
        _params["brandSet"] = _SERIALIZER.query("brand_filter", brand_filter, "[str]", div=",")
    if category_filter is not None:
        _params["categorySet"] = _SERIALIZER.query("category_filter", category_filter, "[int]", div=",")
    if electric_vehicle_connector_filter is not None:
        _params["connectorSet"] = _SERIALIZER.query(
            "electric_vehicle_connector_filter", electric_vehicle_connector_filter, "[str]", div=","
        )
    if localized_map_view is not None:
        _params["view"] = _SERIALIZER.query("localized_map_view", localized_map_view, "str")
    if operating_hours is not None:
        _params["openingHours"] = _SERIALIZER.query("operating_hours", operating_hours, "str")

    # Construct headers
    if client_id is not None:
        _headers["x-ms-client-id"] = _SERIALIZER.header("client_id", client_id, "str")
    if content_type is not None:
        _headers["Content-Type"] = _SERIALIZER.header("content_type", content_type, "str")
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="POST", url=_url, params=_params, headers=_headers, **kwargs)


def build_search_fuzzy_search_batch_sync_request(  # pylint: disable=name-too-long
    format: Union[str, _models.JsonFormat] = "json", *, client_id: Optional[str] = None, **kwargs: Any
) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "1.0"))
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/search/fuzzy/batch/sync/{format}"
    path_format_arguments = {
        "format": _SERIALIZER.url("format", format, "str"),
    }

    _url: str = _url.format(**path_format_arguments)  # type: ignore

    # Construct parameters
    _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")

    # Construct headers
    if client_id is not None:
        _headers["x-ms-client-id"] = _SERIALIZER.header("client_id", client_id, "str")
    if content_type is not None:
        _headers["Content-Type"] = _SERIALIZER.header("content_type", content_type, "str")
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="POST", url=_url, params=_params, headers=_headers, **kwargs)


def build_search_fuzzy_search_batch_request(
    format: Union[str, _models.JsonFormat] = "json", *, client_id: Optional[str] = None, **kwargs: Any
) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "1.0"))
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/search/fuzzy/batch/{format}"
    path_format_arguments = {
        "format": _SERIALIZER.url("format", format, "str"),
    }

    _url: str = _url.format(**path_format_arguments)  # type: ignore

    # Construct parameters
    _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")

    # Construct headers
    if client_id is not None:
        _headers["x-ms-client-id"] = _SERIALIZER.header("client_id", client_id, "str")
    if content_type is not None:
        _headers["Content-Type"] = _SERIALIZER.header("content_type", content_type, "str")
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="POST", url=_url, params=_params, headers=_headers, **kwargs)


def build_search_get_fuzzy_search_batch_request(  # pylint: disable=name-too-long
    batch_id: str, *, client_id: Optional[str] = None, **kwargs: Any
) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "1.0"))
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/search/fuzzy/batch/{format}"
    path_format_arguments = {
        "format": _SERIALIZER.url("batch_id", batch_id, "str"),
    }

    _url: str = _url.format(**path_format_arguments)  # type: ignore

    # Construct parameters
    _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")

    # Construct headers
    if client_id is not None:
        _headers["x-ms-client-id"] = _SERIALIZER.header("client_id", client_id, "str")
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="GET", url=_url, params=_params, headers=_headers, **kwargs)


def build_search_search_address_batch_sync_request(  # pylint: disable=name-too-long
    format: Union[str, _models.JsonFormat] = "json", *, client_id: Optional[str] = None, **kwargs: Any
) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "1.0"))
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/search/address/batch/sync/{format}"
    path_format_arguments = {
        "format": _SERIALIZER.url("format", format, "str"),
    }

    _url: str = _url.format(**path_format_arguments)  # type: ignore

    # Construct parameters
    _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")

    # Construct headers
    if client_id is not None:
        _headers["x-ms-client-id"] = _SERIALIZER.header("client_id", client_id, "str")
    if content_type is not None:
        _headers["Content-Type"] = _SERIALIZER.header("content_type", content_type, "str")
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="POST", url=_url, params=_params, headers=_headers, **kwargs)


def build_search_search_address_batch_request(  # pylint: disable=name-too-long
    format: Union[str, _models.JsonFormat] = "json", *, client_id: Optional[str] = None, **kwargs: Any
) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "1.0"))
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/search/address/batch/{format}"
    path_format_arguments = {
        "format": _SERIALIZER.url("format", format, "str"),
    }

    _url: str = _url.format(**path_format_arguments)  # type: ignore

    # Construct parameters
    _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")

    # Construct headers
    if client_id is not None:
        _headers["x-ms-client-id"] = _SERIALIZER.header("client_id", client_id, "str")
    if content_type is not None:
        _headers["Content-Type"] = _SERIALIZER.header("content_type", content_type, "str")
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="POST", url=_url, params=_params, headers=_headers, **kwargs)


def build_search_get_search_address_batch_request(  # pylint: disable=name-too-long
    batch_id: str, *, client_id: Optional[str] = None, **kwargs: Any
) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "1.0"))
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/search/address/batch/{format}"
    path_format_arguments = {
        "format": _SERIALIZER.url("batch_id", batch_id, "str"),
    }

    _url: str = _url.format(**path_format_arguments)  # type: ignore

    # Construct parameters
    _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")

    # Construct headers
    if client_id is not None:
        _headers["x-ms-client-id"] = _SERIALIZER.header("client_id", client_id, "str")
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="GET", url=_url, params=_params, headers=_headers, **kwargs)


def build_search_reverse_search_address_batch_sync_request(  # pylint: disable=name-too-long
    format: Union[str, _models.JsonFormat] = "json", *, client_id: Optional[str] = None, **kwargs: Any
) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "1.0"))
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/search/address/reverse/batch/sync/{format}"
    path_format_arguments = {
        "format": _SERIALIZER.url("format", format, "str"),
    }

    _url: str = _url.format(**path_format_arguments)  # type: ignore

    # Construct parameters
    _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")

    # Construct headers
    if client_id is not None:
        _headers["x-ms-client-id"] = _SERIALIZER.header("client_id", client_id, "str")
    if content_type is not None:
        _headers["Content-Type"] = _SERIALIZER.header("content_type", content_type, "str")
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="POST", url=_url, params=_params, headers=_headers, **kwargs)


def build_search_reverse_search_address_batch_request(  # pylint: disable=name-too-long
    format: Union[str, _models.JsonFormat] = "json", *, client_id: Optional[str] = None, **kwargs: Any
) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "1.0"))
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/search/address/reverse/batch/{format}"
    path_format_arguments = {
        "format": _SERIALIZER.url("format", format, "str"),
    }

    _url: str = _url.format(**path_format_arguments)  # type: ignore

    # Construct parameters
    _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")

    # Construct headers
    if client_id is not None:
        _headers["x-ms-client-id"] = _SERIALIZER.header("client_id", client_id, "str")
    if content_type is not None:
        _headers["Content-Type"] = _SERIALIZER.header("content_type", content_type, "str")
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="POST", url=_url, params=_params, headers=_headers, **kwargs)


def build_search_get_reverse_search_address_batch_request(  # pylint: disable=name-too-long
    batch_id: str, *, client_id: Optional[str] = None, **kwargs: Any
) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "1.0"))
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/search/address/reverse/batch/{format}"
    path_format_arguments = {
        "format": _SERIALIZER.url("batch_id", batch_id, "str"),
    }

    _url: str = _url.format(**path_format_arguments)  # type: ignore

    # Construct parameters
    _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")

    # Construct headers
    if client_id is not None:
        _headers["x-ms-client-id"] = _SERIALIZER.header("client_id", client_id, "str")
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="GET", url=_url, params=_params, headers=_headers, **kwargs)


class SearchOperations:  # pylint: disable=too-many-public-methods
    """
    .. warning::
        **DO NOT** instantiate this class directly.

        Instead, you should access the following operations through
        :class:`~azure.maps.search.MapsSearchClient`'s
        :attr:`search` attribute.
    """

    models = _models

    def __init__(self, *args, **kwargs):
        input_args = list(args)
        self._client = input_args.pop(0) if input_args else kwargs.pop("client")
        self._config = input_args.pop(0) if input_args else kwargs.pop("config")
        self._serialize = input_args.pop(0) if input_args else kwargs.pop("serializer")
        self._deserialize = input_args.pop(0) if input_args else kwargs.pop("deserializer")

    @distributed_trace
    def list_polygons(
        self, format: Union[str, _models.JsonFormat] = "json", *, geometry_ids: List[str], **kwargs: Any
    ) -> _models.PolygonResult:
        """**Get Polygon**

        **Applies to:** see `pricing tiers <https://aka.ms/AzureMapsPricingTier>`_.

        The Get Polygon service allows you to request the geometry data such as a city or
        country/region outline for a set of entities, previously retrieved from an Online Search
        request in GeoJSON format. The geometry ID is returned in the sourceGeometry object under
        "geometry" and "id" in either a Search Address or Search Fuzzy call.

        Please note that any geometry ID retrieved from an Online Search endpoint has a limited
        lifetime. The client  should not store geometry IDs in persistent storage for later referral,
        as the stability of these identifiers is  not guaranteed for a long period of time. It is
        expected that a request to the Polygon method is made within a  few minutes of the request to
        the Online Search method that provided the ID. The service allows for batch  requests up to 20
        identifiers.

        :param format: Desired format of the response. Only ``json`` format is supported. "json"
         Default value is "json".
        :type format: str or ~azure.maps.search.models.JsonFormat
        :keyword geometry_ids: Comma separated list of geometry UUIDs, previously retrieved from an
         Online Search request. Required.
        :paramtype geometry_ids: list[str]
        :return: PolygonResult
        :rtype: ~azure.maps.search.models.PolygonResult
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[_models.PolygonResult] = kwargs.pop("cls", None)

        _request = build_search_list_polygons_request(
            format=format,
            geometry_ids=geometry_ids,
            client_id=self._config.client_id,
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = False
        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                response.read()  # Load the body in memory and close the socket
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize.failsafe_deserialize(_models.ErrorResponse, pipeline_response)
            raise HttpResponseError(response=response, model=error)

        deserialized = self._deserialize("PolygonResult", pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore

    @distributed_trace
    def fuzzy_search(
        self,
        format: Union[str, _models.ResponseFormat] = "json",
        *,
        query: str,
        is_type_ahead: Optional[bool] = None,
        top: Optional[int] = None,
        skip: Optional[int] = None,
        category_filter: Optional[List[int]] = None,
        country_filter: Optional[List[str]] = None,
        lat: Optional[float] = None,
        lon: Optional[float] = None,
        radius_in_meters: Optional[int] = None,
        top_left: Optional[str] = None,
        btm_right: Optional[str] = None,
        language: Optional[str] = None,
        extended_postal_codes_for: Optional[List[Union[str, _models.SearchIndexes]]] = None,
        min_fuzzy_level: Optional[int] = None,
        max_fuzzy_level: Optional[int] = None,
        index_filter: Optional[List[Union[str, _models.SearchIndexes]]] = None,
        brand_filter: Optional[List[str]] = None,
        electric_vehicle_connector_filter: Optional[List[Union[str, _models.ElectricVehicleConnector]]] = None,
        entity_type: Optional[Union[str, _models.GeographicEntityType]] = None,
        localized_map_view: Optional[Union[str, _models.LocalizedMapView]] = None,
        operating_hours: Optional[Union[str, _models.OperatingHoursRange]] = None,
        **kwargs: Any
    ) -> _models.SearchAddressResult:
        """**Free Form Search**

        **Applies to:** see `pricing tiers <https://aka.ms/AzureMapsPricingTier>`_.

        The basic default API is Free Form Search which handles the most fuzzy of inputs handling any
        combination of address or POI tokens. This search API is the canonical 'single line search'.
        The Free Form Search API is a seamless combination of POI search and geocoding. The API can
        also be weighted with a contextual position (lat./lon. pair), or fully constrained by a
        coordinate and radius, or it can be executed more generally without any geo biasing anchor
        point.:code:`<br>`:code:`<br>`We strongly advise you to use the 'countrySet' parameter to
        specify only the countries/regions for which your application needs coverage, as the default
        behavior will be to search the entire world, potentially returning unnecessary
        results.:code:`<br>`:code:`<br>` E.g.: ``countrySet``\ =US,FR :code:`<br>`:code:`<br>`Please
        see `Search Coverage </azure/location-based-services/geocoding-coverage>`_ for a complete list
        of all the supported countries/regions.:code:`<br>`:code:`<br>`Most Search queries default to
        ``maxFuzzyLevel``\ =2 to gain performance and also reduce unusual results. This new default can
        be overridden as needed per request by passing in the query param ``maxFuzzyLevel``\ =3 or 4.

        :param format: Desired format of the response. Value can be either *json* or *xml*. Known
         values are: "json" and "xml". Default value is "json".
        :type format: str or ~azure.maps.search.models.ResponseFormat
        :keyword query: The applicable query string (e.g., "seattle", "pizza"). Can *also* be specified
         as a comma separated string composed by latitude followed by longitude (e.g., "47.641268,
         -122.125679"). Must be properly URL encoded. Required.
        :paramtype query: str
        :keyword is_type_ahead: Boolean. If the typeahead flag is set, the query will be interpreted as
         a partial input and the search will enter predictive mode. Default value is None.
        :paramtype is_type_ahead: bool
        :keyword top: Maximum number of responses that will be returned. Default: 10, minimum: 1 and
         maximum: 100. Default value is None.
        :paramtype top: int
        :keyword skip: Starting offset of the returned results within the full result set. Default: 0.
         Default value is None.
        :paramtype skip: int
        :keyword category_filter: A comma-separated list of category set IDs which could be used to
         restrict the result to specific Points of Interest categories. ID order does not matter.
         Maximum number of ``categorySet`` values supported per request is 10. When multiple category
         identifiers are provided, only POIs that belong to (at least) one of the categories from the
         provided list will be returned. The list of supported categories can be discovered using `POI
         Categories API <https://aka.ms/AzureMapsPOICategoryTree>`_. Usage examples:


         *
           **categorySet=7315** (Search Points of Interest from category Restaurant)

         *
           **categorySet=7315025,7315017** (Search Points of Interest of category either Italian or
         French Restaurant). Default value is None.
        :paramtype category_filter: list[int]
        :keyword country_filter: Comma separated string of country/region codes, e.g. FR,ES. This will
         limit the search to the specified countries/regions. Default value is None.
        :paramtype country_filter: list[str]
        :keyword lat: Latitude where results should be biased. E.g. 37.337. Default value is None.
        :paramtype lat: float
        :keyword lon: Longitude where results should be biased. E.g. -121.89. Default value is None.
        :paramtype lon: float
        :keyword radius_in_meters: The radius in meters to for the results to be constrained to the
         defined area. Default value is None.
        :paramtype radius_in_meters: int
        :keyword top_left: Top left position of the bounding box. E.g. 37.553,-122.453. Default value
         is None.
        :paramtype top_left: str
        :keyword btm_right: Bottom right position of the bounding box. E.g. 37.553,-122.453. Default
         value is None.
        :paramtype btm_right: str
        :keyword language: Language in which search results should be returned. Should be one of
         supported IETF language tags, case insensitive. When data in specified language is not
         available for a specific field, default language is used.

         Please refer to `Supported Languages
         <https://docs.microsoft.com/azure/azure-maps/supported-languages>`_ for details. Default value
         is None.
        :paramtype language: str
        :keyword extended_postal_codes_for: Indexes for which extended postal codes should be included
         in the results.

         Available indexes are:

          **Addr** = Address ranges

          **Geo** = Geographies

          **PAD** = Point Addresses

          **POI** = Points of Interest

          **Str** = Streets

          **XStr** = Cross Streets (intersections)

         Value should be a comma separated list of index types (in any order) or **None** for no
         indexes.

         By default extended postal codes are included for all indexes except Geo. Extended postal code
         lists for geographies can be quite long so they have to be explicitly requested when needed.

         Usage examples:

          extendedPostalCodesFor=POI

          extendedPostalCodesFor=PAD,Addr,POI

          extendedPostalCodesFor=None

         Extended postal code is returned as an **extendedPostalCode** property of an address.
         Availability is region-dependent. Default value is None.
        :paramtype extended_postal_codes_for: list[str or ~azure.maps.search.models.SearchIndexes]
        :keyword min_fuzzy_level: Minimum fuzziness level to be used. Default: 1, minimum: 1 and
         maximum: 4


         *
           Level 1 has no spell checking.

         *
           Level 2 uses normal n-gram spell checking. For example, query "restrant" can be matched to
         "restaurant."

         *
           Level 3 uses sound-like spell checking, and shingle spell checking. Sound-like spell
         checking is for "rstrnt" to "restaurant" matching. Shingle spell checking is for "mountainview"
         to "mountain view" matching.

         *
           Level 4 doesn’t add any more spell checking functions.

         The search engine will start looking for a match on the level defined by minFuzzyLevel, and
         will stop searching at the level specified by maxFuzzyLevel. Default value is None.
        :paramtype min_fuzzy_level: int
        :keyword max_fuzzy_level: Maximum fuzziness level to be used. Default: 2, minimum: 1 and
         maximum: 4


         *
           Level 1 has no spell checking.

         *
           Level 2 uses normal n-gram spell checking. For example, query "restrant" can be matched to
         "restaurant."

         *
           Level 3 uses sound-like spell checking, and shingle spell checking. Sound-like spell
         checking is for "rstrnt" to "restaurant" matching. Shingle spell checking is for "mountainview"
         to "mountain view" matching.

         *
           Level 4 doesn’t add any more spell checking functions.

         The search engine will start looking for a match on the level defined by minFuzzyLevel, and
         will stop searching at the level specified by maxFuzzyLevel. Default value is None.
        :paramtype max_fuzzy_level: int
        :keyword index_filter: A comma separated list of indexes which should be utilized for the
         search. Item order does not matter. Available indexes are: Addr = Address range interpolation,
         Geo = Geographies, PAD = Point Addresses, POI = Points of interest, Str = Streets, Xstr = Cross
         Streets (intersections). Default value is None.
        :paramtype index_filter: list[str or ~azure.maps.search.models.SearchIndexes]
        :keyword brand_filter: A comma-separated list of brand names which could be used to restrict
         the result to specific brands. Item order does not matter. When multiple brands are provided,
         only results that belong to (at least) one of the provided list will be returned. Brands that
         contain a "," in their name should be put into quotes.

         Usage examples:

          brandSet=Foo

          brandSet=Foo,Bar

          brandSet="A,B,C Comma",Bar. Default value is None.
        :paramtype brand_filter: list[str]
        :keyword electric_vehicle_connector_filter: A comma-separated list of connector types which
         could be used to restrict the result to Electric Vehicle Station supporting specific connector
         types. Item order does not matter. When multiple connector types are provided, only results
         that belong to (at least) one of the provided list will be returned.

         Available connector types are:


         * ``StandardHouseholdCountrySpecific`` - These are the standard household connectors for a
         certain region. They are all AC single phase and the standard Voltage and standard Amperage.
         See also: `Plug & socket types - World Standards
         <https://www.worldstandards.eu/electricity/plugs-and-sockets>`_.
         * ``IEC62196Type1`` - Type 1 connector as defined in the IEC 62196-2 standard. Also called
         Yazaki after the original manufacturer or SAE J1772 after the standard that first published it.
         Mostly used in combination with 120V single phase or up to 240V single phase infrastructure.
         * ``IEC62196Type1CCS`` - Type 1 based combo connector as defined in the IEC 62196-3 standard.
         The connector is based on the Type 1 connector – as defined in the IEC 62196-2 standard – with
         two additional direct current (DC) contacts to allow DC fast charging.
         * ``IEC62196Type2CableAttached`` - Type 2 connector as defined in the IEC 62196-2 standard.
         Provided as a cable and plug attached to the charging point.
         * ``IEC62196Type2Outlet`` - Type 2 connector as defined in the IEC 62196-2 standard. Provided
         as a socket set into the charging point.
         * ``IEC62196Type2CCS`` - Type 2 based combo connector as defined in the IEC 62196-3 standard.
         The connector is based on the Type 2 connector – as defined in the IEC 62196-2 standard – with
         two additional direct current (DC) contacts to allow DC fast charging.
         * ``IEC62196Type3`` - Type 3 connector as defined in the IEC 62196-2 standard. Also called
         Scame after the original manufacturer. Mostly used in combination with up to 240V single phase
         or up to 420V three phase infrastructure.
         * ``Chademo`` - CHAdeMO connector named after an association formed by the Tokyo Electric
         Power Company and industrial partners. Because of this is is also known as the TEPCO's
         connector. It supports fast DC charging.
         * ``IEC60309AC1PhaseBlue`` - Industrial Blue connector is a connector defined in the IEC 60309
         standard. It is sometime referred to as by some combination of the standard, the color and the
         fact that is a single phase connector. The connector usually has the "P+N+E, 6h" configuration.
         * ``IEC60309DCWhite`` - Industrial White connector is a DC connector defined in the IEC 60309
         standard.
         * ``Tesla`` - The Tesla connector is the regionally specific Tesla Supercharger connector.
         I.e. it refers to either Tesla's proprietary connector, sometimes referred to as Tesla Port
         mostly limited to North America or the modified Type 2 (DC over Type 2) in Europe.

         Usage examples:

          connectorSet=IEC62196Type2CableAttached
          connectorSet=IEC62196Type2Outlet,IEC62196Type2CableAttached. Default value is None.
        :paramtype electric_vehicle_connector_filter: list[str or
         ~azure.maps.search.models.ElectricVehicleConnector]
        :keyword entity_type: Specifies the level of filtering performed on geographies. Narrows the
         search for specified geography entity types, e.g. return only municipality. The resulting
         response will contain the geography ID as well as the entity type matched. If you provide more
         than one entity as a comma separated list, endpoint will return the 'smallest entity
         available'. Returned Geometry ID can be used to get the geometry of that geography via `Get
         Search Polygon </rest/api/maps/search/get-search-polygon?view=rest-maps-1.0>`_ API. The
         following parameters are ignored when entityType is set:


         * heading
         * number
         * returnRoadUse
         * returnSpeedLimit
         * roadUse
         * returnMatchType. Known values are: "Country", "CountrySubdivision",
         "CountrySecondarySubdivision", "CountryTertiarySubdivision", "Municipality",
         "MunicipalitySubdivision", "Neighbourhood", and "PostalCodeArea". Default value is None.
        :paramtype entity_type: str or ~azure.maps.search.models.GeographicEntityType
        :keyword localized_map_view: The View parameter (also called the "user region" parameter)
         allows you to show the correct maps for a certain country/region for geopolitically disputed
         regions. Different countries/regions have different views of such regions, and the View
         parameter allows your application to comply with the view required by the country/region your
         application will be serving. By default, the View parameter is set to “Unified” even if you
         haven’t defined it in  the request. It is your responsibility to determine the location of your
         users, and then set the View parameter correctly for that location. Alternatively, you have the
         option to set ‘View=Auto’, which will return the map data based on the IP  address of the
         request. The View parameter in Azure Maps must be used in compliance with applicable laws,
         including those  regarding mapping, of the country/region where maps, images and other data and
         third party content that you are authorized to  access via Azure Maps is made available.
         Example: view=IN.

         Please refer to `Supported Views <https://aka.ms/AzureMapsLocalizationViews>`_ for details and
         to see the available Views. Known values are: "AE", "AR", "BH", "IN", "IQ", "JO", "KW", "LB",
         "MA", "OM", "PK", "PS", "QA", "SA", "SY", "YE", "Auto", and "Unified". Default value is None.
        :paramtype localized_map_view: str or ~azure.maps.search.models.LocalizedMapView
        :keyword operating_hours: Hours of operation for a POI (Points of Interest). The availability
         of hours of operation will vary based on the data available. If not passed, then no opening
         hours information will be returned.
         Supported value: nextSevenDays. "nextSevenDays" Default value is None.
        :paramtype operating_hours: str or ~azure.maps.search.models.OperatingHoursRange
        :return: SearchAddressResult
        :rtype: ~azure.maps.search.models.SearchAddressResult
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[_models.SearchAddressResult] = kwargs.pop("cls", None)

        _request = build_search_fuzzy_search_request(
            format=format,
            query=query,
            is_type_ahead=is_type_ahead,
            top=top,
            skip=skip,
            category_filter=category_filter,
            country_filter=country_filter,
            lat=lat,
            lon=lon,
            radius_in_meters=radius_in_meters,
            top_left=top_left,
            btm_right=btm_right,
            language=language,
            extended_postal_codes_for=extended_postal_codes_for,
            min_fuzzy_level=min_fuzzy_level,
            max_fuzzy_level=max_fuzzy_level,
            index_filter=index_filter,
            brand_filter=brand_filter,
            electric_vehicle_connector_filter=electric_vehicle_connector_filter,
            entity_type=entity_type,
            localized_map_view=localized_map_view,
            operating_hours=operating_hours,
            client_id=self._config.client_id,
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = False
        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                response.read()  # Load the body in memory and close the socket
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize.failsafe_deserialize(_models.ErrorResponse, pipeline_response)
            raise HttpResponseError(response=response, model=error)

        deserialized = self._deserialize("SearchAddressResult", pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore

    @distributed_trace
    def search_point_of_interest(
        self,
        format: Union[str, _models.ResponseFormat] = "json",
        *,
        query: str,
        is_type_ahead: Optional[bool] = None,
        top: Optional[int] = None,
        skip: Optional[int] = None,
        category_filter: Optional[List[int]] = None,
        country_filter: Optional[List[str]] = None,
        lat: Optional[float] = None,
        lon: Optional[float] = None,
        radius_in_meters: Optional[int] = None,
        top_left: Optional[str] = None,
        btm_right: Optional[str] = None,
        language: Optional[str] = None,
        extended_postal_codes_for: Optional[List[Union[str, _models.PointOfInterestExtendedPostalCodes]]] = None,
        brand_filter: Optional[List[str]] = None,
        electric_vehicle_connector_filter: Optional[List[Union[str, _models.ElectricVehicleConnector]]] = None,
        localized_map_view: Optional[Union[str, _models.LocalizedMapView]] = None,
        operating_hours: Optional[Union[str, _models.OperatingHoursRange]] = None,
        **kwargs: Any
    ) -> _models.SearchAddressResult:
        """**Get POI by Name**

        **Applies to:** see `pricing tiers <https://aka.ms/AzureMapsPricingTier>`_.

        Points of Interest (POI) Search allows you to request POI results by name.  Search supports
        additional query parameters such as language and filtering results by area of interest driven
        by country/region or bounding box.  Endpoint will return only POI results matching the query
        string. Response includes POI details such as address, coordinate location and category.

        :param format: Desired format of the response. Value can be either *json* or *xml*. Known
         values are: "json" and "xml". Default value is "json".
        :type format: str or ~azure.maps.search.models.ResponseFormat
        :keyword query: The POI name to search for (e.g., "statue of liberty", "starbucks"), must be
         properly URL encoded. Required.
        :paramtype query: str
        :keyword is_type_ahead: Boolean. If the typeahead flag is set, the query will be interpreted as
         a partial input and the search will enter predictive mode. Default value is None.
        :paramtype is_type_ahead: bool
        :keyword top: Maximum number of responses that will be returned. Default: 10, minimum: 1 and
         maximum: 100. Default value is None.
        :paramtype top: int
        :keyword skip: Starting offset of the returned results within the full result set. Default: 0.
         Default value is None.
        :paramtype skip: int
        :keyword category_filter: A comma-separated list of category set IDs which could be used to
         restrict the result to specific Points of Interest categories. ID order does not matter.
         Maximum number of ``categorySet`` values supported per request is 10. When multiple category
         identifiers are provided, only POIs that belong to (at least) one of the categories from the
         provided list will be returned. The list of supported categories can be discovered using `POI
         Categories API <https://aka.ms/AzureMapsPOICategoryTree>`_. Usage examples:


         *
           **categorySet=7315** (Search Points of Interest from category Restaurant)

         *
           **categorySet=7315025,7315017** (Search Points of Interest of category either Italian or
         French Restaurant). Default value is None.
        :paramtype category_filter: list[int]
        :keyword country_filter: Comma separated string of country/region codes, e.g. FR,ES. This will
         limit the search to the specified countries/regions. Default value is None.
        :paramtype country_filter: list[str]
        :keyword lat: Latitude where results should be biased. E.g. 37.337. Default value is None.
        :paramtype lat: float
        :keyword lon: Longitude where results should be biased. E.g. -121.89. Default value is None.
        :paramtype lon: float
        :keyword radius_in_meters: The radius in meters to for the results to be constrained to the
         defined area. Default value is None.
        :paramtype radius_in_meters: int
        :keyword top_left: Top left position of the bounding box. E.g. 37.553,-122.453. Default value
         is None.
        :paramtype top_left: str
        :keyword btm_right: Bottom right position of the bounding box. E.g. 37.553,-122.453. Default
         value is None.
        :paramtype btm_right: str
        :keyword language: Language in which search results should be returned. Should be one of
         supported IETF language tags, case insensitive. When data in specified language is not
         available for a specific field, default language is used.

         Please refer to `Supported Languages
         <https://docs.microsoft.com/azure/azure-maps/supported-languages>`_ for details. Default value
         is None.
        :paramtype language: str
        :keyword extended_postal_codes_for: Indexes for which extended postal codes should be included
         in the results.

         Available indexes are:

          **POI** = Points of Interest

         Value should be **POI** or **None** to disable extended postal codes.

         By default extended postal codes are included.

         Usage examples:

          extendedPostalCodesFor=POI

          extendedPostalCodesFor=None

         Extended postal code is returned as an **extendedPostalCode** property of an address.
         Availability is region-dependent. Default value is None.
        :paramtype extended_postal_codes_for: list[str or
         ~azure.maps.search.models.PointOfInterestExtendedPostalCodes]
        :keyword brand_filter: A comma-separated list of brand names which could be used to restrict
         the result to specific brands. Item order does not matter. When multiple brands are provided,
         only results that belong to (at least) one of the provided list will be returned. Brands that
         contain a "," in their name should be put into quotes.

         Usage examples:

          brandSet=Foo

          brandSet=Foo,Bar

          brandSet="A,B,C Comma",Bar. Default value is None.
        :paramtype brand_filter: list[str]
        :keyword electric_vehicle_connector_filter: A comma-separated list of connector types which
         could be used to restrict the result to Electric Vehicle Station supporting specific connector
         types. Item order does not matter. When multiple connector types are provided, only results
         that belong to (at least) one of the provided list will be returned.

         Available connector types are:


         * ``StandardHouseholdCountrySpecific`` - These are the standard household connectors for a
         certain region. They are all AC single phase and the standard Voltage and standard Amperage.
         See also: `Plug & socket types - World Standards
         <https://www.worldstandards.eu/electricity/plugs-and-sockets>`_.
         * ``IEC62196Type1`` - Type 1 connector as defined in the IEC 62196-2 standard. Also called
         Yazaki after the original manufacturer or SAE J1772 after the standard that first published it.
         Mostly used in combination with 120V single phase or up to 240V single phase infrastructure.
         * ``IEC62196Type1CCS`` - Type 1 based combo connector as defined in the IEC 62196-3 standard.
         The connector is based on the Type 1 connector – as defined in the IEC 62196-2 standard – with
         two additional direct current (DC) contacts to allow DC fast charging.
         * ``IEC62196Type2CableAttached`` - Type 2 connector as defined in the IEC 62196-2 standard.
         Provided as a cable and plug attached to the charging point.
         * ``IEC62196Type2Outlet`` - Type 2 connector as defined in the IEC 62196-2 standard. Provided
         as a socket set into the charging point.
         * ``IEC62196Type2CCS`` - Type 2 based combo connector as defined in the IEC 62196-3 standard.
         The connector is based on the Type 2 connector – as defined in the IEC 62196-2 standard – with
         two additional direct current (DC) contacts to allow DC fast charging.
         * ``IEC62196Type3`` - Type 3 connector as defined in the IEC 62196-2 standard. Also called
         Scame after the original manufacturer. Mostly used in combination with up to 240V single phase
         or up to 420V three phase infrastructure.
         * ``Chademo`` - CHAdeMO connector named after an association formed by the Tokyo Electric
         Power Company and industrial partners. Because of this is is also known as the TEPCO's
         connector. It supports fast DC charging.
         * ``IEC60309AC1PhaseBlue`` - Industrial Blue connector is a connector defined in the IEC 60309
         standard. It is sometime referred to as by some combination of the standard, the color and the
         fact that is a single phase connector. The connector usually has the "P+N+E, 6h" configuration.
         * ``IEC60309DCWhite`` - Industrial White connector is a DC connector defined in the IEC 60309
         standard.
         * ``Tesla`` - The Tesla connector is the regionally specific Tesla Supercharger connector.
         I.e. it refers to either Tesla's proprietary connector, sometimes referred to as Tesla Port
         mostly limited to North America or the modified Type 2 (DC over Type 2) in Europe.

         Usage examples:

          connectorSet=IEC62196Type2CableAttached
          connectorSet=IEC62196Type2Outlet,IEC62196Type2CableAttached. Default value is None.
        :paramtype electric_vehicle_connector_filter: list[str or
         ~azure.maps.search.models.ElectricVehicleConnector]
        :keyword localized_map_view: The View parameter (also called the "user region" parameter)
         allows you to show the correct maps for a certain country/region for geopolitically disputed
         regions. Different countries/regions have different views of such regions, and the View
         parameter allows your application to comply with the view required by the country/region your
         application will be serving. By default, the View parameter is set to “Unified” even if you
         haven’t defined it in  the request. It is your responsibility to determine the location of your
         users, and then set the View parameter correctly for that location. Alternatively, you have the
         option to set ‘View=Auto’, which will return the map data based on the IP  address of the
         request. The View parameter in Azure Maps must be used in compliance with applicable laws,
         including those  regarding mapping, of the country/region where maps, images and other data and
         third party content that you are authorized to  access via Azure Maps is made available.
         Example: view=IN.

         Please refer to `Supported Views <https://aka.ms/AzureMapsLocalizationViews>`_ for details and
         to see the available Views. Known values are: "AE", "AR", "BH", "IN", "IQ", "JO", "KW", "LB",
         "MA", "OM", "PK", "PS", "QA", "SA", "SY", "YE", "Auto", and "Unified". Default value is None.
        :paramtype localized_map_view: str or ~azure.maps.search.models.LocalizedMapView
        :keyword operating_hours: Hours of operation for a POI (Points of Interest). The availability
         of hours of operation will vary based on the data available. If not passed, then no opening
         hours information will be returned.
         Supported value: nextSevenDays. "nextSevenDays" Default value is None.
        :paramtype operating_hours: str or ~azure.maps.search.models.OperatingHoursRange
        :return: SearchAddressResult
        :rtype: ~azure.maps.search.models.SearchAddressResult
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[_models.SearchAddressResult] = kwargs.pop("cls", None)

        _request = build_search_search_point_of_interest_request(
            format=format,
            query=query,
            is_type_ahead=is_type_ahead,
            top=top,
            skip=skip,
            category_filter=category_filter,
            country_filter=country_filter,
            lat=lat,
            lon=lon,
            radius_in_meters=radius_in_meters,
            top_left=top_left,
            btm_right=btm_right,
            language=language,
            extended_postal_codes_for=extended_postal_codes_for,
            brand_filter=brand_filter,
            electric_vehicle_connector_filter=electric_vehicle_connector_filter,
            localized_map_view=localized_map_view,
            operating_hours=operating_hours,
            client_id=self._config.client_id,
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = False
        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                response.read()  # Load the body in memory and close the socket
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize.failsafe_deserialize(_models.ErrorResponse, pipeline_response)
            raise HttpResponseError(response=response, model=error)

        deserialized = self._deserialize("SearchAddressResult", pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore

    @distributed_trace
    def search_nearby_point_of_interest(
        self,
        format: Union[str, _models.ResponseFormat] = "json",
        *,
        lat: float,
        lon: float,
        top: Optional[int] = None,
        skip: Optional[int] = None,
        category_filter: Optional[List[int]] = None,
        country_filter: Optional[List[str]] = None,
        radius_in_meters: Optional[int] = None,
        language: Optional[str] = None,
        extended_postal_codes_for: Optional[List[Union[str, _models.SearchIndexes]]] = None,
        brand_filter: Optional[List[str]] = None,
        electric_vehicle_connector_filter: Optional[List[Union[str, _models.ElectricVehicleConnector]]] = None,
        localized_map_view: Optional[Union[str, _models.LocalizedMapView]] = None,
        **kwargs: Any
    ) -> _models.SearchAddressResult:
        """**Nearby Search**

        **Applies to:** see `pricing tiers <https://aka.ms/AzureMapsPricingTier>`_.

        If you have a use case for only retrieving POI results around a specific location, the nearby
        search method may be the right choice. This endpoint will only return POI results, and does not
        take in a search query parameter.

        :param format: Desired format of the response. Value can be either *json* or *xml*. Known
         values are: "json" and "xml". Default value is "json".
        :type format: str or ~azure.maps.search.models.ResponseFormat
        :keyword lat: Latitude where results should be biased. E.g. 37.337. Required.
        :paramtype lat: float
        :keyword lon: Longitude where results should be biased. E.g. -121.89. Required.
        :paramtype lon: float
        :keyword top: Maximum number of responses that will be returned. Default: 10, minimum: 1 and
         maximum: 100. Default value is None.
        :paramtype top: int
        :keyword skip: Starting offset of the returned results within the full result set. Default: 0.
         Default value is None.
        :paramtype skip: int
        :keyword category_filter: A comma-separated list of category set IDs which could be used to
         restrict the result to specific Points of Interest categories. ID order does not matter.
         Maximum number of ``categorySet`` values supported per request is 10. When multiple category
         identifiers are provided, only POIs that belong to (at least) one of the categories from the
         provided list will be returned. The list of supported categories can be discovered using `POI
         Categories API <https://aka.ms/AzureMapsPOICategoryTree>`_. Usage examples:


         *
           **categorySet=7315** (Search Points of Interest from category Restaurant)

         *
           **categorySet=7315025,7315017** (Search Points of Interest of category either Italian or
         French Restaurant). Default value is None.
        :paramtype category_filter: list[int]
        :keyword country_filter: Comma separated string of country/region codes, e.g. FR,ES. This will
         limit the search to the specified countries/regions. Default value is None.
        :paramtype country_filter: list[str]
        :keyword radius_in_meters: The radius in meters to for the results to be constrained to the
         defined area, Min value is 1, Max Value is 50000. Default value is None.
        :paramtype radius_in_meters: int
        :keyword language: Language in which search results should be returned. Should be one of
         supported IETF language tags, case insensitive. When data in specified language is not
         available for a specific field, default language is used.

         Please refer to `Supported Languages
         <https://docs.microsoft.com/azure/azure-maps/supported-languages>`_ for details. Default value
         is None.
        :paramtype language: str
        :keyword extended_postal_codes_for: Indexes for which extended postal codes should be included
         in the results.

         Available indexes are:

          **Addr** = Address ranges

          **Geo** = Geographies

          **PAD** = Point Addresses

          **POI** = Points of Interest

          **Str** = Streets

          **XStr** = Cross Streets (intersections)

         Value should be a comma separated list of index types (in any order) or **None** for no
         indexes.

         By default extended postal codes are included for all indexes except Geo. Extended postal code
         lists for geographies can be quite long so they have to be explicitly requested when needed.

         Usage examples:

          extendedPostalCodesFor=POI

          extendedPostalCodesFor=PAD,Addr,POI

          extendedPostalCodesFor=None

         Extended postal code is returned as an **extendedPostalCode** property of an address.
         Availability is region-dependent. Default value is None.
        :paramtype extended_postal_codes_for: list[str or ~azure.maps.search.models.SearchIndexes]
        :keyword brand_filter: A comma-separated list of brand names which could be used to restrict
         the result to specific brands. Item order does not matter. When multiple brands are provided,
         only results that belong to (at least) one of the provided list will be returned. Brands that
         contain a "," in their name should be put into quotes.

         Usage examples:

          brandSet=Foo

          brandSet=Foo,Bar

          brandSet="A,B,C Comma",Bar. Default value is None.
        :paramtype brand_filter: list[str]
        :keyword electric_vehicle_connector_filter: A comma-separated list of connector types which
         could be used to restrict the result to Electric Vehicle Station supporting specific connector
         types. Item order does not matter. When multiple connector types are provided, only results
         that belong to (at least) one of the provided list will be returned.

         Available connector types are:


         * ``StandardHouseholdCountrySpecific`` - These are the standard household connectors for a
         certain region. They are all AC single phase and the standard Voltage and standard Amperage.
         See also: `Plug & socket types - World Standards
         <https://www.worldstandards.eu/electricity/plugs-and-sockets>`_.
         * ``IEC62196Type1`` - Type 1 connector as defined in the IEC 62196-2 standard. Also called
         Yazaki after the original manufacturer or SAE J1772 after the standard that first published it.
         Mostly used in combination with 120V single phase or up to 240V single phase infrastructure.
         * ``IEC62196Type1CCS`` - Type 1 based combo connector as defined in the IEC 62196-3 standard.
         The connector is based on the Type 1 connector – as defined in the IEC 62196-2 standard – with
         two additional direct current (DC) contacts to allow DC fast charging.
         * ``IEC62196Type2CableAttached`` - Type 2 connector as defined in the IEC 62196-2 standard.
         Provided as a cable and plug attached to the charging point.
         * ``IEC62196Type2Outlet`` - Type 2 connector as defined in the IEC 62196-2 standard. Provided
         as a socket set into the charging point.
         * ``IEC62196Type2CCS`` - Type 2 based combo connector as defined in the IEC 62196-3 standard.
         The connector is based on the Type 2 connector – as defined in the IEC 62196-2 standard – with
         two additional direct current (DC) contacts to allow DC fast charging.
         * ``IEC62196Type3`` - Type 3 connector as defined in the IEC 62196-2 standard. Also called
         Scame after the original manufacturer. Mostly used in combination with up to 240V single phase
         or up to 420V three phase infrastructure.
         * ``Chademo`` - CHAdeMO connector named after an association formed by the Tokyo Electric
         Power Company and industrial partners. Because of this is is also known as the TEPCO's
         connector. It supports fast DC charging.
         * ``IEC60309AC1PhaseBlue`` - Industrial Blue connector is a connector defined in the IEC 60309
         standard. It is sometime referred to as by some combination of the standard, the color and the
         fact that is a single phase connector. The connector usually has the "P+N+E, 6h" configuration.
         * ``IEC60309DCWhite`` - Industrial White connector is a DC connector defined in the IEC 60309
         standard.
         * ``Tesla`` - The Tesla connector is the regionally specific Tesla Supercharger connector.
         I.e. it refers to either Tesla's proprietary connector, sometimes referred to as Tesla Port
         mostly limited to North America or the modified Type 2 (DC over Type 2) in Europe.

         Usage examples:

          connectorSet=IEC62196Type2CableAttached
          connectorSet=IEC62196Type2Outlet,IEC62196Type2CableAttached. Default value is None.
        :paramtype electric_vehicle_connector_filter: list[str or
         ~azure.maps.search.models.ElectricVehicleConnector]
        :keyword localized_map_view: The View parameter (also called the "user region" parameter)
         allows you to show the correct maps for a certain country/region for geopolitically disputed
         regions. Different countries/regions have different views of such regions, and the View
         parameter allows your application to comply with the view required by the country/region your
         application will be serving. By default, the View parameter is set to “Unified” even if you
         haven’t defined it in  the request. It is your responsibility to determine the location of your
         users, and then set the View parameter correctly for that location. Alternatively, you have the
         option to set ‘View=Auto’, which will return the map data based on the IP  address of the
         request. The View parameter in Azure Maps must be used in compliance with applicable laws,
         including those  regarding mapping, of the country/region where maps, images and other data and
         third party content that you are authorized to  access via Azure Maps is made available.
         Example: view=IN.

         Please refer to `Supported Views <https://aka.ms/AzureMapsLocalizationViews>`_ for details and
         to see the available Views. Known values are: "AE", "AR", "BH", "IN", "IQ", "JO", "KW", "LB",
         "MA", "OM", "PK", "PS", "QA", "SA", "SY", "YE", "Auto", and "Unified". Default value is None.
        :paramtype localized_map_view: str or ~azure.maps.search.models.LocalizedMapView
        :return: SearchAddressResult
        :rtype: ~azure.maps.search.models.SearchAddressResult
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[_models.SearchAddressResult] = kwargs.pop("cls", None)

        _request = build_search_search_nearby_point_of_interest_request(
            format=format,
            lat=lat,
            lon=lon,
            top=top,
            skip=skip,
            category_filter=category_filter,
            country_filter=country_filter,
            radius_in_meters=radius_in_meters,
            language=language,
            extended_postal_codes_for=extended_postal_codes_for,
            brand_filter=brand_filter,
            electric_vehicle_connector_filter=electric_vehicle_connector_filter,
            localized_map_view=localized_map_view,
            client_id=self._config.client_id,
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = False
        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                response.read()  # Load the body in memory and close the socket
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize.failsafe_deserialize(_models.ErrorResponse, pipeline_response)
            raise HttpResponseError(response=response, model=error)

        deserialized = self._deserialize("SearchAddressResult", pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore

    @distributed_trace
    def search_point_of_interest_category(
        self,
        format: Union[str, _models.ResponseFormat] = "json",
        *,
        query: str,
        is_type_ahead: Optional[bool] = None,
        top: Optional[int] = None,
        skip: Optional[int] = None,
        category_filter: Optional[List[int]] = None,
        country_filter: Optional[List[str]] = None,
        lat: Optional[float] = None,
        lon: Optional[float] = None,
        radius_in_meters: Optional[int] = None,
        top_left: Optional[str] = None,
        btm_right: Optional[str] = None,
        language: Optional[str] = None,
        extended_postal_codes_for: Optional[List[Union[str, _models.SearchIndexes]]] = None,
        brand_filter: Optional[List[str]] = None,
        electric_vehicle_connector_filter: Optional[List[Union[str, _models.ElectricVehicleConnector]]] = None,
        localized_map_view: Optional[Union[str, _models.LocalizedMapView]] = None,
        operating_hours: Optional[Union[str, _models.OperatingHoursRange]] = None,
        **kwargs: Any
    ) -> _models.SearchAddressResult:
        """**Get POI by Category**

        **Applies to:** see `pricing tiers <https://aka.ms/AzureMapsPricingTier>`_.

        Points of Interest (POI) Category Search allows you to request POI results from given category.
        Search allows to query POIs from one category at a time.  Endpoint will only return POI results
        which are categorized as specified.  Response includes POI details such as address, coordinate
        location and classification.

        :param format: Desired format of the response. Value can be either *json* or *xml*. Known
         values are: "json" and "xml". Default value is "json".
        :type format: str or ~azure.maps.search.models.ResponseFormat
        :keyword query: The POI category to search for (e.g., "AIRPORT", "RESTAURANT"), must be
         properly URL encoded. Supported main categories can be requested by calling `Get Search POI
         Category Tree API <https://aka.ms/AzureMapsPOICategoryTree>`_. For a list of available
         categories, see `Azure Maps supported categories
         </azure/azure-maps/supported-search-categories>`_. We recommend to use POI Search Category Tree
         API to request the supported categories. Required.
        :paramtype query: str
        :keyword is_type_ahead: Boolean. If the typeahead flag is set, the query will be interpreted as
         a partial input and the search will enter predictive mode. Default value is None.
        :paramtype is_type_ahead: bool
        :keyword top: Maximum number of responses that will be returned. Default: 10, minimum: 1 and
         maximum: 100. Default value is None.
        :paramtype top: int
        :keyword skip: Starting offset of the returned results within the full result set. Default: 0.
         Default value is None.
        :paramtype skip: int
        :keyword category_filter: A comma-separated list of category set IDs which could be used to
         restrict the result to specific Points of Interest categories. ID order does not matter.
         Maximum number of ``categorySet`` values supported per request is 10. When multiple category
         identifiers are provided, only POIs that belong to (at least) one of the categories from the
         provided list will be returned. The list of supported categories can be discovered using `POI
         Categories API <https://aka.ms/AzureMapsPOICategoryTree>`_. Usage examples:


         *
           **categorySet=7315** (Search Points of Interest from category Restaurant)

         *
           **categorySet=7315025,7315017** (Search Points of Interest of category either Italian or
         French Restaurant). Default value is None.
        :paramtype category_filter: list[int]
        :keyword country_filter: Comma separated string of country/region codes, e.g. FR,ES. This will
         limit the search to the specified countries/regions. Default value is None.
        :paramtype country_filter: list[str]
        :keyword lat: Latitude where results should be biased. E.g. 37.337. Default value is None.
        :paramtype lat: float
        :keyword lon: Longitude where results should be biased. E.g. -121.89. Default value is None.
        :paramtype lon: float
        :keyword radius_in_meters: The radius in meters to for the results to be constrained to the
         defined area. Default value is None.
        :paramtype radius_in_meters: int
        :keyword top_left: Top left position of the bounding box. E.g. 37.553,-122.453. Default value
         is None.
        :paramtype top_left: str
        :keyword btm_right: Bottom right position of the bounding box. E.g. 37.553,-122.453. Default
         value is None.
        :paramtype btm_right: str
        :keyword language: Language in which search results should be returned. Should be one of
         supported IETF language tags, case insensitive. When data in specified language is not
         available for a specific field, default language is used.

         Please refer to `Supported Languages
         <https://docs.microsoft.com/azure/azure-maps/supported-languages>`_ for details. Default value
         is None.
        :paramtype language: str
        :keyword extended_postal_codes_for: Indexes for which extended postal codes should be included
         in the results.

         Available indexes are:

          **Addr** = Address ranges

          **Geo** = Geographies

          **PAD** = Point Addresses

          **POI** = Points of Interest

          **Str** = Streets

          **XStr** = Cross Streets (intersections)

         Value should be a comma separated list of index types (in any order) or **None** for no
         indexes.

         By default extended postal codes are included for all indexes except Geo. Extended postal code
         lists for geographies can be quite long so they have to be explicitly requested when needed.

         Usage examples:

          extendedPostalCodesFor=POI

          extendedPostalCodesFor=PAD,Addr,POI

          extendedPostalCodesFor=None

         Extended postal code is returned as an **extendedPostalCode** property of an address.
         Availability is region-dependent. Default value is None.
        :paramtype extended_postal_codes_for: list[str or ~azure.maps.search.models.SearchIndexes]
        :keyword brand_filter: A comma-separated list of brand names which could be used to restrict
         the result to specific brands. Item order does not matter. When multiple brands are provided,
         only results that belong to (at least) one of the provided list will be returned. Brands that
         contain a "," in their name should be put into quotes.

         Usage examples:

          brandSet=Foo

          brandSet=Foo,Bar

          brandSet="A,B,C Comma",Bar. Default value is None.
        :paramtype brand_filter: list[str]
        :keyword electric_vehicle_connector_filter: A comma-separated list of connector types which
         could be used to restrict the result to Electric Vehicle Station supporting specific connector
         types. Item order does not matter. When multiple connector types are provided, only results
         that belong to (at least) one of the provided list will be returned.

         Available connector types are:


         * ``StandardHouseholdCountrySpecific`` - These are the standard household connectors for a
         certain region. They are all AC single phase and the standard Voltage and standard Amperage.
         See also: `Plug & socket types - World Standards
         <https://www.worldstandards.eu/electricity/plugs-and-sockets>`_.
         * ``IEC62196Type1`` - Type 1 connector as defined in the IEC 62196-2 standard. Also called
         Yazaki after the original manufacturer or SAE J1772 after the standard that first published it.
         Mostly used in combination with 120V single phase or up to 240V single phase infrastructure.
         * ``IEC62196Type1CCS`` - Type 1 based combo connector as defined in the IEC 62196-3 standard.
         The connector is based on the Type 1 connector – as defined in the IEC 62196-2 standard – with
         two additional direct current (DC) contacts to allow DC fast charging.
         * ``IEC62196Type2CableAttached`` - Type 2 connector as defined in the IEC 62196-2 standard.
         Provided as a cable and plug attached to the charging point.
         * ``IEC62196Type2Outlet`` - Type 2 connector as defined in the IEC 62196-2 standard. Provided
         as a socket set into the charging point.
         * ``IEC62196Type2CCS`` - Type 2 based combo connector as defined in the IEC 62196-3 standard.
         The connector is based on the Type 2 connector – as defined in the IEC 62196-2 standard – with
         two additional direct current (DC) contacts to allow DC fast charging.
         * ``IEC62196Type3`` - Type 3 connector as defined in the IEC 62196-2 standard. Also called
         Scame after the original manufacturer. Mostly used in combination with up to 240V single phase
         or up to 420V three phase infrastructure.
         * ``Chademo`` - CHAdeMO connector named after an association formed by the Tokyo Electric
         Power Company and industrial partners. Because of this is is also known as the TEPCO's
         connector. It supports fast DC charging.
         * ``IEC60309AC1PhaseBlue`` - Industrial Blue connector is a connector defined in the IEC 60309
         standard. It is sometime referred to as by some combination of the standard, the color and the
         fact that is a single phase connector. The connector usually has the "P+N+E, 6h" configuration.
         * ``IEC60309DCWhite`` - Industrial White connector is a DC connector defined in the IEC 60309
         standard.
         * ``Tesla`` - The Tesla connector is the regionally specific Tesla Supercharger connector.
         I.e. it refers to either Tesla's proprietary connector, sometimes referred to as Tesla Port
         mostly limited to North America or the modified Type 2 (DC over Type 2) in Europe.

         Usage examples:

          connectorSet=IEC62196Type2CableAttached
          connectorSet=IEC62196Type2Outlet,IEC62196Type2CableAttached. Default value is None.
        :paramtype electric_vehicle_connector_filter: list[str or
         ~azure.maps.search.models.ElectricVehicleConnector]
        :keyword localized_map_view: The View parameter (also called the "user region" parameter)
         allows you to show the correct maps for a certain country/region for geopolitically disputed
         regions. Different countries/regions have different views of such regions, and the View
         parameter allows your application to comply with the view required by the country/region your
         application will be serving. By default, the View parameter is set to “Unified” even if you
         haven’t defined it in  the request. It is your responsibility to determine the location of your
         users, and then set the View parameter correctly for that location. Alternatively, you have the
         option to set ‘View=Auto’, which will return the map data based on the IP  address of the
         request. The View parameter in Azure Maps must be used in compliance with applicable laws,
         including those  regarding mapping, of the country/region where maps, images and other data and
         third party content that you are authorized to  access via Azure Maps is made available.
         Example: view=IN.

         Please refer to `Supported Views <https://aka.ms/AzureMapsLocalizationViews>`_ for details and
         to see the available Views. Known values are: "AE", "AR", "BH", "IN", "IQ", "JO", "KW", "LB",
         "MA", "OM", "PK", "PS", "QA", "SA", "SY", "YE", "Auto", and "Unified". Default value is None.
        :paramtype localized_map_view: str or ~azure.maps.search.models.LocalizedMapView
        :keyword operating_hours: Hours of operation for a POI (Points of Interest). The availability
         of hours of operation will vary based on the data available. If not passed, then no opening
         hours information will be returned.
         Supported value: nextSevenDays. "nextSevenDays" Default value is None.
        :paramtype operating_hours: str or ~azure.maps.search.models.OperatingHoursRange
        :return: SearchAddressResult
        :rtype: ~azure.maps.search.models.SearchAddressResult
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[_models.SearchAddressResult] = kwargs.pop("cls", None)

        _request = build_search_search_point_of_interest_category_request(
            format=format,
            query=query,
            is_type_ahead=is_type_ahead,
            top=top,
            skip=skip,
            category_filter=category_filter,
            country_filter=country_filter,
            lat=lat,
            lon=lon,
            radius_in_meters=radius_in_meters,
            top_left=top_left,
            btm_right=btm_right,
            language=language,
            extended_postal_codes_for=extended_postal_codes_for,
            brand_filter=brand_filter,
            electric_vehicle_connector_filter=electric_vehicle_connector_filter,
            localized_map_view=localized_map_view,
            operating_hours=operating_hours,
            client_id=self._config.client_id,
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = False
        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                response.read()  # Load the body in memory and close the socket
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize.failsafe_deserialize(_models.ErrorResponse, pipeline_response)
            raise HttpResponseError(response=response, model=error)

        deserialized = self._deserialize("SearchAddressResult", pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore

    @distributed_trace
    def get_point_of_interest_category_tree(
        self, format: Union[str, _models.JsonFormat] = "json", *, language: Optional[str] = None, **kwargs: Any
    ) -> _models.PointOfInterestCategoryTreeResult:
        """**Get POI Category Tree**

        **Applies to:** see `pricing tiers <https://aka.ms/AzureMapsPricingTier>`_.

        POI Category API provides a full list of supported Points of Interest (POI) categories and
        subcategories together with their translations and synonyms. The returned content can be used
        to provide more meaningful results through other Search Service APIs, like `Get Search POI
        </rest/api/maps/search/get-search-poi?view=rest-maps-1.0>`_.

        :param format: Desired format of the response. Only ``json`` format is supported. "json"
         Default value is "json".
        :type format: str or ~azure.maps.search.models.JsonFormat
        :keyword language: Language in which search results should be returned. Should be one of
         supported IETF language tags, except NGT and NGT-Latn. Language tag is case insensitive. When
         data in specified language is not available for a specific field, default language is used
         (English).

         Please refer to `Supported Languages </azure/azure-maps/supported-languages>`_ for details.
         Default value is None.
        :paramtype language: str
        :return: PointOfInterestCategoryTreeResult
        :rtype: ~azure.maps.search.models.PointOfInterestCategoryTreeResult
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[_models.PointOfInterestCategoryTreeResult] = kwargs.pop("cls", None)

        _request = build_search_get_point_of_interest_category_tree_request(
            format=format,
            language=language,
            client_id=self._config.client_id,
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = False
        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                response.read()  # Load the body in memory and close the socket
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize.failsafe_deserialize(_models.ErrorResponse, pipeline_response)
            raise HttpResponseError(response=response, model=error)

        deserialized = self._deserialize("PointOfInterestCategoryTreeResult", pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore

    @distributed_trace
    def search_address(
        self,
        format: Union[str, _models.ResponseFormat] = "json",
        *,
        query: str,
        is_type_ahead: Optional[bool] = None,
        top: Optional[int] = None,
        skip: Optional[int] = None,
        country_filter: Optional[List[str]] = None,
        lat: Optional[float] = None,
        lon: Optional[float] = None,
        radius_in_meters: Optional[int] = None,
        top_left: Optional[str] = None,
        btm_right: Optional[str] = None,
        language: Optional[str] = None,
        extended_postal_codes_for: Optional[List[Union[str, _models.SearchIndexes]]] = None,
        entity_type: Optional[Union[str, _models.GeographicEntityType]] = None,
        localized_map_view: Optional[Union[str, _models.LocalizedMapView]] = None,
        **kwargs: Any
    ) -> _models.SearchAddressResult:
        """**Address Geocoding**

        **Applies to:** see `pricing tiers <https://aka.ms/AzureMapsPricingTier>`_.

        In many cases, the complete search service might be too much, for instance if you are only
        interested in traditional geocoding. Search can also be accessed for address look up
        exclusively. The geocoding is performed by hitting the geocode endpoint with just the address
        or partial address in question. The geocoding search index will be queried for everything above
        the street level data. No POIs will be returned. Note that the geocoder is very tolerant of
        typos and incomplete addresses. It will also handle everything from exact street addresses or
        street or intersections as well as higher level geographies such as city centers, counties,
        states etc.

        :param format: Desired format of the response. Value can be either *json* or *xml*. Known
         values are: "json" and "xml". Default value is "json".
        :type format: str or ~azure.maps.search.models.ResponseFormat
        :keyword query: The address to search for (e.g., "1 Microsoft way, Redmond, WA"), must be
         properly URL encoded. Required.
        :paramtype query: str
        :keyword is_type_ahead: Boolean. If the typeahead flag is set, the query will be interpreted as
         a partial input and the search will enter predictive mode. Default value is None.
        :paramtype is_type_ahead: bool
        :keyword top: Maximum number of responses that will be returned. Default: 10, minimum: 1 and
         maximum: 100. Default value is None.
        :paramtype top: int
        :keyword skip: Starting offset of the returned results within the full result set. Default: 0.
         Default value is None.
        :paramtype skip: int
        :keyword country_filter: Comma separated string of country/region codes, e.g. FR,ES. This will
         limit the search to the specified countries/regions. Default value is None.
        :paramtype country_filter: list[str]
        :keyword lat: Latitude where results should be biased. E.g. 37.337. Default value is None.
        :paramtype lat: float
        :keyword lon: Longitude where results should be biased. E.g. -121.89. Default value is None.
        :paramtype lon: float
        :keyword radius_in_meters: The radius in meters to for the results to be constrained to the
         defined area. Default value is None.
        :paramtype radius_in_meters: int
        :keyword top_left: Top left position of the bounding box. E.g. 37.553,-122.453. Default value
         is None.
        :paramtype top_left: str
        :keyword btm_right: Bottom right position of the bounding box. E.g. 37.553,-122.453. Default
         value is None.
        :paramtype btm_right: str
        :keyword language: Language in which search results should be returned. Should be one of
         supported IETF language tags, case insensitive. When data in specified language is not
         available for a specific field, default language is used.

         Please refer to `Supported Languages
         <https://docs.microsoft.com/azure/azure-maps/supported-languages>`_ for details. Default value
         is None.
        :paramtype language: str
        :keyword extended_postal_codes_for: Indexes for which extended postal codes should be included
         in the results.

         Available indexes are:

          **Addr** = Address ranges

          **Geo** = Geographies

          **PAD** = Point Addresses

          **POI** = Points of Interest

          **Str** = Streets

          **XStr** = Cross Streets (intersections)

         Value should be a comma separated list of index types (in any order) or **None** for no
         indexes.

         By default extended postal codes are included for all indexes except Geo. Extended postal code
         lists for geographies can be quite long so they have to be explicitly requested when needed.

         Usage examples:

          extendedPostalCodesFor=POI

          extendedPostalCodesFor=PAD,Addr,POI

          extendedPostalCodesFor=None

         Extended postal code is returned as an **extendedPostalCode** property of an address.
         Availability is region-dependent. Default value is None.
        :paramtype extended_postal_codes_for: list[str or ~azure.maps.search.models.SearchIndexes]
        :keyword entity_type: Specifies the level of filtering performed on geographies. Narrows the
         search for specified geography entity types, e.g. return only municipality. The resulting
         response will contain the geography ID as well as the entity type matched. If you provide more
         than one entity as a comma separated list, endpoint will return the 'smallest entity
         available'. Returned Geometry ID can be used to get the geometry of that geography via `Get
         Search Polygon </rest/api/maps/search/get-search-polygon?view=rest-maps-1.0>`_ API. The
         following parameters are ignored when entityType is set:


         * heading
         * number
         * returnRoadUse
         * returnSpeedLimit
         * roadUse
         * returnMatchType. Known values are: "Country", "CountrySubdivision",
         "CountrySecondarySubdivision", "CountryTertiarySubdivision", "Municipality",
         "MunicipalitySubdivision", "Neighbourhood", and "PostalCodeArea". Default value is None.
        :paramtype entity_type: str or ~azure.maps.search.models.GeographicEntityType
        :keyword localized_map_view: The View parameter (also called the "user region" parameter)
         allows you to show the correct maps for a certain country/region for geopolitically disputed
         regions. Different countries/regions have different views of such regions, and the View
         parameter allows your application to comply with the view required by the country/region your
         application will be serving. By default, the View parameter is set to “Unified” even if you
         haven’t defined it in  the request. It is your responsibility to determine the location of your
         users, and then set the View parameter correctly for that location. Alternatively, you have the
         option to set ‘View=Auto’, which will return the map data based on the IP  address of the
         request. The View parameter in Azure Maps must be used in compliance with applicable laws,
         including those  regarding mapping, of the country/region where maps, images and other data and
         third party content that you are authorized to  access via Azure Maps is made available.
         Example: view=IN.

         Please refer to `Supported Views <https://aka.ms/AzureMapsLocalizationViews>`_ for details and
         to see the available Views. Known values are: "AE", "AR", "BH", "IN", "IQ", "JO", "KW", "LB",
         "MA", "OM", "PK", "PS", "QA", "SA", "SY", "YE", "Auto", and "Unified". Default value is None.
        :paramtype localized_map_view: str or ~azure.maps.search.models.LocalizedMapView
        :return: SearchAddressResult
        :rtype: ~azure.maps.search.models.SearchAddressResult
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[_models.SearchAddressResult] = kwargs.pop("cls", None)

        _request = build_search_search_address_request(
            format=format,
            query=query,
            is_type_ahead=is_type_ahead,
            top=top,
            skip=skip,
            country_filter=country_filter,
            lat=lat,
            lon=lon,
            radius_in_meters=radius_in_meters,
            top_left=top_left,
            btm_right=btm_right,
            language=language,
            extended_postal_codes_for=extended_postal_codes_for,
            entity_type=entity_type,
            localized_map_view=localized_map_view,
            client_id=self._config.client_id,
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = False
        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                response.read()  # Load the body in memory and close the socket
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize.failsafe_deserialize(_models.ErrorResponse, pipeline_response)
            raise HttpResponseError(response=response, model=error)

        deserialized = self._deserialize("SearchAddressResult", pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore

    @distributed_trace
    def reverse_search_address(
        self,
        format: Union[str, _models.ResponseFormat] = "json",
        *,
        query: List[float],
        language: Optional[str] = None,
        include_speed_limit: Optional[bool] = None,
        heading: Optional[int] = None,
        radius_in_meters: Optional[int] = None,
        street_number: Optional[str] = None,
        include_road_use: Optional[bool] = None,
        road_use: Optional[List[Union[str, _models.RoadUseType]]] = None,
        allow_freeform_newline: Optional[bool] = None,
        include_match_type: Optional[bool] = None,
        entity_type: Optional[Union[str, _models.GeographicEntityType]] = None,
        localized_map_view: Optional[Union[str, _models.LocalizedMapView]] = None,
        **kwargs: Any
    ) -> _models.ReverseSearchAddressResult:
        """**Reverse Geocode to an Address**

        **Applies to:** see `pricing tiers <https://aka.ms/AzureMapsPricingTier>`_.

        There may be times when you need to translate a  coordinate (example: 37.786505, -122.3862)
        into a human understandable street address. Most often  this is needed in tracking applications
        where you  receive a GPS feed from the device or asset and  wish to know what address where the
        coordinate is  located. This endpoint will return address  information for a given coordinate.

        :param format: Desired format of the response. Value can be either *json* or *xml*. Known
         values are: "json" and "xml". Default value is "json".
        :type format: str or ~azure.maps.search.models.ResponseFormat
        :keyword query: The applicable query specified as a comma separated string composed by latitude
         followed by longitude e.g. "47.641268,-122.125679". Required.
        :paramtype query: list[float]
        :keyword language: Language in which search results should be returned. Should be one of
         supported IETF language tags, case insensitive. When data in specified language is not
         available for a specific field, default language is used.

         Please refer to `Supported Languages
         <https://docs.microsoft.com/azure/azure-maps/supported-languages>`_ for details. Default value
         is None.
        :paramtype language: str
        :keyword include_speed_limit: Boolean. To enable return of the posted speed limit. Default
         value is None.
        :paramtype include_speed_limit: bool
        :keyword heading: The directional heading of the vehicle in degrees, for travel along a segment
         of roadway. 0 is North, 90 is East and so on, values range from -360 to 360. The precision can
         include upto one decimal place. Default value is None.
        :paramtype heading: int
        :keyword radius_in_meters: The radius in meters to for the results to be constrained to the
         defined area. Default value is None.
        :paramtype radius_in_meters: int
        :keyword street_number: Street number as a string. If a number is sent in along with the
         request, the response may include the side of the street (Left/Right) and also an offset
         position for that number. Default value is None.
        :paramtype street_number: str
        :keyword include_road_use: Boolean. To enable return of the road use array for reverse geocodes
         at street level. Default value is None.
        :paramtype include_road_use: bool
        :keyword road_use: To restrict reverse geocodes to a certain type of road use. The road use
         array for reverse geocodes can be one or more of LimitedAccess, Arterial, Terminal, Ramp,
         Rotary, LocalStreet. Default value is None.
        :paramtype road_use: list[str or ~azure.maps.search.models.RoadUseType]
        :keyword allow_freeform_newline: Format of newlines in the formatted address.

         If true, the address will contain newlines.
         If false, newlines will be converted to commas. Default value is None.
        :paramtype allow_freeform_newline: bool
        :keyword include_match_type: Include information on the type of match the geocoder achieved in
         the response. Default value is None.
        :paramtype include_match_type: bool
        :keyword entity_type: Specifies the level of filtering performed on geographies. Narrows the
         search for specified geography entity types, e.g. return only municipality. The resulting
         response will contain the geography ID as well as the entity type matched. If you provide more
         than one entity as a comma separated list, endpoint will return the 'smallest entity
         available'. Returned Geometry ID can be used to get the geometry of that geography via `Get
         Search Polygon </rest/api/maps/search/get-search-polygon?view=rest-maps-1.0>`_ API. The
         following parameters are ignored when entityType is set:


         * heading
         * number
         * returnRoadUse
         * returnSpeedLimit
         * roadUse
         * returnMatchType. Known values are: "Country", "CountrySubdivision",
         "CountrySecondarySubdivision", "CountryTertiarySubdivision", "Municipality",
         "MunicipalitySubdivision", "Neighbourhood", and "PostalCodeArea". Default value is None.
        :paramtype entity_type: str or ~azure.maps.search.models.GeographicEntityType
        :keyword localized_map_view: The View parameter (also called the "user region" parameter)
         allows you to show the correct maps for a certain country/region for geopolitically disputed
         regions. Different countries/regions have different views of such regions, and the View
         parameter allows your application to comply with the view required by the country/region your
         application will be serving. By default, the View parameter is set to “Unified” even if you
         haven’t defined it in  the request. It is your responsibility to determine the location of your
         users, and then set the View parameter correctly for that location. Alternatively, you have the
         option to set ‘View=Auto’, which will return the map data based on the IP  address of the
         request. The View parameter in Azure Maps must be used in compliance with applicable laws,
         including those  regarding mapping, of the country/region where maps, images and other data and
         third party content that you are authorized to  access via Azure Maps is made available.
         Example: view=IN.

         Please refer to `Supported Views <https://aka.ms/AzureMapsLocalizationViews>`_ for details and
         to see the available Views. Known values are: "AE", "AR", "BH", "IN", "IQ", "JO", "KW", "LB",
         "MA", "OM", "PK", "PS", "QA", "SA", "SY", "YE", "Auto", and "Unified". Default value is None.
        :paramtype localized_map_view: str or ~azure.maps.search.models.LocalizedMapView
        :return: ReverseSearchAddressResult
        :rtype: ~azure.maps.search.models.ReverseSearchAddressResult
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[_models.ReverseSearchAddressResult] = kwargs.pop("cls", None)

        _request = build_search_reverse_search_address_request(
            format=format,
            query=query,
            language=language,
            include_speed_limit=include_speed_limit,
            heading=heading,
            radius_in_meters=radius_in_meters,
            street_number=street_number,
            include_road_use=include_road_use,
            road_use=road_use,
            allow_freeform_newline=allow_freeform_newline,
            include_match_type=include_match_type,
            entity_type=entity_type,
            localized_map_view=localized_map_view,
            client_id=self._config.client_id,
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = False
        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                response.read()  # Load the body in memory and close the socket
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize.failsafe_deserialize(_models.ErrorResponse, pipeline_response)
            raise HttpResponseError(response=response, model=error)

        deserialized = self._deserialize("ReverseSearchAddressResult", pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore

    @distributed_trace
    def reverse_search_cross_street_address(
        self,
        format: Union[str, _models.ResponseFormat] = "json",
        *,
        query: List[float],
        top: Optional[int] = None,
        heading: Optional[int] = None,
        radius_in_meters: Optional[int] = None,
        language: Optional[str] = None,
        localized_map_view: Optional[Union[str, _models.LocalizedMapView]] = None,
        **kwargs: Any
    ) -> _models.ReverseSearchCrossStreetAddressResult:
        """**Reverse Geocode to a Cross Street**

        **Applies to:** see `pricing tiers <https://aka.ms/AzureMapsPricingTier>`_.

        There may be times when you need to translate a  coordinate (example: 37.786505, -122.3862)
        into a human understandable cross street. Most often this  is needed in tracking applications
        where you  receive a GPS feed from the device or asset and wish to know what address where the
        coordinate is  located.
        This endpoint will return cross street information  for a given coordinate.

        :param format: Desired format of the response. Value can be either *json* or *xml*. Known
         values are: "json" and "xml". Default value is "json".
        :type format: str or ~azure.maps.search.models.ResponseFormat
        :keyword query: The applicable query specified as a comma separated string composed by latitude
         followed by longitude e.g. "47.641268,-122.125679". Required.
        :paramtype query: list[float]
        :keyword top: Maximum number of responses that will be returned. Default: 10, minimum: 1 and
         maximum: 100. Default value is None.
        :paramtype top: int
        :keyword heading: The directional heading of the vehicle in degrees, for travel along a segment
         of roadway. 0 is North, 90 is East and so on, values range from -360 to 360. The precision can
         include upto one decimal place. Default value is None.
        :paramtype heading: int
        :keyword radius_in_meters: The radius in meters to for the results to be constrained to the
         defined area. Default value is None.
        :paramtype radius_in_meters: int
        :keyword language: Language in which search results should be returned. Should be one of
         supported IETF language tags, case insensitive. When data in specified language is not
         available for a specific field, default language is used.

         Please refer to `Supported Languages
         <https://docs.microsoft.com/azure/azure-maps/supported-languages>`_ for details. Default value
         is None.
        :paramtype language: str
        :keyword localized_map_view: The View parameter (also called the "user region" parameter)
         allows you to show the correct maps for a certain country/region for geopolitically disputed
         regions. Different countries/regions have different views of such regions, and the View
         parameter allows your application to comply with the view required by the country/region your
         application will be serving. By default, the View parameter is set to “Unified” even if you
         haven’t defined it in  the request. It is your responsibility to determine the location of your
         users, and then set the View parameter correctly for that location. Alternatively, you have the
         option to set ‘View=Auto’, which will return the map data based on the IP  address of the
         request. The View parameter in Azure Maps must be used in compliance with applicable laws,
         including those  regarding mapping, of the country/region where maps, images and other data and
         third party content that you are authorized to  access via Azure Maps is made available.
         Example: view=IN.

         Please refer to `Supported Views <https://aka.ms/AzureMapsLocalizationViews>`_ for details and
         to see the available Views. Known values are: "AE", "AR", "BH", "IN", "IQ", "JO", "KW", "LB",
         "MA", "OM", "PK", "PS", "QA", "SA", "SY", "YE", "Auto", and "Unified". Default value is None.
        :paramtype localized_map_view: str or ~azure.maps.search.models.LocalizedMapView
        :return: ReverseSearchCrossStreetAddressResult
        :rtype: ~azure.maps.search.models.ReverseSearchCrossStreetAddressResult
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[_models.ReverseSearchCrossStreetAddressResult] = kwargs.pop("cls", None)

        _request = build_search_reverse_search_cross_street_address_request(
            format=format,
            query=query,
            top=top,
            heading=heading,
            radius_in_meters=radius_in_meters,
            language=language,
            localized_map_view=localized_map_view,
            client_id=self._config.client_id,
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = False
        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                response.read()  # Load the body in memory and close the socket
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize.failsafe_deserialize(_models.ErrorResponse, pipeline_response)
            raise HttpResponseError(response=response, model=error)

        deserialized = self._deserialize("ReverseSearchCrossStreetAddressResult", pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore

    @distributed_trace
    def search_structured_address(
        self,
        format: Union[str, _models.ResponseFormat] = "json",
        *,
        language: Optional[str] = None,
        country_code: str = "US",
        top: Optional[int] = None,
        skip: Optional[int] = None,
        street_number: Optional[str] = None,
        street_name: Optional[str] = None,
        cross_street: Optional[str] = None,
        municipality: Optional[str] = None,
        municipality_subdivision: Optional[str] = None,
        country_tertiary_subdivision: Optional[str] = None,
        country_secondary_subdivision: Optional[str] = None,
        country_subdivision: Optional[str] = None,
        postal_code: Optional[str] = None,
        extended_postal_codes_for: Optional[List[Union[str, _models.SearchIndexes]]] = None,
        entity_type: Optional[Union[str, _models.GeographicEntityType]] = None,
        localized_map_view: Optional[Union[str, _models.LocalizedMapView]] = None,
        **kwargs: Any
    ) -> _models.SearchAddressResult:
        """**Structured Address Geocoding**

        **Applies to:** see `pricing tiers <https://aka.ms/AzureMapsPricingTier>`_.

        Azure Address Geocoding can also be accessed for  structured address look up exclusively. The
        geocoding search index will be queried for everything above the  street level data. No POIs
        will be returned. Note that the geocoder is very tolerant of typos and incomplete  addresses.
        It will also handle everything from exact  street addresses or street or intersections as well
        as higher level geographies such as city centers,  counties, states etc.

        :param format: Desired format of the response. Value can be either *json* or *xml*. Known
         values are: "json" and "xml". Default value is "json".
        :type format: str or ~azure.maps.search.models.ResponseFormat
        :keyword language: Language in which search results should be returned. Should be one of
         supported IETF language tags, case insensitive. When data in specified language is not
         available for a specific field, default language is used.

         Please refer to `Supported Languages
         <https://docs.microsoft.com/azure/azure-maps/supported-languages>`_ for details. Default value
         is None.
        :paramtype language: str
        :keyword country_code: The 2 or 3 letter `ISO3166-1
         <https://www.iso.org/iso-3166-country-codes.html>`_ country/region code portion of an address.
         E.g. US. Default value is "US".
        :paramtype country_code: str
        :keyword top: Maximum number of responses that will be returned. Default: 10, minimum: 1 and
         maximum: 100. Default value is None.
        :paramtype top: int
        :keyword skip: Starting offset of the returned results within the full result set. Default: 0.
         Default value is None.
        :paramtype skip: int
        :keyword street_number: The street number portion of an address. Default value is None.
        :paramtype street_number: str
        :keyword street_name: The street name portion of an address. Default value is None.
        :paramtype street_name: str
        :keyword cross_street: The cross street name for the structured address. Default value is None.
        :paramtype cross_street: str
        :keyword municipality: The municipality portion of an address. Default value is None.
        :paramtype municipality: str
        :keyword municipality_subdivision: The municipality subdivision (sub/super city) for the
         structured address. Default value is None.
        :paramtype municipality_subdivision: str
        :keyword country_tertiary_subdivision: The named area for the structured address. Default value
         is None.
        :paramtype country_tertiary_subdivision: str
        :keyword country_secondary_subdivision: The country/region for the structured address. Default
         value is None.
        :paramtype country_secondary_subdivision: str
        :keyword country_subdivision: The country/region subdivision portion of an address. Default
         value is None.
        :paramtype country_subdivision: str
        :keyword postal_code: The postal code portion of an address. Default value is None.
        :paramtype postal_code: str
        :keyword extended_postal_codes_for: Indexes for which extended postal codes should be included
         in the results.

         Available indexes are:

          **Addr** = Address ranges

          **Geo** = Geographies

          **PAD** = Point Addresses

          **POI** = Points of Interest

          **Str** = Streets

          **XStr** = Cross Streets (intersections)

         Value should be a comma separated list of index types (in any order) or **None** for no
         indexes.

         By default extended postal codes are included for all indexes except Geo. Extended postal code
         lists for geographies can be quite long so they have to be explicitly requested when needed.

         Usage examples:

          extendedPostalCodesFor=POI

          extendedPostalCodesFor=PAD,Addr,POI

          extendedPostalCodesFor=None

         Extended postal code is returned as an **extendedPostalCode** property of an address.
         Availability is region-dependent. Default value is None.
        :paramtype extended_postal_codes_for: list[str or ~azure.maps.search.models.SearchIndexes]
        :keyword entity_type: Specifies the level of filtering performed on geographies. Narrows the
         search for specified geography entity types, e.g. return only municipality. The resulting
         response will contain the geography ID as well as the entity type matched. If you provide more
         than one entity as a comma separated list, endpoint will return the 'smallest entity
         available'. Returned Geometry ID can be used to get the geometry of that geography via `Get
         Search Polygon </rest/api/maps/search/get-search-polygon?view=rest-maps-1.0>`_ API. The
         following parameters are ignored when entityType is set:


         * heading
         * number
         * returnRoadUse
         * returnSpeedLimit
         * roadUse
         * returnMatchType. Known values are: "Country", "CountrySubdivision",
         "CountrySecondarySubdivision", "CountryTertiarySubdivision", "Municipality",
         "MunicipalitySubdivision", "Neighbourhood", and "PostalCodeArea". Default value is None.
        :paramtype entity_type: str or ~azure.maps.search.models.GeographicEntityType
        :keyword localized_map_view: The View parameter (also called the "user region" parameter)
         allows you to show the correct maps for a certain country/region for geopolitically disputed
         regions. Different countries/regions have different views of such regions, and the View
         parameter allows your application to comply with the view required by the country/region your
         application will be serving. By default, the View parameter is set to “Unified” even if you
         haven’t defined it in  the request. It is your responsibility to determine the location of your
         users, and then set the View parameter correctly for that location. Alternatively, you have the
         option to set ‘View=Auto’, which will return the map data based on the IP  address of the
         request. The View parameter in Azure Maps must be used in compliance with applicable laws,
         including those  regarding mapping, of the country/region where maps, images and other data and
         third party content that you are authorized to  access via Azure Maps is made available.
         Example: view=IN.

         Please refer to `Supported Views <https://aka.ms/AzureMapsLocalizationViews>`_ for details and
         to see the available Views. Known values are: "AE", "AR", "BH", "IN", "IQ", "JO", "KW", "LB",
         "MA", "OM", "PK", "PS", "QA", "SA", "SY", "YE", "Auto", and "Unified". Default value is None.
        :paramtype localized_map_view: str or ~azure.maps.search.models.LocalizedMapView
        :return: SearchAddressResult
        :rtype: ~azure.maps.search.models.SearchAddressResult
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[_models.SearchAddressResult] = kwargs.pop("cls", None)

        _request = build_search_search_structured_address_request(
            format=format,
            language=language,
            country_code=country_code,
            top=top,
            skip=skip,
            street_number=street_number,
            street_name=street_name,
            cross_street=cross_street,
            municipality=municipality,
            municipality_subdivision=municipality_subdivision,
            country_tertiary_subdivision=country_tertiary_subdivision,
            country_secondary_subdivision=country_secondary_subdivision,
            country_subdivision=country_subdivision,
            postal_code=postal_code,
            extended_postal_codes_for=extended_postal_codes_for,
            entity_type=entity_type,
            localized_map_view=localized_map_view,
            client_id=self._config.client_id,
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = False
        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                response.read()  # Load the body in memory and close the socket
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize.failsafe_deserialize(_models.ErrorResponse, pipeline_response)
            raise HttpResponseError(response=response, model=error)

        deserialized = self._deserialize("SearchAddressResult", pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore

    @overload
    def search_inside_geometry(
        self,
        geometry: _models.SearchInsideGeometryRequest,
        format: Union[str, _models.ResponseFormat] = "json",
        *,
        query: str,
        top: Optional[int] = None,
        language: Optional[str] = None,
        category_filter: Optional[List[int]] = None,
        extended_postal_codes_for: Optional[List[Union[str, _models.SearchIndexes]]] = None,
        index_filter: Optional[List[Union[str, _models.SearchIndexes]]] = None,
        localized_map_view: Optional[Union[str, _models.LocalizedMapView]] = None,
        operating_hours: Optional[Union[str, _models.OperatingHoursRange]] = None,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> _models.SearchAddressResult:
        """**Applies to:** see `pricing tiers <https://aka.ms/AzureMapsPricingTier>`_.

        The Search Geometry endpoint allows you to perform a free form search inside a single geometry
        or many of them. The search results that fall inside the geometry/geometries will be
        returned.:code:`<br>`:code:`<br>`To send the geometry you will use a ``POST`` request where the
        request body will contain the ``geometry`` object represented as a ``GeoJSON`` type and the
        ``Content-Type`` header will be set to ``application/json``. The geographical features to be
        searched can be modeled as Polygon and/or Circle geometries represented using any one of the
        following ``GeoJSON`` types::code:`<ul><li>**GeoJSON FeatureCollection** <br>The `geometry` can
        be represented as a `GeoJSON FeatureCollection` object. This is the recommended option if the
        geometry contains both Polygons and Circles. The `FeatureCollection` can contain a max of 50
        `GeoJSON Feature` objects. Each `Feature` object should represent either a Polygon or a Circle
        with the following conditions:<ul style="list-style-type:none"><li>A `Feature` object for the
        Polygon geometry can have a max of 50 coordinates and it's properties must be empty.</li><li>A
        `Feature` object for the Circle geometry is composed of a _center_ represented using a `GeoJSON
        Point` type and a _radius_ value (in meters) which must be specified in the object's properties
        along with the _subType_ property whose value should be 'Circle'.</li></ul>`:code:`<br>` Please
        see the Examples section below for a sample ``FeatureCollection``
        representation.:code:`<br>`:code:`<br>`</li>:code:`<li>**GeoJSON GeometryCollection**<br>The
        `geometry` can be represented as a `GeoJSON GeometryCollection` object. This is the recommended
        option if the geometry contains a list of Polygons only. The `GeometryCollection` can contain a
        max of 50 `GeoJSON Polygon` objects. Each `Polygon` object can have a max of 50 coordinates.
        Please see the Examples section below for a sample `GeometryCollection`
        representation.<br><br></li>`:code:`<li>**GeoJSON Polygon**<br>The `geometry` can be
        represented as a `GeoJSON Polygon` object. This is the recommended option if the geometry
        contains a single Polygon. The `Polygon` object can have a max of 50 coordinates. Please see
        the Examples section below for a sample `Polygon`
        representation.<br><br></li>`</ul>.:code:`<br>`:code:`<br>`.

        :param geometry: This represents the geometry for one or more geographical features (parks,
         state boundary etc.) to search in and should be a GeoJSON compliant type. Please refer to `RFC
         7946 <https://tools.ietf.org/html/rfc7946>`_ for details. Required.
        :type geometry: ~azure.maps.search.models.SearchInsideGeometryRequest
        :param format: Desired format of the response. Value can be either *json* or *xml*. Known
         values are: "json" and "xml". Default value is "json".
        :type format: str or ~azure.maps.search.models.ResponseFormat
        :keyword query: The POI name to search for (e.g., "statue of liberty", "starbucks", "pizza").
         Must be properly URL encoded. Required.
        :paramtype query: str
        :keyword top: Maximum number of responses that will be returned. Default: 10, minimum: 1 and
         maximum: 100. Default value is None.
        :paramtype top: int
        :keyword language: Language in which search results should be returned. Should be one of
         supported IETF language tags, case insensitive. When data in specified language is not
         available for a specific field, default language is used.

         Please refer to `Supported Languages
         <https://docs.microsoft.com/azure/azure-maps/supported-languages>`_ for details. Default value
         is None.
        :paramtype language: str
        :keyword category_filter: A comma-separated list of category set IDs which could be used to
         restrict the result to specific Points of Interest categories. ID order does not matter.
         Maximum number of ``categorySet`` values supported per request is 10. When multiple category
         identifiers are provided, only POIs that belong to (at least) one of the categories from the
         provided list will be returned. The list of supported categories can be discovered using `POI
         Categories API <https://aka.ms/AzureMapsPOICategoryTree>`_. Usage examples:


         *
           **categorySet=7315** (Search Points of Interest from category Restaurant)

         *
           **categorySet=7315025,7315017** (Search Points of Interest of category either Italian or
         French Restaurant). Default value is None.
        :paramtype category_filter: list[int]
        :keyword extended_postal_codes_for: Indexes for which extended postal codes should be included
         in the results.

         Available indexes are:

          **Addr** = Address ranges

          **Geo** = Geographies

          **PAD** = Point Addresses

          **POI** = Points of Interest

          **Str** = Streets

          **XStr** = Cross Streets (intersections)

         Value should be a comma separated list of index types (in any order) or **None** for no
         indexes.

         By default extended postal codes are included for all indexes except Geo. Extended postal code
         lists for geographies can be quite long so they have to be explicitly requested when needed.

         Usage examples:

          extendedPostalCodesFor=POI

          extendedPostalCodesFor=PAD,Addr,POI

          extendedPostalCodesFor=None

         Extended postal code is returned as an **extendedPostalCode** property of an address.
         Availability is region-dependent. Default value is None.
        :paramtype extended_postal_codes_for: list[str or ~azure.maps.search.models.SearchIndexes]
        :keyword index_filter: A comma separated list of indexes which should be utilized for the
         search. Item order does not matter. Available indexes are: Addr = Address range interpolation,
         Geo = Geographies, PAD = Point Addresses, POI = Points of interest, Str = Streets, Xstr = Cross
         Streets (intersections). Default value is None.
        :paramtype index_filter: list[str or ~azure.maps.search.models.SearchIndexes]
        :keyword localized_map_view: The View parameter (also called the "user region" parameter)
         allows you to show the correct maps for a certain country/region for geopolitically disputed
         regions. Different countries/regions have different views of such regions, and the View
         parameter allows your application to comply with the view required by the country/region your
         application will be serving. By default, the View parameter is set to “Unified” even if you
         haven’t defined it in  the request. It is your responsibility to determine the location of your
         users, and then set the View parameter correctly for that location. Alternatively, you have the
         option to set ‘View=Auto’, which will return the map data based on the IP  address of the
         request. The View parameter in Azure Maps must be used in compliance with applicable laws,
         including those  regarding mapping, of the country/region where maps, images and other data and
         third party content that you are authorized to  access via Azure Maps is made available.
         Example: view=IN.

         Please refer to `Supported Views <https://aka.ms/AzureMapsLocalizationViews>`_ for details and
         to see the available Views. Known values are: "AE", "AR", "BH", "IN", "IQ", "JO", "KW", "LB",
         "MA", "OM", "PK", "PS", "QA", "SA", "SY", "YE", "Auto", and "Unified". Default value is None.
        :paramtype localized_map_view: str or ~azure.maps.search.models.LocalizedMapView
        :keyword operating_hours: Hours of operation for a POI (Points of Interest). The availability
         of hours of operation will vary based on the data available. If not passed, then no opening
         hours information will be returned.
         Supported value: nextSevenDays. "nextSevenDays" Default value is None.
        :paramtype operating_hours: str or ~azure.maps.search.models.OperatingHoursRange
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: SearchAddressResult
        :rtype: ~azure.maps.search.models.SearchAddressResult
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @overload
    def search_inside_geometry(
        self,
        geometry: IO[bytes],
        format: Union[str, _models.ResponseFormat] = "json",
        *,
        query: str,
        top: Optional[int] = None,
        language: Optional[str] = None,
        category_filter: Optional[List[int]] = None,
        extended_postal_codes_for: Optional[List[Union[str, _models.SearchIndexes]]] = None,
        index_filter: Optional[List[Union[str, _models.SearchIndexes]]] = None,
        localized_map_view: Optional[Union[str, _models.LocalizedMapView]] = None,
        operating_hours: Optional[Union[str, _models.OperatingHoursRange]] = None,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> _models.SearchAddressResult:
        """**Applies to:** see `pricing tiers <https://aka.ms/AzureMapsPricingTier>`_.

        The Search Geometry endpoint allows you to perform a free form search inside a single geometry
        or many of them. The search results that fall inside the geometry/geometries will be
        returned.:code:`<br>`:code:`<br>`To send the geometry you will use a ``POST`` request where the
        request body will contain the ``geometry`` object represented as a ``GeoJSON`` type and the
        ``Content-Type`` header will be set to ``application/json``. The geographical features to be
        searched can be modeled as Polygon and/or Circle geometries represented using any one of the
        following ``GeoJSON`` types::code:`<ul><li>**GeoJSON FeatureCollection** <br>The `geometry` can
        be represented as a `GeoJSON FeatureCollection` object. This is the recommended option if the
        geometry contains both Polygons and Circles. The `FeatureCollection` can contain a max of 50
        `GeoJSON Feature` objects. Each `Feature` object should represent either a Polygon or a Circle
        with the following conditions:<ul style="list-style-type:none"><li>A `Feature` object for the
        Polygon geometry can have a max of 50 coordinates and it's properties must be empty.</li><li>A
        `Feature` object for the Circle geometry is composed of a _center_ represented using a `GeoJSON
        Point` type and a _radius_ value (in meters) which must be specified in the object's properties
        along with the _subType_ property whose value should be 'Circle'.</li></ul>`:code:`<br>` Please
        see the Examples section below for a sample ``FeatureCollection``
        representation.:code:`<br>`:code:`<br>`</li>:code:`<li>**GeoJSON GeometryCollection**<br>The
        `geometry` can be represented as a `GeoJSON GeometryCollection` object. This is the recommended
        option if the geometry contains a list of Polygons only. The `GeometryCollection` can contain a
        max of 50 `GeoJSON Polygon` objects. Each `Polygon` object can have a max of 50 coordinates.
        Please see the Examples section below for a sample `GeometryCollection`
        representation.<br><br></li>`:code:`<li>**GeoJSON Polygon**<br>The `geometry` can be
        represented as a `GeoJSON Polygon` object. This is the recommended option if the geometry
        contains a single Polygon. The `Polygon` object can have a max of 50 coordinates. Please see
        the Examples section below for a sample `Polygon`
        representation.<br><br></li>`</ul>.:code:`<br>`:code:`<br>`.

        :param geometry: This represents the geometry for one or more geographical features (parks,
         state boundary etc.) to search in and should be a GeoJSON compliant type. Please refer to `RFC
         7946 <https://tools.ietf.org/html/rfc7946>`_ for details. Required.
        :type geometry: IO[bytes]
        :param format: Desired format of the response. Value can be either *json* or *xml*. Known
         values are: "json" and "xml". Default value is "json".
        :type format: str or ~azure.maps.search.models.ResponseFormat
        :keyword query: The POI name to search for (e.g., "statue of liberty", "starbucks", "pizza").
         Must be properly URL encoded. Required.
        :paramtype query: str
        :keyword top: Maximum number of responses that will be returned. Default: 10, minimum: 1 and
         maximum: 100. Default value is None.
        :paramtype top: int
        :keyword language: Language in which search results should be returned. Should be one of
         supported IETF language tags, case insensitive. When data in specified language is not
         available for a specific field, default language is used.

         Please refer to `Supported Languages
         <https://docs.microsoft.com/azure/azure-maps/supported-languages>`_ for details. Default value
         is None.
        :paramtype language: str
        :keyword category_filter: A comma-separated list of category set IDs which could be used to
         restrict the result to specific Points of Interest categories. ID order does not matter.
         Maximum number of ``categorySet`` values supported per request is 10. When multiple category
         identifiers are provided, only POIs that belong to (at least) one of the categories from the
         provided list will be returned. The list of supported categories can be discovered using `POI
         Categories API <https://aka.ms/AzureMapsPOICategoryTree>`_. Usage examples:


         *
           **categorySet=7315** (Search Points of Interest from category Restaurant)

         *
           **categorySet=7315025,7315017** (Search Points of Interest of category either Italian or
         French Restaurant). Default value is None.
        :paramtype category_filter: list[int]
        :keyword extended_postal_codes_for: Indexes for which extended postal codes should be included
         in the results.

         Available indexes are:

          **Addr** = Address ranges

          **Geo** = Geographies

          **PAD** = Point Addresses

          **POI** = Points of Interest

          **Str** = Streets

          **XStr** = Cross Streets (intersections)

         Value should be a comma separated list of index types (in any order) or **None** for no
         indexes.

         By default extended postal codes are included for all indexes except Geo. Extended postal code
         lists for geographies can be quite long so they have to be explicitly requested when needed.

         Usage examples:

          extendedPostalCodesFor=POI

          extendedPostalCodesFor=PAD,Addr,POI

          extendedPostalCodesFor=None

         Extended postal code is returned as an **extendedPostalCode** property of an address.
         Availability is region-dependent. Default value is None.
        :paramtype extended_postal_codes_for: list[str or ~azure.maps.search.models.SearchIndexes]
        :keyword index_filter: A comma separated list of indexes which should be utilized for the
         search. Item order does not matter. Available indexes are: Addr = Address range interpolation,
         Geo = Geographies, PAD = Point Addresses, POI = Points of interest, Str = Streets, Xstr = Cross
         Streets (intersections). Default value is None.
        :paramtype index_filter: list[str or ~azure.maps.search.models.SearchIndexes]
        :keyword localized_map_view: The View parameter (also called the "user region" parameter)
         allows you to show the correct maps for a certain country/region for geopolitically disputed
         regions. Different countries/regions have different views of such regions, and the View
         parameter allows your application to comply with the view required by the country/region your
         application will be serving. By default, the View parameter is set to “Unified” even if you
         haven’t defined it in  the request. It is your responsibility to determine the location of your
         users, and then set the View parameter correctly for that location. Alternatively, you have the
         option to set ‘View=Auto’, which will return the map data based on the IP  address of the
         request. The View parameter in Azure Maps must be used in compliance with applicable laws,
         including those  regarding mapping, of the country/region where maps, images and other data and
         third party content that you are authorized to  access via Azure Maps is made available.
         Example: view=IN.

         Please refer to `Supported Views <https://aka.ms/AzureMapsLocalizationViews>`_ for details and
         to see the available Views. Known values are: "AE", "AR", "BH", "IN", "IQ", "JO", "KW", "LB",
         "MA", "OM", "PK", "PS", "QA", "SA", "SY", "YE", "Auto", and "Unified". Default value is None.
        :paramtype localized_map_view: str or ~azure.maps.search.models.LocalizedMapView
        :keyword operating_hours: Hours of operation for a POI (Points of Interest). The availability
         of hours of operation will vary based on the data available. If not passed, then no opening
         hours information will be returned.
         Supported value: nextSevenDays. "nextSevenDays" Default value is None.
        :paramtype operating_hours: str or ~azure.maps.search.models.OperatingHoursRange
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: SearchAddressResult
        :rtype: ~azure.maps.search.models.SearchAddressResult
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @distributed_trace
    def search_inside_geometry(
        self,
        geometry: Union[_models.SearchInsideGeometryRequest, IO[bytes]],
        format: Union[str, _models.ResponseFormat] = "json",
        *,
        query: str,
        top: Optional[int] = None,
        language: Optional[str] = None,
        category_filter: Optional[List[int]] = None,
        extended_postal_codes_for: Optional[List[Union[str, _models.SearchIndexes]]] = None,
        index_filter: Optional[List[Union[str, _models.SearchIndexes]]] = None,
        localized_map_view: Optional[Union[str, _models.LocalizedMapView]] = None,
        operating_hours: Optional[Union[str, _models.OperatingHoursRange]] = None,
        **kwargs: Any
    ) -> _models.SearchAddressResult:
        """**Applies to:** see `pricing tiers <https://aka.ms/AzureMapsPricingTier>`_.

        The Search Geometry endpoint allows you to perform a free form search inside a single geometry
        or many of them. The search results that fall inside the geometry/geometries will be
        returned.:code:`<br>`:code:`<br>`To send the geometry you will use a ``POST`` request where the
        request body will contain the ``geometry`` object represented as a ``GeoJSON`` type and the
        ``Content-Type`` header will be set to ``application/json``. The geographical features to be
        searched can be modeled as Polygon and/or Circle geometries represented using any one of the
        following ``GeoJSON`` types::code:`<ul><li>**GeoJSON FeatureCollection** <br>The `geometry` can
        be represented as a `GeoJSON FeatureCollection` object. This is the recommended option if the
        geometry contains both Polygons and Circles. The `FeatureCollection` can contain a max of 50
        `GeoJSON Feature` objects. Each `Feature` object should represent either a Polygon or a Circle
        with the following conditions:<ul style="list-style-type:none"><li>A `Feature` object for the
        Polygon geometry can have a max of 50 coordinates and it's properties must be empty.</li><li>A
        `Feature` object for the Circle geometry is composed of a _center_ represented using a `GeoJSON
        Point` type and a _radius_ value (in meters) which must be specified in the object's properties
        along with the _subType_ property whose value should be 'Circle'.</li></ul>`:code:`<br>` Please
        see the Examples section below for a sample ``FeatureCollection``
        representation.:code:`<br>`:code:`<br>`</li>:code:`<li>**GeoJSON GeometryCollection**<br>The
        `geometry` can be represented as a `GeoJSON GeometryCollection` object. This is the recommended
        option if the geometry contains a list of Polygons only. The `GeometryCollection` can contain a
        max of 50 `GeoJSON Polygon` objects. Each `Polygon` object can have a max of 50 coordinates.
        Please see the Examples section below for a sample `GeometryCollection`
        representation.<br><br></li>`:code:`<li>**GeoJSON Polygon**<br>The `geometry` can be
        represented as a `GeoJSON Polygon` object. This is the recommended option if the geometry
        contains a single Polygon. The `Polygon` object can have a max of 50 coordinates. Please see
        the Examples section below for a sample `Polygon`
        representation.<br><br></li>`</ul>.:code:`<br>`:code:`<br>`.

        :param geometry: This represents the geometry for one or more geographical features (parks,
         state boundary etc.) to search in and should be a GeoJSON compliant type. Please refer to `RFC
         7946 <https://tools.ietf.org/html/rfc7946>`_ for details. Is either a
         SearchInsideGeometryRequest type or a IO[bytes] type. Required.
        :type geometry: ~azure.maps.search.models.SearchInsideGeometryRequest or IO[bytes]
        :param format: Desired format of the response. Value can be either *json* or *xml*. Known
         values are: "json" and "xml". Default value is "json".
        :type format: str or ~azure.maps.search.models.ResponseFormat
        :keyword query: The POI name to search for (e.g., "statue of liberty", "starbucks", "pizza").
         Must be properly URL encoded. Required.
        :paramtype query: str
        :keyword top: Maximum number of responses that will be returned. Default: 10, minimum: 1 and
         maximum: 100. Default value is None.
        :paramtype top: int
        :keyword language: Language in which search results should be returned. Should be one of
         supported IETF language tags, case insensitive. When data in specified language is not
         available for a specific field, default language is used.

         Please refer to `Supported Languages
         <https://docs.microsoft.com/azure/azure-maps/supported-languages>`_ for details. Default value
         is None.
        :paramtype language: str
        :keyword category_filter: A comma-separated list of category set IDs which could be used to
         restrict the result to specific Points of Interest categories. ID order does not matter.
         Maximum number of ``categorySet`` values supported per request is 10. When multiple category
         identifiers are provided, only POIs that belong to (at least) one of the categories from the
         provided list will be returned. The list of supported categories can be discovered using `POI
         Categories API <https://aka.ms/AzureMapsPOICategoryTree>`_. Usage examples:


         *
           **categorySet=7315** (Search Points of Interest from category Restaurant)

         *
           **categorySet=7315025,7315017** (Search Points of Interest of category either Italian or
         French Restaurant). Default value is None.
        :paramtype category_filter: list[int]
        :keyword extended_postal_codes_for: Indexes for which extended postal codes should be included
         in the results.

         Available indexes are:

          **Addr** = Address ranges

          **Geo** = Geographies

          **PAD** = Point Addresses

          **POI** = Points of Interest

          **Str** = Streets

          **XStr** = Cross Streets (intersections)

         Value should be a comma separated list of index types (in any order) or **None** for no
         indexes.

         By default extended postal codes are included for all indexes except Geo. Extended postal code
         lists for geographies can be quite long so they have to be explicitly requested when needed.

         Usage examples:

          extendedPostalCodesFor=POI

          extendedPostalCodesFor=PAD,Addr,POI

          extendedPostalCodesFor=None

         Extended postal code is returned as an **extendedPostalCode** property of an address.
         Availability is region-dependent. Default value is None.
        :paramtype extended_postal_codes_for: list[str or ~azure.maps.search.models.SearchIndexes]
        :keyword index_filter: A comma separated list of indexes which should be utilized for the
         search. Item order does not matter. Available indexes are: Addr = Address range interpolation,
         Geo = Geographies, PAD = Point Addresses, POI = Points of interest, Str = Streets, Xstr = Cross
         Streets (intersections). Default value is None.
        :paramtype index_filter: list[str or ~azure.maps.search.models.SearchIndexes]
        :keyword localized_map_view: The View parameter (also called the "user region" parameter)
         allows you to show the correct maps for a certain country/region for geopolitically disputed
         regions. Different countries/regions have different views of such regions, and the View
         parameter allows your application to comply with the view required by the country/region your
         application will be serving. By default, the View parameter is set to “Unified” even if you
         haven’t defined it in  the request. It is your responsibility to determine the location of your
         users, and then set the View parameter correctly for that location. Alternatively, you have the
         option to set ‘View=Auto’, which will return the map data based on the IP  address of the
         request. The View parameter in Azure Maps must be used in compliance with applicable laws,
         including those  regarding mapping, of the country/region where maps, images and other data and
         third party content that you are authorized to  access via Azure Maps is made available.
         Example: view=IN.

         Please refer to `Supported Views <https://aka.ms/AzureMapsLocalizationViews>`_ for details and
         to see the available Views. Known values are: "AE", "AR", "BH", "IN", "IQ", "JO", "KW", "LB",
         "MA", "OM", "PK", "PS", "QA", "SA", "SY", "YE", "Auto", and "Unified". Default value is None.
        :paramtype localized_map_view: str or ~azure.maps.search.models.LocalizedMapView
        :keyword operating_hours: Hours of operation for a POI (Points of Interest). The availability
         of hours of operation will vary based on the data available. If not passed, then no opening
         hours information will be returned.
         Supported value: nextSevenDays. "nextSevenDays" Default value is None.
        :paramtype operating_hours: str or ~azure.maps.search.models.OperatingHoursRange
        :return: SearchAddressResult
        :rtype: ~azure.maps.search.models.SearchAddressResult
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[_models.SearchAddressResult] = kwargs.pop("cls", None)

        content_type = content_type or "application/json"
        _json = None
        _content = None
        if isinstance(geometry, (IOBase, bytes)):
            _content = geometry
        else:
            _json = self._serialize.body(geometry, "SearchInsideGeometryRequest")

        _request = build_search_search_inside_geometry_request(
            format=format,
            query=query,
            top=top,
            language=language,
            category_filter=category_filter,
            extended_postal_codes_for=extended_postal_codes_for,
            index_filter=index_filter,
            localized_map_view=localized_map_view,
            operating_hours=operating_hours,
            client_id=self._config.client_id,
            content_type=content_type,
            api_version=self._config.api_version,
            json=_json,
            content=_content,
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = False
        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                response.read()  # Load the body in memory and close the socket
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize.failsafe_deserialize(_models.ErrorResponse, pipeline_response)
            raise HttpResponseError(response=response, model=error)

        deserialized = self._deserialize("SearchAddressResult", pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore

    @overload
    def search_along_route(
        self,
        route: _models.SearchAlongRouteRequest,
        format: Union[str, _models.ResponseFormat] = "json",
        *,
        query: str,
        max_detour_time: int,
        top: Optional[int] = None,
        brand_filter: Optional[List[str]] = None,
        category_filter: Optional[List[int]] = None,
        electric_vehicle_connector_filter: Optional[List[Union[str, _models.ElectricVehicleConnector]]] = None,
        localized_map_view: Optional[Union[str, _models.LocalizedMapView]] = None,
        operating_hours: Optional[Union[str, _models.OperatingHoursRange]] = None,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> _models.SearchAddressResult:
        """**Applies to:** see `pricing tiers <https://aka.ms/AzureMapsPricingTier>`_.

        The Search Along Route endpoint allows you to perform a fuzzy search for POIs along a specified
        route. This search is constrained by specifying the ``maxDetourTime`` limiting
        measure.:code:`<br>`:code:`<br>`To send the route-points you will use a ``POST`` request where
        the request body will contain the ``route`` object represented as a ``GeoJSON LineString`` type
        and the ``Content-Type`` header will be set to ``application/json``. Each route-point in
        ``route`` is represented as a ``GeoJSON Position`` type i.e. an array where the *longitude*
        value is followed by the *latitude* value and the *altitude* value is ignored. The ``route``
        should contain at least 2 route-points.:code:`<br>`:code:`<br>`It is possible that original
        route will be altered, some of it's points may be skipped. If the route that passes through the
        found point is faster than the original one, the ``detourTime`` value in the response is
        negative.

        :param route: This represents the route to search along and should be a valid ``GeoJSON
         LineString`` type. Please refer to `RFC 7946
         <https://tools.ietf.org/html/rfc7946#section-3.1.4>`_ for details. Required.
        :type route: ~azure.maps.search.models.SearchAlongRouteRequest
        :param format: Desired format of the response. Value can be either *json* or *xml*. Known
         values are: "json" and "xml". Default value is "json".
        :type format: str or ~azure.maps.search.models.ResponseFormat
        :keyword query: The POI name to search for (e.g., "statue of liberty", "starbucks", "pizza").
         Must be properly URL encoded. Required.
        :paramtype query: str
        :keyword max_detour_time: Maximum detour time of the point of interest in seconds. Max value is
         3600 seconds. Required.
        :paramtype max_detour_time: int
        :keyword top: Maximum number of responses that will be returned. Default value is 10. Max value
         is 20. Default value is None.
        :paramtype top: int
        :keyword brand_filter: A comma-separated list of brand names which could be used to restrict
         the result to specific brands. Item order does not matter. When multiple brands are provided,
         only results that belong to (at least) one of the provided list will be returned. Brands that
         contain a "," in their name should be put into quotes.

         Usage examples:

          brandSet=Foo

          brandSet=Foo,Bar

          brandSet="A,B,C Comma",Bar. Default value is None.
        :paramtype brand_filter: list[str]
        :keyword category_filter: A comma-separated list of category set IDs which could be used to
         restrict the result to specific Points of Interest categories. ID order does not matter.
         Maximum number of ``categorySet`` values supported per request is 10. When multiple category
         identifiers are provided, only POIs that belong to (at least) one of the categories from the
         provided list will be returned. The list of supported categories can be discovered using `POI
         Categories API <https://aka.ms/AzureMapsPOICategoryTree>`_. Usage examples:


         *
           **categorySet=7315** (Search Points of Interest from category Restaurant)

         *
           **categorySet=7315025,7315017** (Search Points of Interest of category either Italian or
         French Restaurant). Default value is None.
        :paramtype category_filter: list[int]
        :keyword electric_vehicle_connector_filter: A comma-separated list of connector types which
         could be used to restrict the result to Electric Vehicle Station supporting specific connector
         types. Item order does not matter. When multiple connector types are provided, only results
         that belong to (at least) one of the provided list will be returned.

         Available connector types are:


         * ``StandardHouseholdCountrySpecific`` - These are the standard household connectors for a
         certain region. They are all AC single phase and the standard Voltage and standard Amperage.
         See also: `Plug & socket types - World Standards
         <https://www.worldstandards.eu/electricity/plugs-and-sockets>`_.
         * ``IEC62196Type1`` - Type 1 connector as defined in the IEC 62196-2 standard. Also called
         Yazaki after the original manufacturer or SAE J1772 after the standard that first published it.
         Mostly used in combination with 120V single phase or up to 240V single phase infrastructure.
         * ``IEC62196Type1CCS`` - Type 1 based combo connector as defined in the IEC 62196-3 standard.
         The connector is based on the Type 1 connector – as defined in the IEC 62196-2 standard – with
         two additional direct current (DC) contacts to allow DC fast charging.
         * ``IEC62196Type2CableAttached`` - Type 2 connector as defined in the IEC 62196-2 standard.
         Provided as a cable and plug attached to the charging point.
         * ``IEC62196Type2Outlet`` - Type 2 connector as defined in the IEC 62196-2 standard. Provided
         as a socket set into the charging point.
         * ``IEC62196Type2CCS`` - Type 2 based combo connector as defined in the IEC 62196-3 standard.
         The connector is based on the Type 2 connector – as defined in the IEC 62196-2 standard – with
         two additional direct current (DC) contacts to allow DC fast charging.
         * ``IEC62196Type3`` - Type 3 connector as defined in the IEC 62196-2 standard. Also called
         Scame after the original manufacturer. Mostly used in combination with up to 240V single phase
         or up to 420V three phase infrastructure.
         * ``Chademo`` - CHAdeMO connector named after an association formed by the Tokyo Electric
         Power Company and industrial partners. Because of this is is also known as the TEPCO's
         connector. It supports fast DC charging.
         * ``IEC60309AC1PhaseBlue`` - Industrial Blue connector is a connector defined in the IEC 60309
         standard. It is sometime referred to as by some combination of the standard, the color and the
         fact that is a single phase connector. The connector usually has the "P+N+E, 6h" configuration.
         * ``IEC60309DCWhite`` - Industrial White connector is a DC connector defined in the IEC 60309
         standard.
         * ``Tesla`` - The Tesla connector is the regionally specific Tesla Supercharger connector.
         I.e. it refers to either Tesla's proprietary connector, sometimes referred to as Tesla Port
         mostly limited to North America or the modified Type 2 (DC over Type 2) in Europe.

         Usage examples:

          connectorSet=IEC62196Type2CableAttached
          connectorSet=IEC62196Type2Outlet,IEC62196Type2CableAttached. Default value is None.
        :paramtype electric_vehicle_connector_filter: list[str or
         ~azure.maps.search.models.ElectricVehicleConnector]
        :keyword localized_map_view: The View parameter (also called the "user region" parameter)
         allows you to show the correct maps for a certain country/region for geopolitically disputed
         regions. Different countries/regions have different views of such regions, and the View
         parameter allows your application to comply with the view required by the country/region your
         application will be serving. By default, the View parameter is set to “Unified” even if you
         haven’t defined it in  the request. It is your responsibility to determine the location of your
         users, and then set the View parameter correctly for that location. Alternatively, you have the
         option to set ‘View=Auto’, which will return the map data based on the IP  address of the
         request. The View parameter in Azure Maps must be used in compliance with applicable laws,
         including those  regarding mapping, of the country/region where maps, images and other data and
         third party content that you are authorized to  access via Azure Maps is made available.
         Example: view=IN.

         Please refer to `Supported Views <https://aka.ms/AzureMapsLocalizationViews>`_ for details and
         to see the available Views. Known values are: "AE", "AR", "BH", "IN", "IQ", "JO", "KW", "LB",
         "MA", "OM", "PK", "PS", "QA", "SA", "SY", "YE", "Auto", and "Unified". Default value is None.
        :paramtype localized_map_view: str or ~azure.maps.search.models.LocalizedMapView
        :keyword operating_hours: Hours of operation for a POI (Points of Interest). The availability
         of hours of operation will vary based on the data available. If not passed, then no opening
         hours information will be returned.
         Supported value: nextSevenDays. "nextSevenDays" Default value is None.
        :paramtype operating_hours: str or ~azure.maps.search.models.OperatingHoursRange
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: SearchAddressResult
        :rtype: ~azure.maps.search.models.SearchAddressResult
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @overload
    def search_along_route(
        self,
        route: IO[bytes],
        format: Union[str, _models.ResponseFormat] = "json",
        *,
        query: str,
        max_detour_time: int,
        top: Optional[int] = None,
        brand_filter: Optional[List[str]] = None,
        category_filter: Optional[List[int]] = None,
        electric_vehicle_connector_filter: Optional[List[Union[str, _models.ElectricVehicleConnector]]] = None,
        localized_map_view: Optional[Union[str, _models.LocalizedMapView]] = None,
        operating_hours: Optional[Union[str, _models.OperatingHoursRange]] = None,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> _models.SearchAddressResult:
        """**Applies to:** see `pricing tiers <https://aka.ms/AzureMapsPricingTier>`_.

        The Search Along Route endpoint allows you to perform a fuzzy search for POIs along a specified
        route. This search is constrained by specifying the ``maxDetourTime`` limiting
        measure.:code:`<br>`:code:`<br>`To send the route-points you will use a ``POST`` request where
        the request body will contain the ``route`` object represented as a ``GeoJSON LineString`` type
        and the ``Content-Type`` header will be set to ``application/json``. Each route-point in
        ``route`` is represented as a ``GeoJSON Position`` type i.e. an array where the *longitude*
        value is followed by the *latitude* value and the *altitude* value is ignored. The ``route``
        should contain at least 2 route-points.:code:`<br>`:code:`<br>`It is possible that original
        route will be altered, some of it's points may be skipped. If the route that passes through the
        found point is faster than the original one, the ``detourTime`` value in the response is
        negative.

        :param route: This represents the route to search along and should be a valid ``GeoJSON
         LineString`` type. Please refer to `RFC 7946
         <https://tools.ietf.org/html/rfc7946#section-3.1.4>`_ for details. Required.
        :type route: IO[bytes]
        :param format: Desired format of the response. Value can be either *json* or *xml*. Known
         values are: "json" and "xml". Default value is "json".
        :type format: str or ~azure.maps.search.models.ResponseFormat
        :keyword query: The POI name to search for (e.g., "statue of liberty", "starbucks", "pizza").
         Must be properly URL encoded. Required.
        :paramtype query: str
        :keyword max_detour_time: Maximum detour time of the point of interest in seconds. Max value is
         3600 seconds. Required.
        :paramtype max_detour_time: int
        :keyword top: Maximum number of responses that will be returned. Default value is 10. Max value
         is 20. Default value is None.
        :paramtype top: int
        :keyword brand_filter: A comma-separated list of brand names which could be used to restrict
         the result to specific brands. Item order does not matter. When multiple brands are provided,
         only results that belong to (at least) one of the provided list will be returned. Brands that
         contain a "," in their name should be put into quotes.

         Usage examples:

          brandSet=Foo

          brandSet=Foo,Bar

          brandSet="A,B,C Comma",Bar. Default value is None.
        :paramtype brand_filter: list[str]
        :keyword category_filter: A comma-separated list of category set IDs which could be used to
         restrict the result to specific Points of Interest categories. ID order does not matter.
         Maximum number of ``categorySet`` values supported per request is 10. When multiple category
         identifiers are provided, only POIs that belong to (at least) one of the categories from the
         provided list will be returned. The list of supported categories can be discovered using `POI
         Categories API <https://aka.ms/AzureMapsPOICategoryTree>`_. Usage examples:


         *
           **categorySet=7315** (Search Points of Interest from category Restaurant)

         *
           **categorySet=7315025,7315017** (Search Points of Interest of category either Italian or
         French Restaurant). Default value is None.
        :paramtype category_filter: list[int]
        :keyword electric_vehicle_connector_filter: A comma-separated list of connector types which
         could be used to restrict the result to Electric Vehicle Station supporting specific connector
         types. Item order does not matter. When multiple connector types are provided, only results
         that belong to (at least) one of the provided list will be returned.

         Available connector types are:


         * ``StandardHouseholdCountrySpecific`` - These are the standard household connectors for a
         certain region. They are all AC single phase and the standard Voltage and standard Amperage.
         See also: `Plug & socket types - World Standards
         <https://www.worldstandards.eu/electricity/plugs-and-sockets>`_.
         * ``IEC62196Type1`` - Type 1 connector as defined in the IEC 62196-2 standard. Also called
         Yazaki after the original manufacturer or SAE J1772 after the standard that first published it.
         Mostly used in combination with 120V single phase or up to 240V single phase infrastructure.
         * ``IEC62196Type1CCS`` - Type 1 based combo connector as defined in the IEC 62196-3 standard.
         The connector is based on the Type 1 connector – as defined in the IEC 62196-2 standard – with
         two additional direct current (DC) contacts to allow DC fast charging.
         * ``IEC62196Type2CableAttached`` - Type 2 connector as defined in the IEC 62196-2 standard.
         Provided as a cable and plug attached to the charging point.
         * ``IEC62196Type2Outlet`` - Type 2 connector as defined in the IEC 62196-2 standard. Provided
         as a socket set into the charging point.
         * ``IEC62196Type2CCS`` - Type 2 based combo connector as defined in the IEC 62196-3 standard.
         The connector is based on the Type 2 connector – as defined in the IEC 62196-2 standard – with
         two additional direct current (DC) contacts to allow DC fast charging.
         * ``IEC62196Type3`` - Type 3 connector as defined in the IEC 62196-2 standard. Also called
         Scame after the original manufacturer. Mostly used in combination with up to 240V single phase
         or up to 420V three phase infrastructure.
         * ``Chademo`` - CHAdeMO connector named after an association formed by the Tokyo Electric
         Power Company and industrial partners. Because of this is is also known as the TEPCO's
         connector. It supports fast DC charging.
         * ``IEC60309AC1PhaseBlue`` - Industrial Blue connector is a connector defined in the IEC 60309
         standard. It is sometime referred to as by some combination of the standard, the color and the
         fact that is a single phase connector. The connector usually has the "P+N+E, 6h" configuration.
         * ``IEC60309DCWhite`` - Industrial White connector is a DC connector defined in the IEC 60309
         standard.
         * ``Tesla`` - The Tesla connector is the regionally specific Tesla Supercharger connector.
         I.e. it refers to either Tesla's proprietary connector, sometimes referred to as Tesla Port
         mostly limited to North America or the modified Type 2 (DC over Type 2) in Europe.

         Usage examples:

          connectorSet=IEC62196Type2CableAttached
          connectorSet=IEC62196Type2Outlet,IEC62196Type2CableAttached. Default value is None.
        :paramtype electric_vehicle_connector_filter: list[str or
         ~azure.maps.search.models.ElectricVehicleConnector]
        :keyword localized_map_view: The View parameter (also called the "user region" parameter)
         allows you to show the correct maps for a certain country/region for geopolitically disputed
         regions. Different countries/regions have different views of such regions, and the View
         parameter allows your application to comply with the view required by the country/region your
         application will be serving. By default, the View parameter is set to “Unified” even if you
         haven’t defined it in  the request. It is your responsibility to determine the location of your
         users, and then set the View parameter correctly for that location. Alternatively, you have the
         option to set ‘View=Auto’, which will return the map data based on the IP  address of the
         request. The View parameter in Azure Maps must be used in compliance with applicable laws,
         including those  regarding mapping, of the country/region where maps, images and other data and
         third party content that you are authorized to  access via Azure Maps is made available.
         Example: view=IN.

         Please refer to `Supported Views <https://aka.ms/AzureMapsLocalizationViews>`_ for details and
         to see the available Views. Known values are: "AE", "AR", "BH", "IN", "IQ", "JO", "KW", "LB",
         "MA", "OM", "PK", "PS", "QA", "SA", "SY", "YE", "Auto", and "Unified". Default value is None.
        :paramtype localized_map_view: str or ~azure.maps.search.models.LocalizedMapView
        :keyword operating_hours: Hours of operation for a POI (Points of Interest). The availability
         of hours of operation will vary based on the data available. If not passed, then no opening
         hours information will be returned.
         Supported value: nextSevenDays. "nextSevenDays" Default value is None.
        :paramtype operating_hours: str or ~azure.maps.search.models.OperatingHoursRange
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: SearchAddressResult
        :rtype: ~azure.maps.search.models.SearchAddressResult
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @distributed_trace
    def search_along_route(
        self,
        route: Union[_models.SearchAlongRouteRequest, IO[bytes]],
        format: Union[str, _models.ResponseFormat] = "json",
        *,
        query: str,
        max_detour_time: int,
        top: Optional[int] = None,
        brand_filter: Optional[List[str]] = None,
        category_filter: Optional[List[int]] = None,
        electric_vehicle_connector_filter: Optional[List[Union[str, _models.ElectricVehicleConnector]]] = None,
        localized_map_view: Optional[Union[str, _models.LocalizedMapView]] = None,
        operating_hours: Optional[Union[str, _models.OperatingHoursRange]] = None,
        **kwargs: Any
    ) -> _models.SearchAddressResult:
        """**Applies to:** see `pricing tiers <https://aka.ms/AzureMapsPricingTier>`_.

        The Search Along Route endpoint allows you to perform a fuzzy search for POIs along a specified
        route. This search is constrained by specifying the ``maxDetourTime`` limiting
        measure.:code:`<br>`:code:`<br>`To send the route-points you will use a ``POST`` request where
        the request body will contain the ``route`` object represented as a ``GeoJSON LineString`` type
        and the ``Content-Type`` header will be set to ``application/json``. Each route-point in
        ``route`` is represented as a ``GeoJSON Position`` type i.e. an array where the *longitude*
        value is followed by the *latitude* value and the *altitude* value is ignored. The ``route``
        should contain at least 2 route-points.:code:`<br>`:code:`<br>`It is possible that original
        route will be altered, some of it's points may be skipped. If the route that passes through the
        found point is faster than the original one, the ``detourTime`` value in the response is
        negative.

        :param route: This represents the route to search along and should be a valid ``GeoJSON
         LineString`` type. Please refer to `RFC 7946
         <https://tools.ietf.org/html/rfc7946#section-3.1.4>`_ for details. Is either a
         SearchAlongRouteRequest type or a IO[bytes] type. Required.
        :type route: ~azure.maps.search.models.SearchAlongRouteRequest or IO[bytes]
        :param format: Desired format of the response. Value can be either *json* or *xml*. Known
         values are: "json" and "xml". Default value is "json".
        :type format: str or ~azure.maps.search.models.ResponseFormat
        :keyword query: The POI name to search for (e.g., "statue of liberty", "starbucks", "pizza").
         Must be properly URL encoded. Required.
        :paramtype query: str
        :keyword max_detour_time: Maximum detour time of the point of interest in seconds. Max value is
         3600 seconds. Required.
        :paramtype max_detour_time: int
        :keyword top: Maximum number of responses that will be returned. Default value is 10. Max value
         is 20. Default value is None.
        :paramtype top: int
        :keyword brand_filter: A comma-separated list of brand names which could be used to restrict
         the result to specific brands. Item order does not matter. When multiple brands are provided,
         only results that belong to (at least) one of the provided list will be returned. Brands that
         contain a "," in their name should be put into quotes.

         Usage examples:

          brandSet=Foo

          brandSet=Foo,Bar

          brandSet="A,B,C Comma",Bar. Default value is None.
        :paramtype brand_filter: list[str]
        :keyword category_filter: A comma-separated list of category set IDs which could be used to
         restrict the result to specific Points of Interest categories. ID order does not matter.
         Maximum number of ``categorySet`` values supported per request is 10. When multiple category
         identifiers are provided, only POIs that belong to (at least) one of the categories from the
         provided list will be returned. The list of supported categories can be discovered using `POI
         Categories API <https://aka.ms/AzureMapsPOICategoryTree>`_. Usage examples:


         *
           **categorySet=7315** (Search Points of Interest from category Restaurant)

         *
           **categorySet=7315025,7315017** (Search Points of Interest of category either Italian or
         French Restaurant). Default value is None.
        :paramtype category_filter: list[int]
        :keyword electric_vehicle_connector_filter: A comma-separated list of connector types which
         could be used to restrict the result to Electric Vehicle Station supporting specific connector
         types. Item order does not matter. When multiple connector types are provided, only results
         that belong to (at least) one of the provided list will be returned.

         Available connector types are:


         * ``StandardHouseholdCountrySpecific`` - These are the standard household connectors for a
         certain region. They are all AC single phase and the standard Voltage and standard Amperage.
         See also: `Plug & socket types - World Standards
         <https://www.worldstandards.eu/electricity/plugs-and-sockets>`_.
         * ``IEC62196Type1`` - Type 1 connector as defined in the IEC 62196-2 standard. Also called
         Yazaki after the original manufacturer or SAE J1772 after the standard that first published it.
         Mostly used in combination with 120V single phase or up to 240V single phase infrastructure.
         * ``IEC62196Type1CCS`` - Type 1 based combo connector as defined in the IEC 62196-3 standard.
         The connector is based on the Type 1 connector – as defined in the IEC 62196-2 standard – with
         two additional direct current (DC) contacts to allow DC fast charging.
         * ``IEC62196Type2CableAttached`` - Type 2 connector as defined in the IEC 62196-2 standard.
         Provided as a cable and plug attached to the charging point.
         * ``IEC62196Type2Outlet`` - Type 2 connector as defined in the IEC 62196-2 standard. Provided
         as a socket set into the charging point.
         * ``IEC62196Type2CCS`` - Type 2 based combo connector as defined in the IEC 62196-3 standard.
         The connector is based on the Type 2 connector – as defined in the IEC 62196-2 standard – with
         two additional direct current (DC) contacts to allow DC fast charging.
         * ``IEC62196Type3`` - Type 3 connector as defined in the IEC 62196-2 standard. Also called
         Scame after the original manufacturer. Mostly used in combination with up to 240V single phase
         or up to 420V three phase infrastructure.
         * ``Chademo`` - CHAdeMO connector named after an association formed by the Tokyo Electric
         Power Company and industrial partners. Because of this is is also known as the TEPCO's
         connector. It supports fast DC charging.
         * ``IEC60309AC1PhaseBlue`` - Industrial Blue connector is a connector defined in the IEC 60309
         standard. It is sometime referred to as by some combination of the standard, the color and the
         fact that is a single phase connector. The connector usually has the "P+N+E, 6h" configuration.
         * ``IEC60309DCWhite`` - Industrial White connector is a DC connector defined in the IEC 60309
         standard.
         * ``Tesla`` - The Tesla connector is the regionally specific Tesla Supercharger connector.
         I.e. it refers to either Tesla's proprietary connector, sometimes referred to as Tesla Port
         mostly limited to North America or the modified Type 2 (DC over Type 2) in Europe.

         Usage examples:

          connectorSet=IEC62196Type2CableAttached
          connectorSet=IEC62196Type2Outlet,IEC62196Type2CableAttached. Default value is None.
        :paramtype electric_vehicle_connector_filter: list[str or
         ~azure.maps.search.models.ElectricVehicleConnector]
        :keyword localized_map_view: The View parameter (also called the "user region" parameter)
         allows you to show the correct maps for a certain country/region for geopolitically disputed
         regions. Different countries/regions have different views of such regions, and the View
         parameter allows your application to comply with the view required by the country/region your
         application will be serving. By default, the View parameter is set to “Unified” even if you
         haven’t defined it in  the request. It is your responsibility to determine the location of your
         users, and then set the View parameter correctly for that location. Alternatively, you have the
         option to set ‘View=Auto’, which will return the map data based on the IP  address of the
         request. The View parameter in Azure Maps must be used in compliance with applicable laws,
         including those  regarding mapping, of the country/region where maps, images and other data and
         third party content that you are authorized to  access via Azure Maps is made available.
         Example: view=IN.

         Please refer to `Supported Views <https://aka.ms/AzureMapsLocalizationViews>`_ for details and
         to see the available Views. Known values are: "AE", "AR", "BH", "IN", "IQ", "JO", "KW", "LB",
         "MA", "OM", "PK", "PS", "QA", "SA", "SY", "YE", "Auto", and "Unified". Default value is None.
        :paramtype localized_map_view: str or ~azure.maps.search.models.LocalizedMapView
        :keyword operating_hours: Hours of operation for a POI (Points of Interest). The availability
         of hours of operation will vary based on the data available. If not passed, then no opening
         hours information will be returned.
         Supported value: nextSevenDays. "nextSevenDays" Default value is None.
        :paramtype operating_hours: str or ~azure.maps.search.models.OperatingHoursRange
        :return: SearchAddressResult
        :rtype: ~azure.maps.search.models.SearchAddressResult
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[_models.SearchAddressResult] = kwargs.pop("cls", None)

        content_type = content_type or "application/json"
        _json = None
        _content = None
        if isinstance(route, (IOBase, bytes)):
            _content = route
        else:
            _json = self._serialize.body(route, "SearchAlongRouteRequest")

        _request = build_search_search_along_route_request(
            format=format,
            query=query,
            max_detour_time=max_detour_time,
            top=top,
            brand_filter=brand_filter,
            category_filter=category_filter,
            electric_vehicle_connector_filter=electric_vehicle_connector_filter,
            localized_map_view=localized_map_view,
            operating_hours=operating_hours,
            client_id=self._config.client_id,
            content_type=content_type,
            api_version=self._config.api_version,
            json=_json,
            content=_content,
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = False
        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                response.read()  # Load the body in memory and close the socket
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize.failsafe_deserialize(_models.ErrorResponse, pipeline_response)
            raise HttpResponseError(response=response, model=error)

        deserialized = self._deserialize("SearchAddressResult", pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore

    @overload
    def fuzzy_search_batch_sync(
        self,
        batch_request: _models.BatchRequest,
        format: Union[str, _models.JsonFormat] = "json",
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> _models.SearchAddressBatchResult:
        """**Search Fuzzy Batch API**

        **Applies to:** see `pricing tiers <https://aka.ms/AzureMapsPricingTier>`_.

        The Search Fuzzy Batch API sends batches of queries to `Search Fuzzy API
        </rest/api/maps/search/get-search-fuzzy?view=rest-maps-1.0>`_ using just a single API call. You
        can call Search Fuzzy Batch API to run either asynchronously (async) or synchronously (sync).
        The async API allows caller to batch up to **10,000** queries and sync API up to **100**
        queries.

        Submit Synchronous Batch Request
        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

        The Synchronous API is recommended for lightweight batch requests. When the service receives a
        request, it will respond as soon as the batch items are calculated and there will be no
        possibility to retrieve the results later. The Synchronous API will return a timeout error (a
        408 response) if the request takes longer than 60 seconds. The number of batch items is limited
        to **100** for this API.

        .. code-block::

           POST
        https://atlas.microsoft.com/search/fuzzy/batch/sync/json?api-version=1.0&subscription-key={subscription-key}

        Submit Asynchronous Batch Request
        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

        The Asynchronous API is appropriate for processing big volumes of relatively complex search
        requests


        * It allows the retrieval of results in a separate call (multiple downloads are possible).
        * The asynchronous API is optimized for reliability and is not expected to run into a timeout.
        * The number of batch items is limited to **10,000** for this API.

        When you make a request by using async request, by default the service returns a 202 response
        code along a redirect URL in the Location field of the response header. This URL should be
        checked periodically until the response data or error information is available.
        The asynchronous responses are stored for **14** days. The redirect URL returns a 404 response
        if used after the expiration period.

        Please note that asynchronous batch request is a long-running operation. Here's a typical
        sequence of operations:


        #. Client sends a Search Fuzzy Batch ``POST`` request to Azure Maps
        #.
           The server will respond with one of the following:

           ..

              HTTP ``202 Accepted`` - Batch request has been accepted.

              HTTP ``Error`` - There was an error processing your Batch request. This could either be a
        ``400 Bad Request`` or any other ``Error`` status code.


        #.
           If the batch request was accepted successfully, the ``Location`` header in the response
        contains the URL to download the results of the batch request.
            This status URI looks like following:

        .. code-block::

               GET
        https://atlas.microsoft.com/search/fuzzy/batch/{batch-id}?api-version=1.0&subscription-key={subscription-key}


        #. Client issues a ``GET`` request on the *download URL* obtained in Step 3 to download the
        batch results.

        POST Body for Batch Request
        ^^^^^^^^^^^^^^^^^^^^^^^^^^^

        To send the *search fuzzy* queries you will use a ``POST`` request where the request body will
        contain the ``batchItems`` array in ``json`` format and the ``Content-Type`` header will be set
        to ``application/json``. Here's a sample request body containing 5 *search fuzzy* queries:

        .. code-block:: json

           {
               "batchItems": [
                   {"query": "?query=atm&lat=47.639769&lon=-122.128362&radius=5000&limit=5"},
                   {"query": "?query=Statue Of Liberty&limit=2"},
                   {"query": "?query=Starbucks&lat=47.639769&lon=-122.128362&radius=5000"},
                   {"query": "?query=Space Needle"},
                   {"query": "?query=pizza&limit=10"}
               ]
           }

        A *search fuzzy* query in a batch is just a partial URL *without* the protocol, base URL, path,
        api-version and subscription-key. It can accept any of the supported *search fuzzy* `URI
        parameters </rest/api/maps/search/get-search-fuzzy?view=rest-maps-1.0#uri-parameters>`_. The
        string values in the *search fuzzy* query must be properly escaped (e.g. " character should be
        escaped with ) and it should also be properly URL-encoded.

        The async API allows caller to batch up to **10,000** queries and sync API up to **100**
        queries, and the batch should contain at least **1** query.

        Download Asynchronous Batch Results
        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

        To download the async batch results you will issue a ``GET`` request to the batch download
        endpoint. This *download URL* can be obtained from the ``Location`` header of a successful
        ``POST`` batch request and looks like the following:

        .. code-block::

        https://atlas.microsoft.com/search/fuzzy/batch/{batch-id}?api-version=1.0&subscription-key={subscription-key}

        Here's the typical sequence of operations for downloading the batch results:


        #. Client sends a ``GET`` request using the *download URL*.
        #.
           The server will respond with one of the following:

           ..

              HTTP ``202 Accepted`` - Batch request was accepted but is still being processed. Please
        try again in some time.

              HTTP ``200 OK`` - Batch request successfully processed. The response body contains all
        the batch results.


        Batch Response Model
        ^^^^^^^^^^^^^^^^^^^^

        The returned data content is similar for async and sync requests. When downloading the results
        of an async batch request, if the batch has finished processing, the response body contains the
        batch response. This batch response contains a ``summary`` component that indicates the
        ``totalRequests`` that were part of the original batch request and ``successfulRequests``\ i.e.
        queries which were executed successfully. The batch response also includes a ``batchItems``
        array which contains a response for each and every query in the batch request. The
        ``batchItems`` will contain the results in the exact same order the original queries were sent
        in the batch request. Each item in ``batchItems`` contains ``statusCode`` and ``response``
        fields. Each ``response`` in ``batchItems`` is of one of the following types:


        *
          `\ ``SearchAddressResult``
        </rest/api/maps/search/get-search-fuzzy?view=rest-maps-1.0#SearchAddressResult>`_ - If the
        query completed successfully.

        *
          ``Error`` - If the query failed. The response will contain a ``code`` and a ``message`` in
        this case.

        Here's a sample Batch Response with 2 *successful* and 1 *failed* result:

        .. code-block:: json

           {
               "summary": {
                   "successfulRequests": 2,
                   "totalRequests": 3
               },
               "batchItems": [
                   {
                       "statusCode": 200,
                       "response":
                       {
                           "summary": {
                               "query": "atm"
                           },
                           "results": [
                               {
                                   "type": "POI",
                                   "poi": {
                                       "name": "ATM at Wells Fargo"
                                   },
                                   "address": {
                                       "country": "United States Of America",
                                       "freeformAddress": "3240 157th Ave NE, Redmond, WA 98052"
                                   }
                               }
                           ]
                       }
                   },
                   {
                       "statusCode": 200,
                       "response":
                       {
                           "summary": {
                               "query": "statue of liberty"
                           },
                           "results": [
                               {
                                   "type": "POI",
                                   "poi": {
                                       "name": "Statue of Liberty"
                                   },
                                   "address": {
                                       "country": "United States Of America",
                                       "freeformAddress": "New York, NY 10004"
                                   }
                               }
                           ]
                       }
                   },
                   {
                       "statusCode": 400,
                       "response":
                       {
                           "error":
                           {
                               "code": "400 BadRequest",
                               "message": "Bad request: one or more parameters were incorrectly
        specified or are mutually exclusive."
                           }
                       }
                   }
               ]
           }.

        :param batch_request: The list of search fuzzy queries/requests to process. The list can
         contain  a max of 10,000 queries and must contain at least 1 query. Required.
        :type batch_request: ~azure.maps.search.models.BatchRequest
        :param format: Desired format of the response. Only ``json`` format is supported. "json"
         Default value is "json".
        :type format: str or ~azure.maps.search.models.JsonFormat
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: SearchAddressBatchResult
        :rtype: ~azure.maps.search.models.SearchAddressBatchResult
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @overload
    def fuzzy_search_batch_sync(
        self,
        batch_request: IO[bytes],
        format: Union[str, _models.JsonFormat] = "json",
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> _models.SearchAddressBatchResult:
        """**Search Fuzzy Batch API**

        **Applies to:** see `pricing tiers <https://aka.ms/AzureMapsPricingTier>`_.

        The Search Fuzzy Batch API sends batches of queries to `Search Fuzzy API
        </rest/api/maps/search/get-search-fuzzy?view=rest-maps-1.0>`_ using just a single API call. You
        can call Search Fuzzy Batch API to run either asynchronously (async) or synchronously (sync).
        The async API allows caller to batch up to **10,000** queries and sync API up to **100**
        queries.

        Submit Synchronous Batch Request
        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

        The Synchronous API is recommended for lightweight batch requests. When the service receives a
        request, it will respond as soon as the batch items are calculated and there will be no
        possibility to retrieve the results later. The Synchronous API will return a timeout error (a
        408 response) if the request takes longer than 60 seconds. The number of batch items is limited
        to **100** for this API.

        .. code-block::

           POST
        https://atlas.microsoft.com/search/fuzzy/batch/sync/json?api-version=1.0&subscription-key={subscription-key}

        Submit Asynchronous Batch Request
        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

        The Asynchronous API is appropriate for processing big volumes of relatively complex search
        requests


        * It allows the retrieval of results in a separate call (multiple downloads are possible).
        * The asynchronous API is optimized for reliability and is not expected to run into a timeout.
        * The number of batch items is limited to **10,000** for this API.

        When you make a request by using async request, by default the service returns a 202 response
        code along a redirect URL in the Location field of the response header. This URL should be
        checked periodically until the response data or error information is available.
        The asynchronous responses are stored for **14** days. The redirect URL returns a 404 response
        if used after the expiration period.

        Please note that asynchronous batch request is a long-running operation. Here's a typical
        sequence of operations:


        #. Client sends a Search Fuzzy Batch ``POST`` request to Azure Maps
        #.
           The server will respond with one of the following:

           ..

              HTTP ``202 Accepted`` - Batch request has been accepted.

              HTTP ``Error`` - There was an error processing your Batch request. This could either be a
        ``400 Bad Request`` or any other ``Error`` status code.


        #.
           If the batch request was accepted successfully, the ``Location`` header in the response
        contains the URL to download the results of the batch request.
            This status URI looks like following:

        .. code-block::

               GET
        https://atlas.microsoft.com/search/fuzzy/batch/{batch-id}?api-version=1.0&subscription-key={subscription-key}


        #. Client issues a ``GET`` request on the *download URL* obtained in Step 3 to download the
        batch results.

        POST Body for Batch Request
        ^^^^^^^^^^^^^^^^^^^^^^^^^^^

        To send the *search fuzzy* queries you will use a ``POST`` request where the request body will
        contain the ``batchItems`` array in ``json`` format and the ``Content-Type`` header will be set
        to ``application/json``. Here's a sample request body containing 5 *search fuzzy* queries:

        .. code-block:: json

           {
               "batchItems": [
                   {"query": "?query=atm&lat=47.639769&lon=-122.128362&radius=5000&limit=5"},
                   {"query": "?query=Statue Of Liberty&limit=2"},
                   {"query": "?query=Starbucks&lat=47.639769&lon=-122.128362&radius=5000"},
                   {"query": "?query=Space Needle"},
                   {"query": "?query=pizza&limit=10"}
               ]
           }

        A *search fuzzy* query in a batch is just a partial URL *without* the protocol, base URL, path,
        api-version and subscription-key. It can accept any of the supported *search fuzzy* `URI
        parameters </rest/api/maps/search/get-search-fuzzy?view=rest-maps-1.0#uri-parameters>`_. The
        string values in the *search fuzzy* query must be properly escaped (e.g. " character should be
        escaped with ) and it should also be properly URL-encoded.

        The async API allows caller to batch up to **10,000** queries and sync API up to **100**
        queries, and the batch should contain at least **1** query.

        Download Asynchronous Batch Results
        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

        To download the async batch results you will issue a ``GET`` request to the batch download
        endpoint. This *download URL* can be obtained from the ``Location`` header of a successful
        ``POST`` batch request and looks like the following:

        .. code-block::

        https://atlas.microsoft.com/search/fuzzy/batch/{batch-id}?api-version=1.0&subscription-key={subscription-key}

        Here's the typical sequence of operations for downloading the batch results:


        #. Client sends a ``GET`` request using the *download URL*.
        #.
           The server will respond with one of the following:

           ..

              HTTP ``202 Accepted`` - Batch request was accepted but is still being processed. Please
        try again in some time.

              HTTP ``200 OK`` - Batch request successfully processed. The response body contains all
        the batch results.


        Batch Response Model
        ^^^^^^^^^^^^^^^^^^^^

        The returned data content is similar for async and sync requests. When downloading the results
        of an async batch request, if the batch has finished processing, the response body contains the
        batch response. This batch response contains a ``summary`` component that indicates the
        ``totalRequests`` that were part of the original batch request and ``successfulRequests``\ i.e.
        queries which were executed successfully. The batch response also includes a ``batchItems``
        array which contains a response for each and every query in the batch request. The
        ``batchItems`` will contain the results in the exact same order the original queries were sent
        in the batch request. Each item in ``batchItems`` contains ``statusCode`` and ``response``
        fields. Each ``response`` in ``batchItems`` is of one of the following types:


        *
          `\ ``SearchAddressResult``
        </rest/api/maps/search/get-search-fuzzy?view=rest-maps-1.0#SearchAddressResult>`_ - If the
        query completed successfully.

        *
          ``Error`` - If the query failed. The response will contain a ``code`` and a ``message`` in
        this case.

        Here's a sample Batch Response with 2 *successful* and 1 *failed* result:

        .. code-block:: json

           {
               "summary": {
                   "successfulRequests": 2,
                   "totalRequests": 3
               },
               "batchItems": [
                   {
                       "statusCode": 200,
                       "response":
                       {
                           "summary": {
                               "query": "atm"
                           },
                           "results": [
                               {
                                   "type": "POI",
                                   "poi": {
                                       "name": "ATM at Wells Fargo"
                                   },
                                   "address": {
                                       "country": "United States Of America",
                                       "freeformAddress": "3240 157th Ave NE, Redmond, WA 98052"
                                   }
                               }
                           ]
                       }
                   },
                   {
                       "statusCode": 200,
                       "response":
                       {
                           "summary": {
                               "query": "statue of liberty"
                           },
                           "results": [
                               {
                                   "type": "POI",
                                   "poi": {
                                       "name": "Statue of Liberty"
                                   },
                                   "address": {
                                       "country": "United States Of America",
                                       "freeformAddress": "New York, NY 10004"
                                   }
                               }
                           ]
                       }
                   },
                   {
                       "statusCode": 400,
                       "response":
                       {
                           "error":
                           {
                               "code": "400 BadRequest",
                               "message": "Bad request: one or more parameters were incorrectly
        specified or are mutually exclusive."
                           }
                       }
                   }
               ]
           }.

        :param batch_request: The list of search fuzzy queries/requests to process. The list can
         contain  a max of 10,000 queries and must contain at least 1 query. Required.
        :type batch_request: IO[bytes]
        :param format: Desired format of the response. Only ``json`` format is supported. "json"
         Default value is "json".
        :type format: str or ~azure.maps.search.models.JsonFormat
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: SearchAddressBatchResult
        :rtype: ~azure.maps.search.models.SearchAddressBatchResult
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @distributed_trace
    def fuzzy_search_batch_sync(
        self,
        batch_request: Union[_models.BatchRequest, IO[bytes]],
        format: Union[str, _models.JsonFormat] = "json",
        **kwargs: Any
    ) -> _models.SearchAddressBatchResult:
        """**Search Fuzzy Batch API**

        **Applies to:** see `pricing tiers <https://aka.ms/AzureMapsPricingTier>`_.

        The Search Fuzzy Batch API sends batches of queries to `Search Fuzzy API
        </rest/api/maps/search/get-search-fuzzy?view=rest-maps-1.0>`_ using just a single API call. You
        can call Search Fuzzy Batch API to run either asynchronously (async) or synchronously (sync).
        The async API allows caller to batch up to **10,000** queries and sync API up to **100**
        queries.

        Submit Synchronous Batch Request
        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

        The Synchronous API is recommended for lightweight batch requests. When the service receives a
        request, it will respond as soon as the batch items are calculated and there will be no
        possibility to retrieve the results later. The Synchronous API will return a timeout error (a
        408 response) if the request takes longer than 60 seconds. The number of batch items is limited
        to **100** for this API.

        .. code-block::

           POST
        https://atlas.microsoft.com/search/fuzzy/batch/sync/json?api-version=1.0&subscription-key={subscription-key}

        Submit Asynchronous Batch Request
        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

        The Asynchronous API is appropriate for processing big volumes of relatively complex search
        requests


        * It allows the retrieval of results in a separate call (multiple downloads are possible).
        * The asynchronous API is optimized for reliability and is not expected to run into a timeout.
        * The number of batch items is limited to **10,000** for this API.

        When you make a request by using async request, by default the service returns a 202 response
        code along a redirect URL in the Location field of the response header. This URL should be
        checked periodically until the response data or error information is available.
        The asynchronous responses are stored for **14** days. The redirect URL returns a 404 response
        if used after the expiration period.

        Please note that asynchronous batch request is a long-running operation. Here's a typical
        sequence of operations:


        #. Client sends a Search Fuzzy Batch ``POST`` request to Azure Maps
        #.
           The server will respond with one of the following:

           ..

              HTTP ``202 Accepted`` - Batch request has been accepted.

              HTTP ``Error`` - There was an error processing your Batch request. This could either be a
        ``400 Bad Request`` or any other ``Error`` status code.


        #.
           If the batch request was accepted successfully, the ``Location`` header in the response
        contains the URL to download the results of the batch request.
            This status URI looks like following:

        .. code-block::

               GET
        https://atlas.microsoft.com/search/fuzzy/batch/{batch-id}?api-version=1.0&subscription-key={subscription-key}


        #. Client issues a ``GET`` request on the *download URL* obtained in Step 3 to download the
        batch results.

        POST Body for Batch Request
        ^^^^^^^^^^^^^^^^^^^^^^^^^^^

        To send the *search fuzzy* queries you will use a ``POST`` request where the request body will
        contain the ``batchItems`` array in ``json`` format and the ``Content-Type`` header will be set
        to ``application/json``. Here's a sample request body containing 5 *search fuzzy* queries:

        .. code-block:: json

           {
               "batchItems": [
                   {"query": "?query=atm&lat=47.639769&lon=-122.128362&radius=5000&limit=5"},
                   {"query": "?query=Statue Of Liberty&limit=2"},
                   {"query": "?query=Starbucks&lat=47.639769&lon=-122.128362&radius=5000"},
                   {"query": "?query=Space Needle"},
                   {"query": "?query=pizza&limit=10"}
               ]
           }

        A *search fuzzy* query in a batch is just a partial URL *without* the protocol, base URL, path,
        api-version and subscription-key. It can accept any of the supported *search fuzzy* `URI
        parameters </rest/api/maps/search/get-search-fuzzy?view=rest-maps-1.0#uri-parameters>`_. The
        string values in the *search fuzzy* query must be properly escaped (e.g. " character should be
        escaped with ) and it should also be properly URL-encoded.

        The async API allows caller to batch up to **10,000** queries and sync API up to **100**
        queries, and the batch should contain at least **1** query.

        Download Asynchronous Batch Results
        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

        To download the async batch results you will issue a ``GET`` request to the batch download
        endpoint. This *download URL* can be obtained from the ``Location`` header of a successful
        ``POST`` batch request and looks like the following:

        .. code-block::

        https://atlas.microsoft.com/search/fuzzy/batch/{batch-id}?api-version=1.0&subscription-key={subscription-key}

        Here's the typical sequence of operations for downloading the batch results:


        #. Client sends a ``GET`` request using the *download URL*.
        #.
           The server will respond with one of the following:

           ..

              HTTP ``202 Accepted`` - Batch request was accepted but is still being processed. Please
        try again in some time.

              HTTP ``200 OK`` - Batch request successfully processed. The response body contains all
        the batch results.


        Batch Response Model
        ^^^^^^^^^^^^^^^^^^^^

        The returned data content is similar for async and sync requests. When downloading the results
        of an async batch request, if the batch has finished processing, the response body contains the
        batch response. This batch response contains a ``summary`` component that indicates the
        ``totalRequests`` that were part of the original batch request and ``successfulRequests``\ i.e.
        queries which were executed successfully. The batch response also includes a ``batchItems``
        array which contains a response for each and every query in the batch request. The
        ``batchItems`` will contain the results in the exact same order the original queries were sent
        in the batch request. Each item in ``batchItems`` contains ``statusCode`` and ``response``
        fields. Each ``response`` in ``batchItems`` is of one of the following types:


        *
          `\ ``SearchAddressResult``
        </rest/api/maps/search/get-search-fuzzy?view=rest-maps-1.0#SearchAddressResult>`_ - If the
        query completed successfully.

        *
          ``Error`` - If the query failed. The response will contain a ``code`` and a ``message`` in
        this case.

        Here's a sample Batch Response with 2 *successful* and 1 *failed* result:

        .. code-block:: json

           {
               "summary": {
                   "successfulRequests": 2,
                   "totalRequests": 3
               },
               "batchItems": [
                   {
                       "statusCode": 200,
                       "response":
                       {
                           "summary": {
                               "query": "atm"
                           },
                           "results": [
                               {
                                   "type": "POI",
                                   "poi": {
                                       "name": "ATM at Wells Fargo"
                                   },
                                   "address": {
                                       "country": "United States Of America",
                                       "freeformAddress": "3240 157th Ave NE, Redmond, WA 98052"
                                   }
                               }
                           ]
                       }
                   },
                   {
                       "statusCode": 200,
                       "response":
                       {
                           "summary": {
                               "query": "statue of liberty"
                           },
                           "results": [
                               {
                                   "type": "POI",
                                   "poi": {
                                       "name": "Statue of Liberty"
                                   },
                                   "address": {
                                       "country": "United States Of America",
                                       "freeformAddress": "New York, NY 10004"
                                   }
                               }
                           ]
                       }
                   },
                   {
                       "statusCode": 400,
                       "response":
                       {
                           "error":
                           {
                               "code": "400 BadRequest",
                               "message": "Bad request: one or more parameters were incorrectly
        specified or are mutually exclusive."
                           }
                       }
                   }
               ]
           }.

        :param batch_request: The list of search fuzzy queries/requests to process. The list can
         contain  a max of 10,000 queries and must contain at least 1 query. Is either a BatchRequest
         type or a IO[bytes] type. Required.
        :type batch_request: ~azure.maps.search.models.BatchRequest or IO[bytes]
        :param format: Desired format of the response. Only ``json`` format is supported. "json"
         Default value is "json".
        :type format: str or ~azure.maps.search.models.JsonFormat
        :return: SearchAddressBatchResult
        :rtype: ~azure.maps.search.models.SearchAddressBatchResult
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
            408: lambda response: HttpResponseError(
                response=response, model=self._deserialize(_models.ErrorResponse, response)
            ),
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[_models.SearchAddressBatchResult] = kwargs.pop("cls", None)

        content_type = content_type or "application/json"
        _json = None
        _content = None
        if isinstance(batch_request, (IOBase, bytes)):
            _content = batch_request
        else:
            _json = self._serialize.body(batch_request, "BatchRequest")

        _request = build_search_fuzzy_search_batch_sync_request(
            format=format,
            client_id=self._config.client_id,
            content_type=content_type,
            api_version=self._config.api_version,
            json=_json,
            content=_content,
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = False
        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                response.read()  # Load the body in memory and close the socket
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize.failsafe_deserialize(_models.ErrorResponse, pipeline_response)
            raise HttpResponseError(response=response, model=error)

        deserialized = self._deserialize("SearchAddressBatchResult", pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore

    def _fuzzy_search_batch_initial(
        self,
        batch_request: Union[_models.BatchRequest, IO[bytes]],
        format: Union[str, _models.JsonFormat] = "json",
        **kwargs: Any
    ) -> Optional[_models.SearchAddressBatchResult]:
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[Optional[_models.SearchAddressBatchResult]] = kwargs.pop("cls", None)

        content_type = content_type or "application/json"
        _json = None
        _content = None
        if isinstance(batch_request, (IOBase, bytes)):
            _content = batch_request
        else:
            _json = self._serialize.body(batch_request, "BatchRequest")

        _request = build_search_fuzzy_search_batch_request(
            format=format,
            client_id=self._config.client_id,
            content_type=content_type,
            api_version=self._config.api_version,
            json=_json,
            content=_content,
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = False
        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200, 202]:
            if _stream:
                response.read()  # Load the body in memory and close the socket
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        deserialized = None
        response_headers = {}
        if response.status_code == 200:
            deserialized = self._deserialize("SearchAddressBatchResult", pipeline_response)

        if response.status_code == 202:
            response_headers["Location"] = self._deserialize("str", response.headers.get("Location"))

        if cls:
            return cls(pipeline_response, deserialized, response_headers)  # type: ignore

        return deserialized  # type: ignore

    @overload
    def begin_fuzzy_search_batch(
        self,
        batch_request: _models.BatchRequest,
        format: Union[str, _models.JsonFormat] = "json",
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> LROPoller[_models.SearchAddressBatchResult]:
        """**Search Fuzzy Batch API**

        **Applies to:** see `pricing tiers <https://aka.ms/AzureMapsPricingTier>`_.

        The Search Fuzzy Batch API sends batches of queries to `Search Fuzzy API
        </rest/api/maps/search/get-search-fuzzy?view=rest-maps-1.0>`_ using just a single API call. You
        can call Search Fuzzy Batch API to run either asynchronously (async) or synchronously (sync).
        The async API allows caller to batch up to **10,000** queries and sync API up to **100**
        queries.

        Submit Synchronous Batch Request
        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

        The Synchronous API is recommended for lightweight batch requests. When the service receives a
        request, it will respond as soon as the batch items are calculated and there will be no
        possibility to retrieve the results later. The Synchronous API will return a timeout error (a
        408 response) if the request takes longer than 60 seconds. The number of batch items is limited
        to **100** for this API.

        .. code-block::

           POST
        https://atlas.microsoft.com/search/fuzzy/batch/sync/json?api-version=1.0&subscription-key={subscription-key}

        Submit Asynchronous Batch Request
        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

        The Asynchronous API is appropriate for processing big volumes of relatively complex search
        requests


        * It allows the retrieval of results in a separate call (multiple downloads are possible).
        * The asynchronous API is optimized for reliability and is not expected to run into a timeout.
        * The number of batch items is limited to **10,000** for this API.

        When you make a request by using async request, by default the service returns a 202 response
        code along a redirect URL in the Location field of the response header. This URL should be
        checked periodically until the response data or error information is available.
        The asynchronous responses are stored for **14** days. The redirect URL returns a 404 response
        if used after the expiration period.

        Please note that asynchronous batch request is a long-running operation. Here's a typical
        sequence of operations:


        #. Client sends a Search Fuzzy Batch ``POST`` request to Azure Maps
        #.
           The server will respond with one of the following:

           ..

              HTTP ``202 Accepted`` - Batch request has been accepted.

              HTTP ``Error`` - There was an error processing your Batch request. This could either be a
        ``400 Bad Request`` or any other ``Error`` status code.


        #.
           If the batch request was accepted successfully, the ``Location`` header in the response
        contains the URL to download the results of the batch request.
            This status URI looks like following:

        .. code-block::

               GET
        https://atlas.microsoft.com/search/fuzzy/batch/{batch-id}?api-version=1.0&subscription-key={subscription-key}


        #. Client issues a ``GET`` request on the *download URL* obtained in Step 3 to download the
        batch results.

        POST Body for Batch Request
        ^^^^^^^^^^^^^^^^^^^^^^^^^^^

        To send the *search fuzzy* queries you will use a ``POST`` request where the request body will
        contain the ``batchItems`` array in ``json`` format and the ``Content-Type`` header will be set
        to ``application/json``. Here's a sample request body containing 5 *search fuzzy* queries:

        .. code-block:: json

           {
               "batchItems": [
                   {"query": "?query=atm&lat=47.639769&lon=-122.128362&radius=5000&limit=5"},
                   {"query": "?query=Statue Of Liberty&limit=2"},
                   {"query": "?query=Starbucks&lat=47.639769&lon=-122.128362&radius=5000"},
                   {"query": "?query=Space Needle"},
                   {"query": "?query=pizza&limit=10"}
               ]
           }

        A *search fuzzy* query in a batch is just a partial URL *without* the protocol, base URL, path,
        api-version and subscription-key. It can accept any of the supported *search fuzzy* `URI
        parameters </rest/api/maps/search/get-search-fuzzy?view=rest-maps-1.0#uri-parameters>`_. The
        string values in the *search fuzzy* query must be properly escaped (e.g. " character should be
        escaped with ) and it should also be properly URL-encoded.

        The async API allows caller to batch up to **10,000** queries and sync API up to **100**
        queries, and the batch should contain at least **1** query.

        Download Asynchronous Batch Results
        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

        To download the async batch results you will issue a ``GET`` request to the batch download
        endpoint. This *download URL* can be obtained from the ``Location`` header of a successful
        ``POST`` batch request and looks like the following:

        .. code-block::

        https://atlas.microsoft.com/search/fuzzy/batch/{batch-id}?api-version=1.0&subscription-key={subscription-key}

        Here's the typical sequence of operations for downloading the batch results:


        #. Client sends a ``GET`` request using the *download URL*.
        #.
           The server will respond with one of the following:

           ..

              HTTP ``202 Accepted`` - Batch request was accepted but is still being processed. Please
        try again in some time.

              HTTP ``200 OK`` - Batch request successfully processed. The response body contains all
        the batch results.


        Batch Response Model
        ^^^^^^^^^^^^^^^^^^^^

        The returned data content is similar for async and sync requests. When downloading the results
        of an async batch request, if the batch has finished processing, the response body contains the
        batch response. This batch response contains a ``summary`` component that indicates the
        ``totalRequests`` that were part of the original batch request and ``successfulRequests``\ i.e.
        queries which were executed successfully. The batch response also includes a ``batchItems``
        array which contains a response for each and every query in the batch request. The
        ``batchItems`` will contain the results in the exact same order the original queries were sent
        in the batch request. Each item in ``batchItems`` contains ``statusCode`` and ``response``
        fields. Each ``response`` in ``batchItems`` is of one of the following types:


        *
          `\ ``SearchAddressResult``
        </rest/api/maps/search/get-search-fuzzy?view=rest-maps-1.0#searchaddressresult>`_ - If the
        query completed successfully.

        *
          ``Error`` - If the query failed. The response will contain a ``code`` and a ``message`` in
        this case.

        Here's a sample Batch Response with 2 *successful* and 1 *failed* result:

        .. code-block:: json

           {
               "summary": {
                   "successfulRequests": 2,
                   "totalRequests": 3
               },
               "batchItems": [
                   {
                       "statusCode": 200,
                       "response":
                       {
                           "summary": {
                               "query": "atm"
                           },
                           "results": [
                               {
                                   "type": "POI",
                                   "poi": {
                                       "name": "ATM at Wells Fargo"
                                   },
                                   "address": {
                                       "country": "United States Of America",
                                       "freeformAddress": "3240 157th Ave NE, Redmond, WA 98052"
                                   }
                               }
                           ]
                       }
                   },
                   {
                       "statusCode": 200,
                       "response":
                       {
                           "summary": {
                               "query": "statue of liberty"
                           },
                           "results": [
                               {
                                   "type": "POI",
                                   "poi": {
                                       "name": "Statue of Liberty"
                                   },
                                   "address": {
                                       "country": "United States Of America",
                                       "freeformAddress": "New York, NY 10004"
                                   }
                               }
                           ]
                       }
                   },
                   {
                       "statusCode": 400,
                       "response":
                       {
                           "error":
                           {
                               "code": "400 BadRequest",
                               "message": "Bad request: one or more parameters were incorrectly
        specified or are mutually exclusive."
                           }
                       }
                   }
               ]
           }.

        :param batch_request: The list of search fuzzy queries/requests to process. The list can
         contain a max of 10,000 queries and must contain at least 1 query. Required.
        :type batch_request: ~azure.maps.search.models.BatchRequest
        :param format: Desired format of the response. Only ``json`` format is supported. "json"
         Default value is "json".
        :type format: str or ~azure.maps.search.models.JsonFormat
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: An instance of LROPoller that returns SearchAddressBatchResult
        :rtype: ~azure.core.polling.LROPoller[~azure.maps.search.models.SearchAddressBatchResult]
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @overload
    def begin_fuzzy_search_batch(
        self,
        batch_request: IO[bytes],
        format: Union[str, _models.JsonFormat] = "json",
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> LROPoller[_models.SearchAddressBatchResult]:
        """**Search Fuzzy Batch API**

        **Applies to:** see `pricing tiers <https://aka.ms/AzureMapsPricingTier>`_.

        The Search Fuzzy Batch API sends batches of queries to `Search Fuzzy API
        </rest/api/maps/search/get-search-fuzzy?view=rest-maps-1.0>`_ using just a single API call. You
        can call Search Fuzzy Batch API to run either asynchronously (async) or synchronously (sync).
        The async API allows caller to batch up to **10,000** queries and sync API up to **100**
        queries.

        Submit Synchronous Batch Request
        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

        The Synchronous API is recommended for lightweight batch requests. When the service receives a
        request, it will respond as soon as the batch items are calculated and there will be no
        possibility to retrieve the results later. The Synchronous API will return a timeout error (a
        408 response) if the request takes longer than 60 seconds. The number of batch items is limited
        to **100** for this API.

        .. code-block::

           POST
        https://atlas.microsoft.com/search/fuzzy/batch/sync/json?api-version=1.0&subscription-key={subscription-key}

        Submit Asynchronous Batch Request
        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

        The Asynchronous API is appropriate for processing big volumes of relatively complex search
        requests


        * It allows the retrieval of results in a separate call (multiple downloads are possible).
        * The asynchronous API is optimized for reliability and is not expected to run into a timeout.
        * The number of batch items is limited to **10,000** for this API.

        When you make a request by using async request, by default the service returns a 202 response
        code along a redirect URL in the Location field of the response header. This URL should be
        checked periodically until the response data or error information is available.
        The asynchronous responses are stored for **14** days. The redirect URL returns a 404 response
        if used after the expiration period.

        Please note that asynchronous batch request is a long-running operation. Here's a typical
        sequence of operations:


        #. Client sends a Search Fuzzy Batch ``POST`` request to Azure Maps
        #.
           The server will respond with one of the following:

           ..

              HTTP ``202 Accepted`` - Batch request has been accepted.

              HTTP ``Error`` - There was an error processing your Batch request. This could either be a
        ``400 Bad Request`` or any other ``Error`` status code.


        #.
           If the batch request was accepted successfully, the ``Location`` header in the response
        contains the URL to download the results of the batch request.
            This status URI looks like following:

        .. code-block::

               GET
        https://atlas.microsoft.com/search/fuzzy/batch/{batch-id}?api-version=1.0&subscription-key={subscription-key}


        #. Client issues a ``GET`` request on the *download URL* obtained in Step 3 to download the
        batch results.

        POST Body for Batch Request
        ^^^^^^^^^^^^^^^^^^^^^^^^^^^

        To send the *search fuzzy* queries you will use a ``POST`` request where the request body will
        contain the ``batchItems`` array in ``json`` format and the ``Content-Type`` header will be set
        to ``application/json``. Here's a sample request body containing 5 *search fuzzy* queries:

        .. code-block:: json

           {
               "batchItems": [
                   {"query": "?query=atm&lat=47.639769&lon=-122.128362&radius=5000&limit=5"},
                   {"query": "?query=Statue Of Liberty&limit=2"},
                   {"query": "?query=Starbucks&lat=47.639769&lon=-122.128362&radius=5000"},
                   {"query": "?query=Space Needle"},
                   {"query": "?query=pizza&limit=10"}
               ]
           }

        A *search fuzzy* query in a batch is just a partial URL *without* the protocol, base URL, path,
        api-version and subscription-key. It can accept any of the supported *search fuzzy* `URI
        parameters </rest/api/maps/search/get-search-fuzzy?view=rest-maps-1.0#uri-parameters>`_. The
        string values in the *search fuzzy* query must be properly escaped (e.g. " character should be
        escaped with ) and it should also be properly URL-encoded.

        The async API allows caller to batch up to **10,000** queries and sync API up to **100**
        queries, and the batch should contain at least **1** query.

        Download Asynchronous Batch Results
        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

        To download the async batch results you will issue a ``GET`` request to the batch download
        endpoint. This *download URL* can be obtained from the ``Location`` header of a successful
        ``POST`` batch request and looks like the following:

        .. code-block::

        https://atlas.microsoft.com/search/fuzzy/batch/{batch-id}?api-version=1.0&subscription-key={subscription-key}

        Here's the typical sequence of operations for downloading the batch results:


        #. Client sends a ``GET`` request using the *download URL*.
        #.
           The server will respond with one of the following:

           ..

              HTTP ``202 Accepted`` - Batch request was accepted but is still being processed. Please
        try again in some time.

              HTTP ``200 OK`` - Batch request successfully processed. The response body contains all
        the batch results.


        Batch Response Model
        ^^^^^^^^^^^^^^^^^^^^

        The returned data content is similar for async and sync requests. When downloading the results
        of an async batch request, if the batch has finished processing, the response body contains the
        batch response. This batch response contains a ``summary`` component that indicates the
        ``totalRequests`` that were part of the original batch request and ``successfulRequests``\ i.e.
        queries which were executed successfully. The batch response also includes a ``batchItems``
        array which contains a response for each and every query in the batch request. The
        ``batchItems`` will contain the results in the exact same order the original queries were sent
        in the batch request. Each item in ``batchItems`` contains ``statusCode`` and ``response``
        fields. Each ``response`` in ``batchItems`` is of one of the following types:


        *
          `\ ``SearchAddressResult``
        </rest/api/maps/search/get-search-fuzzy?view=rest-maps-1.0#searchaddressresult>`_ - If the
        query completed successfully.

        *
          ``Error`` - If the query failed. The response will contain a ``code`` and a ``message`` in
        this case.

        Here's a sample Batch Response with 2 *successful* and 1 *failed* result:

        .. code-block:: json

           {
               "summary": {
                   "successfulRequests": 2,
                   "totalRequests": 3
               },
               "batchItems": [
                   {
                       "statusCode": 200,
                       "response":
                       {
                           "summary": {
                               "query": "atm"
                           },
                           "results": [
                               {
                                   "type": "POI",
                                   "poi": {
                                       "name": "ATM at Wells Fargo"
                                   },
                                   "address": {
                                       "country": "United States Of America",
                                       "freeformAddress": "3240 157th Ave NE, Redmond, WA 98052"
                                   }
                               }
                           ]
                       }
                   },
                   {
                       "statusCode": 200,
                       "response":
                       {
                           "summary": {
                               "query": "statue of liberty"
                           },
                           "results": [
                               {
                                   "type": "POI",
                                   "poi": {
                                       "name": "Statue of Liberty"
                                   },
                                   "address": {
                                       "country": "United States Of America",
                                       "freeformAddress": "New York, NY 10004"
                                   }
                               }
                           ]
                       }
                   },
                   {
                       "statusCode": 400,
                       "response":
                       {
                           "error":
                           {
                               "code": "400 BadRequest",
                               "message": "Bad request: one or more parameters were incorrectly
        specified or are mutually exclusive."
                           }
                       }
                   }
               ]
           }.

        :param batch_request: The list of search fuzzy queries/requests to process. The list can
         contain a max of 10,000 queries and must contain at least 1 query. Required.
        :type batch_request: IO[bytes]
        :param format: Desired format of the response. Only ``json`` format is supported. "json"
         Default value is "json".
        :type format: str or ~azure.maps.search.models.JsonFormat
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: An instance of LROPoller that returns SearchAddressBatchResult
        :rtype: ~azure.core.polling.LROPoller[~azure.maps.search.models.SearchAddressBatchResult]
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @distributed_trace
    def begin_fuzzy_search_batch(
        self,
        batch_request: Union[_models.BatchRequest, IO[bytes]],
        format: Union[str, _models.JsonFormat] = "json",
        **kwargs: Any
    ) -> LROPoller[_models.SearchAddressBatchResult]:
        """**Search Fuzzy Batch API**

        **Applies to:** see `pricing tiers <https://aka.ms/AzureMapsPricingTier>`_.

        The Search Fuzzy Batch API sends batches of queries to `Search Fuzzy API
        </rest/api/maps/search/get-search-fuzzy?view=rest-maps-1.0>`_ using just a single API call. You
        can call Search Fuzzy Batch API to run either asynchronously (async) or synchronously (sync).
        The async API allows caller to batch up to **10,000** queries and sync API up to **100**
        queries.

        Submit Synchronous Batch Request
        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

        The Synchronous API is recommended for lightweight batch requests. When the service receives a
        request, it will respond as soon as the batch items are calculated and there will be no
        possibility to retrieve the results later. The Synchronous API will return a timeout error (a
        408 response) if the request takes longer than 60 seconds. The number of batch items is limited
        to **100** for this API.

        .. code-block::

           POST
        https://atlas.microsoft.com/search/fuzzy/batch/sync/json?api-version=1.0&subscription-key={subscription-key}

        Submit Asynchronous Batch Request
        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

        The Asynchronous API is appropriate for processing big volumes of relatively complex search
        requests


        * It allows the retrieval of results in a separate call (multiple downloads are possible).
        * The asynchronous API is optimized for reliability and is not expected to run into a timeout.
        * The number of batch items is limited to **10,000** for this API.

        When you make a request by using async request, by default the service returns a 202 response
        code along a redirect URL in the Location field of the response header. This URL should be
        checked periodically until the response data or error information is available.
        The asynchronous responses are stored for **14** days. The redirect URL returns a 404 response
        if used after the expiration period.

        Please note that asynchronous batch request is a long-running operation. Here's a typical
        sequence of operations:


        #. Client sends a Search Fuzzy Batch ``POST`` request to Azure Maps
        #.
           The server will respond with one of the following:

           ..

              HTTP ``202 Accepted`` - Batch request has been accepted.

              HTTP ``Error`` - There was an error processing your Batch request. This could either be a
        ``400 Bad Request`` or any other ``Error`` status code.


        #.
           If the batch request was accepted successfully, the ``Location`` header in the response
        contains the URL to download the results of the batch request.
            This status URI looks like following:

        .. code-block::

               GET
        https://atlas.microsoft.com/search/fuzzy/batch/{batch-id}?api-version=1.0&subscription-key={subscription-key}


        #. Client issues a ``GET`` request on the *download URL* obtained in Step 3 to download the
        batch results.

        POST Body for Batch Request
        ^^^^^^^^^^^^^^^^^^^^^^^^^^^

        To send the *search fuzzy* queries you will use a ``POST`` request where the request body will
        contain the ``batchItems`` array in ``json`` format and the ``Content-Type`` header will be set
        to ``application/json``. Here's a sample request body containing 5 *search fuzzy* queries:

        .. code-block:: json

           {
               "batchItems": [
                   {"query": "?query=atm&lat=47.639769&lon=-122.128362&radius=5000&limit=5"},
                   {"query": "?query=Statue Of Liberty&limit=2"},
                   {"query": "?query=Starbucks&lat=47.639769&lon=-122.128362&radius=5000"},
                   {"query": "?query=Space Needle"},
                   {"query": "?query=pizza&limit=10"}
               ]
           }

        A *search fuzzy* query in a batch is just a partial URL *without* the protocol, base URL, path,
        api-version and subscription-key. It can accept any of the supported *search fuzzy* `URI
        parameters </rest/api/maps/search/get-search-fuzzy?view=rest-maps-1.0#uri-parameters>`_. The
        string values in the *search fuzzy* query must be properly escaped (e.g. " character should be
        escaped with ) and it should also be properly URL-encoded.

        The async API allows caller to batch up to **10,000** queries and sync API up to **100**
        queries, and the batch should contain at least **1** query.

        Download Asynchronous Batch Results
        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

        To download the async batch results you will issue a ``GET`` request to the batch download
        endpoint. This *download URL* can be obtained from the ``Location`` header of a successful
        ``POST`` batch request and looks like the following:

        .. code-block::

        https://atlas.microsoft.com/search/fuzzy/batch/{batch-id}?api-version=1.0&subscription-key={subscription-key}

        Here's the typical sequence of operations for downloading the batch results:


        #. Client sends a ``GET`` request using the *download URL*.
        #.
           The server will respond with one of the following:

           ..

              HTTP ``202 Accepted`` - Batch request was accepted but is still being processed. Please
        try again in some time.

              HTTP ``200 OK`` - Batch request successfully processed. The response body contains all
        the batch results.


        Batch Response Model
        ^^^^^^^^^^^^^^^^^^^^

        The returned data content is similar for async and sync requests. When downloading the results
        of an async batch request, if the batch has finished processing, the response body contains the
        batch response. This batch response contains a ``summary`` component that indicates the
        ``totalRequests`` that were part of the original batch request and ``successfulRequests``\ i.e.
        queries which were executed successfully. The batch response also includes a ``batchItems``
        array which contains a response for each and every query in the batch request. The
        ``batchItems`` will contain the results in the exact same order the original queries were sent
        in the batch request. Each item in ``batchItems`` contains ``statusCode`` and ``response``
        fields. Each ``response`` in ``batchItems`` is of one of the following types:


        *
          `\ ``SearchAddressResult``
        </rest/api/maps/search/get-search-fuzzy?view=rest-maps-1.0#searchaddressresult>`_ - If the
        query completed successfully.

        *
          ``Error`` - If the query failed. The response will contain a ``code`` and a ``message`` in
        this case.

        Here's a sample Batch Response with 2 *successful* and 1 *failed* result:

        .. code-block:: json

           {
               "summary": {
                   "successfulRequests": 2,
                   "totalRequests": 3
               },
               "batchItems": [
                   {
                       "statusCode": 200,
                       "response":
                       {
                           "summary": {
                               "query": "atm"
                           },
                           "results": [
                               {
                                   "type": "POI",
                                   "poi": {
                                       "name": "ATM at Wells Fargo"
                                   },
                                   "address": {
                                       "country": "United States Of America",
                                       "freeformAddress": "3240 157th Ave NE, Redmond, WA 98052"
                                   }
                               }
                           ]
                       }
                   },
                   {
                       "statusCode": 200,
                       "response":
                       {
                           "summary": {
                               "query": "statue of liberty"
                           },
                           "results": [
                               {
                                   "type": "POI",
                                   "poi": {
                                       "name": "Statue of Liberty"
                                   },
                                   "address": {
                                       "country": "United States Of America",
                                       "freeformAddress": "New York, NY 10004"
                                   }
                               }
                           ]
                       }
                   },
                   {
                       "statusCode": 400,
                       "response":
                       {
                           "error":
                           {
                               "code": "400 BadRequest",
                               "message": "Bad request: one or more parameters were incorrectly
        specified or are mutually exclusive."
                           }
                       }
                   }
               ]
           }.

        :param batch_request: The list of search fuzzy queries/requests to process. The list can
         contain a max of 10,000 queries and must contain at least 1 query. Is either a BatchRequest
         type or a IO[bytes] type. Required.
        :type batch_request: ~azure.maps.search.models.BatchRequest or IO[bytes]
        :param format: Desired format of the response. Only ``json`` format is supported. "json"
         Default value is "json".
        :type format: str or ~azure.maps.search.models.JsonFormat
        :return: An instance of LROPoller that returns SearchAddressBatchResult
        :rtype: ~azure.core.polling.LROPoller[~azure.maps.search.models.SearchAddressBatchResult]
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[_models.SearchAddressBatchResult] = kwargs.pop("cls", None)
        polling: Union[bool, PollingMethod] = kwargs.pop("polling", True)
        lro_delay = kwargs.pop("polling_interval", self._config.polling_interval)
        cont_token: Optional[str] = kwargs.pop("continuation_token", None)
        if cont_token is None:
            raw_result = self._fuzzy_search_batch_initial(
                batch_request=batch_request,
                format=format,
                content_type=content_type,
                cls=lambda x, y, z: x,
                headers=_headers,
                params=_params,
                **kwargs
            )
        kwargs.pop("error_map", None)

        def get_long_running_output(pipeline_response):
            deserialized = self._deserialize("SearchAddressBatchResult", pipeline_response)
            if cls:
                return cls(pipeline_response, deserialized, {})  # type: ignore
            return deserialized

        if polling is True:
            polling_method: PollingMethod = cast(
                PollingMethod, LROBasePolling(lro_delay, lro_options={"final-state-via": "location"}, **kwargs)
            )
        elif polling is False:
            polling_method = cast(PollingMethod, NoPolling())
        else:
            polling_method = polling
        if cont_token:
            return LROPoller[_models.SearchAddressBatchResult].from_continuation_token(
                polling_method=polling_method,
                continuation_token=cont_token,
                client=self._client,
                deserialization_callback=get_long_running_output,
            )
        return LROPoller[_models.SearchAddressBatchResult](
            self._client, raw_result, get_long_running_output, polling_method  # type: ignore
        )

    def _get_fuzzy_search_batch_initial(
        self, batch_id: str, **kwargs: Any
    ) -> Optional[_models.SearchAddressBatchResult]:
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[Optional[_models.SearchAddressBatchResult]] = kwargs.pop("cls", None)

        _request = build_search_get_fuzzy_search_batch_request(
            batch_id=batch_id,
            client_id=self._config.client_id,
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = False
        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200, 202]:
            if _stream:
                response.read()  # Load the body in memory and close the socket
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        deserialized = None
        response_headers = {}
        if response.status_code == 200:
            deserialized = self._deserialize("SearchAddressBatchResult", pipeline_response)

        if response.status_code == 202:
            response_headers["Location"] = self._deserialize("str", response.headers.get("Location"))

        if cls:
            return cls(pipeline_response, deserialized, response_headers)  # type: ignore

        return deserialized  # type: ignore

    @distributed_trace
    def begin_get_fuzzy_search_batch(self, batch_id: str, **kwargs: Any) -> LROPoller[_models.SearchAddressBatchResult]:
        """**Search Fuzzy Batch API**

        **Applies to:** see `pricing tiers <https://aka.ms/AzureMapsPricingTier>`_.

        The Search Fuzzy Batch API sends batches of queries to `Search Fuzzy API
        </rest/api/maps/search/get-search-fuzzy?view=rest-maps-1.0>`_ using just a single API call. You
        can call Search Fuzzy Batch API to run either asynchronously (async) or synchronously (sync).
        The async API allows caller to batch up to **10,000** queries and sync API up to **100**
        queries.

        Submit Synchronous Batch Request
        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

        The Synchronous API is recommended for lightweight batch requests. When the service receives a
        request, it will respond as soon as the batch items are calculated and there will be no
        possibility to retrieve the results later. The Synchronous API will return a timeout error (a
        408 response) if the request takes longer than 60 seconds. The number of batch items is limited
        to **100** for this API.

        .. code-block::

           POST
        https://atlas.microsoft.com/search/fuzzy/batch/sync/json?api-version=1.0&subscription-key={subscription-key}

        Submit Asynchronous Batch Request
        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

        The Asynchronous API is appropriate for processing big volumes of relatively complex search
        requests


        * It allows the retrieval of results in a separate call (multiple downloads are possible).
        * The asynchronous API is optimized for reliability and is not expected to run into a timeout.
        * The number of batch items is limited to **10,000** for this API.

        When you make a request by using async request, by default the service returns a 202 response
        code along a redirect URL in the Location field of the response header. This URL should be
        checked periodically until the response data or error information is available.
        The asynchronous responses are stored for **14** days. The redirect URL returns a 404 response
        if used after the expiration period.

        Please note that asynchronous batch request is a long-running operation. Here's a typical
        sequence of operations:


        #. Client sends a Search Fuzzy Batch ``POST`` request to Azure Maps
        #.
           The server will respond with one of the following:

           ..

              HTTP ``202 Accepted`` - Batch request has been accepted.

              HTTP ``Error`` - There was an error processing your Batch request. This could either be a
        ``400 Bad Request`` or any other ``Error`` status code.


        #.
           If the batch request was accepted successfully, the ``Location`` header in the response
        contains the URL to download the results of the batch request.
            This status URI looks like following:

        .. code-block::

               GET
        https://atlas.microsoft.com/search/fuzzy/batch/{batch-id}?api-version=1.0&subscription-key={subscription-key}


        #. Client issues a ``GET`` request on the *download URL* obtained in Step 3 to download the
        batch results.

        POST Body for Batch Request
        ^^^^^^^^^^^^^^^^^^^^^^^^^^^

        To send the *search fuzzy* queries you will use a ``POST`` request where the request body will
        contain the ``batchItems`` array in ``json`` format and the ``Content-Type`` header will be set
        to ``application/json``. Here's a sample request body containing 5 *search fuzzy* queries:

        .. code-block:: json

           {
               "batchItems": [
                   {"query": "?query=atm&lat=47.639769&lon=-122.128362&radius=5000&limit=5"},
                   {"query": "?query=Statue Of Liberty&limit=2"},
                   {"query": "?query=Starbucks&lat=47.639769&lon=-122.128362&radius=5000"},
                   {"query": "?query=Space Needle"},
                   {"query": "?query=pizza&limit=10"}
               ]
           }

        A *search fuzzy* query in a batch is just a partial URL *without* the protocol, base URL, path,
        api-version and subscription-key. It can accept any of the supported *search fuzzy* `URI
        parameters </rest/api/maps/search/get-search-fuzzy?view=rest-maps-1.0#uri-parameters>`_. The
        string values in the *search fuzzy* query must be properly escaped (e.g. " character should be
        escaped with ) and it should also be properly URL-encoded.

        The async API allows caller to batch up to **10,000** queries and sync API up to **100**
        queries, and the batch should contain at least **1** query.

        Download Asynchronous Batch Results
        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

        To download the async batch results you will issue a ``GET`` request to the batch download
        endpoint. This *download URL* can be obtained from the ``Location`` header of a successful
        ``POST`` batch request and looks like the following:

        .. code-block::

        https://atlas.microsoft.com/search/fuzzy/batch/{batch-id}?api-version=1.0&subscription-key={subscription-key}

        Here's the typical sequence of operations for downloading the batch results:


        #. Client sends a ``GET`` request using the *download URL*.
        #.
           The server will respond with one of the following:

           ..

              HTTP ``202 Accepted`` - Batch request was accepted but is still being processed. Please
        try again in some time.

              HTTP ``200 OK`` - Batch request successfully processed. The response body contains all
        the batch results.


        Batch Response Model
        ^^^^^^^^^^^^^^^^^^^^

        The returned data content is similar for async and sync requests. When downloading the results
        of an async batch request, if the batch has finished processing, the response body contains the
        batch response. This batch response contains a ``summary`` component that indicates the
        ``totalRequests`` that were part of the original batch request and ``successfulRequests``\ i.e.
        queries which were executed successfully. The batch response also includes a ``batchItems``
        array which contains a response for each and every query in the batch request. The
        ``batchItems`` will contain the results in the exact same order the original queries were sent
        in the batch request. Each item in ``batchItems`` contains ``statusCode`` and ``response``
        fields. Each ``response`` in ``batchItems`` is of one of the following types:


        *
          `\ ``SearchAddressResult``
        </rest/api/maps/search/get-search-fuzzy?view=rest-maps-1.0#searchaddressresult>`_ - If the
        query completed successfully.

        *
          ``Error`` - If the query failed. The response will contain a ``code`` and a ``message`` in
        this case.

        Here's a sample Batch Response with 2 *successful* and 1 *failed* result:

        .. code-block:: json

           {
               "summary": {
                   "successfulRequests": 2,
                   "totalRequests": 3
               },
               "batchItems": [
                   {
                       "statusCode": 200,
                       "response":
                       {
                           "summary": {
                               "query": "atm"
                           },
                           "results": [
                               {
                                   "type": "POI",
                                   "poi": {
                                       "name": "ATM at Wells Fargo"
                                   },
                                   "address": {
                                       "country": "United States Of America",
                                       "freeformAddress": "3240 157th Ave NE, Redmond, WA 98052"
                                   }
                               }
                           ]
                       }
                   },
                   {
                       "statusCode": 200,
                       "response":
                       {
                           "summary": {
                               "query": "statue of liberty"
                           },
                           "results": [
                               {
                                   "type": "POI",
                                   "poi": {
                                       "name": "Statue of Liberty"
                                   },
                                   "address": {
                                       "country": "United States Of America",
                                       "freeformAddress": "New York, NY 10004"
                                   }
                               }
                           ]
                       }
                   },
                   {
                       "statusCode": 400,
                       "response":
                       {
                           "error":
                           {
                               "code": "400 BadRequest",
                               "message": "Bad request: one or more parameters were incorrectly
        specified or are mutually exclusive."
                           }
                       }
                   }
               ]
           }.

        :param batch_id: Batch id for querying the operation. Required.
        :type batch_id: str
        :return: An instance of LROPoller that returns SearchAddressBatchResult
        :rtype: ~azure.core.polling.LROPoller[~azure.maps.search.models.SearchAddressBatchResult]
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[_models.SearchAddressBatchResult] = kwargs.pop("cls", None)
        polling: Union[bool, PollingMethod] = kwargs.pop("polling", True)
        lro_delay = kwargs.pop("polling_interval", self._config.polling_interval)
        cont_token: Optional[str] = kwargs.pop("continuation_token", None)
        if cont_token is None:
            raw_result = self._get_fuzzy_search_batch_initial(
                batch_id=batch_id, cls=lambda x, y, z: x, headers=_headers, params=_params, **kwargs
            )
        kwargs.pop("error_map", None)

        def get_long_running_output(pipeline_response):
            deserialized = self._deserialize("SearchAddressBatchResult", pipeline_response)
            if cls:
                return cls(pipeline_response, deserialized, {})  # type: ignore
            return deserialized

        if polling is True:
            polling_method: PollingMethod = cast(
                PollingMethod, LROBasePolling(lro_delay, lro_options={"final-state-via": "original-uri"}, **kwargs)
            )
        elif polling is False:
            polling_method = cast(PollingMethod, NoPolling())
        else:
            polling_method = polling
        if cont_token:
            return LROPoller[_models.SearchAddressBatchResult].from_continuation_token(
                polling_method=polling_method,
                continuation_token=cont_token,
                client=self._client,
                deserialization_callback=get_long_running_output,
            )
        return LROPoller[_models.SearchAddressBatchResult](
            self._client, raw_result, get_long_running_output, polling_method  # type: ignore
        )

    @overload
    def search_address_batch_sync(
        self,
        batch_request: _models.BatchRequest,
        format: Union[str, _models.JsonFormat] = "json",
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> _models.SearchAddressBatchResult:
        """**Search Address Batch API**

        **Applies to:** see `pricing tiers <https://aka.ms/AzureMapsPricingTier>`_.

        The Search Address Batch API sends batches of queries to `Search Address API
        </rest/api/maps/search/get-search-address?view=rest-maps-1.0>`_ using just a single API call.
        You can call Search Address Batch API to run either asynchronously (async) or synchronously
        (sync). The async API allows caller to batch up to **10,000** queries and sync API up to
        **100** queries.

        Submit Synchronous Batch Request
        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

        The Synchronous API is recommended for lightweight batch requests. When the service receives a
        request, it will respond as soon as the batch items are calculated and there will be no
        possibility to retrieve the results later. The Synchronous API will return a timeout error (a
        408 response) if the request takes longer than 60 seconds. The number of batch items is limited
        to **100** for this API.

        .. code-block::

           POST
        https://atlas.microsoft.com/search/address/batch/sync/json?api-version=1.0&subscription-key={subscription-key}

        Submit Asynchronous Batch Request
        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

        The Asynchronous API is appropriate for processing big volumes of relatively complex search
        requests


        * It allows the retrieval of results in a separate call (multiple downloads are possible).
        * The asynchronous API is optimized for reliability and is not expected to run into a timeout.
        * The number of batch items is limited to **10,000** for this API.

        When you make a request by using async request, by default the service returns a 202 response
        code along a redirect URL in the Location field of the response header. This URL should be
        checked periodically until the response data or error information is available.
        The asynchronous responses are stored for **14** days. The redirect URL returns a 404 response
        if used after the expiration period.

        Please note that asynchronous batch request is a long-running operation. Here's a typical
        sequence of operations:


        #. Client sends a Search Address Batch ``POST`` request to Azure Maps
        #.
           The server will respond with one of the following:

           ..

              HTTP ``202 Accepted`` - Batch request has been accepted.

              HTTP ``Error`` - There was an error processing your Batch request. This could either be a
        ``400 Bad Request`` or any other ``Error`` status code.


        #.
           If the batch request was accepted successfully, the ``Location`` header in the response
        contains the URL to download the results of the batch request.
            This status URI looks like following:

        .. code-block::

               GET
        https://atlas.microsoft.com/search/address/batch/{batch-id}?api-version=1.0&subscription-key={subscription-key}


        #. Client issues a ``GET`` request on the *download URL* obtained in Step 3 to download the
        batch results.

        POST Body for Batch Request
        ^^^^^^^^^^^^^^^^^^^^^^^^^^^

        To send the *search address* queries you will use a ``POST`` request where the request body
        will contain the ``batchItems`` array in ``json`` format and the ``Content-Type`` header will
        be set to ``application/json``. Here's a sample request body containing 5 *search address*
        queries:

        .. code-block:: json

           {
               "batchItems": [
                   {"query": "?query=400 Broad St, Seattle, WA 98109&limit=3"},
                   {"query": "?query=One, Microsoft Way, Redmond, WA 98052&limit=3"},
                   {"query": "?query=350 5th Ave, New York, NY 10118&limit=1"},
                   {"query": "?query=Pike Pl, Seattle, WA
        98101&lat=47.610970&lon=-122.342469&radius=1000"},
                   {"query": "?query=Champ de Mars, 5 Avenue Anatole France, 75007 Paris,
        France&limit=1"}
               ]
           }

        A *search address* query in a batch is just a partial URL *without* the protocol, base URL,
        path, api-version and subscription-key. It can accept any of the supported *search address*
        `URI parameters </rest/api/maps/search/get-search-address?view=rest-maps-1.0#uri-parameters>`_.
        The string values in the *search address* query must be properly escaped (e.g. " character
        should be escaped with ) and it should also be properly URL-encoded.

        The async API allows caller to batch up to **10,000** queries and sync API up to **100**
        queries, and the batch should contain at least **1** query.

        Download Asynchronous Batch Results
        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

        To download the async batch results you will issue a ``GET`` request to the batch download
        endpoint. This *download URL* can be obtained from the ``Location`` header of a successful
        ``POST`` batch request and looks like the following:

        .. code-block::

        https://atlas.microsoft.com/search/address/batch/{batch-id}?api-version=1.0&subscription-key={subscription-key}

        Here's the typical sequence of operations for downloading the batch results:


        #. Client sends a ``GET`` request using the *download URL*.
        #.
           The server will respond with one of the following:

           ..

              HTTP ``202 Accepted`` - Batch request was accepted but is still being processed. Please
        try again in some time.

              HTTP ``200 OK`` - Batch request successfully processed. The response body contains all
        the batch results.


        Batch Response Model
        ^^^^^^^^^^^^^^^^^^^^

        The returned data content is similar for async and sync requests. When downloading the results
        of an async batch request, if the batch has finished processing, the response body contains the
        batch response. This batch response contains a ``summary`` component that indicates the
        ``totalRequests`` that were part of the original batch request and ``successfulRequests``\ i.e.
        queries which were executed successfully. The batch response also includes a ``batchItems``
        array which contains a response for each and every query in the batch request. The
        ``batchItems`` will contain the results in the exact same order the original queries were sent
        in the batch request. Each item in ``batchItems`` contains ``statusCode`` and ``response``
        fields. Each ``response`` in ``batchItems`` is of one of the following types:


        *
          `\ ``SearchAddressResult``
        </rest/api/maps/search/get-search-address?view=rest-maps-1.0#SearchAddressResult>`_ - If the
        query completed successfully.

        *
          ``Error`` - If the query failed. The response will contain a ``code`` and a ``message`` in
        this case.

        Here's a sample Batch Response with 2 *successful* and 1 *failed* result:

        .. code-block:: json

           {
               "summary": {
                   "successfulRequests": 2,
                   "totalRequests": 3
               },
               "batchItems": [
                   {
                       "statusCode": 200,
                       "response":
                       {
                           "summary": {
                               "query": "one microsoft way redmond wa 98052"
                           },
                           "results": [
                               {
                                   "position": {
                                       "lat": 47.63989,
                                       "lon": -122.12509
                                   }
                               }
                           ]
                       }
                   },
                   {
                       "statusCode": 200,
                       "response":
                       {
                           "summary": {
                               "query": "pike pl seattle wa 98101"
                           },
                           "results": [
                               {
                                   "position": {
                                       "lat": 47.60963,
                                       "lon": -122.34215
                                   }
                               }
                           ]
                       }
                   },
                   {
                       "statusCode": 400,
                       "response":
                       {
                           "error":
                           {
                               "code": "400 BadRequest",
                               "message": "Bad request: one or more parameters were incorrectly
        specified or are mutually exclusive."
                           }
                       }
                   }
               ]
           }.

        :param batch_request: The list of address geocoding queries/requests to process. The list can
         contain  a max of 10,000 queries and must contain at least 1 query. Required.
        :type batch_request: ~azure.maps.search.models.BatchRequest
        :param format: Desired format of the response. Only ``json`` format is supported. "json"
         Default value is "json".
        :type format: str or ~azure.maps.search.models.JsonFormat
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: SearchAddressBatchResult
        :rtype: ~azure.maps.search.models.SearchAddressBatchResult
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @overload
    def search_address_batch_sync(
        self,
        batch_request: IO[bytes],
        format: Union[str, _models.JsonFormat] = "json",
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> _models.SearchAddressBatchResult:
        """**Search Address Batch API**

        **Applies to:** see `pricing tiers <https://aka.ms/AzureMapsPricingTier>`_.

        The Search Address Batch API sends batches of queries to `Search Address API
        </rest/api/maps/search/get-search-address?view=rest-maps-1.0>`_ using just a single API call.
        You can call Search Address Batch API to run either asynchronously (async) or synchronously
        (sync). The async API allows caller to batch up to **10,000** queries and sync API up to
        **100** queries.

        Submit Synchronous Batch Request
        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

        The Synchronous API is recommended for lightweight batch requests. When the service receives a
        request, it will respond as soon as the batch items are calculated and there will be no
        possibility to retrieve the results later. The Synchronous API will return a timeout error (a
        408 response) if the request takes longer than 60 seconds. The number of batch items is limited
        to **100** for this API.

        .. code-block::

           POST
        https://atlas.microsoft.com/search/address/batch/sync/json?api-version=1.0&subscription-key={subscription-key}

        Submit Asynchronous Batch Request
        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

        The Asynchronous API is appropriate for processing big volumes of relatively complex search
        requests


        * It allows the retrieval of results in a separate call (multiple downloads are possible).
        * The asynchronous API is optimized for reliability and is not expected to run into a timeout.
        * The number of batch items is limited to **10,000** for this API.

        When you make a request by using async request, by default the service returns a 202 response
        code along a redirect URL in the Location field of the response header. This URL should be
        checked periodically until the response data or error information is available.
        The asynchronous responses are stored for **14** days. The redirect URL returns a 404 response
        if used after the expiration period.

        Please note that asynchronous batch request is a long-running operation. Here's a typical
        sequence of operations:


        #. Client sends a Search Address Batch ``POST`` request to Azure Maps
        #.
           The server will respond with one of the following:

           ..

              HTTP ``202 Accepted`` - Batch request has been accepted.

              HTTP ``Error`` - There was an error processing your Batch request. This could either be a
        ``400 Bad Request`` or any other ``Error`` status code.


        #.
           If the batch request was accepted successfully, the ``Location`` header in the response
        contains the URL to download the results of the batch request.
            This status URI looks like following:

        .. code-block::

               GET
        https://atlas.microsoft.com/search/address/batch/{batch-id}?api-version=1.0&subscription-key={subscription-key}


        #. Client issues a ``GET`` request on the *download URL* obtained in Step 3 to download the
        batch results.

        POST Body for Batch Request
        ^^^^^^^^^^^^^^^^^^^^^^^^^^^

        To send the *search address* queries you will use a ``POST`` request where the request body
        will contain the ``batchItems`` array in ``json`` format and the ``Content-Type`` header will
        be set to ``application/json``. Here's a sample request body containing 5 *search address*
        queries:

        .. code-block:: json

           {
               "batchItems": [
                   {"query": "?query=400 Broad St, Seattle, WA 98109&limit=3"},
                   {"query": "?query=One, Microsoft Way, Redmond, WA 98052&limit=3"},
                   {"query": "?query=350 5th Ave, New York, NY 10118&limit=1"},
                   {"query": "?query=Pike Pl, Seattle, WA
        98101&lat=47.610970&lon=-122.342469&radius=1000"},
                   {"query": "?query=Champ de Mars, 5 Avenue Anatole France, 75007 Paris,
        France&limit=1"}
               ]
           }

        A *search address* query in a batch is just a partial URL *without* the protocol, base URL,
        path, api-version and subscription-key. It can accept any of the supported *search address*
        `URI parameters </rest/api/maps/search/get-search-address?view=rest-maps-1.0#uri-parameters>`_.
        The string values in the *search address* query must be properly escaped (e.g. " character
        should be escaped with ) and it should also be properly URL-encoded.

        The async API allows caller to batch up to **10,000** queries and sync API up to **100**
        queries, and the batch should contain at least **1** query.

        Download Asynchronous Batch Results
        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

        To download the async batch results you will issue a ``GET`` request to the batch download
        endpoint. This *download URL* can be obtained from the ``Location`` header of a successful
        ``POST`` batch request and looks like the following:

        .. code-block::

        https://atlas.microsoft.com/search/address/batch/{batch-id}?api-version=1.0&subscription-key={subscription-key}

        Here's the typical sequence of operations for downloading the batch results:


        #. Client sends a ``GET`` request using the *download URL*.
        #.
           The server will respond with one of the following:

           ..

              HTTP ``202 Accepted`` - Batch request was accepted but is still being processed. Please
        try again in some time.

              HTTP ``200 OK`` - Batch request successfully processed. The response body contains all
        the batch results.


        Batch Response Model
        ^^^^^^^^^^^^^^^^^^^^

        The returned data content is similar for async and sync requests. When downloading the results
        of an async batch request, if the batch has finished processing, the response body contains the
        batch response. This batch response contains a ``summary`` component that indicates the
        ``totalRequests`` that were part of the original batch request and ``successfulRequests``\ i.e.
        queries which were executed successfully. The batch response also includes a ``batchItems``
        array which contains a response for each and every query in the batch request. The
        ``batchItems`` will contain the results in the exact same order the original queries were sent
        in the batch request. Each item in ``batchItems`` contains ``statusCode`` and ``response``
        fields. Each ``response`` in ``batchItems`` is of one of the following types:


        *
          `\ ``SearchAddressResult``
        </rest/api/maps/search/get-search-address?view=rest-maps-1.0#SearchAddressResult>`_ - If the
        query completed successfully.

        *
          ``Error`` - If the query failed. The response will contain a ``code`` and a ``message`` in
        this case.

        Here's a sample Batch Response with 2 *successful* and 1 *failed* result:

        .. code-block:: json

           {
               "summary": {
                   "successfulRequests": 2,
                   "totalRequests": 3
               },
               "batchItems": [
                   {
                       "statusCode": 200,
                       "response":
                       {
                           "summary": {
                               "query": "one microsoft way redmond wa 98052"
                           },
                           "results": [
                               {
                                   "position": {
                                       "lat": 47.63989,
                                       "lon": -122.12509
                                   }
                               }
                           ]
                       }
                   },
                   {
                       "statusCode": 200,
                       "response":
                       {
                           "summary": {
                               "query": "pike pl seattle wa 98101"
                           },
                           "results": [
                               {
                                   "position": {
                                       "lat": 47.60963,
                                       "lon": -122.34215
                                   }
                               }
                           ]
                       }
                   },
                   {
                       "statusCode": 400,
                       "response":
                       {
                           "error":
                           {
                               "code": "400 BadRequest",
                               "message": "Bad request: one or more parameters were incorrectly
        specified or are mutually exclusive."
                           }
                       }
                   }
               ]
           }.

        :param batch_request: The list of address geocoding queries/requests to process. The list can
         contain  a max of 10,000 queries and must contain at least 1 query. Required.
        :type batch_request: IO[bytes]
        :param format: Desired format of the response. Only ``json`` format is supported. "json"
         Default value is "json".
        :type format: str or ~azure.maps.search.models.JsonFormat
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: SearchAddressBatchResult
        :rtype: ~azure.maps.search.models.SearchAddressBatchResult
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @distributed_trace
    def search_address_batch_sync(
        self,
        batch_request: Union[_models.BatchRequest, IO[bytes]],
        format: Union[str, _models.JsonFormat] = "json",
        **kwargs: Any
    ) -> _models.SearchAddressBatchResult:
        """**Search Address Batch API**

        **Applies to:** see `pricing tiers <https://aka.ms/AzureMapsPricingTier>`_.

        The Search Address Batch API sends batches of queries to `Search Address API
        </rest/api/maps/search/get-search-address?view=rest-maps-1.0>`_ using just a single API call.
        You can call Search Address Batch API to run either asynchronously (async) or synchronously
        (sync). The async API allows caller to batch up to **10,000** queries and sync API up to
        **100** queries.

        Submit Synchronous Batch Request
        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

        The Synchronous API is recommended for lightweight batch requests. When the service receives a
        request, it will respond as soon as the batch items are calculated and there will be no
        possibility to retrieve the results later. The Synchronous API will return a timeout error (a
        408 response) if the request takes longer than 60 seconds. The number of batch items is limited
        to **100** for this API.

        .. code-block::

           POST
        https://atlas.microsoft.com/search/address/batch/sync/json?api-version=1.0&subscription-key={subscription-key}

        Submit Asynchronous Batch Request
        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

        The Asynchronous API is appropriate for processing big volumes of relatively complex search
        requests


        * It allows the retrieval of results in a separate call (multiple downloads are possible).
        * The asynchronous API is optimized for reliability and is not expected to run into a timeout.
        * The number of batch items is limited to **10,000** for this API.

        When you make a request by using async request, by default the service returns a 202 response
        code along a redirect URL in the Location field of the response header. This URL should be
        checked periodically until the response data or error information is available.
        The asynchronous responses are stored for **14** days. The redirect URL returns a 404 response
        if used after the expiration period.

        Please note that asynchronous batch request is a long-running operation. Here's a typical
        sequence of operations:


        #. Client sends a Search Address Batch ``POST`` request to Azure Maps
        #.
           The server will respond with one of the following:

           ..

              HTTP ``202 Accepted`` - Batch request has been accepted.

              HTTP ``Error`` - There was an error processing your Batch request. This could either be a
        ``400 Bad Request`` or any other ``Error`` status code.


        #.
           If the batch request was accepted successfully, the ``Location`` header in the response
        contains the URL to download the results of the batch request.
            This status URI looks like following:

        .. code-block::

               GET
        https://atlas.microsoft.com/search/address/batch/{batch-id}?api-version=1.0&subscription-key={subscription-key}


        #. Client issues a ``GET`` request on the *download URL* obtained in Step 3 to download the
        batch results.

        POST Body for Batch Request
        ^^^^^^^^^^^^^^^^^^^^^^^^^^^

        To send the *search address* queries you will use a ``POST`` request where the request body
        will contain the ``batchItems`` array in ``json`` format and the ``Content-Type`` header will
        be set to ``application/json``. Here's a sample request body containing 5 *search address*
        queries:

        .. code-block:: json

           {
               "batchItems": [
                   {"query": "?query=400 Broad St, Seattle, WA 98109&limit=3"},
                   {"query": "?query=One, Microsoft Way, Redmond, WA 98052&limit=3"},
                   {"query": "?query=350 5th Ave, New York, NY 10118&limit=1"},
                   {"query": "?query=Pike Pl, Seattle, WA
        98101&lat=47.610970&lon=-122.342469&radius=1000"},
                   {"query": "?query=Champ de Mars, 5 Avenue Anatole France, 75007 Paris,
        France&limit=1"}
               ]
           }

        A *search address* query in a batch is just a partial URL *without* the protocol, base URL,
        path, api-version and subscription-key. It can accept any of the supported *search address*
        `URI parameters </rest/api/maps/search/get-search-address?view=rest-maps-1.0#uri-parameters>`_.
        The string values in the *search address* query must be properly escaped (e.g. " character
        should be escaped with ) and it should also be properly URL-encoded.

        The async API allows caller to batch up to **10,000** queries and sync API up to **100**
        queries, and the batch should contain at least **1** query.

        Download Asynchronous Batch Results
        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

        To download the async batch results you will issue a ``GET`` request to the batch download
        endpoint. This *download URL* can be obtained from the ``Location`` header of a successful
        ``POST`` batch request and looks like the following:

        .. code-block::

        https://atlas.microsoft.com/search/address/batch/{batch-id}?api-version=1.0&subscription-key={subscription-key}

        Here's the typical sequence of operations for downloading the batch results:


        #. Client sends a ``GET`` request using the *download URL*.
        #.
           The server will respond with one of the following:

           ..

              HTTP ``202 Accepted`` - Batch request was accepted but is still being processed. Please
        try again in some time.

              HTTP ``200 OK`` - Batch request successfully processed. The response body contains all
        the batch results.


        Batch Response Model
        ^^^^^^^^^^^^^^^^^^^^

        The returned data content is similar for async and sync requests. When downloading the results
        of an async batch request, if the batch has finished processing, the response body contains the
        batch response. This batch response contains a ``summary`` component that indicates the
        ``totalRequests`` that were part of the original batch request and ``successfulRequests``\ i.e.
        queries which were executed successfully. The batch response also includes a ``batchItems``
        array which contains a response for each and every query in the batch request. The
        ``batchItems`` will contain the results in the exact same order the original queries were sent
        in the batch request. Each item in ``batchItems`` contains ``statusCode`` and ``response``
        fields. Each ``response`` in ``batchItems`` is of one of the following types:


        *
          `\ ``SearchAddressResult``
        </rest/api/maps/search/get-search-address?view=rest-maps-1.0#SearchAddressResult>`_ - If the
        query completed successfully.

        *
          ``Error`` - If the query failed. The response will contain a ``code`` and a ``message`` in
        this case.

        Here's a sample Batch Response with 2 *successful* and 1 *failed* result:

        .. code-block:: json

           {
               "summary": {
                   "successfulRequests": 2,
                   "totalRequests": 3
               },
               "batchItems": [
                   {
                       "statusCode": 200,
                       "response":
                       {
                           "summary": {
                               "query": "one microsoft way redmond wa 98052"
                           },
                           "results": [
                               {
                                   "position": {
                                       "lat": 47.63989,
                                       "lon": -122.12509
                                   }
                               }
                           ]
                       }
                   },
                   {
                       "statusCode": 200,
                       "response":
                       {
                           "summary": {
                               "query": "pike pl seattle wa 98101"
                           },
                           "results": [
                               {
                                   "position": {
                                       "lat": 47.60963,
                                       "lon": -122.34215
                                   }
                               }
                           ]
                       }
                   },
                   {
                       "statusCode": 400,
                       "response":
                       {
                           "error":
                           {
                               "code": "400 BadRequest",
                               "message": "Bad request: one or more parameters were incorrectly
        specified or are mutually exclusive."
                           }
                       }
                   }
               ]
           }.

        :param batch_request: The list of address geocoding queries/requests to process. The list can
         contain  a max of 10,000 queries and must contain at least 1 query. Is either a BatchRequest
         type or a IO[bytes] type. Required.
        :type batch_request: ~azure.maps.search.models.BatchRequest or IO[bytes]
        :param format: Desired format of the response. Only ``json`` format is supported. "json"
         Default value is "json".
        :type format: str or ~azure.maps.search.models.JsonFormat
        :return: SearchAddressBatchResult
        :rtype: ~azure.maps.search.models.SearchAddressBatchResult
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
            408: lambda response: HttpResponseError(
                response=response, model=self._deserialize(_models.ErrorResponse, response)
            ),
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[_models.SearchAddressBatchResult] = kwargs.pop("cls", None)

        content_type = content_type or "application/json"
        _json = None
        _content = None
        if isinstance(batch_request, (IOBase, bytes)):
            _content = batch_request
        else:
            _json = self._serialize.body(batch_request, "BatchRequest")

        _request = build_search_search_address_batch_sync_request(
            format=format,
            client_id=self._config.client_id,
            content_type=content_type,
            api_version=self._config.api_version,
            json=_json,
            content=_content,
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = False
        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                response.read()  # Load the body in memory and close the socket
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize.failsafe_deserialize(_models.ErrorResponse, pipeline_response)
            raise HttpResponseError(response=response, model=error)

        deserialized = self._deserialize("SearchAddressBatchResult", pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore

    def _search_address_batch_initial(
        self,
        batch_request: Union[_models.BatchRequest, IO[bytes]],
        format: Union[str, _models.JsonFormat] = "json",
        **kwargs: Any
    ) -> Optional[_models.SearchAddressBatchResult]:
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[Optional[_models.SearchAddressBatchResult]] = kwargs.pop("cls", None)

        content_type = content_type or "application/json"
        _json = None
        _content = None
        if isinstance(batch_request, (IOBase, bytes)):
            _content = batch_request
        else:
            _json = self._serialize.body(batch_request, "BatchRequest")

        _request = build_search_search_address_batch_request(
            format=format,
            client_id=self._config.client_id,
            content_type=content_type,
            api_version=self._config.api_version,
            json=_json,
            content=_content,
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = False
        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200, 202]:
            if _stream:
                response.read()  # Load the body in memory and close the socket
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        deserialized = None
        response_headers = {}
        if response.status_code == 200:
            deserialized = self._deserialize("SearchAddressBatchResult", pipeline_response)

        if response.status_code == 202:
            response_headers["Location"] = self._deserialize("str", response.headers.get("Location"))

        if cls:
            return cls(pipeline_response, deserialized, response_headers)  # type: ignore

        return deserialized  # type: ignore

    @overload
    def begin_search_address_batch(
        self,
        batch_request: _models.BatchRequest,
        format: Union[str, _models.JsonFormat] = "json",
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> LROPoller[_models.SearchAddressBatchResult]:
        """**Search Address Batch API**

        **Applies to:** see `pricing tiers <https://aka.ms/AzureMapsPricingTier>`_.

        The Search Address Batch API sends batches of queries to `Search Address API
        </rest/api/maps/search/get-search-address?view=rest-maps-1.0>`_ using just a single API call.
        You can call Search Address Batch API to run either asynchronously (async) or synchronously
        (sync). The async API allows caller to batch up to **10,000** queries and sync API up to
        **100** queries.

        Submit Synchronous Batch Request
        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

        The Synchronous API is recommended for lightweight batch requests. When the service receives a
        request, it will respond as soon as the batch items are calculated and there will be no
        possibility to retrieve the results later. The Synchronous API will return a timeout error (a
        408 response) if the request takes longer than 60 seconds. The number of batch items is limited
        to **100** for this API.

        .. code-block::

           POST
        https://atlas.microsoft.com/search/address/batch/sync/json?api-version=1.0&subscription-key={subscription-key}

        Submit Asynchronous Batch Request
        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

        The Asynchronous API is appropriate for processing big volumes of relatively complex search
        requests


        * It allows the retrieval of results in a separate call (multiple downloads are possible).
        * The asynchronous API is optimized for reliability and is not expected to run into a timeout.
        * The number of batch items is limited to **10,000** for this API.

        When you make a request by using async request, by default the service returns a 202 response
        code along a redirect URL in the Location field of the response header. This URL should be
        checked periodically until the response data or error information is available.
        The asynchronous responses are stored for **14** days. The redirect URL returns a 404 response
        if used after the expiration period.

        Please note that asynchronous batch request is a long-running operation. Here's a typical
        sequence of operations:


        #. Client sends a Search Address Batch ``POST`` request to Azure Maps
        #.
           The server will respond with one of the following:

           ..

              HTTP ``202 Accepted`` - Batch request has been accepted.

              HTTP ``Error`` - There was an error processing your Batch request. This could either be a
        ``400 Bad Request`` or any other ``Error`` status code.


        #.
           If the batch request was accepted successfully, the ``Location`` header in the response
        contains the URL to download the results of the batch request.
            This status URI looks like following:

        .. code-block::

               GET
        https://atlas.microsoft.com/search/address/batch/{batch-id}?api-version=1.0&subscription-key={subscription-key}


        #. Client issues a ``GET`` request on the *download URL* obtained in Step 3 to download the
        batch results.

        POST Body for Batch Request
        ^^^^^^^^^^^^^^^^^^^^^^^^^^^

        To send the *search address* queries you will use a ``POST`` request where the request body
        will contain the ``batchItems`` array in ``json`` format and the ``Content-Type`` header will
        be set to ``application/json``. Here's a sample request body containing 5 *search address*
        queries:

        .. code-block:: json

           {
               "batchItems": [
                   {"query": "?query=400 Broad St, Seattle, WA 98109&limit=3"},
                   {"query": "?query=One, Microsoft Way, Redmond, WA 98052&limit=3"},
                   {"query": "?query=350 5th Ave, New York, NY 10118&limit=1"},
                   {"query": "?query=Pike Pl, Seattle, WA
        98101&lat=47.610970&lon=-122.342469&radius=1000"},
                   {"query": "?query=Champ de Mars, 5 Avenue Anatole France, 75007 Paris,
        France&limit=1"}
               ]
           }

        A *search address* query in a batch is just a partial URL *without* the protocol, base URL,
        path, api-version and subscription-key. It can accept any of the supported *search address*
        `URI parameters </rest/api/maps/search/get-search-address?view=rest-maps-1.0#uri-parameters>`_.
        The string values in the *search address* query must be properly escaped (e.g. " character
        should be escaped with ) and it should also be properly URL-encoded.

        The async API allows caller to batch up to **10,000** queries and sync API up to **100**
        queries, and the batch should contain at least **1** query.

        Download Asynchronous Batch Results
        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

        To download the async batch results you will issue a ``GET`` request to the batch download
        endpoint. This *download URL* can be obtained from the ``Location`` header of a successful
        ``POST`` batch request and looks like the following:

        .. code-block::

        https://atlas.microsoft.com/search/address/batch/{batch-id}?api-version=1.0&subscription-key={subscription-key}

        Here's the typical sequence of operations for downloading the batch results:


        #. Client sends a ``GET`` request using the *download URL*.
        #.
           The server will respond with one of the following:

           ..

              HTTP ``202 Accepted`` - Batch request was accepted but is still being processed. Please
        try again in some time.

              HTTP ``200 OK`` - Batch request successfully processed. The response body contains all
        the batch results.


        Batch Response Model
        ^^^^^^^^^^^^^^^^^^^^

        The returned data content is similar for async and sync requests. When downloading the results
        of an async batch request, if the batch has finished processing, the response body contains the
        batch response. This batch response contains a ``summary`` component that indicates the
        ``totalRequests`` that were part of the original batch request and ``successfulRequests``\ i.e.
        queries which were executed successfully. The batch response also includes a ``batchItems``
        array which contains a response for each and every query in the batch request. The
        ``batchItems`` will contain the results in the exact same order the original queries were sent
        in the batch request. Each item in ``batchItems`` contains ``statusCode`` and ``response``
        fields. Each ``response`` in ``batchItems`` is of one of the following types:


        *
          `\ ``SearchAddressResult``
        </rest/api/maps/search/get-search-address?view=rest-maps-1.0#SearchAddressResult>`_ - If the
        query completed successfully.

        *
          ``Error`` - If the query failed. The response will contain a ``code`` and a ``message`` in
        this case.

        Here's a sample Batch Response with 2 *successful* and 1 *failed* result:

        .. code-block:: json

           {
               "summary": {
                   "successfulRequests": 2,
                   "totalRequests": 3
               },
               "batchItems": [
                   {
                       "statusCode": 200,
                       "response":
                       {
                           "summary": {
                               "query": "one microsoft way redmond wa 98052"
                           },
                           "results": [
                               {
                                   "position": {
                                       "lat": 47.63989,
                                       "lon": -122.12509
                                   }
                               }
                           ]
                       }
                   },
                   {
                       "statusCode": 200,
                       "response":
                       {
                           "summary": {
                               "query": "pike pl seattle wa 98101"
                           },
                           "results": [
                               {
                                   "position": {
                                       "lat": 47.60963,
                                       "lon": -122.34215
                                   }
                               }
                           ]
                       }
                   },
                   {
                       "statusCode": 400,
                       "response":
                       {
                           "error":
                           {
                               "code": "400 BadRequest",
                               "message": "Bad request: one or more parameters were incorrectly
        specified or are mutually exclusive."
                           }
                       }
                   }
               ]
           }.

        :param batch_request: The list of address geocoding queries/requests to process. The list can
         contain  a max of 10,000 queries and must contain at least 1 query. Required.
        :type batch_request: ~azure.maps.search.models.BatchRequest
        :param format: Desired format of the response. Only ``json`` format is supported. "json"
         Default value is "json".
        :type format: str or ~azure.maps.search.models.JsonFormat
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: An instance of LROPoller that returns SearchAddressBatchResult
        :rtype: ~azure.core.polling.LROPoller[~azure.maps.search.models.SearchAddressBatchResult]
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @overload
    def begin_search_address_batch(
        self,
        batch_request: IO[bytes],
        format: Union[str, _models.JsonFormat] = "json",
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> LROPoller[_models.SearchAddressBatchResult]:
        """**Search Address Batch API**

        **Applies to:** see `pricing tiers <https://aka.ms/AzureMapsPricingTier>`_.

        The Search Address Batch API sends batches of queries to `Search Address API
        </rest/api/maps/search/get-search-address?view=rest-maps-1.0>`_ using just a single API call.
        You can call Search Address Batch API to run either asynchronously (async) or synchronously
        (sync). The async API allows caller to batch up to **10,000** queries and sync API up to
        **100** queries.

        Submit Synchronous Batch Request
        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

        The Synchronous API is recommended for lightweight batch requests. When the service receives a
        request, it will respond as soon as the batch items are calculated and there will be no
        possibility to retrieve the results later. The Synchronous API will return a timeout error (a
        408 response) if the request takes longer than 60 seconds. The number of batch items is limited
        to **100** for this API.

        .. code-block::

           POST
        https://atlas.microsoft.com/search/address/batch/sync/json?api-version=1.0&subscription-key={subscription-key}

        Submit Asynchronous Batch Request
        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

        The Asynchronous API is appropriate for processing big volumes of relatively complex search
        requests


        * It allows the retrieval of results in a separate call (multiple downloads are possible).
        * The asynchronous API is optimized for reliability and is not expected to run into a timeout.
        * The number of batch items is limited to **10,000** for this API.

        When you make a request by using async request, by default the service returns a 202 response
        code along a redirect URL in the Location field of the response header. This URL should be
        checked periodically until the response data or error information is available.
        The asynchronous responses are stored for **14** days. The redirect URL returns a 404 response
        if used after the expiration period.

        Please note that asynchronous batch request is a long-running operation. Here's a typical
        sequence of operations:


        #. Client sends a Search Address Batch ``POST`` request to Azure Maps
        #.
           The server will respond with one of the following:

           ..

              HTTP ``202 Accepted`` - Batch request has been accepted.

              HTTP ``Error`` - There was an error processing your Batch request. This could either be a
        ``400 Bad Request`` or any other ``Error`` status code.


        #.
           If the batch request was accepted successfully, the ``Location`` header in the response
        contains the URL to download the results of the batch request.
            This status URI looks like following:

        .. code-block::

               GET
        https://atlas.microsoft.com/search/address/batch/{batch-id}?api-version=1.0&subscription-key={subscription-key}


        #. Client issues a ``GET`` request on the *download URL* obtained in Step 3 to download the
        batch results.

        POST Body for Batch Request
        ^^^^^^^^^^^^^^^^^^^^^^^^^^^

        To send the *search address* queries you will use a ``POST`` request where the request body
        will contain the ``batchItems`` array in ``json`` format and the ``Content-Type`` header will
        be set to ``application/json``. Here's a sample request body containing 5 *search address*
        queries:

        .. code-block:: json

           {
               "batchItems": [
                   {"query": "?query=400 Broad St, Seattle, WA 98109&limit=3"},
                   {"query": "?query=One, Microsoft Way, Redmond, WA 98052&limit=3"},
                   {"query": "?query=350 5th Ave, New York, NY 10118&limit=1"},
                   {"query": "?query=Pike Pl, Seattle, WA
        98101&lat=47.610970&lon=-122.342469&radius=1000"},
                   {"query": "?query=Champ de Mars, 5 Avenue Anatole France, 75007 Paris,
        France&limit=1"}
               ]
           }

        A *search address* query in a batch is just a partial URL *without* the protocol, base URL,
        path, api-version and subscription-key. It can accept any of the supported *search address*
        `URI parameters </rest/api/maps/search/get-search-address?view=rest-maps-1.0#uri-parameters>`_.
        The string values in the *search address* query must be properly escaped (e.g. " character
        should be escaped with ) and it should also be properly URL-encoded.

        The async API allows caller to batch up to **10,000** queries and sync API up to **100**
        queries, and the batch should contain at least **1** query.

        Download Asynchronous Batch Results
        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

        To download the async batch results you will issue a ``GET`` request to the batch download
        endpoint. This *download URL* can be obtained from the ``Location`` header of a successful
        ``POST`` batch request and looks like the following:

        .. code-block::

        https://atlas.microsoft.com/search/address/batch/{batch-id}?api-version=1.0&subscription-key={subscription-key}

        Here's the typical sequence of operations for downloading the batch results:


        #. Client sends a ``GET`` request using the *download URL*.
        #.
           The server will respond with one of the following:

           ..

              HTTP ``202 Accepted`` - Batch request was accepted but is still being processed. Please
        try again in some time.

              HTTP ``200 OK`` - Batch request successfully processed. The response body contains all
        the batch results.


        Batch Response Model
        ^^^^^^^^^^^^^^^^^^^^

        The returned data content is similar for async and sync requests. When downloading the results
        of an async batch request, if the batch has finished processing, the response body contains the
        batch response. This batch response contains a ``summary`` component that indicates the
        ``totalRequests`` that were part of the original batch request and ``successfulRequests``\ i.e.
        queries which were executed successfully. The batch response also includes a ``batchItems``
        array which contains a response for each and every query in the batch request. The
        ``batchItems`` will contain the results in the exact same order the original queries were sent
        in the batch request. Each item in ``batchItems`` contains ``statusCode`` and ``response``
        fields. Each ``response`` in ``batchItems`` is of one of the following types:


        *
          `\ ``SearchAddressResult``
        </rest/api/maps/search/get-search-address?view=rest-maps-1.0#SearchAddressResult>`_ - If the
        query completed successfully.

        *
          ``Error`` - If the query failed. The response will contain a ``code`` and a ``message`` in
        this case.

        Here's a sample Batch Response with 2 *successful* and 1 *failed* result:

        .. code-block:: json

           {
               "summary": {
                   "successfulRequests": 2,
                   "totalRequests": 3
               },
               "batchItems": [
                   {
                       "statusCode": 200,
                       "response":
                       {
                           "summary": {
                               "query": "one microsoft way redmond wa 98052"
                           },
                           "results": [
                               {
                                   "position": {
                                       "lat": 47.63989,
                                       "lon": -122.12509
                                   }
                               }
                           ]
                       }
                   },
                   {
                       "statusCode": 200,
                       "response":
                       {
                           "summary": {
                               "query": "pike pl seattle wa 98101"
                           },
                           "results": [
                               {
                                   "position": {
                                       "lat": 47.60963,
                                       "lon": -122.34215
                                   }
                               }
                           ]
                       }
                   },
                   {
                       "statusCode": 400,
                       "response":
                       {
                           "error":
                           {
                               "code": "400 BadRequest",
                               "message": "Bad request: one or more parameters were incorrectly
        specified or are mutually exclusive."
                           }
                       }
                   }
               ]
           }.

        :param batch_request: The list of address geocoding queries/requests to process. The list can
         contain  a max of 10,000 queries and must contain at least 1 query. Required.
        :type batch_request: IO[bytes]
        :param format: Desired format of the response. Only ``json`` format is supported. "json"
         Default value is "json".
        :type format: str or ~azure.maps.search.models.JsonFormat
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: An instance of LROPoller that returns SearchAddressBatchResult
        :rtype: ~azure.core.polling.LROPoller[~azure.maps.search.models.SearchAddressBatchResult]
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @distributed_trace
    def begin_search_address_batch(
        self,
        batch_request: Union[_models.BatchRequest, IO[bytes]],
        format: Union[str, _models.JsonFormat] = "json",
        **kwargs: Any
    ) -> LROPoller[_models.SearchAddressBatchResult]:
        """**Search Address Batch API**

        **Applies to:** see `pricing tiers <https://aka.ms/AzureMapsPricingTier>`_.

        The Search Address Batch API sends batches of queries to `Search Address API
        </rest/api/maps/search/get-search-address?view=rest-maps-1.0>`_ using just a single API call.
        You can call Search Address Batch API to run either asynchronously (async) or synchronously
        (sync). The async API allows caller to batch up to **10,000** queries and sync API up to
        **100** queries.

        Submit Synchronous Batch Request
        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

        The Synchronous API is recommended for lightweight batch requests. When the service receives a
        request, it will respond as soon as the batch items are calculated and there will be no
        possibility to retrieve the results later. The Synchronous API will return a timeout error (a
        408 response) if the request takes longer than 60 seconds. The number of batch items is limited
        to **100** for this API.

        .. code-block::

           POST
        https://atlas.microsoft.com/search/address/batch/sync/json?api-version=1.0&subscription-key={subscription-key}

        Submit Asynchronous Batch Request
        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

        The Asynchronous API is appropriate for processing big volumes of relatively complex search
        requests


        * It allows the retrieval of results in a separate call (multiple downloads are possible).
        * The asynchronous API is optimized for reliability and is not expected to run into a timeout.
        * The number of batch items is limited to **10,000** for this API.

        When you make a request by using async request, by default the service returns a 202 response
        code along a redirect URL in the Location field of the response header. This URL should be
        checked periodically until the response data or error information is available.
        The asynchronous responses are stored for **14** days. The redirect URL returns a 404 response
        if used after the expiration period.

        Please note that asynchronous batch request is a long-running operation. Here's a typical
        sequence of operations:


        #. Client sends a Search Address Batch ``POST`` request to Azure Maps
        #.
           The server will respond with one of the following:

           ..

              HTTP ``202 Accepted`` - Batch request has been accepted.

              HTTP ``Error`` - There was an error processing your Batch request. This could either be a
        ``400 Bad Request`` or any other ``Error`` status code.


        #.
           If the batch request was accepted successfully, the ``Location`` header in the response
        contains the URL to download the results of the batch request.
            This status URI looks like following:

        .. code-block::

               GET
        https://atlas.microsoft.com/search/address/batch/{batch-id}?api-version=1.0&subscription-key={subscription-key}


        #. Client issues a ``GET`` request on the *download URL* obtained in Step 3 to download the
        batch results.

        POST Body for Batch Request
        ^^^^^^^^^^^^^^^^^^^^^^^^^^^

        To send the *search address* queries you will use a ``POST`` request where the request body
        will contain the ``batchItems`` array in ``json`` format and the ``Content-Type`` header will
        be set to ``application/json``. Here's a sample request body containing 5 *search address*
        queries:

        .. code-block:: json

           {
               "batchItems": [
                   {"query": "?query=400 Broad St, Seattle, WA 98109&limit=3"},
                   {"query": "?query=One, Microsoft Way, Redmond, WA 98052&limit=3"},
                   {"query": "?query=350 5th Ave, New York, NY 10118&limit=1"},
                   {"query": "?query=Pike Pl, Seattle, WA
        98101&lat=47.610970&lon=-122.342469&radius=1000"},
                   {"query": "?query=Champ de Mars, 5 Avenue Anatole France, 75007 Paris,
        France&limit=1"}
               ]
           }

        A *search address* query in a batch is just a partial URL *without* the protocol, base URL,
        path, api-version and subscription-key. It can accept any of the supported *search address*
        `URI parameters </rest/api/maps/search/get-search-address?view=rest-maps-1.0#uri-parameters>`_.
        The string values in the *search address* query must be properly escaped (e.g. " character
        should be escaped with ) and it should also be properly URL-encoded.

        The async API allows caller to batch up to **10,000** queries and sync API up to **100**
        queries, and the batch should contain at least **1** query.

        Download Asynchronous Batch Results
        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

        To download the async batch results you will issue a ``GET`` request to the batch download
        endpoint. This *download URL* can be obtained from the ``Location`` header of a successful
        ``POST`` batch request and looks like the following:

        .. code-block::

        https://atlas.microsoft.com/search/address/batch/{batch-id}?api-version=1.0&subscription-key={subscription-key}

        Here's the typical sequence of operations for downloading the batch results:


        #. Client sends a ``GET`` request using the *download URL*.
        #.
           The server will respond with one of the following:

           ..

              HTTP ``202 Accepted`` - Batch request was accepted but is still being processed. Please
        try again in some time.

              HTTP ``200 OK`` - Batch request successfully processed. The response body contains all
        the batch results.


        Batch Response Model
        ^^^^^^^^^^^^^^^^^^^^

        The returned data content is similar for async and sync requests. When downloading the results
        of an async batch request, if the batch has finished processing, the response body contains the
        batch response. This batch response contains a ``summary`` component that indicates the
        ``totalRequests`` that were part of the original batch request and ``successfulRequests``\ i.e.
        queries which were executed successfully. The batch response also includes a ``batchItems``
        array which contains a response for each and every query in the batch request. The
        ``batchItems`` will contain the results in the exact same order the original queries were sent
        in the batch request. Each item in ``batchItems`` contains ``statusCode`` and ``response``
        fields. Each ``response`` in ``batchItems`` is of one of the following types:


        *
          `\ ``SearchAddressResult``
        </rest/api/maps/search/get-search-address?view=rest-maps-1.0#SearchAddressResult>`_ - If the
        query completed successfully.

        *
          ``Error`` - If the query failed. The response will contain a ``code`` and a ``message`` in
        this case.

        Here's a sample Batch Response with 2 *successful* and 1 *failed* result:

        .. code-block:: json

           {
               "summary": {
                   "successfulRequests": 2,
                   "totalRequests": 3
               },
               "batchItems": [
                   {
                       "statusCode": 200,
                       "response":
                       {
                           "summary": {
                               "query": "one microsoft way redmond wa 98052"
                           },
                           "results": [
                               {
                                   "position": {
                                       "lat": 47.63989,
                                       "lon": -122.12509
                                   }
                               }
                           ]
                       }
                   },
                   {
                       "statusCode": 200,
                       "response":
                       {
                           "summary": {
                               "query": "pike pl seattle wa 98101"
                           },
                           "results": [
                               {
                                   "position": {
                                       "lat": 47.60963,
                                       "lon": -122.34215
                                   }
                               }
                           ]
                       }
                   },
                   {
                       "statusCode": 400,
                       "response":
                       {
                           "error":
                           {
                               "code": "400 BadRequest",
                               "message": "Bad request: one or more parameters were incorrectly
        specified or are mutually exclusive."
                           }
                       }
                   }
               ]
           }.

        :param batch_request: The list of address geocoding queries/requests to process. The list can
         contain  a max of 10,000 queries and must contain at least 1 query. Is either a BatchRequest
         type or a IO[bytes] type. Required.
        :type batch_request: ~azure.maps.search.models.BatchRequest or IO[bytes]
        :param format: Desired format of the response. Only ``json`` format is supported. "json"
         Default value is "json".
        :type format: str or ~azure.maps.search.models.JsonFormat
        :return: An instance of LROPoller that returns SearchAddressBatchResult
        :rtype: ~azure.core.polling.LROPoller[~azure.maps.search.models.SearchAddressBatchResult]
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[_models.SearchAddressBatchResult] = kwargs.pop("cls", None)
        polling: Union[bool, PollingMethod] = kwargs.pop("polling", True)
        lro_delay = kwargs.pop("polling_interval", self._config.polling_interval)
        cont_token: Optional[str] = kwargs.pop("continuation_token", None)
        if cont_token is None:
            raw_result = self._search_address_batch_initial(
                batch_request=batch_request,
                format=format,
                content_type=content_type,
                cls=lambda x, y, z: x,
                headers=_headers,
                params=_params,
                **kwargs
            )
        kwargs.pop("error_map", None)

        def get_long_running_output(pipeline_response):
            deserialized = self._deserialize("SearchAddressBatchResult", pipeline_response)
            if cls:
                return cls(pipeline_response, deserialized, {})  # type: ignore
            return deserialized

        if polling is True:
            polling_method: PollingMethod = cast(
                PollingMethod, LROBasePolling(lro_delay, lro_options={"final-state-via": "location"}, **kwargs)
            )
        elif polling is False:
            polling_method = cast(PollingMethod, NoPolling())
        else:
            polling_method = polling
        if cont_token:
            return LROPoller[_models.SearchAddressBatchResult].from_continuation_token(
                polling_method=polling_method,
                continuation_token=cont_token,
                client=self._client,
                deserialization_callback=get_long_running_output,
            )
        return LROPoller[_models.SearchAddressBatchResult](
            self._client, raw_result, get_long_running_output, polling_method  # type: ignore
        )

    def _get_search_address_batch_initial(
        self, batch_id: str, **kwargs: Any
    ) -> Optional[_models.SearchAddressBatchResult]:
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[Optional[_models.SearchAddressBatchResult]] = kwargs.pop("cls", None)

        _request = build_search_get_search_address_batch_request(
            batch_id=batch_id,
            client_id=self._config.client_id,
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = False
        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200, 202]:
            if _stream:
                response.read()  # Load the body in memory and close the socket
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        deserialized = None
        response_headers = {}
        if response.status_code == 200:
            deserialized = self._deserialize("SearchAddressBatchResult", pipeline_response)

        if response.status_code == 202:
            response_headers["Location"] = self._deserialize("str", response.headers.get("Location"))

        if cls:
            return cls(pipeline_response, deserialized, response_headers)  # type: ignore

        return deserialized  # type: ignore

    @distributed_trace
    def begin_get_search_address_batch(
        self, batch_id: str, **kwargs: Any
    ) -> LROPoller[_models.SearchAddressBatchResult]:
        """**Search Address Batch API**

        **Applies to:** see `pricing tiers <https://aka.ms/AzureMapsPricingTier>`_.

        The Search Address Batch API sends batches of queries to `Search Address API
        </rest/api/maps/search/get-search-address?view=rest-maps-1.0>`_ using just a single API call.
        You can call Search Address Batch API to run either asynchronously (async) or synchronously
        (sync). The async API allows caller to batch up to **10,000** queries and sync API up to
        **100** queries.

        Submit Synchronous Batch Request
        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

        The Synchronous API is recommended for lightweight batch requests. When the service receives a
        request, it will respond as soon as the batch items are calculated and there will be no
        possibility to retrieve the results later. The Synchronous API will return a timeout error (a
        408 response) if the request takes longer than 60 seconds. The number of batch items is limited
        to **100** for this API.

        .. code-block::

           POST
        https://atlas.microsoft.com/search/address/batch/sync/json?api-version=1.0&subscription-key={subscription-key}

        Submit Asynchronous Batch Request
        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

        The Asynchronous API is appropriate for processing big volumes of relatively complex search
        requests


        * It allows the retrieval of results in a separate call (multiple downloads are possible).
        * The asynchronous API is optimized for reliability and is not expected to run into a timeout.
        * The number of batch items is limited to **10,000** for this API.

        When you make a request by using async request, by default the service returns a 202 response
        code along a redirect URL in the Location field of the response header. This URL should be
        checked periodically until the response data or error information is available.
        The asynchronous responses are stored for **14** days. The redirect URL returns a 404 response
        if used after the expiration period.

        Please note that asynchronous batch request is a long-running operation. Here's a typical
        sequence of operations:


        #. Client sends a Search Address Batch ``POST`` request to Azure Maps
        #.
           The server will respond with one of the following:

           ..

              HTTP ``202 Accepted`` - Batch request has been accepted.

              HTTP ``Error`` - There was an error processing your Batch request. This could either be a
        ``400 Bad Request`` or any other ``Error`` status code.


        #.
           If the batch request was accepted successfully, the ``Location`` header in the response
        contains the URL to download the results of the batch request.
            This status URI looks like following:

        .. code-block::

               GET
        https://atlas.microsoft.com/search/address/batch/{batch-id}?api-version=1.0&subscription-key={subscription-key}


        #. Client issues a ``GET`` request on the *download URL* obtained in Step 3 to download the
        batch results.

        POST Body for Batch Request
        ^^^^^^^^^^^^^^^^^^^^^^^^^^^

        To send the *search address* queries you will use a ``POST`` request where the request body
        will contain the ``batchItems`` array in ``json`` format and the ``Content-Type`` header will
        be set to ``application/json``. Here's a sample request body containing 5 *search address*
        queries:

        .. code-block:: json

           {
               "batchItems": [
                   {"query": "?query=400 Broad St, Seattle, WA 98109&limit=3"},
                   {"query": "?query=One, Microsoft Way, Redmond, WA 98052&limit=3"},
                   {"query": "?query=350 5th Ave, New York, NY 10118&limit=1"},
                   {"query": "?query=Pike Pl, Seattle, WA
        98101&lat=47.610970&lon=-122.342469&radius=1000"},
                   {"query": "?query=Champ de Mars, 5 Avenue Anatole France, 75007 Paris,
        France&limit=1"}
               ]
           }

        A *search address* query in a batch is just a partial URL *without* the protocol, base URL,
        path, api-version and subscription-key. It can accept any of the supported *search address*
        `URI parameters </rest/api/maps/search/get-search-address?view=rest-maps-1.0#uri-parameters>`_.
        The string values in the *search address* query must be properly escaped (e.g. " character
        should be escaped with ) and it should also be properly URL-encoded.

        The async API allows caller to batch up to **10,000** queries and sync API up to **100**
        queries, and the batch should contain at least **1** query.

        Download Asynchronous Batch Results
        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

        To download the async batch results you will issue a ``GET`` request to the batch download
        endpoint. This *download URL* can be obtained from the ``Location`` header of a successful
        ``POST`` batch request and looks like the following:

        .. code-block::

        https://atlas.microsoft.com/search/address/batch/{batch-id}?api-version=1.0&subscription-key={subscription-key}

        Here's the typical sequence of operations for downloading the batch results:


        #. Client sends a ``GET`` request using the *download URL*.
        #.
           The server will respond with one of the following:

           ..

              HTTP ``202 Accepted`` - Batch request was accepted but is still being processed. Please
        try again in some time.

              HTTP ``200 OK`` - Batch request successfully processed. The response body contains all
        the batch results.


        Batch Response Model
        ^^^^^^^^^^^^^^^^^^^^

        The returned data content is similar for async and sync requests. When downloading the results
        of an async batch request, if the batch has finished processing, the response body contains the
        batch response. This batch response contains a ``summary`` component that indicates the
        ``totalRequests`` that were part of the original batch request and ``successfulRequests``\ i.e.
        queries which were executed successfully. The batch response also includes a ``batchItems``
        array which contains a response for each and every query in the batch request. The
        ``batchItems`` will contain the results in the exact same order the original queries were sent
        in the batch request. Each item in ``batchItems`` contains ``statusCode`` and ``response``
        fields. Each ``response`` in ``batchItems`` is of one of the following types:


        *
          `\ ``SearchAddressResult``
        </rest/api/maps/search/get-search-address?view=rest-maps-1.0#SearchAddressResult>`_ - If the
        query completed successfully.

        *
          ``Error`` - If the query failed. The response will contain a ``code`` and a ``message`` in
        this case.

        Here's a sample Batch Response with 2 *successful* and 1 *failed* result:

        .. code-block:: json

           {
               "summary": {
                   "successfulRequests": 2,
                   "totalRequests": 3
               },
               "batchItems": [
                   {
                       "statusCode": 200,
                       "response":
                       {
                           "summary": {
                               "query": "one microsoft way redmond wa 98052"
                           },
                           "results": [
                               {
                                   "position": {
                                       "lat": 47.63989,
                                       "lon": -122.12509
                                   }
                               }
                           ]
                       }
                   },
                   {
                       "statusCode": 200,
                       "response":
                       {
                           "summary": {
                               "query": "pike pl seattle wa 98101"
                           },
                           "results": [
                               {
                                   "position": {
                                       "lat": 47.60963,
                                       "lon": -122.34215
                                   }
                               }
                           ]
                       }
                   },
                   {
                       "statusCode": 400,
                       "response":
                       {
                           "error":
                           {
                               "code": "400 BadRequest",
                               "message": "Bad request: one or more parameters were incorrectly
        specified or are mutually exclusive."
                           }
                       }
                   }
               ]
           }.

        :param batch_id: Batch id for querying the operation. Required.
        :type batch_id: str
        :return: An instance of LROPoller that returns SearchAddressBatchResult
        :rtype: ~azure.core.polling.LROPoller[~azure.maps.search.models.SearchAddressBatchResult]
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[_models.SearchAddressBatchResult] = kwargs.pop("cls", None)
        polling: Union[bool, PollingMethod] = kwargs.pop("polling", True)
        lro_delay = kwargs.pop("polling_interval", self._config.polling_interval)
        cont_token: Optional[str] = kwargs.pop("continuation_token", None)
        if cont_token is None:
            raw_result = self._get_search_address_batch_initial(
                batch_id=batch_id, cls=lambda x, y, z: x, headers=_headers, params=_params, **kwargs
            )
        kwargs.pop("error_map", None)

        def get_long_running_output(pipeline_response):
            deserialized = self._deserialize("SearchAddressBatchResult", pipeline_response)
            if cls:
                return cls(pipeline_response, deserialized, {})  # type: ignore
            return deserialized

        if polling is True:
            polling_method: PollingMethod = cast(
                PollingMethod, LROBasePolling(lro_delay, lro_options={"final-state-via": "original-uri"}, **kwargs)
            )
        elif polling is False:
            polling_method = cast(PollingMethod, NoPolling())
        else:
            polling_method = polling
        if cont_token:
            return LROPoller[_models.SearchAddressBatchResult].from_continuation_token(
                polling_method=polling_method,
                continuation_token=cont_token,
                client=self._client,
                deserialization_callback=get_long_running_output,
            )
        return LROPoller[_models.SearchAddressBatchResult](
            self._client, raw_result, get_long_running_output, polling_method  # type: ignore
        )

    @overload
    def reverse_search_address_batch_sync(
        self,
        batch_request: _models.BatchRequest,
        format: Union[str, _models.JsonFormat] = "json",
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> _models.ReverseSearchAddressBatchResult:
        """**Search Address Reverse Batch API**

        **Applies to:** see `pricing tiers <https://aka.ms/AzureMapsPricingTier>`_.

        The Search Address Reverse Batch API sends batches of queries to `Search Address Reverse API
        </rest/api/maps/search/get-search-address-reverse?view=rest-maps-1.0>`_ using just a single API
        call. You can call Search Address Reverse Batch API to run either asynchronously (async) or
        synchronously (sync). The async API allows caller to batch up to **10,000** queries and sync
        API up to **100** queries.

        Submit Synchronous Batch Request
        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

        The Synchronous API is recommended for lightweight batch requests. When the service receives a
        request, it will respond as soon as the batch items are calculated and there will be no
        possibility to retrieve the results later. The Synchronous API will return a timeout error (a
        408 response) if the request takes longer than 60 seconds. The number of batch items is limited
        to **100** for this API.

        .. code-block::

           POST
        https://atlas.microsoft.com/search/address/reverse/batch/sync/json?api-version=1.0&subscription-key={subscription-key}

        Submit Asynchronous Batch Request
        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

        The Asynchronous API is appropriate for processing big volumes of relatively complex search
        requests


        * It allows the retrieval of results in a separate call (multiple downloads are possible).
        * The asynchronous API is optimized for reliability and is not expected to run into a timeout.
        * The number of batch items is limited to **10,000** for this API.

        When you make a request by using async request, by default the service returns a 202 response
        code along a redirect URL in the Location field of the response header. This URL should be
        checked periodically until the response data or error information is available.
        The asynchronous responses are stored for **14** days. The redirect URL returns a 404 response
        if used after the expiration period.

        Please note that asynchronous batch request is a long-running operation. Here's a typical
        sequence of operations:


        #. Client sends a Search Address Reverse Batch ``POST`` request to Azure Maps
        #.
           The server will respond with one of the following:

           ..

              HTTP ``202 Accepted`` - Batch request has been accepted.

              HTTP ``Error`` - There was an error processing your Batch request. This could either be a
        ``400 Bad Request`` or any other ``Error`` status code.


        #.
           If the batch request was accepted successfully, the ``Location`` header in the response
        contains the URL to download the results of the batch request.
            This status URI looks like following:

        .. code-block::

               GET
        https://atlas.microsoft.com/search/address/reverse/batch/{batch-id}?api-version=1.0&subscription-key={subscription-key}


        #. Client issues a ``GET`` request on the *download URL* obtained in Step 3 to download the
        batch results.

        POST Body for Batch Request
        ^^^^^^^^^^^^^^^^^^^^^^^^^^^

        To send the *search address reverse* queries you will use a ``POST`` request where the request
        body will contain the ``batchItems`` array in ``json`` format and the ``Content-Type`` header
        will be set to ``application/json``. Here's a sample request body containing 5 *search address
        reverse* queries:

        .. code-block:: json

           {
               "batchItems": [
                   {"query": "?query=48.858561,2.294911"},
                   {"query": "?query=47.639765,-122.127896&radius=5000&limit=2"},
                   {"query": "?query=47.621028,-122.348170"},
                   {"query": "?query=43.722990,10.396695"},
                   {"query": "?query=40.750958,-73.982336"}
               ]
           }

        A *search address reverse* query in a batch is just a partial URL *without* the protocol, base
        URL, path, api-version and subscription-key. It can accept any of the supported *search address
        reverse* `URI parameters
        </rest/api/maps/search/get-search-address-reverse?view=rest-maps-1.0#uri-parameters>`_. The
        string values in the *search address reverse* query must be properly escaped (e.g. " character
        should be escaped with ) and it should also be properly URL-encoded.

        The async API allows caller to batch up to **10,000** queries and sync API up to **100**
        queries, and the batch should contain at least **1** query.

        Download Asynchronous Batch Results
        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

        To download the async batch results you will issue a ``GET`` request to the batch download
        endpoint. This *download URL* can be obtained from the ``Location`` header of a successful
        ``POST`` batch request and looks like the following:

        .. code-block::

        https://atlas.microsoft.com/search/address/reverse/batch/{batch-id}?api-version=1.0&subscription-key={subscription-key}

        Here's the typical sequence of operations for downloading the batch results:


        #. Client sends a ``GET`` request using the *download URL*.
        #.
           The server will respond with one of the following:

           ..

              HTTP ``202 Accepted`` - Batch request was accepted but is still being processed. Please
        try again in some time.

              HTTP ``200 OK`` - Batch request successfully processed. The response body contains all
        the batch results.


        Batch Response Model
        ^^^^^^^^^^^^^^^^^^^^

        The returned data content is similar for async and sync requests. When downloading the results
        of an async batch request, if the batch has finished processing, the response body contains the
        batch response. This batch response contains a ``summary`` component that indicates the
        ``totalRequests`` that were part of the original batch request and ``successfulRequests``\ i.e.
        queries which were executed successfully. The batch response also includes a ``batchItems``
        array which contains a response for each and every query in the batch request. The
        ``batchItems`` will contain the results in the exact same order the original queries were sent
        in the batch request. Each item in ``batchItems`` contains ``statusCode`` and ``response``
        fields. Each ``response`` in ``batchItems`` is of one of the following types:


        *
          `\ ``SearchAddressReverseResponse``
        </rest/api/maps/search/get-search-address-reverse?view=rest-maps-1.0#searchaddressreverseresponse>`_
        - If the query completed successfully.

        *
          ``Error`` - If the query failed. The response will contain a ``code`` and a ``message`` in
        this case.

        Here's a sample Batch Response with 2 *successful* and 1 *failed* result:

        .. code-block:: json

           {
               "summary": {
                   "successfulRequests": 2,
                   "totalRequests": 3
               },
               "batchItems": [
                   {
                       "statusCode": 200,
                       "response":
                       {
                           "summary": {
                               "queryTime": 11
                           },
                           "addresses": [
                               {
                                   "address": {
                                       "country": "France",
                                       "freeformAddress": "Avenue Anatole France, 75007 Paris"
                                   },
                                   "position": "48.858490,2.294820"
                               }
                           ]
                       }
                   },
                   {
                       "statusCode": 200,
                       "response":
                       {
                           "summary": {
                               "queryTime": 1
                           },
                           "addresses": [
                               {
                                   "address": {
                                       "country": "United States of America",
                                       "freeformAddress": "157th Pl NE, Redmond WA 98052"
                                   },
                                   "position": "47.640470,-122.129430"
                               }
                           ]
                       }
                   },
                   {
                       "statusCode": 400,
                       "response":
                       {
                           "error":
                           {
                               "code": "400 BadRequest",
                               "message": "Bad request: one or more parameters were incorrectly
        specified or are mutually exclusive."
                           }
                       }
                   }
               ]
           }.

        :param batch_request: The list of reverse geocoding queries/requests to process. The list can
         contain  a max of 10,000 queries and must contain at least 1 query. Required.
        :type batch_request: ~azure.maps.search.models.BatchRequest
        :param format: Desired format of the response. Only ``json`` format is supported. "json"
         Default value is "json".
        :type format: str or ~azure.maps.search.models.JsonFormat
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: ReverseSearchAddressBatchResult
        :rtype: ~azure.maps.search.models.ReverseSearchAddressBatchResult
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @overload
    def reverse_search_address_batch_sync(
        self,
        batch_request: IO[bytes],
        format: Union[str, _models.JsonFormat] = "json",
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> _models.ReverseSearchAddressBatchResult:
        """**Search Address Reverse Batch API**

        **Applies to:** see `pricing tiers <https://aka.ms/AzureMapsPricingTier>`_.

        The Search Address Reverse Batch API sends batches of queries to `Search Address Reverse API
        </rest/api/maps/search/get-search-address-reverse?view=rest-maps-1.0>`_ using just a single API
        call. You can call Search Address Reverse Batch API to run either asynchronously (async) or
        synchronously (sync). The async API allows caller to batch up to **10,000** queries and sync
        API up to **100** queries.

        Submit Synchronous Batch Request
        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

        The Synchronous API is recommended for lightweight batch requests. When the service receives a
        request, it will respond as soon as the batch items are calculated and there will be no
        possibility to retrieve the results later. The Synchronous API will return a timeout error (a
        408 response) if the request takes longer than 60 seconds. The number of batch items is limited
        to **100** for this API.

        .. code-block::

           POST
        https://atlas.microsoft.com/search/address/reverse/batch/sync/json?api-version=1.0&subscription-key={subscription-key}

        Submit Asynchronous Batch Request
        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

        The Asynchronous API is appropriate for processing big volumes of relatively complex search
        requests


        * It allows the retrieval of results in a separate call (multiple downloads are possible).
        * The asynchronous API is optimized for reliability and is not expected to run into a timeout.
        * The number of batch items is limited to **10,000** for this API.

        When you make a request by using async request, by default the service returns a 202 response
        code along a redirect URL in the Location field of the response header. This URL should be
        checked periodically until the response data or error information is available.
        The asynchronous responses are stored for **14** days. The redirect URL returns a 404 response
        if used after the expiration period.

        Please note that asynchronous batch request is a long-running operation. Here's a typical
        sequence of operations:


        #. Client sends a Search Address Reverse Batch ``POST`` request to Azure Maps
        #.
           The server will respond with one of the following:

           ..

              HTTP ``202 Accepted`` - Batch request has been accepted.

              HTTP ``Error`` - There was an error processing your Batch request. This could either be a
        ``400 Bad Request`` or any other ``Error`` status code.


        #.
           If the batch request was accepted successfully, the ``Location`` header in the response
        contains the URL to download the results of the batch request.
            This status URI looks like following:

        .. code-block::

               GET
        https://atlas.microsoft.com/search/address/reverse/batch/{batch-id}?api-version=1.0&subscription-key={subscription-key}


        #. Client issues a ``GET`` request on the *download URL* obtained in Step 3 to download the
        batch results.

        POST Body for Batch Request
        ^^^^^^^^^^^^^^^^^^^^^^^^^^^

        To send the *search address reverse* queries you will use a ``POST`` request where the request
        body will contain the ``batchItems`` array in ``json`` format and the ``Content-Type`` header
        will be set to ``application/json``. Here's a sample request body containing 5 *search address
        reverse* queries:

        .. code-block:: json

           {
               "batchItems": [
                   {"query": "?query=48.858561,2.294911"},
                   {"query": "?query=47.639765,-122.127896&radius=5000&limit=2"},
                   {"query": "?query=47.621028,-122.348170"},
                   {"query": "?query=43.722990,10.396695"},
                   {"query": "?query=40.750958,-73.982336"}
               ]
           }

        A *search address reverse* query in a batch is just a partial URL *without* the protocol, base
        URL, path, api-version and subscription-key. It can accept any of the supported *search address
        reverse* `URI parameters
        </rest/api/maps/search/get-search-address-reverse?view=rest-maps-1.0#uri-parameters>`_. The
        string values in the *search address reverse* query must be properly escaped (e.g. " character
        should be escaped with ) and it should also be properly URL-encoded.

        The async API allows caller to batch up to **10,000** queries and sync API up to **100**
        queries, and the batch should contain at least **1** query.

        Download Asynchronous Batch Results
        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

        To download the async batch results you will issue a ``GET`` request to the batch download
        endpoint. This *download URL* can be obtained from the ``Location`` header of a successful
        ``POST`` batch request and looks like the following:

        .. code-block::

        https://atlas.microsoft.com/search/address/reverse/batch/{batch-id}?api-version=1.0&subscription-key={subscription-key}

        Here's the typical sequence of operations for downloading the batch results:


        #. Client sends a ``GET`` request using the *download URL*.
        #.
           The server will respond with one of the following:

           ..

              HTTP ``202 Accepted`` - Batch request was accepted but is still being processed. Please
        try again in some time.

              HTTP ``200 OK`` - Batch request successfully processed. The response body contains all
        the batch results.


        Batch Response Model
        ^^^^^^^^^^^^^^^^^^^^

        The returned data content is similar for async and sync requests. When downloading the results
        of an async batch request, if the batch has finished processing, the response body contains the
        batch response. This batch response contains a ``summary`` component that indicates the
        ``totalRequests`` that were part of the original batch request and ``successfulRequests``\ i.e.
        queries which were executed successfully. The batch response also includes a ``batchItems``
        array which contains a response for each and every query in the batch request. The
        ``batchItems`` will contain the results in the exact same order the original queries were sent
        in the batch request. Each item in ``batchItems`` contains ``statusCode`` and ``response``
        fields. Each ``response`` in ``batchItems`` is of one of the following types:


        *
          `\ ``SearchAddressReverseResponse``
        </rest/api/maps/search/get-search-address-reverse?view=rest-maps-1.0#searchaddressreverseresponse>`_
        - If the query completed successfully.

        *
          ``Error`` - If the query failed. The response will contain a ``code`` and a ``message`` in
        this case.

        Here's a sample Batch Response with 2 *successful* and 1 *failed* result:

        .. code-block:: json

           {
               "summary": {
                   "successfulRequests": 2,
                   "totalRequests": 3
               },
               "batchItems": [
                   {
                       "statusCode": 200,
                       "response":
                       {
                           "summary": {
                               "queryTime": 11
                           },
                           "addresses": [
                               {
                                   "address": {
                                       "country": "France",
                                       "freeformAddress": "Avenue Anatole France, 75007 Paris"
                                   },
                                   "position": "48.858490,2.294820"
                               }
                           ]
                       }
                   },
                   {
                       "statusCode": 200,
                       "response":
                       {
                           "summary": {
                               "queryTime": 1
                           },
                           "addresses": [
                               {
                                   "address": {
                                       "country": "United States of America",
                                       "freeformAddress": "157th Pl NE, Redmond WA 98052"
                                   },
                                   "position": "47.640470,-122.129430"
                               }
                           ]
                       }
                   },
                   {
                       "statusCode": 400,
                       "response":
                       {
                           "error":
                           {
                               "code": "400 BadRequest",
                               "message": "Bad request: one or more parameters were incorrectly
        specified or are mutually exclusive."
                           }
                       }
                   }
               ]
           }.

        :param batch_request: The list of reverse geocoding queries/requests to process. The list can
         contain  a max of 10,000 queries and must contain at least 1 query. Required.
        :type batch_request: IO[bytes]
        :param format: Desired format of the response. Only ``json`` format is supported. "json"
         Default value is "json".
        :type format: str or ~azure.maps.search.models.JsonFormat
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: ReverseSearchAddressBatchResult
        :rtype: ~azure.maps.search.models.ReverseSearchAddressBatchResult
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @distributed_trace
    def reverse_search_address_batch_sync(
        self,
        batch_request: Union[_models.BatchRequest, IO[bytes]],
        format: Union[str, _models.JsonFormat] = "json",
        **kwargs: Any
    ) -> _models.ReverseSearchAddressBatchResult:
        """**Search Address Reverse Batch API**

        **Applies to:** see `pricing tiers <https://aka.ms/AzureMapsPricingTier>`_.

        The Search Address Reverse Batch API sends batches of queries to `Search Address Reverse API
        </rest/api/maps/search/get-search-address-reverse?view=rest-maps-1.0>`_ using just a single API
        call. You can call Search Address Reverse Batch API to run either asynchronously (async) or
        synchronously (sync). The async API allows caller to batch up to **10,000** queries and sync
        API up to **100** queries.

        Submit Synchronous Batch Request
        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

        The Synchronous API is recommended for lightweight batch requests. When the service receives a
        request, it will respond as soon as the batch items are calculated and there will be no
        possibility to retrieve the results later. The Synchronous API will return a timeout error (a
        408 response) if the request takes longer than 60 seconds. The number of batch items is limited
        to **100** for this API.

        .. code-block::

           POST
        https://atlas.microsoft.com/search/address/reverse/batch/sync/json?api-version=1.0&subscription-key={subscription-key}

        Submit Asynchronous Batch Request
        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

        The Asynchronous API is appropriate for processing big volumes of relatively complex search
        requests


        * It allows the retrieval of results in a separate call (multiple downloads are possible).
        * The asynchronous API is optimized for reliability and is not expected to run into a timeout.
        * The number of batch items is limited to **10,000** for this API.

        When you make a request by using async request, by default the service returns a 202 response
        code along a redirect URL in the Location field of the response header. This URL should be
        checked periodically until the response data or error information is available.
        The asynchronous responses are stored for **14** days. The redirect URL returns a 404 response
        if used after the expiration period.

        Please note that asynchronous batch request is a long-running operation. Here's a typical
        sequence of operations:


        #. Client sends a Search Address Reverse Batch ``POST`` request to Azure Maps
        #.
           The server will respond with one of the following:

           ..

              HTTP ``202 Accepted`` - Batch request has been accepted.

              HTTP ``Error`` - There was an error processing your Batch request. This could either be a
        ``400 Bad Request`` or any other ``Error`` status code.


        #.
           If the batch request was accepted successfully, the ``Location`` header in the response
        contains the URL to download the results of the batch request.
            This status URI looks like following:

        .. code-block::

               GET
        https://atlas.microsoft.com/search/address/reverse/batch/{batch-id}?api-version=1.0&subscription-key={subscription-key}


        #. Client issues a ``GET`` request on the *download URL* obtained in Step 3 to download the
        batch results.

        POST Body for Batch Request
        ^^^^^^^^^^^^^^^^^^^^^^^^^^^

        To send the *search address reverse* queries you will use a ``POST`` request where the request
        body will contain the ``batchItems`` array in ``json`` format and the ``Content-Type`` header
        will be set to ``application/json``. Here's a sample request body containing 5 *search address
        reverse* queries:

        .. code-block:: json

           {
               "batchItems": [
                   {"query": "?query=48.858561,2.294911"},
                   {"query": "?query=47.639765,-122.127896&radius=5000&limit=2"},
                   {"query": "?query=47.621028,-122.348170"},
                   {"query": "?query=43.722990,10.396695"},
                   {"query": "?query=40.750958,-73.982336"}
               ]
           }

        A *search address reverse* query in a batch is just a partial URL *without* the protocol, base
        URL, path, api-version and subscription-key. It can accept any of the supported *search address
        reverse* `URI parameters
        </rest/api/maps/search/get-search-address-reverse?view=rest-maps-1.0#uri-parameters>`_. The
        string values in the *search address reverse* query must be properly escaped (e.g. " character
        should be escaped with ) and it should also be properly URL-encoded.

        The async API allows caller to batch up to **10,000** queries and sync API up to **100**
        queries, and the batch should contain at least **1** query.

        Download Asynchronous Batch Results
        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

        To download the async batch results you will issue a ``GET`` request to the batch download
        endpoint. This *download URL* can be obtained from the ``Location`` header of a successful
        ``POST`` batch request and looks like the following:

        .. code-block::

        https://atlas.microsoft.com/search/address/reverse/batch/{batch-id}?api-version=1.0&subscription-key={subscription-key}

        Here's the typical sequence of operations for downloading the batch results:


        #. Client sends a ``GET`` request using the *download URL*.
        #.
           The server will respond with one of the following:

           ..

              HTTP ``202 Accepted`` - Batch request was accepted but is still being processed. Please
        try again in some time.

              HTTP ``200 OK`` - Batch request successfully processed. The response body contains all
        the batch results.


        Batch Response Model
        ^^^^^^^^^^^^^^^^^^^^

        The returned data content is similar for async and sync requests. When downloading the results
        of an async batch request, if the batch has finished processing, the response body contains the
        batch response. This batch response contains a ``summary`` component that indicates the
        ``totalRequests`` that were part of the original batch request and ``successfulRequests``\ i.e.
        queries which were executed successfully. The batch response also includes a ``batchItems``
        array which contains a response for each and every query in the batch request. The
        ``batchItems`` will contain the results in the exact same order the original queries were sent
        in the batch request. Each item in ``batchItems`` contains ``statusCode`` and ``response``
        fields. Each ``response`` in ``batchItems`` is of one of the following types:


        *
          `\ ``SearchAddressReverseResponse``
        </rest/api/maps/search/get-search-address-reverse?view=rest-maps-1.0#searchaddressreverseresponse>`_
        - If the query completed successfully.

        *
          ``Error`` - If the query failed. The response will contain a ``code`` and a ``message`` in
        this case.

        Here's a sample Batch Response with 2 *successful* and 1 *failed* result:

        .. code-block:: json

           {
               "summary": {
                   "successfulRequests": 2,
                   "totalRequests": 3
               },
               "batchItems": [
                   {
                       "statusCode": 200,
                       "response":
                       {
                           "summary": {
                               "queryTime": 11
                           },
                           "addresses": [
                               {
                                   "address": {
                                       "country": "France",
                                       "freeformAddress": "Avenue Anatole France, 75007 Paris"
                                   },
                                   "position": "48.858490,2.294820"
                               }
                           ]
                       }
                   },
                   {
                       "statusCode": 200,
                       "response":
                       {
                           "summary": {
                               "queryTime": 1
                           },
                           "addresses": [
                               {
                                   "address": {
                                       "country": "United States of America",
                                       "freeformAddress": "157th Pl NE, Redmond WA 98052"
                                   },
                                   "position": "47.640470,-122.129430"
                               }
                           ]
                       }
                   },
                   {
                       "statusCode": 400,
                       "response":
                       {
                           "error":
                           {
                               "code": "400 BadRequest",
                               "message": "Bad request: one or more parameters were incorrectly
        specified or are mutually exclusive."
                           }
                       }
                   }
               ]
           }.

        :param batch_request: The list of reverse geocoding queries/requests to process. The list can
         contain  a max of 10,000 queries and must contain at least 1 query. Is either a BatchRequest
         type or a IO[bytes] type. Required.
        :type batch_request: ~azure.maps.search.models.BatchRequest or IO[bytes]
        :param format: Desired format of the response. Only ``json`` format is supported. "json"
         Default value is "json".
        :type format: str or ~azure.maps.search.models.JsonFormat
        :return: ReverseSearchAddressBatchResult
        :rtype: ~azure.maps.search.models.ReverseSearchAddressBatchResult
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
            408: lambda response: HttpResponseError(
                response=response, model=self._deserialize(_models.ErrorResponse, response)
            ),
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[_models.ReverseSearchAddressBatchResult] = kwargs.pop("cls", None)

        content_type = content_type or "application/json"
        _json = None
        _content = None
        if isinstance(batch_request, (IOBase, bytes)):
            _content = batch_request
        else:
            _json = self._serialize.body(batch_request, "BatchRequest")

        _request = build_search_reverse_search_address_batch_sync_request(
            format=format,
            client_id=self._config.client_id,
            content_type=content_type,
            api_version=self._config.api_version,
            json=_json,
            content=_content,
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = False
        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                response.read()  # Load the body in memory and close the socket
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize.failsafe_deserialize(_models.ErrorResponse, pipeline_response)
            raise HttpResponseError(response=response, model=error)

        deserialized = self._deserialize("ReverseSearchAddressBatchResult", pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore

    def _reverse_search_address_batch_initial(
        self,
        batch_request: Union[_models.BatchRequest, IO[bytes]],
        format: Union[str, _models.JsonFormat] = "json",
        **kwargs: Any
    ) -> Optional[_models.ReverseSearchAddressBatchResult]:
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[Optional[_models.ReverseSearchAddressBatchResult]] = kwargs.pop("cls", None)

        content_type = content_type or "application/json"
        _json = None
        _content = None
        if isinstance(batch_request, (IOBase, bytes)):
            _content = batch_request
        else:
            _json = self._serialize.body(batch_request, "BatchRequest")

        _request = build_search_reverse_search_address_batch_request(
            format=format,
            client_id=self._config.client_id,
            content_type=content_type,
            api_version=self._config.api_version,
            json=_json,
            content=_content,
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = False
        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200, 202]:
            if _stream:
                response.read()  # Load the body in memory and close the socket
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        deserialized = None
        response_headers = {}
        if response.status_code == 200:
            deserialized = self._deserialize("ReverseSearchAddressBatchResult", pipeline_response)

        if response.status_code == 202:
            response_headers["Location"] = self._deserialize("str", response.headers.get("Location"))

        if cls:
            return cls(pipeline_response, deserialized, response_headers)  # type: ignore

        return deserialized  # type: ignore

    @overload
    def begin_reverse_search_address_batch(
        self,
        batch_request: _models.BatchRequest,
        format: Union[str, _models.JsonFormat] = "json",
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> LROPoller[_models.ReverseSearchAddressBatchResult]:
        """**Search Address Reverse Batch API**

        **Applies to:** see `pricing tiers <https://aka.ms/AzureMapsPricingTier>`_.

        The Search Address Reverse Batch API sends batches of queries to `Search Address Reverse API
        </rest/api/maps/search/get-search-address-reverse?view=rest-maps-1.0>`_ using just a single API
        call. You can call Search Address Reverse Batch API to run either asynchronously (async) or
        synchronously (sync). The async API allows caller to batch up to **10,000** queries and sync
        API up to **100** queries.

        Submit Synchronous Batch Request
        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

        The Synchronous API is recommended for lightweight batch requests. When the service receives a
        request, it will respond as soon as the batch items are calculated and there will be no
        possibility to retrieve the results later. The Synchronous API will return a timeout error (a
        408 response) if the request takes longer than 60 seconds. The number of batch items is limited
        to **100** for this API.

        .. code-block::

           POST
        https://atlas.microsoft.com/search/address/reverse/batch/sync/json?api-version=1.0&subscription-key={subscription-key}

        Submit Asynchronous Batch Request
        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

        The Asynchronous API is appropriate for processing big volumes of relatively complex search
        requests


        * It allows the retrieval of results in a separate call (multiple downloads are possible).
        * The asynchronous API is optimized for reliability and is not expected to run into a timeout.
        * The number of batch items is limited to **10,000** for this API.

        When you make a request by using async request, by default the service returns a 202 response
        code along a redirect URL in the Location field of the response header. This URL should be
        checked periodically until the response data or error information is available.
        The asynchronous responses are stored for **14** days. The redirect URL returns a 404 response
        if used after the expiration period.

        Please note that asynchronous batch request is a long-running operation. Here's a typical
        sequence of operations:


        #. Client sends a Search Address Reverse Batch ``POST`` request to Azure Maps
        #.
           The server will respond with one of the following:

           ..

              HTTP ``202 Accepted`` - Batch request has been accepted.

              HTTP ``Error`` - There was an error processing your Batch request. This could either be a
        ``400 Bad Request`` or any other ``Error`` status code.


        #.
           If the batch request was accepted successfully, the ``Location`` header in the response
        contains the URL to download the results of the batch request.
            This status URI looks like following:

        .. code-block::

               GET
        https://atlas.microsoft.com/search/address/reverse/batch/{batch-id}?api-version=1.0&subscription-key={subscription-key}


        #. Client issues a ``GET`` request on the *download URL* obtained in Step 3 to download the
        batch results.

        POST Body for Batch Request
        ^^^^^^^^^^^^^^^^^^^^^^^^^^^

        To send the *search address reverse* queries you will use a ``POST`` request where the request
        body will contain the ``batchItems`` array in ``json`` format and the ``Content-Type`` header
        will be set to ``application/json``. Here's a sample request body containing 5 *search address
        reverse* queries:

        .. code-block:: json

           {
               "batchItems": [
                   {"query": "?query=48.858561,2.294911"},
                   {"query": "?query=47.639765,-122.127896&radius=5000&limit=2"},
                   {"query": "?query=47.621028,-122.348170"},
                   {"query": "?query=43.722990,10.396695"},
                   {"query": "?query=40.750958,-73.982336"}
               ]
           }

        A *search address reverse* query in a batch is just a partial URL *without* the protocol, base
        URL, path, api-version and subscription-key. It can accept any of the supported *search address
        reverse* `URI parameters
        </rest/api/maps/search/get-search-address-reverse?view=rest-maps-1.0#uri-parameters>`_. The
        string values in the *search address reverse* query must be properly escaped (e.g. " character
        should be escaped with ) and it should also be properly URL-encoded.

        The async API allows caller to batch up to **10,000** queries and sync API up to **100**
        queries, and the batch should contain at least **1** query.

        Download Asynchronous Batch Results
        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

        To download the async batch results you will issue a ``GET`` request to the batch download
        endpoint. This *download URL* can be obtained from the ``Location`` header of a successful
        ``POST`` batch request and looks like the following:

        .. code-block::

        https://atlas.microsoft.com/search/address/reverse/batch/{batch-id}?api-version=1.0&subscription-key={subscription-key}

        Here's the typical sequence of operations for downloading the batch results:


        #. Client sends a ``GET`` request using the *download URL*.
        #.
           The server will respond with one of the following:

           ..

              HTTP ``202 Accepted`` - Batch request was accepted but is still being processed. Please
        try again in some time.

              HTTP ``200 OK`` - Batch request successfully processed. The response body contains all
        the batch results.


        Batch Response Model
        ^^^^^^^^^^^^^^^^^^^^

        The returned data content is similar for async and sync requests. When downloading the results
        of an async batch request, if the batch has finished processing, the response body contains the
        batch response. This batch response contains a ``summary`` component that indicates the
        ``totalRequests`` that were part of the original batch request and ``successfulRequests``\ i.e.
        queries which were executed successfully. The batch response also includes a ``batchItems``
        array which contains a response for each and every query in the batch request. The
        ``batchItems`` will contain the results in the exact same order the original queries were sent
        in the batch request. Each item in ``batchItems`` contains ``statusCode`` and ``response``
        fields. Each ``response`` in ``batchItems`` is of one of the following types:


        *
          `\ ``SearchAddressReverseResponse``
        </rest/api/maps/search/get-search-address-reverse?view=rest-maps-1.0#searchaddressreverseresponse>`_
        - If the query completed successfully.

        *
          ``Error`` - If the query failed. The response will contain a ``code`` and a ``message`` in
        this case.

        Here's a sample Batch Response with 2 *successful* and 1 *failed* result:

        .. code-block:: json

           {
               "summary": {
                   "successfulRequests": 2,
                   "totalRequests": 3
               },
               "batchItems": [
                   {
                       "statusCode": 200,
                       "response":
                       {
                           "summary": {
                               "queryTime": 11
                           },
                           "addresses": [
                               {
                                   "address": {
                                       "country": "France",
                                       "freeformAddress": "Avenue Anatole France, 75007 Paris"
                                   },
                                   "position": "48.858490,2.294820"
                               }
                           ]
                       }
                   },
                   {
                       "statusCode": 200,
                       "response":
                       {
                           "summary": {
                               "queryTime": 1
                           },
                           "addresses": [
                               {
                                   "address": {
                                       "country": "United States of America",
                                       "freeformAddress": "157th Pl NE, Redmond WA 98052"
                                   },
                                   "position": "47.640470,-122.129430"
                               }
                           ]
                       }
                   },
                   {
                       "statusCode": 400,
                       "response":
                       {
                           "error":
                           {
                               "code": "400 BadRequest",
                               "message": "Bad request: one or more parameters were incorrectly
        specified or are mutually exclusive."
                           }
                       }
                   }
               ]
           }.

        :param batch_request: The list of reverse geocoding queries/requests to process. The list can
         contain  a max of 10,000 queries and must contain at least 1 query. Required.
        :type batch_request: ~azure.maps.search.models.BatchRequest
        :param format: Desired format of the response. Only ``json`` format is supported. "json"
         Default value is "json".
        :type format: str or ~azure.maps.search.models.JsonFormat
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: An instance of LROPoller that returns ReverseSearchAddressBatchResult
        :rtype:
         ~azure.core.polling.LROPoller[~azure.maps.search.models.ReverseSearchAddressBatchResult]
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @overload
    def begin_reverse_search_address_batch(
        self,
        batch_request: IO[bytes],
        format: Union[str, _models.JsonFormat] = "json",
        *,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> LROPoller[_models.ReverseSearchAddressBatchResult]:
        """**Search Address Reverse Batch API**

        **Applies to:** see `pricing tiers <https://aka.ms/AzureMapsPricingTier>`_.

        The Search Address Reverse Batch API sends batches of queries to `Search Address Reverse API
        </rest/api/maps/search/get-search-address-reverse?view=rest-maps-1.0>`_ using just a single API
        call. You can call Search Address Reverse Batch API to run either asynchronously (async) or
        synchronously (sync). The async API allows caller to batch up to **10,000** queries and sync
        API up to **100** queries.

        Submit Synchronous Batch Request
        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

        The Synchronous API is recommended for lightweight batch requests. When the service receives a
        request, it will respond as soon as the batch items are calculated and there will be no
        possibility to retrieve the results later. The Synchronous API will return a timeout error (a
        408 response) if the request takes longer than 60 seconds. The number of batch items is limited
        to **100** for this API.

        .. code-block::

           POST
        https://atlas.microsoft.com/search/address/reverse/batch/sync/json?api-version=1.0&subscription-key={subscription-key}

        Submit Asynchronous Batch Request
        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

        The Asynchronous API is appropriate for processing big volumes of relatively complex search
        requests


        * It allows the retrieval of results in a separate call (multiple downloads are possible).
        * The asynchronous API is optimized for reliability and is not expected to run into a timeout.
        * The number of batch items is limited to **10,000** for this API.

        When you make a request by using async request, by default the service returns a 202 response
        code along a redirect URL in the Location field of the response header. This URL should be
        checked periodically until the response data or error information is available.
        The asynchronous responses are stored for **14** days. The redirect URL returns a 404 response
        if used after the expiration period.

        Please note that asynchronous batch request is a long-running operation. Here's a typical
        sequence of operations:


        #. Client sends a Search Address Reverse Batch ``POST`` request to Azure Maps
        #.
           The server will respond with one of the following:

           ..

              HTTP ``202 Accepted`` - Batch request has been accepted.

              HTTP ``Error`` - There was an error processing your Batch request. This could either be a
        ``400 Bad Request`` or any other ``Error`` status code.


        #.
           If the batch request was accepted successfully, the ``Location`` header in the response
        contains the URL to download the results of the batch request.
            This status URI looks like following:

        .. code-block::

               GET
        https://atlas.microsoft.com/search/address/reverse/batch/{batch-id}?api-version=1.0&subscription-key={subscription-key}


        #. Client issues a ``GET`` request on the *download URL* obtained in Step 3 to download the
        batch results.

        POST Body for Batch Request
        ^^^^^^^^^^^^^^^^^^^^^^^^^^^

        To send the *search address reverse* queries you will use a ``POST`` request where the request
        body will contain the ``batchItems`` array in ``json`` format and the ``Content-Type`` header
        will be set to ``application/json``. Here's a sample request body containing 5 *search address
        reverse* queries:

        .. code-block:: json

           {
               "batchItems": [
                   {"query": "?query=48.858561,2.294911"},
                   {"query": "?query=47.639765,-122.127896&radius=5000&limit=2"},
                   {"query": "?query=47.621028,-122.348170"},
                   {"query": "?query=43.722990,10.396695"},
                   {"query": "?query=40.750958,-73.982336"}
               ]
           }

        A *search address reverse* query in a batch is just a partial URL *without* the protocol, base
        URL, path, api-version and subscription-key. It can accept any of the supported *search address
        reverse* `URI parameters
        </rest/api/maps/search/get-search-address-reverse?view=rest-maps-1.0#uri-parameters>`_. The
        string values in the *search address reverse* query must be properly escaped (e.g. " character
        should be escaped with ) and it should also be properly URL-encoded.

        The async API allows caller to batch up to **10,000** queries and sync API up to **100**
        queries, and the batch should contain at least **1** query.

        Download Asynchronous Batch Results
        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

        To download the async batch results you will issue a ``GET`` request to the batch download
        endpoint. This *download URL* can be obtained from the ``Location`` header of a successful
        ``POST`` batch request and looks like the following:

        .. code-block::

        https://atlas.microsoft.com/search/address/reverse/batch/{batch-id}?api-version=1.0&subscription-key={subscription-key}

        Here's the typical sequence of operations for downloading the batch results:


        #. Client sends a ``GET`` request using the *download URL*.
        #.
           The server will respond with one of the following:

           ..

              HTTP ``202 Accepted`` - Batch request was accepted but is still being processed. Please
        try again in some time.

              HTTP ``200 OK`` - Batch request successfully processed. The response body contains all
        the batch results.


        Batch Response Model
        ^^^^^^^^^^^^^^^^^^^^

        The returned data content is similar for async and sync requests. When downloading the results
        of an async batch request, if the batch has finished processing, the response body contains the
        batch response. This batch response contains a ``summary`` component that indicates the
        ``totalRequests`` that were part of the original batch request and ``successfulRequests``\ i.e.
        queries which were executed successfully. The batch response also includes a ``batchItems``
        array which contains a response for each and every query in the batch request. The
        ``batchItems`` will contain the results in the exact same order the original queries were sent
        in the batch request. Each item in ``batchItems`` contains ``statusCode`` and ``response``
        fields. Each ``response`` in ``batchItems`` is of one of the following types:


        *
          `\ ``SearchAddressReverseResponse``
        </rest/api/maps/search/get-search-address-reverse?view=rest-maps-1.0#searchaddressreverseresponse>`_
        - If the query completed successfully.

        *
          ``Error`` - If the query failed. The response will contain a ``code`` and a ``message`` in
        this case.

        Here's a sample Batch Response with 2 *successful* and 1 *failed* result:

        .. code-block:: json

           {
               "summary": {
                   "successfulRequests": 2,
                   "totalRequests": 3
               },
               "batchItems": [
                   {
                       "statusCode": 200,
                       "response":
                       {
                           "summary": {
                               "queryTime": 11
                           },
                           "addresses": [
                               {
                                   "address": {
                                       "country": "France",
                                       "freeformAddress": "Avenue Anatole France, 75007 Paris"
                                   },
                                   "position": "48.858490,2.294820"
                               }
                           ]
                       }
                   },
                   {
                       "statusCode": 200,
                       "response":
                       {
                           "summary": {
                               "queryTime": 1
                           },
                           "addresses": [
                               {
                                   "address": {
                                       "country": "United States of America",
                                       "freeformAddress": "157th Pl NE, Redmond WA 98052"
                                   },
                                   "position": "47.640470,-122.129430"
                               }
                           ]
                       }
                   },
                   {
                       "statusCode": 400,
                       "response":
                       {
                           "error":
                           {
                               "code": "400 BadRequest",
                               "message": "Bad request: one or more parameters were incorrectly
        specified or are mutually exclusive."
                           }
                       }
                   }
               ]
           }.

        :param batch_request: The list of reverse geocoding queries/requests to process. The list can
         contain  a max of 10,000 queries and must contain at least 1 query. Required.
        :type batch_request: IO[bytes]
        :param format: Desired format of the response. Only ``json`` format is supported. "json"
         Default value is "json".
        :type format: str or ~azure.maps.search.models.JsonFormat
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: An instance of LROPoller that returns ReverseSearchAddressBatchResult
        :rtype:
         ~azure.core.polling.LROPoller[~azure.maps.search.models.ReverseSearchAddressBatchResult]
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @distributed_trace
    def begin_reverse_search_address_batch(
        self,
        batch_request: Union[_models.BatchRequest, IO[bytes]],
        format: Union[str, _models.JsonFormat] = "json",
        **kwargs: Any
    ) -> LROPoller[_models.ReverseSearchAddressBatchResult]:
        """**Search Address Reverse Batch API**

        **Applies to:** see `pricing tiers <https://aka.ms/AzureMapsPricingTier>`_.

        The Search Address Reverse Batch API sends batches of queries to `Search Address Reverse API
        </rest/api/maps/search/get-search-address-reverse?view=rest-maps-1.0>`_ using just a single API
        call. You can call Search Address Reverse Batch API to run either asynchronously (async) or
        synchronously (sync). The async API allows caller to batch up to **10,000** queries and sync
        API up to **100** queries.

        Submit Synchronous Batch Request
        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

        The Synchronous API is recommended for lightweight batch requests. When the service receives a
        request, it will respond as soon as the batch items are calculated and there will be no
        possibility to retrieve the results later. The Synchronous API will return a timeout error (a
        408 response) if the request takes longer than 60 seconds. The number of batch items is limited
        to **100** for this API.

        .. code-block::

           POST
        https://atlas.microsoft.com/search/address/reverse/batch/sync/json?api-version=1.0&subscription-key={subscription-key}

        Submit Asynchronous Batch Request
        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

        The Asynchronous API is appropriate for processing big volumes of relatively complex search
        requests


        * It allows the retrieval of results in a separate call (multiple downloads are possible).
        * The asynchronous API is optimized for reliability and is not expected to run into a timeout.
        * The number of batch items is limited to **10,000** for this API.

        When you make a request by using async request, by default the service returns a 202 response
        code along a redirect URL in the Location field of the response header. This URL should be
        checked periodically until the response data or error information is available.
        The asynchronous responses are stored for **14** days. The redirect URL returns a 404 response
        if used after the expiration period.

        Please note that asynchronous batch request is a long-running operation. Here's a typical
        sequence of operations:


        #. Client sends a Search Address Reverse Batch ``POST`` request to Azure Maps
        #.
           The server will respond with one of the following:

           ..

              HTTP ``202 Accepted`` - Batch request has been accepted.

              HTTP ``Error`` - There was an error processing your Batch request. This could either be a
        ``400 Bad Request`` or any other ``Error`` status code.


        #.
           If the batch request was accepted successfully, the ``Location`` header in the response
        contains the URL to download the results of the batch request.
            This status URI looks like following:

        .. code-block::

               GET
        https://atlas.microsoft.com/search/address/reverse/batch/{batch-id}?api-version=1.0&subscription-key={subscription-key}


        #. Client issues a ``GET`` request on the *download URL* obtained in Step 3 to download the
        batch results.

        POST Body for Batch Request
        ^^^^^^^^^^^^^^^^^^^^^^^^^^^

        To send the *search address reverse* queries you will use a ``POST`` request where the request
        body will contain the ``batchItems`` array in ``json`` format and the ``Content-Type`` header
        will be set to ``application/json``. Here's a sample request body containing 5 *search address
        reverse* queries:

        .. code-block:: json

           {
               "batchItems": [
                   {"query": "?query=48.858561,2.294911"},
                   {"query": "?query=47.639765,-122.127896&radius=5000&limit=2"},
                   {"query": "?query=47.621028,-122.348170"},
                   {"query": "?query=43.722990,10.396695"},
                   {"query": "?query=40.750958,-73.982336"}
               ]
           }

        A *search address reverse* query in a batch is just a partial URL *without* the protocol, base
        URL, path, api-version and subscription-key. It can accept any of the supported *search address
        reverse* `URI parameters
        </rest/api/maps/search/get-search-address-reverse?view=rest-maps-1.0#uri-parameters>`_. The
        string values in the *search address reverse* query must be properly escaped (e.g. " character
        should be escaped with ) and it should also be properly URL-encoded.

        The async API allows caller to batch up to **10,000** queries and sync API up to **100**
        queries, and the batch should contain at least **1** query.

        Download Asynchronous Batch Results
        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

        To download the async batch results you will issue a ``GET`` request to the batch download
        endpoint. This *download URL* can be obtained from the ``Location`` header of a successful
        ``POST`` batch request and looks like the following:

        .. code-block::

        https://atlas.microsoft.com/search/address/reverse/batch/{batch-id}?api-version=1.0&subscription-key={subscription-key}

        Here's the typical sequence of operations for downloading the batch results:


        #. Client sends a ``GET`` request using the *download URL*.
        #.
           The server will respond with one of the following:

           ..

              HTTP ``202 Accepted`` - Batch request was accepted but is still being processed. Please
        try again in some time.

              HTTP ``200 OK`` - Batch request successfully processed. The response body contains all
        the batch results.


        Batch Response Model
        ^^^^^^^^^^^^^^^^^^^^

        The returned data content is similar for async and sync requests. When downloading the results
        of an async batch request, if the batch has finished processing, the response body contains the
        batch response. This batch response contains a ``summary`` component that indicates the
        ``totalRequests`` that were part of the original batch request and ``successfulRequests``\ i.e.
        queries which were executed successfully. The batch response also includes a ``batchItems``
        array which contains a response for each and every query in the batch request. The
        ``batchItems`` will contain the results in the exact same order the original queries were sent
        in the batch request. Each item in ``batchItems`` contains ``statusCode`` and ``response``
        fields. Each ``response`` in ``batchItems`` is of one of the following types:


        *
          `\ ``SearchAddressReverseResponse``
        </rest/api/maps/search/get-search-address-reverse?view=rest-maps-1.0#searchaddressreverseresponse>`_
        - If the query completed successfully.

        *
          ``Error`` - If the query failed. The response will contain a ``code`` and a ``message`` in
        this case.

        Here's a sample Batch Response with 2 *successful* and 1 *failed* result:

        .. code-block:: json

           {
               "summary": {
                   "successfulRequests": 2,
                   "totalRequests": 3
               },
               "batchItems": [
                   {
                       "statusCode": 200,
                       "response":
                       {
                           "summary": {
                               "queryTime": 11
                           },
                           "addresses": [
                               {
                                   "address": {
                                       "country": "France",
                                       "freeformAddress": "Avenue Anatole France, 75007 Paris"
                                   },
                                   "position": "48.858490,2.294820"
                               }
                           ]
                       }
                   },
                   {
                       "statusCode": 200,
                       "response":
                       {
                           "summary": {
                               "queryTime": 1
                           },
                           "addresses": [
                               {
                                   "address": {
                                       "country": "United States of America",
                                       "freeformAddress": "157th Pl NE, Redmond WA 98052"
                                   },
                                   "position": "47.640470,-122.129430"
                               }
                           ]
                       }
                   },
                   {
                       "statusCode": 400,
                       "response":
                       {
                           "error":
                           {
                               "code": "400 BadRequest",
                               "message": "Bad request: one or more parameters were incorrectly
        specified or are mutually exclusive."
                           }
                       }
                   }
               ]
           }.

        :param batch_request: The list of reverse geocoding queries/requests to process. The list can
         contain  a max of 10,000 queries and must contain at least 1 query. Is either a BatchRequest
         type or a IO[bytes] type. Required.
        :type batch_request: ~azure.maps.search.models.BatchRequest or IO[bytes]
        :param format: Desired format of the response. Only ``json`` format is supported. "json"
         Default value is "json".
        :type format: str or ~azure.maps.search.models.JsonFormat
        :return: An instance of LROPoller that returns ReverseSearchAddressBatchResult
        :rtype:
         ~azure.core.polling.LROPoller[~azure.maps.search.models.ReverseSearchAddressBatchResult]
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[_models.ReverseSearchAddressBatchResult] = kwargs.pop("cls", None)
        polling: Union[bool, PollingMethod] = kwargs.pop("polling", True)
        lro_delay = kwargs.pop("polling_interval", self._config.polling_interval)
        cont_token: Optional[str] = kwargs.pop("continuation_token", None)
        if cont_token is None:
            raw_result = self._reverse_search_address_batch_initial(
                batch_request=batch_request,
                format=format,
                content_type=content_type,
                cls=lambda x, y, z: x,
                headers=_headers,
                params=_params,
                **kwargs
            )
        kwargs.pop("error_map", None)

        def get_long_running_output(pipeline_response):
            deserialized = self._deserialize("ReverseSearchAddressBatchResult", pipeline_response)
            if cls:
                return cls(pipeline_response, deserialized, {})  # type: ignore
            return deserialized

        if polling is True:
            polling_method: PollingMethod = cast(
                PollingMethod, LROBasePolling(lro_delay, lro_options={"final-state-via": "location"}, **kwargs)
            )
        elif polling is False:
            polling_method = cast(PollingMethod, NoPolling())
        else:
            polling_method = polling
        if cont_token:
            return LROPoller[_models.ReverseSearchAddressBatchResult].from_continuation_token(
                polling_method=polling_method,
                continuation_token=cont_token,
                client=self._client,
                deserialization_callback=get_long_running_output,
            )
        return LROPoller[_models.ReverseSearchAddressBatchResult](
            self._client, raw_result, get_long_running_output, polling_method  # type: ignore
        )

    def _get_reverse_search_address_batch_initial(  # pylint: disable=name-too-long
        self, batch_id: str, **kwargs: Any
    ) -> Optional[_models.ReverseSearchAddressBatchResult]:
        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[Optional[_models.ReverseSearchAddressBatchResult]] = kwargs.pop("cls", None)

        _request = build_search_get_reverse_search_address_batch_request(
            batch_id=batch_id,
            client_id=self._config.client_id,
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = False
        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200, 202]:
            if _stream:
                response.read()  # Load the body in memory and close the socket
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        deserialized = None
        response_headers = {}
        if response.status_code == 200:
            deserialized = self._deserialize("ReverseSearchAddressBatchResult", pipeline_response)

        if response.status_code == 202:
            response_headers["Location"] = self._deserialize("str", response.headers.get("Location"))

        if cls:
            return cls(pipeline_response, deserialized, response_headers)  # type: ignore

        return deserialized  # type: ignore

    @distributed_trace
    def begin_get_reverse_search_address_batch(
        self, batch_id: str, **kwargs: Any
    ) -> LROPoller[_models.ReverseSearchAddressBatchResult]:
        """**Search Address Reverse Batch API**

        **Applies to:** see `pricing tiers <https://aka.ms/AzureMapsPricingTier>`_.

        The Search Address Reverse Batch API sends batches of queries to `Search Address Reverse API
        </rest/api/maps/search/get-search-address-reverse?view=rest-maps-1.0>`_ using just a single API
        call. You can call Search Address Reverse Batch API to run either asynchronously (async) or
        synchronously (sync). The async API allows caller to batch up to **10,000** queries and sync
        API up to **100** queries.

        Submit Synchronous Batch Request
        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

        The Synchronous API is recommended for lightweight batch requests. When the service receives a
        request, it will respond as soon as the batch items are calculated and there will be no
        possibility to retrieve the results later. The Synchronous API will return a timeout error (a
        408 response) if the request takes longer than 60 seconds. The number of batch items is limited
        to **100** for this API.

        .. code-block::

           POST
        https://atlas.microsoft.com/search/address/reverse/batch/sync/json?api-version=1.0&subscription-key={subscription-key}

        Submit Asynchronous Batch Request
        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

        The Asynchronous API is appropriate for processing big volumes of relatively complex search
        requests


        * It allows the retrieval of results in a separate call (multiple downloads are possible).
        * The asynchronous API is optimized for reliability and is not expected to run into a timeout.
        * The number of batch items is limited to **10,000** for this API.

        When you make a request by using async request, by default the service returns a 202 response
        code along a redirect URL in the Location field of the response header. This URL should be
        checked periodically until the response data or error information is available.
        The asynchronous responses are stored for **14** days. The redirect URL returns a 404 response
        if used after the expiration period.

        Please note that asynchronous batch request is a long-running operation. Here's a typical
        sequence of operations:


        #. Client sends a Search Address Reverse Batch ``POST`` request to Azure Maps
        #.
           The server will respond with one of the following:

           ..

              HTTP ``202 Accepted`` - Batch request has been accepted.

              HTTP ``Error`` - There was an error processing your Batch request. This could either be a
        ``400 Bad Request`` or any other ``Error`` status code.


        #.
           If the batch request was accepted successfully, the ``Location`` header in the response
        contains the URL to download the results of the batch request.
            This status URI looks like following:

        .. code-block::

               GET
        https://atlas.microsoft.com/search/address/reverse/batch/{batch-id}?api-version=1.0&subscription-key={subscription-key}


        #. Client issues a ``GET`` request on the *download URL* obtained in Step 3 to download the
        batch results.

        POST Body for Batch Request
        ^^^^^^^^^^^^^^^^^^^^^^^^^^^

        To send the *search address reverse* queries you will use a ``POST`` request where the request
        body will contain the ``batchItems`` array in ``json`` format and the ``Content-Type`` header
        will be set to ``application/json``. Here's a sample request body containing 5 *search address
        reverse* queries:

        .. code-block:: json

           {
               "batchItems": [
                   {"query": "?query=48.858561,2.294911"},
                   {"query": "?query=47.639765,-122.127896&radius=5000&limit=2"},
                   {"query": "?query=47.621028,-122.348170"},
                   {"query": "?query=43.722990,10.396695"},
                   {"query": "?query=40.750958,-73.982336"}
               ]
           }

        A *search address reverse* query in a batch is just a partial URL *without* the protocol, base
        URL, path, api-version and subscription-key. It can accept any of the supported *search address
        reverse* `URI parameters
        </rest/api/maps/search/get-search-address-reverse?view=rest-maps-1.0#uri-parameters>`_. The
        string values in the *search address reverse* query must be properly escaped (e.g. " character
        should be escaped with ) and it should also be properly URL-encoded.

        The async API allows caller to batch up to **10,000** queries and sync API up to **100**
        queries, and the batch should contain at least **1** query.

        Download Asynchronous Batch Results
        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

        To download the async batch results you will issue a ``GET`` request to the batch download
        endpoint. This *download URL* can be obtained from the ``Location`` header of a successful
        ``POST`` batch request and looks like the following:

        .. code-block::

        https://atlas.microsoft.com/search/address/reverse/batch/{batch-id}?api-version=1.0&subscription-key={subscription-key}

        Here's the typical sequence of operations for downloading the batch results:


        #. Client sends a ``GET`` request using the *download URL*.
        #.
           The server will respond with one of the following:

           ..

              HTTP ``202 Accepted`` - Batch request was accepted but is still being processed. Please
        try again in some time.

              HTTP ``200 OK`` - Batch request successfully processed. The response body contains all
        the batch results.


        Batch Response Model
        ^^^^^^^^^^^^^^^^^^^^

        The returned data content is similar for async and sync requests. When downloading the results
        of an async batch request, if the batch has finished processing, the response body contains the
        batch response. This batch response contains a ``summary`` component that indicates the
        ``totalRequests`` that were part of the original batch request and ``successfulRequests``\ i.e.
        queries which were executed successfully. The batch response also includes a ``batchItems``
        array which contains a response for each and every query in the batch request. The
        ``batchItems`` will contain the results in the exact same order the original queries were sent
        in the batch request. Each item in ``batchItems`` contains ``statusCode`` and ``response``
        fields. Each ``response`` in ``batchItems`` is of one of the following types:


        *
          `\ ``SearchAddressReverseResponse``
        </rest/api/maps/search/get-search-address-reverse?view=rest-maps-1.0#searchaddressreverseresponse>`_
        - If the query completed successfully.

        *
          ``Error`` - If the query failed. The response will contain a ``code`` and a ``message`` in
        this case.

        Here's a sample Batch Response with 2 *successful* and 1 *failed* result:

        .. code-block:: json

           {
               "summary": {
                   "successfulRequests": 2,
                   "totalRequests": 3
               },
               "batchItems": [
                   {
                       "statusCode": 200,
                       "response":
                       {
                           "summary": {
                               "queryTime": 11
                           },
                           "addresses": [
                               {
                                   "address": {
                                       "country": "France",
                                       "freeformAddress": "Avenue Anatole France, 75007 Paris"
                                   },
                                   "position": "48.858490,2.294820"
                               }
                           ]
                       }
                   },
                   {
                       "statusCode": 200,
                       "response":
                       {
                           "summary": {
                               "queryTime": 1
                           },
                           "addresses": [
                               {
                                   "address": {
                                       "country": "United States of America",
                                       "freeformAddress": "157th Pl NE, Redmond WA 98052"
                                   },
                                   "position": "47.640470,-122.129430"
                               }
                           ]
                       }
                   },
                   {
                       "statusCode": 400,
                       "response":
                       {
                           "error":
                           {
                               "code": "400 BadRequest",
                               "message": "Bad request: one or more parameters were incorrectly
        specified or are mutually exclusive."
                           }
                       }
                   }
               ]
           }.

        :param batch_id: Batch id for querying the operation. Required.
        :type batch_id: str
        :return: An instance of LROPoller that returns ReverseSearchAddressBatchResult
        :rtype:
         ~azure.core.polling.LROPoller[~azure.maps.search.models.ReverseSearchAddressBatchResult]
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[_models.ReverseSearchAddressBatchResult] = kwargs.pop("cls", None)
        polling: Union[bool, PollingMethod] = kwargs.pop("polling", True)
        lro_delay = kwargs.pop("polling_interval", self._config.polling_interval)
        cont_token: Optional[str] = kwargs.pop("continuation_token", None)
        if cont_token is None:
            raw_result = self._get_reverse_search_address_batch_initial(
                batch_id=batch_id, cls=lambda x, y, z: x, headers=_headers, params=_params, **kwargs
            )
        kwargs.pop("error_map", None)

        def get_long_running_output(pipeline_response):
            deserialized = self._deserialize("ReverseSearchAddressBatchResult", pipeline_response)
            if cls:
                return cls(pipeline_response, deserialized, {})  # type: ignore
            return deserialized

        if polling is True:
            polling_method: PollingMethod = cast(
                PollingMethod, LROBasePolling(lro_delay, lro_options={"final-state-via": "original-uri"}, **kwargs)
            )
        elif polling is False:
            polling_method = cast(PollingMethod, NoPolling())
        else:
            polling_method = polling
        if cont_token:
            return LROPoller[_models.ReverseSearchAddressBatchResult].from_continuation_token(
                polling_method=polling_method,
                continuation_token=cont_token,
                client=self._client,
                deserialization_callback=get_long_running_output,
            )
        return LROPoller[_models.ReverseSearchAddressBatchResult](
            self._client, raw_result, get_long_running_output, polling_method  # type: ignore
        )
