# coding=utf-8
# --------------------------------------------------------------------------
# Copyright (c) Microsoft Corporation. All rights reserved.
# Licensed under the MIT License. See License.txt in the project root for license information.
# Code generated by Microsoft (R) AutoRest Code Generator.
# Changes may cause incorrect behavior and will be lost if the code is regenerated.
# --------------------------------------------------------------------------
from typing import TYPE_CHECKING
import warnings

from azure.core.exceptions import ClientAuthenticationError, HttpResponseError, ResourceExistsError, ResourceNotFoundError, map_error
from azure.core.pipeline import PipelineResponse
from azure.core.pipeline.transport import HttpRequest, HttpResponse

from .. import models

if TYPE_CHECKING:
    # pylint: disable=unused-import,ungrouped-imports
    from typing import Any, Callable, Dict, Generic, IO, List, Optional, TypeVar, Union

    T = TypeVar('T')
    ClsType = Optional[Callable[[PipelineResponse[HttpRequest, HttpResponse], T, Dict[str, Any]], Any]]

class TrafficOperations(object):
    """TrafficOperations operations.

    You should not instantiate this class directly. Instead, you should create a Client instance that
    instantiates it for you and attaches it as an attribute.

    :ivar models: Alias to model classes used in this operation group.
    :type models: ~azure.maps.traffic.models
    :param client: Client for service requests.
    :param config: Configuration of service client.
    :param serializer: An object model serializer.
    :param deserializer: An object model deserializer.
    """

    models = models

    def __init__(self, client, config, serializer, deserializer):
        self._client = client
        self._serialize = serializer
        self._deserialize = deserializer
        self._config = config

    def get_traffic_flow_tile(
        self,
        format,  # type: Union[str, "models.TileFormat"]
        style,  # type: Union[str, "models.TrafficFlowTileStyle"]
        zoom,  # type: int
        tile_index,  # type: "models.TileIndex"
        thickness=None,  # type: Optional[int]
        **kwargs  # type: Any
    ):
        # type: (...) -> IO
        """**Traffic Flow Tile**

        **Applies to**\ : S0 and S1 pricing tiers.

        The Azure Flow Tile API serves 256 x 256 pixel tiles showing traffic flow. All tiles use the
        same grid system. Because the traffic tiles use transparent images, they can be layered on top
        of map tiles to create a compound  display. The Flow tiles use colors to indicate either the
        speed of traffic on different road segments, or the difference between that speed and the free-
        flow speed on the road segment in question.

        :param format: Desired format of the response. Possible values are png & pbf.
        :type format: str or ~azure.maps.traffic.models.TileFormat
        :param style: .. raw:: html

            <p>The style to be used to render the tile.</p>.
        :type style: str or ~azure.maps.traffic.models.TrafficFlowTileStyle
        :param zoom: Zoom level for the desired tile. For *raster* tiles, value must be in the range:
         0-22 (inclusive). For *vector* tiles, value must be in the range: 0-22 (inclusive).
         Please see `Zoom Levels and Tile Grid <https://docs.microsoft.com/en-us/azure/location-based-
         services/zoom-levels-and-tile-grid>`_ for details.
        :type zoom: int
        :param tile_index: Parameter group.
        :type tile_index: ~azure.maps.traffic.models.TileIndex
        :param thickness: The value of the width of the line representing traffic. This value is a
         multiplier and the accepted values range from 1 - 20. The default value is 10. This parameter
         is not valid when format is pbf.
        :type thickness: int
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: IO, or the result of cls(response)
        :rtype: IO
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType[IO]
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}))
        
        _x = None
        _y = None
        if tile_index is not None:
            _x = tile_index.x
            _y = tile_index.y
        api_version = "1.0"
        accept = "image/jpeg, image/png, image/pbf, application/vnd.mapbox-vector-tile, application/json"

        # Construct URL
        url = self.get_traffic_flow_tile.metadata['url']  # type: ignore
        path_format_arguments = {
            'format': self._serialize.url("format", format, 'str'),
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]
        query_parameters['api-version'] = self._serialize.query("api_version", api_version, 'str')
        query_parameters['style'] = self._serialize.query("style", style, 'str')
        query_parameters['zoom'] = self._serialize.query("zoom", zoom, 'int')
        query_parameters['x'] = self._serialize.query("x", _x, 'int')
        query_parameters['y'] = self._serialize.query("y", _y, 'int')
        if thickness is not None:
            query_parameters['thickness'] = self._serialize.query("thickness", thickness, 'int', maximum=20, minimum=1)

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]
        if self._config.client_id is not None:
            header_parameters['x-ms-client-id'] = self._serialize.header("self._config.client_id", self._config.client_id, 'str')
        header_parameters['Accept'] = self._serialize.header("accept", accept, 'str')

        request = self._client.get(url, query_parameters, header_parameters)
        pipeline_response = self._client._pipeline.run(request, stream=True, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize(models.ErrorResponse, response)
            raise HttpResponseError(response=response, model=error)

        response_headers = {}
        response_headers['Content-Type']=self._deserialize('str', response.headers.get('Content-Type'))
        deserialized = response.stream_download(self._client._pipeline)

        if cls:
            return cls(pipeline_response, deserialized, response_headers)

        return deserialized
    get_traffic_flow_tile.metadata = {'url': '/traffic/flow/tile/{format}'}  # type: ignore

    def get_traffic_flow_segment(
        self,
        style,  # type: Union[str, "models.TrafficFlowSegmentStyle"]
        zoom,  # type: int
        coordinates,  # type: List[float]
        format="json",  # type: Union[str, "models.ResponseFormat"]
        unit=None,  # type: Optional[Union[str, "models.SpeedUnit"]]
        thickness=None,  # type: Optional[int]
        open_lr=None,  # type: Optional[bool]
        **kwargs  # type: Any
    ):
        # type: (...) -> "models.TrafficFlowSegmentData"
        """**Traffic Flow Segment**

        **Applies to**\ : S0 and S1 pricing tiers.

        This service provides information about the speeds and travel times of the road fragment
        closest to the given coordinates. It is designed to work alongside the Flow layer of the Render
        Service to support clickable  flow data visualizations. With this API, the client side can
        connect any place in the map with flow data on the  closest road and present it to the user.

        :param style: The style to be used to render the tile. Valid values are absolute which returns
         colors reflecting the absolute speed measured, relative which returns the speed relative to
         free-flow, Relative-delay which displays relative speeds only where they are different from the
         freeflow speeds.
        :type style: str or ~azure.maps.traffic.models.TrafficFlowSegmentStyle
        :param zoom: Zoom level for the desired tile. Zoom value must be in the range: 0-22
         (inclusive).
         Please see `Zoom Levels and Tile Grid <https://docs.microsoft.com/en-us/azure/location-based-
         services/zoom-levels-and-tile-grid>`_ for details.
        :type zoom: int
        :param coordinates: Coordinates of the point close to the road segment. This parameter is a
         list of four coordinates, containing two coordinate pairs (lat, long, lat, long), and
         calculated using EPSG4326 projection. When this endpoint is called directly, coordinates are
         passed in as a single string containing four coordinates, separated by commas.
        :type coordinates: list[float]
        :param format: Desired format of the response. Value can be either *json* or *xml*.
        :type format: str or ~azure.maps.traffic.models.ResponseFormat
        :param unit: Unit of speed in KMPH or MPH.
        :type unit: str or ~azure.maps.traffic.models.SpeedUnit
        :param thickness: The value of the width of the line representing traffic. This value is a
         multiplier and the accepted values range from 1 - 20. The default value is 10.
        :type thickness: int
        :param open_lr: Boolean on whether the response should include OpenLR code.
        :type open_lr: bool
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: TrafficFlowSegmentData, or the result of cls(response)
        :rtype: ~azure.maps.traffic.models.TrafficFlowSegmentData
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType["models.TrafficFlowSegmentData"]
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}))
        api_version = "1.0"
        accept = "application/json"

        # Construct URL
        url = self.get_traffic_flow_segment.metadata['url']  # type: ignore
        path_format_arguments = {
            'format': self._serialize.url("format", format, 'str'),
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]
        query_parameters['api-version'] = self._serialize.query("api_version", api_version, 'str')
        query_parameters['style'] = self._serialize.query("style", style, 'str')
        query_parameters['zoom'] = self._serialize.query("zoom", zoom, 'int')
        query_parameters['query'] = self._serialize.query("coordinates", coordinates, '[float]', div=',')
        if unit is not None:
            query_parameters['unit'] = self._serialize.query("unit", unit, 'str')
        if thickness is not None:
            query_parameters['thickness'] = self._serialize.query("thickness", thickness, 'int', maximum=20, minimum=1)
        if open_lr is not None:
            query_parameters['openLr'] = self._serialize.query("open_lr", open_lr, 'bool')

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]
        if self._config.client_id is not None:
            header_parameters['x-ms-client-id'] = self._serialize.header("self._config.client_id", self._config.client_id, 'str')
        header_parameters['Accept'] = self._serialize.header("accept", accept, 'str')

        request = self._client.get(url, query_parameters, header_parameters)
        pipeline_response = self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize(models.ErrorResponse, response)
            raise HttpResponseError(response=response, model=error)

        deserialized = self._deserialize('TrafficFlowSegmentData', pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized
    get_traffic_flow_segment.metadata = {'url': '/traffic/flow/segment/{format}'}  # type: ignore

    def get_traffic_incident_tile(
        self,
        format,  # type: Union[str, "models.TileFormat"]
        style,  # type: Union[str, "models.TrafficIncidentTileStyle"]
        zoom,  # type: int
        tile_index,  # type: "models.TileIndex"
        traffic_state=None,  # type: Optional[str]
        **kwargs  # type: Any
    ):
        # type: (...) -> IO
        """**Traffic Incident Tile**

        **Applies to**\ : S0 and S1 pricing tiers.

        This service serves 256 x 256 pixel tiles showing traffic incidents. All tiles use the same
        grid system. Because the traffic tiles use transparent images, they can be layered on top of
        map tiles to create a compound display. Traffic tiles render graphics to indicate traffic on
        the roads in the specified area.

        :param format: Desired format of the response. Possible values are png & pbf.
        :type format: str or ~azure.maps.traffic.models.TileFormat
        :param style: The style to be used to render the tile. This parameter is not valid when format
         is pbf.
        :type style: str or ~azure.maps.traffic.models.TrafficIncidentTileStyle
        :param zoom: Zoom level for the desired tile. For *raster* tiles, value must be in the range:
         0-22 (inclusive). For *vector* tiles, value must be in the range: 0-22 (inclusive).
         Please see `Zoom Levels and Tile Grid <https://docs.microsoft.com/en-us/azure/location-based-
         services/zoom-levels-and-tile-grid>`_ for details.
        :type zoom: int
        :param tile_index: Parameter group.
        :type tile_index: ~azure.maps.traffic.models.TileIndex
        :param traffic_state: Reference value for the state of traffic at a particular time, obtained
         from the Viewport API call, trafficModelId attribute in trafficState field. It is updated every
         minute, and is valid for two minutes before it times out. Use -1 to  get the most recent
         traffic information. Default: most recent traffic information.
        :type traffic_state: str
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: IO, or the result of cls(response)
        :rtype: IO
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType[IO]
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}))
        
        _x = None
        _y = None
        if tile_index is not None:
            _x = tile_index.x
            _y = tile_index.y
        api_version = "1.0"
        accept = "image/jpeg, image/png, image/pbf, application/vnd.mapbox-vector-tile, application/json"

        # Construct URL
        url = self.get_traffic_incident_tile.metadata['url']  # type: ignore
        path_format_arguments = {
            'format': self._serialize.url("format", format, 'str'),
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]
        query_parameters['api-version'] = self._serialize.query("api_version", api_version, 'str')
        query_parameters['style'] = self._serialize.query("style", style, 'str')
        query_parameters['zoom'] = self._serialize.query("zoom", zoom, 'int')
        query_parameters['x'] = self._serialize.query("x", _x, 'int')
        query_parameters['y'] = self._serialize.query("y", _y, 'int')
        if traffic_state is not None:
            query_parameters['t'] = self._serialize.query("traffic_state", traffic_state, 'str')

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]
        if self._config.client_id is not None:
            header_parameters['x-ms-client-id'] = self._serialize.header("self._config.client_id", self._config.client_id, 'str')
        header_parameters['Accept'] = self._serialize.header("accept", accept, 'str')

        request = self._client.get(url, query_parameters, header_parameters)
        pipeline_response = self._client._pipeline.run(request, stream=True, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize(models.ErrorResponse, response)
            raise HttpResponseError(response=response, model=error)

        response_headers = {}
        response_headers['Content-Type']=self._deserialize('str', response.headers.get('Content-Type'))
        deserialized = response.stream_download(self._client._pipeline)

        if cls:
            return cls(pipeline_response, deserialized, response_headers)

        return deserialized
    get_traffic_incident_tile.metadata = {'url': '/traffic/incident/tile/{format}'}  # type: ignore

    def get_traffic_incident_detail(
        self,
        style,  # type: Union[str, "models.IncidentDetailStyle"]
        boundingbox,  # type: List[float]
        bounding_zoom,  # type: int
        trafficmodelid,  # type: str
        format="json",  # type: Union[str, "models.ResponseFormat"]
        language=None,  # type: Optional[str]
        projection=None,  # type: Optional[Union[str, "models.ProjectionStandard"]]
        geometries=None,  # type: Optional[Union[str, "models.IncidentGeometryType"]]
        expand_cluster=None,  # type: Optional[bool]
        original_position=None,  # type: Optional[bool]
        **kwargs  # type: Any
    ):
        # type: (...) -> "models.TrafficIncidentDetail"
        """**Traffic Incident Detail**

        **Applies to**\ : S0 and S1 pricing tiers.

        This API provides information on traffic incidents inside a given bounding box, based on the
        current Traffic  Model ID. The Traffic Model ID is available to grant synchronization of data
        between calls and API's. The  Traffic Model ID is a key value for determining the currency of
        traffic incidents. It is updated every minute,  and is valid for two minutes before it times
        out. It is used in rendering  `incident tiles <https://docs.microsoft.com/en-
        us/rest/api/maps/traffic/gettrafficincidenttile>`_. It can be  obtained from the `Viewport API
        <https://docs.microsoft.com/en-us/rest/api/maps/traffic/gettrafficincidentviewport>`_.

        :param style: The style that will be used to render the tile in Traffic `Incident Tile API
         <https://docs.microsoft.com/en-us/rest/api/maps/traffic/gettrafficincidenttile>`_.  This will
         have an effect on the coordinates of traffic incidents in the reply.
        :type style: str or ~azure.maps.traffic.models.IncidentDetailStyle
        :param boundingbox: The ``boundingbox`` is represented by two value pairs describing it's
         corners (first pair for lower left corner and second for upper right). The pairs can either be
         specified using any of the ``projection``\ 's specified below (e.g., *minY,minX,maxY,maxX*\ )
         or by two latitude-longitude pairs (e.g., *minLat,minLon,maxLat,maxLon*\
         ).:code:`<br>`:code:`<br>`NOTE: If latitude/longitude pairs are used, then the ``projection``
         parameter must be set to "EPSG4326".
        :type boundingbox: list[float]
        :param bounding_zoom: Zoom level for desired tile. 0 to 22 for raster tiles, 0 through 22 for
         vector tiles.
        :type bounding_zoom: int
        :param trafficmodelid: Number referencing traffic model. This can be obtained from the
         `Viewport API <https://docs.microsoft.com/en-
         us/rest/api/maps/traffic/gettrafficincidentviewport>`_. It is updated every minute, and is
         valid for two minutes before it times out. If the wrong Traffic Model ID is specified, the
         correct one will be returned by the interface. A value of -1 will always invoke the most recent
         traffic model.
        :type trafficmodelid: str
        :param format: Desired format of the response. Value can be either *json* or *xml*.
        :type format: str or ~azure.maps.traffic.models.ResponseFormat
        :param language: `ISO 639-1 code <https://en.wikipedia.org/wiki/List_of_ISO_639-1_codes>`_ for
         the output language. Supported languages are ar, ca, cs, da, de, el, en, en-GB, en-US, es, et,
         fi, fr, he, hu, id, in*, it, lt, lv, nb, nl, no, pl, pt, ro, ru, sk, sv, th, tr, zh.

         Please refer to `Supported Languages <https://docs.microsoft.com/en-us/azure/azure-
         maps/supported-languages>`_ for details. When invalid language code is provided response is
         returned in English. When incident cause or description does not have translation, English
         description is returned.
        :type language: str
        :param projection: The projection used to specify the coordinates in the request and response.
         `EPSG900913 <http://docs.openlayers.org/library/spherical_mercator.html>`_ (default) or
         `EPSG4326 <http://spatialreference.org/ref/epsg/4326/>`_.
        :type projection: str or ~azure.maps.traffic.models.ProjectionStandard
        :param geometries: The type of vector geometry added to incidents (returned in the :code:`<v>`
         element of the response).
        :type geometries: str or ~azure.maps.traffic.models.IncidentGeometryType
        :param expand_cluster: Boolean to indicate whether to list all traffic incidents in a cluster
         separately.
        :type expand_cluster: bool
        :param original_position: Boolean on whether to return the original position of the incident
         (:code:`<op>`) as well as the one shifted to the beginning of the traffic tube (:code:`<op>`).
        :type original_position: bool
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: TrafficIncidentDetail, or the result of cls(response)
        :rtype: ~azure.maps.traffic.models.TrafficIncidentDetail
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType["models.TrafficIncidentDetail"]
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}))
        api_version = "1.0"
        accept = "application/json"

        # Construct URL
        url = self.get_traffic_incident_detail.metadata['url']  # type: ignore
        path_format_arguments = {
            'format': self._serialize.url("format", format, 'str'),
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]
        query_parameters['api-version'] = self._serialize.query("api_version", api_version, 'str')
        query_parameters['style'] = self._serialize.query("style", style, 'str')
        query_parameters['boundingbox'] = self._serialize.query("boundingbox", boundingbox, '[float]', div=',')
        query_parameters['boundingZoom'] = self._serialize.query("bounding_zoom", bounding_zoom, 'int', maximum=22, minimum=0)
        query_parameters['trafficmodelid'] = self._serialize.query("trafficmodelid", trafficmodelid, 'str')
        if language is not None:
            query_parameters['language'] = self._serialize.query("language", language, 'str')
        if projection is not None:
            query_parameters['projection'] = self._serialize.query("projection", projection, 'str')
        if geometries is not None:
            query_parameters['geometries'] = self._serialize.query("geometries", geometries, 'str')
        if expand_cluster is not None:
            query_parameters['expandCluster'] = self._serialize.query("expand_cluster", expand_cluster, 'bool')
        if original_position is not None:
            query_parameters['originalPosition'] = self._serialize.query("original_position", original_position, 'bool')

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]
        if self._config.client_id is not None:
            header_parameters['x-ms-client-id'] = self._serialize.header("self._config.client_id", self._config.client_id, 'str')
        header_parameters['Accept'] = self._serialize.header("accept", accept, 'str')

        request = self._client.get(url, query_parameters, header_parameters)
        pipeline_response = self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize(models.ErrorResponse, response)
            raise HttpResponseError(response=response, model=error)

        deserialized = self._deserialize('TrafficIncidentDetail', pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized
    get_traffic_incident_detail.metadata = {'url': '/traffic/incident/detail/{format}'}  # type: ignore

    def get_traffic_incident_viewport(
        self,
        boundingbox,  # type: List[float]
        boundingzoom,  # type: int
        overviewbox,  # type: List[float]
        overviewzoom,  # type: int
        format="json",  # type: Union[str, "models.ResponseFormat"]
        copyright=True,  # type: Optional[bool]
        **kwargs  # type: Any
    ):
        # type: (...) -> "models.TrafficIncidentViewport"
        """**Traffic Incident Viewport**

        **Applies to**\ : S0 and S1 pricing tiers.

        This API returns legal and technical information for the viewport described in the request. It
        should be called  by client applications whenever the viewport changes (for instance, through
        zooming, panning, going to a  location, or displaying a route). The request should contain the
        bounding box and zoom level of the viewport  whose information is needed. The return will
        contain map version information, as well as the current Traffic  Model ID and copyright IDs.
        The Traffic Model ID returned by the Viewport Description is used by other APIs to  retrieve
        last traffic information for further processing.

        :param boundingbox: Bounding box of the map viewport in `EPSG900913
         <http://docs.openlayers.org/library/spherical_mercator.html>`_ projection. The ``boundingbox``
         is represented by two value pairs describing it's corners (first pair for lower left corner and
         second for upper right). When this endpoint is called directly, all values should be separated
         by commas (e.g., *minY,minX,maxY,maxX*\ ). The maximum size of the bounding box that can be
         passed is dependent on the requested zoom level. The width and height cannot exceed 4092 pixels
         when rendered on the given zoom level.:code:`<br>`:code:`<br>`NOTE: Bounding boxes that cross
         the 180° meridian require special treatment. For such boxes, the eastern *maxX* value will be
         negative, and thus less than the *minX* value west of the 180° meridian. To address that, the
         value 40075016.6855874 should be added to the true *maxX* value before it is passed in the
         request.
        :type boundingbox: list[float]
        :param boundingzoom: Zoom level of the map viewport. Used to determine whether the view can be
         zoomed in.
        :type boundingzoom: int
        :param overviewbox: Bounding box of the overview map in `EPSG900913
         <http://docs.openlayers.org/library/spherical_mercator.html>`_
         projection.:code:`<br>`:code:`<br>`Used in case the overview box/mini map has different
         copyright data than the main map. If there is no mini map, the same coordinates as
         ``boundingBox`` is used. When this endpoint is called directly, coordinates are passed in as a
         single string containing four coordinates, separated by commas.
        :type overviewbox: list[float]
        :param overviewzoom: Zoom level of the overview map. If there is no mini map, use the same zoom
         level as boundingZoom.
        :type overviewzoom: int
        :param format: Desired format of the response. Value can be either *json* or *xml*.
        :type format: str or ~azure.maps.traffic.models.ResponseFormat
        :param copyright: Determines what copyright information to return. When true the copyright text
         is returned; when false only the copyright index is returned.
        :type copyright: bool
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: TrafficIncidentViewport, or the result of cls(response)
        :rtype: ~azure.maps.traffic.models.TrafficIncidentViewport
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType["models.TrafficIncidentViewport"]
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}))
        api_version = "1.0"
        accept = "application/json"

        # Construct URL
        url = self.get_traffic_incident_viewport.metadata['url']  # type: ignore
        path_format_arguments = {
            'format': self._serialize.url("format", format, 'str'),
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]
        query_parameters['api-version'] = self._serialize.query("api_version", api_version, 'str')
        query_parameters['boundingbox'] = self._serialize.query("boundingbox", boundingbox, '[float]', div=',')
        query_parameters['boundingzoom'] = self._serialize.query("boundingzoom", boundingzoom, 'int', maximum=22, minimum=0)
        query_parameters['overviewbox'] = self._serialize.query("overviewbox", overviewbox, '[float]', div=',')
        query_parameters['overviewzoom'] = self._serialize.query("overviewzoom", overviewzoom, 'int', maximum=22, minimum=0)
        if copyright is not None:
            query_parameters['copyright'] = self._serialize.query("copyright", copyright, 'bool')

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]
        if self._config.client_id is not None:
            header_parameters['x-ms-client-id'] = self._serialize.header("self._config.client_id", self._config.client_id, 'str')
        header_parameters['Accept'] = self._serialize.header("accept", accept, 'str')

        request = self._client.get(url, query_parameters, header_parameters)
        pipeline_response = self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize(models.ErrorResponse, response)
            raise HttpResponseError(response=response, model=error)

        deserialized = self._deserialize('TrafficIncidentViewport', pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized
    get_traffic_incident_viewport.metadata = {'url': '/traffic/incident/viewport/{format}'}  # type: ignore
