# coding=utf-8
# --------------------------------------------------------------------------
# Copyright (c) Microsoft Corporation. All rights reserved.
# Licensed under the MIT License. See License.txt in the project root for license information.
# Code generated by Microsoft (R) AutoRest Code Generator.
# Changes may cause incorrect behavior and will be lost if the code is regenerated.
# --------------------------------------------------------------------------
from typing import TYPE_CHECKING
import warnings

from azure.core.exceptions import ClientAuthenticationError, HttpResponseError, ResourceExistsError, ResourceNotFoundError, map_error
from azure.core.pipeline import PipelineResponse
from azure.core.pipeline.transport import HttpRequest, HttpResponse

from .. import models as _models

if TYPE_CHECKING:
    # pylint: disable=unused-import,ungrouped-imports
    from typing import Any, Callable, Dict, Generic, IO, Optional, TypeVar, Union

    T = TypeVar('T')
    ClsType = Optional[Callable[[PipelineResponse[HttpRequest, HttpResponse], T, Dict[str, Any]], Any]]

class TrafficOperations(object):
    """TrafficOperations operations.

    You should not instantiate this class directly. Instead, you should create a Client instance that
    instantiates it for you and attaches it as an attribute.

    :ivar models: Alias to model classes used in this operation group.
    :type models: ~azure.maps.traffic.models
    :param client: Client for service requests.
    :param config: Configuration of service client.
    :param serializer: An object model serializer.
    :param deserializer: An object model deserializer.
    """

    models = _models

    def __init__(self, client, config, serializer, deserializer):
        self._client = client
        self._serialize = serializer
        self._deserialize = deserializer
        self._config = config

    def get_traffic_flow_tile(
        self,
        format,  # type: Union[str, "_models.TileFormat"]
        style,  # type: Union[str, "_models.TrafficFlowTileStyle"]
        zoom,  # type: int
        x_tile_index,  # type: int
        y_tile_index,  # type: int
        thickness=None,  # type: Optional[int]
        **kwargs  # type: Any
    ):
        # type: (...) -> IO
        """**Traffic Flow Tile**

        **Applies to**\ : S0 and S1 pricing tiers.

        The Azure Flow Tile API serves 256 x 256 pixel tiles showing traffic flow. All tiles use the
        same grid system. Because the traffic tiles use transparent images, they can be layered on top
        of map tiles to create a compound  display. The Flow tiles use colors to indicate either the
        speed of traffic on different road segments, or the difference between that speed and the
        free-flow speed on the road segment in question.

        :param format: Desired format of the response. Possible values are png & pbf.
        :type format: str or ~azure.maps.traffic.models.TileFormat
        :param style: .. raw:: html

            <p>The style to be used to render the tile.</p>.
        :type style: str or ~azure.maps.traffic.models.TrafficFlowTileStyle
        :param zoom: Zoom level for the desired tile. For *raster* tiles, value must be in the range:
         0-22 (inclusive). For *vector* tiles, value must be in the range: 0-22 (inclusive).
         Please see `Zoom Levels and Tile Grid
         <https://docs.microsoft.com/en-us/azure/location-based-services/zoom-levels-and-tile-grid>`_
         for details.
        :type zoom: int
        :param x_tile_index: X coordinate of the tile on zoom grid. Value must be in the range [0,
         2:code:`<sup>`zoom`</sup>` -1].

         Please see `Zoom Levels and Tile Grid
         <https://docs.microsoft.com/en-us/azure/location-based-services/zoom-levels-and-tile-grid>`_
         for details.
        :type x_tile_index: int
        :param y_tile_index: Y coordinate of the tile on zoom grid. Value must be in the range [0,
         2:code:`<sup>`zoom`</sup>` -1].

         Please see `Zoom Levels and Tile Grid
         <https://docs.microsoft.com/en-us/azure/location-based-services/zoom-levels-and-tile-grid>`_
         for details.
        :type y_tile_index: int
        :param thickness: The value of the width of the line representing traffic. This value is a
         multiplier and the accepted values range from 1 - 20. The default value is 10. This parameter
         is not valid when format is pbf.
        :type thickness: int
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: IO, or the result of cls(response)
        :rtype: IO
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType[IO]
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}))
        api_version = "1.0"
        accept = "application/json, image/jpeg, image/png, image/pbf, application/vnd.mapbox-vector-tile"

        # Construct URL
        url = self.get_traffic_flow_tile.metadata['url']  # type: ignore
        path_format_arguments = {
            'geography': self._serialize.url("self._config.geography", self._config.geography, 'str'),
            'format': self._serialize.url("format", format, 'str'),
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]
        query_parameters['api-version'] = self._serialize.query("api_version", api_version, 'str')
        query_parameters['style'] = self._serialize.query("style", style, 'str')
        query_parameters['zoom'] = self._serialize.query("zoom", zoom, 'int')
        query_parameters['x'] = self._serialize.query("x_tile_index", x_tile_index, 'int')
        query_parameters['y'] = self._serialize.query("y_tile_index", y_tile_index, 'int')
        if thickness is not None:
            query_parameters['thickness'] = self._serialize.query("thickness", thickness, 'int', maximum=20, minimum=1)

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]
        if self._config.x_ms_client_id is not None:
            header_parameters['x-ms-client-id'] = self._serialize.header("self._config.x_ms_client_id", self._config.x_ms_client_id, 'str')
        header_parameters['Accept'] = self._serialize.header("accept", accept, 'str')

        request = self._client.get(url, query_parameters, header_parameters)
        pipeline_response = self._client._pipeline.run(request, stream=True, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize.failsafe_deserialize(_models.ErrorResponse, response)
            raise HttpResponseError(response=response, model=error)

        response_headers = {}
        response_headers['Content-Type']=self._deserialize('str', response.headers.get('Content-Type'))
        deserialized = response.stream_download(self._client._pipeline)

        if cls:
            return cls(pipeline_response, deserialized, response_headers)

        return deserialized
    get_traffic_flow_tile.metadata = {'url': '/traffic/flow/tile/{format}'}  # type: ignore

    def get_traffic_flow_segment(
        self,
        format,  # type: Union[str, "_models.TextFormat"]
        style,  # type: Union[str, "_models.TrafficFlowSegmentStyle"]
        zoom,  # type: int
        query,  # type: str
        unit=None,  # type: Optional[Union[str, "_models.SpeedUnit"]]
        thickness=None,  # type: Optional[int]
        open_lr=None,  # type: Optional[bool]
        **kwargs  # type: Any
    ):
        # type: (...) -> "_models.TrafficFlowSegmentResult"
        """**Traffic Flow Segment**

        **Applies to**\ : S0 and S1 pricing tiers.

        This service provides information about the speeds and travel times of the road fragment
        closest to the given coordinates. It is designed to work alongside the Flow layer of the Render
        Service to support clickable  flow data visualizations. With this API, the client side can
        connect any place in the map with flow data on the  closest road and present it to the user.

        :param format: Desired format of the response. Value can be either *json* or *xml*.
        :type format: str or ~azure.maps.traffic.models.TextFormat
        :param style: The style to be used to render the tile. Valid values are absolute which returns
         colors reflecting the absolute speed measured, relative which returns the speed relative to
         free-flow, Relative-delay which displays relative speeds only where they are different from the
         freeflow speeds.
        :type style: str or ~azure.maps.traffic.models.TrafficFlowSegmentStyle
        :param zoom: Zoom level for the desired tile. Zoom value must be in the range: 0-22
         (inclusive).
         Please see `Zoom Levels and Tile Grid
         <https://docs.microsoft.com/en-us/azure/location-based-services/zoom-levels-and-tile-grid>`_
         for details.
        :type zoom: int
        :param query: Coordinates of the point close to the road segment. They have to be
         comma-separated and calculated using EPSG4326 projection.
        :type query: str
        :param unit: Unit of speed in KMPH or MPH.
        :type unit: str or ~azure.maps.traffic.models.SpeedUnit
        :param thickness: The value of the width of the line representing traffic. This value is a
         multiplier and the accepted values range from 1 - 20. The default value is 10.
        :type thickness: int
        :param open_lr: Boolean on whether the response should include OpenLR code.
        :type open_lr: bool
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: TrafficFlowSegmentResult, or the result of cls(response)
        :rtype: ~azure.maps.traffic.models.TrafficFlowSegmentResult
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType["_models.TrafficFlowSegmentResult"]
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}))
        api_version = "1.0"
        accept = "application/json"

        # Construct URL
        url = self.get_traffic_flow_segment.metadata['url']  # type: ignore
        path_format_arguments = {
            'geography': self._serialize.url("self._config.geography", self._config.geography, 'str'),
            'format': self._serialize.url("format", format, 'str'),
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]
        query_parameters['api-version'] = self._serialize.query("api_version", api_version, 'str')
        query_parameters['style'] = self._serialize.query("style", style, 'str')
        query_parameters['zoom'] = self._serialize.query("zoom", zoom, 'int')
        query_parameters['query'] = self._serialize.query("query", query, 'str')
        if unit is not None:
            query_parameters['unit'] = self._serialize.query("unit", unit, 'str')
        if thickness is not None:
            query_parameters['thickness'] = self._serialize.query("thickness", thickness, 'int', maximum=20, minimum=1)
        if open_lr is not None:
            query_parameters['openLr'] = self._serialize.query("open_lr", open_lr, 'bool')

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]
        if self._config.x_ms_client_id is not None:
            header_parameters['x-ms-client-id'] = self._serialize.header("self._config.x_ms_client_id", self._config.x_ms_client_id, 'str')
        header_parameters['Accept'] = self._serialize.header("accept", accept, 'str')

        request = self._client.get(url, query_parameters, header_parameters)
        pipeline_response = self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize.failsafe_deserialize(_models.ErrorResponse, response)
            raise HttpResponseError(response=response, model=error)

        deserialized = self._deserialize('TrafficFlowSegmentResult', pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized
    get_traffic_flow_segment.metadata = {'url': '/traffic/flow/segment/{format}'}  # type: ignore

    def get_traffic_incident_tile(
        self,
        format,  # type: Union[str, "_models.TileFormat"]
        style,  # type: Union[str, "_models.TrafficIncidentTileStyle"]
        zoom,  # type: int
        x_tile_index,  # type: int
        y_tile_index,  # type: int
        traffic_state=None,  # type: Optional[str]
        **kwargs  # type: Any
    ):
        # type: (...) -> IO
        """**Traffic Incident Tile**

        **Applies to**\ : S0 and S1 pricing tiers.

        This service serves 256 x 256 pixel tiles showing traffic incidents. All tiles use the same
        grid system. Because the traffic tiles use transparent images, they can be layered on top of
        map tiles to create a compound display. Traffic tiles render graphics to indicate traffic on
        the roads in the specified area.

        :param format: Desired format of the response. Possible values are png & pbf.
        :type format: str or ~azure.maps.traffic.models.TileFormat
        :param style: The style to be used to render the tile. This parameter is not valid when format
         is pbf.
        :type style: str or ~azure.maps.traffic.models.TrafficIncidentTileStyle
        :param zoom: Zoom level for the desired tile. For *raster* tiles, value must be in the range:
         0-22 (inclusive). For *vector* tiles, value must be in the range: 0-22 (inclusive).
         Please see `Zoom Levels and Tile Grid
         <https://docs.microsoft.com/en-us/azure/location-based-services/zoom-levels-and-tile-grid>`_
         for details.
        :type zoom: int
        :param x_tile_index: X coordinate of the tile on zoom grid. Value must be in the range [0,
         2:code:`<sup>`zoom`</sup>` -1].

         Please see `Zoom Levels and Tile Grid
         <https://docs.microsoft.com/en-us/azure/location-based-services/zoom-levels-and-tile-grid>`_
         for details.
        :type x_tile_index: int
        :param y_tile_index: Y coordinate of the tile on zoom grid. Value must be in the range [0,
         2:code:`<sup>`zoom`</sup>` -1].

         Please see `Zoom Levels and Tile Grid
         <https://docs.microsoft.com/en-us/azure/location-based-services/zoom-levels-and-tile-grid>`_
         for details.
        :type y_tile_index: int
        :param traffic_state: Reference value for the state of traffic at a particular time, obtained
         from the Viewport API call, trafficModelId attribute in trafficState field. It is updated every
         minute, and is valid for two minutes before it times out. Use -1 to  get the most recent
         traffic information. Default: most recent traffic information.
        :type traffic_state: str
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: IO, or the result of cls(response)
        :rtype: IO
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType[IO]
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}))
        api_version = "1.0"
        accept = "application/json, image/jpeg, image/png, image/pbf, application/vnd.mapbox-vector-tile"

        # Construct URL
        url = self.get_traffic_incident_tile.metadata['url']  # type: ignore
        path_format_arguments = {
            'geography': self._serialize.url("self._config.geography", self._config.geography, 'str'),
            'format': self._serialize.url("format", format, 'str'),
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]
        query_parameters['api-version'] = self._serialize.query("api_version", api_version, 'str')
        query_parameters['style'] = self._serialize.query("style", style, 'str')
        query_parameters['zoom'] = self._serialize.query("zoom", zoom, 'int')
        query_parameters['x'] = self._serialize.query("x_tile_index", x_tile_index, 'int')
        query_parameters['y'] = self._serialize.query("y_tile_index", y_tile_index, 'int')
        if traffic_state is not None:
            query_parameters['t'] = self._serialize.query("traffic_state", traffic_state, 'str')

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]
        if self._config.x_ms_client_id is not None:
            header_parameters['x-ms-client-id'] = self._serialize.header("self._config.x_ms_client_id", self._config.x_ms_client_id, 'str')
        header_parameters['Accept'] = self._serialize.header("accept", accept, 'str')

        request = self._client.get(url, query_parameters, header_parameters)
        pipeline_response = self._client._pipeline.run(request, stream=True, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize.failsafe_deserialize(_models.ErrorResponse, response)
            raise HttpResponseError(response=response, model=error)

        response_headers = {}
        response_headers['Content-Type']=self._deserialize('str', response.headers.get('Content-Type'))
        deserialized = response.stream_download(self._client._pipeline)

        if cls:
            return cls(pipeline_response, deserialized, response_headers)

        return deserialized
    get_traffic_incident_tile.metadata = {'url': '/traffic/incident/tile/{format}'}  # type: ignore

    def get_traffic_incident_detail(
        self,
        format,  # type: Union[str, "_models.TextFormat"]
        style,  # type: Union[str, "_models.TrafficIncidentDetailStyle"]
        boundingbox,  # type: str
        bounding_zoom,  # type: int
        trafficmodelid,  # type: str
        language=None,  # type: Optional[str]
        projection=None,  # type: Optional[Union[str, "_models.ProjectionStandard"]]
        geometries=None,  # type: Optional[Union[str, "_models.IncidentGeometryType"]]
        expand_cluster=None,  # type: Optional[bool]
        original_position=None,  # type: Optional[bool]
        **kwargs  # type: Any
    ):
        # type: (...) -> "_models.TrafficIncidentDetailResult"
        """**Traffic Incident Detail**

        **Applies to**\ : S0 and S1 pricing tiers.

        This API provides information on traffic incidents inside a given bounding box, based on the
        current Traffic  Model ID. The Traffic Model ID is available to grant synchronization of data
        between calls and API's. The  Traffic Model ID is a key value for determining the currency of
        traffic incidents. It is updated every minute,  and is valid for two minutes before it times
        out. It is used in rendering  `incident tiles
        <https://docs.microsoft.com/en-us/rest/api/maps/traffic/gettrafficincidenttile>`_. It can be
        obtained from the `Viewport API
        <https://docs.microsoft.com/en-us/rest/api/maps/traffic/gettrafficincidentviewport>`_.

        :param format: Desired format of the response. Value can be either *json* or *xml*.
        :type format: str or ~azure.maps.traffic.models.TextFormat
        :param style: The style that will be used to render the tile in Traffic `Incident Tile API
         <https://docs.microsoft.com/en-us/rest/api/maps/traffic/gettrafficincidenttile>`_.  This will
         have an effect on the coordinates of traffic incidents in the reply.
        :type style: str or ~azure.maps.traffic.models.TrafficIncidentDetailStyle
        :param boundingbox: The ``boundingbox`` is represented by two value pairs describing it's
         corners (first pair for lower left corner and second for upper right). The pairs can either be
         specified using any of the ``projection``\ 's specified below (e.g., *minY,minX,maxY,maxX*\ )
         or by two latitude-longitude pairs (e.g., *minLat,minLon,maxLat,maxLon*\
         ).:code:`<br>`:code:`<br>`NOTE: If latitude/longitude pairs are used, then the ``projection``
         parameter must be set to "EPSG4326".
        :type boundingbox: str
        :param bounding_zoom: Zoom level for desired tile. 0 to 22 for raster tiles, 0 through 22 for
         vector tiles.
        :type bounding_zoom: int
        :param trafficmodelid: Number referencing traffic model. This can be obtained from the
         `Viewport API
         <https://docs.microsoft.com/en-us/rest/api/maps/traffic/gettrafficincidentviewport>`_. It is
         updated every minute, and is valid for two minutes before it times out. If the wrong Traffic
         Model ID is specified, the correct one will be returned by the interface. A value of -1 will
         always invoke the most recent traffic model.
        :type trafficmodelid: str
        :param language: `ISO 639-1 code <https://en.wikipedia.org/wiki/List_of_ISO_639-1_codes>`_ for
         the output language. Supported languages are ar, ca, cs, da, de, el, en, en-GB, en-US, es, et,
         fi, fr, he, hu, id, in*, it, lt, lv, nb, nl, no, pl, pt, ro, ru, sk, sv, th, tr, zh.

         Please refer to `Supported Languages
         <https://docs.microsoft.com/en-us/azure/azure-maps/supported-languages>`_ for details. When
         invalid language code is provided response is returned in English. When incident cause or
         description does not have translation, English description is returned.
        :type language: str
        :param projection: The projection used to specify the coordinates in the request and response.
         `EPSG900913 <http://docs.openlayers.org/library/spherical_mercator.html>`_ (default) or
         `EPSG4326 <http://spatialreference.org/ref/epsg/4326/>`_.
        :type projection: str or ~azure.maps.traffic.models.ProjectionStandard
        :param geometries: The type of vector geometry added to incidents (returned in the :code:`<v>`
         element of the response).
        :type geometries: str or ~azure.maps.traffic.models.IncidentGeometryType
        :param expand_cluster: Boolean to indicate whether to list all traffic incidents in a cluster
         separately.
        :type expand_cluster: bool
        :param original_position: Boolean on whether to return the original position of the incident
         (:code:`<op>`) as well as the one shifted to the beginning of the traffic tube (:code:`<op>`).
        :type original_position: bool
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: TrafficIncidentDetailResult, or the result of cls(response)
        :rtype: ~azure.maps.traffic.models.TrafficIncidentDetailResult
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType["_models.TrafficIncidentDetailResult"]
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}))
        api_version = "1.0"
        accept = "application/json"

        # Construct URL
        url = self.get_traffic_incident_detail.metadata['url']  # type: ignore
        path_format_arguments = {
            'geography': self._serialize.url("self._config.geography", self._config.geography, 'str'),
            'format': self._serialize.url("format", format, 'str'),
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]
        query_parameters['api-version'] = self._serialize.query("api_version", api_version, 'str')
        query_parameters['style'] = self._serialize.query("style", style, 'str')
        query_parameters['boundingbox'] = self._serialize.query("boundingbox", boundingbox, 'str')
        query_parameters['boundingZoom'] = self._serialize.query("bounding_zoom", bounding_zoom, 'int', maximum=22, minimum=0)
        query_parameters['trafficmodelid'] = self._serialize.query("trafficmodelid", trafficmodelid, 'str')
        if language is not None:
            query_parameters['language'] = self._serialize.query("language", language, 'str')
        if projection is not None:
            query_parameters['projection'] = self._serialize.query("projection", projection, 'str')
        if geometries is not None:
            query_parameters['geometries'] = self._serialize.query("geometries", geometries, 'str')
        if expand_cluster is not None:
            query_parameters['expandCluster'] = self._serialize.query("expand_cluster", expand_cluster, 'bool')
        if original_position is not None:
            query_parameters['originalPosition'] = self._serialize.query("original_position", original_position, 'bool')

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]
        if self._config.x_ms_client_id is not None:
            header_parameters['x-ms-client-id'] = self._serialize.header("self._config.x_ms_client_id", self._config.x_ms_client_id, 'str')
        header_parameters['Accept'] = self._serialize.header("accept", accept, 'str')

        request = self._client.get(url, query_parameters, header_parameters)
        pipeline_response = self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize.failsafe_deserialize(_models.ErrorResponse, response)
            raise HttpResponseError(response=response, model=error)

        deserialized = self._deserialize('TrafficIncidentDetailResult', pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized
    get_traffic_incident_detail.metadata = {'url': '/traffic/incident/detail/{format}'}  # type: ignore

    def get_traffic_incident_viewport(
        self,
        format,  # type: Union[str, "_models.TextFormat"]
        boundingbox,  # type: str
        boundingzoom,  # type: int
        overviewbox,  # type: str
        overviewzoom,  # type: int
        copyright=True,  # type: Optional[bool]
        **kwargs  # type: Any
    ):
        # type: (...) -> "_models.TrafficIncidentViewportResult"
        """**Traffic Incident Viewport**

        **Applies to**\ : S0 and S1 pricing tiers.

        This API returns legal and technical information for the viewport described in the request. It
        should be called  by client applications whenever the viewport changes (for instance, through
        zooming, panning, going to a  location, or displaying a route). The request should contain the
        bounding box and zoom level of the viewport  whose information is needed. The return will
        contain map version information, as well as the current Traffic  Model ID and copyright IDs.
        The Traffic Model ID returned by the Viewport Description is used by other APIs to  retrieve
        last traffic information for further processing.

        :param format: Desired format of the response. Value can be either *json* or *xml*.
        :type format: str or ~azure.maps.traffic.models.TextFormat
        :param boundingbox: Bounding box of the map viewport in `EPSG900913
         <http://docs.openlayers.org/library/spherical_mercator.html>`_ projection. The ``boundingbox``
         is represented by two value pairs describing it's corners (first pair for lower left corner and
         second for upper right). All values should be separated by commas (e.g., *minY,minX,maxY,maxX*\
         ). The maximum size of the bounding box that can be passed is dependent on the requested zoom
         level. The width and height cannot exceed 4092 pixels when rendered on the given zoom
         level.:code:`<br>`:code:`<br>`NOTE: Bounding boxes that cross the 180° meridian require special
         treatment. For such boxes, the eastern *maxX* value will be negative, and thus less than the
         *minX* value west of the 180° meridian. To address that, the value 40075016.6855874 should be
         added to the true *maxX* value before it is passed in the request.
        :type boundingbox: str
        :param boundingzoom: Zoom level of the map viewport. Used to determine whether the view can be
         zoomed in.
        :type boundingzoom: int
        :param overviewbox: Bounding box of the overview map in `EPSG900913
         <http://docs.openlayers.org/library/spherical_mercator.html>`_
         projection.:code:`<br>`:code:`<br>`Used in case the overview box/mini map has different
         copyright data than the main map. If there is no mini map, the same coordinates as
         ``boundingBox`` is used.
        :type overviewbox: str
        :param overviewzoom: Zoom level of the overview map. If there is no mini map, use the same zoom
         level as boundingZoom.
        :type overviewzoom: int
        :param copyright: Determines what copyright information to return. When true the copyright text
         is returned; when false only the copyright index is returned.
        :type copyright: bool
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: TrafficIncidentViewportResult, or the result of cls(response)
        :rtype: ~azure.maps.traffic.models.TrafficIncidentViewportResult
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType["_models.TrafficIncidentViewportResult"]
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}))
        api_version = "1.0"
        accept = "application/json"

        # Construct URL
        url = self.get_traffic_incident_viewport.metadata['url']  # type: ignore
        path_format_arguments = {
            'geography': self._serialize.url("self._config.geography", self._config.geography, 'str'),
            'format': self._serialize.url("format", format, 'str'),
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]
        query_parameters['api-version'] = self._serialize.query("api_version", api_version, 'str')
        query_parameters['boundingbox'] = self._serialize.query("boundingbox", boundingbox, 'str')
        query_parameters['boundingzoom'] = self._serialize.query("boundingzoom", boundingzoom, 'int', maximum=22, minimum=0)
        query_parameters['overviewbox'] = self._serialize.query("overviewbox", overviewbox, 'str')
        query_parameters['overviewzoom'] = self._serialize.query("overviewzoom", overviewzoom, 'int', maximum=22, minimum=0)
        if copyright is not None:
            query_parameters['copyright'] = self._serialize.query("copyright", copyright, 'bool')

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]
        if self._config.x_ms_client_id is not None:
            header_parameters['x-ms-client-id'] = self._serialize.header("self._config.x_ms_client_id", self._config.x_ms_client_id, 'str')
        header_parameters['Accept'] = self._serialize.header("accept", accept, 'str')

        request = self._client.get(url, query_parameters, header_parameters)
        pipeline_response = self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize.failsafe_deserialize(_models.ErrorResponse, response)
            raise HttpResponseError(response=response, model=error)

        deserialized = self._deserialize('TrafficIncidentViewportResult', pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized
    get_traffic_incident_viewport.metadata = {'url': '/traffic/incident/viewport/{format}'}  # type: ignore
