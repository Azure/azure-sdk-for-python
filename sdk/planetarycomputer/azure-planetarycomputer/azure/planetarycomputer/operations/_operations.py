# pylint: disable=line-too-long,useless-suppression,too-many-lines,too-many-locals,too-many-branches,too-many-statements,file-needs-copyright-header
# coding=utf-8
# --------------------------------------------------------------------------
# Copyright (c) Microsoft Corporation. All rights reserved.
# Licensed under the MIT License. See License.txt in the project root for license information.
# Code generated by Microsoft (R) Python Code Generator.
# Changes may cause incorrect behavior and will be lost if the code is regenerated.
# --------------------------------------------------------------------------
from collections.abc import MutableMapping
from io import IOBase
import json
from typing import Any, Callable, Dict, IO, Iterator, List, Optional, TYPE_CHECKING, TypeVar, Union, cast, overload

from azure.core import PipelineClient
from azure.core.exceptions import (
    ClientAuthenticationError,
    HttpResponseError,
    ResourceExistsError,
    ResourceNotFoundError,
    ResourceNotModifiedError,
    StreamClosedError,
    StreamConsumedError,
    map_error,
)
from azure.core.pipeline import PipelineResponse
from azure.core.polling import LROPoller, NoPolling, PollingMethod
from azure.core.polling.base_polling import LROBasePolling
from azure.core.rest import HttpRequest, HttpResponse
from azure.core.tracing.decorator import distributed_trace
from azure.core.utils import case_insensitive_dict

from .. import models as _models
from .._configuration import PlanetaryComputerClientConfiguration
from .._utils.model_base import Model as _Model, SdkJSONEncoder, _deserialize, _deserialize_xml
from .._utils.serialization import Deserializer, Serializer
from .._utils.utils import prepare_multipart_form_data

if TYPE_CHECKING:
    from .. import _types
JSON = MutableMapping[str, Any]
T = TypeVar("T")
ClsType = Optional[Callable[[PipelineResponse[HttpRequest, HttpResponse], T, Dict[str, Any]], Any]]
_Unset: Any = object()

_SERIALIZER = Serializer()
_SERIALIZER.client_side_validation = False


def build_ingestions_list_all_request(
    collection_id: str, *, top: Optional[int] = None, skip: Optional[int] = None, **kwargs: Any
) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2025-04-30-preview"))
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/inma/collections/{collectionId}/ingestions"
    path_format_arguments = {
        "collectionId": _SERIALIZER.url("collection_id", collection_id, "str"),
    }

    _url: str = _url.format(**path_format_arguments)  # type: ignore

    # Construct parameters
    _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")
    if top is not None:
        _params["$top"] = _SERIALIZER.query("top", top, "int")
    if skip is not None:
        _params["$skip"] = _SERIALIZER.query("skip", skip, "int")

    # Construct headers
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="GET", url=_url, params=_params, headers=_headers, **kwargs)


def build_ingestions_create_request(collection_id: str, **kwargs: Any) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2025-04-30-preview"))
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/inma/collections/{collectionId}/ingestions"
    path_format_arguments = {
        "collectionId": _SERIALIZER.url("collection_id", collection_id, "str"),
    }

    _url: str = _url.format(**path_format_arguments)  # type: ignore

    # Construct parameters
    _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")

    # Construct headers
    if content_type is not None:
        _headers["Content-Type"] = _SERIALIZER.header("content_type", content_type, "str")
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="POST", url=_url, params=_params, headers=_headers, **kwargs)


def build_ingestions_get_request(collection_id: str, ingestion_id: str, **kwargs: Any) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2025-04-30-preview"))
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/inma/collections/{collectionId}/ingestions/{ingestionId}"
    path_format_arguments = {
        "collectionId": _SERIALIZER.url("collection_id", collection_id, "str"),
        "ingestionId": _SERIALIZER.url("ingestion_id", ingestion_id, "str"),
    }

    _url: str = _url.format(**path_format_arguments)  # type: ignore

    # Construct parameters
    _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")

    # Construct headers
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="GET", url=_url, params=_params, headers=_headers, **kwargs)


def build_ingestions_update_request(collection_id: str, ingestion_id: str, **kwargs: Any) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("content-type", None))
    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2025-04-30-preview"))
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/inma/collections/{collectionId}/ingestions/{ingestionId}"
    path_format_arguments = {
        "collectionId": _SERIALIZER.url("collection_id", collection_id, "str"),
        "ingestionId": _SERIALIZER.url("ingestion_id", ingestion_id, "str"),
    }

    _url: str = _url.format(**path_format_arguments)  # type: ignore

    # Construct parameters
    _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")

    # Construct headers
    if content_type is not None:
        _headers["content-type"] = _SERIALIZER.header("content_type", content_type, "str")
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="PATCH", url=_url, params=_params, headers=_headers, **kwargs)


def build_ingestions_delete_request(collection_id: str, ingestion_id: str, **kwargs: Any) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2025-04-30-preview"))
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/inma/collections/{collectionId}/ingestions/{ingestionId}"
    path_format_arguments = {
        "collectionId": _SERIALIZER.url("collection_id", collection_id, "str"),
        "ingestionId": _SERIALIZER.url("ingestion_id", ingestion_id, "str"),
    }

    _url: str = _url.format(**path_format_arguments)  # type: ignore

    # Construct parameters
    _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")

    # Construct headers
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="DELETE", url=_url, params=_params, headers=_headers, **kwargs)


def build_stac_items_get_features_request(
    collection_id: str,
    *,
    limit: Optional[int] = None,
    bbox: Optional[List[str]] = None,
    datetime: Optional[str] = None,
    **kwargs: Any,
) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2025-04-30-preview"))
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/stac/collections/{collectionId}/items"
    path_format_arguments = {
        "collectionId": _SERIALIZER.url("collection_id", collection_id, "str"),
    }

    _url: str = _url.format(**path_format_arguments)  # type: ignore

    # Construct parameters
    _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")
    if limit is not None:
        _params["limit"] = _SERIALIZER.query("limit", limit, "int")
    if bbox is not None:
        _params["bbox"] = [_SERIALIZER.query("bbox", q, "str") if q is not None else "" for q in bbox]
    if datetime is not None:
        _params["datetime"] = _SERIALIZER.query("datetime", datetime, "str")

    # Construct headers
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="GET", url=_url, params=_params, headers=_headers, **kwargs)


def build_stac_items_create_request(collection_id: str, **kwargs: Any) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2025-04-30-preview"))
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/stac/collections/{collectionId}/items"
    path_format_arguments = {
        "collectionId": _SERIALIZER.url("collection_id", collection_id, "str"),
    }

    _url: str = _url.format(**path_format_arguments)  # type: ignore

    # Construct parameters
    _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")

    # Construct headers
    if content_type is not None:
        _headers["Content-Type"] = _SERIALIZER.header("content_type", content_type, "str")
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="POST", url=_url, params=_params, headers=_headers, **kwargs)


def build_stac_items_get_request(collection_id: str, item_id: str, **kwargs: Any) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2025-04-30-preview"))
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/stac/collections/{collectionId}/items/{itemId}"
    path_format_arguments = {
        "collectionId": _SERIALIZER.url("collection_id", collection_id, "str"),
        "itemId": _SERIALIZER.url("item_id", item_id, "str"),
    }

    _url: str = _url.format(**path_format_arguments)  # type: ignore

    # Construct parameters
    _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")

    # Construct headers
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="GET", url=_url, params=_params, headers=_headers, **kwargs)


def build_stac_items_create_or_replace_request(  # pylint: disable=name-too-long
    collection_id: str, item_id: str, **kwargs: Any
) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2025-04-30-preview"))
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/stac/collections/{collectionId}/items/{itemId}"
    path_format_arguments = {
        "collectionId": _SERIALIZER.url("collection_id", collection_id, "str"),
        "itemId": _SERIALIZER.url("item_id", item_id, "str"),
    }

    _url: str = _url.format(**path_format_arguments)  # type: ignore

    # Construct parameters
    _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")

    # Construct headers
    if content_type is not None:
        _headers["Content-Type"] = _SERIALIZER.header("content_type", content_type, "str")
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="PUT", url=_url, params=_params, headers=_headers, **kwargs)


def build_stac_items_update_request(collection_id: str, item_id: str, **kwargs: Any) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("content-type", None))
    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2025-04-30-preview"))
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/stac/collections/{collectionId}/items/{itemId}"
    path_format_arguments = {
        "collectionId": _SERIALIZER.url("collection_id", collection_id, "str"),
        "itemId": _SERIALIZER.url("item_id", item_id, "str"),
    }

    _url: str = _url.format(**path_format_arguments)  # type: ignore

    # Construct parameters
    _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")

    # Construct headers
    if content_type is not None:
        _headers["content-type"] = _SERIALIZER.header("content_type", content_type, "str")
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="PATCH", url=_url, params=_params, headers=_headers, **kwargs)


def build_stac_items_delete_request(collection_id: str, item_id: str, **kwargs: Any) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2025-04-30-preview"))
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/stac/collections/{collectionId}/items/{itemId}"
    path_format_arguments = {
        "collectionId": _SERIALIZER.url("collection_id", collection_id, "str"),
        "itemId": _SERIALIZER.url("item_id", item_id, "str"),
    }

    _url: str = _url.format(**path_format_arguments)  # type: ignore

    # Construct parameters
    _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")

    # Construct headers
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="DELETE", url=_url, params=_params, headers=_headers, **kwargs)


def build_ingestion_sources_list_all_request(
    *, top: Optional[int] = None, skip: Optional[int] = None, **kwargs: Any
) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2025-04-30-preview"))
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/inma/ingestion-sources"

    # Construct parameters
    _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")
    if top is not None:
        _params["$top"] = _SERIALIZER.query("top", top, "int")
    if skip is not None:
        _params["$skip"] = _SERIALIZER.query("skip", skip, "int")

    # Construct headers
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="GET", url=_url, params=_params, headers=_headers, **kwargs)


def build_ingestion_sources_create_request(**kwargs: Any) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2025-04-30-preview"))
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/inma/ingestion-sources"

    # Construct parameters
    _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")

    # Construct headers
    if content_type is not None:
        _headers["Content-Type"] = _SERIALIZER.header("content_type", content_type, "str")
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="POST", url=_url, params=_params, headers=_headers, **kwargs)


def build_ingestion_sources_get_request(id: str, **kwargs: Any) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2025-04-30-preview"))
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/inma/ingestion-sources/{id}"
    path_format_arguments = {
        "id": _SERIALIZER.url("id", id, "str"),
    }

    _url: str = _url.format(**path_format_arguments)  # type: ignore

    # Construct parameters
    _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")

    # Construct headers
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="GET", url=_url, params=_params, headers=_headers, **kwargs)


def build_ingestion_sources_create_or_replace_request(  # pylint: disable=name-too-long
    id: str, **kwargs: Any
) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2025-04-30-preview"))
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/inma/ingestion-sources/{id}"
    path_format_arguments = {
        "id": _SERIALIZER.url("id", id, "str"),
    }

    _url: str = _url.format(**path_format_arguments)  # type: ignore

    # Construct parameters
    _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")

    # Construct headers
    if content_type is not None:
        _headers["Content-Type"] = _SERIALIZER.header("content_type", content_type, "str")
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="PUT", url=_url, params=_params, headers=_headers, **kwargs)


def build_ingestion_sources_delete_request(id: str, **kwargs: Any) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2025-04-30-preview"))
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/inma/ingestion-sources/{id}"
    path_format_arguments = {
        "id": _SERIALIZER.url("id", id, "str"),
    }

    _url: str = _url.format(**path_format_arguments)  # type: ignore

    # Construct parameters
    _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")

    # Construct headers
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="DELETE", url=_url, params=_params, headers=_headers, **kwargs)


def build_ingestion_sources_list_managed_identities_request(  # pylint: disable=name-too-long
    **kwargs: Any,
) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2025-04-30-preview"))
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/inma/ingestion-sources/managed-identities"

    # Construct parameters
    _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")

    # Construct headers
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="GET", url=_url, params=_params, headers=_headers, **kwargs)


def build_ingestion_operations_get_request(operation_id: str, **kwargs: Any) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2025-04-30-preview"))
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/inma/operations/{operationId}"
    path_format_arguments = {
        "operationId": _SERIALIZER.url("operation_id", operation_id, "str"),
    }

    _url: str = _url.format(**path_format_arguments)  # type: ignore

    # Construct parameters
    _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")

    # Construct headers
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="GET", url=_url, params=_params, headers=_headers, **kwargs)


def build_ingestion_operations_list_all_request(  # pylint: disable=name-too-long
    *,
    top: Optional[int] = None,
    skip: Optional[int] = None,
    collection_id: Optional[str] = None,
    status: Optional[Union[str, _models.OperationStatus]] = None,
    **kwargs: Any,
) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2025-04-30-preview"))
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/inma/operations"

    # Construct parameters
    _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")
    if top is not None:
        _params["$top"] = _SERIALIZER.query("top", top, "int")
    if skip is not None:
        _params["$skip"] = _SERIALIZER.query("skip", skip, "int")
    if collection_id is not None:
        _params["collectionId"] = _SERIALIZER.query("collection_id", collection_id, "str")
    if status is not None:
        _params["status"] = _SERIALIZER.query("status", status, "str")

    # Construct headers
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="GET", url=_url, params=_params, headers=_headers, **kwargs)


def build_ingestion_operations_delete_all_request(**kwargs: Any) -> HttpRequest:  # pylint: disable=name-too-long
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2025-04-30-preview"))
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/inma/operations"

    # Construct parameters
    _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")

    # Construct headers
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="DELETE", url=_url, params=_params, headers=_headers, **kwargs)


def build_ingestion_operations_delete_request(  # pylint: disable=name-too-long
    operation_id: str, **kwargs: Any
) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2025-04-30-preview"))
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/inma/operations/{operationId}"
    path_format_arguments = {
        "operationId": _SERIALIZER.url("operation_id", operation_id, "str"),
    }

    _url: str = _url.format(**path_format_arguments)  # type: ignore

    # Construct parameters
    _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")

    # Construct headers
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="DELETE", url=_url, params=_params, headers=_headers, **kwargs)


def build_stac_landing_pages_get_request(**kwargs: Any) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2025-04-30-preview"))
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/stac"

    # Construct parameters
    _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")

    # Construct headers
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="GET", url=_url, params=_params, headers=_headers, **kwargs)


def build_stac_collection_operations_get_all_request(  # pylint: disable=name-too-long
    *, sign: Optional[Union[str, _models.SignType]] = None, duration: Optional[int] = None, **kwargs: Any
) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2025-04-30-preview"))
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/stac/collections"

    # Construct parameters
    _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")
    if sign is not None:
        _params["sign"] = _SERIALIZER.query("sign", sign, "str")
    if duration is not None:
        _params["duration"] = _SERIALIZER.query("duration", duration, "int")

    # Construct headers
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="GET", url=_url, params=_params, headers=_headers, **kwargs)


def build_stac_collection_operations_create_request(**kwargs: Any) -> HttpRequest:  # pylint: disable=name-too-long
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2025-04-30-preview"))
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/stac/collections"

    # Construct parameters
    _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")

    # Construct headers
    if content_type is not None:
        _headers["Content-Type"] = _SERIALIZER.header("content_type", content_type, "str")
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="POST", url=_url, params=_params, headers=_headers, **kwargs)


def build_stac_collection_operations_get_request(  # pylint: disable=name-too-long
    collection_id: str,
    *,
    sign: Optional[Union[str, _models.SignType]] = None,
    duration: Optional[int] = None,
    **kwargs: Any,
) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2025-04-30-preview"))
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/stac/collections/{collectionId}"
    path_format_arguments = {
        "collectionId": _SERIALIZER.url("collection_id", collection_id, "str"),
    }

    _url: str = _url.format(**path_format_arguments)  # type: ignore

    # Construct parameters
    _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")
    if sign is not None:
        _params["sign"] = _SERIALIZER.query("sign", sign, "str")
    if duration is not None:
        _params["duration"] = _SERIALIZER.query("duration", duration, "int")

    # Construct headers
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="GET", url=_url, params=_params, headers=_headers, **kwargs)


def build_stac_collection_operations_create_or_replace_request(  # pylint: disable=name-too-long
    collection_id: str, **kwargs: Any
) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2025-04-30-preview"))
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/stac/collections/{collectionId}"
    path_format_arguments = {
        "collectionId": _SERIALIZER.url("collection_id", collection_id, "str"),
    }

    _url: str = _url.format(**path_format_arguments)  # type: ignore

    # Construct parameters
    _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")

    # Construct headers
    if content_type is not None:
        _headers["Content-Type"] = _SERIALIZER.header("content_type", content_type, "str")
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="PUT", url=_url, params=_params, headers=_headers, **kwargs)


def build_stac_collection_operations_delete_request(  # pylint: disable=name-too-long
    collection_id: str, **kwargs: Any
) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2025-04-30-preview"))
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/stac/collections/{collectionId}"
    path_format_arguments = {
        "collectionId": _SERIALIZER.url("collection_id", collection_id, "str"),
    }

    _url: str = _url.format(**path_format_arguments)  # type: ignore

    # Construct parameters
    _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")

    # Construct headers
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="DELETE", url=_url, params=_params, headers=_headers, **kwargs)


def build_stac_queryables_get_all_request(**kwargs: Any) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2025-04-30-preview"))
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/stac/queryables"

    # Construct parameters
    _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")

    # Construct headers
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="GET", url=_url, params=_params, headers=_headers, **kwargs)


def build_stac_queryables_delete_request(collection_id: str, queryable_name: str, **kwargs: Any) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2025-04-30-preview"))
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/stac/collections/{collectionId}/queryables/{queryableName}"
    path_format_arguments = {
        "collectionId": _SERIALIZER.url("collection_id", collection_id, "str"),
        "queryableName": _SERIALIZER.url("queryable_name", queryable_name, "str"),
    }

    _url: str = _url.format(**path_format_arguments)  # type: ignore

    # Construct parameters
    _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")

    # Construct headers
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="DELETE", url=_url, params=_params, headers=_headers, **kwargs)


def build_stac_queryables_get_all_by_collection_request(  # pylint: disable=name-too-long
    collection_id: str, **kwargs: Any
) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2025-04-30-preview"))
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/stac/collections/{collectionId}/queryables"
    path_format_arguments = {
        "collectionId": _SERIALIZER.url("collection_id", collection_id, "str"),
    }

    _url: str = _url.format(**path_format_arguments)  # type: ignore

    # Construct parameters
    _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")

    # Construct headers
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="GET", url=_url, params=_params, headers=_headers, **kwargs)


def build_stac_queryables_create_request(collection_id: str, **kwargs: Any) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2025-04-30-preview"))
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/stac/collections/{collectionId}/queryables"
    path_format_arguments = {
        "collectionId": _SERIALIZER.url("collection_id", collection_id, "str"),
    }

    _url: str = _url.format(**path_format_arguments)  # type: ignore

    # Construct parameters
    _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")

    # Construct headers
    if content_type is not None:
        _headers["Content-Type"] = _SERIALIZER.header("content_type", content_type, "str")
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="POST", url=_url, params=_params, headers=_headers, **kwargs)


def build_stac_queryables_create_or_replace_request(  # pylint: disable=name-too-long
    collection_id: str, queryable_name: str, **kwargs: Any
) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2025-04-30-preview"))
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/stac/collections/{collectionId}/queryables/{queryableName}"
    path_format_arguments = {
        "collectionId": _SERIALIZER.url("collection_id", collection_id, "str"),
        "queryableName": _SERIALIZER.url("queryable_name", queryable_name, "str"),
    }

    _url: str = _url.format(**path_format_arguments)  # type: ignore

    # Construct parameters
    _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")

    # Construct headers
    if content_type is not None:
        _headers["Content-Type"] = _SERIALIZER.header("content_type", content_type, "str")
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="PUT", url=_url, params=_params, headers=_headers, **kwargs)


def build_stac_conformance_class_get_request(**kwargs: Any) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2025-04-30-preview"))
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/stac/conformance"

    # Construct parameters
    _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")

    # Construct headers
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="GET", url=_url, params=_params, headers=_headers, **kwargs)


def build_stac_search_operations_get_request(
    *,
    collections: Optional[List[str]] = None,
    ids: Optional[List[str]] = None,
    bbox: Optional[List[float]] = None,
    intersects: Optional[str] = None,
    datetime: Optional[str] = None,
    limit: Optional[int] = None,
    sign: Optional[Union[str, _models.SignType]] = None,
    duration: Optional[int] = None,
    query: Optional[str] = None,
    sort_by: Optional[str] = None,
    fields: Optional[str] = None,
    filter: Optional[str] = None,
    token: Optional[str] = None,
    **kwargs: Any,
) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2025-04-30-preview"))
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/stac/search"

    # Construct parameters
    _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")
    if collections is not None:
        _params["collections"] = _SERIALIZER.query("collections", collections, "[str]", div=",")
    if ids is not None:
        _params["ids"] = _SERIALIZER.query("ids", ids, "[str]", div=",")
    if bbox is not None:
        _params["bbox"] = _SERIALIZER.query("bbox", bbox, "[float]", div=",")
    if intersects is not None:
        _params["intersects"] = _SERIALIZER.query("intersects", intersects, "str")
    if datetime is not None:
        _params["datetime"] = _SERIALIZER.query("datetime", datetime, "str")
    if limit is not None:
        _params["limit"] = _SERIALIZER.query("limit", limit, "int")
    if sign is not None:
        _params["sign"] = _SERIALIZER.query("sign", sign, "str")
    if duration is not None:
        _params["duration"] = _SERIALIZER.query("duration", duration, "int")
    if query is not None:
        _params["query"] = _SERIALIZER.query("query", query, "str")
    if sort_by is not None:
        _params["sortby"] = _SERIALIZER.query("sort_by", sort_by, "str")
    if fields is not None:
        _params["fields"] = _SERIALIZER.query("fields", fields, "str")
    if filter is not None:
        _params["filter"] = _SERIALIZER.query("filter", filter, "str")
    if token is not None:
        _params["token"] = _SERIALIZER.query("token", token, "str")

    # Construct headers
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="GET", url=_url, params=_params, headers=_headers, **kwargs)


def build_stac_search_operations_create_request(**kwargs: Any) -> HttpRequest:  # pylint: disable=name-too-long
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2025-04-30-preview"))
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/stac/search"

    # Construct parameters
    _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")

    # Construct headers
    if content_type is not None:
        _headers["Content-Type"] = _SERIALIZER.header("content_type", content_type, "str")
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="POST", url=_url, params=_params, headers=_headers, **kwargs)


def build_stac_collection_assets_create_request(  # pylint: disable=name-too-long
    collection_id: str, **kwargs: Any
) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2025-04-30-preview"))
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/stac/collections/{collectionId}/assets"
    path_format_arguments = {
        "collectionId": _SERIALIZER.url("collection_id", collection_id, "str"),
    }

    _url: str = _url.format(**path_format_arguments)  # type: ignore

    # Construct parameters
    _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")

    # Construct headers
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="POST", url=_url, params=_params, headers=_headers, **kwargs)


def build_stac_collection_assets_create_or_replace_request(  # pylint: disable=name-too-long
    collection_id: str, asset_id: str, **kwargs: Any
) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2025-04-30-preview"))
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/stac/collections/{collectionId}/assets/{assetId}"
    path_format_arguments = {
        "collectionId": _SERIALIZER.url("collection_id", collection_id, "str"),
        "assetId": _SERIALIZER.url("asset_id", asset_id, "str"),
    }

    _url: str = _url.format(**path_format_arguments)  # type: ignore

    # Construct parameters
    _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")

    # Construct headers
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="PUT", url=_url, params=_params, headers=_headers, **kwargs)


def build_stac_collection_assets_delete_request(  # pylint: disable=name-too-long
    collection_id: str, asset_id: str, **kwargs: Any
) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2025-04-30-preview"))
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/stac/collections/{collectionId}/assets/{assetId}"
    path_format_arguments = {
        "collectionId": _SERIALIZER.url("collection_id", collection_id, "str"),
        "assetId": _SERIALIZER.url("asset_id", asset_id, "str"),
    }

    _url: str = _url.format(**path_format_arguments)  # type: ignore

    # Construct parameters
    _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")

    # Construct headers
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="DELETE", url=_url, params=_params, headers=_headers, **kwargs)


def build_stac_collection_config_get_request(collection_id: str, **kwargs: Any) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2025-04-30-preview"))
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/stac/collections/{collectionId}/configurations"
    path_format_arguments = {
        "collectionId": _SERIALIZER.url("collection_id", collection_id, "str"),
    }

    _url: str = _url.format(**path_format_arguments)  # type: ignore

    # Construct parameters
    _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")

    # Construct headers
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="GET", url=_url, params=_params, headers=_headers, **kwargs)


def build_stac_collection_mosaics_get_all_request(  # pylint: disable=name-too-long
    collection_id: str, **kwargs: Any
) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2025-04-30-preview"))
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/stac/collections/{collectionId}/configurations/mosaics"
    path_format_arguments = {
        "collectionId": _SERIALIZER.url("collection_id", collection_id, "str"),
    }

    _url: str = _url.format(**path_format_arguments)  # type: ignore

    # Construct parameters
    _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")

    # Construct headers
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="GET", url=_url, params=_params, headers=_headers, **kwargs)


def build_stac_collection_mosaics_add_request(  # pylint: disable=name-too-long
    collection_id: str, **kwargs: Any
) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2025-04-30-preview"))
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/stac/collections/{collectionId}/configurations/mosaics"
    path_format_arguments = {
        "collectionId": _SERIALIZER.url("collection_id", collection_id, "str"),
    }

    _url: str = _url.format(**path_format_arguments)  # type: ignore

    # Construct parameters
    _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")

    # Construct headers
    if content_type is not None:
        _headers["Content-Type"] = _SERIALIZER.header("content_type", content_type, "str")
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="POST", url=_url, params=_params, headers=_headers, **kwargs)


def build_stac_collection_mosaics_get_request(  # pylint: disable=name-too-long
    collection_id: str, mosaic_id: str, **kwargs: Any
) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2025-04-30-preview"))
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/stac/collections/{collectionId}/configurations/mosaics/{mosaicId}"
    path_format_arguments = {
        "collectionId": _SERIALIZER.url("collection_id", collection_id, "str"),
        "mosaicId": _SERIALIZER.url("mosaic_id", mosaic_id, "str"),
    }

    _url: str = _url.format(**path_format_arguments)  # type: ignore

    # Construct parameters
    _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")

    # Construct headers
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="GET", url=_url, params=_params, headers=_headers, **kwargs)


def build_stac_collection_mosaics_create_or_replace_request(  # pylint: disable=name-too-long
    collection_id: str, mosaic_id: str, **kwargs: Any
) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2025-04-30-preview"))
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/stac/collections/{collectionId}/configurations/mosaics/{mosaicId}"
    path_format_arguments = {
        "collectionId": _SERIALIZER.url("collection_id", collection_id, "str"),
        "mosaicId": _SERIALIZER.url("mosaic_id", mosaic_id, "str"),
    }

    _url: str = _url.format(**path_format_arguments)  # type: ignore

    # Construct parameters
    _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")

    # Construct headers
    if content_type is not None:
        _headers["Content-Type"] = _SERIALIZER.header("content_type", content_type, "str")
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="PUT", url=_url, params=_params, headers=_headers, **kwargs)


def build_stac_collection_mosaics_delete_request(  # pylint: disable=name-too-long
    collection_id: str, mosaic_id: str, **kwargs: Any
) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2025-04-30-preview"))
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/stac/collections/{collectionId}/configurations/mosaics/{mosaicId}"
    path_format_arguments = {
        "collectionId": _SERIALIZER.url("collection_id", collection_id, "str"),
        "mosaicId": _SERIALIZER.url("mosaic_id", mosaic_id, "str"),
    }

    _url: str = _url.format(**path_format_arguments)  # type: ignore

    # Construct parameters
    _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")

    # Construct headers
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="DELETE", url=_url, params=_params, headers=_headers, **kwargs)


def build_stac_collection_partition_types_get_request(  # pylint: disable=name-too-long
    collection_id: str, **kwargs: Any
) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2025-04-30-preview"))
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/stac/collections/{collectionId}/configurations/partition-type"
    path_format_arguments = {
        "collectionId": _SERIALIZER.url("collection_id", collection_id, "str"),
    }

    _url: str = _url.format(**path_format_arguments)  # type: ignore

    # Construct parameters
    _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")

    # Construct headers
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="GET", url=_url, params=_params, headers=_headers, **kwargs)


def build_stac_collection_partition_types_replace_request(  # pylint: disable=name-too-long
    collection_id: str, **kwargs: Any
) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2025-04-30-preview"))
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/stac/collections/{collectionId}/configurations/partition-type"
    path_format_arguments = {
        "collectionId": _SERIALIZER.url("collection_id", collection_id, "str"),
    }

    _url: str = _url.format(**path_format_arguments)  # type: ignore

    # Construct parameters
    _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")

    # Construct headers
    if content_type is not None:
        _headers["Content-Type"] = _SERIALIZER.header("content_type", content_type, "str")
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="PUT", url=_url, params=_params, headers=_headers, **kwargs)


def build_stac_collection_render_options_get_all_request(  # pylint: disable=name-too-long
    collection_id: str, **kwargs: Any
) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2025-04-30-preview"))
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/stac/collections/{collectionId}/configurations/render-options"
    path_format_arguments = {
        "collectionId": _SERIALIZER.url("collection_id", collection_id, "str"),
    }

    _url: str = _url.format(**path_format_arguments)  # type: ignore

    # Construct parameters
    _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")

    # Construct headers
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="GET", url=_url, params=_params, headers=_headers, **kwargs)


def build_stac_collection_render_options_create_request(  # pylint: disable=name-too-long
    collection_id: str, **kwargs: Any
) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2025-04-30-preview"))
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/stac/collections/{collectionId}/configurations/render-options"
    path_format_arguments = {
        "collectionId": _SERIALIZER.url("collection_id", collection_id, "str"),
    }

    _url: str = _url.format(**path_format_arguments)  # type: ignore

    # Construct parameters
    _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")

    # Construct headers
    if content_type is not None:
        _headers["Content-Type"] = _SERIALIZER.header("content_type", content_type, "str")
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="POST", url=_url, params=_params, headers=_headers, **kwargs)


def build_stac_collection_render_options_get_request(  # pylint: disable=name-too-long
    collection_id: str, render_option_id: str, **kwargs: Any
) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2025-04-30-preview"))
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/stac/collections/{collectionId}/configurations/render-options/{renderOptionId}"
    path_format_arguments = {
        "collectionId": _SERIALIZER.url("collection_id", collection_id, "str"),
        "renderOptionId": _SERIALIZER.url("render_option_id", render_option_id, "str"),
    }

    _url: str = _url.format(**path_format_arguments)  # type: ignore

    # Construct parameters
    _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")

    # Construct headers
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="GET", url=_url, params=_params, headers=_headers, **kwargs)


def build_stac_collection_render_options_create_or_replace_request(  # pylint: disable=name-too-long
    collection_id: str, render_option_id: str, **kwargs: Any
) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2025-04-30-preview"))
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/stac/collections/{collectionId}/configurations/render-options/{renderOptionId}"
    path_format_arguments = {
        "collectionId": _SERIALIZER.url("collection_id", collection_id, "str"),
        "renderOptionId": _SERIALIZER.url("render_option_id", render_option_id, "str"),
    }

    _url: str = _url.format(**path_format_arguments)  # type: ignore

    # Construct parameters
    _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")

    # Construct headers
    if content_type is not None:
        _headers["Content-Type"] = _SERIALIZER.header("content_type", content_type, "str")
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="PUT", url=_url, params=_params, headers=_headers, **kwargs)


def build_stac_collection_render_options_delete_request(  # pylint: disable=name-too-long
    collection_id: str, render_option_id: str, **kwargs: Any
) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2025-04-30-preview"))
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/stac/collections/{collectionId}/configurations/render-options/{renderOptionId}"
    path_format_arguments = {
        "collectionId": _SERIALIZER.url("collection_id", collection_id, "str"),
        "renderOptionId": _SERIALIZER.url("render_option_id", render_option_id, "str"),
    }

    _url: str = _url.format(**path_format_arguments)  # type: ignore

    # Construct parameters
    _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")

    # Construct headers
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="DELETE", url=_url, params=_params, headers=_headers, **kwargs)


def build_stac_collection_tile_settings_get_all_request(  # pylint: disable=name-too-long
    collection_id: str, **kwargs: Any
) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2025-04-30-preview"))
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/stac/collections/{collectionId}/configurations/tile-settings"
    path_format_arguments = {
        "collectionId": _SERIALIZER.url("collection_id", collection_id, "str"),
    }

    _url: str = _url.format(**path_format_arguments)  # type: ignore

    # Construct parameters
    _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")

    # Construct headers
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="GET", url=_url, params=_params, headers=_headers, **kwargs)


def build_stac_collection_tile_settings_replace_request(  # pylint: disable=name-too-long
    collection_id: str, **kwargs: Any
) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2025-04-30-preview"))
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/stac/collections/{collectionId}/configurations/tile-settings"
    path_format_arguments = {
        "collectionId": _SERIALIZER.url("collection_id", collection_id, "str"),
    }

    _url: str = _url.format(**path_format_arguments)  # type: ignore

    # Construct parameters
    _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")

    # Construct headers
    if content_type is not None:
        _headers["Content-Type"] = _SERIALIZER.header("content_type", content_type, "str")
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="PUT", url=_url, params=_params, headers=_headers, **kwargs)


def build_stac_collection_thumbnails_get_request(  # pylint: disable=name-too-long
    collection_id: str, **kwargs: Any
) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2025-04-30-preview"))
    accept = _headers.pop("Accept", None)

    # Construct URL
    _url = "/stac/collections/{collectionId}/thumbnail"
    path_format_arguments = {
        "collectionId": _SERIALIZER.url("collection_id", collection_id, "str"),
    }

    _url: str = _url.format(**path_format_arguments)  # type: ignore

    # Construct parameters
    _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")

    # Construct headers
    if accept is not None:
        _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="GET", url=_url, params=_params, headers=_headers, **kwargs)


def build_geo_catalog_auth_config_operations_get_request(**kwargs: Any) -> HttpRequest:  # pylint: disable=name-too-long
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2025-04-30-preview"))
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/geocatalog/auth"

    # Construct parameters
    _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")

    # Construct headers
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="GET", url=_url, params=_params, headers=_headers, **kwargs)


def build_geo_catalog_azmaps_client_get_id_request(**kwargs: Any) -> HttpRequest:  # pylint: disable=name-too-long
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2025-04-30-preview"))
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/geocatalog/map/id"

    # Construct parameters
    _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")

    # Construct headers
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="GET", url=_url, params=_params, headers=_headers, **kwargs)


def build_geo_catalog_azmaps_token_get_request(**kwargs: Any) -> HttpRequest:  # pylint: disable=name-too-long
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2025-04-30-preview"))
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/geocatalog/map/token"

    # Construct parameters
    _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")

    # Construct headers
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="GET", url=_url, params=_params, headers=_headers, **kwargs)


def build_tiler_static_images_create_request(collection_id: str, **kwargs: Any) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2025-04-30-preview"))
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/data/collections/{collectionId}/image/static"
    path_format_arguments = {
        "collectionId": _SERIALIZER.url("collection_id", collection_id, "str"),
    }

    _url: str = _url.format(**path_format_arguments)  # type: ignore

    # Construct parameters
    _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")

    # Construct headers
    if content_type is not None:
        _headers["Content-Type"] = _SERIALIZER.header("content_type", content_type, "str")
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="POST", url=_url, params=_params, headers=_headers, **kwargs)


def build_tiler_static_images_get_request(collection_id: str, id: str, **kwargs: Any) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2025-04-30-preview"))
    accept = _headers.pop("Accept", "image/png")

    # Construct URL
    _url = "/data/collections/{collectionId}/image/static/{id}"
    path_format_arguments = {
        "collectionId": _SERIALIZER.url("collection_id", collection_id, "str"),
        "id": _SERIALIZER.url("id", id, "str"),
    }

    _url: str = _url.format(**path_format_arguments)  # type: ignore

    # Construct parameters
    _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")

    # Construct headers
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="GET", url=_url, params=_params, headers=_headers, **kwargs)


def build_tiler_bound_get_all_request(collection_id: str, item_id: str, **kwargs: Any) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2025-04-30-preview"))
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/data/collections/{collectionId}/items/{itemId}/bounds"
    path_format_arguments = {
        "collectionId": _SERIALIZER.url("collection_id", collection_id, "str"),
        "itemId": _SERIALIZER.url("item_id", item_id, "str"),
    }

    _url: str = _url.format(**path_format_arguments)  # type: ignore

    # Construct parameters
    _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")

    # Construct headers
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="GET", url=_url, params=_params, headers=_headers, **kwargs)


def build_tiler_info_operations_get_request(
    collection_id: str, item_id: str, *, assets: Optional[List[str]] = None, **kwargs: Any
) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2025-04-30-preview"))
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/data/collections/{collectionId}/items/{itemId}/info"
    path_format_arguments = {
        "collectionId": _SERIALIZER.url("collection_id", collection_id, "str"),
        "itemId": _SERIALIZER.url("item_id", item_id, "str"),
    }

    _url: str = _url.format(**path_format_arguments)  # type: ignore

    # Construct parameters
    _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")
    if assets is not None:
        _params["assets"] = [_SERIALIZER.query("assets", q, "str") if q is not None else "" for q in assets]

    # Construct headers
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="GET", url=_url, params=_params, headers=_headers, **kwargs)


def build_tiler_info_geo_json_operations_get_request(  # pylint: disable=name-too-long
    collection_id: str, item_id: str, *, assets: Optional[List[str]] = None, **kwargs: Any
) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2025-04-30-preview"))
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/data/collections/{collectionId}/items/{itemId}/info.geojson"
    path_format_arguments = {
        "collectionId": _SERIALIZER.url("collection_id", collection_id, "str"),
        "itemId": _SERIALIZER.url("item_id", item_id, "str"),
    }

    _url: str = _url.format(**path_format_arguments)  # type: ignore

    # Construct parameters
    _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")
    if assets is not None:
        _params["assets"] = [_SERIALIZER.query("assets", q, "str") if q is not None else "" for q in assets]

    # Construct headers
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="GET", url=_url, params=_params, headers=_headers, **kwargs)


def build_tiler_available_assets_get_all_request(  # pylint: disable=name-too-long
    collection_id: str, item_id: str, **kwargs: Any
) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2025-04-30-preview"))
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/data/collections/{collectionId}/items/{itemId}/assets"
    path_format_arguments = {
        "collectionId": _SERIALIZER.url("collection_id", collection_id, "str"),
        "itemId": _SERIALIZER.url("item_id", item_id, "str"),
    }

    _url: str = _url.format(**path_format_arguments)  # type: ignore

    # Construct parameters
    _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")

    # Construct headers
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="GET", url=_url, params=_params, headers=_headers, **kwargs)


def build_tiler_asset_statistics_get_all_request(  # pylint: disable=name-too-long
    collection_id: str,
    item_id: str,
    *,
    assets: Optional[List[str]] = None,
    expression: Optional[str] = None,
    asset_bidx: Optional[List[str]] = None,
    asset_as_band: Optional[bool] = None,
    nodata: Optional[float] = None,
    unscale: Optional[bool] = None,
    resampling: Optional[Union[str, _models.Resampling]] = None,
    max_size: Optional[int] = None,
    categorical: Optional[bool] = None,
    c: Optional[List[str]] = None,
    p: Optional[List[int]] = None,
    histogram_bins: Optional[str] = None,
    histogram_range: Optional[str] = None,
    **kwargs: Any,
) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2025-04-30-preview"))
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/data/collections/{collectionId}/items/{itemId}/asset_statistics"
    path_format_arguments = {
        "collectionId": _SERIALIZER.url("collection_id", collection_id, "str"),
        "itemId": _SERIALIZER.url("item_id", item_id, "str"),
    }

    _url: str = _url.format(**path_format_arguments)  # type: ignore

    # Construct parameters
    _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")
    if assets is not None:
        _params["assets"] = [_SERIALIZER.query("assets", q, "str") if q is not None else "" for q in assets]
    if expression is not None:
        _params["expression"] = _SERIALIZER.query("expression", expression, "str")
    if asset_bidx is not None:
        _params["asset_bidx"] = _SERIALIZER.query("asset_bidx", asset_bidx, "[str]", div=",")
    if asset_as_band is not None:
        _params["asset_as_band"] = _SERIALIZER.query("asset_as_band", asset_as_band, "bool")
    if nodata is not None:
        _params["nodata"] = _SERIALIZER.query("nodata", nodata, "float")
    if unscale is not None:
        _params["unscale"] = _SERIALIZER.query("unscale", unscale, "bool")
    if resampling is not None:
        _params["resampling"] = _SERIALIZER.query("resampling", resampling, "str")
    if max_size is not None:
        _params["max_size"] = _SERIALIZER.query("max_size", max_size, "int")
    if categorical is not None:
        _params["categorical"] = _SERIALIZER.query("categorical", categorical, "bool")
    if c is not None:
        _params["c"] = [_SERIALIZER.query("c", q, "str") if q is not None else "" for q in c]
    if p is not None:
        _params["p"] = [_SERIALIZER.query("p", q, "int") if q is not None else "" for q in p]
    if histogram_bins is not None:
        _params["histogram_bins"] = _SERIALIZER.query("histogram_bins", histogram_bins, "str")
    if histogram_range is not None:
        _params["histogram_range"] = _SERIALIZER.query("histogram_range", histogram_range, "str")

    # Construct headers
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="GET", url=_url, params=_params, headers=_headers, **kwargs)


def build_tiler_statistics_get_all_request(
    collection_id: str,
    item_id: str,
    *,
    assets: Optional[List[str]] = None,
    expression: Optional[str] = None,
    asset_bidx: Optional[List[str]] = None,
    asset_as_band: Optional[bool] = None,
    nodata: Optional[float] = None,
    unscale: Optional[bool] = None,
    resampling: Optional[Union[str, _models.Resampling]] = None,
    max_size: Optional[int] = None,
    categorical: Optional[bool] = None,
    c: Optional[List[str]] = None,
    p: Optional[List[int]] = None,
    histogram_bins: Optional[str] = None,
    histogram_range: Optional[str] = None,
    **kwargs: Any,
) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2025-04-30-preview"))
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/data/collections/{collectionId}/items/{itemId}/statistics"
    path_format_arguments = {
        "collectionId": _SERIALIZER.url("collection_id", collection_id, "str"),
        "itemId": _SERIALIZER.url("item_id", item_id, "str"),
    }

    _url: str = _url.format(**path_format_arguments)  # type: ignore

    # Construct parameters
    _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")
    if assets is not None:
        _params["assets"] = [_SERIALIZER.query("assets", q, "str") if q is not None else "" for q in assets]
    if expression is not None:
        _params["expression"] = _SERIALIZER.query("expression", expression, "str")
    if asset_bidx is not None:
        _params["asset_bidx"] = _SERIALIZER.query("asset_bidx", asset_bidx, "[str]", div=",")
    if asset_as_band is not None:
        _params["asset_as_band"] = _SERIALIZER.query("asset_as_band", asset_as_band, "bool")
    if nodata is not None:
        _params["nodata"] = _SERIALIZER.query("nodata", nodata, "float")
    if unscale is not None:
        _params["unscale"] = _SERIALIZER.query("unscale", unscale, "bool")
    if resampling is not None:
        _params["resampling"] = _SERIALIZER.query("resampling", resampling, "str")
    if max_size is not None:
        _params["max_size"] = _SERIALIZER.query("max_size", max_size, "int")
    if categorical is not None:
        _params["categorical"] = _SERIALIZER.query("categorical", categorical, "bool")
    if c is not None:
        _params["c"] = [_SERIALIZER.query("c", q, "str") if q is not None else "" for q in c]
    if p is not None:
        _params["p"] = [_SERIALIZER.query("p", q, "int") if q is not None else "" for q in p]
    if histogram_bins is not None:
        _params["histogram_bins"] = _SERIALIZER.query("histogram_bins", histogram_bins, "str")
    if histogram_range is not None:
        _params["histogram_range"] = _SERIALIZER.query("histogram_range", histogram_range, "str")

    # Construct headers
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="GET", url=_url, params=_params, headers=_headers, **kwargs)


def build_tiler_geo_json_statistics_get_all_request(  # pylint: disable=name-too-long
    collection_id: str,
    item_id: str,
    *,
    assets: Optional[List[str]] = None,
    expression: Optional[str] = None,
    asset_bidx: Optional[List[str]] = None,
    asset_as_band: Optional[bool] = None,
    nodata: Optional[float] = None,
    unscale: Optional[bool] = None,
    coord_crs: Optional[str] = None,
    resampling: Optional[Union[str, _models.Resampling]] = None,
    max_size: Optional[int] = None,
    categorical: Optional[bool] = None,
    c: Optional[List[str]] = None,
    p: Optional[List[int]] = None,
    histogram_bins: Optional[str] = None,
    histogram_range: Optional[str] = None,
    **kwargs: Any,
) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2025-04-30-preview"))
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/data/collections/{collectionId}/items/{itemId}/statistics"
    path_format_arguments = {
        "collectionId": _SERIALIZER.url("collection_id", collection_id, "str"),
        "itemId": _SERIALIZER.url("item_id", item_id, "str"),
    }

    _url: str = _url.format(**path_format_arguments)  # type: ignore

    # Construct parameters
    _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")
    if assets is not None:
        _params["assets"] = [_SERIALIZER.query("assets", q, "str") if q is not None else "" for q in assets]
    if expression is not None:
        _params["expression"] = _SERIALIZER.query("expression", expression, "str")
    if asset_bidx is not None:
        _params["asset_bidx"] = _SERIALIZER.query("asset_bidx", asset_bidx, "[str]", div=",")
    if asset_as_band is not None:
        _params["asset_as_band"] = _SERIALIZER.query("asset_as_band", asset_as_band, "bool")
    if nodata is not None:
        _params["nodata"] = _SERIALIZER.query("nodata", nodata, "float")
    if unscale is not None:
        _params["unscale"] = _SERIALIZER.query("unscale", unscale, "bool")
    if coord_crs is not None:
        _params["coord-crs"] = _SERIALIZER.query("coord_crs", coord_crs, "str")
    if resampling is not None:
        _params["resampling"] = _SERIALIZER.query("resampling", resampling, "str")
    if max_size is not None:
        _params["max_size"] = _SERIALIZER.query("max_size", max_size, "int")
    if categorical is not None:
        _params["categorical"] = _SERIALIZER.query("categorical", categorical, "bool")
    if c is not None:
        _params["c"] = [_SERIALIZER.query("c", q, "str") if q is not None else "" for q in c]
    if p is not None:
        _params["p"] = [_SERIALIZER.query("p", q, "int") if q is not None else "" for q in p]
    if histogram_bins is not None:
        _params["histogram_bins"] = _SERIALIZER.query("histogram_bins", histogram_bins, "str")
    if histogram_range is not None:
        _params["histogram_range"] = _SERIALIZER.query("histogram_range", histogram_range, "str")

    # Construct headers
    if content_type is not None:
        _headers["Content-Type"] = _SERIALIZER.header("content_type", content_type, "str")
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="POST", url=_url, params=_params, headers=_headers, **kwargs)


def build_tiler_tiles_get_zxy_scalex_format_request(  # pylint: disable=name-too-long
    collection_id: str,
    item_id: str,
    z: float,
    x: float,
    y: float,
    scale: float,
    format: str,
    *,
    assets: Optional[List[str]] = None,
    expression: Optional[str] = None,
    asset_bidx: Optional[List[str]] = None,
    asset_as_band: Optional[bool] = None,
    nodata: Optional[float] = None,
    unscale: Optional[bool] = None,
    algorithm: Optional[Union[str, _models.Algorithm]] = None,
    algorithm_params: Optional[str] = None,
    tile_matrix_set_id: Optional[Union[str, _models.Tilematrixsetid]] = None,
    buffer: Optional[str] = None,
    color_formula: Optional[str] = None,
    resampling: Optional[Union[str, _models.Resampling]] = None,
    rescale: Optional[List[str]] = None,
    colormap_name: Optional[Union[str, _models.ColorMapNames]] = None,
    colormap: Optional[str] = None,
    return_mask: Optional[bool] = None,
    subdataset_name: Optional[str] = None,
    subdataset_bands: Optional[List[str]] = None,
    **kwargs: Any,
) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2025-04-30-preview"))
    accept = _headers.pop("Accept", None)

    # Construct URL
    _url = "/data/collections/{collectionId}/items/{itemId}/tiles/{z}/{x}/{y}@{scale}x.{format}"
    path_format_arguments = {
        "collectionId": _SERIALIZER.url("collection_id", collection_id, "str"),
        "itemId": _SERIALIZER.url("item_id", item_id, "str"),
        "z": _SERIALIZER.url("z", z, "float"),
        "x": _SERIALIZER.url("x", x, "float"),
        "y": _SERIALIZER.url("y", y, "float"),
        "scale": _SERIALIZER.url("scale", scale, "float"),
        "format": _SERIALIZER.url("format", format, "str"),
    }

    _url: str = _url.format(**path_format_arguments)  # type: ignore

    # Construct parameters
    _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")
    if assets is not None:
        _params["assets"] = [_SERIALIZER.query("assets", q, "str") if q is not None else "" for q in assets]
    if expression is not None:
        _params["expression"] = _SERIALIZER.query("expression", expression, "str")
    if asset_bidx is not None:
        _params["asset_bidx"] = _SERIALIZER.query("asset_bidx", asset_bidx, "[str]", div=",")
    if asset_as_band is not None:
        _params["asset_as_band"] = _SERIALIZER.query("asset_as_band", asset_as_band, "bool")
    if nodata is not None:
        _params["nodata"] = _SERIALIZER.query("nodata", nodata, "float")
    if unscale is not None:
        _params["unscale"] = _SERIALIZER.query("unscale", unscale, "bool")
    if algorithm is not None:
        _params["algorithm"] = _SERIALIZER.query("algorithm", algorithm, "str")
    if algorithm_params is not None:
        _params["algorithm_params"] = _SERIALIZER.query("algorithm_params", algorithm_params, "str")
    if tile_matrix_set_id is not None:
        _params["tileMatrixSetId"] = _SERIALIZER.query("tile_matrix_set_id", tile_matrix_set_id, "str")
    if buffer is not None:
        _params["buffer"] = _SERIALIZER.query("buffer", buffer, "str")
    if color_formula is not None:
        _params["color_formula"] = _SERIALIZER.query("color_formula", color_formula, "str")
    if resampling is not None:
        _params["resampling"] = _SERIALIZER.query("resampling", resampling, "str")
    if rescale is not None:
        _params["rescale"] = [_SERIALIZER.query("rescale", q, "str") if q is not None else "" for q in rescale]
    if colormap_name is not None:
        _params["colormap_name"] = _SERIALIZER.query("colormap_name", colormap_name, "str")
    if colormap is not None:
        _params["colormap"] = _SERIALIZER.query("colormap", colormap, "str")
    if return_mask is not None:
        _params["return_mask"] = _SERIALIZER.query("return_mask", return_mask, "bool")
    if subdataset_name is not None:
        _params["subdataset_name"] = _SERIALIZER.query("subdataset_name", subdataset_name, "str")
    if subdataset_bands is not None:
        _params["subdataset_bands"] = _SERIALIZER.query("subdataset_bands", subdataset_bands, "[str]", div=",")

    # Construct headers
    if accept is not None:
        _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="GET", url=_url, params=_params, headers=_headers, **kwargs)


def build_tiler_tile_matrix_sets_get_zxy_scalex_format_request(  # pylint: disable=name-too-long
    collection_id: str,
    item_id: str,
    tile_matrix_set_id: str,
    z: float,
    x: float,
    y: float,
    scale: float,
    format: str,
    *,
    assets: Optional[List[str]] = None,
    expression: Optional[str] = None,
    asset_bidx: Optional[List[str]] = None,
    asset_as_band: Optional[bool] = None,
    nodata: Optional[float] = None,
    unscale: Optional[bool] = None,
    algorithm: Optional[Union[str, _models.Algorithm]] = None,
    algorithm_params: Optional[str] = None,
    buffer: Optional[str] = None,
    color_formula: Optional[str] = None,
    resampling: Optional[Union[str, _models.Resampling]] = None,
    rescale: Optional[List[str]] = None,
    colormap_name: Optional[Union[str, _models.ColorMapNames]] = None,
    colormap: Optional[str] = None,
    return_mask: Optional[bool] = None,
    subdataset_name: Optional[str] = None,
    subdataset_bands: Optional[List[str]] = None,
    **kwargs: Any,
) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2025-04-30-preview"))
    accept = _headers.pop("Accept", None)

    # Construct URL
    _url = "/data/collections/{collectionId}/items/{itemId}/tiles/{tileMatrixSetId}/{z}/{x}/{y}@{scale}x.{format}"
    path_format_arguments = {
        "collectionId": _SERIALIZER.url("collection_id", collection_id, "str"),
        "itemId": _SERIALIZER.url("item_id", item_id, "str"),
        "tileMatrixSetId": _SERIALIZER.url("tile_matrix_set_id", tile_matrix_set_id, "str"),
        "z": _SERIALIZER.url("z", z, "float"),
        "x": _SERIALIZER.url("x", x, "float"),
        "y": _SERIALIZER.url("y", y, "float"),
        "scale": _SERIALIZER.url("scale", scale, "float"),
        "format": _SERIALIZER.url("format", format, "str"),
    }

    _url: str = _url.format(**path_format_arguments)  # type: ignore

    # Construct parameters
    _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")
    if assets is not None:
        _params["assets"] = [_SERIALIZER.query("assets", q, "str") if q is not None else "" for q in assets]
    if expression is not None:
        _params["expression"] = _SERIALIZER.query("expression", expression, "str")
    if asset_bidx is not None:
        _params["asset_bidx"] = _SERIALIZER.query("asset_bidx", asset_bidx, "[str]", div=",")
    if asset_as_band is not None:
        _params["asset_as_band"] = _SERIALIZER.query("asset_as_band", asset_as_band, "bool")
    if nodata is not None:
        _params["nodata"] = _SERIALIZER.query("nodata", nodata, "float")
    if unscale is not None:
        _params["unscale"] = _SERIALIZER.query("unscale", unscale, "bool")
    if algorithm is not None:
        _params["algorithm"] = _SERIALIZER.query("algorithm", algorithm, "str")
    if algorithm_params is not None:
        _params["algorithm_params"] = _SERIALIZER.query("algorithm_params", algorithm_params, "str")
    if buffer is not None:
        _params["buffer"] = _SERIALIZER.query("buffer", buffer, "str")
    if color_formula is not None:
        _params["color_formula"] = _SERIALIZER.query("color_formula", color_formula, "str")
    if resampling is not None:
        _params["resampling"] = _SERIALIZER.query("resampling", resampling, "str")
    if rescale is not None:
        _params["rescale"] = [_SERIALIZER.query("rescale", q, "str") if q is not None else "" for q in rescale]
    if colormap_name is not None:
        _params["colormap_name"] = _SERIALIZER.query("colormap_name", colormap_name, "str")
    if colormap is not None:
        _params["colormap"] = _SERIALIZER.query("colormap", colormap, "str")
    if return_mask is not None:
        _params["return_mask"] = _SERIALIZER.query("return_mask", return_mask, "bool")
    if subdataset_name is not None:
        _params["subdataset_name"] = _SERIALIZER.query("subdataset_name", subdataset_name, "str")
    if subdataset_bands is not None:
        _params["subdataset_bands"] = _SERIALIZER.query("subdataset_bands", subdataset_bands, "[str]", div=",")

    # Construct headers
    if accept is not None:
        _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="GET", url=_url, params=_params, headers=_headers, **kwargs)


def build_tiler_tile_json_operations_get_request(  # pylint: disable=name-too-long
    collection_id: str,
    item_id: str,
    *,
    assets: Optional[List[str]] = None,
    expression: Optional[str] = None,
    asset_bidx: Optional[List[str]] = None,
    asset_as_band: Optional[bool] = None,
    nodata: Optional[float] = None,
    unscale: Optional[bool] = None,
    algorithm: Optional[Union[str, _models.Algorithm]] = None,
    algorithm_params: Optional[str] = None,
    tile_matrix_set_id: Optional[Union[str, _models.Tilematrixsetid]] = None,
    tile_format: Optional[Union[str, _models.ImageType]] = None,
    tile_scale: Optional[int] = None,
    minzoom: Optional[int] = None,
    maxzoom: Optional[int] = None,
    buffer: Optional[str] = None,
    color_formula: Optional[str] = None,
    resampling: Optional[Union[str, _models.Resampling]] = None,
    rescale: Optional[List[str]] = None,
    colormap_name: Optional[Union[str, _models.ColorMapNames]] = None,
    colormap: Optional[str] = None,
    return_mask: Optional[bool] = None,
    **kwargs: Any,
) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2025-04-30-preview"))
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/data/collections/{collectionId}/items/{itemId}/tilejson.json"
    path_format_arguments = {
        "collectionId": _SERIALIZER.url("collection_id", collection_id, "str"),
        "itemId": _SERIALIZER.url("item_id", item_id, "str"),
    }

    _url: str = _url.format(**path_format_arguments)  # type: ignore

    # Construct parameters
    _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")
    if assets is not None:
        _params["assets"] = [_SERIALIZER.query("assets", q, "str") if q is not None else "" for q in assets]
    if expression is not None:
        _params["expression"] = _SERIALIZER.query("expression", expression, "str")
    if asset_bidx is not None:
        _params["asset_bidx"] = _SERIALIZER.query("asset_bidx", asset_bidx, "[str]", div=",")
    if asset_as_band is not None:
        _params["asset_as_band"] = _SERIALIZER.query("asset_as_band", asset_as_band, "bool")
    if nodata is not None:
        _params["nodata"] = _SERIALIZER.query("nodata", nodata, "float")
    if unscale is not None:
        _params["unscale"] = _SERIALIZER.query("unscale", unscale, "bool")
    if algorithm is not None:
        _params["algorithm"] = _SERIALIZER.query("algorithm", algorithm, "str")
    if algorithm_params is not None:
        _params["algorithm_params"] = _SERIALIZER.query("algorithm_params", algorithm_params, "str")
    if tile_matrix_set_id is not None:
        _params["tileMatrixSetId"] = _SERIALIZER.query("tile_matrix_set_id", tile_matrix_set_id, "str")
    if tile_format is not None:
        _params["tile_format"] = _SERIALIZER.query("tile_format", tile_format, "str")
    if tile_scale is not None:
        _params["tile_scale"] = _SERIALIZER.query("tile_scale", tile_scale, "int")
    if minzoom is not None:
        _params["minzoom"] = _SERIALIZER.query("minzoom", minzoom, "int")
    if maxzoom is not None:
        _params["maxzoom"] = _SERIALIZER.query("maxzoom", maxzoom, "int")
    if buffer is not None:
        _params["buffer"] = _SERIALIZER.query("buffer", buffer, "str")
    if color_formula is not None:
        _params["color_formula"] = _SERIALIZER.query("color_formula", color_formula, "str")
    if resampling is not None:
        _params["resampling"] = _SERIALIZER.query("resampling", resampling, "str")
    if rescale is not None:
        _params["rescale"] = [_SERIALIZER.query("rescale", q, "str") if q is not None else "" for q in rescale]
    if colormap_name is not None:
        _params["colormap_name"] = _SERIALIZER.query("colormap_name", colormap_name, "str")
    if colormap is not None:
        _params["colormap"] = _SERIALIZER.query("colormap", colormap, "str")
    if return_mask is not None:
        _params["return_mask"] = _SERIALIZER.query("return_mask", return_mask, "bool")

    # Construct headers
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="GET", url=_url, params=_params, headers=_headers, **kwargs)


def build_tiler_tile_json_tile_matrix_sets_get_request(  # pylint: disable=name-too-long
    collection_id: str,
    item_id: str,
    tile_matrix_set_id: str,
    *,
    assets: Optional[List[str]] = None,
    expression: Optional[str] = None,
    asset_bidx: Optional[List[str]] = None,
    asset_as_band: Optional[bool] = None,
    nodata: Optional[float] = None,
    unscale: Optional[bool] = None,
    algorithm: Optional[Union[str, _models.Algorithm]] = None,
    algorithm_params: Optional[str] = None,
    tile_format: Optional[Union[str, _models.ImageType]] = None,
    tile_scale: Optional[int] = None,
    minzoom: Optional[int] = None,
    maxzoom: Optional[int] = None,
    buffer: Optional[str] = None,
    color_formula: Optional[str] = None,
    resampling: Optional[Union[str, _models.Resampling]] = None,
    rescale: Optional[List[str]] = None,
    colormap_name: Optional[Union[str, _models.ColorMapNames]] = None,
    colormap: Optional[str] = None,
    return_mask: Optional[bool] = None,
    **kwargs: Any,
) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2025-04-30-preview"))
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/data/collections/{collectionId}/items/{itemId}/{tileMatrixSetId}/tilejson.json"
    path_format_arguments = {
        "collectionId": _SERIALIZER.url("collection_id", collection_id, "str"),
        "itemId": _SERIALIZER.url("item_id", item_id, "str"),
        "tileMatrixSetId": _SERIALIZER.url("tile_matrix_set_id", tile_matrix_set_id, "str"),
    }

    _url: str = _url.format(**path_format_arguments)  # type: ignore

    # Construct parameters
    _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")
    if assets is not None:
        _params["assets"] = [_SERIALIZER.query("assets", q, "str") if q is not None else "" for q in assets]
    if expression is not None:
        _params["expression"] = _SERIALIZER.query("expression", expression, "str")
    if asset_bidx is not None:
        _params["asset_bidx"] = _SERIALIZER.query("asset_bidx", asset_bidx, "[str]", div=",")
    if asset_as_band is not None:
        _params["asset_as_band"] = _SERIALIZER.query("asset_as_band", asset_as_band, "bool")
    if nodata is not None:
        _params["nodata"] = _SERIALIZER.query("nodata", nodata, "float")
    if unscale is not None:
        _params["unscale"] = _SERIALIZER.query("unscale", unscale, "bool")
    if algorithm is not None:
        _params["algorithm"] = _SERIALIZER.query("algorithm", algorithm, "str")
    if algorithm_params is not None:
        _params["algorithm_params"] = _SERIALIZER.query("algorithm_params", algorithm_params, "str")
    if tile_format is not None:
        _params["tile_format"] = _SERIALIZER.query("tile_format", tile_format, "str")
    if tile_scale is not None:
        _params["tile_scale"] = _SERIALIZER.query("tile_scale", tile_scale, "int")
    if minzoom is not None:
        _params["minzoom"] = _SERIALIZER.query("minzoom", minzoom, "int")
    if maxzoom is not None:
        _params["maxzoom"] = _SERIALIZER.query("maxzoom", maxzoom, "int")
    if buffer is not None:
        _params["buffer"] = _SERIALIZER.query("buffer", buffer, "str")
    if color_formula is not None:
        _params["color_formula"] = _SERIALIZER.query("color_formula", color_formula, "str")
    if resampling is not None:
        _params["resampling"] = _SERIALIZER.query("resampling", resampling, "str")
    if rescale is not None:
        _params["rescale"] = [_SERIALIZER.query("rescale", q, "str") if q is not None else "" for q in rescale]
    if colormap_name is not None:
        _params["colormap_name"] = _SERIALIZER.query("colormap_name", colormap_name, "str")
    if colormap is not None:
        _params["colormap"] = _SERIALIZER.query("colormap", colormap, "str")
    if return_mask is not None:
        _params["return_mask"] = _SERIALIZER.query("return_mask", return_mask, "bool")

    # Construct headers
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="GET", url=_url, params=_params, headers=_headers, **kwargs)


def build_tiler_wmts_get_capabilities_xml_request(  # pylint: disable=name-too-long
    collection_id: str,
    item_id: str,
    *,
    assets: Optional[List[str]] = None,
    expression: Optional[str] = None,
    asset_bidx: Optional[List[str]] = None,
    asset_as_band: Optional[bool] = None,
    nodata: Optional[float] = None,
    unscale: Optional[bool] = None,
    algorithm: Optional[Union[str, _models.Algorithm]] = None,
    algorithm_params: Optional[str] = None,
    tile_matrix_set_id: Optional[Union[str, _models.Tilematrixsetid]] = None,
    tile_format: Optional[Union[str, _models.ImageType]] = None,
    tile_scale: Optional[int] = None,
    minzoom: Optional[int] = None,
    maxzoom: Optional[int] = None,
    buffer: Optional[str] = None,
    color_formula: Optional[str] = None,
    resampling: Optional[Union[str, _models.Resampling]] = None,
    rescale: Optional[List[str]] = None,
    colormap_name: Optional[Union[str, _models.ColorMapNames]] = None,
    colormap: Optional[str] = None,
    return_mask: Optional[bool] = None,
    **kwargs: Any,
) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2025-04-30-preview"))
    accept = _headers.pop("Accept", "application/xml")

    # Construct URL
    _url = "/data/collections/{collectionId}/items/{itemId}/WMTSCapabilities.xml"
    path_format_arguments = {
        "collectionId": _SERIALIZER.url("collection_id", collection_id, "str"),
        "itemId": _SERIALIZER.url("item_id", item_id, "str"),
    }

    _url: str = _url.format(**path_format_arguments)  # type: ignore

    # Construct parameters
    _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")
    if assets is not None:
        _params["assets"] = [_SERIALIZER.query("assets", q, "str") if q is not None else "" for q in assets]
    if expression is not None:
        _params["expression"] = _SERIALIZER.query("expression", expression, "str")
    if asset_bidx is not None:
        _params["asset_bidx"] = _SERIALIZER.query("asset_bidx", asset_bidx, "[str]", div=",")
    if asset_as_band is not None:
        _params["asset_as_band"] = _SERIALIZER.query("asset_as_band", asset_as_band, "bool")
    if nodata is not None:
        _params["nodata"] = _SERIALIZER.query("nodata", nodata, "float")
    if unscale is not None:
        _params["unscale"] = _SERIALIZER.query("unscale", unscale, "bool")
    if algorithm is not None:
        _params["algorithm"] = _SERIALIZER.query("algorithm", algorithm, "str")
    if algorithm_params is not None:
        _params["algorithm_params"] = _SERIALIZER.query("algorithm_params", algorithm_params, "str")
    if tile_matrix_set_id is not None:
        _params["tileMatrixSetId"] = _SERIALIZER.query("tile_matrix_set_id", tile_matrix_set_id, "str")
    if tile_format is not None:
        _params["tile_format"] = _SERIALIZER.query("tile_format", tile_format, "str")
    if tile_scale is not None:
        _params["tile_scale"] = _SERIALIZER.query("tile_scale", tile_scale, "int")
    if minzoom is not None:
        _params["minzoom"] = _SERIALIZER.query("minzoom", minzoom, "int")
    if maxzoom is not None:
        _params["maxzoom"] = _SERIALIZER.query("maxzoom", maxzoom, "int")
    if buffer is not None:
        _params["buffer"] = _SERIALIZER.query("buffer", buffer, "str")
    if color_formula is not None:
        _params["color_formula"] = _SERIALIZER.query("color_formula", color_formula, "str")
    if resampling is not None:
        _params["resampling"] = _SERIALIZER.query("resampling", resampling, "str")
    if rescale is not None:
        _params["rescale"] = [_SERIALIZER.query("rescale", q, "str") if q is not None else "" for q in rescale]
    if colormap_name is not None:
        _params["colormap_name"] = _SERIALIZER.query("colormap_name", colormap_name, "str")
    if colormap is not None:
        _params["colormap"] = _SERIALIZER.query("colormap", colormap, "str")
    if return_mask is not None:
        _params["return_mask"] = _SERIALIZER.query("return_mask", return_mask, "bool")

    # Construct headers
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="GET", url=_url, params=_params, headers=_headers, **kwargs)


def build_tiler_wmts_tile_matrix_sets_get_capabilities_xml_request(  # pylint: disable=name-too-long
    collection_id: str,
    item_id: str,
    tile_matrix_set_id: str,
    *,
    assets: Optional[List[str]] = None,
    expression: Optional[str] = None,
    asset_bidx: Optional[List[str]] = None,
    asset_as_band: Optional[bool] = None,
    nodata: Optional[float] = None,
    unscale: Optional[bool] = None,
    algorithm: Optional[Union[str, _models.Algorithm]] = None,
    algorithm_params: Optional[str] = None,
    tile_format: Optional[Union[str, _models.ImageType]] = None,
    tile_scale: Optional[int] = None,
    minzoom: Optional[int] = None,
    maxzoom: Optional[int] = None,
    buffer: Optional[str] = None,
    color_formula: Optional[str] = None,
    resampling: Optional[Union[str, _models.Resampling]] = None,
    rescale: Optional[List[str]] = None,
    colormap_name: Optional[Union[str, _models.ColorMapNames]] = None,
    colormap: Optional[str] = None,
    return_mask: Optional[bool] = None,
    **kwargs: Any,
) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2025-04-30-preview"))
    accept = _headers.pop("Accept", "application/xml")

    # Construct URL
    _url = "/data/collections/{collectionId}/items/{itemId}/{tileMatrixSetId}/WMTSCapabilities.xml"
    path_format_arguments = {
        "collectionId": _SERIALIZER.url("collection_id", collection_id, "str"),
        "itemId": _SERIALIZER.url("item_id", item_id, "str"),
        "tileMatrixSetId": _SERIALIZER.url("tile_matrix_set_id", tile_matrix_set_id, "str"),
    }

    _url: str = _url.format(**path_format_arguments)  # type: ignore

    # Construct parameters
    _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")
    if assets is not None:
        _params["assets"] = [_SERIALIZER.query("assets", q, "str") if q is not None else "" for q in assets]
    if expression is not None:
        _params["expression"] = _SERIALIZER.query("expression", expression, "str")
    if asset_bidx is not None:
        _params["asset_bidx"] = _SERIALIZER.query("asset_bidx", asset_bidx, "[str]", div=",")
    if asset_as_band is not None:
        _params["asset_as_band"] = _SERIALIZER.query("asset_as_band", asset_as_band, "bool")
    if nodata is not None:
        _params["nodata"] = _SERIALIZER.query("nodata", nodata, "float")
    if unscale is not None:
        _params["unscale"] = _SERIALIZER.query("unscale", unscale, "bool")
    if algorithm is not None:
        _params["algorithm"] = _SERIALIZER.query("algorithm", algorithm, "str")
    if algorithm_params is not None:
        _params["algorithm_params"] = _SERIALIZER.query("algorithm_params", algorithm_params, "str")
    if tile_format is not None:
        _params["tile_format"] = _SERIALIZER.query("tile_format", tile_format, "str")
    if tile_scale is not None:
        _params["tile_scale"] = _SERIALIZER.query("tile_scale", tile_scale, "int")
    if minzoom is not None:
        _params["minzoom"] = _SERIALIZER.query("minzoom", minzoom, "int")
    if maxzoom is not None:
        _params["maxzoom"] = _SERIALIZER.query("maxzoom", maxzoom, "int")
    if buffer is not None:
        _params["buffer"] = _SERIALIZER.query("buffer", buffer, "str")
    if color_formula is not None:
        _params["color_formula"] = _SERIALIZER.query("color_formula", color_formula, "str")
    if resampling is not None:
        _params["resampling"] = _SERIALIZER.query("resampling", resampling, "str")
    if rescale is not None:
        _params["rescale"] = [_SERIALIZER.query("rescale", q, "str") if q is not None else "" for q in rescale]
    if colormap_name is not None:
        _params["colormap_name"] = _SERIALIZER.query("colormap_name", colormap_name, "str")
    if colormap is not None:
        _params["colormap"] = _SERIALIZER.query("colormap", colormap, "str")
    if return_mask is not None:
        _params["return_mask"] = _SERIALIZER.query("return_mask", return_mask, "bool")

    # Construct headers
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="GET", url=_url, params=_params, headers=_headers, **kwargs)


def build_tiler_points_get_lon_lat_request(
    collection_id: str,
    item_id: str,
    lon: float,
    lat: float,
    *,
    assets: Optional[List[str]] = None,
    expression: Optional[str] = None,
    asset_bidx: Optional[List[str]] = None,
    asset_as_band: Optional[bool] = None,
    nodata: Optional[float] = None,
    unscale: Optional[bool] = None,
    coord_crs: Optional[str] = None,
    resampling: Optional[Union[str, _models.Resampling]] = None,
    **kwargs: Any,
) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2025-04-30-preview"))
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/data/collections/{collectionId}/items/{itemId}/point/{lon},{lat}"
    path_format_arguments = {
        "collectionId": _SERIALIZER.url("collection_id", collection_id, "str"),
        "itemId": _SERIALIZER.url("item_id", item_id, "str"),
        "lon": _SERIALIZER.url("lon", lon, "float"),
        "lat": _SERIALIZER.url("lat", lat, "float"),
    }

    _url: str = _url.format(**path_format_arguments)  # type: ignore

    # Construct parameters
    _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")
    if assets is not None:
        _params["assets"] = [_SERIALIZER.query("assets", q, "str") if q is not None else "" for q in assets]
    if expression is not None:
        _params["expression"] = _SERIALIZER.query("expression", expression, "str")
    if asset_bidx is not None:
        _params["asset_bidx"] = _SERIALIZER.query("asset_bidx", asset_bidx, "[str]", div=",")
    if asset_as_band is not None:
        _params["asset_as_band"] = _SERIALIZER.query("asset_as_band", asset_as_band, "bool")
    if nodata is not None:
        _params["nodata"] = _SERIALIZER.query("nodata", nodata, "float")
    if unscale is not None:
        _params["unscale"] = _SERIALIZER.query("unscale", unscale, "bool")
    if coord_crs is not None:
        _params["coord-crs"] = _SERIALIZER.query("coord_crs", coord_crs, "str")
    if resampling is not None:
        _params["resampling"] = _SERIALIZER.query("resampling", resampling, "str")

    # Construct headers
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="GET", url=_url, params=_params, headers=_headers, **kwargs)


def build_tiler_previews_get_format_request(
    collection_id: str,
    item_id: str,
    format: str,
    *,
    assets: Optional[List[str]] = None,
    expression: Optional[str] = None,
    asset_bidx: Optional[List[str]] = None,
    asset_as_band: Optional[bool] = None,
    nodata: Optional[float] = None,
    unscale: Optional[bool] = None,
    algorithm: Optional[Union[str, _models.Algorithm]] = None,
    algorithm_params: Optional[str] = None,
    color_formula: Optional[str] = None,
    dst_crs: Optional[str] = None,
    resampling: Optional[Union[str, _models.Resampling]] = None,
    max_size: Optional[int] = None,
    height: Optional[int] = None,
    width: Optional[int] = None,
    rescale: Optional[List[str]] = None,
    colormap_name: Optional[Union[str, _models.ColorMapNames]] = None,
    colormap: Optional[str] = None,
    return_mask: Optional[bool] = None,
    **kwargs: Any,
) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2025-04-30-preview"))
    accept = _headers.pop("Accept", None)

    # Construct URL
    _url = "/data/collections/{collectionId}/items/{itemId}/preview.{format}"
    path_format_arguments = {
        "collectionId": _SERIALIZER.url("collection_id", collection_id, "str"),
        "itemId": _SERIALIZER.url("item_id", item_id, "str"),
        "format": _SERIALIZER.url("format", format, "str"),
    }

    _url: str = _url.format(**path_format_arguments)  # type: ignore

    # Construct parameters
    _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")
    if assets is not None:
        _params["assets"] = [_SERIALIZER.query("assets", q, "str") if q is not None else "" for q in assets]
    if expression is not None:
        _params["expression"] = _SERIALIZER.query("expression", expression, "str")
    if asset_bidx is not None:
        _params["asset_bidx"] = _SERIALIZER.query("asset_bidx", asset_bidx, "[str]", div=",")
    if asset_as_band is not None:
        _params["asset_as_band"] = _SERIALIZER.query("asset_as_band", asset_as_band, "bool")
    if nodata is not None:
        _params["nodata"] = _SERIALIZER.query("nodata", nodata, "float")
    if unscale is not None:
        _params["unscale"] = _SERIALIZER.query("unscale", unscale, "bool")
    if algorithm is not None:
        _params["algorithm"] = _SERIALIZER.query("algorithm", algorithm, "str")
    if algorithm_params is not None:
        _params["algorithm_params"] = _SERIALIZER.query("algorithm_params", algorithm_params, "str")
    if color_formula is not None:
        _params["color_formula"] = _SERIALIZER.query("color_formula", color_formula, "str")
    if dst_crs is not None:
        _params["dst-crs"] = _SERIALIZER.query("dst_crs", dst_crs, "str")
    if resampling is not None:
        _params["resampling"] = _SERIALIZER.query("resampling", resampling, "str")
    if max_size is not None:
        _params["max_size"] = _SERIALIZER.query("max_size", max_size, "int")
    if height is not None:
        _params["height"] = _SERIALIZER.query("height", height, "int")
    if width is not None:
        _params["width"] = _SERIALIZER.query("width", width, "int")
    if rescale is not None:
        _params["rescale"] = [_SERIALIZER.query("rescale", q, "str") if q is not None else "" for q in rescale]
    if colormap_name is not None:
        _params["colormap_name"] = _SERIALIZER.query("colormap_name", colormap_name, "str")
    if colormap is not None:
        _params["colormap"] = _SERIALIZER.query("colormap", colormap, "str")
    if return_mask is not None:
        _params["return_mask"] = _SERIALIZER.query("return_mask", return_mask, "bool")

    # Construct headers
    if accept is not None:
        _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="GET", url=_url, params=_params, headers=_headers, **kwargs)


def build_tiler_previews_get_request(
    collection_id: str,
    item_id: str,
    *,
    assets: Optional[List[str]] = None,
    expression: Optional[str] = None,
    asset_bidx: Optional[List[str]] = None,
    asset_as_band: Optional[bool] = None,
    nodata: Optional[float] = None,
    unscale: Optional[bool] = None,
    algorithm: Optional[Union[str, _models.Algorithm]] = None,
    algorithm_params: Optional[str] = None,
    format: Optional[Union[str, _models.ImageType]] = None,
    color_formula: Optional[str] = None,
    dst_crs: Optional[str] = None,
    resampling: Optional[Union[str, _models.Resampling]] = None,
    max_size: Optional[int] = None,
    height: Optional[int] = None,
    width: Optional[int] = None,
    rescale: Optional[List[str]] = None,
    colormap_name: Optional[Union[str, _models.ColorMapNames]] = None,
    colormap: Optional[str] = None,
    return_mask: Optional[bool] = None,
    **kwargs: Any,
) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2025-04-30-preview"))
    accept = _headers.pop("Accept", None)

    # Construct URL
    _url = "/data/collections/{collectionId}/items/{itemId}/preview"
    path_format_arguments = {
        "collectionId": _SERIALIZER.url("collection_id", collection_id, "str"),
        "itemId": _SERIALIZER.url("item_id", item_id, "str"),
    }

    _url: str = _url.format(**path_format_arguments)  # type: ignore

    # Construct parameters
    _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")
    if assets is not None:
        _params["assets"] = [_SERIALIZER.query("assets", q, "str") if q is not None else "" for q in assets]
    if expression is not None:
        _params["expression"] = _SERIALIZER.query("expression", expression, "str")
    if asset_bidx is not None:
        _params["asset_bidx"] = _SERIALIZER.query("asset_bidx", asset_bidx, "[str]", div=",")
    if asset_as_band is not None:
        _params["asset_as_band"] = _SERIALIZER.query("asset_as_band", asset_as_band, "bool")
    if nodata is not None:
        _params["nodata"] = _SERIALIZER.query("nodata", nodata, "float")
    if unscale is not None:
        _params["unscale"] = _SERIALIZER.query("unscale", unscale, "bool")
    if algorithm is not None:
        _params["algorithm"] = _SERIALIZER.query("algorithm", algorithm, "str")
    if algorithm_params is not None:
        _params["algorithm_params"] = _SERIALIZER.query("algorithm_params", algorithm_params, "str")
    if format is not None:
        _params["format"] = _SERIALIZER.query("format", format, "str")
    if color_formula is not None:
        _params["color_formula"] = _SERIALIZER.query("color_formula", color_formula, "str")
    if dst_crs is not None:
        _params["dst-crs"] = _SERIALIZER.query("dst_crs", dst_crs, "str")
    if resampling is not None:
        _params["resampling"] = _SERIALIZER.query("resampling", resampling, "str")
    if max_size is not None:
        _params["max_size"] = _SERIALIZER.query("max_size", max_size, "int")
    if height is not None:
        _params["height"] = _SERIALIZER.query("height", height, "int")
    if width is not None:
        _params["width"] = _SERIALIZER.query("width", width, "int")
    if rescale is not None:
        _params["rescale"] = [_SERIALIZER.query("rescale", q, "str") if q is not None else "" for q in rescale]
    if colormap_name is not None:
        _params["colormap_name"] = _SERIALIZER.query("colormap_name", colormap_name, "str")
    if colormap is not None:
        _params["colormap"] = _SERIALIZER.query("colormap", colormap, "str")
    if return_mask is not None:
        _params["return_mask"] = _SERIALIZER.query("return_mask", return_mask, "bool")

    # Construct headers
    if accept is not None:
        _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="GET", url=_url, params=_params, headers=_headers, **kwargs)


def build_tiler_parts_get_minx_miny_maxx_maxy_widthx_height_format_request(  # pylint: disable=name-too-long
    collection_id: str,
    item_id: str,
    minx: float,
    miny: float,
    maxx: float,
    maxy: float,
    width: float,
    height: float,
    format: str,
    *,
    assets: Optional[List[str]] = None,
    expression: Optional[str] = None,
    asset_bidx: Optional[List[str]] = None,
    asset_as_band: Optional[bool] = None,
    nodata: Optional[float] = None,
    unscale: Optional[bool] = None,
    algorithm: Optional[Union[str, _models.Algorithm]] = None,
    algorithm_params: Optional[str] = None,
    color_formula: Optional[str] = None,
    dst_crs: Optional[str] = None,
    coord_crs: Optional[str] = None,
    resampling: Optional[Union[str, _models.Resampling]] = None,
    max_size: Optional[int] = None,
    rescale: Optional[List[str]] = None,
    colormap_name: Optional[Union[str, _models.ColorMapNames]] = None,
    colormap: Optional[str] = None,
    return_mask: Optional[bool] = None,
    **kwargs: Any,
) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2025-04-30-preview"))
    accept = _headers.pop("Accept", None)

    # Construct URL
    _url = "/data/collections/{collectionId}/items/{itemId}/crop/{minx},{miny},{maxx},{maxy}/{width}x{height}.{format}"
    path_format_arguments = {
        "collectionId": _SERIALIZER.url("collection_id", collection_id, "str"),
        "itemId": _SERIALIZER.url("item_id", item_id, "str"),
        "minx": _SERIALIZER.url("minx", minx, "float"),
        "miny": _SERIALIZER.url("miny", miny, "float"),
        "maxx": _SERIALIZER.url("maxx", maxx, "float"),
        "maxy": _SERIALIZER.url("maxy", maxy, "float"),
        "width": _SERIALIZER.url("width", width, "float"),
        "height": _SERIALIZER.url("height", height, "float"),
        "format": _SERIALIZER.url("format", format, "str"),
    }

    _url: str = _url.format(**path_format_arguments)  # type: ignore

    # Construct parameters
    _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")
    if assets is not None:
        _params["assets"] = [_SERIALIZER.query("assets", q, "str") if q is not None else "" for q in assets]
    if expression is not None:
        _params["expression"] = _SERIALIZER.query("expression", expression, "str")
    if asset_bidx is not None:
        _params["asset_bidx"] = _SERIALIZER.query("asset_bidx", asset_bidx, "[str]", div=",")
    if asset_as_band is not None:
        _params["asset_as_band"] = _SERIALIZER.query("asset_as_band", asset_as_band, "bool")
    if nodata is not None:
        _params["nodata"] = _SERIALIZER.query("nodata", nodata, "float")
    if unscale is not None:
        _params["unscale"] = _SERIALIZER.query("unscale", unscale, "bool")
    if algorithm is not None:
        _params["algorithm"] = _SERIALIZER.query("algorithm", algorithm, "str")
    if algorithm_params is not None:
        _params["algorithm_params"] = _SERIALIZER.query("algorithm_params", algorithm_params, "str")
    if color_formula is not None:
        _params["color_formula"] = _SERIALIZER.query("color_formula", color_formula, "str")
    if dst_crs is not None:
        _params["dst-crs"] = _SERIALIZER.query("dst_crs", dst_crs, "str")
    if coord_crs is not None:
        _params["coord-crs"] = _SERIALIZER.query("coord_crs", coord_crs, "str")
    if resampling is not None:
        _params["resampling"] = _SERIALIZER.query("resampling", resampling, "str")
    if max_size is not None:
        _params["max_size"] = _SERIALIZER.query("max_size", max_size, "int")
    if rescale is not None:
        _params["rescale"] = [_SERIALIZER.query("rescale", q, "str") if q is not None else "" for q in rescale]
    if colormap_name is not None:
        _params["colormap_name"] = _SERIALIZER.query("colormap_name", colormap_name, "str")
    if colormap is not None:
        _params["colormap"] = _SERIALIZER.query("colormap", colormap, "str")
    if return_mask is not None:
        _params["return_mask"] = _SERIALIZER.query("return_mask", return_mask, "bool")

    # Construct headers
    if accept is not None:
        _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="GET", url=_url, params=_params, headers=_headers, **kwargs)


def build_tiler_parts_get_minx_miny_maxx_maxy_format_request(  # pylint: disable=name-too-long
    collection_id: str,
    item_id: str,
    minx: float,
    miny: float,
    maxx: float,
    maxy: float,
    format: str,
    *,
    assets: Optional[List[str]] = None,
    expression: Optional[str] = None,
    asset_bidx: Optional[List[str]] = None,
    asset_as_band: Optional[bool] = None,
    nodata: Optional[float] = None,
    unscale: Optional[bool] = None,
    algorithm: Optional[Union[str, _models.Algorithm]] = None,
    algorithm_params: Optional[str] = None,
    color_formula: Optional[str] = None,
    dst_crs: Optional[str] = None,
    coord_crs: Optional[str] = None,
    resampling: Optional[Union[str, _models.Resampling]] = None,
    max_size: Optional[int] = None,
    height: Optional[int] = None,
    width: Optional[int] = None,
    rescale: Optional[List[str]] = None,
    colormap_name: Optional[Union[str, _models.ColorMapNames]] = None,
    colormap: Optional[str] = None,
    return_mask: Optional[bool] = None,
    **kwargs: Any,
) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2025-04-30-preview"))
    accept = _headers.pop("Accept", None)

    # Construct URL
    _url = "/data/collections/{collectionId}/items/{itemId}/crop/{minx},{miny},{maxx},{maxy}.{format}"
    path_format_arguments = {
        "collectionId": _SERIALIZER.url("collection_id", collection_id, "str"),
        "itemId": _SERIALIZER.url("item_id", item_id, "str"),
        "minx": _SERIALIZER.url("minx", minx, "float"),
        "miny": _SERIALIZER.url("miny", miny, "float"),
        "maxx": _SERIALIZER.url("maxx", maxx, "float"),
        "maxy": _SERIALIZER.url("maxy", maxy, "float"),
        "format": _SERIALIZER.url("format", format, "str"),
    }

    _url: str = _url.format(**path_format_arguments)  # type: ignore

    # Construct parameters
    _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")
    if assets is not None:
        _params["assets"] = [_SERIALIZER.query("assets", q, "str") if q is not None else "" for q in assets]
    if expression is not None:
        _params["expression"] = _SERIALIZER.query("expression", expression, "str")
    if asset_bidx is not None:
        _params["asset_bidx"] = _SERIALIZER.query("asset_bidx", asset_bidx, "[str]", div=",")
    if asset_as_band is not None:
        _params["asset_as_band"] = _SERIALIZER.query("asset_as_band", asset_as_band, "bool")
    if nodata is not None:
        _params["nodata"] = _SERIALIZER.query("nodata", nodata, "float")
    if unscale is not None:
        _params["unscale"] = _SERIALIZER.query("unscale", unscale, "bool")
    if algorithm is not None:
        _params["algorithm"] = _SERIALIZER.query("algorithm", algorithm, "str")
    if algorithm_params is not None:
        _params["algorithm_params"] = _SERIALIZER.query("algorithm_params", algorithm_params, "str")
    if color_formula is not None:
        _params["color_formula"] = _SERIALIZER.query("color_formula", color_formula, "str")
    if dst_crs is not None:
        _params["dst-crs"] = _SERIALIZER.query("dst_crs", dst_crs, "str")
    if coord_crs is not None:
        _params["coord-crs"] = _SERIALIZER.query("coord_crs", coord_crs, "str")
    if resampling is not None:
        _params["resampling"] = _SERIALIZER.query("resampling", resampling, "str")
    if max_size is not None:
        _params["max_size"] = _SERIALIZER.query("max_size", max_size, "int")
    if height is not None:
        _params["height"] = _SERIALIZER.query("height", height, "int")
    if width is not None:
        _params["width"] = _SERIALIZER.query("width", width, "int")
    if rescale is not None:
        _params["rescale"] = [_SERIALIZER.query("rescale", q, "str") if q is not None else "" for q in rescale]
    if colormap_name is not None:
        _params["colormap_name"] = _SERIALIZER.query("colormap_name", colormap_name, "str")
    if colormap is not None:
        _params["colormap"] = _SERIALIZER.query("colormap", colormap, "str")
    if return_mask is not None:
        _params["return_mask"] = _SERIALIZER.query("return_mask", return_mask, "bool")

    # Construct headers
    if accept is not None:
        _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="GET", url=_url, params=_params, headers=_headers, **kwargs)


def build_tiler_geo_jsons_crop_widthx_height_format_request(  # pylint: disable=name-too-long
    collection_id: str,
    item_id: str,
    width: float,
    height: float,
    format: str,
    *,
    assets: Optional[List[str]] = None,
    expression: Optional[str] = None,
    asset_bidx: Optional[List[str]] = None,
    asset_as_band: Optional[bool] = None,
    nodata: Optional[float] = None,
    unscale: Optional[bool] = None,
    algorithm: Optional[Union[str, _models.Algorithm]] = None,
    algorithm_params: Optional[str] = None,
    color_formula: Optional[str] = None,
    coord_crs: Optional[str] = None,
    resampling: Optional[Union[str, _models.Resampling]] = None,
    max_size: Optional[int] = None,
    rescale: Optional[List[str]] = None,
    colormap_name: Optional[Union[str, _models.ColorMapNames]] = None,
    colormap: Optional[str] = None,
    return_mask: Optional[bool] = None,
    **kwargs: Any,
) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2025-04-30-preview"))
    accept = _headers.pop("Accept", None)

    # Construct URL
    _url = "/data/collections/{collectionId}/items/{itemId}/crop/{width}x{height}.{format}"
    path_format_arguments = {
        "collectionId": _SERIALIZER.url("collection_id", collection_id, "str"),
        "itemId": _SERIALIZER.url("item_id", item_id, "str"),
        "width": _SERIALIZER.url("width", width, "float"),
        "height": _SERIALIZER.url("height", height, "float"),
        "format": _SERIALIZER.url("format", format, "str"),
    }

    _url: str = _url.format(**path_format_arguments)  # type: ignore

    # Construct parameters
    _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")
    if assets is not None:
        _params["assets"] = [_SERIALIZER.query("assets", q, "str") if q is not None else "" for q in assets]
    if expression is not None:
        _params["expression"] = _SERIALIZER.query("expression", expression, "str")
    if asset_bidx is not None:
        _params["asset_bidx"] = _SERIALIZER.query("asset_bidx", asset_bidx, "[str]", div=",")
    if asset_as_band is not None:
        _params["asset_as_band"] = _SERIALIZER.query("asset_as_band", asset_as_band, "bool")
    if nodata is not None:
        _params["nodata"] = _SERIALIZER.query("nodata", nodata, "float")
    if unscale is not None:
        _params["unscale"] = _SERIALIZER.query("unscale", unscale, "bool")
    if algorithm is not None:
        _params["algorithm"] = _SERIALIZER.query("algorithm", algorithm, "str")
    if algorithm_params is not None:
        _params["algorithm_params"] = _SERIALIZER.query("algorithm_params", algorithm_params, "str")
    if color_formula is not None:
        _params["color_formula"] = _SERIALIZER.query("color_formula", color_formula, "str")
    if coord_crs is not None:
        _params["coord-crs"] = _SERIALIZER.query("coord_crs", coord_crs, "str")
    if resampling is not None:
        _params["resampling"] = _SERIALIZER.query("resampling", resampling, "str")
    if max_size is not None:
        _params["max_size"] = _SERIALIZER.query("max_size", max_size, "int")
    if rescale is not None:
        _params["rescale"] = [_SERIALIZER.query("rescale", q, "str") if q is not None else "" for q in rescale]
    if colormap_name is not None:
        _params["colormap_name"] = _SERIALIZER.query("colormap_name", colormap_name, "str")
    if colormap is not None:
        _params["colormap"] = _SERIALIZER.query("colormap", colormap, "str")
    if return_mask is not None:
        _params["return_mask"] = _SERIALIZER.query("return_mask", return_mask, "bool")

    # Construct headers
    if content_type is not None:
        _headers["Content-Type"] = _SERIALIZER.header("content_type", content_type, "str")
    if accept is not None:
        _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="POST", url=_url, params=_params, headers=_headers, **kwargs)


def build_tiler_geo_jsons_crop_format_request(  # pylint: disable=name-too-long
    collection_id: str,
    item_id: str,
    format: str,
    *,
    assets: Optional[List[str]] = None,
    expression: Optional[str] = None,
    asset_bidx: Optional[List[str]] = None,
    asset_as_band: Optional[bool] = None,
    nodata: Optional[float] = None,
    unscale: Optional[bool] = None,
    algorithm: Optional[Union[str, _models.Algorithm]] = None,
    algorithm_params: Optional[str] = None,
    color_formula: Optional[str] = None,
    coord_crs: Optional[str] = None,
    resampling: Optional[Union[str, _models.Resampling]] = None,
    max_size: Optional[int] = None,
    height: Optional[int] = None,
    width: Optional[int] = None,
    rescale: Optional[List[str]] = None,
    colormap_name: Optional[Union[str, _models.ColorMapNames]] = None,
    colormap: Optional[str] = None,
    return_mask: Optional[bool] = None,
    **kwargs: Any,
) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2025-04-30-preview"))
    accept = _headers.pop("Accept", None)

    # Construct URL
    _url = "/data/collections/{collectionId}/items/{itemId}/crop.{format}"
    path_format_arguments = {
        "collectionId": _SERIALIZER.url("collection_id", collection_id, "str"),
        "itemId": _SERIALIZER.url("item_id", item_id, "str"),
        "format": _SERIALIZER.url("format", format, "str"),
    }

    _url: str = _url.format(**path_format_arguments)  # type: ignore

    # Construct parameters
    _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")
    if assets is not None:
        _params["assets"] = [_SERIALIZER.query("assets", q, "str") if q is not None else "" for q in assets]
    if expression is not None:
        _params["expression"] = _SERIALIZER.query("expression", expression, "str")
    if asset_bidx is not None:
        _params["asset_bidx"] = _SERIALIZER.query("asset_bidx", asset_bidx, "[str]", div=",")
    if asset_as_band is not None:
        _params["asset_as_band"] = _SERIALIZER.query("asset_as_band", asset_as_band, "bool")
    if nodata is not None:
        _params["nodata"] = _SERIALIZER.query("nodata", nodata, "float")
    if unscale is not None:
        _params["unscale"] = _SERIALIZER.query("unscale", unscale, "bool")
    if algorithm is not None:
        _params["algorithm"] = _SERIALIZER.query("algorithm", algorithm, "str")
    if algorithm_params is not None:
        _params["algorithm_params"] = _SERIALIZER.query("algorithm_params", algorithm_params, "str")
    if color_formula is not None:
        _params["color_formula"] = _SERIALIZER.query("color_formula", color_formula, "str")
    if coord_crs is not None:
        _params["coord-crs"] = _SERIALIZER.query("coord_crs", coord_crs, "str")
    if resampling is not None:
        _params["resampling"] = _SERIALIZER.query("resampling", resampling, "str")
    if max_size is not None:
        _params["max_size"] = _SERIALIZER.query("max_size", max_size, "int")
    if height is not None:
        _params["height"] = _SERIALIZER.query("height", height, "int")
    if width is not None:
        _params["width"] = _SERIALIZER.query("width", width, "int")
    if rescale is not None:
        _params["rescale"] = [_SERIALIZER.query("rescale", q, "str") if q is not None else "" for q in rescale]
    if colormap_name is not None:
        _params["colormap_name"] = _SERIALIZER.query("colormap_name", colormap_name, "str")
    if colormap is not None:
        _params["colormap"] = _SERIALIZER.query("colormap", colormap, "str")
    if return_mask is not None:
        _params["return_mask"] = _SERIALIZER.query("return_mask", return_mask, "bool")

    # Construct headers
    if content_type is not None:
        _headers["Content-Type"] = _SERIALIZER.header("content_type", content_type, "str")
    if accept is not None:
        _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="POST", url=_url, params=_params, headers=_headers, **kwargs)


def build_maps_classmap_legends_get_request(
    classmap_name: str, *, trim_start: Optional[int] = None, trim_end: Optional[int] = None, **kwargs: Any
) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2025-04-30-preview"))
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/data/legend/classmap/{classmapName}"
    path_format_arguments = {
        "classmapName": _SERIALIZER.url("classmap_name", classmap_name, "str"),
    }

    _url: str = _url.format(**path_format_arguments)  # type: ignore

    # Construct parameters
    _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")
    if trim_start is not None:
        _params["trim_start"] = _SERIALIZER.query("trim_start", trim_start, "int")
    if trim_end is not None:
        _params["trim_end"] = _SERIALIZER.query("trim_end", trim_end, "int")

    # Construct headers
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="GET", url=_url, params=_params, headers=_headers, **kwargs)


def build_maps_legends_get_request(
    cmap_name: str,
    *,
    height: Optional[float] = None,
    width: Optional[float] = None,
    trim_start: Optional[int] = None,
    trim_end: Optional[int] = None,
    **kwargs: Any,
) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2025-04-30-preview"))
    accept = _headers.pop("Accept", "image/png")

    # Construct URL
    _url = "/data/legend/colormap/{cmapName}"
    path_format_arguments = {
        "cmapName": _SERIALIZER.url("cmap_name", cmap_name, "str"),
    }

    _url: str = _url.format(**path_format_arguments)  # type: ignore

    # Construct parameters
    _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")
    if height is not None:
        _params["height"] = _SERIALIZER.query("height", height, "float")
    if width is not None:
        _params["width"] = _SERIALIZER.query("width", width, "float")
    if trim_start is not None:
        _params["trim_start"] = _SERIALIZER.query("trim_start", trim_start, "int")
    if trim_end is not None:
        _params["trim_end"] = _SERIALIZER.query("trim_end", trim_end, "int")

    # Construct headers
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="GET", url=_url, params=_params, headers=_headers, **kwargs)


def build_maps_interval_legends_get_by_classmap_name_request(  # pylint: disable=name-too-long
    classmap_name: str, *, trim_start: Optional[int] = None, trim_end: Optional[int] = None, **kwargs: Any
) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2025-04-30-preview"))
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/data/legend/interval/{classmapName}"
    path_format_arguments = {
        "classmapName": _SERIALIZER.url("classmap_name", classmap_name, "str"),
    }

    _url: str = _url.format(**path_format_arguments)  # type: ignore

    # Construct parameters
    _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")
    if trim_start is not None:
        _params["trim_start"] = _SERIALIZER.query("trim_start", trim_start, "int")
    if trim_end is not None:
        _params["trim_end"] = _SERIALIZER.query("trim_end", trim_end, "int")

    # Construct headers
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="GET", url=_url, params=_params, headers=_headers, **kwargs)


def build_mosaics_tiles_get_zxy_scalex_format_request(  # pylint: disable=name-too-long
    search_id: str,
    z: float,
    x: float,
    y: float,
    scale: float,
    format: str,
    *,
    assets: Optional[List[str]] = None,
    expression: Optional[str] = None,
    asset_bidx: Optional[List[str]] = None,
    asset_as_band: Optional[bool] = None,
    nodata: Optional[float] = None,
    unscale: Optional[bool] = None,
    scan_limit: Optional[int] = None,
    items_limit: Optional[int] = None,
    time_limit: Optional[int] = None,
    exitwhenfull: Optional[bool] = None,
    skipcovered: Optional[bool] = None,
    algorithm: Optional[Union[str, _models.Algorithm]] = None,
    algorithm_params: Optional[str] = None,
    tile_matrix_set_id: Optional[Union[str, _models.Tilematrixsetid]] = None,
    buffer: Optional[str] = None,
    color_formula: Optional[str] = None,
    collection: Optional[str] = None,
    resampling: Optional[Union[str, _models.Resampling]] = None,
    pixel_selection: Optional[Union[str, _models.PixelSelection]] = None,
    rescale: Optional[List[str]] = None,
    colormap_name: Optional[Union[str, _models.ColorMapNames]] = None,
    colormap: Optional[str] = None,
    return_mask: Optional[bool] = None,
    **kwargs: Any,
) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2025-04-30-preview"))
    accept = _headers.pop("Accept", None)

    # Construct URL
    _url = "/data/mosaic/{searchId}/tiles/{z}/{x}/{y}@{scale}x.{format}"
    path_format_arguments = {
        "searchId": _SERIALIZER.url("search_id", search_id, "str"),
        "z": _SERIALIZER.url("z", z, "float"),
        "x": _SERIALIZER.url("x", x, "float"),
        "y": _SERIALIZER.url("y", y, "float"),
        "scale": _SERIALIZER.url("scale", scale, "float"),
        "format": _SERIALIZER.url("format", format, "str"),
    }

    _url: str = _url.format(**path_format_arguments)  # type: ignore

    # Construct parameters
    _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")
    if assets is not None:
        _params["assets"] = [_SERIALIZER.query("assets", q, "str") if q is not None else "" for q in assets]
    if expression is not None:
        _params["expression"] = _SERIALIZER.query("expression", expression, "str")
    if asset_bidx is not None:
        _params["asset_bidx"] = _SERIALIZER.query("asset_bidx", asset_bidx, "[str]", div=",")
    if asset_as_band is not None:
        _params["asset_as_band"] = _SERIALIZER.query("asset_as_band", asset_as_band, "bool")
    if nodata is not None:
        _params["nodata"] = _SERIALIZER.query("nodata", nodata, "float")
    if unscale is not None:
        _params["unscale"] = _SERIALIZER.query("unscale", unscale, "bool")
    if scan_limit is not None:
        _params["scan_limit"] = _SERIALIZER.query("scan_limit", scan_limit, "int")
    if items_limit is not None:
        _params["items_limit"] = _SERIALIZER.query("items_limit", items_limit, "int")
    if time_limit is not None:
        _params["time_limit"] = _SERIALIZER.query("time_limit", time_limit, "int")
    if exitwhenfull is not None:
        _params["exitwhenfull"] = _SERIALIZER.query("exitwhenfull", exitwhenfull, "bool")
    if skipcovered is not None:
        _params["skipcovered"] = _SERIALIZER.query("skipcovered", skipcovered, "bool")
    if algorithm is not None:
        _params["algorithm"] = _SERIALIZER.query("algorithm", algorithm, "str")
    if algorithm_params is not None:
        _params["algorithm_params"] = _SERIALIZER.query("algorithm_params", algorithm_params, "str")
    if tile_matrix_set_id is not None:
        _params["tileMatrixSetId"] = _SERIALIZER.query("tile_matrix_set_id", tile_matrix_set_id, "str")
    if buffer is not None:
        _params["buffer"] = _SERIALIZER.query("buffer", buffer, "str")
    if color_formula is not None:
        _params["color_formula"] = _SERIALIZER.query("color_formula", color_formula, "str")
    if collection is not None:
        _params["collection"] = _SERIALIZER.query("collection", collection, "str")
    if resampling is not None:
        _params["resampling"] = _SERIALIZER.query("resampling", resampling, "str")
    if pixel_selection is not None:
        _params["pixel_selection"] = _SERIALIZER.query("pixel_selection", pixel_selection, "str")
    if rescale is not None:
        _params["rescale"] = [_SERIALIZER.query("rescale", q, "str") if q is not None else "" for q in rescale]
    if colormap_name is not None:
        _params["colormap_name"] = _SERIALIZER.query("colormap_name", colormap_name, "str")
    if colormap is not None:
        _params["colormap"] = _SERIALIZER.query("colormap", colormap, "str")
    if return_mask is not None:
        _params["return_mask"] = _SERIALIZER.query("return_mask", return_mask, "bool")

    # Construct headers
    if accept is not None:
        _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="GET", url=_url, params=_params, headers=_headers, **kwargs)


def build_mosaics_tile_matrix_sets_get_zxy_scalex_format_request(  # pylint: disable=name-too-long
    search_id: str,
    tile_matrix_set_id: str,
    z: float,
    x: float,
    y: float,
    scale: float,
    format: str,
    *,
    assets: Optional[List[str]] = None,
    expression: Optional[str] = None,
    asset_bidx: Optional[List[str]] = None,
    asset_as_band: Optional[bool] = None,
    nodata: Optional[float] = None,
    unscale: Optional[bool] = None,
    scan_limit: Optional[int] = None,
    items_limit: Optional[int] = None,
    time_limit: Optional[int] = None,
    exitwhenfull: Optional[bool] = None,
    skipcovered: Optional[bool] = None,
    algorithm: Optional[Union[str, _models.Algorithm]] = None,
    algorithm_params: Optional[str] = None,
    buffer: Optional[str] = None,
    color_formula: Optional[str] = None,
    collection: Optional[str] = None,
    resampling: Optional[Union[str, _models.Resampling]] = None,
    pixel_selection: Optional[Union[str, _models.PixelSelection]] = None,
    rescale: Optional[List[str]] = None,
    colormap_name: Optional[Union[str, _models.ColorMapNames]] = None,
    colormap: Optional[str] = None,
    return_mask: Optional[bool] = None,
    **kwargs: Any,
) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2025-04-30-preview"))
    accept = _headers.pop("Accept", None)

    # Construct URL
    _url = "/data/mosaic/{searchId}/tiles/{tileMatrixSetId}/{z}/{x}/{y}@{scale}x.{format}"
    path_format_arguments = {
        "searchId": _SERIALIZER.url("search_id", search_id, "str"),
        "tileMatrixSetId": _SERIALIZER.url("tile_matrix_set_id", tile_matrix_set_id, "str"),
        "z": _SERIALIZER.url("z", z, "float"),
        "x": _SERIALIZER.url("x", x, "float"),
        "y": _SERIALIZER.url("y", y, "float"),
        "scale": _SERIALIZER.url("scale", scale, "float"),
        "format": _SERIALIZER.url("format", format, "str"),
    }

    _url: str = _url.format(**path_format_arguments)  # type: ignore

    # Construct parameters
    _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")
    if assets is not None:
        _params["assets"] = [_SERIALIZER.query("assets", q, "str") if q is not None else "" for q in assets]
    if expression is not None:
        _params["expression"] = _SERIALIZER.query("expression", expression, "str")
    if asset_bidx is not None:
        _params["asset_bidx"] = _SERIALIZER.query("asset_bidx", asset_bidx, "[str]", div=",")
    if asset_as_band is not None:
        _params["asset_as_band"] = _SERIALIZER.query("asset_as_band", asset_as_band, "bool")
    if nodata is not None:
        _params["nodata"] = _SERIALIZER.query("nodata", nodata, "float")
    if unscale is not None:
        _params["unscale"] = _SERIALIZER.query("unscale", unscale, "bool")
    if scan_limit is not None:
        _params["scan_limit"] = _SERIALIZER.query("scan_limit", scan_limit, "int")
    if items_limit is not None:
        _params["items_limit"] = _SERIALIZER.query("items_limit", items_limit, "int")
    if time_limit is not None:
        _params["time_limit"] = _SERIALIZER.query("time_limit", time_limit, "int")
    if exitwhenfull is not None:
        _params["exitwhenfull"] = _SERIALIZER.query("exitwhenfull", exitwhenfull, "bool")
    if skipcovered is not None:
        _params["skipcovered"] = _SERIALIZER.query("skipcovered", skipcovered, "bool")
    if algorithm is not None:
        _params["algorithm"] = _SERIALIZER.query("algorithm", algorithm, "str")
    if algorithm_params is not None:
        _params["algorithm_params"] = _SERIALIZER.query("algorithm_params", algorithm_params, "str")
    if buffer is not None:
        _params["buffer"] = _SERIALIZER.query("buffer", buffer, "str")
    if color_formula is not None:
        _params["color_formula"] = _SERIALIZER.query("color_formula", color_formula, "str")
    if collection is not None:
        _params["collection"] = _SERIALIZER.query("collection", collection, "str")
    if resampling is not None:
        _params["resampling"] = _SERIALIZER.query("resampling", resampling, "str")
    if pixel_selection is not None:
        _params["pixel_selection"] = _SERIALIZER.query("pixel_selection", pixel_selection, "str")
    if rescale is not None:
        _params["rescale"] = [_SERIALIZER.query("rescale", q, "str") if q is not None else "" for q in rescale]
    if colormap_name is not None:
        _params["colormap_name"] = _SERIALIZER.query("colormap_name", colormap_name, "str")
    if colormap is not None:
        _params["colormap"] = _SERIALIZER.query("colormap", colormap, "str")
    if return_mask is not None:
        _params["return_mask"] = _SERIALIZER.query("return_mask", return_mask, "bool")

    # Construct headers
    if accept is not None:
        _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="GET", url=_url, params=_params, headers=_headers, **kwargs)


def build_mosaics_tile_json_operations_get_request(  # pylint: disable=name-too-long
    search_id: str,
    *,
    assets: Optional[List[str]] = None,
    expression: Optional[str] = None,
    asset_bidx: Optional[List[str]] = None,
    asset_as_band: Optional[bool] = None,
    nodata: Optional[float] = None,
    unscale: Optional[bool] = None,
    scan_limit: Optional[int] = None,
    items_limit: Optional[int] = None,
    time_limit: Optional[int] = None,
    exitwhenfull: Optional[bool] = None,
    skipcovered: Optional[bool] = None,
    tile_matrix_set_id: Optional[Union[str, _models.Tilematrixsetid]] = None,
    tile_format: Optional[Union[str, _models.ImageType]] = None,
    tile_scale: Optional[int] = None,
    minzoom: Optional[int] = None,
    maxzoom: Optional[int] = None,
    buffer: Optional[float] = None,
    color_formula: Optional[str] = None,
    collection: Optional[str] = None,
    resampling: Optional[Union[str, _models.Resampling]] = None,
    pixel_selection: Optional[Union[str, _models.PixelSelection]] = None,
    algorithm: Optional[Union[str, _models.Algorithm]] = None,
    algorithm_params: Optional[str] = None,
    rescale: Optional[List[str]] = None,
    colormap_name: Optional[Union[str, _models.ColorMapNames]] = None,
    colormap: Optional[str] = None,
    return_mask: Optional[bool] = None,
    **kwargs: Any,
) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2025-04-30-preview"))
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/data/mosaic/{searchId}/tilejson.json"
    path_format_arguments = {
        "searchId": _SERIALIZER.url("search_id", search_id, "str"),
    }

    _url: str = _url.format(**path_format_arguments)  # type: ignore

    # Construct parameters
    _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")
    if assets is not None:
        _params["assets"] = [_SERIALIZER.query("assets", q, "str") if q is not None else "" for q in assets]
    if expression is not None:
        _params["expression"] = _SERIALIZER.query("expression", expression, "str")
    if asset_bidx is not None:
        _params["asset_bidx"] = _SERIALIZER.query("asset_bidx", asset_bidx, "[str]", div=",")
    if asset_as_band is not None:
        _params["asset_as_band"] = _SERIALIZER.query("asset_as_band", asset_as_band, "bool")
    if nodata is not None:
        _params["nodata"] = _SERIALIZER.query("nodata", nodata, "float")
    if unscale is not None:
        _params["unscale"] = _SERIALIZER.query("unscale", unscale, "bool")
    if scan_limit is not None:
        _params["scan_limit"] = _SERIALIZER.query("scan_limit", scan_limit, "int")
    if items_limit is not None:
        _params["items_limit"] = _SERIALIZER.query("items_limit", items_limit, "int")
    if time_limit is not None:
        _params["time_limit"] = _SERIALIZER.query("time_limit", time_limit, "int")
    if exitwhenfull is not None:
        _params["exitwhenfull"] = _SERIALIZER.query("exitwhenfull", exitwhenfull, "bool")
    if skipcovered is not None:
        _params["skipcovered"] = _SERIALIZER.query("skipcovered", skipcovered, "bool")
    if tile_matrix_set_id is not None:
        _params["tileMatrixSetId"] = _SERIALIZER.query("tile_matrix_set_id", tile_matrix_set_id, "str")
    if tile_format is not None:
        _params["tile_format"] = _SERIALIZER.query("tile_format", tile_format, "str")
    if tile_scale is not None:
        _params["tile_scale"] = _SERIALIZER.query("tile_scale", tile_scale, "int")
    if minzoom is not None:
        _params["minzoom"] = _SERIALIZER.query("minzoom", minzoom, "int")
    if maxzoom is not None:
        _params["maxzoom"] = _SERIALIZER.query("maxzoom", maxzoom, "int")
    if buffer is not None:
        _params["buffer"] = _SERIALIZER.query("buffer", buffer, "float")
    if color_formula is not None:
        _params["color_formula"] = _SERIALIZER.query("color_formula", color_formula, "str")
    if collection is not None:
        _params["collection"] = _SERIALIZER.query("collection", collection, "str")
    if resampling is not None:
        _params["resampling"] = _SERIALIZER.query("resampling", resampling, "str")
    if pixel_selection is not None:
        _params["pixel_selection"] = _SERIALIZER.query("pixel_selection", pixel_selection, "str")
    if algorithm is not None:
        _params["algorithm"] = _SERIALIZER.query("algorithm", algorithm, "str")
    if algorithm_params is not None:
        _params["algorithm_params"] = _SERIALIZER.query("algorithm_params", algorithm_params, "str")
    if rescale is not None:
        _params["rescale"] = [_SERIALIZER.query("rescale", q, "str") if q is not None else "" for q in rescale]
    if colormap_name is not None:
        _params["colormap_name"] = _SERIALIZER.query("colormap_name", colormap_name, "str")
    if colormap is not None:
        _params["colormap"] = _SERIALIZER.query("colormap", colormap, "str")
    if return_mask is not None:
        _params["return_mask"] = _SERIALIZER.query("return_mask", return_mask, "bool")

    # Construct headers
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="GET", url=_url, params=_params, headers=_headers, **kwargs)


def build_mosaics_tile_matrix_sets_tile_json_get_request(  # pylint: disable=name-too-long
    search_id: str,
    tile_matrix_set_id: str,
    *,
    assets: Optional[List[str]] = None,
    expression: Optional[str] = None,
    asset_bidx: Optional[List[str]] = None,
    asset_as_band: Optional[bool] = None,
    nodata: Optional[float] = None,
    unscale: Optional[bool] = None,
    scan_limit: Optional[int] = None,
    items_limit: Optional[int] = None,
    time_limit: Optional[int] = None,
    exitwhenfull: Optional[bool] = None,
    skipcovered: Optional[bool] = None,
    algorithm: Optional[Union[str, _models.Algorithm]] = None,
    algorithm_params: Optional[str] = None,
    minzoom: Optional[int] = None,
    maxzoom: Optional[int] = None,
    tile_format: Optional[Union[str, _models.ImageType]] = None,
    tile_scale: Optional[int] = None,
    buffer: Optional[str] = None,
    color_formula: Optional[str] = None,
    collection: Optional[str] = None,
    resampling: Optional[Union[str, _models.Resampling]] = None,
    pixel_selection: Optional[Union[str, _models.PixelSelection]] = None,
    rescale: Optional[List[str]] = None,
    colormap_name: Optional[Union[str, _models.ColorMapNames]] = None,
    colormap: Optional[str] = None,
    return_mask: Optional[bool] = None,
    **kwargs: Any,
) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2025-04-30-preview"))
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/data/mosaic/{searchId}/{tileMatrixSetId}/tilejson.json"
    path_format_arguments = {
        "searchId": _SERIALIZER.url("search_id", search_id, "str"),
        "tileMatrixSetId": _SERIALIZER.url("tile_matrix_set_id", tile_matrix_set_id, "str"),
    }

    _url: str = _url.format(**path_format_arguments)  # type: ignore

    # Construct parameters
    _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")
    if assets is not None:
        _params["assets"] = [_SERIALIZER.query("assets", q, "str") if q is not None else "" for q in assets]
    if expression is not None:
        _params["expression"] = _SERIALIZER.query("expression", expression, "str")
    if asset_bidx is not None:
        _params["asset_bidx"] = _SERIALIZER.query("asset_bidx", asset_bidx, "[str]", div=",")
    if asset_as_band is not None:
        _params["asset_as_band"] = _SERIALIZER.query("asset_as_band", asset_as_band, "bool")
    if nodata is not None:
        _params["nodata"] = _SERIALIZER.query("nodata", nodata, "float")
    if unscale is not None:
        _params["unscale"] = _SERIALIZER.query("unscale", unscale, "bool")
    if scan_limit is not None:
        _params["scan_limit"] = _SERIALIZER.query("scan_limit", scan_limit, "int")
    if items_limit is not None:
        _params["items_limit"] = _SERIALIZER.query("items_limit", items_limit, "int")
    if time_limit is not None:
        _params["time_limit"] = _SERIALIZER.query("time_limit", time_limit, "int")
    if exitwhenfull is not None:
        _params["exitwhenfull"] = _SERIALIZER.query("exitwhenfull", exitwhenfull, "bool")
    if skipcovered is not None:
        _params["skipcovered"] = _SERIALIZER.query("skipcovered", skipcovered, "bool")
    if algorithm is not None:
        _params["algorithm"] = _SERIALIZER.query("algorithm", algorithm, "str")
    if algorithm_params is not None:
        _params["algorithm_params"] = _SERIALIZER.query("algorithm_params", algorithm_params, "str")
    if minzoom is not None:
        _params["minzoom"] = _SERIALIZER.query("minzoom", minzoom, "int")
    if maxzoom is not None:
        _params["maxzoom"] = _SERIALIZER.query("maxzoom", maxzoom, "int")
    if tile_format is not None:
        _params["tile_format"] = _SERIALIZER.query("tile_format", tile_format, "str")
    if tile_scale is not None:
        _params["tile_scale"] = _SERIALIZER.query("tile_scale", tile_scale, "int")
    if buffer is not None:
        _params["buffer"] = _SERIALIZER.query("buffer", buffer, "str")
    if color_formula is not None:
        _params["color_formula"] = _SERIALIZER.query("color_formula", color_formula, "str")
    if collection is not None:
        _params["collection"] = _SERIALIZER.query("collection", collection, "str")
    if resampling is not None:
        _params["resampling"] = _SERIALIZER.query("resampling", resampling, "str")
    if pixel_selection is not None:
        _params["pixel_selection"] = _SERIALIZER.query("pixel_selection", pixel_selection, "str")
    if rescale is not None:
        _params["rescale"] = [_SERIALIZER.query("rescale", q, "str") if q is not None else "" for q in rescale]
    if colormap_name is not None:
        _params["colormap_name"] = _SERIALIZER.query("colormap_name", colormap_name, "str")
    if colormap is not None:
        _params["colormap"] = _SERIALIZER.query("colormap", colormap, "str")
    if return_mask is not None:
        _params["return_mask"] = _SERIALIZER.query("return_mask", return_mask, "bool")

    # Construct headers
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="GET", url=_url, params=_params, headers=_headers, **kwargs)


def build_mosaics_wmts_mosaics_get_capabilities_xml_request(  # pylint: disable=name-too-long
    search_id: str,
    *,
    assets: Optional[List[str]] = None,
    expression: Optional[str] = None,
    asset_bidx: Optional[List[str]] = None,
    asset_as_band: Optional[bool] = None,
    nodata: Optional[float] = None,
    unscale: Optional[bool] = None,
    algorithm: Optional[Union[str, _models.Algorithm]] = None,
    algorithm_params: Optional[str] = None,
    tile_matrix_set_id: Optional[Union[str, _models.Tilematrixsetid]] = None,
    tile_format: Optional[Union[str, _models.ImageType]] = None,
    tile_scale: Optional[int] = None,
    minzoom: Optional[int] = None,
    maxzoom: Optional[int] = None,
    buffer: Optional[str] = None,
    color_formula: Optional[str] = None,
    resampling: Optional[Union[str, _models.Resampling]] = None,
    rescale: Optional[List[str]] = None,
    colormap_name: Optional[Union[str, _models.ColorMapNames]] = None,
    colormap: Optional[str] = None,
    return_mask: Optional[bool] = None,
    **kwargs: Any,
) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2025-04-30-preview"))
    accept = _headers.pop("Accept", "application/xml")

    # Construct URL
    _url = "/data/mosaic/{searchId}/WMTSCapabilities.xml"
    path_format_arguments = {
        "searchId": _SERIALIZER.url("search_id", search_id, "str"),
    }

    _url: str = _url.format(**path_format_arguments)  # type: ignore

    # Construct parameters
    _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")
    if assets is not None:
        _params["assets"] = [_SERIALIZER.query("assets", q, "str") if q is not None else "" for q in assets]
    if expression is not None:
        _params["expression"] = _SERIALIZER.query("expression", expression, "str")
    if asset_bidx is not None:
        _params["asset_bidx"] = _SERIALIZER.query("asset_bidx", asset_bidx, "[str]", div=",")
    if asset_as_band is not None:
        _params["asset_as_band"] = _SERIALIZER.query("asset_as_band", asset_as_band, "bool")
    if nodata is not None:
        _params["nodata"] = _SERIALIZER.query("nodata", nodata, "float")
    if unscale is not None:
        _params["unscale"] = _SERIALIZER.query("unscale", unscale, "bool")
    if algorithm is not None:
        _params["algorithm"] = _SERIALIZER.query("algorithm", algorithm, "str")
    if algorithm_params is not None:
        _params["algorithm_params"] = _SERIALIZER.query("algorithm_params", algorithm_params, "str")
    if tile_matrix_set_id is not None:
        _params["tileMatrixSetId"] = _SERIALIZER.query("tile_matrix_set_id", tile_matrix_set_id, "str")
    if tile_format is not None:
        _params["tile_format"] = _SERIALIZER.query("tile_format", tile_format, "str")
    if tile_scale is not None:
        _params["tile_scale"] = _SERIALIZER.query("tile_scale", tile_scale, "int")
    if minzoom is not None:
        _params["minzoom"] = _SERIALIZER.query("minzoom", minzoom, "int")
    if maxzoom is not None:
        _params["maxzoom"] = _SERIALIZER.query("maxzoom", maxzoom, "int")
    if buffer is not None:
        _params["buffer"] = _SERIALIZER.query("buffer", buffer, "str")
    if color_formula is not None:
        _params["color_formula"] = _SERIALIZER.query("color_formula", color_formula, "str")
    if resampling is not None:
        _params["resampling"] = _SERIALIZER.query("resampling", resampling, "str")
    if rescale is not None:
        _params["rescale"] = [_SERIALIZER.query("rescale", q, "str") if q is not None else "" for q in rescale]
    if colormap_name is not None:
        _params["colormap_name"] = _SERIALIZER.query("colormap_name", colormap_name, "str")
    if colormap is not None:
        _params["colormap"] = _SERIALIZER.query("colormap", colormap, "str")
    if return_mask is not None:
        _params["return_mask"] = _SERIALIZER.query("return_mask", return_mask, "bool")

    # Construct headers
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="GET", url=_url, params=_params, headers=_headers, **kwargs)


def build_mosaics_wmts_mosaics_tile_matrix_sets_get_capabilities_xml_request(  # pylint: disable=name-too-long
    search_id: str,
    tile_matrix_set_id: str,
    *,
    assets: Optional[List[str]] = None,
    expression: Optional[str] = None,
    asset_bidx: Optional[List[str]] = None,
    asset_as_band: Optional[bool] = None,
    nodata: Optional[float] = None,
    unscale: Optional[bool] = None,
    algorithm: Optional[Union[str, _models.Algorithm]] = None,
    algorithm_params: Optional[str] = None,
    tile_format: Optional[Union[str, _models.ImageType]] = None,
    tile_scale: Optional[int] = None,
    minzoom: Optional[int] = None,
    maxzoom: Optional[int] = None,
    buffer: Optional[str] = None,
    color_formula: Optional[str] = None,
    resampling: Optional[Union[str, _models.Resampling]] = None,
    rescale: Optional[List[str]] = None,
    colormap_name: Optional[Union[str, _models.ColorMapNames]] = None,
    colormap: Optional[str] = None,
    return_mask: Optional[bool] = None,
    **kwargs: Any,
) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2025-04-30-preview"))
    accept = _headers.pop("Accept", "application/xml")

    # Construct URL
    _url = "/data/mosaic/{searchId}/{tileMatrixSetId}/WMTSCapabilities.xml"
    path_format_arguments = {
        "searchId": _SERIALIZER.url("search_id", search_id, "str"),
        "tileMatrixSetId": _SERIALIZER.url("tile_matrix_set_id", tile_matrix_set_id, "str"),
    }

    _url: str = _url.format(**path_format_arguments)  # type: ignore

    # Construct parameters
    _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")
    if assets is not None:
        _params["assets"] = [_SERIALIZER.query("assets", q, "str") if q is not None else "" for q in assets]
    if expression is not None:
        _params["expression"] = _SERIALIZER.query("expression", expression, "str")
    if asset_bidx is not None:
        _params["asset_bidx"] = _SERIALIZER.query("asset_bidx", asset_bidx, "[str]", div=",")
    if asset_as_band is not None:
        _params["asset_as_band"] = _SERIALIZER.query("asset_as_band", asset_as_band, "bool")
    if nodata is not None:
        _params["nodata"] = _SERIALIZER.query("nodata", nodata, "float")
    if unscale is not None:
        _params["unscale"] = _SERIALIZER.query("unscale", unscale, "bool")
    if algorithm is not None:
        _params["algorithm"] = _SERIALIZER.query("algorithm", algorithm, "str")
    if algorithm_params is not None:
        _params["algorithm_params"] = _SERIALIZER.query("algorithm_params", algorithm_params, "str")
    if tile_format is not None:
        _params["tile_format"] = _SERIALIZER.query("tile_format", tile_format, "str")
    if tile_scale is not None:
        _params["tile_scale"] = _SERIALIZER.query("tile_scale", tile_scale, "int")
    if minzoom is not None:
        _params["minzoom"] = _SERIALIZER.query("minzoom", minzoom, "int")
    if maxzoom is not None:
        _params["maxzoom"] = _SERIALIZER.query("maxzoom", maxzoom, "int")
    if buffer is not None:
        _params["buffer"] = _SERIALIZER.query("buffer", buffer, "str")
    if color_formula is not None:
        _params["color_formula"] = _SERIALIZER.query("color_formula", color_formula, "str")
    if resampling is not None:
        _params["resampling"] = _SERIALIZER.query("resampling", resampling, "str")
    if rescale is not None:
        _params["rescale"] = [_SERIALIZER.query("rescale", q, "str") if q is not None else "" for q in rescale]
    if colormap_name is not None:
        _params["colormap_name"] = _SERIALIZER.query("colormap_name", colormap_name, "str")
    if colormap is not None:
        _params["colormap"] = _SERIALIZER.query("colormap", colormap, "str")
    if return_mask is not None:
        _params["return_mask"] = _SERIALIZER.query("return_mask", return_mask, "bool")

    # Construct headers
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="GET", url=_url, params=_params, headers=_headers, **kwargs)


def build_mosaics_register_search_register_request(**kwargs: Any) -> HttpRequest:  # pylint: disable=name-too-long
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2025-04-30-preview"))
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/data/mosaic/register"

    # Construct parameters
    _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")

    # Construct headers
    if content_type is not None:
        _headers["Content-Type"] = _SERIALIZER.header("content_type", content_type, "str")
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="POST", url=_url, params=_params, headers=_headers, **kwargs)


def build_mosaics_info_search_get_request(search_id: str, **kwargs: Any) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2025-04-30-preview"))
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/data/mosaic/{searchId}/info"
    path_format_arguments = {
        "searchId": _SERIALIZER.url("search_id", search_id, "str"),
    }

    _url: str = _url.format(**path_format_arguments)  # type: ignore

    # Construct parameters
    _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")

    # Construct headers
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="GET", url=_url, params=_params, headers=_headers, **kwargs)


def build_mosaics_assets_for_tiles_get_zxy_assets_request(  # pylint: disable=name-too-long
    search_id: str,
    z: float,
    x: float,
    y: float,
    *,
    scan_limit: Optional[int] = None,
    items_limit: Optional[int] = None,
    time_limit: Optional[int] = None,
    exitwhenfull: Optional[bool] = None,
    skipcovered: Optional[bool] = None,
    tile_matrix_set_id: Optional[Union[str, _models.Tilematrixsetid]] = None,
    **kwargs: Any,
) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2025-04-30-preview"))
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/data/mosaic/{searchId}/tiles/{z}/{x}/{y}/assets"
    path_format_arguments = {
        "searchId": _SERIALIZER.url("search_id", search_id, "str"),
        "z": _SERIALIZER.url("z", z, "float"),
        "x": _SERIALIZER.url("x", x, "float"),
        "y": _SERIALIZER.url("y", y, "float"),
    }

    _url: str = _url.format(**path_format_arguments)  # type: ignore

    # Construct parameters
    _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")
    if scan_limit is not None:
        _params["scan_limit"] = _SERIALIZER.query("scan_limit", scan_limit, "int")
    if items_limit is not None:
        _params["items_limit"] = _SERIALIZER.query("items_limit", items_limit, "int")
    if time_limit is not None:
        _params["time_limit"] = _SERIALIZER.query("time_limit", time_limit, "int")
    if exitwhenfull is not None:
        _params["exitwhenfull"] = _SERIALIZER.query("exitwhenfull", exitwhenfull, "bool")
    if skipcovered is not None:
        _params["skipcovered"] = _SERIALIZER.query("skipcovered", skipcovered, "bool")
    if tile_matrix_set_id is not None:
        _params["tileMatrixSetId"] = _SERIALIZER.query("tile_matrix_set_id", tile_matrix_set_id, "str")

    # Construct headers
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="GET", url=_url, params=_params, headers=_headers, **kwargs)


def build_mosaics_assets_for_tile_matrix_sets_get_zxy_assets_request(  # pylint: disable=name-too-long
    search_id: str,
    tile_matrix_set_id: str,
    z: float,
    x: float,
    y: float,
    *,
    scan_limit: Optional[int] = None,
    items_limit: Optional[int] = None,
    time_limit: Optional[int] = None,
    exitwhenfull: Optional[bool] = None,
    skipcovered: Optional[bool] = None,
    **kwargs: Any,
) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2025-04-30-preview"))
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/data/mosaic/{searchId}/tiles/{tileMatrixSetId}/{z}/{x}/{y}/assets"
    path_format_arguments = {
        "searchId": _SERIALIZER.url("search_id", search_id, "str"),
        "tileMatrixSetId": _SERIALIZER.url("tile_matrix_set_id", tile_matrix_set_id, "str"),
        "z": _SERIALIZER.url("z", z, "float"),
        "x": _SERIALIZER.url("x", x, "float"),
        "y": _SERIALIZER.url("y", y, "float"),
    }

    _url: str = _url.format(**path_format_arguments)  # type: ignore

    # Construct parameters
    _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")
    if scan_limit is not None:
        _params["scan_limit"] = _SERIALIZER.query("scan_limit", scan_limit, "int")
    if items_limit is not None:
        _params["items_limit"] = _SERIALIZER.query("items_limit", items_limit, "int")
    if time_limit is not None:
        _params["time_limit"] = _SERIALIZER.query("time_limit", time_limit, "int")
    if exitwhenfull is not None:
        _params["exitwhenfull"] = _SERIALIZER.query("exitwhenfull", exitwhenfull, "bool")
    if skipcovered is not None:
        _params["skipcovered"] = _SERIALIZER.query("skipcovered", skipcovered, "bool")

    # Construct headers
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="GET", url=_url, params=_params, headers=_headers, **kwargs)


def build_mosaics_assets_for_points_get_lon_lat_assets_request(  # pylint: disable=name-too-long
    search_id: str,
    lon: float,
    lat: float,
    *,
    scan_limit: Optional[int] = None,
    items_limit: Optional[int] = None,
    time_limit: Optional[int] = None,
    exitwhenfull: Optional[bool] = None,
    skipcovered: Optional[bool] = None,
    coord_crs: Optional[str] = None,
    **kwargs: Any,
) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2025-04-30-preview"))
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/data/mosaic/{searchId}/{lon},{lat}/assets"
    path_format_arguments = {
        "searchId": _SERIALIZER.url("search_id", search_id, "str"),
        "lon": _SERIALIZER.url("lon", lon, "float"),
        "lat": _SERIALIZER.url("lat", lat, "float"),
    }

    _url: str = _url.format(**path_format_arguments)  # type: ignore

    # Construct parameters
    _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")
    if scan_limit is not None:
        _params["scan_limit"] = _SERIALIZER.query("scan_limit", scan_limit, "int")
    if items_limit is not None:
        _params["items_limit"] = _SERIALIZER.query("items_limit", items_limit, "int")
    if time_limit is not None:
        _params["time_limit"] = _SERIALIZER.query("time_limit", time_limit, "int")
    if exitwhenfull is not None:
        _params["exitwhenfull"] = _SERIALIZER.query("exitwhenfull", exitwhenfull, "bool")
    if skipcovered is not None:
        _params["skipcovered"] = _SERIALIZER.query("skipcovered", skipcovered, "bool")
    if coord_crs is not None:
        _params["coord-crs"] = _SERIALIZER.query("coord_crs", coord_crs, "str")

    # Construct headers
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="GET", url=_url, params=_params, headers=_headers, **kwargs)


def build_tile_matrix_list_get_request(**kwargs: Any) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2025-04-30-preview"))
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/data/tile-matrix-sets"

    # Construct parameters
    _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")

    # Construct headers
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="GET", url=_url, params=_params, headers=_headers, **kwargs)


def build_tile_matrix_definitions_get_request(  # pylint: disable=name-too-long
    tile_matrix_set_id: str, **kwargs: Any
) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2025-04-30-preview"))
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/data/tile-matrix-sets/{tileMatrixSetId}"
    path_format_arguments = {
        "tileMatrixSetId": _SERIALIZER.url("tile_matrix_set_id", tile_matrix_set_id, "str"),
    }

    _url: str = _url.format(**path_format_arguments)  # type: ignore

    # Construct parameters
    _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")

    # Construct headers
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="GET", url=_url, params=_params, headers=_headers, **kwargs)


def build_sas_get_token_request(collection_id: str, *, duration: Optional[int] = None, **kwargs: Any) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2025-04-30-preview"))
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/sas/token/{collectionId}"
    path_format_arguments = {
        "collectionId": _SERIALIZER.url("collection_id", collection_id, "str"),
    }

    _url: str = _url.format(**path_format_arguments)  # type: ignore

    # Construct parameters
    _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")
    if duration is not None:
        _params["duration"] = _SERIALIZER.query("duration", duration, "int")

    # Construct headers
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="GET", url=_url, params=_params, headers=_headers, **kwargs)


def build_sas_revoke_token_request(*, duration: Optional[int] = None, **kwargs: Any) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2025-04-30-preview"))
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/sas/token/revoke"

    # Construct parameters
    _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")
    if duration is not None:
        _params["duration"] = _SERIALIZER.query("duration", duration, "int")

    # Construct headers
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="POST", url=_url, params=_params, headers=_headers, **kwargs)


def build_sas_get_sign_request(*, href: str, duration: Optional[int] = None, **kwargs: Any) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2025-04-30-preview"))
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/sas/sign"

    # Construct parameters
    _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")
    _params["href"] = _SERIALIZER.query("href", href, "str")
    if duration is not None:
        _params["duration"] = _SERIALIZER.query("duration", duration, "int")

    # Construct headers
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="GET", url=_url, params=_params, headers=_headers, **kwargs)


def build_ingestions_ingestion_runs_list_all_request(  # pylint: disable=name-too-long
    collection_id: str, ingestion_id: str, *, top: Optional[int] = None, skip: Optional[int] = None, **kwargs: Any
) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2025-04-30-preview"))
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/inma/collections/{collectionId}/ingestions/{ingestionId}/runs"
    path_format_arguments = {
        "collectionId": _SERIALIZER.url("collection_id", collection_id, "str"),
        "ingestionId": _SERIALIZER.url("ingestion_id", ingestion_id, "str"),
    }

    _url: str = _url.format(**path_format_arguments)  # type: ignore

    # Construct parameters
    _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")
    if top is not None:
        _params["$top"] = _SERIALIZER.query("top", top, "int")
    if skip is not None:
        _params["$skip"] = _SERIALIZER.query("skip", skip, "int")

    # Construct headers
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="GET", url=_url, params=_params, headers=_headers, **kwargs)


def build_ingestions_ingestion_runs_create_request(  # pylint: disable=name-too-long
    collection_id: str, ingestion_id: str, **kwargs: Any
) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2025-04-30-preview"))
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/inma/collections/{collectionId}/ingestions/{ingestionId}/runs"
    path_format_arguments = {
        "collectionId": _SERIALIZER.url("collection_id", collection_id, "str"),
        "ingestionId": _SERIALIZER.url("ingestion_id", ingestion_id, "str"),
    }

    _url: str = _url.format(**path_format_arguments)  # type: ignore

    # Construct parameters
    _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")

    # Construct headers
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="POST", url=_url, params=_params, headers=_headers, **kwargs)


def build_ingestions_ingestion_runs_get_request(  # pylint: disable=name-too-long
    collection_id: str, ingestion_id: str, run_id: str, **kwargs: Any
) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2025-04-30-preview"))
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/inma/collections/{collectionId}/ingestions/{ingestionId}/runs/{runId}"
    path_format_arguments = {
        "collectionId": _SERIALIZER.url("collection_id", collection_id, "str"),
        "ingestionId": _SERIALIZER.url("ingestion_id", ingestion_id, "str"),
        "runId": _SERIALIZER.url("run_id", run_id, "str"),
    }

    _url: str = _url.format(**path_format_arguments)  # type: ignore

    # Construct parameters
    _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")

    # Construct headers
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="GET", url=_url, params=_params, headers=_headers, **kwargs)


class IngestionsOperations:
    """
    .. warning::
        **DO NOT** instantiate this class directly.

        Instead, you should access the following operations through
        :class:`~azure.planetarycomputer.PlanetaryComputerClient`'s
        :attr:`ingestions` attribute.
    """

    def __init__(self, *args, **kwargs) -> None:
        input_args = list(args)
        self._client: PipelineClient = input_args.pop(0) if input_args else kwargs.pop("client")
        self._config: PlanetaryComputerClientConfiguration = input_args.pop(0) if input_args else kwargs.pop("config")
        self._serialize: Serializer = input_args.pop(0) if input_args else kwargs.pop("serializer")
        self._deserialize: Deserializer = input_args.pop(0) if input_args else kwargs.pop("deserializer")

        self.ingestion_runs = IngestionsIngestionRunsOperations(
            self._client, self._config, self._serialize, self._deserialize
        )

    @distributed_trace
    def list_all(
        self, collection_id: str, *, top: Optional[int] = None, skip: Optional[int] = None, **kwargs: Any
    ) -> _models.IngestionDefinitionsPagedResponse:
        """Get ingestions of a catalog.

        :param collection_id: Catalog collection id. Required.
        :type collection_id: str
        :keyword top: The number of items to return. Default value is None.
        :paramtype top: int
        :keyword skip: The number of items to skip. Default value is None.
        :paramtype skip: int
        :return: IngestionDefinitionsPagedResponse. The IngestionDefinitionsPagedResponse is compatible
         with MutableMapping
        :rtype: ~azure.planetarycomputer.models.IngestionDefinitionsPagedResponse
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[_models.IngestionDefinitionsPagedResponse] = kwargs.pop("cls", None)

        _request = build_ingestions_list_all_request(
            collection_id=collection_id,
            top=top,
            skip=skip,
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = kwargs.pop("stream", False)
        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                try:
                    response.read()  # Load the body in memory and close the socket
                except (StreamConsumedError, StreamClosedError):
                    pass
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if _stream:
            deserialized = response.iter_bytes()
        else:
            deserialized = _deserialize(_models.IngestionDefinitionsPagedResponse, response.json())

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore

    @overload
    def create(
        self,
        collection_id: str,
        definition: _models.IngestionDefinition,
        *,
        content_type: str = "application/json",
        **kwargs: Any,
    ) -> _models.IngestionDefinition:
        """Create a new ingestion.

        :param collection_id: Catalog collection id. Required.
        :type collection_id: str
        :param definition: Definition of the ingestion. Required.
        :type definition: ~azure.planetarycomputer.models.IngestionDefinition
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: IngestionDefinition. The IngestionDefinition is compatible with MutableMapping
        :rtype: ~azure.planetarycomputer.models.IngestionDefinition
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @overload
    def create(
        self, collection_id: str, definition: JSON, *, content_type: str = "application/json", **kwargs: Any
    ) -> _models.IngestionDefinition:
        """Create a new ingestion.

        :param collection_id: Catalog collection id. Required.
        :type collection_id: str
        :param definition: Definition of the ingestion. Required.
        :type definition: JSON
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: IngestionDefinition. The IngestionDefinition is compatible with MutableMapping
        :rtype: ~azure.planetarycomputer.models.IngestionDefinition
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @overload
    def create(
        self, collection_id: str, definition: IO[bytes], *, content_type: str = "application/json", **kwargs: Any
    ) -> _models.IngestionDefinition:
        """Create a new ingestion.

        :param collection_id: Catalog collection id. Required.
        :type collection_id: str
        :param definition: Definition of the ingestion. Required.
        :type definition: IO[bytes]
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: IngestionDefinition. The IngestionDefinition is compatible with MutableMapping
        :rtype: ~azure.planetarycomputer.models.IngestionDefinition
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @distributed_trace
    def create(
        self, collection_id: str, definition: Union[_models.IngestionDefinition, JSON, IO[bytes]], **kwargs: Any
    ) -> _models.IngestionDefinition:
        """Create a new ingestion.

        :param collection_id: Catalog collection id. Required.
        :type collection_id: str
        :param definition: Definition of the ingestion. Is one of the following types:
         IngestionDefinition, JSON, IO[bytes] Required.
        :type definition: ~azure.planetarycomputer.models.IngestionDefinition or JSON or IO[bytes]
        :return: IngestionDefinition. The IngestionDefinition is compatible with MutableMapping
        :rtype: ~azure.planetarycomputer.models.IngestionDefinition
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[_models.IngestionDefinition] = kwargs.pop("cls", None)

        content_type = content_type or "application/json"
        _content = None
        if isinstance(definition, (IOBase, bytes)):
            _content = definition
        else:
            _content = json.dumps(definition, cls=SdkJSONEncoder, exclude_readonly=True)  # type: ignore

        _request = build_ingestions_create_request(
            collection_id=collection_id,
            content_type=content_type,
            api_version=self._config.api_version,
            content=_content,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = kwargs.pop("stream", False)
        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [201]:
            if _stream:
                try:
                    response.read()  # Load the body in memory and close the socket
                except (StreamConsumedError, StreamClosedError):
                    pass
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        response_headers = {}
        response_headers["location"] = self._deserialize("str", response.headers.get("location"))

        if _stream:
            deserialized = response.iter_bytes()
        else:
            deserialized = _deserialize(_models.IngestionDefinition, response.json())

        if cls:
            return cls(pipeline_response, deserialized, response_headers)  # type: ignore

        return deserialized  # type: ignore

    @distributed_trace
    def get(self, collection_id: str, ingestion_id: str, **kwargs: Any) -> _models.IngestionDefinition:
        """Get the definition of an ingestion.

        :param collection_id: Catalog collection id. Required.
        :type collection_id: str
        :param ingestion_id: Ingestion id. Required.
        :type ingestion_id: str
        :return: IngestionDefinition. The IngestionDefinition is compatible with MutableMapping
        :rtype: ~azure.planetarycomputer.models.IngestionDefinition
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[_models.IngestionDefinition] = kwargs.pop("cls", None)

        _request = build_ingestions_get_request(
            collection_id=collection_id,
            ingestion_id=ingestion_id,
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = kwargs.pop("stream", False)
        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                try:
                    response.read()  # Load the body in memory and close the socket
                except (StreamConsumedError, StreamClosedError):
                    pass
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if _stream:
            deserialized = response.iter_bytes()
        else:
            deserialized = _deserialize(_models.IngestionDefinition, response.json())

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore

    @overload
    def update(
        self,
        collection_id: str,
        ingestion_id: str,
        definition: _models.IngestionDefinition,
        *,
        content_type: str = "application/merge-patch+json",
        **kwargs: Any,
    ) -> _models.IngestionDefinition:
        """Update an existing ingestion.

        :param collection_id: Catalog collection id. Required.
        :type collection_id: str
        :param ingestion_id: Ingestion id. Required.
        :type ingestion_id: str
        :param definition: Ingestion properties to update. Required.
        :type definition: ~azure.planetarycomputer.models.IngestionDefinition
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/merge-patch+json".
        :paramtype content_type: str
        :return: IngestionDefinition. The IngestionDefinition is compatible with MutableMapping
        :rtype: ~azure.planetarycomputer.models.IngestionDefinition
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @overload
    def update(
        self,
        collection_id: str,
        ingestion_id: str,
        definition: JSON,
        *,
        content_type: str = "application/merge-patch+json",
        **kwargs: Any,
    ) -> _models.IngestionDefinition:
        """Update an existing ingestion.

        :param collection_id: Catalog collection id. Required.
        :type collection_id: str
        :param ingestion_id: Ingestion id. Required.
        :type ingestion_id: str
        :param definition: Ingestion properties to update. Required.
        :type definition: JSON
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/merge-patch+json".
        :paramtype content_type: str
        :return: IngestionDefinition. The IngestionDefinition is compatible with MutableMapping
        :rtype: ~azure.planetarycomputer.models.IngestionDefinition
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @overload
    def update(
        self,
        collection_id: str,
        ingestion_id: str,
        definition: IO[bytes],
        *,
        content_type: str = "application/merge-patch+json",
        **kwargs: Any,
    ) -> _models.IngestionDefinition:
        """Update an existing ingestion.

        :param collection_id: Catalog collection id. Required.
        :type collection_id: str
        :param ingestion_id: Ingestion id. Required.
        :type ingestion_id: str
        :param definition: Ingestion properties to update. Required.
        :type definition: IO[bytes]
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Default value is "application/merge-patch+json".
        :paramtype content_type: str
        :return: IngestionDefinition. The IngestionDefinition is compatible with MutableMapping
        :rtype: ~azure.planetarycomputer.models.IngestionDefinition
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @distributed_trace
    def update(
        self,
        collection_id: str,
        ingestion_id: str,
        definition: Union[_models.IngestionDefinition, JSON, IO[bytes]],
        **kwargs: Any,
    ) -> _models.IngestionDefinition:
        """Update an existing ingestion.

        :param collection_id: Catalog collection id. Required.
        :type collection_id: str
        :param ingestion_id: Ingestion id. Required.
        :type ingestion_id: str
        :param definition: Ingestion properties to update. Is one of the following types:
         IngestionDefinition, JSON, IO[bytes] Required.
        :type definition: ~azure.planetarycomputer.models.IngestionDefinition or JSON or IO[bytes]
        :return: IngestionDefinition. The IngestionDefinition is compatible with MutableMapping
        :rtype: ~azure.planetarycomputer.models.IngestionDefinition
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("content-type", None))
        cls: ClsType[_models.IngestionDefinition] = kwargs.pop("cls", None)

        content_type = content_type or "application/merge-patch+json"
        _content = None
        if isinstance(definition, (IOBase, bytes)):
            _content = definition
        else:
            _content = json.dumps(definition, cls=SdkJSONEncoder, exclude_readonly=True)  # type: ignore

        _request = build_ingestions_update_request(
            collection_id=collection_id,
            ingestion_id=ingestion_id,
            content_type=content_type,
            api_version=self._config.api_version,
            content=_content,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = kwargs.pop("stream", False)
        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                try:
                    response.read()  # Load the body in memory and close the socket
                except (StreamConsumedError, StreamClosedError):
                    pass
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if _stream:
            deserialized = response.iter_bytes()
        else:
            deserialized = _deserialize(_models.IngestionDefinition, response.json())

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore

    def _delete_initial(self, collection_id: str, ingestion_id: str, **kwargs: Any) -> Iterator[bytes]:
        error_map: MutableMapping = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[Iterator[bytes]] = kwargs.pop("cls", None)

        _request = build_ingestions_delete_request(
            collection_id=collection_id,
            ingestion_id=ingestion_id,
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = True
        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [202]:
            try:
                response.read()  # Load the body in memory and close the socket
            except (StreamConsumedError, StreamClosedError):
                pass
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        response_headers = {}
        response_headers["location"] = self._deserialize("str", response.headers.get("location"))
        response_headers["operation-location"] = self._deserialize("str", response.headers.get("operation-location"))

        deserialized = response.iter_bytes()

        if cls:
            return cls(pipeline_response, deserialized, response_headers)  # type: ignore

        return deserialized  # type: ignore

    @distributed_trace
    def begin_delete(self, collection_id: str, ingestion_id: str, **kwargs: Any) -> LROPoller[None]:
        """Delete an ingestion from a catalog. All runs of the ingestion will be deleted. Ingestion must
        not have any runs in progress or queued.

        :param collection_id: Catalog collection id. Required.
        :type collection_id: str
        :param ingestion_id: Ingestion id. Required.
        :type ingestion_id: str
        :return: An instance of LROPoller that returns None
        :rtype: ~azure.core.polling.LROPoller[None]
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[None] = kwargs.pop("cls", None)
        polling: Union[bool, PollingMethod] = kwargs.pop("polling", True)
        lro_delay = kwargs.pop("polling_interval", self._config.polling_interval)
        cont_token: Optional[str] = kwargs.pop("continuation_token", None)
        if cont_token is None:
            raw_result = self._delete_initial(
                collection_id=collection_id,
                ingestion_id=ingestion_id,
                cls=lambda x, y, z: x,
                headers=_headers,
                params=_params,
                **kwargs,
            )
            raw_result.http_response.read()  # type: ignore
        kwargs.pop("error_map", None)

        def get_long_running_output(pipeline_response):  # pylint: disable=inconsistent-return-statements
            if cls:
                return cls(pipeline_response, None, {})  # type: ignore

        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, "str", skip_quote=True),
        }

        if polling is True:
            polling_method: PollingMethod = cast(
                PollingMethod, LROBasePolling(lro_delay, path_format_arguments=path_format_arguments, **kwargs)
            )
        elif polling is False:
            polling_method = cast(PollingMethod, NoPolling())
        else:
            polling_method = polling
        if cont_token:
            return LROPoller[None].from_continuation_token(
                polling_method=polling_method,
                continuation_token=cont_token,
                client=self._client,
                deserialization_callback=get_long_running_output,
            )
        return LROPoller[None](self._client, raw_result, get_long_running_output, polling_method)  # type: ignore


class StacItemsOperations:
    """
    .. warning::
        **DO NOT** instantiate this class directly.

        Instead, you should access the following operations through
        :class:`~azure.planetarycomputer.PlanetaryComputerClient`'s
        :attr:`stac_items` attribute.
    """

    def __init__(self, *args, **kwargs) -> None:
        input_args = list(args)
        self._client: PipelineClient = input_args.pop(0) if input_args else kwargs.pop("client")
        self._config: PlanetaryComputerClientConfiguration = input_args.pop(0) if input_args else kwargs.pop("config")
        self._serialize: Serializer = input_args.pop(0) if input_args else kwargs.pop("serializer")
        self._deserialize: Deserializer = input_args.pop(0) if input_args else kwargs.pop("deserializer")

    @distributed_trace
    def get_features(
        self,
        collection_id: str,
        *,
        limit: Optional[int] = None,
        bbox: Optional[List[str]] = None,
        datetime: Optional[str] = None,
        **kwargs: Any,
    ) -> _models.ItemCollection:
        """Fetch features of the feature collection with id ``collectionId``.

        Every feature in a dataset belongs to a collection. A dataset may
        consist of multiple feature collections. A feature collection is often a
        collection of features of a similar type, based on a common schema.").

        :param collection_id: Catalog collection id. Required.
        :type collection_id: str
        :keyword limit: The optional limit parameter recommends the number of items that should be
         present in the response document.

         If the limit parameter value is greater than advertised limit maximum, the server must return
         the
         maximum possible number of items, rather than responding with an error.

         Only items are counted that are on the first level of the collection in the response document.
         Nested objects contained within the explicitly requested items must not be counted.

         Minimum = 1. Maximum = 10000. Default = 10. Default value is None.
        :paramtype limit: int
        :keyword bbox: Only features that have a geometry that intersects the bounding box are
         selected.
         The bounding box is provided as four or six numbers, depending on whether the
         coordinate reference system includes a vertical axis (height or depth):



         * Lower left corner, coordinate axis 1
         * Lower left corner, coordinate axis 2
         * Minimum value, coordinate axis 3 (optional)
         * Upper right corner, coordinate axis 1
         * Upper right corner, coordinate axis 2
         * Maximum value, coordinate axis 3 (optional)

         The coordinate reference system of the values is WGS 84 longitude/latitude
         (`http://www.opengis.net/def/crs/OGC/1.3/CRS84
         <http://www.opengis.net/def/crs/OGC/1.3/CRS84>`_).

         For WGS 84 longitude/latitude the values are in most cases the sequence of
         minimum longitude, minimum latitude, maximum longitude and maximum latitude.
         However, in cases where the box spans the antimeridian the first value
         (west-most box edge) is larger than the third value (east-most box edge).

         If the vertical axis is included, the third and the sixth number are
         the bottom and the top of the 3-dimensional bounding box.

         If a feature has multiple spatial geometry properties, it is the decision of the
         server whether only a single spatial geometry property is used to determine
         the extent or all relevant geometries. Default value is None.
        :paramtype bbox: list[str]
        :keyword datetime: Either a date-time or an interval, open or closed. Date and time expressions
         adhere to RFC 3339. Open intervals are expressed using double-dots.

         Examples:



         * A date-time: "2018-02-12T23:20:50Z"
         * A closed interval: "2018-02-12T00:00:00Z/2018-03-18T12:31:12Z"
         * Open intervals: "2018-02-12T00:00:00Z/.." or "../2018-03-18T12:31:12Z"

         Only features that have a temporal property that intersects the value of
         ``datetime`` are selected.

         If a feature has multiple temporal properties, it is the decision of the
         server whether only a single temporal property is used to determine
         the extent or all relevant temporal properties. Default value is None.
        :paramtype datetime: str
        :return: ItemCollection. The ItemCollection is compatible with MutableMapping
        :rtype: ~azure.planetarycomputer.models.ItemCollection
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[_models.ItemCollection] = kwargs.pop("cls", None)

        _request = build_stac_items_get_features_request(
            collection_id=collection_id,
            limit=limit,
            bbox=bbox,
            datetime=datetime,
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = kwargs.pop("stream", False)
        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                try:
                    response.read()  # Load the body in memory and close the socket
                except (StreamConsumedError, StreamClosedError):
                    pass
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if _stream:
            deserialized = response.iter_bytes()
        else:
            deserialized = _deserialize(_models.ItemCollection, response.json())

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore

    def _create_initial(
        self, collection_id: str, body: Union[_models.StacItemOrItemCollection, JSON, IO[bytes]], **kwargs: Any
    ) -> Iterator[bytes]:
        error_map: MutableMapping = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[Iterator[bytes]] = kwargs.pop("cls", None)

        content_type = content_type or "application/json"
        _content = None
        if isinstance(body, (IOBase, bytes)):
            _content = body
        else:
            _content = json.dumps(body, cls=SdkJSONEncoder, exclude_readonly=True)  # type: ignore

        _request = build_stac_items_create_request(
            collection_id=collection_id,
            content_type=content_type,
            api_version=self._config.api_version,
            content=_content,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = True
        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [202]:
            try:
                response.read()  # Load the body in memory and close the socket
            except (StreamConsumedError, StreamClosedError):
                pass
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        response_headers = {}
        response_headers["location"] = self._deserialize("str", response.headers.get("location"))
        response_headers["operation-location"] = self._deserialize("str", response.headers.get("operation-location"))

        deserialized = response.iter_bytes()

        if cls:
            return cls(pipeline_response, deserialized, response_headers)  # type: ignore

        return deserialized  # type: ignore

    @overload
    def begin_create(
        self,
        collection_id: str,
        body: _models.StacItemOrItemCollection,
        *,
        content_type: str = "application/json",
        **kwargs: Any,
    ) -> LROPoller[None]:
        """Create a new STAC item or a set of items in a collection.

        :param collection_id: Catalog collection id. Required.
        :type collection_id: str
        :param body: STAC Item or ItemCollection

         Represents a STAC Item or ItemCollection as defined by the STAC 1.0.0 standard.

         **Item**: A GeoJSON Feature that represents a single spatiotemporal asset.
         It includes metadata such as geometry, datetime, and links to related assets.
         Example: A satellite image with its metadata.

         **ItemCollection**: A GeoJSON FeatureCollection that contains multiple Items.
         It is used to group multiple related Items together, such as a collection of satellite images.

         This union allows the request body to accept either a single Item or a collection of Items.
         Required.
        :type body: ~azure.planetarycomputer.models.StacItemOrItemCollection
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: An instance of LROPoller that returns None
        :rtype: ~azure.core.polling.LROPoller[None]
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @overload
    def begin_create(
        self, collection_id: str, body: JSON, *, content_type: str = "application/json", **kwargs: Any
    ) -> LROPoller[None]:
        """Create a new STAC item or a set of items in a collection.

        :param collection_id: Catalog collection id. Required.
        :type collection_id: str
        :param body: STAC Item or ItemCollection

         Represents a STAC Item or ItemCollection as defined by the STAC 1.0.0 standard.

         **Item**: A GeoJSON Feature that represents a single spatiotemporal asset.
         It includes metadata such as geometry, datetime, and links to related assets.
         Example: A satellite image with its metadata.

         **ItemCollection**: A GeoJSON FeatureCollection that contains multiple Items.
         It is used to group multiple related Items together, such as a collection of satellite images.

         This union allows the request body to accept either a single Item or a collection of Items.
         Required.
        :type body: JSON
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: An instance of LROPoller that returns None
        :rtype: ~azure.core.polling.LROPoller[None]
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @overload
    def begin_create(
        self, collection_id: str, body: IO[bytes], *, content_type: str = "application/json", **kwargs: Any
    ) -> LROPoller[None]:
        """Create a new STAC item or a set of items in a collection.

        :param collection_id: Catalog collection id. Required.
        :type collection_id: str
        :param body: STAC Item or ItemCollection

         Represents a STAC Item or ItemCollection as defined by the STAC 1.0.0 standard.

         **Item**: A GeoJSON Feature that represents a single spatiotemporal asset.
         It includes metadata such as geometry, datetime, and links to related assets.
         Example: A satellite image with its metadata.

         **ItemCollection**: A GeoJSON FeatureCollection that contains multiple Items.
         It is used to group multiple related Items together, such as a collection of satellite images.

         This union allows the request body to accept either a single Item or a collection of Items.
         Required.
        :type body: IO[bytes]
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: An instance of LROPoller that returns None
        :rtype: ~azure.core.polling.LROPoller[None]
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @distributed_trace
    def begin_create(
        self, collection_id: str, body: Union[_models.StacItemOrItemCollection, JSON, IO[bytes]], **kwargs: Any
    ) -> LROPoller[None]:
        """Create a new STAC item or a set of items in a collection.

        :param collection_id: Catalog collection id. Required.
        :type collection_id: str
        :param body: STAC Item or ItemCollection

         Represents a STAC Item or ItemCollection as defined by the STAC 1.0.0 standard.

         **Item**: A GeoJSON Feature that represents a single spatiotemporal asset.
         It includes metadata such as geometry, datetime, and links to related assets.
         Example: A satellite image with its metadata.

         **ItemCollection**: A GeoJSON FeatureCollection that contains multiple Items.
         It is used to group multiple related Items together, such as a collection of satellite images.

         This union allows the request body to accept either a single Item or a collection of Items. Is
         one of the following types: StacItemOrItemCollection, JSON, IO[bytes] Required.
        :type body: ~azure.planetarycomputer.models.StacItemOrItemCollection or JSON or IO[bytes]
        :return: An instance of LROPoller that returns None
        :rtype: ~azure.core.polling.LROPoller[None]
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[None] = kwargs.pop("cls", None)
        polling: Union[bool, PollingMethod] = kwargs.pop("polling", True)
        lro_delay = kwargs.pop("polling_interval", self._config.polling_interval)
        cont_token: Optional[str] = kwargs.pop("continuation_token", None)
        if cont_token is None:
            raw_result = self._create_initial(
                collection_id=collection_id,
                body=body,
                content_type=content_type,
                cls=lambda x, y, z: x,
                headers=_headers,
                params=_params,
                **kwargs,
            )
            raw_result.http_response.read()  # type: ignore
        kwargs.pop("error_map", None)

        def get_long_running_output(pipeline_response):  # pylint: disable=inconsistent-return-statements
            if cls:
                return cls(pipeline_response, None, {})  # type: ignore

        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, "str", skip_quote=True),
        }

        if polling is True:
            polling_method: PollingMethod = cast(
                PollingMethod, LROBasePolling(lro_delay, path_format_arguments=path_format_arguments, **kwargs)
            )
        elif polling is False:
            polling_method = cast(PollingMethod, NoPolling())
        else:
            polling_method = polling
        if cont_token:
            return LROPoller[None].from_continuation_token(
                polling_method=polling_method,
                continuation_token=cont_token,
                client=self._client,
                deserialization_callback=get_long_running_output,
            )
        return LROPoller[None](self._client, raw_result, get_long_running_output, polling_method)  # type: ignore

    @distributed_trace
    def get(self, collection_id: str, item_id: str, **kwargs: Any) -> _models.StacItem:
        """Fetch a single STAC Item.

        :param collection_id: Catalog collection id. Required.
        :type collection_id: str
        :param item_id: STAC Item id. Required.
        :type item_id: str
        :return: StacItem. The StacItem is compatible with MutableMapping
        :rtype: ~azure.planetarycomputer.models.StacItem
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[_models.StacItem] = kwargs.pop("cls", None)

        _request = build_stac_items_get_request(
            collection_id=collection_id,
            item_id=item_id,
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = kwargs.pop("stream", False)
        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                try:
                    response.read()  # Load the body in memory and close the socket
                except (StreamConsumedError, StreamClosedError):
                    pass
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if _stream:
            deserialized = response.iter_bytes()
        else:
            deserialized = _deserialize(_models.StacItem, response.json())

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore

    def _create_or_replace_initial(
        self, collection_id: str, item_id: str, body: Union[_models.StacItem, JSON, IO[bytes]], **kwargs: Any
    ) -> Iterator[bytes]:
        error_map: MutableMapping = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[Iterator[bytes]] = kwargs.pop("cls", None)

        content_type = content_type or "application/json"
        _content = None
        if isinstance(body, (IOBase, bytes)):
            _content = body
        else:
            _content = json.dumps(body, cls=SdkJSONEncoder, exclude_readonly=True)  # type: ignore

        _request = build_stac_items_create_or_replace_request(
            collection_id=collection_id,
            item_id=item_id,
            content_type=content_type,
            api_version=self._config.api_version,
            content=_content,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = True
        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [202]:
            try:
                response.read()  # Load the body in memory and close the socket
            except (StreamConsumedError, StreamClosedError):
                pass
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        response_headers = {}
        response_headers["location"] = self._deserialize("str", response.headers.get("location"))
        response_headers["operation-location"] = self._deserialize("str", response.headers.get("operation-location"))

        deserialized = response.iter_bytes()

        if cls:
            return cls(pipeline_response, deserialized, response_headers)  # type: ignore

        return deserialized  # type: ignore

    @overload
    def begin_create_or_replace(
        self,
        collection_id: str,
        item_id: str,
        body: _models.StacItem,
        *,
        content_type: str = "application/json",
        **kwargs: Any,
    ) -> LROPoller[None]:
        """Create or replace a STAC item in a collection.

        :param collection_id: Catalog collection id. Required.
        :type collection_id: str
        :param item_id: STAC Item id. Required.
        :type item_id: str
        :param body: STAC Item. Required.
        :type body: ~azure.planetarycomputer.models.StacItem
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: An instance of LROPoller that returns None
        :rtype: ~azure.core.polling.LROPoller[None]
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @overload
    def begin_create_or_replace(
        self, collection_id: str, item_id: str, body: JSON, *, content_type: str = "application/json", **kwargs: Any
    ) -> LROPoller[None]:
        """Create or replace a STAC item in a collection.

        :param collection_id: Catalog collection id. Required.
        :type collection_id: str
        :param item_id: STAC Item id. Required.
        :type item_id: str
        :param body: STAC Item. Required.
        :type body: JSON
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: An instance of LROPoller that returns None
        :rtype: ~azure.core.polling.LROPoller[None]
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @overload
    def begin_create_or_replace(
        self,
        collection_id: str,
        item_id: str,
        body: IO[bytes],
        *,
        content_type: str = "application/json",
        **kwargs: Any,
    ) -> LROPoller[None]:
        """Create or replace a STAC item in a collection.

        :param collection_id: Catalog collection id. Required.
        :type collection_id: str
        :param item_id: STAC Item id. Required.
        :type item_id: str
        :param body: STAC Item. Required.
        :type body: IO[bytes]
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: An instance of LROPoller that returns None
        :rtype: ~azure.core.polling.LROPoller[None]
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @distributed_trace
    def begin_create_or_replace(
        self, collection_id: str, item_id: str, body: Union[_models.StacItem, JSON, IO[bytes]], **kwargs: Any
    ) -> LROPoller[None]:
        """Create or replace a STAC item in a collection.

        :param collection_id: Catalog collection id. Required.
        :type collection_id: str
        :param item_id: STAC Item id. Required.
        :type item_id: str
        :param body: STAC Item. Is one of the following types: StacItem, JSON, IO[bytes] Required.
        :type body: ~azure.planetarycomputer.models.StacItem or JSON or IO[bytes]
        :return: An instance of LROPoller that returns None
        :rtype: ~azure.core.polling.LROPoller[None]
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[None] = kwargs.pop("cls", None)
        polling: Union[bool, PollingMethod] = kwargs.pop("polling", True)
        lro_delay = kwargs.pop("polling_interval", self._config.polling_interval)
        cont_token: Optional[str] = kwargs.pop("continuation_token", None)
        if cont_token is None:
            raw_result = self._create_or_replace_initial(
                collection_id=collection_id,
                item_id=item_id,
                body=body,
                content_type=content_type,
                cls=lambda x, y, z: x,
                headers=_headers,
                params=_params,
                **kwargs,
            )
            raw_result.http_response.read()  # type: ignore
        kwargs.pop("error_map", None)

        def get_long_running_output(pipeline_response):  # pylint: disable=inconsistent-return-statements
            if cls:
                return cls(pipeline_response, None, {})  # type: ignore

        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, "str", skip_quote=True),
        }

        if polling is True:
            polling_method: PollingMethod = cast(
                PollingMethod, LROBasePolling(lro_delay, path_format_arguments=path_format_arguments, **kwargs)
            )
        elif polling is False:
            polling_method = cast(PollingMethod, NoPolling())
        else:
            polling_method = polling
        if cont_token:
            return LROPoller[None].from_continuation_token(
                polling_method=polling_method,
                continuation_token=cont_token,
                client=self._client,
                deserialization_callback=get_long_running_output,
            )
        return LROPoller[None](self._client, raw_result, get_long_running_output, polling_method)  # type: ignore

    def _update_initial(
        self, collection_id: str, item_id: str, body: Union[_models.StacItem, JSON, IO[bytes]], **kwargs: Any
    ) -> Iterator[bytes]:
        error_map: MutableMapping = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("content-type", None))
        cls: ClsType[Iterator[bytes]] = kwargs.pop("cls", None)

        content_type = content_type or "application/merge-patch+json"
        _content = None
        if isinstance(body, (IOBase, bytes)):
            _content = body
        else:
            _content = json.dumps(body, cls=SdkJSONEncoder, exclude_readonly=True)  # type: ignore

        _request = build_stac_items_update_request(
            collection_id=collection_id,
            item_id=item_id,
            content_type=content_type,
            api_version=self._config.api_version,
            content=_content,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = True
        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [202]:
            try:
                response.read()  # Load the body in memory and close the socket
            except (StreamConsumedError, StreamClosedError):
                pass
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        response_headers = {}
        response_headers["location"] = self._deserialize("str", response.headers.get("location"))
        response_headers["operation-location"] = self._deserialize("str", response.headers.get("operation-location"))

        deserialized = response.iter_bytes()

        if cls:
            return cls(pipeline_response, deserialized, response_headers)  # type: ignore

        return deserialized  # type: ignore

    @overload
    def begin_update(
        self,
        collection_id: str,
        item_id: str,
        body: _models.StacItem,
        *,
        content_type: str = "application/merge-patch+json",
        **kwargs: Any,
    ) -> LROPoller[None]:
        """Update a STAC item in a collection.

        :param collection_id: Catalog collection id. Required.
        :type collection_id: str
        :param item_id: STAC Item id. Required.
        :type item_id: str
        :param body: STAC Item. Required.
        :type body: ~azure.planetarycomputer.models.StacItem
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/merge-patch+json".
        :paramtype content_type: str
        :return: An instance of LROPoller that returns None
        :rtype: ~azure.core.polling.LROPoller[None]
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @overload
    def begin_update(
        self,
        collection_id: str,
        item_id: str,
        body: JSON,
        *,
        content_type: str = "application/merge-patch+json",
        **kwargs: Any,
    ) -> LROPoller[None]:
        """Update a STAC item in a collection.

        :param collection_id: Catalog collection id. Required.
        :type collection_id: str
        :param item_id: STAC Item id. Required.
        :type item_id: str
        :param body: STAC Item. Required.
        :type body: JSON
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/merge-patch+json".
        :paramtype content_type: str
        :return: An instance of LROPoller that returns None
        :rtype: ~azure.core.polling.LROPoller[None]
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @overload
    def begin_update(
        self,
        collection_id: str,
        item_id: str,
        body: IO[bytes],
        *,
        content_type: str = "application/merge-patch+json",
        **kwargs: Any,
    ) -> LROPoller[None]:
        """Update a STAC item in a collection.

        :param collection_id: Catalog collection id. Required.
        :type collection_id: str
        :param item_id: STAC Item id. Required.
        :type item_id: str
        :param body: STAC Item. Required.
        :type body: IO[bytes]
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Default value is "application/merge-patch+json".
        :paramtype content_type: str
        :return: An instance of LROPoller that returns None
        :rtype: ~azure.core.polling.LROPoller[None]
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @distributed_trace
    def begin_update(
        self, collection_id: str, item_id: str, body: Union[_models.StacItem, JSON, IO[bytes]], **kwargs: Any
    ) -> LROPoller[None]:
        """Update a STAC item in a collection.

        :param collection_id: Catalog collection id. Required.
        :type collection_id: str
        :param item_id: STAC Item id. Required.
        :type item_id: str
        :param body: STAC Item. Is one of the following types: StacItem, JSON, IO[bytes] Required.
        :type body: ~azure.planetarycomputer.models.StacItem or JSON or IO[bytes]
        :return: An instance of LROPoller that returns None
        :rtype: ~azure.core.polling.LROPoller[None]
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("content-type", None))
        cls: ClsType[None] = kwargs.pop("cls", None)
        polling: Union[bool, PollingMethod] = kwargs.pop("polling", True)
        lro_delay = kwargs.pop("polling_interval", self._config.polling_interval)
        cont_token: Optional[str] = kwargs.pop("continuation_token", None)
        if cont_token is None:
            raw_result = self._update_initial(
                collection_id=collection_id,
                item_id=item_id,
                body=body,
                content_type=content_type,
                cls=lambda x, y, z: x,
                headers=_headers,
                params=_params,
                **kwargs,
            )
            raw_result.http_response.read()  # type: ignore
        kwargs.pop("error_map", None)

        def get_long_running_output(pipeline_response):  # pylint: disable=inconsistent-return-statements
            if cls:
                return cls(pipeline_response, None, {})  # type: ignore

        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, "str", skip_quote=True),
        }

        if polling is True:
            polling_method: PollingMethod = cast(
                PollingMethod, LROBasePolling(lro_delay, path_format_arguments=path_format_arguments, **kwargs)
            )
        elif polling is False:
            polling_method = cast(PollingMethod, NoPolling())
        else:
            polling_method = polling
        if cont_token:
            return LROPoller[None].from_continuation_token(
                polling_method=polling_method,
                continuation_token=cont_token,
                client=self._client,
                deserialization_callback=get_long_running_output,
            )
        return LROPoller[None](self._client, raw_result, get_long_running_output, polling_method)  # type: ignore

    def _delete_initial(self, collection_id: str, item_id: str, **kwargs: Any) -> Iterator[bytes]:
        error_map: MutableMapping = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[Iterator[bytes]] = kwargs.pop("cls", None)

        _request = build_stac_items_delete_request(
            collection_id=collection_id,
            item_id=item_id,
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = True
        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [202]:
            try:
                response.read()  # Load the body in memory and close the socket
            except (StreamConsumedError, StreamClosedError):
                pass
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        response_headers = {}
        response_headers["location"] = self._deserialize("str", response.headers.get("location"))
        response_headers["operation-location"] = self._deserialize("str", response.headers.get("operation-location"))

        deserialized = response.iter_bytes()

        if cls:
            return cls(pipeline_response, deserialized, response_headers)  # type: ignore

        return deserialized  # type: ignore

    @distributed_trace
    def begin_delete(self, collection_id: str, item_id: str, **kwargs: Any) -> LROPoller[None]:
        """Delete a STAC item from a collection.

        :param collection_id: Catalog collection id. Required.
        :type collection_id: str
        :param item_id: STAC Item id. Required.
        :type item_id: str
        :return: An instance of LROPoller that returns None
        :rtype: ~azure.core.polling.LROPoller[None]
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[None] = kwargs.pop("cls", None)
        polling: Union[bool, PollingMethod] = kwargs.pop("polling", True)
        lro_delay = kwargs.pop("polling_interval", self._config.polling_interval)
        cont_token: Optional[str] = kwargs.pop("continuation_token", None)
        if cont_token is None:
            raw_result = self._delete_initial(
                collection_id=collection_id,
                item_id=item_id,
                cls=lambda x, y, z: x,
                headers=_headers,
                params=_params,
                **kwargs,
            )
            raw_result.http_response.read()  # type: ignore
        kwargs.pop("error_map", None)

        def get_long_running_output(pipeline_response):  # pylint: disable=inconsistent-return-statements
            if cls:
                return cls(pipeline_response, None, {})  # type: ignore

        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, "str", skip_quote=True),
        }

        if polling is True:
            polling_method: PollingMethod = cast(
                PollingMethod, LROBasePolling(lro_delay, path_format_arguments=path_format_arguments, **kwargs)
            )
        elif polling is False:
            polling_method = cast(PollingMethod, NoPolling())
        else:
            polling_method = polling
        if cont_token:
            return LROPoller[None].from_continuation_token(
                polling_method=polling_method,
                continuation_token=cont_token,
                client=self._client,
                deserialization_callback=get_long_running_output,
            )
        return LROPoller[None](self._client, raw_result, get_long_running_output, polling_method)  # type: ignore


class IngestionSourcesOperations:
    """
    .. warning::
        **DO NOT** instantiate this class directly.

        Instead, you should access the following operations through
        :class:`~azure.planetarycomputer.PlanetaryComputerClient`'s
        :attr:`ingestion_sources` attribute.
    """

    def __init__(self, *args, **kwargs) -> None:
        input_args = list(args)
        self._client: PipelineClient = input_args.pop(0) if input_args else kwargs.pop("client")
        self._config: PlanetaryComputerClientConfiguration = input_args.pop(0) if input_args else kwargs.pop("config")
        self._serialize: Serializer = input_args.pop(0) if input_args else kwargs.pop("serializer")
        self._deserialize: Deserializer = input_args.pop(0) if input_args else kwargs.pop("deserializer")

    @distributed_trace
    def list_all(
        self, *, top: Optional[int] = None, skip: Optional[int] = None, **kwargs: Any
    ) -> _models.IngestionSourcesPagedResponse:
        """Get ingestion sources in a geo-catalog.

        :keyword top: The number of items to return. Default value is None.
        :paramtype top: int
        :keyword skip: The number of items to skip. Default value is None.
        :paramtype skip: int
        :return: IngestionSourcesPagedResponse. The IngestionSourcesPagedResponse is compatible with
         MutableMapping
        :rtype: ~azure.planetarycomputer.models.IngestionSourcesPagedResponse
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[_models.IngestionSourcesPagedResponse] = kwargs.pop("cls", None)

        _request = build_ingestion_sources_list_all_request(
            top=top,
            skip=skip,
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = kwargs.pop("stream", False)
        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                try:
                    response.read()  # Load the body in memory and close the socket
                except (StreamConsumedError, StreamClosedError):
                    pass
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if _stream:
            deserialized = response.iter_bytes()
        else:
            deserialized = _deserialize(_models.IngestionSourcesPagedResponse, response.json())

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore

    @overload
    def create(
        self, ingestion_source: _models.IngestionSource, *, content_type: str = "application/json", **kwargs: Any
    ) -> _models.IngestionSource:
        """Create a new ingestion source in a geo-catalog.

        :param ingestion_source: Definition of the ingestion source. Required.
        :type ingestion_source: ~azure.planetarycomputer.models.IngestionSource
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: IngestionSource. The IngestionSource is compatible with MutableMapping
        :rtype: ~azure.planetarycomputer.models.IngestionSource
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @overload
    def create(
        self, ingestion_source: JSON, *, content_type: str = "application/json", **kwargs: Any
    ) -> _models.IngestionSource:
        """Create a new ingestion source in a geo-catalog.

        :param ingestion_source: Definition of the ingestion source. Required.
        :type ingestion_source: JSON
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: IngestionSource. The IngestionSource is compatible with MutableMapping
        :rtype: ~azure.planetarycomputer.models.IngestionSource
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @overload
    def create(
        self, ingestion_source: IO[bytes], *, content_type: str = "application/json", **kwargs: Any
    ) -> _models.IngestionSource:
        """Create a new ingestion source in a geo-catalog.

        :param ingestion_source: Definition of the ingestion source. Required.
        :type ingestion_source: IO[bytes]
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: IngestionSource. The IngestionSource is compatible with MutableMapping
        :rtype: ~azure.planetarycomputer.models.IngestionSource
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @distributed_trace
    def create(
        self, ingestion_source: Union[_models.IngestionSource, JSON, IO[bytes]], **kwargs: Any
    ) -> _models.IngestionSource:
        """Create a new ingestion source in a geo-catalog.

        :param ingestion_source: Definition of the ingestion source. Is one of the following types:
         IngestionSource, JSON, IO[bytes] Required.
        :type ingestion_source: ~azure.planetarycomputer.models.IngestionSource or JSON or IO[bytes]
        :return: IngestionSource. The IngestionSource is compatible with MutableMapping
        :rtype: ~azure.planetarycomputer.models.IngestionSource
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[_models.IngestionSource] = kwargs.pop("cls", None)

        content_type = content_type or "application/json"
        _content = None
        if isinstance(ingestion_source, (IOBase, bytes)):
            _content = ingestion_source
        else:
            _content = json.dumps(ingestion_source, cls=SdkJSONEncoder, exclude_readonly=True)  # type: ignore

        _request = build_ingestion_sources_create_request(
            content_type=content_type,
            api_version=self._config.api_version,
            content=_content,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = kwargs.pop("stream", False)
        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [201]:
            if _stream:
                try:
                    response.read()  # Load the body in memory and close the socket
                except (StreamConsumedError, StreamClosedError):
                    pass
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        response_headers = {}
        response_headers["location"] = self._deserialize("str", response.headers.get("location"))

        if _stream:
            deserialized = response.iter_bytes()
        else:
            deserialized = _deserialize(_models.IngestionSource, response.json())

        if cls:
            return cls(pipeline_response, deserialized, response_headers)  # type: ignore

        return deserialized  # type: ignore

    @distributed_trace
    def get(self, id: str, **kwargs: Any) -> _models.IngestionSource:
        """Get an ingestion source in a geo-catalog.

        :param id: Ingestion source id. Required.
        :type id: str
        :return: IngestionSource. The IngestionSource is compatible with MutableMapping
        :rtype: ~azure.planetarycomputer.models.IngestionSource
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[_models.IngestionSource] = kwargs.pop("cls", None)

        _request = build_ingestion_sources_get_request(
            id=id,
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = kwargs.pop("stream", False)
        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                try:
                    response.read()  # Load the body in memory and close the socket
                except (StreamConsumedError, StreamClosedError):
                    pass
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if _stream:
            deserialized = response.iter_bytes()
        else:
            deserialized = _deserialize(_models.IngestionSource, response.json())

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore

    @overload
    def create_or_replace(
        self,
        id: str,
        ingestion_source: _models.IngestionSource,
        *,
        content_type: str = "application/json",
        **kwargs: Any,
    ) -> _models.IngestionSource:
        """Update an existing ingestion source in a geo-catalog.

        :param id: Ingestion source id. Required.
        :type id: str
        :param ingestion_source: Definition of the ingestion source. Required.
        :type ingestion_source: ~azure.planetarycomputer.models.IngestionSource
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: IngestionSource. The IngestionSource is compatible with MutableMapping
        :rtype: ~azure.planetarycomputer.models.IngestionSource
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @overload
    def create_or_replace(
        self, id: str, ingestion_source: JSON, *, content_type: str = "application/json", **kwargs: Any
    ) -> _models.IngestionSource:
        """Update an existing ingestion source in a geo-catalog.

        :param id: Ingestion source id. Required.
        :type id: str
        :param ingestion_source: Definition of the ingestion source. Required.
        :type ingestion_source: JSON
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: IngestionSource. The IngestionSource is compatible with MutableMapping
        :rtype: ~azure.planetarycomputer.models.IngestionSource
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @overload
    def create_or_replace(
        self, id: str, ingestion_source: IO[bytes], *, content_type: str = "application/json", **kwargs: Any
    ) -> _models.IngestionSource:
        """Update an existing ingestion source in a geo-catalog.

        :param id: Ingestion source id. Required.
        :type id: str
        :param ingestion_source: Definition of the ingestion source. Required.
        :type ingestion_source: IO[bytes]
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: IngestionSource. The IngestionSource is compatible with MutableMapping
        :rtype: ~azure.planetarycomputer.models.IngestionSource
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @distributed_trace
    def create_or_replace(
        self, id: str, ingestion_source: Union[_models.IngestionSource, JSON, IO[bytes]], **kwargs: Any
    ) -> _models.IngestionSource:
        """Update an existing ingestion source in a geo-catalog.

        :param id: Ingestion source id. Required.
        :type id: str
        :param ingestion_source: Definition of the ingestion source. Is one of the following types:
         IngestionSource, JSON, IO[bytes] Required.
        :type ingestion_source: ~azure.planetarycomputer.models.IngestionSource or JSON or IO[bytes]
        :return: IngestionSource. The IngestionSource is compatible with MutableMapping
        :rtype: ~azure.planetarycomputer.models.IngestionSource
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[_models.IngestionSource] = kwargs.pop("cls", None)

        content_type = content_type or "application/json"
        _content = None
        if isinstance(ingestion_source, (IOBase, bytes)):
            _content = ingestion_source
        else:
            _content = json.dumps(ingestion_source, cls=SdkJSONEncoder, exclude_readonly=True)  # type: ignore

        _request = build_ingestion_sources_create_or_replace_request(
            id=id,
            content_type=content_type,
            api_version=self._config.api_version,
            content=_content,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = kwargs.pop("stream", False)
        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200, 201]:
            if _stream:
                try:
                    response.read()  # Load the body in memory and close the socket
                except (StreamConsumedError, StreamClosedError):
                    pass
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        response_headers = {}
        response_headers["location"] = self._deserialize("str", response.headers.get("location"))

        if _stream:
            deserialized = response.iter_bytes()
        else:
            deserialized = _deserialize(_models.IngestionSource, response.json())

        if cls:
            return cls(pipeline_response, deserialized, response_headers)  # type: ignore

        return deserialized  # type: ignore

    @distributed_trace
    def delete(self, id: str, **kwargs: Any) -> None:  # pylint: disable=inconsistent-return-statements
        """Delete an ingestion source from a geo-catalog.

        :param id: Ingestion source id. Required.
        :type id: str
        :return: None
        :rtype: None
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[None] = kwargs.pop("cls", None)

        _request = build_ingestion_sources_delete_request(
            id=id,
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = False
        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [204]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if cls:
            return cls(pipeline_response, None, {})  # type: ignore

    @distributed_trace
    def list_managed_identities(self, **kwargs: Any) -> _models.ManagedIdentitiesPagedResponse:
        """Get all managed identities with access to storage accounts configured for a geo-catalog.

        :return: ManagedIdentitiesPagedResponse. The ManagedIdentitiesPagedResponse is compatible with
         MutableMapping
        :rtype: ~azure.planetarycomputer.models.ManagedIdentitiesPagedResponse
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[_models.ManagedIdentitiesPagedResponse] = kwargs.pop("cls", None)

        _request = build_ingestion_sources_list_managed_identities_request(
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = kwargs.pop("stream", False)
        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                try:
                    response.read()  # Load the body in memory and close the socket
                except (StreamConsumedError, StreamClosedError):
                    pass
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if _stream:
            deserialized = response.iter_bytes()
        else:
            deserialized = _deserialize(_models.ManagedIdentitiesPagedResponse, response.json())

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore


class IngestionOperationsOperations:
    """
    .. warning::
        **DO NOT** instantiate this class directly.

        Instead, you should access the following operations through
        :class:`~azure.planetarycomputer.PlanetaryComputerClient`'s
        :attr:`ingestion_operations` attribute.
    """

    def __init__(self, *args, **kwargs) -> None:
        input_args = list(args)
        self._client: PipelineClient = input_args.pop(0) if input_args else kwargs.pop("client")
        self._config: PlanetaryComputerClientConfiguration = input_args.pop(0) if input_args else kwargs.pop("config")
        self._serialize: Serializer = input_args.pop(0) if input_args else kwargs.pop("serializer")
        self._deserialize: Deserializer = input_args.pop(0) if input_args else kwargs.pop("deserializer")

    @distributed_trace
    def get(self, operation_id: str, **kwargs: Any) -> _models.Operation:
        """Get an operation of a geo-catalog collection.

        :param operation_id: Operation id. Required.
        :type operation_id: str
        :return: Operation. The Operation is compatible with MutableMapping
        :rtype: ~azure.planetarycomputer.models.Operation
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[_models.Operation] = kwargs.pop("cls", None)

        _request = build_ingestion_operations_get_request(
            operation_id=operation_id,
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = kwargs.pop("stream", False)
        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                try:
                    response.read()  # Load the body in memory and close the socket
                except (StreamConsumedError, StreamClosedError):
                    pass
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if _stream:
            deserialized = response.iter_bytes()
        else:
            deserialized = _deserialize(_models.Operation, response.json())

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore

    @distributed_trace
    def list_all(
        self,
        *,
        top: Optional[int] = None,
        skip: Optional[int] = None,
        collection_id: Optional[str] = None,
        status: Optional[Union[str, _models.OperationStatus]] = None,
        **kwargs: Any,
    ) -> _models.OperationsPagedResponse:
        """Get operations of a geo-catalog collection.

        :keyword top: The number of items to return. Default value is None.
        :paramtype top: int
        :keyword skip: The number of items to skip. Default value is None.
        :paramtype skip: int
        :keyword collection_id: Operation id used to filter the results. Default value is None.
        :paramtype collection_id: str
        :keyword status: Operation status used to filter the results. Known values are: "Pending",
         "Running", "Succeeded", "Canceled", "Canceling", and "Failed". Default value is None.
        :paramtype status: str or ~azure.planetarycomputer.models.OperationStatus
        :return: OperationsPagedResponse. The OperationsPagedResponse is compatible with MutableMapping
        :rtype: ~azure.planetarycomputer.models.OperationsPagedResponse
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[_models.OperationsPagedResponse] = kwargs.pop("cls", None)

        _request = build_ingestion_operations_list_all_request(
            top=top,
            skip=skip,
            collection_id=collection_id,
            status=status,
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = kwargs.pop("stream", False)
        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                try:
                    response.read()  # Load the body in memory and close the socket
                except (StreamConsumedError, StreamClosedError):
                    pass
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if _stream:
            deserialized = response.iter_bytes()
        else:
            deserialized = _deserialize(_models.OperationsPagedResponse, response.json())

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore

    @distributed_trace
    def delete_all(self, **kwargs: Any) -> None:  # pylint: disable=inconsistent-return-statements
        """Cancel all running operations of a geo-catalog collection.

        :return: None
        :rtype: None
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[None] = kwargs.pop("cls", None)

        _request = build_ingestion_operations_delete_all_request(
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = False
        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [204]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if cls:
            return cls(pipeline_response, None, {})  # type: ignore

    @distributed_trace
    def delete(self, operation_id: str, **kwargs: Any) -> None:  # pylint: disable=inconsistent-return-statements
        """Cancel a running operation of a geo-catalog collection.

        :param operation_id: Operation id. Required.
        :type operation_id: str
        :return: None
        :rtype: None
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[None] = kwargs.pop("cls", None)

        _request = build_ingestion_operations_delete_request(
            operation_id=operation_id,
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = False
        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [204]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if cls:
            return cls(pipeline_response, None, {})  # type: ignore


class StacLandingPagesOperations:
    """
    .. warning::
        **DO NOT** instantiate this class directly.

        Instead, you should access the following operations through
        :class:`~azure.planetarycomputer.PlanetaryComputerClient`'s
        :attr:`stac_landing_pages` attribute.
    """

    def __init__(self, *args, **kwargs) -> None:
        input_args = list(args)
        self._client: PipelineClient = input_args.pop(0) if input_args else kwargs.pop("client")
        self._config: PlanetaryComputerClientConfiguration = input_args.pop(0) if input_args else kwargs.pop("config")
        self._serialize: Serializer = input_args.pop(0) if input_args else kwargs.pop("serializer")
        self._deserialize: Deserializer = input_args.pop(0) if input_args else kwargs.pop("deserializer")

    @distributed_trace
    def get(self, **kwargs: Any) -> _models.LandingPage:
        """Landing Page.

        Endpoint.

        :return: LandingPage. The LandingPage is compatible with MutableMapping
        :rtype: ~azure.planetarycomputer.models.LandingPage
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[_models.LandingPage] = kwargs.pop("cls", None)

        _request = build_stac_landing_pages_get_request(
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = kwargs.pop("stream", False)
        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                try:
                    response.read()  # Load the body in memory and close the socket
                except (StreamConsumedError, StreamClosedError):
                    pass
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if _stream:
            deserialized = response.iter_bytes()
        else:
            deserialized = _deserialize(_models.LandingPage, response.json())

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore


class StacCollectionOperationsOperations:
    """
    .. warning::
        **DO NOT** instantiate this class directly.

        Instead, you should access the following operations through
        :class:`~azure.planetarycomputer.PlanetaryComputerClient`'s
        :attr:`stac_collection_operations` attribute.
    """

    def __init__(self, *args, **kwargs) -> None:
        input_args = list(args)
        self._client: PipelineClient = input_args.pop(0) if input_args else kwargs.pop("client")
        self._config: PlanetaryComputerClientConfiguration = input_args.pop(0) if input_args else kwargs.pop("config")
        self._serialize: Serializer = input_args.pop(0) if input_args else kwargs.pop("serializer")
        self._deserialize: Deserializer = input_args.pop(0) if input_args else kwargs.pop("deserializer")

    @distributed_trace
    def get_all(
        self, *, sign: Optional[Union[str, _models.SignType]] = None, duration: Optional[int] = None, **kwargs: Any
    ) -> _models.FeatureCollections:
        """Get Collections.

        Endpoint.

        :keyword sign: Whether to sign asset URLs in the response. Known values are: "true" and
         "false". Default value is None.
        :paramtype sign: str or ~azure.planetarycomputer.models.SignType
        :keyword duration: URL signature duration in seconds. Default value is None.
        :paramtype duration: int
        :return: FeatureCollections. The FeatureCollections is compatible with MutableMapping
        :rtype: ~azure.planetarycomputer.models.FeatureCollections
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[_models.FeatureCollections] = kwargs.pop("cls", None)

        _request = build_stac_collection_operations_get_all_request(
            sign=sign,
            duration=duration,
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = kwargs.pop("stream", False)
        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                try:
                    response.read()  # Load the body in memory and close the socket
                except (StreamConsumedError, StreamClosedError):
                    pass
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if _stream:
            deserialized = response.iter_bytes()
        else:
            deserialized = _deserialize(_models.FeatureCollections, response.json())

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore

    def _create_initial(self, body: Union[_models.StacCollection, JSON, IO[bytes]], **kwargs: Any) -> Iterator[bytes]:
        error_map: MutableMapping = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[Iterator[bytes]] = kwargs.pop("cls", None)

        content_type = content_type or "application/json"
        _content = None
        if isinstance(body, (IOBase, bytes)):
            _content = body
        else:
            _content = json.dumps(body, cls=SdkJSONEncoder, exclude_readonly=True)  # type: ignore

        _request = build_stac_collection_operations_create_request(
            content_type=content_type,
            api_version=self._config.api_version,
            content=_content,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = True
        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [202]:
            try:
                response.read()  # Load the body in memory and close the socket
            except (StreamConsumedError, StreamClosedError):
                pass
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        response_headers = {}
        response_headers["location"] = self._deserialize("str", response.headers.get("location"))
        response_headers["operation-location"] = self._deserialize("str", response.headers.get("operation-location"))

        deserialized = response.iter_bytes()

        if cls:
            return cls(pipeline_response, deserialized, response_headers)  # type: ignore

        return deserialized  # type: ignore

    @overload
    def begin_create(
        self, body: _models.StacCollection, *, content_type: str = "application/json", **kwargs: Any
    ) -> LROPoller[None]:
        """Create Collection.

        Create a new collection in the GeoCatalog instance.

        :param body: Request collection body. Required.
        :type body: ~azure.planetarycomputer.models.StacCollection
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: An instance of LROPoller that returns None
        :rtype: ~azure.core.polling.LROPoller[None]
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @overload
    def begin_create(self, body: JSON, *, content_type: str = "application/json", **kwargs: Any) -> LROPoller[None]:
        """Create Collection.

        Create a new collection in the GeoCatalog instance.

        :param body: Request collection body. Required.
        :type body: JSON
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: An instance of LROPoller that returns None
        :rtype: ~azure.core.polling.LROPoller[None]
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @overload
    def begin_create(
        self, body: IO[bytes], *, content_type: str = "application/json", **kwargs: Any
    ) -> LROPoller[None]:
        """Create Collection.

        Create a new collection in the GeoCatalog instance.

        :param body: Request collection body. Required.
        :type body: IO[bytes]
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: An instance of LROPoller that returns None
        :rtype: ~azure.core.polling.LROPoller[None]
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @distributed_trace
    def begin_create(self, body: Union[_models.StacCollection, JSON, IO[bytes]], **kwargs: Any) -> LROPoller[None]:
        """Create Collection.

        Create a new collection in the GeoCatalog instance.

        :param body: Request collection body. Is one of the following types: StacCollection, JSON,
         IO[bytes] Required.
        :type body: ~azure.planetarycomputer.models.StacCollection or JSON or IO[bytes]
        :return: An instance of LROPoller that returns None
        :rtype: ~azure.core.polling.LROPoller[None]
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[None] = kwargs.pop("cls", None)
        polling: Union[bool, PollingMethod] = kwargs.pop("polling", True)
        lro_delay = kwargs.pop("polling_interval", self._config.polling_interval)
        cont_token: Optional[str] = kwargs.pop("continuation_token", None)
        if cont_token is None:
            raw_result = self._create_initial(
                body=body, content_type=content_type, cls=lambda x, y, z: x, headers=_headers, params=_params, **kwargs
            )
            raw_result.http_response.read()  # type: ignore
        kwargs.pop("error_map", None)

        def get_long_running_output(pipeline_response):  # pylint: disable=inconsistent-return-statements
            if cls:
                return cls(pipeline_response, None, {})  # type: ignore

        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, "str", skip_quote=True),
        }

        if polling is True:
            polling_method: PollingMethod = cast(
                PollingMethod, LROBasePolling(lro_delay, path_format_arguments=path_format_arguments, **kwargs)
            )
        elif polling is False:
            polling_method = cast(PollingMethod, NoPolling())
        else:
            polling_method = polling
        if cont_token:
            return LROPoller[None].from_continuation_token(
                polling_method=polling_method,
                continuation_token=cont_token,
                client=self._client,
                deserialization_callback=get_long_running_output,
            )
        return LROPoller[None](self._client, raw_result, get_long_running_output, polling_method)  # type: ignore

    @distributed_trace
    def get(
        self,
        collection_id: str,
        *,
        sign: Optional[Union[str, _models.SignType]] = None,
        duration: Optional[int] = None,
        **kwargs: Any,
    ) -> _models.StacCollection:
        """Get Collection.

        Get a collection in the GeoCatalog instance.

        :param collection_id: Unique identifier for the collection. Required.
        :type collection_id: str
        :keyword sign: Whether to sign asset URLs in the response. Known values are: "true" and
         "false". Default value is None.
        :paramtype sign: str or ~azure.planetarycomputer.models.SignType
        :keyword duration: URL signature duration in seconds. Default value is None.
        :paramtype duration: int
        :return: StacCollection. The StacCollection is compatible with MutableMapping
        :rtype: ~azure.planetarycomputer.models.StacCollection
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[_models.StacCollection] = kwargs.pop("cls", None)

        _request = build_stac_collection_operations_get_request(
            collection_id=collection_id,
            sign=sign,
            duration=duration,
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = kwargs.pop("stream", False)
        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                try:
                    response.read()  # Load the body in memory and close the socket
                except (StreamConsumedError, StreamClosedError):
                    pass
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if _stream:
            deserialized = response.iter_bytes()
        else:
            deserialized = _deserialize(_models.StacCollection, response.json())

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore

    def _create_or_replace_initial(
        self, collection_id: str, body: Union[_models.StacCollection, JSON, IO[bytes]], **kwargs: Any
    ) -> Iterator[bytes]:
        error_map: MutableMapping = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[Iterator[bytes]] = kwargs.pop("cls", None)

        content_type = content_type or "application/json"
        _content = None
        if isinstance(body, (IOBase, bytes)):
            _content = body
        else:
            _content = json.dumps(body, cls=SdkJSONEncoder, exclude_readonly=True)  # type: ignore

        _request = build_stac_collection_operations_create_or_replace_request(
            collection_id=collection_id,
            content_type=content_type,
            api_version=self._config.api_version,
            content=_content,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = True
        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [202]:
            try:
                response.read()  # Load the body in memory and close the socket
            except (StreamConsumedError, StreamClosedError):
                pass
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        response_headers = {}
        response_headers["location"] = self._deserialize("str", response.headers.get("location"))
        response_headers["operation-location"] = self._deserialize("str", response.headers.get("operation-location"))

        deserialized = response.iter_bytes()

        if cls:
            return cls(pipeline_response, deserialized, response_headers)  # type: ignore

        return deserialized  # type: ignore

    @overload
    def begin_create_or_replace(
        self, collection_id: str, body: _models.StacCollection, *, content_type: str = "application/json", **kwargs: Any
    ) -> LROPoller[None]:
        """Create or update Collection.

        Create or replace a collection in the GeoCatalog instance.

        :param collection_id: Catalog collection id. Required.
        :type collection_id: str
        :param body: Request collection body. Required.
        :type body: ~azure.planetarycomputer.models.StacCollection
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: An instance of LROPoller that returns None
        :rtype: ~azure.core.polling.LROPoller[None]
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @overload
    def begin_create_or_replace(
        self, collection_id: str, body: JSON, *, content_type: str = "application/json", **kwargs: Any
    ) -> LROPoller[None]:
        """Create or update Collection.

        Create or replace a collection in the GeoCatalog instance.

        :param collection_id: Catalog collection id. Required.
        :type collection_id: str
        :param body: Request collection body. Required.
        :type body: JSON
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: An instance of LROPoller that returns None
        :rtype: ~azure.core.polling.LROPoller[None]
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @overload
    def begin_create_or_replace(
        self, collection_id: str, body: IO[bytes], *, content_type: str = "application/json", **kwargs: Any
    ) -> LROPoller[None]:
        """Create or update Collection.

        Create or replace a collection in the GeoCatalog instance.

        :param collection_id: Catalog collection id. Required.
        :type collection_id: str
        :param body: Request collection body. Required.
        :type body: IO[bytes]
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: An instance of LROPoller that returns None
        :rtype: ~azure.core.polling.LROPoller[None]
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @distributed_trace
    def begin_create_or_replace(
        self, collection_id: str, body: Union[_models.StacCollection, JSON, IO[bytes]], **kwargs: Any
    ) -> LROPoller[None]:
        """Create or update Collection.

        Create or replace a collection in the GeoCatalog instance.

        :param collection_id: Catalog collection id. Required.
        :type collection_id: str
        :param body: Request collection body. Is one of the following types: StacCollection, JSON,
         IO[bytes] Required.
        :type body: ~azure.planetarycomputer.models.StacCollection or JSON or IO[bytes]
        :return: An instance of LROPoller that returns None
        :rtype: ~azure.core.polling.LROPoller[None]
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[None] = kwargs.pop("cls", None)
        polling: Union[bool, PollingMethod] = kwargs.pop("polling", True)
        lro_delay = kwargs.pop("polling_interval", self._config.polling_interval)
        cont_token: Optional[str] = kwargs.pop("continuation_token", None)
        if cont_token is None:
            raw_result = self._create_or_replace_initial(
                collection_id=collection_id,
                body=body,
                content_type=content_type,
                cls=lambda x, y, z: x,
                headers=_headers,
                params=_params,
                **kwargs,
            )
            raw_result.http_response.read()  # type: ignore
        kwargs.pop("error_map", None)

        def get_long_running_output(pipeline_response):  # pylint: disable=inconsistent-return-statements
            if cls:
                return cls(pipeline_response, None, {})  # type: ignore

        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, "str", skip_quote=True),
        }

        if polling is True:
            polling_method: PollingMethod = cast(
                PollingMethod, LROBasePolling(lro_delay, path_format_arguments=path_format_arguments, **kwargs)
            )
        elif polling is False:
            polling_method = cast(PollingMethod, NoPolling())
        else:
            polling_method = polling
        if cont_token:
            return LROPoller[None].from_continuation_token(
                polling_method=polling_method,
                continuation_token=cont_token,
                client=self._client,
                deserialization_callback=get_long_running_output,
            )
        return LROPoller[None](self._client, raw_result, get_long_running_output, polling_method)  # type: ignore

    def _delete_initial(self, collection_id: str, **kwargs: Any) -> Iterator[bytes]:
        error_map: MutableMapping = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[Iterator[bytes]] = kwargs.pop("cls", None)

        _request = build_stac_collection_operations_delete_request(
            collection_id=collection_id,
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = True
        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [202]:
            try:
                response.read()  # Load the body in memory and close the socket
            except (StreamConsumedError, StreamClosedError):
                pass
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        response_headers = {}
        response_headers["location"] = self._deserialize("str", response.headers.get("location"))
        response_headers["operation-location"] = self._deserialize("str", response.headers.get("operation-location"))

        deserialized = response.iter_bytes()

        if cls:
            return cls(pipeline_response, deserialized, response_headers)  # type: ignore

        return deserialized  # type: ignore

    @distributed_trace
    def begin_delete(self, collection_id: str, **kwargs: Any) -> LROPoller[None]:
        """Delete Collection.

        Delete a collection in the GeoCatalog instance.

        :param collection_id: Catalog collection id. Required.
        :type collection_id: str
        :return: An instance of LROPoller that returns None
        :rtype: ~azure.core.polling.LROPoller[None]
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[None] = kwargs.pop("cls", None)
        polling: Union[bool, PollingMethod] = kwargs.pop("polling", True)
        lro_delay = kwargs.pop("polling_interval", self._config.polling_interval)
        cont_token: Optional[str] = kwargs.pop("continuation_token", None)
        if cont_token is None:
            raw_result = self._delete_initial(
                collection_id=collection_id, cls=lambda x, y, z: x, headers=_headers, params=_params, **kwargs
            )
            raw_result.http_response.read()  # type: ignore
        kwargs.pop("error_map", None)

        def get_long_running_output(pipeline_response):  # pylint: disable=inconsistent-return-statements
            if cls:
                return cls(pipeline_response, None, {})  # type: ignore

        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, "str", skip_quote=True),
        }

        if polling is True:
            polling_method: PollingMethod = cast(
                PollingMethod, LROBasePolling(lro_delay, path_format_arguments=path_format_arguments, **kwargs)
            )
        elif polling is False:
            polling_method = cast(PollingMethod, NoPolling())
        else:
            polling_method = polling
        if cont_token:
            return LROPoller[None].from_continuation_token(
                polling_method=polling_method,
                continuation_token=cont_token,
                client=self._client,
                deserialization_callback=get_long_running_output,
            )
        return LROPoller[None](self._client, raw_result, get_long_running_output, polling_method)  # type: ignore


class StacQueryablesOperations:
    """
    .. warning::
        **DO NOT** instantiate this class directly.

        Instead, you should access the following operations through
        :class:`~azure.planetarycomputer.PlanetaryComputerClient`'s
        :attr:`stac_queryables` attribute.
    """

    def __init__(self, *args, **kwargs) -> None:
        input_args = list(args)
        self._client: PipelineClient = input_args.pop(0) if input_args else kwargs.pop("client")
        self._config: PlanetaryComputerClientConfiguration = input_args.pop(0) if input_args else kwargs.pop("config")
        self._serialize: Serializer = input_args.pop(0) if input_args else kwargs.pop("serializer")
        self._deserialize: Deserializer = input_args.pop(0) if input_args else kwargs.pop("deserializer")

    @distributed_trace
    def get_all(self, **kwargs: Any) -> Optional[_models.JsonSchema]:
        """Queryables.

        Endpoint.

        :return: JsonSchema or None. The JsonSchema is compatible with MutableMapping
        :rtype: ~azure.planetarycomputer.models.JsonSchema or None
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[Optional[_models.JsonSchema]] = kwargs.pop("cls", None)

        _request = build_stac_queryables_get_all_request(
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = kwargs.pop("stream", False)
        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200, 204]:
            if _stream:
                try:
                    response.read()  # Load the body in memory and close the socket
                except (StreamConsumedError, StreamClosedError):
                    pass
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        deserialized = None
        if response.status_code == 200:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.JsonSchema, response.json())

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore

    @distributed_trace
    def delete(  # pylint: disable=inconsistent-return-statements
        self, collection_id: str, queryable_name: str, **kwargs: Any
    ) -> None:
        """Delete Queryables.

        Delete queryables by name for specified collection.

        :param collection_id: Unique identifier for the STAC collection. Required.
        :type collection_id: str
        :param queryable_name: Name of the queryable property to operate on. Required.
        :type queryable_name: str
        :return: None
        :rtype: None
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[None] = kwargs.pop("cls", None)

        _request = build_stac_queryables_delete_request(
            collection_id=collection_id,
            queryable_name=queryable_name,
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = False
        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200, 204]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if cls:
            return cls(pipeline_response, None, {})  # type: ignore

    @distributed_trace
    def get_all_by_collection(self, collection_id: str, **kwargs: Any) -> Optional[_models.JsonSchema]:
        """Collection Queryables.

        Endpoint.

        :param collection_id: Collection ID. Required.
        :type collection_id: str
        :return: JsonSchema or None. The JsonSchema is compatible with MutableMapping
        :rtype: ~azure.planetarycomputer.models.JsonSchema or None
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[Optional[_models.JsonSchema]] = kwargs.pop("cls", None)

        _request = build_stac_queryables_get_all_by_collection_request(
            collection_id=collection_id,
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = kwargs.pop("stream", False)
        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200, 204]:
            if _stream:
                try:
                    response.read()  # Load the body in memory and close the socket
                except (StreamConsumedError, StreamClosedError):
                    pass
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        deserialized = None
        if response.status_code == 200:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.JsonSchema, response.json())

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore

    @overload
    def create(
        self,
        collection_id: str,
        body: List[_models.QueryableDefinition],
        *,
        content_type: str = "application/json",
        **kwargs: Any,
    ) -> Optional[List[_models.QueryableDefinition]]:
        """Set Collection Queryables.

        Set queryables for a collection given a list of queryable definitions.

        :param collection_id: Unique identifier for the STAC collection. Required.
        :type collection_id: str
        :param body: Request queryable definition body. Required.
        :type body: list[~azure.planetarycomputer.models.QueryableDefinition]
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: list of QueryableDefinition or None
        :rtype: list[~azure.planetarycomputer.models.QueryableDefinition] or None
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @overload
    def create(
        self, collection_id: str, body: IO[bytes], *, content_type: str = "application/json", **kwargs: Any
    ) -> Optional[List[_models.QueryableDefinition]]:
        """Set Collection Queryables.

        Set queryables for a collection given a list of queryable definitions.

        :param collection_id: Unique identifier for the STAC collection. Required.
        :type collection_id: str
        :param body: Request queryable definition body. Required.
        :type body: IO[bytes]
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: list of QueryableDefinition or None
        :rtype: list[~azure.planetarycomputer.models.QueryableDefinition] or None
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @distributed_trace
    def create(
        self, collection_id: str, body: Union[List[_models.QueryableDefinition], IO[bytes]], **kwargs: Any
    ) -> Optional[List[_models.QueryableDefinition]]:
        """Set Collection Queryables.

        Set queryables for a collection given a list of queryable definitions.

        :param collection_id: Unique identifier for the STAC collection. Required.
        :type collection_id: str
        :param body: Request queryable definition body. Is either a [QueryableDefinition] type or a
         IO[bytes] type. Required.
        :type body: list[~azure.planetarycomputer.models.QueryableDefinition] or IO[bytes]
        :return: list of QueryableDefinition or None
        :rtype: list[~azure.planetarycomputer.models.QueryableDefinition] or None
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[Optional[List[_models.QueryableDefinition]]] = kwargs.pop("cls", None)

        content_type = content_type or "application/json"
        _content = None
        if isinstance(body, (IOBase, bytes)):
            _content = body
        else:
            _content = json.dumps(body, cls=SdkJSONEncoder, exclude_readonly=True)  # type: ignore

        _request = build_stac_queryables_create_request(
            collection_id=collection_id,
            content_type=content_type,
            api_version=self._config.api_version,
            content=_content,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = kwargs.pop("stream", False)
        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [201, 204]:
            if _stream:
                try:
                    response.read()  # Load the body in memory and close the socket
                except (StreamConsumedError, StreamClosedError):
                    pass
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        deserialized = None
        if response.status_code == 201:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(List[_models.QueryableDefinition], response.json())

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore

    @overload
    def create_or_replace(
        self,
        collection_id: str,
        queryable_name: str,
        body: _models.QueryableDefinition,
        *,
        content_type: str = "application/json",
        **kwargs: Any,
    ) -> _models.QueryableDefinition:
        """Update Collection Queryables.

        Updates a queryable given a queryable definition and
        corresponding collection id.

        :param collection_id: Unique identifier for the STAC collection. Required.
        :type collection_id: str
        :param queryable_name: Name of the queryable property to operate on. Required.
        :type queryable_name: str
        :param body: Request queryable definition body. Required.
        :type body: ~azure.planetarycomputer.models.QueryableDefinition
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: QueryableDefinition. The QueryableDefinition is compatible with MutableMapping
        :rtype: ~azure.planetarycomputer.models.QueryableDefinition
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @overload
    def create_or_replace(
        self,
        collection_id: str,
        queryable_name: str,
        body: JSON,
        *,
        content_type: str = "application/json",
        **kwargs: Any,
    ) -> _models.QueryableDefinition:
        """Update Collection Queryables.

        Updates a queryable given a queryable definition and
        corresponding collection id.

        :param collection_id: Unique identifier for the STAC collection. Required.
        :type collection_id: str
        :param queryable_name: Name of the queryable property to operate on. Required.
        :type queryable_name: str
        :param body: Request queryable definition body. Required.
        :type body: JSON
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: QueryableDefinition. The QueryableDefinition is compatible with MutableMapping
        :rtype: ~azure.planetarycomputer.models.QueryableDefinition
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @overload
    def create_or_replace(
        self,
        collection_id: str,
        queryable_name: str,
        body: IO[bytes],
        *,
        content_type: str = "application/json",
        **kwargs: Any,
    ) -> _models.QueryableDefinition:
        """Update Collection Queryables.

        Updates a queryable given a queryable definition and
        corresponding collection id.

        :param collection_id: Unique identifier for the STAC collection. Required.
        :type collection_id: str
        :param queryable_name: Name of the queryable property to operate on. Required.
        :type queryable_name: str
        :param body: Request queryable definition body. Required.
        :type body: IO[bytes]
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: QueryableDefinition. The QueryableDefinition is compatible with MutableMapping
        :rtype: ~azure.planetarycomputer.models.QueryableDefinition
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @distributed_trace
    def create_or_replace(
        self,
        collection_id: str,
        queryable_name: str,
        body: Union[_models.QueryableDefinition, JSON, IO[bytes]],
        **kwargs: Any,
    ) -> _models.QueryableDefinition:
        """Update Collection Queryables.

        Updates a queryable given a queryable definition and
        corresponding collection id.

        :param collection_id: Unique identifier for the STAC collection. Required.
        :type collection_id: str
        :param queryable_name: Name of the queryable property to operate on. Required.
        :type queryable_name: str
        :param body: Request queryable definition body. Is one of the following types:
         QueryableDefinition, JSON, IO[bytes] Required.
        :type body: ~azure.planetarycomputer.models.QueryableDefinition or JSON or IO[bytes]
        :return: QueryableDefinition. The QueryableDefinition is compatible with MutableMapping
        :rtype: ~azure.planetarycomputer.models.QueryableDefinition
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[_models.QueryableDefinition] = kwargs.pop("cls", None)

        content_type = content_type or "application/json"
        _content = None
        if isinstance(body, (IOBase, bytes)):
            _content = body
        else:
            _content = json.dumps(body, cls=SdkJSONEncoder, exclude_readonly=True)  # type: ignore

        _request = build_stac_queryables_create_or_replace_request(
            collection_id=collection_id,
            queryable_name=queryable_name,
            content_type=content_type,
            api_version=self._config.api_version,
            content=_content,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = kwargs.pop("stream", False)
        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200, 201]:
            if _stream:
                try:
                    response.read()  # Load the body in memory and close the socket
                except (StreamConsumedError, StreamClosedError):
                    pass
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if _stream:
            deserialized = response.iter_bytes()
        else:
            deserialized = _deserialize(_models.QueryableDefinition, response.json())

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore


class StacConformanceClassOperations:
    """
    .. warning::
        **DO NOT** instantiate this class directly.

        Instead, you should access the following operations through
        :class:`~azure.planetarycomputer.PlanetaryComputerClient`'s
        :attr:`stac_conformance_class` attribute.
    """

    def __init__(self, *args, **kwargs) -> None:
        input_args = list(args)
        self._client: PipelineClient = input_args.pop(0) if input_args else kwargs.pop("client")
        self._config: PlanetaryComputerClientConfiguration = input_args.pop(0) if input_args else kwargs.pop("config")
        self._serialize: Serializer = input_args.pop(0) if input_args else kwargs.pop("serializer")
        self._deserialize: Deserializer = input_args.pop(0) if input_args else kwargs.pop("deserializer")

    @distributed_trace
    def get(self, **kwargs: Any) -> _models.ConformanceClasses:
        """Conformance Classes.

        Endpoint.

        :return: ConformanceClasses. The ConformanceClasses is compatible with MutableMapping
        :rtype: ~azure.planetarycomputer.models.ConformanceClasses
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[_models.ConformanceClasses] = kwargs.pop("cls", None)

        _request = build_stac_conformance_class_get_request(
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = kwargs.pop("stream", False)
        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                try:
                    response.read()  # Load the body in memory and close the socket
                except (StreamConsumedError, StreamClosedError):
                    pass
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if _stream:
            deserialized = response.iter_bytes()
        else:
            deserialized = _deserialize(_models.ConformanceClasses, response.json())

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore


class StacSearchOperationsOperations:
    """
    .. warning::
        **DO NOT** instantiate this class directly.

        Instead, you should access the following operations through
        :class:`~azure.planetarycomputer.PlanetaryComputerClient`'s
        :attr:`stac_search_operations` attribute.
    """

    def __init__(self, *args, **kwargs) -> None:
        input_args = list(args)
        self._client: PipelineClient = input_args.pop(0) if input_args else kwargs.pop("client")
        self._config: PlanetaryComputerClientConfiguration = input_args.pop(0) if input_args else kwargs.pop("config")
        self._serialize: Serializer = input_args.pop(0) if input_args else kwargs.pop("serializer")
        self._deserialize: Deserializer = input_args.pop(0) if input_args else kwargs.pop("deserializer")

    @distributed_trace
    def get(
        self,
        *,
        collections: Optional[List[str]] = None,
        ids: Optional[List[str]] = None,
        bbox: Optional[List[float]] = None,
        intersects: Optional[str] = None,
        datetime: Optional[str] = None,
        limit: Optional[int] = None,
        sign: Optional[Union[str, _models.SignType]] = None,
        duration: Optional[int] = None,
        query: Optional[str] = None,
        sort_by: Optional[str] = None,
        fields: Optional[str] = None,
        filter: Optional[str] = None,
        token: Optional[str] = None,
        **kwargs: Any,
    ) -> Optional[_models.ItemCollection]:
        """Search.

        Endpoint.

        :keyword collections: List of Collection IDs to include in the search. Only items in these
         collections will be searched. Default value is None.
        :paramtype collections: list[str]
        :keyword ids: Array of Item IDs to return specific items. Default value is None.
        :paramtype ids: list[str]
        :keyword bbox: Bounding box for spatial filtering in format [west, south, east, north]. Default
         value is None.
        :paramtype bbox: list[float]
        :keyword intersects: GeoJSON geometry for spatial filtering. Default value is None.
        :paramtype intersects: str
        :keyword datetime: Temporal filter in RFC 3339 format, can be a single time or range. Default
         value is None.
        :paramtype datetime: str
        :keyword limit: Maximum number of results to return. Default value is None.
        :paramtype limit: int
        :keyword sign: Whether to sign asset URLs in the response. Known values are: "true" and
         "false". Default value is None.
        :paramtype sign: str or ~azure.planetarycomputer.models.SignType
        :keyword duration: URL signature duration in seconds. Default value is None.
        :paramtype duration: int
        :keyword query: Property-based filtering expressed as a JSON object. Default value is None.
        :paramtype query: str
        :keyword sort_by: Sort order for items. Format is property name prefixed with "+" for ascending
         or "-" for descending. Default value is None.
        :paramtype sort_by: str
        :keyword fields: Determines which fields to include in the response. Format is comma-separated
         field names with "-" prefix to exclude fields. Default value is None.
        :paramtype fields: str
        :keyword filter: CQL filter expression for advanced filtering of items. Default value is None.
        :paramtype filter: str
        :keyword token: Pagination token for fetching the next set of results. Default value is None.
        :paramtype token: str
        :return: ItemCollection or None. The ItemCollection is compatible with MutableMapping
        :rtype: ~azure.planetarycomputer.models.ItemCollection or None
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[Optional[_models.ItemCollection]] = kwargs.pop("cls", None)

        _request = build_stac_search_operations_get_request(
            collections=collections,
            ids=ids,
            bbox=bbox,
            intersects=intersects,
            datetime=datetime,
            limit=limit,
            sign=sign,
            duration=duration,
            query=query,
            sort_by=sort_by,
            fields=fields,
            filter=filter,
            token=token,
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = kwargs.pop("stream", False)
        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200, 204]:
            if _stream:
                try:
                    response.read()  # Load the body in memory and close the socket
                except (StreamConsumedError, StreamClosedError):
                    pass
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        deserialized = None
        if response.status_code == 200:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ItemCollection, response.json())

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore

    @overload
    def create(
        self, body: _models.SearchPostRequest, *, content_type: str = "application/json", **kwargs: Any
    ) -> Optional[_models.ItemCollection]:
        """Search.

        Endpoint.

        :param body: Request body. Required.
        :type body: ~azure.planetarycomputer.models.SearchPostRequest
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: ItemCollection or None. The ItemCollection is compatible with MutableMapping
        :rtype: ~azure.planetarycomputer.models.ItemCollection or None
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @overload
    def create(
        self, body: JSON, *, content_type: str = "application/json", **kwargs: Any
    ) -> Optional[_models.ItemCollection]:
        """Search.

        Endpoint.

        :param body: Request body. Required.
        :type body: JSON
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: ItemCollection or None. The ItemCollection is compatible with MutableMapping
        :rtype: ~azure.planetarycomputer.models.ItemCollection or None
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @overload
    def create(
        self, body: IO[bytes], *, content_type: str = "application/json", **kwargs: Any
    ) -> Optional[_models.ItemCollection]:
        """Search.

        Endpoint.

        :param body: Request body. Required.
        :type body: IO[bytes]
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: ItemCollection or None. The ItemCollection is compatible with MutableMapping
        :rtype: ~azure.planetarycomputer.models.ItemCollection or None
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @distributed_trace
    def create(
        self, body: Union[_models.SearchPostRequest, JSON, IO[bytes]], **kwargs: Any
    ) -> Optional[_models.ItemCollection]:
        """Search.

        Endpoint.

        :param body: Request body. Is one of the following types: SearchPostRequest, JSON, IO[bytes]
         Required.
        :type body: ~azure.planetarycomputer.models.SearchPostRequest or JSON or IO[bytes]
        :return: ItemCollection or None. The ItemCollection is compatible with MutableMapping
        :rtype: ~azure.planetarycomputer.models.ItemCollection or None
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[Optional[_models.ItemCollection]] = kwargs.pop("cls", None)

        content_type = content_type or "application/json"
        _content = None
        if isinstance(body, (IOBase, bytes)):
            _content = body
        else:
            _content = json.dumps(body, cls=SdkJSONEncoder, exclude_readonly=True)  # type: ignore

        _request = build_stac_search_operations_create_request(
            content_type=content_type,
            api_version=self._config.api_version,
            content=_content,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = kwargs.pop("stream", False)
        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200, 204]:
            if _stream:
                try:
                    response.read()  # Load the body in memory and close the socket
                except (StreamConsumedError, StreamClosedError):
                    pass
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        deserialized = None
        if response.status_code == 200:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ItemCollection, response.json())

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore


class StacCollectionAssetsOperations:
    """
    .. warning::
        **DO NOT** instantiate this class directly.

        Instead, you should access the following operations through
        :class:`~azure.planetarycomputer.PlanetaryComputerClient`'s
        :attr:`stac_collection_assets` attribute.
    """

    def __init__(self, *args, **kwargs) -> None:
        input_args = list(args)
        self._client: PipelineClient = input_args.pop(0) if input_args else kwargs.pop("client")
        self._config: PlanetaryComputerClientConfiguration = input_args.pop(0) if input_args else kwargs.pop("config")
        self._serialize: Serializer = input_args.pop(0) if input_args else kwargs.pop("serializer")
        self._deserialize: Deserializer = input_args.pop(0) if input_args else kwargs.pop("deserializer")

    @overload
    def create(self, collection_id: str, body: _models.FormContent, **kwargs: Any) -> _models.StacCollection:
        """Create Collection Asset.

        Create a new asset in the Collection metadata and write the associated
        file to managed storage.

        Args:
        request: The incoming request.
        asset: The Asset object to write, without a valid href to the asset.
        file: The file to write.
        collection_id: The ID of the collection to write the asset to.
        content_type: The content type of the request.

        Returns:
        A Response object containing the newly created asset.

        :param collection_id: STAC Collection ID. Required.
        :type collection_id: str
        :param body: Multi-part form data. Required.
        :type body: ~azure.planetarycomputer.models.FormContent
        :return: StacCollection. The StacCollection is compatible with MutableMapping
        :rtype: ~azure.planetarycomputer.models.StacCollection
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @overload
    def create(self, collection_id: str, body: JSON, **kwargs: Any) -> _models.StacCollection:
        """Create Collection Asset.

        Create a new asset in the Collection metadata and write the associated
        file to managed storage.

        Args:
        request: The incoming request.
        asset: The Asset object to write, without a valid href to the asset.
        file: The file to write.
        collection_id: The ID of the collection to write the asset to.
        content_type: The content type of the request.

        Returns:
        A Response object containing the newly created asset.

        :param collection_id: STAC Collection ID. Required.
        :type collection_id: str
        :param body: Multi-part form data. Required.
        :type body: JSON
        :return: StacCollection. The StacCollection is compatible with MutableMapping
        :rtype: ~azure.planetarycomputer.models.StacCollection
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @distributed_trace
    def create(
        self, collection_id: str, body: Union[_models.FormContent, JSON], **kwargs: Any
    ) -> _models.StacCollection:
        """Create Collection Asset.

        Create a new asset in the Collection metadata and write the associated
        file to managed storage.

        Args:
        request: The incoming request.
        asset: The Asset object to write, without a valid href to the asset.
        file: The file to write.
        collection_id: The ID of the collection to write the asset to.
        content_type: The content type of the request.

        Returns:
        A Response object containing the newly created asset.

        :param collection_id: STAC Collection ID. Required.
        :type collection_id: str
        :param body: Multi-part form data. Is either a FormContent type or a JSON type. Required.
        :type body: ~azure.planetarycomputer.models.FormContent or JSON
        :return: StacCollection. The StacCollection is compatible with MutableMapping
        :rtype: ~azure.planetarycomputer.models.StacCollection
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[_models.StacCollection] = kwargs.pop("cls", None)

        _body = body.as_dict() if isinstance(body, _Model) else body
        _file_fields: List[str] = ["file"]
        _data_fields: List[str] = ["data"]
        _files, _data = prepare_multipart_form_data(_body, _file_fields, _data_fields)

        _request = build_stac_collection_assets_create_request(
            collection_id=collection_id,
            api_version=self._config.api_version,
            files=_files,
            data=_data,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = kwargs.pop("stream", False)
        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200, 201]:
            if _stream:
                try:
                    response.read()  # Load the body in memory and close the socket
                except (StreamConsumedError, StreamClosedError):
                    pass
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if _stream:
            deserialized = response.iter_bytes()
        else:
            deserialized = _deserialize(_models.StacCollection, response.json())

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore

    @overload
    def create_or_replace(
        self, collection_id: str, asset_id: str, body: _models.FormContent, **kwargs: Any
    ) -> _models.StacCollection:
        """Update Collection Asset.

        Update an existing asset in a given collection.

        Args:
        request: The incoming request.
        asset: The Asset object to update.
        file: The file to update (optional).
        collection_id: The ID of the collection to update the asset in.
        asset_id: The ID of the asset to update.
        content_type: The content type of the request.

        Returns:
        A Response object containing the updated asset.

        :param collection_id: STAC Collection ID. Required.
        :type collection_id: str
        :param asset_id: STAC Asset ID. Required.
        :type asset_id: str
        :param body: Multi-part form data. Required.
        :type body: ~azure.planetarycomputer.models.FormContent
        :return: StacCollection. The StacCollection is compatible with MutableMapping
        :rtype: ~azure.planetarycomputer.models.StacCollection
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @overload
    def create_or_replace(self, collection_id: str, asset_id: str, body: JSON, **kwargs: Any) -> _models.StacCollection:
        """Update Collection Asset.

        Update an existing asset in a given collection.

        Args:
        request: The incoming request.
        asset: The Asset object to update.
        file: The file to update (optional).
        collection_id: The ID of the collection to update the asset in.
        asset_id: The ID of the asset to update.
        content_type: The content type of the request.

        Returns:
        A Response object containing the updated asset.

        :param collection_id: STAC Collection ID. Required.
        :type collection_id: str
        :param asset_id: STAC Asset ID. Required.
        :type asset_id: str
        :param body: Multi-part form data. Required.
        :type body: JSON
        :return: StacCollection. The StacCollection is compatible with MutableMapping
        :rtype: ~azure.planetarycomputer.models.StacCollection
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @distributed_trace
    def create_or_replace(
        self, collection_id: str, asset_id: str, body: Union[_models.FormContent, JSON], **kwargs: Any
    ) -> _models.StacCollection:
        """Update Collection Asset.

        Update an existing asset in a given collection.

        Args:
        request: The incoming request.
        asset: The Asset object to update.
        file: The file to update (optional).
        collection_id: The ID of the collection to update the asset in.
        asset_id: The ID of the asset to update.
        content_type: The content type of the request.

        Returns:
        A Response object containing the updated asset.

        :param collection_id: STAC Collection ID. Required.
        :type collection_id: str
        :param asset_id: STAC Asset ID. Required.
        :type asset_id: str
        :param body: Multi-part form data. Is either a FormContent type or a JSON type. Required.
        :type body: ~azure.planetarycomputer.models.FormContent or JSON
        :return: StacCollection. The StacCollection is compatible with MutableMapping
        :rtype: ~azure.planetarycomputer.models.StacCollection
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[_models.StacCollection] = kwargs.pop("cls", None)

        _body = body.as_dict() if isinstance(body, _Model) else body
        _file_fields: List[str] = ["file"]
        _data_fields: List[str] = ["data"]
        _files, _data = prepare_multipart_form_data(_body, _file_fields, _data_fields)

        _request = build_stac_collection_assets_create_or_replace_request(
            collection_id=collection_id,
            asset_id=asset_id,
            api_version=self._config.api_version,
            files=_files,
            data=_data,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = kwargs.pop("stream", False)
        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200, 201]:
            if _stream:
                try:
                    response.read()  # Load the body in memory and close the socket
                except (StreamConsumedError, StreamClosedError):
                    pass
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if _stream:
            deserialized = response.iter_bytes()
        else:
            deserialized = _deserialize(_models.StacCollection, response.json())

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore

    @distributed_trace
    def delete(  # pylint: disable=inconsistent-return-statements
        self, collection_id: str, asset_id: str, **kwargs: Any
    ) -> None:
        """Delete Collection Asset.

        Delete an asset from a given collection.

        Args:
        request: The incoming request.
        collection_id: The ID of the collection to delete the asset from.
        asset_id: The ID of the asset to delete.

        Returns:
        A Response object indicating the success of the deletion.

        :param collection_id: STAC Collection ID. Required.
        :type collection_id: str
        :param asset_id: STAC Asset ID. Required.
        :type asset_id: str
        :return: None
        :rtype: None
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[None] = kwargs.pop("cls", None)

        _request = build_stac_collection_assets_delete_request(
            collection_id=collection_id,
            asset_id=asset_id,
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = False
        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200, 204]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if cls:
            return cls(pipeline_response, None, {})  # type: ignore


class StacCollectionConfigOperations:
    """
    .. warning::
        **DO NOT** instantiate this class directly.

        Instead, you should access the following operations through
        :class:`~azure.planetarycomputer.PlanetaryComputerClient`'s
        :attr:`stac_collection_config` attribute.
    """

    def __init__(self, *args, **kwargs) -> None:
        input_args = list(args)
        self._client: PipelineClient = input_args.pop(0) if input_args else kwargs.pop("client")
        self._config: PlanetaryComputerClientConfiguration = input_args.pop(0) if input_args else kwargs.pop("config")
        self._serialize: Serializer = input_args.pop(0) if input_args else kwargs.pop("serializer")
        self._deserialize: Deserializer = input_args.pop(0) if input_args else kwargs.pop("deserializer")

    @distributed_trace
    def get(self, collection_id: str, **kwargs: Any) -> _models.UserCollectionSettings:
        """Get Config.

        Get the complete user configuration for a given collection.

        :param collection_id: Unique identifier for the STAC collection. Required.
        :type collection_id: str
        :return: UserCollectionSettings. The UserCollectionSettings is compatible with MutableMapping
        :rtype: ~azure.planetarycomputer.models.UserCollectionSettings
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[_models.UserCollectionSettings] = kwargs.pop("cls", None)

        _request = build_stac_collection_config_get_request(
            collection_id=collection_id,
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = kwargs.pop("stream", False)
        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                try:
                    response.read()  # Load the body in memory and close the socket
                except (StreamConsumedError, StreamClosedError):
                    pass
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if _stream:
            deserialized = response.iter_bytes()
        else:
            deserialized = _deserialize(_models.UserCollectionSettings, response.json())

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore


class StacCollectionMosaicsOperations:
    """
    .. warning::
        **DO NOT** instantiate this class directly.

        Instead, you should access the following operations through
        :class:`~azure.planetarycomputer.PlanetaryComputerClient`'s
        :attr:`stac_collection_mosaics` attribute.
    """

    def __init__(self, *args, **kwargs) -> None:
        input_args = list(args)
        self._client: PipelineClient = input_args.pop(0) if input_args else kwargs.pop("client")
        self._config: PlanetaryComputerClientConfiguration = input_args.pop(0) if input_args else kwargs.pop("config")
        self._serialize: Serializer = input_args.pop(0) if input_args else kwargs.pop("serializer")
        self._deserialize: Deserializer = input_args.pop(0) if input_args else kwargs.pop("deserializer")

    @distributed_trace
    def get_all(self, collection_id: str, **kwargs: Any) -> Optional[List[_models.Mosaic]]:
        """Get Collection Mosaics.

        Get the mosaic definitions for a given collection.

        :param collection_id: Unique identifier for the STAC collection. Required.
        :type collection_id: str
        :return: list of Mosaic or None
        :rtype: list[~azure.planetarycomputer.models.Mosaic] or None
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[Optional[List[_models.Mosaic]]] = kwargs.pop("cls", None)

        _request = build_stac_collection_mosaics_get_all_request(
            collection_id=collection_id,
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = kwargs.pop("stream", False)
        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200, 204]:
            if _stream:
                try:
                    response.read()  # Load the body in memory and close the socket
                except (StreamConsumedError, StreamClosedError):
                    pass
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        deserialized = None
        if response.status_code == 200:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(List[_models.Mosaic], response.json())

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore

    @overload
    def add(
        self, collection_id: str, body: _models.Mosaic, *, content_type: str = "application/json", **kwargs: Any
    ) -> _models.Mosaic:
        """Add Collection Mosaic.

        Add a mosaic definition to a given collection.

        :param collection_id: Unique identifier for the STAC collection. Required.
        :type collection_id: str
        :param body: Mosaic definition to be created or updated. Required.
        :type body: ~azure.planetarycomputer.models.Mosaic
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: Mosaic. The Mosaic is compatible with MutableMapping
        :rtype: ~azure.planetarycomputer.models.Mosaic
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @overload
    def add(
        self, collection_id: str, body: JSON, *, content_type: str = "application/json", **kwargs: Any
    ) -> _models.Mosaic:
        """Add Collection Mosaic.

        Add a mosaic definition to a given collection.

        :param collection_id: Unique identifier for the STAC collection. Required.
        :type collection_id: str
        :param body: Mosaic definition to be created or updated. Required.
        :type body: JSON
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: Mosaic. The Mosaic is compatible with MutableMapping
        :rtype: ~azure.planetarycomputer.models.Mosaic
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @overload
    def add(
        self, collection_id: str, body: IO[bytes], *, content_type: str = "application/json", **kwargs: Any
    ) -> _models.Mosaic:
        """Add Collection Mosaic.

        Add a mosaic definition to a given collection.

        :param collection_id: Unique identifier for the STAC collection. Required.
        :type collection_id: str
        :param body: Mosaic definition to be created or updated. Required.
        :type body: IO[bytes]
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: Mosaic. The Mosaic is compatible with MutableMapping
        :rtype: ~azure.planetarycomputer.models.Mosaic
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @distributed_trace
    def add(self, collection_id: str, body: Union[_models.Mosaic, JSON, IO[bytes]], **kwargs: Any) -> _models.Mosaic:
        """Add Collection Mosaic.

        Add a mosaic definition to a given collection.

        :param collection_id: Unique identifier for the STAC collection. Required.
        :type collection_id: str
        :param body: Mosaic definition to be created or updated. Is one of the following types: Mosaic,
         JSON, IO[bytes] Required.
        :type body: ~azure.planetarycomputer.models.Mosaic or JSON or IO[bytes]
        :return: Mosaic. The Mosaic is compatible with MutableMapping
        :rtype: ~azure.planetarycomputer.models.Mosaic
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[_models.Mosaic] = kwargs.pop("cls", None)

        content_type = content_type or "application/json"
        _content = None
        if isinstance(body, (IOBase, bytes)):
            _content = body
        else:
            _content = json.dumps(body, cls=SdkJSONEncoder, exclude_readonly=True)  # type: ignore

        _request = build_stac_collection_mosaics_add_request(
            collection_id=collection_id,
            content_type=content_type,
            api_version=self._config.api_version,
            content=_content,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = kwargs.pop("stream", False)
        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200, 201]:
            if _stream:
                try:
                    response.read()  # Load the body in memory and close the socket
                except (StreamConsumedError, StreamClosedError):
                    pass
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if _stream:
            deserialized = response.iter_bytes()
        else:
            deserialized = _deserialize(_models.Mosaic, response.json())

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore

    @distributed_trace
    def get(self, collection_id: str, mosaic_id: str, **kwargs: Any) -> _models.Mosaic:
        """Get Collection Mosaic.

        Get a mosaic definition from a given collection.

        :param collection_id: Unique identifier for the STAC collection. Required.
        :type collection_id: str
        :param mosaic_id: Unique identifier for the mosaic configuration. Required.
        :type mosaic_id: str
        :return: Mosaic. The Mosaic is compatible with MutableMapping
        :rtype: ~azure.planetarycomputer.models.Mosaic
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[_models.Mosaic] = kwargs.pop("cls", None)

        _request = build_stac_collection_mosaics_get_request(
            collection_id=collection_id,
            mosaic_id=mosaic_id,
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = kwargs.pop("stream", False)
        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                try:
                    response.read()  # Load the body in memory and close the socket
                except (StreamConsumedError, StreamClosedError):
                    pass
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if _stream:
            deserialized = response.iter_bytes()
        else:
            deserialized = _deserialize(_models.Mosaic, response.json())

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore

    @overload
    def create_or_replace(
        self,
        collection_id: str,
        mosaic_id: str,
        body: _models.Mosaic,
        *,
        content_type: str = "application/json",
        **kwargs: Any,
    ) -> _models.Mosaic:
        """Update Collection Mosaic.

        Update a mosaic definition from a given collection.

        :param collection_id: Unique identifier for the STAC collection. Required.
        :type collection_id: str
        :param mosaic_id: Unique identifier for the mosaic configuration. Required.
        :type mosaic_id: str
        :param body: Mosaic definition to be created or updated. Required.
        :type body: ~azure.planetarycomputer.models.Mosaic
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: Mosaic. The Mosaic is compatible with MutableMapping
        :rtype: ~azure.planetarycomputer.models.Mosaic
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @overload
    def create_or_replace(
        self, collection_id: str, mosaic_id: str, body: JSON, *, content_type: str = "application/json", **kwargs: Any
    ) -> _models.Mosaic:
        """Update Collection Mosaic.

        Update a mosaic definition from a given collection.

        :param collection_id: Unique identifier for the STAC collection. Required.
        :type collection_id: str
        :param mosaic_id: Unique identifier for the mosaic configuration. Required.
        :type mosaic_id: str
        :param body: Mosaic definition to be created or updated. Required.
        :type body: JSON
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: Mosaic. The Mosaic is compatible with MutableMapping
        :rtype: ~azure.planetarycomputer.models.Mosaic
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @overload
    def create_or_replace(
        self,
        collection_id: str,
        mosaic_id: str,
        body: IO[bytes],
        *,
        content_type: str = "application/json",
        **kwargs: Any,
    ) -> _models.Mosaic:
        """Update Collection Mosaic.

        Update a mosaic definition from a given collection.

        :param collection_id: Unique identifier for the STAC collection. Required.
        :type collection_id: str
        :param mosaic_id: Unique identifier for the mosaic configuration. Required.
        :type mosaic_id: str
        :param body: Mosaic definition to be created or updated. Required.
        :type body: IO[bytes]
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: Mosaic. The Mosaic is compatible with MutableMapping
        :rtype: ~azure.planetarycomputer.models.Mosaic
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @distributed_trace
    def create_or_replace(
        self, collection_id: str, mosaic_id: str, body: Union[_models.Mosaic, JSON, IO[bytes]], **kwargs: Any
    ) -> _models.Mosaic:
        """Update Collection Mosaic.

        Update a mosaic definition from a given collection.

        :param collection_id: Unique identifier for the STAC collection. Required.
        :type collection_id: str
        :param mosaic_id: Unique identifier for the mosaic configuration. Required.
        :type mosaic_id: str
        :param body: Mosaic definition to be created or updated. Is one of the following types: Mosaic,
         JSON, IO[bytes] Required.
        :type body: ~azure.planetarycomputer.models.Mosaic or JSON or IO[bytes]
        :return: Mosaic. The Mosaic is compatible with MutableMapping
        :rtype: ~azure.planetarycomputer.models.Mosaic
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[_models.Mosaic] = kwargs.pop("cls", None)

        content_type = content_type or "application/json"
        _content = None
        if isinstance(body, (IOBase, bytes)):
            _content = body
        else:
            _content = json.dumps(body, cls=SdkJSONEncoder, exclude_readonly=True)  # type: ignore

        _request = build_stac_collection_mosaics_create_or_replace_request(
            collection_id=collection_id,
            mosaic_id=mosaic_id,
            content_type=content_type,
            api_version=self._config.api_version,
            content=_content,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = kwargs.pop("stream", False)
        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200, 201]:
            if _stream:
                try:
                    response.read()  # Load the body in memory and close the socket
                except (StreamConsumedError, StreamClosedError):
                    pass
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if _stream:
            deserialized = response.iter_bytes()
        else:
            deserialized = _deserialize(_models.Mosaic, response.json())

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore

    @distributed_trace
    def delete(  # pylint: disable=inconsistent-return-statements
        self, collection_id: str, mosaic_id: str, **kwargs: Any
    ) -> None:
        """Delete Collection Mosaic.

        Delete a mosaic definition from a given collection.

        :param collection_id: Unique identifier for the STAC collection. Required.
        :type collection_id: str
        :param mosaic_id: Unique identifier for the mosaic configuration. Required.
        :type mosaic_id: str
        :return: None
        :rtype: None
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[None] = kwargs.pop("cls", None)

        _request = build_stac_collection_mosaics_delete_request(
            collection_id=collection_id,
            mosaic_id=mosaic_id,
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = False
        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200, 204]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if cls:
            return cls(pipeline_response, None, {})  # type: ignore


class StacCollectionPartitionTypesOperations:
    """
    .. warning::
        **DO NOT** instantiate this class directly.

        Instead, you should access the following operations through
        :class:`~azure.planetarycomputer.PlanetaryComputerClient`'s
        :attr:`stac_collection_partition_types` attribute.
    """

    def __init__(self, *args, **kwargs) -> None:
        input_args = list(args)
        self._client: PipelineClient = input_args.pop(0) if input_args else kwargs.pop("client")
        self._config: PlanetaryComputerClientConfiguration = input_args.pop(0) if input_args else kwargs.pop("config")
        self._serialize: Serializer = input_args.pop(0) if input_args else kwargs.pop("serializer")
        self._deserialize: Deserializer = input_args.pop(0) if input_args else kwargs.pop("deserializer")

    @distributed_trace
    def get(self, collection_id: str, **kwargs: Any) -> _models.PartitionType:
        """Get Partitiontype.

        Get the partitiontype for a GeoCatalog Collection.

        Args:
        collection_id: the collection id to get the partitiontype for.

        Returns:
        The partitiontype for the collection.

        :param collection_id: Unique identifier for the STAC collection. Required.
        :type collection_id: str
        :return: PartitionType. The PartitionType is compatible with MutableMapping
        :rtype: ~azure.planetarycomputer.models.PartitionType
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[_models.PartitionType] = kwargs.pop("cls", None)

        _request = build_stac_collection_partition_types_get_request(
            collection_id=collection_id,
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = kwargs.pop("stream", False)
        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                try:
                    response.read()  # Load the body in memory and close the socket
                except (StreamConsumedError, StreamClosedError):
                    pass
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if _stream:
            deserialized = response.iter_bytes()
        else:
            deserialized = _deserialize(_models.PartitionType, response.json())

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore

    @overload
    def replace(
        self, collection_id: str, body: _models.PartitionType, *, content_type: str = "application/json", **kwargs: Any
    ) -> Optional[_models.PartitionType]:
        """Create Partitiontype.

        Updates partition type for a GeoCatalog Collection. This will
        determine the partitioning scheme for items within the database,
        and can only be set before any items are loaded.

        Ideal partitioning schemes result in partitions of roughly 100k items each.

        The default partitioning scheme is "none" which does not partition items.

        Args:
        collection_id: the collection id to add the partitiontype to.
        partitiontype: the partitiontype to add.

        Returns:
        None.

        :param collection_id: Unique identifier for the STAC collection. Required.
        :type collection_id: str
        :param body: Partition type configuration determining how items are partitioned in storage.
         Required.
        :type body: ~azure.planetarycomputer.models.PartitionType
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: PartitionType or None. The PartitionType is compatible with MutableMapping
        :rtype: ~azure.planetarycomputer.models.PartitionType or None
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @overload
    def replace(
        self, collection_id: str, body: JSON, *, content_type: str = "application/json", **kwargs: Any
    ) -> Optional[_models.PartitionType]:
        """Create Partitiontype.

        Updates partition type for a GeoCatalog Collection. This will
        determine the partitioning scheme for items within the database,
        and can only be set before any items are loaded.

        Ideal partitioning schemes result in partitions of roughly 100k items each.

        The default partitioning scheme is "none" which does not partition items.

        Args:
        collection_id: the collection id to add the partitiontype to.
        partitiontype: the partitiontype to add.

        Returns:
        None.

        :param collection_id: Unique identifier for the STAC collection. Required.
        :type collection_id: str
        :param body: Partition type configuration determining how items are partitioned in storage.
         Required.
        :type body: JSON
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: PartitionType or None. The PartitionType is compatible with MutableMapping
        :rtype: ~azure.planetarycomputer.models.PartitionType or None
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @overload
    def replace(
        self, collection_id: str, body: IO[bytes], *, content_type: str = "application/json", **kwargs: Any
    ) -> Optional[_models.PartitionType]:
        """Create Partitiontype.

        Updates partition type for a GeoCatalog Collection. This will
        determine the partitioning scheme for items within the database,
        and can only be set before any items are loaded.

        Ideal partitioning schemes result in partitions of roughly 100k items each.

        The default partitioning scheme is "none" which does not partition items.

        Args:
        collection_id: the collection id to add the partitiontype to.
        partitiontype: the partitiontype to add.

        Returns:
        None.

        :param collection_id: Unique identifier for the STAC collection. Required.
        :type collection_id: str
        :param body: Partition type configuration determining how items are partitioned in storage.
         Required.
        :type body: IO[bytes]
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: PartitionType or None. The PartitionType is compatible with MutableMapping
        :rtype: ~azure.planetarycomputer.models.PartitionType or None
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @distributed_trace
    def replace(
        self, collection_id: str, body: Union[_models.PartitionType, JSON, IO[bytes]], **kwargs: Any
    ) -> Optional[_models.PartitionType]:
        """Create Partitiontype.

        Updates partition type for a GeoCatalog Collection. This will
        determine the partitioning scheme for items within the database,
        and can only be set before any items are loaded.

        Ideal partitioning schemes result in partitions of roughly 100k items each.

        The default partitioning scheme is "none" which does not partition items.

        Args:
        collection_id: the collection id to add the partitiontype to.
        partitiontype: the partitiontype to add.

        Returns:
        None.

        :param collection_id: Unique identifier for the STAC collection. Required.
        :type collection_id: str
        :param body: Partition type configuration determining how items are partitioned in storage. Is
         one of the following types: PartitionType, JSON, IO[bytes] Required.
        :type body: ~azure.planetarycomputer.models.PartitionType or JSON or IO[bytes]
        :return: PartitionType or None. The PartitionType is compatible with MutableMapping
        :rtype: ~azure.planetarycomputer.models.PartitionType or None
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[Optional[_models.PartitionType]] = kwargs.pop("cls", None)

        content_type = content_type or "application/json"
        _content = None
        if isinstance(body, (IOBase, bytes)):
            _content = body
        else:
            _content = json.dumps(body, cls=SdkJSONEncoder, exclude_readonly=True)  # type: ignore

        _request = build_stac_collection_partition_types_replace_request(
            collection_id=collection_id,
            content_type=content_type,
            api_version=self._config.api_version,
            content=_content,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = kwargs.pop("stream", False)
        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200, 204]:
            if _stream:
                try:
                    response.read()  # Load the body in memory and close the socket
                except (StreamConsumedError, StreamClosedError):
                    pass
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        deserialized = None
        if response.status_code == 200:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.PartitionType, response.json())

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore


class StacCollectionRenderOptionsOperations:
    """
    .. warning::
        **DO NOT** instantiate this class directly.

        Instead, you should access the following operations through
        :class:`~azure.planetarycomputer.PlanetaryComputerClient`'s
        :attr:`stac_collection_render_options` attribute.
    """

    def __init__(self, *args, **kwargs) -> None:
        input_args = list(args)
        self._client: PipelineClient = input_args.pop(0) if input_args else kwargs.pop("client")
        self._config: PlanetaryComputerClientConfiguration = input_args.pop(0) if input_args else kwargs.pop("config")
        self._serialize: Serializer = input_args.pop(0) if input_args else kwargs.pop("serializer")
        self._deserialize: Deserializer = input_args.pop(0) if input_args else kwargs.pop("deserializer")

    @distributed_trace
    def get_all(self, collection_id: str, **kwargs: Any) -> Optional[List[_models.RenderOption]]:
        """Get Collection Render Options.

        Get all render options for a given collection.

        :param collection_id: Unique identifier for the STAC collection. Required.
        :type collection_id: str
        :return: list of RenderOption or None
        :rtype: list[~azure.planetarycomputer.models.RenderOption] or None
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[Optional[List[_models.RenderOption]]] = kwargs.pop("cls", None)

        _request = build_stac_collection_render_options_get_all_request(
            collection_id=collection_id,
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = kwargs.pop("stream", False)
        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200, 204]:
            if _stream:
                try:
                    response.read()  # Load the body in memory and close the socket
                except (StreamConsumedError, StreamClosedError):
                    pass
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        deserialized = None
        if response.status_code == 200:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(List[_models.RenderOption], response.json())

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore

    @overload
    def create(
        self, collection_id: str, body: _models.RenderOption, *, content_type: str = "application/json", **kwargs: Any
    ) -> _models.RenderOption:
        """Add Collection Render Option.

        Add a render option for a given collection.

        :param collection_id: Unique identifier for the STAC collection. Required.
        :type collection_id: str
        :param body: Render option configuration to be created or updated. Required.
        :type body: ~azure.planetarycomputer.models.RenderOption
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: RenderOption. The RenderOption is compatible with MutableMapping
        :rtype: ~azure.planetarycomputer.models.RenderOption
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @overload
    def create(
        self, collection_id: str, body: JSON, *, content_type: str = "application/json", **kwargs: Any
    ) -> _models.RenderOption:
        """Add Collection Render Option.

        Add a render option for a given collection.

        :param collection_id: Unique identifier for the STAC collection. Required.
        :type collection_id: str
        :param body: Render option configuration to be created or updated. Required.
        :type body: JSON
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: RenderOption. The RenderOption is compatible with MutableMapping
        :rtype: ~azure.planetarycomputer.models.RenderOption
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @overload
    def create(
        self, collection_id: str, body: IO[bytes], *, content_type: str = "application/json", **kwargs: Any
    ) -> _models.RenderOption:
        """Add Collection Render Option.

        Add a render option for a given collection.

        :param collection_id: Unique identifier for the STAC collection. Required.
        :type collection_id: str
        :param body: Render option configuration to be created or updated. Required.
        :type body: IO[bytes]
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: RenderOption. The RenderOption is compatible with MutableMapping
        :rtype: ~azure.planetarycomputer.models.RenderOption
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @distributed_trace
    def create(
        self, collection_id: str, body: Union[_models.RenderOption, JSON, IO[bytes]], **kwargs: Any
    ) -> _models.RenderOption:
        """Add Collection Render Option.

        Add a render option for a given collection.

        :param collection_id: Unique identifier for the STAC collection. Required.
        :type collection_id: str
        :param body: Render option configuration to be created or updated. Is one of the following
         types: RenderOption, JSON, IO[bytes] Required.
        :type body: ~azure.planetarycomputer.models.RenderOption or JSON or IO[bytes]
        :return: RenderOption. The RenderOption is compatible with MutableMapping
        :rtype: ~azure.planetarycomputer.models.RenderOption
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[_models.RenderOption] = kwargs.pop("cls", None)

        content_type = content_type or "application/json"
        _content = None
        if isinstance(body, (IOBase, bytes)):
            _content = body
        else:
            _content = json.dumps(body, cls=SdkJSONEncoder, exclude_readonly=True)  # type: ignore

        _request = build_stac_collection_render_options_create_request(
            collection_id=collection_id,
            content_type=content_type,
            api_version=self._config.api_version,
            content=_content,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = kwargs.pop("stream", False)
        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200, 201]:
            if _stream:
                try:
                    response.read()  # Load the body in memory and close the socket
                except (StreamConsumedError, StreamClosedError):
                    pass
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if _stream:
            deserialized = response.iter_bytes()
        else:
            deserialized = _deserialize(_models.RenderOption, response.json())

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore

    @distributed_trace
    def get(self, collection_id: str, render_option_id: str, **kwargs: Any) -> List[_models.RenderOption]:
        """Get Collection Render Option.

        Get a render option for a given collection.

        :param collection_id: Unique identifier for the STAC collection. Required.
        :type collection_id: str
        :param render_option_id: Unique identifier for the render option. Required.
        :type render_option_id: str
        :return: list of RenderOption
        :rtype: list[~azure.planetarycomputer.models.RenderOption]
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[List[_models.RenderOption]] = kwargs.pop("cls", None)

        _request = build_stac_collection_render_options_get_request(
            collection_id=collection_id,
            render_option_id=render_option_id,
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = kwargs.pop("stream", False)
        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                try:
                    response.read()  # Load the body in memory and close the socket
                except (StreamConsumedError, StreamClosedError):
                    pass
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if _stream:
            deserialized = response.iter_bytes()
        else:
            deserialized = _deserialize(List[_models.RenderOption], response.json())

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore

    @overload
    def create_or_replace(
        self,
        collection_id: str,
        render_option_id: str,
        body: _models.RenderOption,
        *,
        content_type: str = "application/json",
        **kwargs: Any,
    ) -> _models.RenderOption:
        """Update Collection Render Option.

        Update a render option for a given collection.

        :param collection_id: Unique identifier for the STAC collection. Required.
        :type collection_id: str
        :param render_option_id: Unique identifier for the render option. Required.
        :type render_option_id: str
        :param body: Render option configuration to be created or updated. Required.
        :type body: ~azure.planetarycomputer.models.RenderOption
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: RenderOption. The RenderOption is compatible with MutableMapping
        :rtype: ~azure.planetarycomputer.models.RenderOption
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @overload
    def create_or_replace(
        self,
        collection_id: str,
        render_option_id: str,
        body: JSON,
        *,
        content_type: str = "application/json",
        **kwargs: Any,
    ) -> _models.RenderOption:
        """Update Collection Render Option.

        Update a render option for a given collection.

        :param collection_id: Unique identifier for the STAC collection. Required.
        :type collection_id: str
        :param render_option_id: Unique identifier for the render option. Required.
        :type render_option_id: str
        :param body: Render option configuration to be created or updated. Required.
        :type body: JSON
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: RenderOption. The RenderOption is compatible with MutableMapping
        :rtype: ~azure.planetarycomputer.models.RenderOption
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @overload
    def create_or_replace(
        self,
        collection_id: str,
        render_option_id: str,
        body: IO[bytes],
        *,
        content_type: str = "application/json",
        **kwargs: Any,
    ) -> _models.RenderOption:
        """Update Collection Render Option.

        Update a render option for a given collection.

        :param collection_id: Unique identifier for the STAC collection. Required.
        :type collection_id: str
        :param render_option_id: Unique identifier for the render option. Required.
        :type render_option_id: str
        :param body: Render option configuration to be created or updated. Required.
        :type body: IO[bytes]
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: RenderOption. The RenderOption is compatible with MutableMapping
        :rtype: ~azure.planetarycomputer.models.RenderOption
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @distributed_trace
    def create_or_replace(
        self,
        collection_id: str,
        render_option_id: str,
        body: Union[_models.RenderOption, JSON, IO[bytes]],
        **kwargs: Any,
    ) -> _models.RenderOption:
        """Update Collection Render Option.

        Update a render option for a given collection.

        :param collection_id: Unique identifier for the STAC collection. Required.
        :type collection_id: str
        :param render_option_id: Unique identifier for the render option. Required.
        :type render_option_id: str
        :param body: Render option configuration to be created or updated. Is one of the following
         types: RenderOption, JSON, IO[bytes] Required.
        :type body: ~azure.planetarycomputer.models.RenderOption or JSON or IO[bytes]
        :return: RenderOption. The RenderOption is compatible with MutableMapping
        :rtype: ~azure.planetarycomputer.models.RenderOption
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[_models.RenderOption] = kwargs.pop("cls", None)

        content_type = content_type or "application/json"
        _content = None
        if isinstance(body, (IOBase, bytes)):
            _content = body
        else:
            _content = json.dumps(body, cls=SdkJSONEncoder, exclude_readonly=True)  # type: ignore

        _request = build_stac_collection_render_options_create_or_replace_request(
            collection_id=collection_id,
            render_option_id=render_option_id,
            content_type=content_type,
            api_version=self._config.api_version,
            content=_content,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = kwargs.pop("stream", False)
        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200, 201]:
            if _stream:
                try:
                    response.read()  # Load the body in memory and close the socket
                except (StreamConsumedError, StreamClosedError):
                    pass
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if _stream:
            deserialized = response.iter_bytes()
        else:
            deserialized = _deserialize(_models.RenderOption, response.json())

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore

    @distributed_trace
    def delete(  # pylint: disable=inconsistent-return-statements
        self, collection_id: str, render_option_id: str, **kwargs: Any
    ) -> None:
        """Delete Collection Render Option.

        Delete a render option for a given collection.

        :param collection_id: Unique identifier for the STAC collection. Required.
        :type collection_id: str
        :param render_option_id: Unique identifier for the render option. Required.
        :type render_option_id: str
        :return: None
        :rtype: None
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[None] = kwargs.pop("cls", None)

        _request = build_stac_collection_render_options_delete_request(
            collection_id=collection_id,
            render_option_id=render_option_id,
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = False
        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200, 204]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if cls:
            return cls(pipeline_response, None, {})  # type: ignore


class StacCollectionTileSettingsOperations:
    """
    .. warning::
        **DO NOT** instantiate this class directly.

        Instead, you should access the following operations through
        :class:`~azure.planetarycomputer.PlanetaryComputerClient`'s
        :attr:`stac_collection_tile_settings` attribute.
    """

    def __init__(self, *args, **kwargs) -> None:
        input_args = list(args)
        self._client: PipelineClient = input_args.pop(0) if input_args else kwargs.pop("client")
        self._config: PlanetaryComputerClientConfiguration = input_args.pop(0) if input_args else kwargs.pop("config")
        self._serialize: Serializer = input_args.pop(0) if input_args else kwargs.pop("serializer")
        self._deserialize: Deserializer = input_args.pop(0) if input_args else kwargs.pop("deserializer")

    @distributed_trace
    def get_all(self, collection_id: str, **kwargs: Any) -> _models.TileSettings:
        """Get Collection Tile Settings.

        Get the tile settings for a given collection.

        :param collection_id: Unique identifier for the STAC collection. Required.
        :type collection_id: str
        :return: TileSettings. The TileSettings is compatible with MutableMapping
        :rtype: ~azure.planetarycomputer.models.TileSettings
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[_models.TileSettings] = kwargs.pop("cls", None)

        _request = build_stac_collection_tile_settings_get_all_request(
            collection_id=collection_id,
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = kwargs.pop("stream", False)
        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                try:
                    response.read()  # Load the body in memory and close the socket
                except (StreamConsumedError, StreamClosedError):
                    pass
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if _stream:
            deserialized = response.iter_bytes()
        else:
            deserialized = _deserialize(_models.TileSettings, response.json())

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore

    @overload
    def replace(
        self, collection_id: str, body: _models.TileSettings, *, content_type: str = "application/json", **kwargs: Any
    ) -> _models.TileSettings:
        """Update Collection Tile Settings.

        Update the tile settings for a given collection.

        :param collection_id: Unique identifier for the STAC collection. Required.
        :type collection_id: str
        :param body: Tile settings configuration to be updated. Required.
        :type body: ~azure.planetarycomputer.models.TileSettings
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: TileSettings. The TileSettings is compatible with MutableMapping
        :rtype: ~azure.planetarycomputer.models.TileSettings
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @overload
    def replace(
        self, collection_id: str, body: JSON, *, content_type: str = "application/json", **kwargs: Any
    ) -> _models.TileSettings:
        """Update Collection Tile Settings.

        Update the tile settings for a given collection.

        :param collection_id: Unique identifier for the STAC collection. Required.
        :type collection_id: str
        :param body: Tile settings configuration to be updated. Required.
        :type body: JSON
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: TileSettings. The TileSettings is compatible with MutableMapping
        :rtype: ~azure.planetarycomputer.models.TileSettings
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @overload
    def replace(
        self, collection_id: str, body: IO[bytes], *, content_type: str = "application/json", **kwargs: Any
    ) -> _models.TileSettings:
        """Update Collection Tile Settings.

        Update the tile settings for a given collection.

        :param collection_id: Unique identifier for the STAC collection. Required.
        :type collection_id: str
        :param body: Tile settings configuration to be updated. Required.
        :type body: IO[bytes]
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: TileSettings. The TileSettings is compatible with MutableMapping
        :rtype: ~azure.planetarycomputer.models.TileSettings
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @distributed_trace
    def replace(
        self, collection_id: str, body: Union[_models.TileSettings, JSON, IO[bytes]], **kwargs: Any
    ) -> _models.TileSettings:
        """Update Collection Tile Settings.

        Update the tile settings for a given collection.

        :param collection_id: Unique identifier for the STAC collection. Required.
        :type collection_id: str
        :param body: Tile settings configuration to be updated. Is one of the following types:
         TileSettings, JSON, IO[bytes] Required.
        :type body: ~azure.planetarycomputer.models.TileSettings or JSON or IO[bytes]
        :return: TileSettings. The TileSettings is compatible with MutableMapping
        :rtype: ~azure.planetarycomputer.models.TileSettings
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[_models.TileSettings] = kwargs.pop("cls", None)

        content_type = content_type or "application/json"
        _content = None
        if isinstance(body, (IOBase, bytes)):
            _content = body
        else:
            _content = json.dumps(body, cls=SdkJSONEncoder, exclude_readonly=True)  # type: ignore

        _request = build_stac_collection_tile_settings_replace_request(
            collection_id=collection_id,
            content_type=content_type,
            api_version=self._config.api_version,
            content=_content,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = kwargs.pop("stream", False)
        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                try:
                    response.read()  # Load the body in memory and close the socket
                except (StreamConsumedError, StreamClosedError):
                    pass
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if _stream:
            deserialized = response.iter_bytes()
        else:
            deserialized = _deserialize(_models.TileSettings, response.json())

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore


class StacCollectionThumbnailsOperations:
    """
    .. warning::
        **DO NOT** instantiate this class directly.

        Instead, you should access the following operations through
        :class:`~azure.planetarycomputer.PlanetaryComputerClient`'s
        :attr:`stac_collection_thumbnails` attribute.
    """

    def __init__(self, *args, **kwargs) -> None:
        input_args = list(args)
        self._client: PipelineClient = input_args.pop(0) if input_args else kwargs.pop("client")
        self._config: PlanetaryComputerClientConfiguration = input_args.pop(0) if input_args else kwargs.pop("config")
        self._serialize: Serializer = input_args.pop(0) if input_args else kwargs.pop("serializer")
        self._deserialize: Deserializer = input_args.pop(0) if input_args else kwargs.pop("deserializer")

    @distributed_trace
    def get(self, collection_id: str, **kwargs: Any) -> Optional[Iterator[bytes]]:
        """Get Collection Thumbnail.

        Get thumbnail for given collection.

        Args:
        request: The incoming request.
        collection_id: The ID of the collection to retrieve assets for.

        Returns:
        thumbnail image.

        :param collection_id: STAC Collection ID. Required.
        :type collection_id: str
        :return: Iterator[bytes] or None
        :rtype: Iterator[bytes] or None
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[Optional[Iterator[bytes]]] = kwargs.pop("cls", None)

        _request = build_stac_collection_thumbnails_get_request(
            collection_id=collection_id,
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = kwargs.pop("stream", True)
        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200, 204]:
            if _stream:
                try:
                    response.read()  # Load the body in memory and close the socket
                except (StreamConsumedError, StreamClosedError):
                    pass
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        deserialized = None
        response_headers = {}
        if response.status_code == 200:
            response_headers["content-type"] = self._deserialize("str", response.headers.get("content-type"))
            response_headers["content-type"] = self._deserialize("str", response.headers.get("content-type"))
            response_headers["content-type"] = self._deserialize("str", response.headers.get("content-type"))
            response_headers["content-type"] = self._deserialize("str", response.headers.get("content-type"))
            response_headers["content-type"] = self._deserialize("str", response.headers.get("content-type"))
            response_headers["content-type"] = self._deserialize("str", response.headers.get("content-type"))
            response_headers["content-type"] = self._deserialize("str", response.headers.get("content-type"))

            deserialized = response.iter_bytes()

        if cls:
            return cls(pipeline_response, deserialized, response_headers)  # type: ignore

        return deserialized  # type: ignore


class GeoCatalogAuthConfigOperationsOperations:
    """
    .. warning::
        **DO NOT** instantiate this class directly.

        Instead, you should access the following operations through
        :class:`~azure.planetarycomputer.PlanetaryComputerClient`'s
        :attr:`geo_catalog_auth_config_operations` attribute.
    """

    def __init__(self, *args, **kwargs) -> None:
        input_args = list(args)
        self._client: PipelineClient = input_args.pop(0) if input_args else kwargs.pop("client")
        self._config: PlanetaryComputerClientConfiguration = input_args.pop(0) if input_args else kwargs.pop("config")
        self._serialize: Serializer = input_args.pop(0) if input_args else kwargs.pop("serializer")
        self._deserialize: Deserializer = input_args.pop(0) if input_args else kwargs.pop("deserializer")

    @distributed_trace
    def get(self, **kwargs: Any) -> _models.AuthConfig:
        """Get Auth Config.

        Get the app id and tenant id information to make a MSAL request for this
        GeoCatalog instance.

        :return: AuthConfig. The AuthConfig is compatible with MutableMapping
        :rtype: ~azure.planetarycomputer.models.AuthConfig
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[_models.AuthConfig] = kwargs.pop("cls", None)

        _request = build_geo_catalog_auth_config_operations_get_request(
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = kwargs.pop("stream", False)
        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                try:
                    response.read()  # Load the body in memory and close the socket
                except (StreamConsumedError, StreamClosedError):
                    pass
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if _stream:
            deserialized = response.iter_bytes()
        else:
            deserialized = _deserialize(_models.AuthConfig, response.json())

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore


class GeoCatalogAzmapsClientOperations:
    """
    .. warning::
        **DO NOT** instantiate this class directly.

        Instead, you should access the following operations through
        :class:`~azure.planetarycomputer.PlanetaryComputerClient`'s
        :attr:`geo_catalog_azmaps_client` attribute.
    """

    def __init__(self, *args, **kwargs) -> None:
        input_args = list(args)
        self._client: PipelineClient = input_args.pop(0) if input_args else kwargs.pop("client")
        self._config: PlanetaryComputerClientConfiguration = input_args.pop(0) if input_args else kwargs.pop("config")
        self._serialize: Serializer = input_args.pop(0) if input_args else kwargs.pop("serializer")
        self._deserialize: Deserializer = input_args.pop(0) if input_args else kwargs.pop("deserializer")

    @distributed_trace
    def get_id(self, **kwargs: Any) -> _models.AzMapsClientId:
        """Get Azmaps Client Id.

        Fetch the client id for the Azure Maps API service based on the current
        on the current identity. This client id is used for the Explorer to
        authenticate with the Azure Maps API service.

        :return: AzMapsClientId. The AzMapsClientId is compatible with MutableMapping
        :rtype: ~azure.planetarycomputer.models.AzMapsClientId
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[_models.AzMapsClientId] = kwargs.pop("cls", None)

        _request = build_geo_catalog_azmaps_client_get_id_request(
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = kwargs.pop("stream", False)
        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                try:
                    response.read()  # Load the body in memory and close the socket
                except (StreamConsumedError, StreamClosedError):
                    pass
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if _stream:
            deserialized = response.iter_bytes()
        else:
            deserialized = _deserialize(_models.AzMapsClientId, response.json())

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore


class GeoCatalogAzmapsTokenOperations:
    """
    .. warning::
        **DO NOT** instantiate this class directly.

        Instead, you should access the following operations through
        :class:`~azure.planetarycomputer.PlanetaryComputerClient`'s
        :attr:`geo_catalog_azmaps_token` attribute.
    """

    def __init__(self, *args, **kwargs) -> None:
        input_args = list(args)
        self._client: PipelineClient = input_args.pop(0) if input_args else kwargs.pop("client")
        self._config: PlanetaryComputerClientConfiguration = input_args.pop(0) if input_args else kwargs.pop("config")
        self._serialize: Serializer = input_args.pop(0) if input_args else kwargs.pop("serializer")
        self._deserialize: Deserializer = input_args.pop(0) if input_args else kwargs.pop("deserializer")

    @distributed_trace
    def get(self, **kwargs: Any) -> _models.AzMapsToken:
        """Get Azmaps Token.

        Fetch a token for the Azure Maps API service based on the current
        service identity. This token is used for the Explorer to authenticate
        with the Azure Maps API service.

        :return: AzMapsToken. The AzMapsToken is compatible with MutableMapping
        :rtype: ~azure.planetarycomputer.models.AzMapsToken
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[_models.AzMapsToken] = kwargs.pop("cls", None)

        _request = build_geo_catalog_azmaps_token_get_request(
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = kwargs.pop("stream", False)
        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                try:
                    response.read()  # Load the body in memory and close the socket
                except (StreamConsumedError, StreamClosedError):
                    pass
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if _stream:
            deserialized = response.iter_bytes()
        else:
            deserialized = _deserialize(_models.AzMapsToken, response.json())

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore


class TilerStaticImagesOperations:
    """
    .. warning::
        **DO NOT** instantiate this class directly.

        Instead, you should access the following operations through
        :class:`~azure.planetarycomputer.PlanetaryComputerClient`'s
        :attr:`tiler_static_images` attribute.
    """

    def __init__(self, *args, **kwargs) -> None:
        input_args = list(args)
        self._client: PipelineClient = input_args.pop(0) if input_args else kwargs.pop("client")
        self._config: PlanetaryComputerClientConfiguration = input_args.pop(0) if input_args else kwargs.pop("config")
        self._serialize: Serializer = input_args.pop(0) if input_args else kwargs.pop("serializer")
        self._deserialize: Deserializer = input_args.pop(0) if input_args else kwargs.pop("deserializer")

    @overload
    def create(
        self, collection_id: str, body: _models.ImageRequest, *, content_type: str = "application/json", **kwargs: Any
    ) -> _models.ImageResponse:
        """Create Static Image.

        Create a new image export.

        :param collection_id: STAC Collection ID. Required.
        :type collection_id: str
        :param body: Image request body. Required.
        :type body: ~azure.planetarycomputer.models.ImageRequest
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: ImageResponse. The ImageResponse is compatible with MutableMapping
        :rtype: ~azure.planetarycomputer.models.ImageResponse
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @overload
    def create(
        self, collection_id: str, body: JSON, *, content_type: str = "application/json", **kwargs: Any
    ) -> _models.ImageResponse:
        """Create Static Image.

        Create a new image export.

        :param collection_id: STAC Collection ID. Required.
        :type collection_id: str
        :param body: Image request body. Required.
        :type body: JSON
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: ImageResponse. The ImageResponse is compatible with MutableMapping
        :rtype: ~azure.planetarycomputer.models.ImageResponse
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @overload
    def create(
        self, collection_id: str, body: IO[bytes], *, content_type: str = "application/json", **kwargs: Any
    ) -> _models.ImageResponse:
        """Create Static Image.

        Create a new image export.

        :param collection_id: STAC Collection ID. Required.
        :type collection_id: str
        :param body: Image request body. Required.
        :type body: IO[bytes]
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: ImageResponse. The ImageResponse is compatible with MutableMapping
        :rtype: ~azure.planetarycomputer.models.ImageResponse
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @distributed_trace
    def create(
        self, collection_id: str, body: Union[_models.ImageRequest, JSON, IO[bytes]], **kwargs: Any
    ) -> _models.ImageResponse:
        """Create Static Image.

        Create a new image export.

        :param collection_id: STAC Collection ID. Required.
        :type collection_id: str
        :param body: Image request body. Is one of the following types: ImageRequest, JSON, IO[bytes]
         Required.
        :type body: ~azure.planetarycomputer.models.ImageRequest or JSON or IO[bytes]
        :return: ImageResponse. The ImageResponse is compatible with MutableMapping
        :rtype: ~azure.planetarycomputer.models.ImageResponse
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[_models.ImageResponse] = kwargs.pop("cls", None)

        content_type = content_type or "application/json"
        _content = None
        if isinstance(body, (IOBase, bytes)):
            _content = body
        else:
            _content = json.dumps(body, cls=SdkJSONEncoder, exclude_readonly=True)  # type: ignore

        _request = build_tiler_static_images_create_request(
            collection_id=collection_id,
            content_type=content_type,
            api_version=self._config.api_version,
            content=_content,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = kwargs.pop("stream", False)
        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                try:
                    response.read()  # Load the body in memory and close the socket
                except (StreamConsumedError, StreamClosedError):
                    pass
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if _stream:
            deserialized = response.iter_bytes()
        else:
            deserialized = _deserialize(_models.ImageResponse, response.json())

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore

    @distributed_trace
    def get(self, collection_id: str, id: str, **kwargs: Any) -> Optional[Iterator[bytes]]:
        """Get Static Image.

        Fetch an existing image export by ID.

        :param collection_id: STAC Collection ID. Required.
        :type collection_id: str
        :param id: Image export ID. Required.
        :type id: str
        :return: Iterator[bytes] or None
        :rtype: Iterator[bytes] or None
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[Optional[Iterator[bytes]]] = kwargs.pop("cls", None)

        _request = build_tiler_static_images_get_request(
            collection_id=collection_id,
            id=id,
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = kwargs.pop("stream", True)
        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200, 204]:
            if _stream:
                try:
                    response.read()  # Load the body in memory and close the socket
                except (StreamConsumedError, StreamClosedError):
                    pass
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        deserialized = None
        response_headers = {}
        if response.status_code == 200:
            response_headers["content-type"] = self._deserialize("str", response.headers.get("content-type"))

            deserialized = response.iter_bytes()

        if cls:
            return cls(pipeline_response, deserialized, response_headers)  # type: ignore

        return deserialized  # type: ignore


class TilerBoundOperations:
    """
    .. warning::
        **DO NOT** instantiate this class directly.

        Instead, you should access the following operations through
        :class:`~azure.planetarycomputer.PlanetaryComputerClient`'s
        :attr:`tiler_bound` attribute.
    """

    def __init__(self, *args, **kwargs) -> None:
        input_args = list(args)
        self._client: PipelineClient = input_args.pop(0) if input_args else kwargs.pop("client")
        self._config: PlanetaryComputerClientConfiguration = input_args.pop(0) if input_args else kwargs.pop("config")
        self._serialize: Serializer = input_args.pop(0) if input_args else kwargs.pop("serializer")
        self._deserialize: Deserializer = input_args.pop(0) if input_args else kwargs.pop("deserializer")

    @distributed_trace
    def get_all(self, collection_id: str, item_id: str, **kwargs: Any) -> _models.BoundsResponse:
        """Bounds.

        Return all Bounds.

        :param collection_id: STAC Collection Identifier. Required.
        :type collection_id: str
        :param item_id: STAC Item Identifier. Required.
        :type item_id: str
        :return: BoundsResponse. The BoundsResponse is compatible with MutableMapping
        :rtype: ~azure.planetarycomputer.models.BoundsResponse
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[_models.BoundsResponse] = kwargs.pop("cls", None)

        _request = build_tiler_bound_get_all_request(
            collection_id=collection_id,
            item_id=item_id,
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = kwargs.pop("stream", False)
        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                try:
                    response.read()  # Load the body in memory and close the socket
                except (StreamConsumedError, StreamClosedError):
                    pass
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if _stream:
            deserialized = response.iter_bytes()
        else:
            deserialized = _deserialize(_models.BoundsResponse, response.json())

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore


class TilerInfoOperationsOperations:
    """
    .. warning::
        **DO NOT** instantiate this class directly.

        Instead, you should access the following operations through
        :class:`~azure.planetarycomputer.PlanetaryComputerClient`'s
        :attr:`tiler_info_operations` attribute.
    """

    def __init__(self, *args, **kwargs) -> None:
        input_args = list(args)
        self._client: PipelineClient = input_args.pop(0) if input_args else kwargs.pop("client")
        self._config: PlanetaryComputerClientConfiguration = input_args.pop(0) if input_args else kwargs.pop("config")
        self._serialize: Serializer = input_args.pop(0) if input_args else kwargs.pop("serializer")
        self._deserialize: Deserializer = input_args.pop(0) if input_args else kwargs.pop("deserializer")

    @distributed_trace
    def get(
        self, collection_id: str, item_id: str, *, assets: Optional[List[str]] = None, **kwargs: Any
    ) -> _models.InfoOperationResponse:
        """Info.

        Return dataset's basic info.

        :param collection_id: STAC Collection Identifier. Required.
        :type collection_id: str
        :param item_id: STAC Item Identifier. Required.
        :type item_id: str
        :keyword assets: Asset's names. Default value is None.
        :paramtype assets: list[str]
        :return: InfoOperationResponse. The InfoOperationResponse is compatible with MutableMapping
        :rtype: ~azure.planetarycomputer.models.InfoOperationResponse
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[_models.InfoOperationResponse] = kwargs.pop("cls", None)

        _request = build_tiler_info_operations_get_request(
            collection_id=collection_id,
            item_id=item_id,
            assets=assets,
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = kwargs.pop("stream", False)
        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                try:
                    response.read()  # Load the body in memory and close the socket
                except (StreamConsumedError, StreamClosedError):
                    pass
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if _stream:
            deserialized = response.iter_bytes()
        else:
            deserialized = _deserialize(_models.InfoOperationResponse, response.json())

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore


class TilerInfoGeoJsonOperationsOperations:
    """
    .. warning::
        **DO NOT** instantiate this class directly.

        Instead, you should access the following operations through
        :class:`~azure.planetarycomputer.PlanetaryComputerClient`'s
        :attr:`tiler_info_geo_json_operations` attribute.
    """

    def __init__(self, *args, **kwargs) -> None:
        input_args = list(args)
        self._client: PipelineClient = input_args.pop(0) if input_args else kwargs.pop("client")
        self._config: PlanetaryComputerClientConfiguration = input_args.pop(0) if input_args else kwargs.pop("config")
        self._serialize: Serializer = input_args.pop(0) if input_args else kwargs.pop("serializer")
        self._deserialize: Deserializer = input_args.pop(0) if input_args else kwargs.pop("deserializer")

    @distributed_trace
    def get(
        self, collection_id: str, item_id: str, *, assets: Optional[List[str]] = None, **kwargs: Any
    ) -> _models.TilerInfoGeoJsonFeature:
        """Info Geojson.

        Return Info Geojson.

        :param collection_id: STAC Collection Identifier. Required.
        :type collection_id: str
        :param item_id: STAC Item Identifier. Required.
        :type item_id: str
        :keyword assets: Asset's names. Default value is None.
        :paramtype assets: list[str]
        :return: TilerInfoGeoJsonFeature. The TilerInfoGeoJsonFeature is compatible with MutableMapping
        :rtype: ~azure.planetarycomputer.models.TilerInfoGeoJsonFeature
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[_models.TilerInfoGeoJsonFeature] = kwargs.pop("cls", None)

        _request = build_tiler_info_geo_json_operations_get_request(
            collection_id=collection_id,
            item_id=item_id,
            assets=assets,
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = kwargs.pop("stream", False)
        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                try:
                    response.read()  # Load the body in memory and close the socket
                except (StreamConsumedError, StreamClosedError):
                    pass
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if _stream:
            deserialized = response.iter_bytes()
        else:
            deserialized = _deserialize(_models.TilerInfoGeoJsonFeature, response.json())

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore


class TilerAvailableAssetsOperations:
    """
    .. warning::
        **DO NOT** instantiate this class directly.

        Instead, you should access the following operations through
        :class:`~azure.planetarycomputer.PlanetaryComputerClient`'s
        :attr:`tiler_available_assets` attribute.
    """

    def __init__(self, *args, **kwargs) -> None:
        input_args = list(args)
        self._client: PipelineClient = input_args.pop(0) if input_args else kwargs.pop("client")
        self._config: PlanetaryComputerClientConfiguration = input_args.pop(0) if input_args else kwargs.pop("config")
        self._serialize: Serializer = input_args.pop(0) if input_args else kwargs.pop("serializer")
        self._deserialize: Deserializer = input_args.pop(0) if input_args else kwargs.pop("deserializer")

    @distributed_trace
    def get_all(self, collection_id: str, item_id: str, **kwargs: Any) -> Optional[List[str]]:
        """Available Assets.

        Return a list of supported assets.

        :param collection_id: STAC Collection Identifier. Required.
        :type collection_id: str
        :param item_id: STAC Item Identifier. Required.
        :type item_id: str
        :return: list of str or None
        :rtype: list[str] or None
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[Optional[List[str]]] = kwargs.pop("cls", None)

        _request = build_tiler_available_assets_get_all_request(
            collection_id=collection_id,
            item_id=item_id,
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = kwargs.pop("stream", False)
        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200, 204]:
            if _stream:
                try:
                    response.read()  # Load the body in memory and close the socket
                except (StreamConsumedError, StreamClosedError):
                    pass
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        deserialized = None
        if response.status_code == 200:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(List[str], response.json())

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore


class TilerAssetStatisticsOperations:
    """
    .. warning::
        **DO NOT** instantiate this class directly.

        Instead, you should access the following operations through
        :class:`~azure.planetarycomputer.PlanetaryComputerClient`'s
        :attr:`tiler_asset_statistics` attribute.
    """

    def __init__(self, *args, **kwargs) -> None:
        input_args = list(args)
        self._client: PipelineClient = input_args.pop(0) if input_args else kwargs.pop("client")
        self._config: PlanetaryComputerClientConfiguration = input_args.pop(0) if input_args else kwargs.pop("config")
        self._serialize: Serializer = input_args.pop(0) if input_args else kwargs.pop("serializer")
        self._deserialize: Deserializer = input_args.pop(0) if input_args else kwargs.pop("deserializer")

    @distributed_trace
    def get_all(
        self,
        collection_id: str,
        item_id: str,
        *,
        assets: Optional[List[str]] = None,
        expression: Optional[str] = None,
        asset_bidx: Optional[List[str]] = None,
        asset_as_band: Optional[bool] = None,
        nodata: Optional[float] = None,
        unscale: Optional[bool] = None,
        resampling: Optional[Union[str, _models.Resampling]] = None,
        max_size: Optional[int] = None,
        categorical: Optional[bool] = None,
        c: Optional[List[str]] = None,
        p: Optional[List[int]] = None,
        histogram_bins: Optional[str] = None,
        histogram_range: Optional[str] = None,
        **kwargs: Any,
    ) -> _models.AssetStatisticsResponse:
        """Asset Statistics.

        Per Asset statistics.

        :param collection_id: STAC Collection Identifier. Required.
        :type collection_id: str
        :param item_id: STAC Item Identifier. Required.
        :type item_id: str
        :keyword assets: Asset's names. Default value is None.
        :paramtype assets: list[str]
        :keyword expression: Band math expression between assets. Default value is None.
        :paramtype expression: str
        :keyword asset_bidx: Per asset band indexes (coma separated indexes). Default value is None.
        :paramtype asset_bidx: list[str]
        :keyword asset_as_band: Asset as Band. Default value is None.
        :paramtype asset_as_band: bool
        :keyword nodata: Overwrite internal Nodata value. Default value is None.
        :paramtype nodata: float
        :keyword unscale: Apply internal Scale or Offset. Default value is None.
        :paramtype unscale: bool
        :keyword resampling: Resampling method. Known values are: "nearest", "bilinear", "cubic",
         "cubic_spline", "lanczos", "average", "mode", "gauss", and "rms". Default value is None.
        :paramtype resampling: str or ~azure.planetarycomputer.models.Resampling
        :keyword max_size: Maximum dimension in pixels for the source data used to calculate
         statistics. Default value is None.
        :paramtype max_size: int
        :keyword categorical: Return statistics for categorical dataset. Default value is None.
        :paramtype categorical: bool
        :keyword c: List of values for which to report counts. Default value is None.
        :paramtype c: list[str]
        :keyword p: List of percentile values (default to [2, 98]). Default value is None.
        :paramtype p: list[int]
        :keyword histogram_bins: Defines the number of equal-width bins in the given range (10, by
         default).

         If bins is a sequence (comma ``,`` delimited values), it defines a monotonically
         increasing array of bin edges, including the rightmost edge, allowing for
         non-uniform bin widths.

         link: `https://numpy.org/doc/stable/reference/generated/numpy.histogram.html
         <https://numpy.org/doc/stable/reference/generated/numpy.histogram.html>`_. Default value is
         None.
        :paramtype histogram_bins: str
        :keyword histogram_range: Comma ``,`` delimited range of the bins.

         The lower and upper range of the bins. If not provided, range is simply
         (a.min(), a.max()).

         Values outside the range are ignored. The first element of the range must be
         less than or equal to the second.
         range affects the automatic bin computation as well.

         link: `https://numpy.org/doc/stable/reference/generated/numpy.histogram.html
         <https://numpy.org/doc/stable/reference/generated/numpy.histogram.html>`_. Default value is
         None.
        :paramtype histogram_range: str
        :return: AssetStatisticsResponse. The AssetStatisticsResponse is compatible with MutableMapping
        :rtype: ~azure.planetarycomputer.models.AssetStatisticsResponse
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[_models.AssetStatisticsResponse] = kwargs.pop("cls", None)

        _request = build_tiler_asset_statistics_get_all_request(
            collection_id=collection_id,
            item_id=item_id,
            assets=assets,
            expression=expression,
            asset_bidx=asset_bidx,
            asset_as_band=asset_as_band,
            nodata=nodata,
            unscale=unscale,
            resampling=resampling,
            max_size=max_size,
            categorical=categorical,
            c=c,
            p=p,
            histogram_bins=histogram_bins,
            histogram_range=histogram_range,
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = kwargs.pop("stream", False)
        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                try:
                    response.read()  # Load the body in memory and close the socket
                except (StreamConsumedError, StreamClosedError):
                    pass
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if _stream:
            deserialized = response.iter_bytes()
        else:
            deserialized = _deserialize(_models.AssetStatisticsResponse, response.json())

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore


class TilerStatisticsOperations:
    """
    .. warning::
        **DO NOT** instantiate this class directly.

        Instead, you should access the following operations through
        :class:`~azure.planetarycomputer.PlanetaryComputerClient`'s
        :attr:`tiler_statistics` attribute.
    """

    def __init__(self, *args, **kwargs) -> None:
        input_args = list(args)
        self._client: PipelineClient = input_args.pop(0) if input_args else kwargs.pop("client")
        self._config: PlanetaryComputerClientConfiguration = input_args.pop(0) if input_args else kwargs.pop("config")
        self._serialize: Serializer = input_args.pop(0) if input_args else kwargs.pop("serializer")
        self._deserialize: Deserializer = input_args.pop(0) if input_args else kwargs.pop("deserializer")

    @distributed_trace
    def get_all(
        self,
        collection_id: str,
        item_id: str,
        *,
        assets: Optional[List[str]] = None,
        expression: Optional[str] = None,
        asset_bidx: Optional[List[str]] = None,
        asset_as_band: Optional[bool] = None,
        nodata: Optional[float] = None,
        unscale: Optional[bool] = None,
        resampling: Optional[Union[str, _models.Resampling]] = None,
        max_size: Optional[int] = None,
        categorical: Optional[bool] = None,
        c: Optional[List[str]] = None,
        p: Optional[List[int]] = None,
        histogram_bins: Optional[str] = None,
        histogram_range: Optional[str] = None,
        **kwargs: Any,
    ) -> _models.StatisticsResponse:
        """Statistics.

        Merged assets statistics.

        :param collection_id: STAC Collection Identifier. Required.
        :type collection_id: str
        :param item_id: STAC Item Identifier. Required.
        :type item_id: str
        :keyword assets: Asset's names. Default value is None.
        :paramtype assets: list[str]
        :keyword expression: Band math expression between assets. Default value is None.
        :paramtype expression: str
        :keyword asset_bidx: Per asset band indexes (coma separated indexes). Default value is None.
        :paramtype asset_bidx: list[str]
        :keyword asset_as_band: Asset as Band. Default value is None.
        :paramtype asset_as_band: bool
        :keyword nodata: Overwrite internal Nodata value. Default value is None.
        :paramtype nodata: float
        :keyword unscale: Apply internal Scale or Offset. Default value is None.
        :paramtype unscale: bool
        :keyword resampling: Resampling method. Known values are: "nearest", "bilinear", "cubic",
         "cubic_spline", "lanczos", "average", "mode", "gauss", and "rms". Default value is None.
        :paramtype resampling: str or ~azure.planetarycomputer.models.Resampling
        :keyword max_size: Maximum dimension in pixels for the source data used to calculate
         statistics. Default value is None.
        :paramtype max_size: int
        :keyword categorical: Return statistics for categorical dataset. Default value is None.
        :paramtype categorical: bool
        :keyword c: List of values for which to report counts. Default value is None.
        :paramtype c: list[str]
        :keyword p: List of percentile values (default to [2, 98]). Default value is None.
        :paramtype p: list[int]
        :keyword histogram_bins: Defines the number of equal-width bins in the given range (10, by
         default).

         If bins is a sequence (comma ``,`` delimited values), it defines a monotonically
         increasing array of bin edges, including the rightmost edge, allowing for
         non-uniform bin widths.

         link: `https://numpy.org/doc/stable/reference/generated/numpy.histogram.html
         <https://numpy.org/doc/stable/reference/generated/numpy.histogram.html>`_. Default value is
         None.
        :paramtype histogram_bins: str
        :keyword histogram_range: Comma ``,`` delimited range of the bins.

         The lower and upper range of the bins. If not provided, range is simply
         (a.min(), a.max()).

         Values outside the range are ignored. The first element of the range must be
         less than or equal to the second.
         range affects the automatic bin computation as well.

         link: `https://numpy.org/doc/stable/reference/generated/numpy.histogram.html
         <https://numpy.org/doc/stable/reference/generated/numpy.histogram.html>`_. Default value is
         None.
        :paramtype histogram_range: str
        :return: StatisticsResponse. The StatisticsResponse is compatible with MutableMapping
        :rtype: ~azure.planetarycomputer.models.StatisticsResponse
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[_models.StatisticsResponse] = kwargs.pop("cls", None)

        _request = build_tiler_statistics_get_all_request(
            collection_id=collection_id,
            item_id=item_id,
            assets=assets,
            expression=expression,
            asset_bidx=asset_bidx,
            asset_as_band=asset_as_band,
            nodata=nodata,
            unscale=unscale,
            resampling=resampling,
            max_size=max_size,
            categorical=categorical,
            c=c,
            p=p,
            histogram_bins=histogram_bins,
            histogram_range=histogram_range,
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = kwargs.pop("stream", False)
        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                try:
                    response.read()  # Load the body in memory and close the socket
                except (StreamConsumedError, StreamClosedError):
                    pass
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if _stream:
            deserialized = response.iter_bytes()
        else:
            deserialized = _deserialize(_models.StatisticsResponse, response.json())

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore


class TilerGeoJsonStatisticsOperations:
    """
    .. warning::
        **DO NOT** instantiate this class directly.

        Instead, you should access the following operations through
        :class:`~azure.planetarycomputer.PlanetaryComputerClient`'s
        :attr:`tiler_geo_json_statistics` attribute.
    """

    def __init__(self, *args, **kwargs) -> None:
        input_args = list(args)
        self._client: PipelineClient = input_args.pop(0) if input_args else kwargs.pop("client")
        self._config: PlanetaryComputerClientConfiguration = input_args.pop(0) if input_args else kwargs.pop("config")
        self._serialize: Serializer = input_args.pop(0) if input_args else kwargs.pop("serializer")
        self._deserialize: Deserializer = input_args.pop(0) if input_args else kwargs.pop("deserializer")

    @overload
    def get_all(
        self,
        collection_id: str,
        item_id: str,
        body: _models.ItemCollection,
        *,
        assets: Optional[List[str]] = None,
        expression: Optional[str] = None,
        asset_bidx: Optional[List[str]] = None,
        asset_as_band: Optional[bool] = None,
        nodata: Optional[float] = None,
        unscale: Optional[bool] = None,
        coord_crs: Optional[str] = None,
        resampling: Optional[Union[str, _models.Resampling]] = None,
        max_size: Optional[int] = None,
        categorical: Optional[bool] = None,
        c: Optional[List[str]] = None,
        p: Optional[List[int]] = None,
        histogram_bins: Optional[str] = None,
        histogram_range: Optional[str] = None,
        content_type: str = "application/json",
        **kwargs: Any,
    ) -> _models.GeoJsonStatisticsItemCollectionResponse:
        """Geojson Statistics.

        Get Statistics from a geojson feature or featureCollection.

        :param collection_id: STAC Collection Identifier. Required.
        :type collection_id: str
        :param item_id: STAC Item Identifier. Required.
        :type item_id: str
        :param body: Request GeoJson body. Required.
        :type body: ~azure.planetarycomputer.models.ItemCollection
        :keyword assets: Asset's names. Default value is None.
        :paramtype assets: list[str]
        :keyword expression: Band math expression between assets. Default value is None.
        :paramtype expression: str
        :keyword asset_bidx: Per asset band indexes (coma separated indexes). Default value is None.
        :paramtype asset_bidx: list[str]
        :keyword asset_as_band: Asset as Band. Default value is None.
        :paramtype asset_as_band: bool
        :keyword nodata: Overwrite internal Nodata value. Default value is None.
        :paramtype nodata: float
        :keyword unscale: Apply internal Scale or Offset. Default value is None.
        :paramtype unscale: bool
        :keyword coord_crs: Coordinate Reference System of the input coords. Default to ``epsg:4326``.
         Default value is None.
        :paramtype coord_crs: str
        :keyword resampling: Resampling method. Known values are: "nearest", "bilinear", "cubic",
         "cubic_spline", "lanczos", "average", "mode", "gauss", and "rms". Default value is None.
        :paramtype resampling: str or ~azure.planetarycomputer.models.Resampling
        :keyword max_size: Maximum dimension in pixels for the source data used to calculate
         statistics. Default value is None.
        :paramtype max_size: int
        :keyword categorical: Return statistics for categorical dataset. Default value is None.
        :paramtype categorical: bool
        :keyword c: List of values for which to report counts. Default value is None.
        :paramtype c: list[str]
        :keyword p: List of percentile values (default to [2, 98]). Default value is None.
        :paramtype p: list[int]
        :keyword histogram_bins: Defines the number of equal-width bins in the given range (10, by
         default).

         If bins is a sequence (comma ``,`` delimited values), it defines a monotonically
         increasing array of bin edges, including the rightmost edge, allowing for
         non-uniform bin widths.

         link: `https://numpy.org/doc/stable/reference/generated/numpy.histogram.html
         <https://numpy.org/doc/stable/reference/generated/numpy.histogram.html>`_. Default value is
         None.
        :paramtype histogram_bins: str
        :keyword histogram_range: Comma ``,`` delimited range of the bins.

         The lower and upper range of the bins. If not provided, range is simply
         (a.min(), a.max()).

         Values outside the range are ignored. The first element of the range must be
         less than or equal to the second.
         range affects the automatic bin computation as well.

         link: `https://numpy.org/doc/stable/reference/generated/numpy.histogram.html
         <https://numpy.org/doc/stable/reference/generated/numpy.histogram.html>`_. Default value is
         None.
        :paramtype histogram_range: str
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: GeoJsonStatisticsItemCollectionResponse. The GeoJsonStatisticsItemCollectionResponse
         is compatible with MutableMapping
        :rtype: ~azure.planetarycomputer.models.GeoJsonStatisticsItemCollectionResponse
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @overload
    def get_all(
        self,
        collection_id: str,
        item_id: str,
        body: JSON,
        *,
        assets: Optional[List[str]] = None,
        expression: Optional[str] = None,
        asset_bidx: Optional[List[str]] = None,
        asset_as_band: Optional[bool] = None,
        nodata: Optional[float] = None,
        unscale: Optional[bool] = None,
        coord_crs: Optional[str] = None,
        resampling: Optional[Union[str, _models.Resampling]] = None,
        max_size: Optional[int] = None,
        categorical: Optional[bool] = None,
        c: Optional[List[str]] = None,
        p: Optional[List[int]] = None,
        histogram_bins: Optional[str] = None,
        histogram_range: Optional[str] = None,
        content_type: str = "application/json",
        **kwargs: Any,
    ) -> _models.GeoJsonStatisticsItemCollectionResponse:
        """Geojson Statistics.

        Get Statistics from a geojson feature or featureCollection.

        :param collection_id: STAC Collection Identifier. Required.
        :type collection_id: str
        :param item_id: STAC Item Identifier. Required.
        :type item_id: str
        :param body: Request GeoJson body. Required.
        :type body: JSON
        :keyword assets: Asset's names. Default value is None.
        :paramtype assets: list[str]
        :keyword expression: Band math expression between assets. Default value is None.
        :paramtype expression: str
        :keyword asset_bidx: Per asset band indexes (coma separated indexes). Default value is None.
        :paramtype asset_bidx: list[str]
        :keyword asset_as_band: Asset as Band. Default value is None.
        :paramtype asset_as_band: bool
        :keyword nodata: Overwrite internal Nodata value. Default value is None.
        :paramtype nodata: float
        :keyword unscale: Apply internal Scale or Offset. Default value is None.
        :paramtype unscale: bool
        :keyword coord_crs: Coordinate Reference System of the input coords. Default to ``epsg:4326``.
         Default value is None.
        :paramtype coord_crs: str
        :keyword resampling: Resampling method. Known values are: "nearest", "bilinear", "cubic",
         "cubic_spline", "lanczos", "average", "mode", "gauss", and "rms". Default value is None.
        :paramtype resampling: str or ~azure.planetarycomputer.models.Resampling
        :keyword max_size: Maximum dimension in pixels for the source data used to calculate
         statistics. Default value is None.
        :paramtype max_size: int
        :keyword categorical: Return statistics for categorical dataset. Default value is None.
        :paramtype categorical: bool
        :keyword c: List of values for which to report counts. Default value is None.
        :paramtype c: list[str]
        :keyword p: List of percentile values (default to [2, 98]). Default value is None.
        :paramtype p: list[int]
        :keyword histogram_bins: Defines the number of equal-width bins in the given range (10, by
         default).

         If bins is a sequence (comma ``,`` delimited values), it defines a monotonically
         increasing array of bin edges, including the rightmost edge, allowing for
         non-uniform bin widths.

         link: `https://numpy.org/doc/stable/reference/generated/numpy.histogram.html
         <https://numpy.org/doc/stable/reference/generated/numpy.histogram.html>`_. Default value is
         None.
        :paramtype histogram_bins: str
        :keyword histogram_range: Comma ``,`` delimited range of the bins.

         The lower and upper range of the bins. If not provided, range is simply
         (a.min(), a.max()).

         Values outside the range are ignored. The first element of the range must be
         less than or equal to the second.
         range affects the automatic bin computation as well.

         link: `https://numpy.org/doc/stable/reference/generated/numpy.histogram.html
         <https://numpy.org/doc/stable/reference/generated/numpy.histogram.html>`_. Default value is
         None.
        :paramtype histogram_range: str
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: GeoJsonStatisticsItemCollectionResponse. The GeoJsonStatisticsItemCollectionResponse
         is compatible with MutableMapping
        :rtype: ~azure.planetarycomputer.models.GeoJsonStatisticsItemCollectionResponse
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @overload
    def get_all(
        self,
        collection_id: str,
        item_id: str,
        body: IO[bytes],
        *,
        assets: Optional[List[str]] = None,
        expression: Optional[str] = None,
        asset_bidx: Optional[List[str]] = None,
        asset_as_band: Optional[bool] = None,
        nodata: Optional[float] = None,
        unscale: Optional[bool] = None,
        coord_crs: Optional[str] = None,
        resampling: Optional[Union[str, _models.Resampling]] = None,
        max_size: Optional[int] = None,
        categorical: Optional[bool] = None,
        c: Optional[List[str]] = None,
        p: Optional[List[int]] = None,
        histogram_bins: Optional[str] = None,
        histogram_range: Optional[str] = None,
        content_type: str = "application/json",
        **kwargs: Any,
    ) -> _models.GeoJsonStatisticsItemCollectionResponse:
        """Geojson Statistics.

        Get Statistics from a geojson feature or featureCollection.

        :param collection_id: STAC Collection Identifier. Required.
        :type collection_id: str
        :param item_id: STAC Item Identifier. Required.
        :type item_id: str
        :param body: Request GeoJson body. Required.
        :type body: IO[bytes]
        :keyword assets: Asset's names. Default value is None.
        :paramtype assets: list[str]
        :keyword expression: Band math expression between assets. Default value is None.
        :paramtype expression: str
        :keyword asset_bidx: Per asset band indexes (coma separated indexes). Default value is None.
        :paramtype asset_bidx: list[str]
        :keyword asset_as_band: Asset as Band. Default value is None.
        :paramtype asset_as_band: bool
        :keyword nodata: Overwrite internal Nodata value. Default value is None.
        :paramtype nodata: float
        :keyword unscale: Apply internal Scale or Offset. Default value is None.
        :paramtype unscale: bool
        :keyword coord_crs: Coordinate Reference System of the input coords. Default to ``epsg:4326``.
         Default value is None.
        :paramtype coord_crs: str
        :keyword resampling: Resampling method. Known values are: "nearest", "bilinear", "cubic",
         "cubic_spline", "lanczos", "average", "mode", "gauss", and "rms". Default value is None.
        :paramtype resampling: str or ~azure.planetarycomputer.models.Resampling
        :keyword max_size: Maximum dimension in pixels for the source data used to calculate
         statistics. Default value is None.
        :paramtype max_size: int
        :keyword categorical: Return statistics for categorical dataset. Default value is None.
        :paramtype categorical: bool
        :keyword c: List of values for which to report counts. Default value is None.
        :paramtype c: list[str]
        :keyword p: List of percentile values (default to [2, 98]). Default value is None.
        :paramtype p: list[int]
        :keyword histogram_bins: Defines the number of equal-width bins in the given range (10, by
         default).

         If bins is a sequence (comma ``,`` delimited values), it defines a monotonically
         increasing array of bin edges, including the rightmost edge, allowing for
         non-uniform bin widths.

         link: `https://numpy.org/doc/stable/reference/generated/numpy.histogram.html
         <https://numpy.org/doc/stable/reference/generated/numpy.histogram.html>`_. Default value is
         None.
        :paramtype histogram_bins: str
        :keyword histogram_range: Comma ``,`` delimited range of the bins.

         The lower and upper range of the bins. If not provided, range is simply
         (a.min(), a.max()).

         Values outside the range are ignored. The first element of the range must be
         less than or equal to the second.
         range affects the automatic bin computation as well.

         link: `https://numpy.org/doc/stable/reference/generated/numpy.histogram.html
         <https://numpy.org/doc/stable/reference/generated/numpy.histogram.html>`_. Default value is
         None.
        :paramtype histogram_range: str
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: GeoJsonStatisticsItemCollectionResponse. The GeoJsonStatisticsItemCollectionResponse
         is compatible with MutableMapping
        :rtype: ~azure.planetarycomputer.models.GeoJsonStatisticsItemCollectionResponse
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @distributed_trace
    def get_all(
        self,
        collection_id: str,
        item_id: str,
        body: Union[_models.ItemCollection, JSON, IO[bytes]],
        *,
        assets: Optional[List[str]] = None,
        expression: Optional[str] = None,
        asset_bidx: Optional[List[str]] = None,
        asset_as_band: Optional[bool] = None,
        nodata: Optional[float] = None,
        unscale: Optional[bool] = None,
        coord_crs: Optional[str] = None,
        resampling: Optional[Union[str, _models.Resampling]] = None,
        max_size: Optional[int] = None,
        categorical: Optional[bool] = None,
        c: Optional[List[str]] = None,
        p: Optional[List[int]] = None,
        histogram_bins: Optional[str] = None,
        histogram_range: Optional[str] = None,
        **kwargs: Any,
    ) -> _models.GeoJsonStatisticsItemCollectionResponse:
        """Geojson Statistics.

        Get Statistics from a geojson feature or featureCollection.

        :param collection_id: STAC Collection Identifier. Required.
        :type collection_id: str
        :param item_id: STAC Item Identifier. Required.
        :type item_id: str
        :param body: Request GeoJson body. Is one of the following types: ItemCollection, JSON,
         IO[bytes] Required.
        :type body: ~azure.planetarycomputer.models.ItemCollection or JSON or IO[bytes]
        :keyword assets: Asset's names. Default value is None.
        :paramtype assets: list[str]
        :keyword expression: Band math expression between assets. Default value is None.
        :paramtype expression: str
        :keyword asset_bidx: Per asset band indexes (coma separated indexes). Default value is None.
        :paramtype asset_bidx: list[str]
        :keyword asset_as_band: Asset as Band. Default value is None.
        :paramtype asset_as_band: bool
        :keyword nodata: Overwrite internal Nodata value. Default value is None.
        :paramtype nodata: float
        :keyword unscale: Apply internal Scale or Offset. Default value is None.
        :paramtype unscale: bool
        :keyword coord_crs: Coordinate Reference System of the input coords. Default to ``epsg:4326``.
         Default value is None.
        :paramtype coord_crs: str
        :keyword resampling: Resampling method. Known values are: "nearest", "bilinear", "cubic",
         "cubic_spline", "lanczos", "average", "mode", "gauss", and "rms". Default value is None.
        :paramtype resampling: str or ~azure.planetarycomputer.models.Resampling
        :keyword max_size: Maximum dimension in pixels for the source data used to calculate
         statistics. Default value is None.
        :paramtype max_size: int
        :keyword categorical: Return statistics for categorical dataset. Default value is None.
        :paramtype categorical: bool
        :keyword c: List of values for which to report counts. Default value is None.
        :paramtype c: list[str]
        :keyword p: List of percentile values (default to [2, 98]). Default value is None.
        :paramtype p: list[int]
        :keyword histogram_bins: Defines the number of equal-width bins in the given range (10, by
         default).

         If bins is a sequence (comma ``,`` delimited values), it defines a monotonically
         increasing array of bin edges, including the rightmost edge, allowing for
         non-uniform bin widths.

         link: `https://numpy.org/doc/stable/reference/generated/numpy.histogram.html
         <https://numpy.org/doc/stable/reference/generated/numpy.histogram.html>`_. Default value is
         None.
        :paramtype histogram_bins: str
        :keyword histogram_range: Comma ``,`` delimited range of the bins.

         The lower and upper range of the bins. If not provided, range is simply
         (a.min(), a.max()).

         Values outside the range are ignored. The first element of the range must be
         less than or equal to the second.
         range affects the automatic bin computation as well.

         link: `https://numpy.org/doc/stable/reference/generated/numpy.histogram.html
         <https://numpy.org/doc/stable/reference/generated/numpy.histogram.html>`_. Default value is
         None.
        :paramtype histogram_range: str
        :return: GeoJsonStatisticsItemCollectionResponse. The GeoJsonStatisticsItemCollectionResponse
         is compatible with MutableMapping
        :rtype: ~azure.planetarycomputer.models.GeoJsonStatisticsItemCollectionResponse
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[_models.GeoJsonStatisticsItemCollectionResponse] = kwargs.pop("cls", None)

        content_type = content_type or "application/json"
        _content = None
        if isinstance(body, (IOBase, bytes)):
            _content = body
        else:
            _content = json.dumps(body, cls=SdkJSONEncoder, exclude_readonly=True)  # type: ignore

        _request = build_tiler_geo_json_statistics_get_all_request(
            collection_id=collection_id,
            item_id=item_id,
            assets=assets,
            expression=expression,
            asset_bidx=asset_bidx,
            asset_as_band=asset_as_band,
            nodata=nodata,
            unscale=unscale,
            coord_crs=coord_crs,
            resampling=resampling,
            max_size=max_size,
            categorical=categorical,
            c=c,
            p=p,
            histogram_bins=histogram_bins,
            histogram_range=histogram_range,
            content_type=content_type,
            api_version=self._config.api_version,
            content=_content,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = kwargs.pop("stream", False)
        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                try:
                    response.read()  # Load the body in memory and close the socket
                except (StreamConsumedError, StreamClosedError):
                    pass
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if _stream:
            deserialized = response.iter_bytes()
        else:
            deserialized = _deserialize(_models.GeoJsonStatisticsItemCollectionResponse, response.json())

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore


class TilerTilesOperations:
    """
    .. warning::
        **DO NOT** instantiate this class directly.

        Instead, you should access the following operations through
        :class:`~azure.planetarycomputer.PlanetaryComputerClient`'s
        :attr:`tiler_tiles` attribute.
    """

    def __init__(self, *args, **kwargs) -> None:
        input_args = list(args)
        self._client: PipelineClient = input_args.pop(0) if input_args else kwargs.pop("client")
        self._config: PlanetaryComputerClientConfiguration = input_args.pop(0) if input_args else kwargs.pop("config")
        self._serialize: Serializer = input_args.pop(0) if input_args else kwargs.pop("serializer")
        self._deserialize: Deserializer = input_args.pop(0) if input_args else kwargs.pop("deserializer")

    @distributed_trace
    def get_zxy_scalex_format(
        self,
        collection_id: str,
        item_id: str,
        z: float,
        x: float,
        y: float,
        scale: float,
        format: str,
        *,
        assets: Optional[List[str]] = None,
        expression: Optional[str] = None,
        asset_bidx: Optional[List[str]] = None,
        asset_as_band: Optional[bool] = None,
        nodata: Optional[float] = None,
        unscale: Optional[bool] = None,
        algorithm: Optional[Union[str, _models.Algorithm]] = None,
        algorithm_params: Optional[str] = None,
        tile_matrix_set_id: Optional[Union[str, _models.Tilematrixsetid]] = None,
        buffer: Optional[str] = None,
        color_formula: Optional[str] = None,
        resampling: Optional[Union[str, _models.Resampling]] = None,
        rescale: Optional[List[str]] = None,
        colormap_name: Optional[Union[str, _models.ColorMapNames]] = None,
        colormap: Optional[str] = None,
        return_mask: Optional[bool] = None,
        subdataset_name: Optional[str] = None,
        subdataset_bands: Optional[List[str]] = None,
        **kwargs: Any,
    ) -> Optional[Iterator[bytes]]:
        """Tile.

        Create map tile from a dataset.

        :param collection_id: STAC Collection Identifier. Required.
        :type collection_id: str
        :param item_id: STAC Item Identifier. Required.
        :type item_id: str
        :param z: Identifier (Z) selecting one of the scales defined in the TileMatrixSet and
         representing the scaleDenominator the tile. Required.
        :type z: float
        :param x: Column (X) index of the tile on the selected TileMatrix. It cannot exceed the
         MatrixHeight-1 for the selected TileMatrix. Required.
        :type x: float
        :param y: Row (Y) index of the tile on the selected TileMatrix. It cannot exceed the
         MatrixWidth-1 for the selected TileMatrix. Required.
        :type y: float
        :param scale: Numeric scale factor for the tile. Higher values produce larger tiles (default:
         "1"). Required.
        :type scale: float
        :param format: Output format for the tile or image (e.g., png, jpeg, webp) (default: "png").
         Required.
        :type format: str
        :keyword assets: Asset's names. Default value is None.
        :paramtype assets: list[str]
        :keyword expression: Band math expression between assets. Default value is None.
        :paramtype expression: str
        :keyword asset_bidx: Per asset band indexes (coma separated indexes). Default value is None.
        :paramtype asset_bidx: list[str]
        :keyword asset_as_band: Asset as Band. Default value is None.
        :paramtype asset_as_band: bool
        :keyword nodata: Overwrite internal Nodata value. Default value is None.
        :paramtype nodata: float
        :keyword unscale: Apply internal Scale or Offset. Default value is None.
        :paramtype unscale: bool
        :keyword algorithm: Algorithm name. Known values are: "hillshade", "contours",
         "normalizedIndex", "terrarium", and "terrainrgb". Default value is None.
        :paramtype algorithm: str or ~azure.planetarycomputer.models.Algorithm
        :keyword algorithm_params: Algorithm parameter. Default value is None.
        :paramtype algorithm_params: str
        :keyword tile_matrix_set_id: Identifier selecting one of the TileMatrixSetId supported
         (default:
         'WebMercatorQuad'). Known values are: "CanadianNAD83_LCC", "EuropeanETRS89_LAEAQuad",
         "LINZAntarticaMapTilegrid", "NZTM2000Quad", "UPSAntarcticWGS84Quad", "UPSArcticWGS84Quad",
         "UTM31WGS84Quad", "WGS1984Quad", "WebMercatorQuad", "WorldCRS84Quad", and
         "WorldMercatorWGS84Quad". Default value is None.
        :paramtype tile_matrix_set_id: str or ~azure.planetarycomputer.models.Tilematrixsetid
        :keyword buffer: Buffer on each side of the given tile. It must be a multiple of ``0.5``.
         Output
         **tilesize** will be expanded to ``tilesize + 2 * buffer`` (e.g 0.5 = 257x257,
         1.0 = 258x258). Default value is None.
        :paramtype buffer: str
        :keyword color_formula: rio-color formula (info: `https://github.com/mapbox/rio-color
         <https://github.com/mapbox/rio-color>`_). Default value is None.
        :paramtype color_formula: str
        :keyword resampling: Resampling method. Known values are: "nearest", "bilinear", "cubic",
         "cubic_spline", "lanczos", "average", "mode", "gauss", and "rms". Default value is None.
        :paramtype resampling: str or ~azure.planetarycomputer.models.Resampling
        :keyword rescale: comma (',') delimited Min,Max range. Can set multiple time for multiple
         bands. Default value is None.
        :paramtype rescale: list[str]
        :keyword colormap_name: Colormap name. Known values are: "accent", "accent_r", "afmhot",
         "afmhot_r", "ai4g-lulc", "alos-fnf", "alos-palsar-mask", "autumn", "autumn_r", "binary",
         "binary_r", "blues", "blues_r", "bone", "bone_r", "brbg", "brbg_r", "brg", "brg_r", "bugn",
         "bugn_r", "bupu", "bupu_r", "bwr", "bwr_r", "c-cap", "cfastie", "chesapeake-lc-13",
         "chesapeake-lc-7", "chesapeake-lu", "chloris-biomass", "cividis", "cividis_r", "cmrmap",
         "cmrmap_r", "cool", "cool_r", "coolwarm", "coolwarm_r", "copper", "copper_r", "cubehelix",
         "cubehelix_r", "dark2", "dark2_r", "drcog-lulc", "esa-cci-lc", "esa-worldcover", "flag",
         "flag_r", "gap-lulc", "gist_earth", "gist_earth_r", "gist_gray", "gist_gray_r", "gist_heat",
         "gist_heat_r", "gist_ncar", "gist_ncar_r", "gist_rainbow", "gist_rainbow_r", "gist_stern",
         "gist_stern_r", "gist_yarg", "gist_yarg_r", "gnbu", "gnbu_r", "gnuplot", "gnuplot2",
         "gnuplot2_r", "gnuplot_r", "gray", "gray_r", "greens", "greens_r", "greys", "greys_r", "hot",
         "hot_r", "hsv", "hsv_r", "inferno", "inferno_r", "io-bii", "io-lulc", "io-lulc-9-class", "jet",
         "jet_r", "jrc-change", "jrc-extent", "jrc-occurrence", "jrc-recurrence", "jrc-seasonality",
         "jrc-transitions", "lidar-classification", "lidar-hag", "lidar-hag-alternative",
         "lidar-intensity", "lidar-returns", "magma", "magma_r", "modis-10A1", "modis-10A2",
         "modis-13A1|Q1", "modis-14A1|A2", "modis-15A2H|A3H", "modis-16A3GF-ET", "modis-16A3GF-PET",
         "modis-17A2H|A2HGF", "modis-17A3HGF", "modis-64A1", "mtbs-severity", "nipy_spectral",
         "nipy_spectral_r", "nrcan-lulc", "ocean", "ocean_r", "oranges", "oranges_r", "orrd", "orrd_r",
         "paired", "paired_r", "pastel1", "pastel1_r", "pastel2", "pastel2_r", "pink", "pink_r", "piyg",
         "piyg_r", "plasma", "plasma_r", "prgn", "prgn_r", "prism", "prism_r", "pubu", "pubu_r",
         "pubugn", "pubugn_r", "puor", "puor_r", "purd", "purd_r", "purples", "purples_r", "qpe",
         "rainbow", "rainbow_r", "rdbu", "rdbu_r", "rdgy", "rdgy_r", "rdpu", "rdpu_r", "rdylbu",
         "rdylbu_r", "rdylgn", "rdylgn_r", "reds", "reds_r", "rplumbo", "schwarzwald", "seismic",
         "seismic_r", "set1", "set1_r", "set2", "set2_r", "set3", "set3_r", "spectral", "spectral_r",
         "spring", "spring_r", "summer", "summer_r", "tab10", "tab10_r", "tab20", "tab20_r", "tab20b",
         "tab20b_r", "tab20c", "tab20c_r", "terrain", "terrain_r", "twilight", "twilight_r",
         "twilight_shifted", "twilight_shifted_r", "usda-cdl", "usda-cdl-corn", "usda-cdl-cotton",
         "usda-cdl-soybeans", "usda-cdl-wheat", "usgs-lcmap", "viirs-10a1", "viirs-13a1", "viirs-14a1",
         "viirs-15a2H", "viridis", "viridis_r", "winter", "winter_r", "wistia", "wistia_r", "ylgn",
         "ylgn_r", "ylgnbu", "ylgnbu_r", "ylorbr", "ylorbr_r", "ylorrd", and "ylorrd_r". Default value
         is None.
        :paramtype colormap_name: str or ~azure.planetarycomputer.models.ColorMapNames
        :keyword colormap: JSON encoded custom Colormap. Default value is None.
        :paramtype colormap: str
        :keyword return_mask: Add mask to the output data. Default value is None.
        :paramtype return_mask: bool
        :keyword subdataset_name: The name of a subdataset within the asset. Default value is None.
        :paramtype subdataset_name: str
        :keyword subdataset_bands: The index of a subdataset band within the asset. Default value is
         None.
        :paramtype subdataset_bands: list[str]
        :return: Iterator[bytes] or None
        :rtype: Iterator[bytes] or None
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[Optional[Iterator[bytes]]] = kwargs.pop("cls", None)

        _request = build_tiler_tiles_get_zxy_scalex_format_request(
            collection_id=collection_id,
            item_id=item_id,
            z=z,
            x=x,
            y=y,
            scale=scale,
            format=format,
            assets=assets,
            expression=expression,
            asset_bidx=asset_bidx,
            asset_as_band=asset_as_band,
            nodata=nodata,
            unscale=unscale,
            algorithm=algorithm,
            algorithm_params=algorithm_params,
            tile_matrix_set_id=tile_matrix_set_id,
            buffer=buffer,
            color_formula=color_formula,
            resampling=resampling,
            rescale=rescale,
            colormap_name=colormap_name,
            colormap=colormap,
            return_mask=return_mask,
            subdataset_name=subdataset_name,
            subdataset_bands=subdataset_bands,
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = kwargs.pop("stream", True)
        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200, 204]:
            if _stream:
                try:
                    response.read()  # Load the body in memory and close the socket
                except (StreamConsumedError, StreamClosedError):
                    pass
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        deserialized = None
        response_headers = {}
        if response.status_code == 200:
            response_headers["content-type"] = self._deserialize("str", response.headers.get("content-type"))
            response_headers["content-type"] = self._deserialize("str", response.headers.get("content-type"))
            response_headers["content-type"] = self._deserialize("str", response.headers.get("content-type"))
            response_headers["content-type"] = self._deserialize("str", response.headers.get("content-type"))
            response_headers["content-type"] = self._deserialize("str", response.headers.get("content-type"))
            response_headers["content-type"] = self._deserialize("str", response.headers.get("content-type"))
            response_headers["content-type"] = self._deserialize("str", response.headers.get("content-type"))

            deserialized = response.iter_bytes()

        if cls:
            return cls(pipeline_response, deserialized, response_headers)  # type: ignore

        return deserialized  # type: ignore


class TilerTileMatrixSetsOperations:
    """
    .. warning::
        **DO NOT** instantiate this class directly.

        Instead, you should access the following operations through
        :class:`~azure.planetarycomputer.PlanetaryComputerClient`'s
        :attr:`tiler_tile_matrix_sets` attribute.
    """

    def __init__(self, *args, **kwargs) -> None:
        input_args = list(args)
        self._client: PipelineClient = input_args.pop(0) if input_args else kwargs.pop("client")
        self._config: PlanetaryComputerClientConfiguration = input_args.pop(0) if input_args else kwargs.pop("config")
        self._serialize: Serializer = input_args.pop(0) if input_args else kwargs.pop("serializer")
        self._deserialize: Deserializer = input_args.pop(0) if input_args else kwargs.pop("deserializer")

    @distributed_trace
    def get_zxy_scalex_format(
        self,
        collection_id: str,
        item_id: str,
        tile_matrix_set_id: str,
        z: float,
        x: float,
        y: float,
        scale: float,
        format: str,
        *,
        assets: Optional[List[str]] = None,
        expression: Optional[str] = None,
        asset_bidx: Optional[List[str]] = None,
        asset_as_band: Optional[bool] = None,
        nodata: Optional[float] = None,
        unscale: Optional[bool] = None,
        algorithm: Optional[Union[str, _models.Algorithm]] = None,
        algorithm_params: Optional[str] = None,
        buffer: Optional[str] = None,
        color_formula: Optional[str] = None,
        resampling: Optional[Union[str, _models.Resampling]] = None,
        rescale: Optional[List[str]] = None,
        colormap_name: Optional[Union[str, _models.ColorMapNames]] = None,
        colormap: Optional[str] = None,
        return_mask: Optional[bool] = None,
        subdataset_name: Optional[str] = None,
        subdataset_bands: Optional[List[str]] = None,
        **kwargs: Any,
    ) -> Iterator[bytes]:
        """Tile Tilematrixsetid As Path.

        Create map tile from a dataset.

        :param collection_id: STAC Collection Identifier. Required.
        :type collection_id: str
        :param item_id: STAC Item Identifier. Required.
        :type item_id: str
        :param tile_matrix_set_id: Identifier selecting one of the TileMatrixSetId supported. Required.
        :type tile_matrix_set_id: str
        :param z: Identifier (Z) selecting one of the scales defined in the TileMatrixSet and
         representing the scaleDenominator the tile. Required.
        :type z: float
        :param x: Column (X) index of the tile on the selected TileMatrix. It cannot exceed the
         MatrixHeight-1 for the selected TileMatrix. Required.
        :type x: float
        :param y: Row (Y) index of the tile on the selected TileMatrix. It cannot exceed the
         MatrixWidth-1 for the selected TileMatrix. Required.
        :type y: float
        :param scale: Numeric scale factor for the tile. Higher values produce larger tiles (default:
         "1"). Required.
        :type scale: float
        :param format: Output format for the tile or image (e.g., png, jpeg, webp) (default: "png").
         Required.
        :type format: str
        :keyword assets: Asset's names. Default value is None.
        :paramtype assets: list[str]
        :keyword expression: Band math expression between assets. Default value is None.
        :paramtype expression: str
        :keyword asset_bidx: Per asset band indexes (coma separated indexes). Default value is None.
        :paramtype asset_bidx: list[str]
        :keyword asset_as_band: Asset as Band. Default value is None.
        :paramtype asset_as_band: bool
        :keyword nodata: Overwrite internal Nodata value. Default value is None.
        :paramtype nodata: float
        :keyword unscale: Apply internal Scale or Offset. Default value is None.
        :paramtype unscale: bool
        :keyword algorithm: Algorithm name. Known values are: "hillshade", "contours",
         "normalizedIndex", "terrarium", and "terrainrgb". Default value is None.
        :paramtype algorithm: str or ~azure.planetarycomputer.models.Algorithm
        :keyword algorithm_params: Algorithm parameter. Default value is None.
        :paramtype algorithm_params: str
        :keyword buffer: Buffer on each side of the given tile. It must be a multiple of ``0.5``.
         Output
         **tilesize** will be expanded to ``tilesize + 2 * buffer`` (e.g 0.5 = 257x257,
         1.0 = 258x258). Default value is None.
        :paramtype buffer: str
        :keyword color_formula: rio-color formula (info: `https://github.com/mapbox/rio-color
         <https://github.com/mapbox/rio-color>`_). Default value is None.
        :paramtype color_formula: str
        :keyword resampling: Resampling method. Known values are: "nearest", "bilinear", "cubic",
         "cubic_spline", "lanczos", "average", "mode", "gauss", and "rms". Default value is None.
        :paramtype resampling: str or ~azure.planetarycomputer.models.Resampling
        :keyword rescale: comma (',') delimited Min,Max range. Can set multiple time for multiple
         bands. Default value is None.
        :paramtype rescale: list[str]
        :keyword colormap_name: Colormap name. Known values are: "accent", "accent_r", "afmhot",
         "afmhot_r", "ai4g-lulc", "alos-fnf", "alos-palsar-mask", "autumn", "autumn_r", "binary",
         "binary_r", "blues", "blues_r", "bone", "bone_r", "brbg", "brbg_r", "brg", "brg_r", "bugn",
         "bugn_r", "bupu", "bupu_r", "bwr", "bwr_r", "c-cap", "cfastie", "chesapeake-lc-13",
         "chesapeake-lc-7", "chesapeake-lu", "chloris-biomass", "cividis", "cividis_r", "cmrmap",
         "cmrmap_r", "cool", "cool_r", "coolwarm", "coolwarm_r", "copper", "copper_r", "cubehelix",
         "cubehelix_r", "dark2", "dark2_r", "drcog-lulc", "esa-cci-lc", "esa-worldcover", "flag",
         "flag_r", "gap-lulc", "gist_earth", "gist_earth_r", "gist_gray", "gist_gray_r", "gist_heat",
         "gist_heat_r", "gist_ncar", "gist_ncar_r", "gist_rainbow", "gist_rainbow_r", "gist_stern",
         "gist_stern_r", "gist_yarg", "gist_yarg_r", "gnbu", "gnbu_r", "gnuplot", "gnuplot2",
         "gnuplot2_r", "gnuplot_r", "gray", "gray_r", "greens", "greens_r", "greys", "greys_r", "hot",
         "hot_r", "hsv", "hsv_r", "inferno", "inferno_r", "io-bii", "io-lulc", "io-lulc-9-class", "jet",
         "jet_r", "jrc-change", "jrc-extent", "jrc-occurrence", "jrc-recurrence", "jrc-seasonality",
         "jrc-transitions", "lidar-classification", "lidar-hag", "lidar-hag-alternative",
         "lidar-intensity", "lidar-returns", "magma", "magma_r", "modis-10A1", "modis-10A2",
         "modis-13A1|Q1", "modis-14A1|A2", "modis-15A2H|A3H", "modis-16A3GF-ET", "modis-16A3GF-PET",
         "modis-17A2H|A2HGF", "modis-17A3HGF", "modis-64A1", "mtbs-severity", "nipy_spectral",
         "nipy_spectral_r", "nrcan-lulc", "ocean", "ocean_r", "oranges", "oranges_r", "orrd", "orrd_r",
         "paired", "paired_r", "pastel1", "pastel1_r", "pastel2", "pastel2_r", "pink", "pink_r", "piyg",
         "piyg_r", "plasma", "plasma_r", "prgn", "prgn_r", "prism", "prism_r", "pubu", "pubu_r",
         "pubugn", "pubugn_r", "puor", "puor_r", "purd", "purd_r", "purples", "purples_r", "qpe",
         "rainbow", "rainbow_r", "rdbu", "rdbu_r", "rdgy", "rdgy_r", "rdpu", "rdpu_r", "rdylbu",
         "rdylbu_r", "rdylgn", "rdylgn_r", "reds", "reds_r", "rplumbo", "schwarzwald", "seismic",
         "seismic_r", "set1", "set1_r", "set2", "set2_r", "set3", "set3_r", "spectral", "spectral_r",
         "spring", "spring_r", "summer", "summer_r", "tab10", "tab10_r", "tab20", "tab20_r", "tab20b",
         "tab20b_r", "tab20c", "tab20c_r", "terrain", "terrain_r", "twilight", "twilight_r",
         "twilight_shifted", "twilight_shifted_r", "usda-cdl", "usda-cdl-corn", "usda-cdl-cotton",
         "usda-cdl-soybeans", "usda-cdl-wheat", "usgs-lcmap", "viirs-10a1", "viirs-13a1", "viirs-14a1",
         "viirs-15a2H", "viridis", "viridis_r", "winter", "winter_r", "wistia", "wistia_r", "ylgn",
         "ylgn_r", "ylgnbu", "ylgnbu_r", "ylorbr", "ylorbr_r", "ylorrd", and "ylorrd_r". Default value
         is None.
        :paramtype colormap_name: str or ~azure.planetarycomputer.models.ColorMapNames
        :keyword colormap: JSON encoded custom Colormap. Default value is None.
        :paramtype colormap: str
        :keyword return_mask: Add mask to the output data. Default value is None.
        :paramtype return_mask: bool
        :keyword subdataset_name: The name of a subdataset within the asset. Default value is None.
        :paramtype subdataset_name: str
        :keyword subdataset_bands: The index of a subdataset band within the asset. Default value is
         None.
        :paramtype subdataset_bands: list[str]
        :return: Iterator[bytes]
        :rtype: Iterator[bytes]
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[Iterator[bytes]] = kwargs.pop("cls", None)

        _request = build_tiler_tile_matrix_sets_get_zxy_scalex_format_request(
            collection_id=collection_id,
            item_id=item_id,
            tile_matrix_set_id=tile_matrix_set_id,
            z=z,
            x=x,
            y=y,
            scale=scale,
            format=format,
            assets=assets,
            expression=expression,
            asset_bidx=asset_bidx,
            asset_as_band=asset_as_band,
            nodata=nodata,
            unscale=unscale,
            algorithm=algorithm,
            algorithm_params=algorithm_params,
            buffer=buffer,
            color_formula=color_formula,
            resampling=resampling,
            rescale=rescale,
            colormap_name=colormap_name,
            colormap=colormap,
            return_mask=return_mask,
            subdataset_name=subdataset_name,
            subdataset_bands=subdataset_bands,
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = kwargs.pop("stream", True)
        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                try:
                    response.read()  # Load the body in memory and close the socket
                except (StreamConsumedError, StreamClosedError):
                    pass
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        response_headers = {}
        response_headers["content-type"] = self._deserialize("str", response.headers.get("content-type"))
        response_headers["content-type"] = self._deserialize("str", response.headers.get("content-type"))
        response_headers["content-type"] = self._deserialize("str", response.headers.get("content-type"))
        response_headers["content-type"] = self._deserialize("str", response.headers.get("content-type"))
        response_headers["content-type"] = self._deserialize("str", response.headers.get("content-type"))
        response_headers["content-type"] = self._deserialize("str", response.headers.get("content-type"))
        response_headers["content-type"] = self._deserialize("str", response.headers.get("content-type"))

        deserialized = response.iter_bytes()

        if cls:
            return cls(pipeline_response, deserialized, response_headers)  # type: ignore

        return deserialized  # type: ignore


class TilerTileJsonOperationsOperations:
    """
    .. warning::
        **DO NOT** instantiate this class directly.

        Instead, you should access the following operations through
        :class:`~azure.planetarycomputer.PlanetaryComputerClient`'s
        :attr:`tiler_tile_json_operations` attribute.
    """

    def __init__(self, *args, **kwargs) -> None:
        input_args = list(args)
        self._client: PipelineClient = input_args.pop(0) if input_args else kwargs.pop("client")
        self._config: PlanetaryComputerClientConfiguration = input_args.pop(0) if input_args else kwargs.pop("config")
        self._serialize: Serializer = input_args.pop(0) if input_args else kwargs.pop("serializer")
        self._deserialize: Deserializer = input_args.pop(0) if input_args else kwargs.pop("deserializer")

    @distributed_trace
    def get(
        self,
        collection_id: str,
        item_id: str,
        *,
        assets: Optional[List[str]] = None,
        expression: Optional[str] = None,
        asset_bidx: Optional[List[str]] = None,
        asset_as_band: Optional[bool] = None,
        nodata: Optional[float] = None,
        unscale: Optional[bool] = None,
        algorithm: Optional[Union[str, _models.Algorithm]] = None,
        algorithm_params: Optional[str] = None,
        tile_matrix_set_id: Optional[Union[str, _models.Tilematrixsetid]] = None,
        tile_format: Optional[Union[str, _models.ImageType]] = None,
        tile_scale: Optional[int] = None,
        minzoom: Optional[int] = None,
        maxzoom: Optional[int] = None,
        buffer: Optional[str] = None,
        color_formula: Optional[str] = None,
        resampling: Optional[Union[str, _models.Resampling]] = None,
        rescale: Optional[List[str]] = None,
        colormap_name: Optional[Union[str, _models.ColorMapNames]] = None,
        colormap: Optional[str] = None,
        return_mask: Optional[bool] = None,
        **kwargs: Any,
    ) -> _models.TileJsonResponse:
        """Tilejson.

        Return Tilejson.

        :param collection_id: STAC Collection Identifier. Required.
        :type collection_id: str
        :param item_id: STAC Item Identifier. Required.
        :type item_id: str
        :keyword assets: Asset's names. Default value is None.
        :paramtype assets: list[str]
        :keyword expression: Band math expression between assets. Default value is None.
        :paramtype expression: str
        :keyword asset_bidx: Per asset band indexes (coma separated indexes). Default value is None.
        :paramtype asset_bidx: list[str]
        :keyword asset_as_band: Asset as Band. Default value is None.
        :paramtype asset_as_band: bool
        :keyword nodata: Overwrite internal Nodata value. Default value is None.
        :paramtype nodata: float
        :keyword unscale: Apply internal Scale or Offset. Default value is None.
        :paramtype unscale: bool
        :keyword algorithm: Algorithm name. Known values are: "hillshade", "contours",
         "normalizedIndex", "terrarium", and "terrainrgb". Default value is None.
        :paramtype algorithm: str or ~azure.planetarycomputer.models.Algorithm
        :keyword algorithm_params: Algorithm parameter. Default value is None.
        :paramtype algorithm_params: str
        :keyword tile_matrix_set_id: Identifier selecting one of the TileMatrixSetId supported
         (default:
         'WebMercatorQuad'). Known values are: "CanadianNAD83_LCC", "EuropeanETRS89_LAEAQuad",
         "LINZAntarticaMapTilegrid", "NZTM2000Quad", "UPSAntarcticWGS84Quad", "UPSArcticWGS84Quad",
         "UTM31WGS84Quad", "WGS1984Quad", "WebMercatorQuad", "WorldCRS84Quad", and
         "WorldMercatorWGS84Quad". Default value is None.
        :paramtype tile_matrix_set_id: str or ~azure.planetarycomputer.models.Tilematrixsetid
        :keyword tile_format: Default will be automatically defined if the output image needs a mask
         (png) or
         not (jpeg). Known values are: "png", "npy", "tif", "jpeg", "jpg", "jp2", "webp", and "pngraw".
         Default value is None.
        :paramtype tile_format: str or ~azure.planetarycomputer.models.ImageType
        :keyword tile_scale: Tile scale factor affecting output size. Values > 1 produce larger tiles
         (e.g., 1=256x256, 2=512x512). Default value is None.
        :paramtype tile_scale: int
        :keyword minzoom: Overwrite default minzoom. Default value is None.
        :paramtype minzoom: int
        :keyword maxzoom: Overwrite default maxzoom. Default value is None.
        :paramtype maxzoom: int
        :keyword buffer: Buffer on each side of the given tile. It must be a multiple of ``0.5``.
         Output
         **tilesize** will be expanded to ``tilesize + 2 * buffer`` (e.g 0.5 = 257x257,
         1.0 = 258x258). Default value is None.
        :paramtype buffer: str
        :keyword color_formula: rio-color formula (info: `https://github.com/mapbox/rio-color
         <https://github.com/mapbox/rio-color>`_). Default value is None.
        :paramtype color_formula: str
        :keyword resampling: Resampling method. Known values are: "nearest", "bilinear", "cubic",
         "cubic_spline", "lanczos", "average", "mode", "gauss", and "rms". Default value is None.
        :paramtype resampling: str or ~azure.planetarycomputer.models.Resampling
        :keyword rescale: comma (',') delimited Min,Max range. Can set multiple time for multiple
         bands. Default value is None.
        :paramtype rescale: list[str]
        :keyword colormap_name: Colormap name. Known values are: "accent", "accent_r", "afmhot",
         "afmhot_r", "ai4g-lulc", "alos-fnf", "alos-palsar-mask", "autumn", "autumn_r", "binary",
         "binary_r", "blues", "blues_r", "bone", "bone_r", "brbg", "brbg_r", "brg", "brg_r", "bugn",
         "bugn_r", "bupu", "bupu_r", "bwr", "bwr_r", "c-cap", "cfastie", "chesapeake-lc-13",
         "chesapeake-lc-7", "chesapeake-lu", "chloris-biomass", "cividis", "cividis_r", "cmrmap",
         "cmrmap_r", "cool", "cool_r", "coolwarm", "coolwarm_r", "copper", "copper_r", "cubehelix",
         "cubehelix_r", "dark2", "dark2_r", "drcog-lulc", "esa-cci-lc", "esa-worldcover", "flag",
         "flag_r", "gap-lulc", "gist_earth", "gist_earth_r", "gist_gray", "gist_gray_r", "gist_heat",
         "gist_heat_r", "gist_ncar", "gist_ncar_r", "gist_rainbow", "gist_rainbow_r", "gist_stern",
         "gist_stern_r", "gist_yarg", "gist_yarg_r", "gnbu", "gnbu_r", "gnuplot", "gnuplot2",
         "gnuplot2_r", "gnuplot_r", "gray", "gray_r", "greens", "greens_r", "greys", "greys_r", "hot",
         "hot_r", "hsv", "hsv_r", "inferno", "inferno_r", "io-bii", "io-lulc", "io-lulc-9-class", "jet",
         "jet_r", "jrc-change", "jrc-extent", "jrc-occurrence", "jrc-recurrence", "jrc-seasonality",
         "jrc-transitions", "lidar-classification", "lidar-hag", "lidar-hag-alternative",
         "lidar-intensity", "lidar-returns", "magma", "magma_r", "modis-10A1", "modis-10A2",
         "modis-13A1|Q1", "modis-14A1|A2", "modis-15A2H|A3H", "modis-16A3GF-ET", "modis-16A3GF-PET",
         "modis-17A2H|A2HGF", "modis-17A3HGF", "modis-64A1", "mtbs-severity", "nipy_spectral",
         "nipy_spectral_r", "nrcan-lulc", "ocean", "ocean_r", "oranges", "oranges_r", "orrd", "orrd_r",
         "paired", "paired_r", "pastel1", "pastel1_r", "pastel2", "pastel2_r", "pink", "pink_r", "piyg",
         "piyg_r", "plasma", "plasma_r", "prgn", "prgn_r", "prism", "prism_r", "pubu", "pubu_r",
         "pubugn", "pubugn_r", "puor", "puor_r", "purd", "purd_r", "purples", "purples_r", "qpe",
         "rainbow", "rainbow_r", "rdbu", "rdbu_r", "rdgy", "rdgy_r", "rdpu", "rdpu_r", "rdylbu",
         "rdylbu_r", "rdylgn", "rdylgn_r", "reds", "reds_r", "rplumbo", "schwarzwald", "seismic",
         "seismic_r", "set1", "set1_r", "set2", "set2_r", "set3", "set3_r", "spectral", "spectral_r",
         "spring", "spring_r", "summer", "summer_r", "tab10", "tab10_r", "tab20", "tab20_r", "tab20b",
         "tab20b_r", "tab20c", "tab20c_r", "terrain", "terrain_r", "twilight", "twilight_r",
         "twilight_shifted", "twilight_shifted_r", "usda-cdl", "usda-cdl-corn", "usda-cdl-cotton",
         "usda-cdl-soybeans", "usda-cdl-wheat", "usgs-lcmap", "viirs-10a1", "viirs-13a1", "viirs-14a1",
         "viirs-15a2H", "viridis", "viridis_r", "winter", "winter_r", "wistia", "wistia_r", "ylgn",
         "ylgn_r", "ylgnbu", "ylgnbu_r", "ylorbr", "ylorbr_r", "ylorrd", and "ylorrd_r". Default value
         is None.
        :paramtype colormap_name: str or ~azure.planetarycomputer.models.ColorMapNames
        :keyword colormap: JSON encoded custom Colormap. Default value is None.
        :paramtype colormap: str
        :keyword return_mask: Add mask to the output data. Default value is None.
        :paramtype return_mask: bool
        :return: TileJsonResponse. The TileJsonResponse is compatible with MutableMapping
        :rtype: ~azure.planetarycomputer.models.TileJsonResponse
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[_models.TileJsonResponse] = kwargs.pop("cls", None)

        _request = build_tiler_tile_json_operations_get_request(
            collection_id=collection_id,
            item_id=item_id,
            assets=assets,
            expression=expression,
            asset_bidx=asset_bidx,
            asset_as_band=asset_as_band,
            nodata=nodata,
            unscale=unscale,
            algorithm=algorithm,
            algorithm_params=algorithm_params,
            tile_matrix_set_id=tile_matrix_set_id,
            tile_format=tile_format,
            tile_scale=tile_scale,
            minzoom=minzoom,
            maxzoom=maxzoom,
            buffer=buffer,
            color_formula=color_formula,
            resampling=resampling,
            rescale=rescale,
            colormap_name=colormap_name,
            colormap=colormap,
            return_mask=return_mask,
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = kwargs.pop("stream", False)
        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                try:
                    response.read()  # Load the body in memory and close the socket
                except (StreamConsumedError, StreamClosedError):
                    pass
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if _stream:
            deserialized = response.iter_bytes()
        else:
            deserialized = _deserialize(_models.TileJsonResponse, response.json())

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore


class TilerTileJsonTileMatrixSetsOperations:
    """
    .. warning::
        **DO NOT** instantiate this class directly.

        Instead, you should access the following operations through
        :class:`~azure.planetarycomputer.PlanetaryComputerClient`'s
        :attr:`tiler_tile_json_tile_matrix_sets` attribute.
    """

    def __init__(self, *args, **kwargs) -> None:
        input_args = list(args)
        self._client: PipelineClient = input_args.pop(0) if input_args else kwargs.pop("client")
        self._config: PlanetaryComputerClientConfiguration = input_args.pop(0) if input_args else kwargs.pop("config")
        self._serialize: Serializer = input_args.pop(0) if input_args else kwargs.pop("serializer")
        self._deserialize: Deserializer = input_args.pop(0) if input_args else kwargs.pop("deserializer")

    @distributed_trace
    def get(
        self,
        collection_id: str,
        item_id: str,
        tile_matrix_set_id: str,
        *,
        assets: Optional[List[str]] = None,
        expression: Optional[str] = None,
        asset_bidx: Optional[List[str]] = None,
        asset_as_band: Optional[bool] = None,
        nodata: Optional[float] = None,
        unscale: Optional[bool] = None,
        algorithm: Optional[Union[str, _models.Algorithm]] = None,
        algorithm_params: Optional[str] = None,
        tile_format: Optional[Union[str, _models.ImageType]] = None,
        tile_scale: Optional[int] = None,
        minzoom: Optional[int] = None,
        maxzoom: Optional[int] = None,
        buffer: Optional[str] = None,
        color_formula: Optional[str] = None,
        resampling: Optional[Union[str, _models.Resampling]] = None,
        rescale: Optional[List[str]] = None,
        colormap_name: Optional[Union[str, _models.ColorMapNames]] = None,
        colormap: Optional[str] = None,
        return_mask: Optional[bool] = None,
        **kwargs: Any,
    ) -> _models.TileJsonResponse:
        """Tilejson Tilematrixsetid As Path.

        Return the Tilejson Tilematrixsetid As a path.

        :param collection_id: STAC Collection Identifier. Required.
        :type collection_id: str
        :param item_id: STAC Item Identifier. Required.
        :type item_id: str
        :param tile_matrix_set_id: Identifier selecting one of the TileMatrixSetId supported. Required.
        :type tile_matrix_set_id: str
        :keyword assets: Asset's names. Default value is None.
        :paramtype assets: list[str]
        :keyword expression: Band math expression between assets. Default value is None.
        :paramtype expression: str
        :keyword asset_bidx: Per asset band indexes (coma separated indexes). Default value is None.
        :paramtype asset_bidx: list[str]
        :keyword asset_as_band: Asset as Band. Default value is None.
        :paramtype asset_as_band: bool
        :keyword nodata: Overwrite internal Nodata value. Default value is None.
        :paramtype nodata: float
        :keyword unscale: Apply internal Scale or Offset. Default value is None.
        :paramtype unscale: bool
        :keyword algorithm: Algorithm name. Known values are: "hillshade", "contours",
         "normalizedIndex", "terrarium", and "terrainrgb". Default value is None.
        :paramtype algorithm: str or ~azure.planetarycomputer.models.Algorithm
        :keyword algorithm_params: Algorithm parameter. Default value is None.
        :paramtype algorithm_params: str
        :keyword tile_format: Default will be automatically defined if the output image needs a mask
         (png) or
         not (jpeg). Known values are: "png", "npy", "tif", "jpeg", "jpg", "jp2", "webp", and "pngraw".
         Default value is None.
        :paramtype tile_format: str or ~azure.planetarycomputer.models.ImageType
        :keyword tile_scale: Tile scale factor affecting output size. Values > 1 produce larger tiles
         (e.g., 1=256x256, 2=512x512). Default value is None.
        :paramtype tile_scale: int
        :keyword minzoom: Overwrite default minzoom. Default value is None.
        :paramtype minzoom: int
        :keyword maxzoom: Overwrite default maxzoom. Default value is None.
        :paramtype maxzoom: int
        :keyword buffer: Buffer on each side of the given tile. It must be a multiple of ``0.5``.
         Output
         **tilesize** will be expanded to ``tilesize + 2 * buffer`` (e.g 0.5 = 257x257,
         1.0 = 258x258). Default value is None.
        :paramtype buffer: str
        :keyword color_formula: rio-color formula (info: `https://github.com/mapbox/rio-color
         <https://github.com/mapbox/rio-color>`_). Default value is None.
        :paramtype color_formula: str
        :keyword resampling: Resampling method. Known values are: "nearest", "bilinear", "cubic",
         "cubic_spline", "lanczos", "average", "mode", "gauss", and "rms". Default value is None.
        :paramtype resampling: str or ~azure.planetarycomputer.models.Resampling
        :keyword rescale: comma (',') delimited Min,Max range. Can set multiple time for multiple
         bands. Default value is None.
        :paramtype rescale: list[str]
        :keyword colormap_name: Colormap name. Known values are: "accent", "accent_r", "afmhot",
         "afmhot_r", "ai4g-lulc", "alos-fnf", "alos-palsar-mask", "autumn", "autumn_r", "binary",
         "binary_r", "blues", "blues_r", "bone", "bone_r", "brbg", "brbg_r", "brg", "brg_r", "bugn",
         "bugn_r", "bupu", "bupu_r", "bwr", "bwr_r", "c-cap", "cfastie", "chesapeake-lc-13",
         "chesapeake-lc-7", "chesapeake-lu", "chloris-biomass", "cividis", "cividis_r", "cmrmap",
         "cmrmap_r", "cool", "cool_r", "coolwarm", "coolwarm_r", "copper", "copper_r", "cubehelix",
         "cubehelix_r", "dark2", "dark2_r", "drcog-lulc", "esa-cci-lc", "esa-worldcover", "flag",
         "flag_r", "gap-lulc", "gist_earth", "gist_earth_r", "gist_gray", "gist_gray_r", "gist_heat",
         "gist_heat_r", "gist_ncar", "gist_ncar_r", "gist_rainbow", "gist_rainbow_r", "gist_stern",
         "gist_stern_r", "gist_yarg", "gist_yarg_r", "gnbu", "gnbu_r", "gnuplot", "gnuplot2",
         "gnuplot2_r", "gnuplot_r", "gray", "gray_r", "greens", "greens_r", "greys", "greys_r", "hot",
         "hot_r", "hsv", "hsv_r", "inferno", "inferno_r", "io-bii", "io-lulc", "io-lulc-9-class", "jet",
         "jet_r", "jrc-change", "jrc-extent", "jrc-occurrence", "jrc-recurrence", "jrc-seasonality",
         "jrc-transitions", "lidar-classification", "lidar-hag", "lidar-hag-alternative",
         "lidar-intensity", "lidar-returns", "magma", "magma_r", "modis-10A1", "modis-10A2",
         "modis-13A1|Q1", "modis-14A1|A2", "modis-15A2H|A3H", "modis-16A3GF-ET", "modis-16A3GF-PET",
         "modis-17A2H|A2HGF", "modis-17A3HGF", "modis-64A1", "mtbs-severity", "nipy_spectral",
         "nipy_spectral_r", "nrcan-lulc", "ocean", "ocean_r", "oranges", "oranges_r", "orrd", "orrd_r",
         "paired", "paired_r", "pastel1", "pastel1_r", "pastel2", "pastel2_r", "pink", "pink_r", "piyg",
         "piyg_r", "plasma", "plasma_r", "prgn", "prgn_r", "prism", "prism_r", "pubu", "pubu_r",
         "pubugn", "pubugn_r", "puor", "puor_r", "purd", "purd_r", "purples", "purples_r", "qpe",
         "rainbow", "rainbow_r", "rdbu", "rdbu_r", "rdgy", "rdgy_r", "rdpu", "rdpu_r", "rdylbu",
         "rdylbu_r", "rdylgn", "rdylgn_r", "reds", "reds_r", "rplumbo", "schwarzwald", "seismic",
         "seismic_r", "set1", "set1_r", "set2", "set2_r", "set3", "set3_r", "spectral", "spectral_r",
         "spring", "spring_r", "summer", "summer_r", "tab10", "tab10_r", "tab20", "tab20_r", "tab20b",
         "tab20b_r", "tab20c", "tab20c_r", "terrain", "terrain_r", "twilight", "twilight_r",
         "twilight_shifted", "twilight_shifted_r", "usda-cdl", "usda-cdl-corn", "usda-cdl-cotton",
         "usda-cdl-soybeans", "usda-cdl-wheat", "usgs-lcmap", "viirs-10a1", "viirs-13a1", "viirs-14a1",
         "viirs-15a2H", "viridis", "viridis_r", "winter", "winter_r", "wistia", "wistia_r", "ylgn",
         "ylgn_r", "ylgnbu", "ylgnbu_r", "ylorbr", "ylorbr_r", "ylorrd", and "ylorrd_r". Default value
         is None.
        :paramtype colormap_name: str or ~azure.planetarycomputer.models.ColorMapNames
        :keyword colormap: JSON encoded custom Colormap. Default value is None.
        :paramtype colormap: str
        :keyword return_mask: Add mask to the output data. Default value is None.
        :paramtype return_mask: bool
        :return: TileJsonResponse. The TileJsonResponse is compatible with MutableMapping
        :rtype: ~azure.planetarycomputer.models.TileJsonResponse
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[_models.TileJsonResponse] = kwargs.pop("cls", None)

        _request = build_tiler_tile_json_tile_matrix_sets_get_request(
            collection_id=collection_id,
            item_id=item_id,
            tile_matrix_set_id=tile_matrix_set_id,
            assets=assets,
            expression=expression,
            asset_bidx=asset_bidx,
            asset_as_band=asset_as_band,
            nodata=nodata,
            unscale=unscale,
            algorithm=algorithm,
            algorithm_params=algorithm_params,
            tile_format=tile_format,
            tile_scale=tile_scale,
            minzoom=minzoom,
            maxzoom=maxzoom,
            buffer=buffer,
            color_formula=color_formula,
            resampling=resampling,
            rescale=rescale,
            colormap_name=colormap_name,
            colormap=colormap,
            return_mask=return_mask,
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = kwargs.pop("stream", False)
        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                try:
                    response.read()  # Load the body in memory and close the socket
                except (StreamConsumedError, StreamClosedError):
                    pass
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if _stream:
            deserialized = response.iter_bytes()
        else:
            deserialized = _deserialize(_models.TileJsonResponse, response.json())

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore


class TilerWmtsOperations:
    """
    .. warning::
        **DO NOT** instantiate this class directly.

        Instead, you should access the following operations through
        :class:`~azure.planetarycomputer.PlanetaryComputerClient`'s
        :attr:`tiler_wmts` attribute.
    """

    def __init__(self, *args, **kwargs) -> None:
        input_args = list(args)
        self._client: PipelineClient = input_args.pop(0) if input_args else kwargs.pop("client")
        self._config: PlanetaryComputerClientConfiguration = input_args.pop(0) if input_args else kwargs.pop("config")
        self._serialize: Serializer = input_args.pop(0) if input_args else kwargs.pop("serializer")
        self._deserialize: Deserializer = input_args.pop(0) if input_args else kwargs.pop("deserializer")

    @distributed_trace
    def get_capabilities_xml(
        self,
        collection_id: str,
        item_id: str,
        *,
        assets: Optional[List[str]] = None,
        expression: Optional[str] = None,
        asset_bidx: Optional[List[str]] = None,
        asset_as_band: Optional[bool] = None,
        nodata: Optional[float] = None,
        unscale: Optional[bool] = None,
        algorithm: Optional[Union[str, _models.Algorithm]] = None,
        algorithm_params: Optional[str] = None,
        tile_matrix_set_id: Optional[Union[str, _models.Tilematrixsetid]] = None,
        tile_format: Optional[Union[str, _models.ImageType]] = None,
        tile_scale: Optional[int] = None,
        minzoom: Optional[int] = None,
        maxzoom: Optional[int] = None,
        buffer: Optional[str] = None,
        color_formula: Optional[str] = None,
        resampling: Optional[Union[str, _models.Resampling]] = None,
        rescale: Optional[List[str]] = None,
        colormap_name: Optional[Union[str, _models.ColorMapNames]] = None,
        colormap: Optional[str] = None,
        return_mask: Optional[bool] = None,
        **kwargs: Any,
    ) -> Optional[str]:
        """Wmts.

        OGC WMTS endpoint.

        :param collection_id: STAC Collection Identifier. Required.
        :type collection_id: str
        :param item_id: STAC Item Identifier. Required.
        :type item_id: str
        :keyword assets: Asset's names. Default value is None.
        :paramtype assets: list[str]
        :keyword expression: Band math expression between assets. Default value is None.
        :paramtype expression: str
        :keyword asset_bidx: Per asset band indexes (coma separated indexes). Default value is None.
        :paramtype asset_bidx: list[str]
        :keyword asset_as_band: Asset as Band. Default value is None.
        :paramtype asset_as_band: bool
        :keyword nodata: Overwrite internal Nodata value. Default value is None.
        :paramtype nodata: float
        :keyword unscale: Apply internal Scale or Offset. Default value is None.
        :paramtype unscale: bool
        :keyword algorithm: Algorithm name. Known values are: "hillshade", "contours",
         "normalizedIndex", "terrarium", and "terrainrgb". Default value is None.
        :paramtype algorithm: str or ~azure.planetarycomputer.models.Algorithm
        :keyword algorithm_params: Algorithm parameter. Default value is None.
        :paramtype algorithm_params: str
        :keyword tile_matrix_set_id: Identifier selecting one of the TileMatrixSetId supported
         (default:
         'WebMercatorQuad'). Known values are: "CanadianNAD83_LCC", "EuropeanETRS89_LAEAQuad",
         "LINZAntarticaMapTilegrid", "NZTM2000Quad", "UPSAntarcticWGS84Quad", "UPSArcticWGS84Quad",
         "UTM31WGS84Quad", "WGS1984Quad", "WebMercatorQuad", "WorldCRS84Quad", and
         "WorldMercatorWGS84Quad". Default value is None.
        :paramtype tile_matrix_set_id: str or ~azure.planetarycomputer.models.Tilematrixsetid
        :keyword tile_format: Output image type. Default is png. Known values are: "png", "npy", "tif",
         "jpeg", "jpg", "jp2", "webp", and "pngraw". Default value is None.
        :paramtype tile_format: str or ~azure.planetarycomputer.models.ImageType
        :keyword tile_scale: Tile scale factor affecting output size. Values > 1 produce larger tiles
         (e.g., 1=256x256, 2=512x512). Default value is None.
        :paramtype tile_scale: int
        :keyword minzoom: Overwrite default minzoom. Default value is None.
        :paramtype minzoom: int
        :keyword maxzoom: Overwrite default maxzoom. Default value is None.
        :paramtype maxzoom: int
        :keyword buffer: Buffer on each side of the given tile. It must be a multiple of ``0.5``.
         Output
         **tilesize** will be expanded to ``tilesize + 2 * buffer`` (e.g 0.5 = 257x257,
         1.0 = 258x258). Default value is None.
        :paramtype buffer: str
        :keyword color_formula: rio-color formula (info: `https://github.com/mapbox/rio-color
         <https://github.com/mapbox/rio-color>`_). Default value is None.
        :paramtype color_formula: str
        :keyword resampling: Resampling method. Known values are: "nearest", "bilinear", "cubic",
         "cubic_spline", "lanczos", "average", "mode", "gauss", and "rms". Default value is None.
        :paramtype resampling: str or ~azure.planetarycomputer.models.Resampling
        :keyword rescale: comma (',') delimited Min,Max range. Can set multiple time for multiple
         bands. Default value is None.
        :paramtype rescale: list[str]
        :keyword colormap_name: Colormap name. Known values are: "accent", "accent_r", "afmhot",
         "afmhot_r", "ai4g-lulc", "alos-fnf", "alos-palsar-mask", "autumn", "autumn_r", "binary",
         "binary_r", "blues", "blues_r", "bone", "bone_r", "brbg", "brbg_r", "brg", "brg_r", "bugn",
         "bugn_r", "bupu", "bupu_r", "bwr", "bwr_r", "c-cap", "cfastie", "chesapeake-lc-13",
         "chesapeake-lc-7", "chesapeake-lu", "chloris-biomass", "cividis", "cividis_r", "cmrmap",
         "cmrmap_r", "cool", "cool_r", "coolwarm", "coolwarm_r", "copper", "copper_r", "cubehelix",
         "cubehelix_r", "dark2", "dark2_r", "drcog-lulc", "esa-cci-lc", "esa-worldcover", "flag",
         "flag_r", "gap-lulc", "gist_earth", "gist_earth_r", "gist_gray", "gist_gray_r", "gist_heat",
         "gist_heat_r", "gist_ncar", "gist_ncar_r", "gist_rainbow", "gist_rainbow_r", "gist_stern",
         "gist_stern_r", "gist_yarg", "gist_yarg_r", "gnbu", "gnbu_r", "gnuplot", "gnuplot2",
         "gnuplot2_r", "gnuplot_r", "gray", "gray_r", "greens", "greens_r", "greys", "greys_r", "hot",
         "hot_r", "hsv", "hsv_r", "inferno", "inferno_r", "io-bii", "io-lulc", "io-lulc-9-class", "jet",
         "jet_r", "jrc-change", "jrc-extent", "jrc-occurrence", "jrc-recurrence", "jrc-seasonality",
         "jrc-transitions", "lidar-classification", "lidar-hag", "lidar-hag-alternative",
         "lidar-intensity", "lidar-returns", "magma", "magma_r", "modis-10A1", "modis-10A2",
         "modis-13A1|Q1", "modis-14A1|A2", "modis-15A2H|A3H", "modis-16A3GF-ET", "modis-16A3GF-PET",
         "modis-17A2H|A2HGF", "modis-17A3HGF", "modis-64A1", "mtbs-severity", "nipy_spectral",
         "nipy_spectral_r", "nrcan-lulc", "ocean", "ocean_r", "oranges", "oranges_r", "orrd", "orrd_r",
         "paired", "paired_r", "pastel1", "pastel1_r", "pastel2", "pastel2_r", "pink", "pink_r", "piyg",
         "piyg_r", "plasma", "plasma_r", "prgn", "prgn_r", "prism", "prism_r", "pubu", "pubu_r",
         "pubugn", "pubugn_r", "puor", "puor_r", "purd", "purd_r", "purples", "purples_r", "qpe",
         "rainbow", "rainbow_r", "rdbu", "rdbu_r", "rdgy", "rdgy_r", "rdpu", "rdpu_r", "rdylbu",
         "rdylbu_r", "rdylgn", "rdylgn_r", "reds", "reds_r", "rplumbo", "schwarzwald", "seismic",
         "seismic_r", "set1", "set1_r", "set2", "set2_r", "set3", "set3_r", "spectral", "spectral_r",
         "spring", "spring_r", "summer", "summer_r", "tab10", "tab10_r", "tab20", "tab20_r", "tab20b",
         "tab20b_r", "tab20c", "tab20c_r", "terrain", "terrain_r", "twilight", "twilight_r",
         "twilight_shifted", "twilight_shifted_r", "usda-cdl", "usda-cdl-corn", "usda-cdl-cotton",
         "usda-cdl-soybeans", "usda-cdl-wheat", "usgs-lcmap", "viirs-10a1", "viirs-13a1", "viirs-14a1",
         "viirs-15a2H", "viridis", "viridis_r", "winter", "winter_r", "wistia", "wistia_r", "ylgn",
         "ylgn_r", "ylgnbu", "ylgnbu_r", "ylorbr", "ylorbr_r", "ylorrd", and "ylorrd_r". Default value
         is None.
        :paramtype colormap_name: str or ~azure.planetarycomputer.models.ColorMapNames
        :keyword colormap: JSON encoded custom Colormap. Default value is None.
        :paramtype colormap: str
        :keyword return_mask: Add mask to the output data. Default value is None.
        :paramtype return_mask: bool
        :return: str or None
        :rtype: str or None
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[Optional[str]] = kwargs.pop("cls", None)

        _request = build_tiler_wmts_get_capabilities_xml_request(
            collection_id=collection_id,
            item_id=item_id,
            assets=assets,
            expression=expression,
            asset_bidx=asset_bidx,
            asset_as_band=asset_as_band,
            nodata=nodata,
            unscale=unscale,
            algorithm=algorithm,
            algorithm_params=algorithm_params,
            tile_matrix_set_id=tile_matrix_set_id,
            tile_format=tile_format,
            tile_scale=tile_scale,
            minzoom=minzoom,
            maxzoom=maxzoom,
            buffer=buffer,
            color_formula=color_formula,
            resampling=resampling,
            rescale=rescale,
            colormap_name=colormap_name,
            colormap=colormap,
            return_mask=return_mask,
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = kwargs.pop("stream", False)
        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200, 204]:
            if _stream:
                try:
                    response.read()  # Load the body in memory and close the socket
                except (StreamConsumedError, StreamClosedError):
                    pass
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        deserialized = None
        response_headers = {}
        if response.status_code == 200:
            response_headers["content-type"] = self._deserialize("str", response.headers.get("content-type"))

            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize_xml(str, response.text())

        if cls:
            return cls(pipeline_response, deserialized, response_headers)  # type: ignore

        return deserialized  # type: ignore


class TilerWmtsTileMatrixSetsOperations:
    """
    .. warning::
        **DO NOT** instantiate this class directly.

        Instead, you should access the following operations through
        :class:`~azure.planetarycomputer.PlanetaryComputerClient`'s
        :attr:`tiler_wmts_tile_matrix_sets` attribute.
    """

    def __init__(self, *args, **kwargs) -> None:
        input_args = list(args)
        self._client: PipelineClient = input_args.pop(0) if input_args else kwargs.pop("client")
        self._config: PlanetaryComputerClientConfiguration = input_args.pop(0) if input_args else kwargs.pop("config")
        self._serialize: Serializer = input_args.pop(0) if input_args else kwargs.pop("serializer")
        self._deserialize: Deserializer = input_args.pop(0) if input_args else kwargs.pop("deserializer")

    @distributed_trace
    def get_capabilities_xml(
        self,
        collection_id: str,
        item_id: str,
        tile_matrix_set_id: str,
        *,
        assets: Optional[List[str]] = None,
        expression: Optional[str] = None,
        asset_bidx: Optional[List[str]] = None,
        asset_as_band: Optional[bool] = None,
        nodata: Optional[float] = None,
        unscale: Optional[bool] = None,
        algorithm: Optional[Union[str, _models.Algorithm]] = None,
        algorithm_params: Optional[str] = None,
        tile_format: Optional[Union[str, _models.ImageType]] = None,
        tile_scale: Optional[int] = None,
        minzoom: Optional[int] = None,
        maxzoom: Optional[int] = None,
        buffer: Optional[str] = None,
        color_formula: Optional[str] = None,
        resampling: Optional[Union[str, _models.Resampling]] = None,
        rescale: Optional[List[str]] = None,
        colormap_name: Optional[Union[str, _models.ColorMapNames]] = None,
        colormap: Optional[str] = None,
        return_mask: Optional[bool] = None,
        **kwargs: Any,
    ) -> str:
        """Wmts Tilematrixsetid As Path.

        OGC WMTS endpoint.

        :param collection_id: STAC Collection Identifier. Required.
        :type collection_id: str
        :param item_id: STAC Item Identifier. Required.
        :type item_id: str
        :param tile_matrix_set_id: Identifier selecting one of the TileMatrixSetId supported. Required.
        :type tile_matrix_set_id: str
        :keyword assets: Asset's names. Default value is None.
        :paramtype assets: list[str]
        :keyword expression: Band math expression between assets. Default value is None.
        :paramtype expression: str
        :keyword asset_bidx: Per asset band indexes (coma separated indexes). Default value is None.
        :paramtype asset_bidx: list[str]
        :keyword asset_as_band: Asset as Band. Default value is None.
        :paramtype asset_as_band: bool
        :keyword nodata: Overwrite internal Nodata value. Default value is None.
        :paramtype nodata: float
        :keyword unscale: Apply internal Scale or Offset. Default value is None.
        :paramtype unscale: bool
        :keyword algorithm: Algorithm name. Known values are: "hillshade", "contours",
         "normalizedIndex", "terrarium", and "terrainrgb". Default value is None.
        :paramtype algorithm: str or ~azure.planetarycomputer.models.Algorithm
        :keyword algorithm_params: Algorithm parameter. Default value is None.
        :paramtype algorithm_params: str
        :keyword tile_format: Output image type. Default is png. Known values are: "png", "npy", "tif",
         "jpeg", "jpg", "jp2", "webp", and "pngraw". Default value is None.
        :paramtype tile_format: str or ~azure.planetarycomputer.models.ImageType
        :keyword tile_scale: Tile scale factor affecting output size. Values > 1 produce larger tiles
         (e.g., 1=256x256, 2=512x512). Default value is None.
        :paramtype tile_scale: int
        :keyword minzoom: Overwrite default minzoom. Default value is None.
        :paramtype minzoom: int
        :keyword maxzoom: Overwrite default maxzoom. Default value is None.
        :paramtype maxzoom: int
        :keyword buffer: Buffer on each side of the given tile. It must be a multiple of ``0.5``.
         Output
         **tilesize** will be expanded to ``tilesize + 2 * buffer`` (e.g 0.5 = 257x257,
         1.0 = 258x258). Default value is None.
        :paramtype buffer: str
        :keyword color_formula: rio-color formula (info: `https://github.com/mapbox/rio-color
         <https://github.com/mapbox/rio-color>`_). Default value is None.
        :paramtype color_formula: str
        :keyword resampling: Resampling method. Known values are: "nearest", "bilinear", "cubic",
         "cubic_spline", "lanczos", "average", "mode", "gauss", and "rms". Default value is None.
        :paramtype resampling: str or ~azure.planetarycomputer.models.Resampling
        :keyword rescale: comma (',') delimited Min,Max range. Can set multiple time for multiple
         bands. Default value is None.
        :paramtype rescale: list[str]
        :keyword colormap_name: Colormap name. Known values are: "accent", "accent_r", "afmhot",
         "afmhot_r", "ai4g-lulc", "alos-fnf", "alos-palsar-mask", "autumn", "autumn_r", "binary",
         "binary_r", "blues", "blues_r", "bone", "bone_r", "brbg", "brbg_r", "brg", "brg_r", "bugn",
         "bugn_r", "bupu", "bupu_r", "bwr", "bwr_r", "c-cap", "cfastie", "chesapeake-lc-13",
         "chesapeake-lc-7", "chesapeake-lu", "chloris-biomass", "cividis", "cividis_r", "cmrmap",
         "cmrmap_r", "cool", "cool_r", "coolwarm", "coolwarm_r", "copper", "copper_r", "cubehelix",
         "cubehelix_r", "dark2", "dark2_r", "drcog-lulc", "esa-cci-lc", "esa-worldcover", "flag",
         "flag_r", "gap-lulc", "gist_earth", "gist_earth_r", "gist_gray", "gist_gray_r", "gist_heat",
         "gist_heat_r", "gist_ncar", "gist_ncar_r", "gist_rainbow", "gist_rainbow_r", "gist_stern",
         "gist_stern_r", "gist_yarg", "gist_yarg_r", "gnbu", "gnbu_r", "gnuplot", "gnuplot2",
         "gnuplot2_r", "gnuplot_r", "gray", "gray_r", "greens", "greens_r", "greys", "greys_r", "hot",
         "hot_r", "hsv", "hsv_r", "inferno", "inferno_r", "io-bii", "io-lulc", "io-lulc-9-class", "jet",
         "jet_r", "jrc-change", "jrc-extent", "jrc-occurrence", "jrc-recurrence", "jrc-seasonality",
         "jrc-transitions", "lidar-classification", "lidar-hag", "lidar-hag-alternative",
         "lidar-intensity", "lidar-returns", "magma", "magma_r", "modis-10A1", "modis-10A2",
         "modis-13A1|Q1", "modis-14A1|A2", "modis-15A2H|A3H", "modis-16A3GF-ET", "modis-16A3GF-PET",
         "modis-17A2H|A2HGF", "modis-17A3HGF", "modis-64A1", "mtbs-severity", "nipy_spectral",
         "nipy_spectral_r", "nrcan-lulc", "ocean", "ocean_r", "oranges", "oranges_r", "orrd", "orrd_r",
         "paired", "paired_r", "pastel1", "pastel1_r", "pastel2", "pastel2_r", "pink", "pink_r", "piyg",
         "piyg_r", "plasma", "plasma_r", "prgn", "prgn_r", "prism", "prism_r", "pubu", "pubu_r",
         "pubugn", "pubugn_r", "puor", "puor_r", "purd", "purd_r", "purples", "purples_r", "qpe",
         "rainbow", "rainbow_r", "rdbu", "rdbu_r", "rdgy", "rdgy_r", "rdpu", "rdpu_r", "rdylbu",
         "rdylbu_r", "rdylgn", "rdylgn_r", "reds", "reds_r", "rplumbo", "schwarzwald", "seismic",
         "seismic_r", "set1", "set1_r", "set2", "set2_r", "set3", "set3_r", "spectral", "spectral_r",
         "spring", "spring_r", "summer", "summer_r", "tab10", "tab10_r", "tab20", "tab20_r", "tab20b",
         "tab20b_r", "tab20c", "tab20c_r", "terrain", "terrain_r", "twilight", "twilight_r",
         "twilight_shifted", "twilight_shifted_r", "usda-cdl", "usda-cdl-corn", "usda-cdl-cotton",
         "usda-cdl-soybeans", "usda-cdl-wheat", "usgs-lcmap", "viirs-10a1", "viirs-13a1", "viirs-14a1",
         "viirs-15a2H", "viridis", "viridis_r", "winter", "winter_r", "wistia", "wistia_r", "ylgn",
         "ylgn_r", "ylgnbu", "ylgnbu_r", "ylorbr", "ylorbr_r", "ylorrd", and "ylorrd_r". Default value
         is None.
        :paramtype colormap_name: str or ~azure.planetarycomputer.models.ColorMapNames
        :keyword colormap: JSON encoded custom Colormap. Default value is None.
        :paramtype colormap: str
        :keyword return_mask: Add mask to the output data. Default value is None.
        :paramtype return_mask: bool
        :return: str
        :rtype: str
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[str] = kwargs.pop("cls", None)

        _request = build_tiler_wmts_tile_matrix_sets_get_capabilities_xml_request(
            collection_id=collection_id,
            item_id=item_id,
            tile_matrix_set_id=tile_matrix_set_id,
            assets=assets,
            expression=expression,
            asset_bidx=asset_bidx,
            asset_as_band=asset_as_band,
            nodata=nodata,
            unscale=unscale,
            algorithm=algorithm,
            algorithm_params=algorithm_params,
            tile_format=tile_format,
            tile_scale=tile_scale,
            minzoom=minzoom,
            maxzoom=maxzoom,
            buffer=buffer,
            color_formula=color_formula,
            resampling=resampling,
            rescale=rescale,
            colormap_name=colormap_name,
            colormap=colormap,
            return_mask=return_mask,
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = kwargs.pop("stream", False)
        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                try:
                    response.read()  # Load the body in memory and close the socket
                except (StreamConsumedError, StreamClosedError):
                    pass
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        response_headers = {}
        response_headers["content-type"] = self._deserialize("str", response.headers.get("content-type"))

        if _stream:
            deserialized = response.iter_bytes()
        else:
            deserialized = _deserialize_xml(str, response.text())

        if cls:
            return cls(pipeline_response, deserialized, response_headers)  # type: ignore

        return deserialized  # type: ignore


class TilerPointsOperations:
    """
    .. warning::
        **DO NOT** instantiate this class directly.

        Instead, you should access the following operations through
        :class:`~azure.planetarycomputer.PlanetaryComputerClient`'s
        :attr:`tiler_points` attribute.
    """

    def __init__(self, *args, **kwargs) -> None:
        input_args = list(args)
        self._client: PipelineClient = input_args.pop(0) if input_args else kwargs.pop("client")
        self._config: PlanetaryComputerClientConfiguration = input_args.pop(0) if input_args else kwargs.pop("config")
        self._serialize: Serializer = input_args.pop(0) if input_args else kwargs.pop("serializer")
        self._deserialize: Deserializer = input_args.pop(0) if input_args else kwargs.pop("deserializer")

    @distributed_trace
    def get_lon_lat(
        self,
        collection_id: str,
        item_id: str,
        lon: float,
        lat: float,
        *,
        assets: Optional[List[str]] = None,
        expression: Optional[str] = None,
        asset_bidx: Optional[List[str]] = None,
        asset_as_band: Optional[bool] = None,
        nodata: Optional[float] = None,
        unscale: Optional[bool] = None,
        coord_crs: Optional[str] = None,
        resampling: Optional[Union[str, _models.Resampling]] = None,
        **kwargs: Any,
    ) -> _models.TitilerCoreModelsResponsesPoint:
        """Point.

        Get Point value for a dataset.

        :param collection_id: STAC Collection Identifier. Required.
        :type collection_id: str
        :param item_id: STAC Item Identifier. Required.
        :type item_id: str
        :param lon: Longitude. Required.
        :type lon: float
        :param lat: Latitude. Required.
        :type lat: float
        :keyword assets: Asset's names. Default value is None.
        :paramtype assets: list[str]
        :keyword expression: Band math expression between assets. Default value is None.
        :paramtype expression: str
        :keyword asset_bidx: Per asset band indexes (coma separated indexes). Default value is None.
        :paramtype asset_bidx: list[str]
        :keyword asset_as_band: Asset as Band. Default value is None.
        :paramtype asset_as_band: bool
        :keyword nodata: Overwrite internal Nodata value. Default value is None.
        :paramtype nodata: float
        :keyword unscale: Apply internal Scale or Offset. Default value is None.
        :paramtype unscale: bool
        :keyword coord_crs: Coordinate Reference System of the input coords. Default to ``epsg:4326``.
         Default value is None.
        :paramtype coord_crs: str
        :keyword resampling: Resampling method. Known values are: "nearest", "bilinear", "cubic",
         "cubic_spline", "lanczos", "average", "mode", "gauss", and "rms". Default value is None.
        :paramtype resampling: str or ~azure.planetarycomputer.models.Resampling
        :return: TitilerCoreModelsResponsesPoint. The TitilerCoreModelsResponsesPoint is compatible
         with MutableMapping
        :rtype: ~azure.planetarycomputer.models.TitilerCoreModelsResponsesPoint
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[_models.TitilerCoreModelsResponsesPoint] = kwargs.pop("cls", None)

        _request = build_tiler_points_get_lon_lat_request(
            collection_id=collection_id,
            item_id=item_id,
            lon=lon,
            lat=lat,
            assets=assets,
            expression=expression,
            asset_bidx=asset_bidx,
            asset_as_band=asset_as_band,
            nodata=nodata,
            unscale=unscale,
            coord_crs=coord_crs,
            resampling=resampling,
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = kwargs.pop("stream", False)
        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                try:
                    response.read()  # Load the body in memory and close the socket
                except (StreamConsumedError, StreamClosedError):
                    pass
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if _stream:
            deserialized = response.iter_bytes()
        else:
            deserialized = _deserialize(_models.TitilerCoreModelsResponsesPoint, response.json())

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore


class TilerPreviewsOperations:
    """
    .. warning::
        **DO NOT** instantiate this class directly.

        Instead, you should access the following operations through
        :class:`~azure.planetarycomputer.PlanetaryComputerClient`'s
        :attr:`tiler_previews` attribute.
    """

    def __init__(self, *args, **kwargs) -> None:
        input_args = list(args)
        self._client: PipelineClient = input_args.pop(0) if input_args else kwargs.pop("client")
        self._config: PlanetaryComputerClientConfiguration = input_args.pop(0) if input_args else kwargs.pop("config")
        self._serialize: Serializer = input_args.pop(0) if input_args else kwargs.pop("serializer")
        self._deserialize: Deserializer = input_args.pop(0) if input_args else kwargs.pop("deserializer")

    @distributed_trace
    def get_format(
        self,
        collection_id: str,
        item_id: str,
        format: str,
        *,
        assets: Optional[List[str]] = None,
        expression: Optional[str] = None,
        asset_bidx: Optional[List[str]] = None,
        asset_as_band: Optional[bool] = None,
        nodata: Optional[float] = None,
        unscale: Optional[bool] = None,
        algorithm: Optional[Union[str, _models.Algorithm]] = None,
        algorithm_params: Optional[str] = None,
        color_formula: Optional[str] = None,
        dst_crs: Optional[str] = None,
        resampling: Optional[Union[str, _models.Resampling]] = None,
        max_size: Optional[int] = None,
        height: Optional[int] = None,
        width: Optional[int] = None,
        rescale: Optional[List[str]] = None,
        colormap_name: Optional[Union[str, _models.ColorMapNames]] = None,
        colormap: Optional[str] = None,
        return_mask: Optional[bool] = None,
        **kwargs: Any,
    ) -> Iterator[bytes]:
        """Preview.

        Create preview of a dataset.

        :param collection_id: STAC Collection Identifier. Required.
        :type collection_id: str
        :param item_id: STAC Item Identifier. Required.
        :type item_id: str
        :param format: Output format for the tile or image (e.g., png, jpeg, webp). Required.
        :type format: str
        :keyword assets: Asset's names. Default value is None.
        :paramtype assets: list[str]
        :keyword expression: Band math expression between assets. Default value is None.
        :paramtype expression: str
        :keyword asset_bidx: Per asset band indexes (coma separated indexes). Default value is None.
        :paramtype asset_bidx: list[str]
        :keyword asset_as_band: Asset as Band. Default value is None.
        :paramtype asset_as_band: bool
        :keyword nodata: Overwrite internal Nodata value. Default value is None.
        :paramtype nodata: float
        :keyword unscale: Apply internal Scale or Offset. Default value is None.
        :paramtype unscale: bool
        :keyword algorithm: Algorithm name. Known values are: "hillshade", "contours",
         "normalizedIndex", "terrarium", and "terrainrgb". Default value is None.
        :paramtype algorithm: str or ~azure.planetarycomputer.models.Algorithm
        :keyword algorithm_params: Algorithm parameter. Default value is None.
        :paramtype algorithm_params: str
        :keyword color_formula: rio-color formula (info: `https://github.com/mapbox/rio-color
         <https://github.com/mapbox/rio-color>`_). Default value is None.
        :paramtype color_formula: str
        :keyword dst_crs: Output Coordinate Reference System. Default value is None.
        :paramtype dst_crs: str
        :keyword resampling: Resampling method. Known values are: "nearest", "bilinear", "cubic",
         "cubic_spline", "lanczos", "average", "mode", "gauss", and "rms". Default value is None.
        :paramtype resampling: str or ~azure.planetarycomputer.models.Resampling
        :keyword max_size: Image output size limit if width and height limits are not set. Default
         value is None.
        :paramtype max_size: int
        :keyword height: Height in pixels for the output image. Default value is None.
        :paramtype height: int
        :keyword width: Width in pixels for the output image. Default value is None.
        :paramtype width: int
        :keyword rescale: comma (',') delimited Min,Max range. Can set multiple time for multiple
         bands. Default value is None.
        :paramtype rescale: list[str]
        :keyword colormap_name: Colormap name. Known values are: "accent", "accent_r", "afmhot",
         "afmhot_r", "ai4g-lulc", "alos-fnf", "alos-palsar-mask", "autumn", "autumn_r", "binary",
         "binary_r", "blues", "blues_r", "bone", "bone_r", "brbg", "brbg_r", "brg", "brg_r", "bugn",
         "bugn_r", "bupu", "bupu_r", "bwr", "bwr_r", "c-cap", "cfastie", "chesapeake-lc-13",
         "chesapeake-lc-7", "chesapeake-lu", "chloris-biomass", "cividis", "cividis_r", "cmrmap",
         "cmrmap_r", "cool", "cool_r", "coolwarm", "coolwarm_r", "copper", "copper_r", "cubehelix",
         "cubehelix_r", "dark2", "dark2_r", "drcog-lulc", "esa-cci-lc", "esa-worldcover", "flag",
         "flag_r", "gap-lulc", "gist_earth", "gist_earth_r", "gist_gray", "gist_gray_r", "gist_heat",
         "gist_heat_r", "gist_ncar", "gist_ncar_r", "gist_rainbow", "gist_rainbow_r", "gist_stern",
         "gist_stern_r", "gist_yarg", "gist_yarg_r", "gnbu", "gnbu_r", "gnuplot", "gnuplot2",
         "gnuplot2_r", "gnuplot_r", "gray", "gray_r", "greens", "greens_r", "greys", "greys_r", "hot",
         "hot_r", "hsv", "hsv_r", "inferno", "inferno_r", "io-bii", "io-lulc", "io-lulc-9-class", "jet",
         "jet_r", "jrc-change", "jrc-extent", "jrc-occurrence", "jrc-recurrence", "jrc-seasonality",
         "jrc-transitions", "lidar-classification", "lidar-hag", "lidar-hag-alternative",
         "lidar-intensity", "lidar-returns", "magma", "magma_r", "modis-10A1", "modis-10A2",
         "modis-13A1|Q1", "modis-14A1|A2", "modis-15A2H|A3H", "modis-16A3GF-ET", "modis-16A3GF-PET",
         "modis-17A2H|A2HGF", "modis-17A3HGF", "modis-64A1", "mtbs-severity", "nipy_spectral",
         "nipy_spectral_r", "nrcan-lulc", "ocean", "ocean_r", "oranges", "oranges_r", "orrd", "orrd_r",
         "paired", "paired_r", "pastel1", "pastel1_r", "pastel2", "pastel2_r", "pink", "pink_r", "piyg",
         "piyg_r", "plasma", "plasma_r", "prgn", "prgn_r", "prism", "prism_r", "pubu", "pubu_r",
         "pubugn", "pubugn_r", "puor", "puor_r", "purd", "purd_r", "purples", "purples_r", "qpe",
         "rainbow", "rainbow_r", "rdbu", "rdbu_r", "rdgy", "rdgy_r", "rdpu", "rdpu_r", "rdylbu",
         "rdylbu_r", "rdylgn", "rdylgn_r", "reds", "reds_r", "rplumbo", "schwarzwald", "seismic",
         "seismic_r", "set1", "set1_r", "set2", "set2_r", "set3", "set3_r", "spectral", "spectral_r",
         "spring", "spring_r", "summer", "summer_r", "tab10", "tab10_r", "tab20", "tab20_r", "tab20b",
         "tab20b_r", "tab20c", "tab20c_r", "terrain", "terrain_r", "twilight", "twilight_r",
         "twilight_shifted", "twilight_shifted_r", "usda-cdl", "usda-cdl-corn", "usda-cdl-cotton",
         "usda-cdl-soybeans", "usda-cdl-wheat", "usgs-lcmap", "viirs-10a1", "viirs-13a1", "viirs-14a1",
         "viirs-15a2H", "viridis", "viridis_r", "winter", "winter_r", "wistia", "wistia_r", "ylgn",
         "ylgn_r", "ylgnbu", "ylgnbu_r", "ylorbr", "ylorbr_r", "ylorrd", and "ylorrd_r". Default value
         is None.
        :paramtype colormap_name: str or ~azure.planetarycomputer.models.ColorMapNames
        :keyword colormap: JSON encoded custom Colormap. Default value is None.
        :paramtype colormap: str
        :keyword return_mask: Add mask to the output data. Default value is None.
        :paramtype return_mask: bool
        :return: Iterator[bytes]
        :rtype: Iterator[bytes]
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[Iterator[bytes]] = kwargs.pop("cls", None)

        _request = build_tiler_previews_get_format_request(
            collection_id=collection_id,
            item_id=item_id,
            format=format,
            assets=assets,
            expression=expression,
            asset_bidx=asset_bidx,
            asset_as_band=asset_as_band,
            nodata=nodata,
            unscale=unscale,
            algorithm=algorithm,
            algorithm_params=algorithm_params,
            color_formula=color_formula,
            dst_crs=dst_crs,
            resampling=resampling,
            max_size=max_size,
            height=height,
            width=width,
            rescale=rescale,
            colormap_name=colormap_name,
            colormap=colormap,
            return_mask=return_mask,
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = kwargs.pop("stream", True)
        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                try:
                    response.read()  # Load the body in memory and close the socket
                except (StreamConsumedError, StreamClosedError):
                    pass
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        response_headers = {}
        response_headers["content-type"] = self._deserialize("str", response.headers.get("content-type"))
        response_headers["content-type"] = self._deserialize("str", response.headers.get("content-type"))
        response_headers["content-type"] = self._deserialize("str", response.headers.get("content-type"))
        response_headers["content-type"] = self._deserialize("str", response.headers.get("content-type"))
        response_headers["content-type"] = self._deserialize("str", response.headers.get("content-type"))
        response_headers["content-type"] = self._deserialize("str", response.headers.get("content-type"))
        response_headers["content-type"] = self._deserialize("str", response.headers.get("content-type"))

        deserialized = response.iter_bytes()

        if cls:
            return cls(pipeline_response, deserialized, response_headers)  # type: ignore

        return deserialized  # type: ignore

    @distributed_trace
    def get(
        self,
        collection_id: str,
        item_id: str,
        *,
        assets: Optional[List[str]] = None,
        expression: Optional[str] = None,
        asset_bidx: Optional[List[str]] = None,
        asset_as_band: Optional[bool] = None,
        nodata: Optional[float] = None,
        unscale: Optional[bool] = None,
        algorithm: Optional[Union[str, _models.Algorithm]] = None,
        algorithm_params: Optional[str] = None,
        format: Optional[Union[str, _models.ImageType]] = None,
        color_formula: Optional[str] = None,
        dst_crs: Optional[str] = None,
        resampling: Optional[Union[str, _models.Resampling]] = None,
        max_size: Optional[int] = None,
        height: Optional[int] = None,
        width: Optional[int] = None,
        rescale: Optional[List[str]] = None,
        colormap_name: Optional[Union[str, _models.ColorMapNames]] = None,
        colormap: Optional[str] = None,
        return_mask: Optional[bool] = None,
        **kwargs: Any,
    ) -> Iterator[bytes]:
        """Preview.

        Create preview of a dataset.

        :param collection_id: STAC Collection Identifier. Required.
        :type collection_id: str
        :param item_id: STAC Item Identifier. Required.
        :type item_id: str
        :keyword assets: Asset's names. Default value is None.
        :paramtype assets: list[str]
        :keyword expression: Band math expression between assets. Default value is None.
        :paramtype expression: str
        :keyword asset_bidx: Per asset band indexes (coma separated indexes). Default value is None.
        :paramtype asset_bidx: list[str]
        :keyword asset_as_band: Asset as Band. Default value is None.
        :paramtype asset_as_band: bool
        :keyword nodata: Overwrite internal Nodata value. Default value is None.
        :paramtype nodata: float
        :keyword unscale: Apply internal Scale or Offset. Default value is None.
        :paramtype unscale: bool
        :keyword algorithm: Algorithm name. Known values are: "hillshade", "contours",
         "normalizedIndex", "terrarium", and "terrainrgb". Default value is None.
        :paramtype algorithm: str or ~azure.planetarycomputer.models.Algorithm
        :keyword algorithm_params: Algorithm parameter. Default value is None.
        :paramtype algorithm_params: str
        :keyword format: Output format for the tile or image (e.g., png, jpeg, webp). Known values are:
         "png", "npy", "tif", "jpeg", "jpg", "jp2", "webp", and "pngraw". Default value is None.
        :paramtype format: str or ~azure.planetarycomputer.models.ImageType
        :keyword color_formula: rio-color formula (info: `https://github.com/mapbox/rio-color
         <https://github.com/mapbox/rio-color>`_). Default value is None.
        :paramtype color_formula: str
        :keyword dst_crs: Output Coordinate Reference System. Default value is None.
        :paramtype dst_crs: str
        :keyword resampling: Resampling method. Known values are: "nearest", "bilinear", "cubic",
         "cubic_spline", "lanczos", "average", "mode", "gauss", and "rms". Default value is None.
        :paramtype resampling: str or ~azure.planetarycomputer.models.Resampling
        :keyword max_size: Image output size limit if width and height limits are not set. Default
         value is None.
        :paramtype max_size: int
        :keyword height: Height in pixels for the output image. Default value is None.
        :paramtype height: int
        :keyword width: Width in pixels for the output image. Default value is None.
        :paramtype width: int
        :keyword rescale: comma (',') delimited Min,Max range. Can set multiple time for multiple
         bands. Default value is None.
        :paramtype rescale: list[str]
        :keyword colormap_name: Colormap name. Known values are: "accent", "accent_r", "afmhot",
         "afmhot_r", "ai4g-lulc", "alos-fnf", "alos-palsar-mask", "autumn", "autumn_r", "binary",
         "binary_r", "blues", "blues_r", "bone", "bone_r", "brbg", "brbg_r", "brg", "brg_r", "bugn",
         "bugn_r", "bupu", "bupu_r", "bwr", "bwr_r", "c-cap", "cfastie", "chesapeake-lc-13",
         "chesapeake-lc-7", "chesapeake-lu", "chloris-biomass", "cividis", "cividis_r", "cmrmap",
         "cmrmap_r", "cool", "cool_r", "coolwarm", "coolwarm_r", "copper", "copper_r", "cubehelix",
         "cubehelix_r", "dark2", "dark2_r", "drcog-lulc", "esa-cci-lc", "esa-worldcover", "flag",
         "flag_r", "gap-lulc", "gist_earth", "gist_earth_r", "gist_gray", "gist_gray_r", "gist_heat",
         "gist_heat_r", "gist_ncar", "gist_ncar_r", "gist_rainbow", "gist_rainbow_r", "gist_stern",
         "gist_stern_r", "gist_yarg", "gist_yarg_r", "gnbu", "gnbu_r", "gnuplot", "gnuplot2",
         "gnuplot2_r", "gnuplot_r", "gray", "gray_r", "greens", "greens_r", "greys", "greys_r", "hot",
         "hot_r", "hsv", "hsv_r", "inferno", "inferno_r", "io-bii", "io-lulc", "io-lulc-9-class", "jet",
         "jet_r", "jrc-change", "jrc-extent", "jrc-occurrence", "jrc-recurrence", "jrc-seasonality",
         "jrc-transitions", "lidar-classification", "lidar-hag", "lidar-hag-alternative",
         "lidar-intensity", "lidar-returns", "magma", "magma_r", "modis-10A1", "modis-10A2",
         "modis-13A1|Q1", "modis-14A1|A2", "modis-15A2H|A3H", "modis-16A3GF-ET", "modis-16A3GF-PET",
         "modis-17A2H|A2HGF", "modis-17A3HGF", "modis-64A1", "mtbs-severity", "nipy_spectral",
         "nipy_spectral_r", "nrcan-lulc", "ocean", "ocean_r", "oranges", "oranges_r", "orrd", "orrd_r",
         "paired", "paired_r", "pastel1", "pastel1_r", "pastel2", "pastel2_r", "pink", "pink_r", "piyg",
         "piyg_r", "plasma", "plasma_r", "prgn", "prgn_r", "prism", "prism_r", "pubu", "pubu_r",
         "pubugn", "pubugn_r", "puor", "puor_r", "purd", "purd_r", "purples", "purples_r", "qpe",
         "rainbow", "rainbow_r", "rdbu", "rdbu_r", "rdgy", "rdgy_r", "rdpu", "rdpu_r", "rdylbu",
         "rdylbu_r", "rdylgn", "rdylgn_r", "reds", "reds_r", "rplumbo", "schwarzwald", "seismic",
         "seismic_r", "set1", "set1_r", "set2", "set2_r", "set3", "set3_r", "spectral", "spectral_r",
         "spring", "spring_r", "summer", "summer_r", "tab10", "tab10_r", "tab20", "tab20_r", "tab20b",
         "tab20b_r", "tab20c", "tab20c_r", "terrain", "terrain_r", "twilight", "twilight_r",
         "twilight_shifted", "twilight_shifted_r", "usda-cdl", "usda-cdl-corn", "usda-cdl-cotton",
         "usda-cdl-soybeans", "usda-cdl-wheat", "usgs-lcmap", "viirs-10a1", "viirs-13a1", "viirs-14a1",
         "viirs-15a2H", "viridis", "viridis_r", "winter", "winter_r", "wistia", "wistia_r", "ylgn",
         "ylgn_r", "ylgnbu", "ylgnbu_r", "ylorbr", "ylorbr_r", "ylorrd", and "ylorrd_r". Default value
         is None.
        :paramtype colormap_name: str or ~azure.planetarycomputer.models.ColorMapNames
        :keyword colormap: JSON encoded custom Colormap. Default value is None.
        :paramtype colormap: str
        :keyword return_mask: Add mask to the output data. Default value is None.
        :paramtype return_mask: bool
        :return: Iterator[bytes]
        :rtype: Iterator[bytes]
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[Iterator[bytes]] = kwargs.pop("cls", None)

        _request = build_tiler_previews_get_request(
            collection_id=collection_id,
            item_id=item_id,
            assets=assets,
            expression=expression,
            asset_bidx=asset_bidx,
            asset_as_band=asset_as_band,
            nodata=nodata,
            unscale=unscale,
            algorithm=algorithm,
            algorithm_params=algorithm_params,
            format=format,
            color_formula=color_formula,
            dst_crs=dst_crs,
            resampling=resampling,
            max_size=max_size,
            height=height,
            width=width,
            rescale=rescale,
            colormap_name=colormap_name,
            colormap=colormap,
            return_mask=return_mask,
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = kwargs.pop("stream", True)
        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                try:
                    response.read()  # Load the body in memory and close the socket
                except (StreamConsumedError, StreamClosedError):
                    pass
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        response_headers = {}
        response_headers["content-type"] = self._deserialize("str", response.headers.get("content-type"))
        response_headers["content-type"] = self._deserialize("str", response.headers.get("content-type"))
        response_headers["content-type"] = self._deserialize("str", response.headers.get("content-type"))
        response_headers["content-type"] = self._deserialize("str", response.headers.get("content-type"))
        response_headers["content-type"] = self._deserialize("str", response.headers.get("content-type"))
        response_headers["content-type"] = self._deserialize("str", response.headers.get("content-type"))
        response_headers["content-type"] = self._deserialize("str", response.headers.get("content-type"))

        deserialized = response.iter_bytes()

        if cls:
            return cls(pipeline_response, deserialized, response_headers)  # type: ignore

        return deserialized  # type: ignore


class TilerPartsOperations:
    """
    .. warning::
        **DO NOT** instantiate this class directly.

        Instead, you should access the following operations through
        :class:`~azure.planetarycomputer.PlanetaryComputerClient`'s
        :attr:`tiler_parts` attribute.
    """

    def __init__(self, *args, **kwargs) -> None:
        input_args = list(args)
        self._client: PipelineClient = input_args.pop(0) if input_args else kwargs.pop("client")
        self._config: PlanetaryComputerClientConfiguration = input_args.pop(0) if input_args else kwargs.pop("config")
        self._serialize: Serializer = input_args.pop(0) if input_args else kwargs.pop("serializer")
        self._deserialize: Deserializer = input_args.pop(0) if input_args else kwargs.pop("deserializer")

    @distributed_trace
    def get_minx_miny_maxx_maxy_widthx_height_format(  # pylint: disable=name-too-long
        self,
        collection_id: str,
        item_id: str,
        minx: float,
        miny: float,
        maxx: float,
        maxy: float,
        width: float,
        height: float,
        format: str,
        *,
        assets: Optional[List[str]] = None,
        expression: Optional[str] = None,
        asset_bidx: Optional[List[str]] = None,
        asset_as_band: Optional[bool] = None,
        nodata: Optional[float] = None,
        unscale: Optional[bool] = None,
        algorithm: Optional[Union[str, _models.Algorithm]] = None,
        algorithm_params: Optional[str] = None,
        color_formula: Optional[str] = None,
        dst_crs: Optional[str] = None,
        coord_crs: Optional[str] = None,
        resampling: Optional[Union[str, _models.Resampling]] = None,
        max_size: Optional[int] = None,
        rescale: Optional[List[str]] = None,
        colormap_name: Optional[Union[str, _models.ColorMapNames]] = None,
        colormap: Optional[str] = None,
        return_mask: Optional[bool] = None,
        **kwargs: Any,
    ) -> Iterator[bytes]:
        """Part.

        Create image from part of a dataset.

        :param collection_id: STAC Collection Identifier. Required.
        :type collection_id: str
        :param item_id: STAC Item Identifier. Required.
        :type item_id: str
        :param minx: Bounding box min X. Required.
        :type minx: float
        :param miny: Bounding box min Y. Required.
        :type miny: float
        :param maxx: Bounding box max X. Required.
        :type maxx: float
        :param maxy: Bounding box max Y. Required.
        :type maxy: float
        :param width: Width in pixels for the output image. Required.
        :type width: float
        :param height: Height in pixels for the output image. Required.
        :type height: float
        :param format: Output format for the tile or image (e.g., png, jpeg, webp). Required.
        :type format: str
        :keyword assets: Asset's names. Default value is None.
        :paramtype assets: list[str]
        :keyword expression: Band math expression between assets. Default value is None.
        :paramtype expression: str
        :keyword asset_bidx: Per asset band indexes (coma separated indexes). Default value is None.
        :paramtype asset_bidx: list[str]
        :keyword asset_as_band: Asset as Band. Default value is None.
        :paramtype asset_as_band: bool
        :keyword nodata: Overwrite internal Nodata value. Default value is None.
        :paramtype nodata: float
        :keyword unscale: Apply internal Scale or Offset. Default value is None.
        :paramtype unscale: bool
        :keyword algorithm: Algorithm name. Known values are: "hillshade", "contours",
         "normalizedIndex", "terrarium", and "terrainrgb". Default value is None.
        :paramtype algorithm: str or ~azure.planetarycomputer.models.Algorithm
        :keyword algorithm_params: Algorithm parameter. Default value is None.
        :paramtype algorithm_params: str
        :keyword color_formula: rio-color formula (info: `https://github.com/mapbox/rio-color
         <https://github.com/mapbox/rio-color>`_). Default value is None.
        :paramtype color_formula: str
        :keyword dst_crs: Output Coordinate Reference System. Default value is None.
        :paramtype dst_crs: str
        :keyword coord_crs: Coordinate Reference System of the input coords. Default to ``epsg:4326``.
         Default value is None.
        :paramtype coord_crs: str
        :keyword resampling: Resampling method. Known values are: "nearest", "bilinear", "cubic",
         "cubic_spline", "lanczos", "average", "mode", "gauss", and "rms". Default value is None.
        :paramtype resampling: str or ~azure.planetarycomputer.models.Resampling
        :keyword max_size: Image output size limit if width and height limits are not set. Default
         value is None.
        :paramtype max_size: int
        :keyword rescale: comma (',') delimited Min,Max range. Can set multiple time for multiple
         bands. Default value is None.
        :paramtype rescale: list[str]
        :keyword colormap_name: Colormap name. Known values are: "accent", "accent_r", "afmhot",
         "afmhot_r", "ai4g-lulc", "alos-fnf", "alos-palsar-mask", "autumn", "autumn_r", "binary",
         "binary_r", "blues", "blues_r", "bone", "bone_r", "brbg", "brbg_r", "brg", "brg_r", "bugn",
         "bugn_r", "bupu", "bupu_r", "bwr", "bwr_r", "c-cap", "cfastie", "chesapeake-lc-13",
         "chesapeake-lc-7", "chesapeake-lu", "chloris-biomass", "cividis", "cividis_r", "cmrmap",
         "cmrmap_r", "cool", "cool_r", "coolwarm", "coolwarm_r", "copper", "copper_r", "cubehelix",
         "cubehelix_r", "dark2", "dark2_r", "drcog-lulc", "esa-cci-lc", "esa-worldcover", "flag",
         "flag_r", "gap-lulc", "gist_earth", "gist_earth_r", "gist_gray", "gist_gray_r", "gist_heat",
         "gist_heat_r", "gist_ncar", "gist_ncar_r", "gist_rainbow", "gist_rainbow_r", "gist_stern",
         "gist_stern_r", "gist_yarg", "gist_yarg_r", "gnbu", "gnbu_r", "gnuplot", "gnuplot2",
         "gnuplot2_r", "gnuplot_r", "gray", "gray_r", "greens", "greens_r", "greys", "greys_r", "hot",
         "hot_r", "hsv", "hsv_r", "inferno", "inferno_r", "io-bii", "io-lulc", "io-lulc-9-class", "jet",
         "jet_r", "jrc-change", "jrc-extent", "jrc-occurrence", "jrc-recurrence", "jrc-seasonality",
         "jrc-transitions", "lidar-classification", "lidar-hag", "lidar-hag-alternative",
         "lidar-intensity", "lidar-returns", "magma", "magma_r", "modis-10A1", "modis-10A2",
         "modis-13A1|Q1", "modis-14A1|A2", "modis-15A2H|A3H", "modis-16A3GF-ET", "modis-16A3GF-PET",
         "modis-17A2H|A2HGF", "modis-17A3HGF", "modis-64A1", "mtbs-severity", "nipy_spectral",
         "nipy_spectral_r", "nrcan-lulc", "ocean", "ocean_r", "oranges", "oranges_r", "orrd", "orrd_r",
         "paired", "paired_r", "pastel1", "pastel1_r", "pastel2", "pastel2_r", "pink", "pink_r", "piyg",
         "piyg_r", "plasma", "plasma_r", "prgn", "prgn_r", "prism", "prism_r", "pubu", "pubu_r",
         "pubugn", "pubugn_r", "puor", "puor_r", "purd", "purd_r", "purples", "purples_r", "qpe",
         "rainbow", "rainbow_r", "rdbu", "rdbu_r", "rdgy", "rdgy_r", "rdpu", "rdpu_r", "rdylbu",
         "rdylbu_r", "rdylgn", "rdylgn_r", "reds", "reds_r", "rplumbo", "schwarzwald", "seismic",
         "seismic_r", "set1", "set1_r", "set2", "set2_r", "set3", "set3_r", "spectral", "spectral_r",
         "spring", "spring_r", "summer", "summer_r", "tab10", "tab10_r", "tab20", "tab20_r", "tab20b",
         "tab20b_r", "tab20c", "tab20c_r", "terrain", "terrain_r", "twilight", "twilight_r",
         "twilight_shifted", "twilight_shifted_r", "usda-cdl", "usda-cdl-corn", "usda-cdl-cotton",
         "usda-cdl-soybeans", "usda-cdl-wheat", "usgs-lcmap", "viirs-10a1", "viirs-13a1", "viirs-14a1",
         "viirs-15a2H", "viridis", "viridis_r", "winter", "winter_r", "wistia", "wistia_r", "ylgn",
         "ylgn_r", "ylgnbu", "ylgnbu_r", "ylorbr", "ylorbr_r", "ylorrd", and "ylorrd_r". Default value
         is None.
        :paramtype colormap_name: str or ~azure.planetarycomputer.models.ColorMapNames
        :keyword colormap: JSON encoded custom Colormap. Default value is None.
        :paramtype colormap: str
        :keyword return_mask: Add mask to the output data. Default value is None.
        :paramtype return_mask: bool
        :return: Iterator[bytes]
        :rtype: Iterator[bytes]
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[Iterator[bytes]] = kwargs.pop("cls", None)

        _request = build_tiler_parts_get_minx_miny_maxx_maxy_widthx_height_format_request(
            collection_id=collection_id,
            item_id=item_id,
            minx=minx,
            miny=miny,
            maxx=maxx,
            maxy=maxy,
            width=width,
            height=height,
            format=format,
            assets=assets,
            expression=expression,
            asset_bidx=asset_bidx,
            asset_as_band=asset_as_band,
            nodata=nodata,
            unscale=unscale,
            algorithm=algorithm,
            algorithm_params=algorithm_params,
            color_formula=color_formula,
            dst_crs=dst_crs,
            coord_crs=coord_crs,
            resampling=resampling,
            max_size=max_size,
            rescale=rescale,
            colormap_name=colormap_name,
            colormap=colormap,
            return_mask=return_mask,
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = kwargs.pop("stream", True)
        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                try:
                    response.read()  # Load the body in memory and close the socket
                except (StreamConsumedError, StreamClosedError):
                    pass
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        response_headers = {}
        response_headers["content-type"] = self._deserialize("str", response.headers.get("content-type"))
        response_headers["content-type"] = self._deserialize("str", response.headers.get("content-type"))
        response_headers["content-type"] = self._deserialize("str", response.headers.get("content-type"))
        response_headers["content-type"] = self._deserialize("str", response.headers.get("content-type"))
        response_headers["content-type"] = self._deserialize("str", response.headers.get("content-type"))
        response_headers["content-type"] = self._deserialize("str", response.headers.get("content-type"))
        response_headers["content-type"] = self._deserialize("str", response.headers.get("content-type"))

        deserialized = response.iter_bytes()

        if cls:
            return cls(pipeline_response, deserialized, response_headers)  # type: ignore

        return deserialized  # type: ignore

    @distributed_trace
    def get_minx_miny_maxx_maxy_format(
        self,
        collection_id: str,
        item_id: str,
        minx: float,
        miny: float,
        maxx: float,
        maxy: float,
        format: str,
        *,
        assets: Optional[List[str]] = None,
        expression: Optional[str] = None,
        asset_bidx: Optional[List[str]] = None,
        asset_as_band: Optional[bool] = None,
        nodata: Optional[float] = None,
        unscale: Optional[bool] = None,
        algorithm: Optional[Union[str, _models.Algorithm]] = None,
        algorithm_params: Optional[str] = None,
        color_formula: Optional[str] = None,
        dst_crs: Optional[str] = None,
        coord_crs: Optional[str] = None,
        resampling: Optional[Union[str, _models.Resampling]] = None,
        max_size: Optional[int] = None,
        height: Optional[int] = None,
        width: Optional[int] = None,
        rescale: Optional[List[str]] = None,
        colormap_name: Optional[Union[str, _models.ColorMapNames]] = None,
        colormap: Optional[str] = None,
        return_mask: Optional[bool] = None,
        **kwargs: Any,
    ) -> Iterator[bytes]:
        """Part.

        Create image from part of a dataset.

        :param collection_id: STAC Collection Identifier. Required.
        :type collection_id: str
        :param item_id: STAC Item Identifier. Required.
        :type item_id: str
        :param minx: Bounding box min X. Required.
        :type minx: float
        :param miny: Bounding box min Y. Required.
        :type miny: float
        :param maxx: Bounding box max X. Required.
        :type maxx: float
        :param maxy: Bounding box max Y. Required.
        :type maxy: float
        :param format: Output format for the tile or image (e.g., png, jpeg, webp). Required.
        :type format: str
        :keyword assets: Asset's names. Default value is None.
        :paramtype assets: list[str]
        :keyword expression: Band math expression between assets. Default value is None.
        :paramtype expression: str
        :keyword asset_bidx: Per asset band indexes (coma separated indexes). Default value is None.
        :paramtype asset_bidx: list[str]
        :keyword asset_as_band: Asset as Band. Default value is None.
        :paramtype asset_as_band: bool
        :keyword nodata: Overwrite internal Nodata value. Default value is None.
        :paramtype nodata: float
        :keyword unscale: Apply internal Scale or Offset. Default value is None.
        :paramtype unscale: bool
        :keyword algorithm: Algorithm name. Known values are: "hillshade", "contours",
         "normalizedIndex", "terrarium", and "terrainrgb". Default value is None.
        :paramtype algorithm: str or ~azure.planetarycomputer.models.Algorithm
        :keyword algorithm_params: Algorithm parameter. Default value is None.
        :paramtype algorithm_params: str
        :keyword color_formula: rio-color formula (info: `https://github.com/mapbox/rio-color
         <https://github.com/mapbox/rio-color>`_). Default value is None.
        :paramtype color_formula: str
        :keyword dst_crs: Output Coordinate Reference System. Default value is None.
        :paramtype dst_crs: str
        :keyword coord_crs: Coordinate Reference System of the input coords. Default to ``epsg:4326``.
         Default value is None.
        :paramtype coord_crs: str
        :keyword resampling: Resampling method. Known values are: "nearest", "bilinear", "cubic",
         "cubic_spline", "lanczos", "average", "mode", "gauss", and "rms". Default value is None.
        :paramtype resampling: str or ~azure.planetarycomputer.models.Resampling
        :keyword max_size: Image output size limit if width and height limits are not set. Default
         value is None.
        :paramtype max_size: int
        :keyword height: Height in pixels for the output image. Default value is None.
        :paramtype height: int
        :keyword width: Width in pixels for the output image. Default value is None.
        :paramtype width: int
        :keyword rescale: comma (',') delimited Min,Max range. Can set multiple time for multiple
         bands. Default value is None.
        :paramtype rescale: list[str]
        :keyword colormap_name: Colormap name. Known values are: "accent", "accent_r", "afmhot",
         "afmhot_r", "ai4g-lulc", "alos-fnf", "alos-palsar-mask", "autumn", "autumn_r", "binary",
         "binary_r", "blues", "blues_r", "bone", "bone_r", "brbg", "brbg_r", "brg", "brg_r", "bugn",
         "bugn_r", "bupu", "bupu_r", "bwr", "bwr_r", "c-cap", "cfastie", "chesapeake-lc-13",
         "chesapeake-lc-7", "chesapeake-lu", "chloris-biomass", "cividis", "cividis_r", "cmrmap",
         "cmrmap_r", "cool", "cool_r", "coolwarm", "coolwarm_r", "copper", "copper_r", "cubehelix",
         "cubehelix_r", "dark2", "dark2_r", "drcog-lulc", "esa-cci-lc", "esa-worldcover", "flag",
         "flag_r", "gap-lulc", "gist_earth", "gist_earth_r", "gist_gray", "gist_gray_r", "gist_heat",
         "gist_heat_r", "gist_ncar", "gist_ncar_r", "gist_rainbow", "gist_rainbow_r", "gist_stern",
         "gist_stern_r", "gist_yarg", "gist_yarg_r", "gnbu", "gnbu_r", "gnuplot", "gnuplot2",
         "gnuplot2_r", "gnuplot_r", "gray", "gray_r", "greens", "greens_r", "greys", "greys_r", "hot",
         "hot_r", "hsv", "hsv_r", "inferno", "inferno_r", "io-bii", "io-lulc", "io-lulc-9-class", "jet",
         "jet_r", "jrc-change", "jrc-extent", "jrc-occurrence", "jrc-recurrence", "jrc-seasonality",
         "jrc-transitions", "lidar-classification", "lidar-hag", "lidar-hag-alternative",
         "lidar-intensity", "lidar-returns", "magma", "magma_r", "modis-10A1", "modis-10A2",
         "modis-13A1|Q1", "modis-14A1|A2", "modis-15A2H|A3H", "modis-16A3GF-ET", "modis-16A3GF-PET",
         "modis-17A2H|A2HGF", "modis-17A3HGF", "modis-64A1", "mtbs-severity", "nipy_spectral",
         "nipy_spectral_r", "nrcan-lulc", "ocean", "ocean_r", "oranges", "oranges_r", "orrd", "orrd_r",
         "paired", "paired_r", "pastel1", "pastel1_r", "pastel2", "pastel2_r", "pink", "pink_r", "piyg",
         "piyg_r", "plasma", "plasma_r", "prgn", "prgn_r", "prism", "prism_r", "pubu", "pubu_r",
         "pubugn", "pubugn_r", "puor", "puor_r", "purd", "purd_r", "purples", "purples_r", "qpe",
         "rainbow", "rainbow_r", "rdbu", "rdbu_r", "rdgy", "rdgy_r", "rdpu", "rdpu_r", "rdylbu",
         "rdylbu_r", "rdylgn", "rdylgn_r", "reds", "reds_r", "rplumbo", "schwarzwald", "seismic",
         "seismic_r", "set1", "set1_r", "set2", "set2_r", "set3", "set3_r", "spectral", "spectral_r",
         "spring", "spring_r", "summer", "summer_r", "tab10", "tab10_r", "tab20", "tab20_r", "tab20b",
         "tab20b_r", "tab20c", "tab20c_r", "terrain", "terrain_r", "twilight", "twilight_r",
         "twilight_shifted", "twilight_shifted_r", "usda-cdl", "usda-cdl-corn", "usda-cdl-cotton",
         "usda-cdl-soybeans", "usda-cdl-wheat", "usgs-lcmap", "viirs-10a1", "viirs-13a1", "viirs-14a1",
         "viirs-15a2H", "viridis", "viridis_r", "winter", "winter_r", "wistia", "wistia_r", "ylgn",
         "ylgn_r", "ylgnbu", "ylgnbu_r", "ylorbr", "ylorbr_r", "ylorrd", and "ylorrd_r". Default value
         is None.
        :paramtype colormap_name: str or ~azure.planetarycomputer.models.ColorMapNames
        :keyword colormap: JSON encoded custom Colormap. Default value is None.
        :paramtype colormap: str
        :keyword return_mask: Add mask to the output data. Default value is None.
        :paramtype return_mask: bool
        :return: Iterator[bytes]
        :rtype: Iterator[bytes]
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[Iterator[bytes]] = kwargs.pop("cls", None)

        _request = build_tiler_parts_get_minx_miny_maxx_maxy_format_request(
            collection_id=collection_id,
            item_id=item_id,
            minx=minx,
            miny=miny,
            maxx=maxx,
            maxy=maxy,
            format=format,
            assets=assets,
            expression=expression,
            asset_bidx=asset_bidx,
            asset_as_band=asset_as_band,
            nodata=nodata,
            unscale=unscale,
            algorithm=algorithm,
            algorithm_params=algorithm_params,
            color_formula=color_formula,
            dst_crs=dst_crs,
            coord_crs=coord_crs,
            resampling=resampling,
            max_size=max_size,
            height=height,
            width=width,
            rescale=rescale,
            colormap_name=colormap_name,
            colormap=colormap,
            return_mask=return_mask,
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = kwargs.pop("stream", True)
        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                try:
                    response.read()  # Load the body in memory and close the socket
                except (StreamConsumedError, StreamClosedError):
                    pass
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        response_headers = {}
        response_headers["content-type"] = self._deserialize("str", response.headers.get("content-type"))
        response_headers["content-type"] = self._deserialize("str", response.headers.get("content-type"))
        response_headers["content-type"] = self._deserialize("str", response.headers.get("content-type"))
        response_headers["content-type"] = self._deserialize("str", response.headers.get("content-type"))
        response_headers["content-type"] = self._deserialize("str", response.headers.get("content-type"))
        response_headers["content-type"] = self._deserialize("str", response.headers.get("content-type"))
        response_headers["content-type"] = self._deserialize("str", response.headers.get("content-type"))

        deserialized = response.iter_bytes()

        if cls:
            return cls(pipeline_response, deserialized, response_headers)  # type: ignore

        return deserialized  # type: ignore


class TilerGeoJsonsOperations:
    """
    .. warning::
        **DO NOT** instantiate this class directly.

        Instead, you should access the following operations through
        :class:`~azure.planetarycomputer.PlanetaryComputerClient`'s
        :attr:`tiler_geo_jsons` attribute.
    """

    def __init__(self, *args, **kwargs) -> None:
        input_args = list(args)
        self._client: PipelineClient = input_args.pop(0) if input_args else kwargs.pop("client")
        self._config: PlanetaryComputerClientConfiguration = input_args.pop(0) if input_args else kwargs.pop("config")
        self._serialize: Serializer = input_args.pop(0) if input_args else kwargs.pop("serializer")
        self._deserialize: Deserializer = input_args.pop(0) if input_args else kwargs.pop("deserializer")

    @overload
    def crop_widthx_height_format(
        self,
        collection_id: str,
        item_id: str,
        width: float,
        height: float,
        format: str,
        body: _models.StacItem,
        *,
        assets: Optional[List[str]] = None,
        expression: Optional[str] = None,
        asset_bidx: Optional[List[str]] = None,
        asset_as_band: Optional[bool] = None,
        nodata: Optional[float] = None,
        unscale: Optional[bool] = None,
        algorithm: Optional[Union[str, _models.Algorithm]] = None,
        algorithm_params: Optional[str] = None,
        color_formula: Optional[str] = None,
        coord_crs: Optional[str] = None,
        resampling: Optional[Union[str, _models.Resampling]] = None,
        max_size: Optional[int] = None,
        rescale: Optional[List[str]] = None,
        colormap_name: Optional[Union[str, _models.ColorMapNames]] = None,
        colormap: Optional[str] = None,
        return_mask: Optional[bool] = None,
        content_type: str = "application/json",
        **kwargs: Any,
    ) -> Iterator[bytes]:
        """Geojson Crop.

        Create image from a geojson feature.

        :param collection_id: STAC Collection Identifier. Required.
        :type collection_id: str
        :param item_id: STAC Item Identifier. Required.
        :type item_id: str
        :param width: Width in pixels for the output image. Required.
        :type width: float
        :param height: Height in pixels for the output image. Required.
        :type height: float
        :param format: Output format for the tile or image (e.g., png, jpeg, webp). Required.
        :type format: str
        :param body: Request GeoJson body. Required.
        :type body: ~azure.planetarycomputer.models.StacItem
        :keyword assets: Asset's names. Default value is None.
        :paramtype assets: list[str]
        :keyword expression: Band math expression between assets. Default value is None.
        :paramtype expression: str
        :keyword asset_bidx: Per asset band indexes (coma separated indexes). Default value is None.
        :paramtype asset_bidx: list[str]
        :keyword asset_as_band: Asset as Band. Default value is None.
        :paramtype asset_as_band: bool
        :keyword nodata: Overwrite internal Nodata value. Default value is None.
        :paramtype nodata: float
        :keyword unscale: Apply internal Scale or Offset. Default value is None.
        :paramtype unscale: bool
        :keyword algorithm: Algorithm name. Known values are: "hillshade", "contours",
         "normalizedIndex", "terrarium", and "terrainrgb". Default value is None.
        :paramtype algorithm: str or ~azure.planetarycomputer.models.Algorithm
        :keyword algorithm_params: Algorithm parameter. Default value is None.
        :paramtype algorithm_params: str
        :keyword color_formula: rio-color formula (info: `https://github.com/mapbox/rio-color
         <https://github.com/mapbox/rio-color>`_). Default value is None.
        :paramtype color_formula: str
        :keyword coord_crs: Coordinate Reference System of the input coords. Default to ``epsg:4326``.
         Default value is None.
        :paramtype coord_crs: str
        :keyword resampling: Resampling method. Known values are: "nearest", "bilinear", "cubic",
         "cubic_spline", "lanczos", "average", "mode", "gauss", and "rms". Default value is None.
        :paramtype resampling: str or ~azure.planetarycomputer.models.Resampling
        :keyword max_size: Image output size limit if width and height limits are not set. Default
         value is None.
        :paramtype max_size: int
        :keyword rescale: comma (',') delimited Min,Max range. Can set multiple time for multiple
         bands. Default value is None.
        :paramtype rescale: list[str]
        :keyword colormap_name: Colormap name. Known values are: "accent", "accent_r", "afmhot",
         "afmhot_r", "ai4g-lulc", "alos-fnf", "alos-palsar-mask", "autumn", "autumn_r", "binary",
         "binary_r", "blues", "blues_r", "bone", "bone_r", "brbg", "brbg_r", "brg", "brg_r", "bugn",
         "bugn_r", "bupu", "bupu_r", "bwr", "bwr_r", "c-cap", "cfastie", "chesapeake-lc-13",
         "chesapeake-lc-7", "chesapeake-lu", "chloris-biomass", "cividis", "cividis_r", "cmrmap",
         "cmrmap_r", "cool", "cool_r", "coolwarm", "coolwarm_r", "copper", "copper_r", "cubehelix",
         "cubehelix_r", "dark2", "dark2_r", "drcog-lulc", "esa-cci-lc", "esa-worldcover", "flag",
         "flag_r", "gap-lulc", "gist_earth", "gist_earth_r", "gist_gray", "gist_gray_r", "gist_heat",
         "gist_heat_r", "gist_ncar", "gist_ncar_r", "gist_rainbow", "gist_rainbow_r", "gist_stern",
         "gist_stern_r", "gist_yarg", "gist_yarg_r", "gnbu", "gnbu_r", "gnuplot", "gnuplot2",
         "gnuplot2_r", "gnuplot_r", "gray", "gray_r", "greens", "greens_r", "greys", "greys_r", "hot",
         "hot_r", "hsv", "hsv_r", "inferno", "inferno_r", "io-bii", "io-lulc", "io-lulc-9-class", "jet",
         "jet_r", "jrc-change", "jrc-extent", "jrc-occurrence", "jrc-recurrence", "jrc-seasonality",
         "jrc-transitions", "lidar-classification", "lidar-hag", "lidar-hag-alternative",
         "lidar-intensity", "lidar-returns", "magma", "magma_r", "modis-10A1", "modis-10A2",
         "modis-13A1|Q1", "modis-14A1|A2", "modis-15A2H|A3H", "modis-16A3GF-ET", "modis-16A3GF-PET",
         "modis-17A2H|A2HGF", "modis-17A3HGF", "modis-64A1", "mtbs-severity", "nipy_spectral",
         "nipy_spectral_r", "nrcan-lulc", "ocean", "ocean_r", "oranges", "oranges_r", "orrd", "orrd_r",
         "paired", "paired_r", "pastel1", "pastel1_r", "pastel2", "pastel2_r", "pink", "pink_r", "piyg",
         "piyg_r", "plasma", "plasma_r", "prgn", "prgn_r", "prism", "prism_r", "pubu", "pubu_r",
         "pubugn", "pubugn_r", "puor", "puor_r", "purd", "purd_r", "purples", "purples_r", "qpe",
         "rainbow", "rainbow_r", "rdbu", "rdbu_r", "rdgy", "rdgy_r", "rdpu", "rdpu_r", "rdylbu",
         "rdylbu_r", "rdylgn", "rdylgn_r", "reds", "reds_r", "rplumbo", "schwarzwald", "seismic",
         "seismic_r", "set1", "set1_r", "set2", "set2_r", "set3", "set3_r", "spectral", "spectral_r",
         "spring", "spring_r", "summer", "summer_r", "tab10", "tab10_r", "tab20", "tab20_r", "tab20b",
         "tab20b_r", "tab20c", "tab20c_r", "terrain", "terrain_r", "twilight", "twilight_r",
         "twilight_shifted", "twilight_shifted_r", "usda-cdl", "usda-cdl-corn", "usda-cdl-cotton",
         "usda-cdl-soybeans", "usda-cdl-wheat", "usgs-lcmap", "viirs-10a1", "viirs-13a1", "viirs-14a1",
         "viirs-15a2H", "viridis", "viridis_r", "winter", "winter_r", "wistia", "wistia_r", "ylgn",
         "ylgn_r", "ylgnbu", "ylgnbu_r", "ylorbr", "ylorbr_r", "ylorrd", and "ylorrd_r". Default value
         is None.
        :paramtype colormap_name: str or ~azure.planetarycomputer.models.ColorMapNames
        :keyword colormap: JSON encoded custom Colormap. Default value is None.
        :paramtype colormap: str
        :keyword return_mask: Add mask to the output data. Default value is None.
        :paramtype return_mask: bool
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: Iterator[bytes]
        :rtype: Iterator[bytes]
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @overload
    def crop_widthx_height_format(
        self,
        collection_id: str,
        item_id: str,
        width: float,
        height: float,
        format: str,
        body: JSON,
        *,
        assets: Optional[List[str]] = None,
        expression: Optional[str] = None,
        asset_bidx: Optional[List[str]] = None,
        asset_as_band: Optional[bool] = None,
        nodata: Optional[float] = None,
        unscale: Optional[bool] = None,
        algorithm: Optional[Union[str, _models.Algorithm]] = None,
        algorithm_params: Optional[str] = None,
        color_formula: Optional[str] = None,
        coord_crs: Optional[str] = None,
        resampling: Optional[Union[str, _models.Resampling]] = None,
        max_size: Optional[int] = None,
        rescale: Optional[List[str]] = None,
        colormap_name: Optional[Union[str, _models.ColorMapNames]] = None,
        colormap: Optional[str] = None,
        return_mask: Optional[bool] = None,
        content_type: str = "application/json",
        **kwargs: Any,
    ) -> Iterator[bytes]:
        """Geojson Crop.

        Create image from a geojson feature.

        :param collection_id: STAC Collection Identifier. Required.
        :type collection_id: str
        :param item_id: STAC Item Identifier. Required.
        :type item_id: str
        :param width: Width in pixels for the output image. Required.
        :type width: float
        :param height: Height in pixels for the output image. Required.
        :type height: float
        :param format: Output format for the tile or image (e.g., png, jpeg, webp). Required.
        :type format: str
        :param body: Request GeoJson body. Required.
        :type body: JSON
        :keyword assets: Asset's names. Default value is None.
        :paramtype assets: list[str]
        :keyword expression: Band math expression between assets. Default value is None.
        :paramtype expression: str
        :keyword asset_bidx: Per asset band indexes (coma separated indexes). Default value is None.
        :paramtype asset_bidx: list[str]
        :keyword asset_as_band: Asset as Band. Default value is None.
        :paramtype asset_as_band: bool
        :keyword nodata: Overwrite internal Nodata value. Default value is None.
        :paramtype nodata: float
        :keyword unscale: Apply internal Scale or Offset. Default value is None.
        :paramtype unscale: bool
        :keyword algorithm: Algorithm name. Known values are: "hillshade", "contours",
         "normalizedIndex", "terrarium", and "terrainrgb". Default value is None.
        :paramtype algorithm: str or ~azure.planetarycomputer.models.Algorithm
        :keyword algorithm_params: Algorithm parameter. Default value is None.
        :paramtype algorithm_params: str
        :keyword color_formula: rio-color formula (info: `https://github.com/mapbox/rio-color
         <https://github.com/mapbox/rio-color>`_). Default value is None.
        :paramtype color_formula: str
        :keyword coord_crs: Coordinate Reference System of the input coords. Default to ``epsg:4326``.
         Default value is None.
        :paramtype coord_crs: str
        :keyword resampling: Resampling method. Known values are: "nearest", "bilinear", "cubic",
         "cubic_spline", "lanczos", "average", "mode", "gauss", and "rms". Default value is None.
        :paramtype resampling: str or ~azure.planetarycomputer.models.Resampling
        :keyword max_size: Image output size limit if width and height limits are not set. Default
         value is None.
        :paramtype max_size: int
        :keyword rescale: comma (',') delimited Min,Max range. Can set multiple time for multiple
         bands. Default value is None.
        :paramtype rescale: list[str]
        :keyword colormap_name: Colormap name. Known values are: "accent", "accent_r", "afmhot",
         "afmhot_r", "ai4g-lulc", "alos-fnf", "alos-palsar-mask", "autumn", "autumn_r", "binary",
         "binary_r", "blues", "blues_r", "bone", "bone_r", "brbg", "brbg_r", "brg", "brg_r", "bugn",
         "bugn_r", "bupu", "bupu_r", "bwr", "bwr_r", "c-cap", "cfastie", "chesapeake-lc-13",
         "chesapeake-lc-7", "chesapeake-lu", "chloris-biomass", "cividis", "cividis_r", "cmrmap",
         "cmrmap_r", "cool", "cool_r", "coolwarm", "coolwarm_r", "copper", "copper_r", "cubehelix",
         "cubehelix_r", "dark2", "dark2_r", "drcog-lulc", "esa-cci-lc", "esa-worldcover", "flag",
         "flag_r", "gap-lulc", "gist_earth", "gist_earth_r", "gist_gray", "gist_gray_r", "gist_heat",
         "gist_heat_r", "gist_ncar", "gist_ncar_r", "gist_rainbow", "gist_rainbow_r", "gist_stern",
         "gist_stern_r", "gist_yarg", "gist_yarg_r", "gnbu", "gnbu_r", "gnuplot", "gnuplot2",
         "gnuplot2_r", "gnuplot_r", "gray", "gray_r", "greens", "greens_r", "greys", "greys_r", "hot",
         "hot_r", "hsv", "hsv_r", "inferno", "inferno_r", "io-bii", "io-lulc", "io-lulc-9-class", "jet",
         "jet_r", "jrc-change", "jrc-extent", "jrc-occurrence", "jrc-recurrence", "jrc-seasonality",
         "jrc-transitions", "lidar-classification", "lidar-hag", "lidar-hag-alternative",
         "lidar-intensity", "lidar-returns", "magma", "magma_r", "modis-10A1", "modis-10A2",
         "modis-13A1|Q1", "modis-14A1|A2", "modis-15A2H|A3H", "modis-16A3GF-ET", "modis-16A3GF-PET",
         "modis-17A2H|A2HGF", "modis-17A3HGF", "modis-64A1", "mtbs-severity", "nipy_spectral",
         "nipy_spectral_r", "nrcan-lulc", "ocean", "ocean_r", "oranges", "oranges_r", "orrd", "orrd_r",
         "paired", "paired_r", "pastel1", "pastel1_r", "pastel2", "pastel2_r", "pink", "pink_r", "piyg",
         "piyg_r", "plasma", "plasma_r", "prgn", "prgn_r", "prism", "prism_r", "pubu", "pubu_r",
         "pubugn", "pubugn_r", "puor", "puor_r", "purd", "purd_r", "purples", "purples_r", "qpe",
         "rainbow", "rainbow_r", "rdbu", "rdbu_r", "rdgy", "rdgy_r", "rdpu", "rdpu_r", "rdylbu",
         "rdylbu_r", "rdylgn", "rdylgn_r", "reds", "reds_r", "rplumbo", "schwarzwald", "seismic",
         "seismic_r", "set1", "set1_r", "set2", "set2_r", "set3", "set3_r", "spectral", "spectral_r",
         "spring", "spring_r", "summer", "summer_r", "tab10", "tab10_r", "tab20", "tab20_r", "tab20b",
         "tab20b_r", "tab20c", "tab20c_r", "terrain", "terrain_r", "twilight", "twilight_r",
         "twilight_shifted", "twilight_shifted_r", "usda-cdl", "usda-cdl-corn", "usda-cdl-cotton",
         "usda-cdl-soybeans", "usda-cdl-wheat", "usgs-lcmap", "viirs-10a1", "viirs-13a1", "viirs-14a1",
         "viirs-15a2H", "viridis", "viridis_r", "winter", "winter_r", "wistia", "wistia_r", "ylgn",
         "ylgn_r", "ylgnbu", "ylgnbu_r", "ylorbr", "ylorbr_r", "ylorrd", and "ylorrd_r". Default value
         is None.
        :paramtype colormap_name: str or ~azure.planetarycomputer.models.ColorMapNames
        :keyword colormap: JSON encoded custom Colormap. Default value is None.
        :paramtype colormap: str
        :keyword return_mask: Add mask to the output data. Default value is None.
        :paramtype return_mask: bool
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: Iterator[bytes]
        :rtype: Iterator[bytes]
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @overload
    def crop_widthx_height_format(
        self,
        collection_id: str,
        item_id: str,
        width: float,
        height: float,
        format: str,
        body: IO[bytes],
        *,
        assets: Optional[List[str]] = None,
        expression: Optional[str] = None,
        asset_bidx: Optional[List[str]] = None,
        asset_as_band: Optional[bool] = None,
        nodata: Optional[float] = None,
        unscale: Optional[bool] = None,
        algorithm: Optional[Union[str, _models.Algorithm]] = None,
        algorithm_params: Optional[str] = None,
        color_formula: Optional[str] = None,
        coord_crs: Optional[str] = None,
        resampling: Optional[Union[str, _models.Resampling]] = None,
        max_size: Optional[int] = None,
        rescale: Optional[List[str]] = None,
        colormap_name: Optional[Union[str, _models.ColorMapNames]] = None,
        colormap: Optional[str] = None,
        return_mask: Optional[bool] = None,
        content_type: str = "application/json",
        **kwargs: Any,
    ) -> Iterator[bytes]:
        """Geojson Crop.

        Create image from a geojson feature.

        :param collection_id: STAC Collection Identifier. Required.
        :type collection_id: str
        :param item_id: STAC Item Identifier. Required.
        :type item_id: str
        :param width: Width in pixels for the output image. Required.
        :type width: float
        :param height: Height in pixels for the output image. Required.
        :type height: float
        :param format: Output format for the tile or image (e.g., png, jpeg, webp). Required.
        :type format: str
        :param body: Request GeoJson body. Required.
        :type body: IO[bytes]
        :keyword assets: Asset's names. Default value is None.
        :paramtype assets: list[str]
        :keyword expression: Band math expression between assets. Default value is None.
        :paramtype expression: str
        :keyword asset_bidx: Per asset band indexes (coma separated indexes). Default value is None.
        :paramtype asset_bidx: list[str]
        :keyword asset_as_band: Asset as Band. Default value is None.
        :paramtype asset_as_band: bool
        :keyword nodata: Overwrite internal Nodata value. Default value is None.
        :paramtype nodata: float
        :keyword unscale: Apply internal Scale or Offset. Default value is None.
        :paramtype unscale: bool
        :keyword algorithm: Algorithm name. Known values are: "hillshade", "contours",
         "normalizedIndex", "terrarium", and "terrainrgb". Default value is None.
        :paramtype algorithm: str or ~azure.planetarycomputer.models.Algorithm
        :keyword algorithm_params: Algorithm parameter. Default value is None.
        :paramtype algorithm_params: str
        :keyword color_formula: rio-color formula (info: `https://github.com/mapbox/rio-color
         <https://github.com/mapbox/rio-color>`_). Default value is None.
        :paramtype color_formula: str
        :keyword coord_crs: Coordinate Reference System of the input coords. Default to ``epsg:4326``.
         Default value is None.
        :paramtype coord_crs: str
        :keyword resampling: Resampling method. Known values are: "nearest", "bilinear", "cubic",
         "cubic_spline", "lanczos", "average", "mode", "gauss", and "rms". Default value is None.
        :paramtype resampling: str or ~azure.planetarycomputer.models.Resampling
        :keyword max_size: Image output size limit if width and height limits are not set. Default
         value is None.
        :paramtype max_size: int
        :keyword rescale: comma (',') delimited Min,Max range. Can set multiple time for multiple
         bands. Default value is None.
        :paramtype rescale: list[str]
        :keyword colormap_name: Colormap name. Known values are: "accent", "accent_r", "afmhot",
         "afmhot_r", "ai4g-lulc", "alos-fnf", "alos-palsar-mask", "autumn", "autumn_r", "binary",
         "binary_r", "blues", "blues_r", "bone", "bone_r", "brbg", "brbg_r", "brg", "brg_r", "bugn",
         "bugn_r", "bupu", "bupu_r", "bwr", "bwr_r", "c-cap", "cfastie", "chesapeake-lc-13",
         "chesapeake-lc-7", "chesapeake-lu", "chloris-biomass", "cividis", "cividis_r", "cmrmap",
         "cmrmap_r", "cool", "cool_r", "coolwarm", "coolwarm_r", "copper", "copper_r", "cubehelix",
         "cubehelix_r", "dark2", "dark2_r", "drcog-lulc", "esa-cci-lc", "esa-worldcover", "flag",
         "flag_r", "gap-lulc", "gist_earth", "gist_earth_r", "gist_gray", "gist_gray_r", "gist_heat",
         "gist_heat_r", "gist_ncar", "gist_ncar_r", "gist_rainbow", "gist_rainbow_r", "gist_stern",
         "gist_stern_r", "gist_yarg", "gist_yarg_r", "gnbu", "gnbu_r", "gnuplot", "gnuplot2",
         "gnuplot2_r", "gnuplot_r", "gray", "gray_r", "greens", "greens_r", "greys", "greys_r", "hot",
         "hot_r", "hsv", "hsv_r", "inferno", "inferno_r", "io-bii", "io-lulc", "io-lulc-9-class", "jet",
         "jet_r", "jrc-change", "jrc-extent", "jrc-occurrence", "jrc-recurrence", "jrc-seasonality",
         "jrc-transitions", "lidar-classification", "lidar-hag", "lidar-hag-alternative",
         "lidar-intensity", "lidar-returns", "magma", "magma_r", "modis-10A1", "modis-10A2",
         "modis-13A1|Q1", "modis-14A1|A2", "modis-15A2H|A3H", "modis-16A3GF-ET", "modis-16A3GF-PET",
         "modis-17A2H|A2HGF", "modis-17A3HGF", "modis-64A1", "mtbs-severity", "nipy_spectral",
         "nipy_spectral_r", "nrcan-lulc", "ocean", "ocean_r", "oranges", "oranges_r", "orrd", "orrd_r",
         "paired", "paired_r", "pastel1", "pastel1_r", "pastel2", "pastel2_r", "pink", "pink_r", "piyg",
         "piyg_r", "plasma", "plasma_r", "prgn", "prgn_r", "prism", "prism_r", "pubu", "pubu_r",
         "pubugn", "pubugn_r", "puor", "puor_r", "purd", "purd_r", "purples", "purples_r", "qpe",
         "rainbow", "rainbow_r", "rdbu", "rdbu_r", "rdgy", "rdgy_r", "rdpu", "rdpu_r", "rdylbu",
         "rdylbu_r", "rdylgn", "rdylgn_r", "reds", "reds_r", "rplumbo", "schwarzwald", "seismic",
         "seismic_r", "set1", "set1_r", "set2", "set2_r", "set3", "set3_r", "spectral", "spectral_r",
         "spring", "spring_r", "summer", "summer_r", "tab10", "tab10_r", "tab20", "tab20_r", "tab20b",
         "tab20b_r", "tab20c", "tab20c_r", "terrain", "terrain_r", "twilight", "twilight_r",
         "twilight_shifted", "twilight_shifted_r", "usda-cdl", "usda-cdl-corn", "usda-cdl-cotton",
         "usda-cdl-soybeans", "usda-cdl-wheat", "usgs-lcmap", "viirs-10a1", "viirs-13a1", "viirs-14a1",
         "viirs-15a2H", "viridis", "viridis_r", "winter", "winter_r", "wistia", "wistia_r", "ylgn",
         "ylgn_r", "ylgnbu", "ylgnbu_r", "ylorbr", "ylorbr_r", "ylorrd", and "ylorrd_r". Default value
         is None.
        :paramtype colormap_name: str or ~azure.planetarycomputer.models.ColorMapNames
        :keyword colormap: JSON encoded custom Colormap. Default value is None.
        :paramtype colormap: str
        :keyword return_mask: Add mask to the output data. Default value is None.
        :paramtype return_mask: bool
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: Iterator[bytes]
        :rtype: Iterator[bytes]
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @distributed_trace
    def crop_widthx_height_format(
        self,
        collection_id: str,
        item_id: str,
        width: float,
        height: float,
        format: str,
        body: Union[_models.StacItem, JSON, IO[bytes]],
        *,
        assets: Optional[List[str]] = None,
        expression: Optional[str] = None,
        asset_bidx: Optional[List[str]] = None,
        asset_as_band: Optional[bool] = None,
        nodata: Optional[float] = None,
        unscale: Optional[bool] = None,
        algorithm: Optional[Union[str, _models.Algorithm]] = None,
        algorithm_params: Optional[str] = None,
        color_formula: Optional[str] = None,
        coord_crs: Optional[str] = None,
        resampling: Optional[Union[str, _models.Resampling]] = None,
        max_size: Optional[int] = None,
        rescale: Optional[List[str]] = None,
        colormap_name: Optional[Union[str, _models.ColorMapNames]] = None,
        colormap: Optional[str] = None,
        return_mask: Optional[bool] = None,
        **kwargs: Any,
    ) -> Iterator[bytes]:
        """Geojson Crop.

        Create image from a geojson feature.

        :param collection_id: STAC Collection Identifier. Required.
        :type collection_id: str
        :param item_id: STAC Item Identifier. Required.
        :type item_id: str
        :param width: Width in pixels for the output image. Required.
        :type width: float
        :param height: Height in pixels for the output image. Required.
        :type height: float
        :param format: Output format for the tile or image (e.g., png, jpeg, webp). Required.
        :type format: str
        :param body: Request GeoJson body. Is one of the following types: StacItem, JSON, IO[bytes]
         Required.
        :type body: ~azure.planetarycomputer.models.StacItem or JSON or IO[bytes]
        :keyword assets: Asset's names. Default value is None.
        :paramtype assets: list[str]
        :keyword expression: Band math expression between assets. Default value is None.
        :paramtype expression: str
        :keyword asset_bidx: Per asset band indexes (coma separated indexes). Default value is None.
        :paramtype asset_bidx: list[str]
        :keyword asset_as_band: Asset as Band. Default value is None.
        :paramtype asset_as_band: bool
        :keyword nodata: Overwrite internal Nodata value. Default value is None.
        :paramtype nodata: float
        :keyword unscale: Apply internal Scale or Offset. Default value is None.
        :paramtype unscale: bool
        :keyword algorithm: Algorithm name. Known values are: "hillshade", "contours",
         "normalizedIndex", "terrarium", and "terrainrgb". Default value is None.
        :paramtype algorithm: str or ~azure.planetarycomputer.models.Algorithm
        :keyword algorithm_params: Algorithm parameter. Default value is None.
        :paramtype algorithm_params: str
        :keyword color_formula: rio-color formula (info: `https://github.com/mapbox/rio-color
         <https://github.com/mapbox/rio-color>`_). Default value is None.
        :paramtype color_formula: str
        :keyword coord_crs: Coordinate Reference System of the input coords. Default to ``epsg:4326``.
         Default value is None.
        :paramtype coord_crs: str
        :keyword resampling: Resampling method. Known values are: "nearest", "bilinear", "cubic",
         "cubic_spline", "lanczos", "average", "mode", "gauss", and "rms". Default value is None.
        :paramtype resampling: str or ~azure.planetarycomputer.models.Resampling
        :keyword max_size: Image output size limit if width and height limits are not set. Default
         value is None.
        :paramtype max_size: int
        :keyword rescale: comma (',') delimited Min,Max range. Can set multiple time for multiple
         bands. Default value is None.
        :paramtype rescale: list[str]
        :keyword colormap_name: Colormap name. Known values are: "accent", "accent_r", "afmhot",
         "afmhot_r", "ai4g-lulc", "alos-fnf", "alos-palsar-mask", "autumn", "autumn_r", "binary",
         "binary_r", "blues", "blues_r", "bone", "bone_r", "brbg", "brbg_r", "brg", "brg_r", "bugn",
         "bugn_r", "bupu", "bupu_r", "bwr", "bwr_r", "c-cap", "cfastie", "chesapeake-lc-13",
         "chesapeake-lc-7", "chesapeake-lu", "chloris-biomass", "cividis", "cividis_r", "cmrmap",
         "cmrmap_r", "cool", "cool_r", "coolwarm", "coolwarm_r", "copper", "copper_r", "cubehelix",
         "cubehelix_r", "dark2", "dark2_r", "drcog-lulc", "esa-cci-lc", "esa-worldcover", "flag",
         "flag_r", "gap-lulc", "gist_earth", "gist_earth_r", "gist_gray", "gist_gray_r", "gist_heat",
         "gist_heat_r", "gist_ncar", "gist_ncar_r", "gist_rainbow", "gist_rainbow_r", "gist_stern",
         "gist_stern_r", "gist_yarg", "gist_yarg_r", "gnbu", "gnbu_r", "gnuplot", "gnuplot2",
         "gnuplot2_r", "gnuplot_r", "gray", "gray_r", "greens", "greens_r", "greys", "greys_r", "hot",
         "hot_r", "hsv", "hsv_r", "inferno", "inferno_r", "io-bii", "io-lulc", "io-lulc-9-class", "jet",
         "jet_r", "jrc-change", "jrc-extent", "jrc-occurrence", "jrc-recurrence", "jrc-seasonality",
         "jrc-transitions", "lidar-classification", "lidar-hag", "lidar-hag-alternative",
         "lidar-intensity", "lidar-returns", "magma", "magma_r", "modis-10A1", "modis-10A2",
         "modis-13A1|Q1", "modis-14A1|A2", "modis-15A2H|A3H", "modis-16A3GF-ET", "modis-16A3GF-PET",
         "modis-17A2H|A2HGF", "modis-17A3HGF", "modis-64A1", "mtbs-severity", "nipy_spectral",
         "nipy_spectral_r", "nrcan-lulc", "ocean", "ocean_r", "oranges", "oranges_r", "orrd", "orrd_r",
         "paired", "paired_r", "pastel1", "pastel1_r", "pastel2", "pastel2_r", "pink", "pink_r", "piyg",
         "piyg_r", "plasma", "plasma_r", "prgn", "prgn_r", "prism", "prism_r", "pubu", "pubu_r",
         "pubugn", "pubugn_r", "puor", "puor_r", "purd", "purd_r", "purples", "purples_r", "qpe",
         "rainbow", "rainbow_r", "rdbu", "rdbu_r", "rdgy", "rdgy_r", "rdpu", "rdpu_r", "rdylbu",
         "rdylbu_r", "rdylgn", "rdylgn_r", "reds", "reds_r", "rplumbo", "schwarzwald", "seismic",
         "seismic_r", "set1", "set1_r", "set2", "set2_r", "set3", "set3_r", "spectral", "spectral_r",
         "spring", "spring_r", "summer", "summer_r", "tab10", "tab10_r", "tab20", "tab20_r", "tab20b",
         "tab20b_r", "tab20c", "tab20c_r", "terrain", "terrain_r", "twilight", "twilight_r",
         "twilight_shifted", "twilight_shifted_r", "usda-cdl", "usda-cdl-corn", "usda-cdl-cotton",
         "usda-cdl-soybeans", "usda-cdl-wheat", "usgs-lcmap", "viirs-10a1", "viirs-13a1", "viirs-14a1",
         "viirs-15a2H", "viridis", "viridis_r", "winter", "winter_r", "wistia", "wistia_r", "ylgn",
         "ylgn_r", "ylgnbu", "ylgnbu_r", "ylorbr", "ylorbr_r", "ylorrd", and "ylorrd_r". Default value
         is None.
        :paramtype colormap_name: str or ~azure.planetarycomputer.models.ColorMapNames
        :keyword colormap: JSON encoded custom Colormap. Default value is None.
        :paramtype colormap: str
        :keyword return_mask: Add mask to the output data. Default value is None.
        :paramtype return_mask: bool
        :return: Iterator[bytes]
        :rtype: Iterator[bytes]
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[Iterator[bytes]] = kwargs.pop("cls", None)

        content_type = content_type or "application/json"
        _content = None
        if isinstance(body, (IOBase, bytes)):
            _content = body
        else:
            _content = json.dumps(body, cls=SdkJSONEncoder, exclude_readonly=True)  # type: ignore

        _request = build_tiler_geo_jsons_crop_widthx_height_format_request(
            collection_id=collection_id,
            item_id=item_id,
            width=width,
            height=height,
            format=format,
            assets=assets,
            expression=expression,
            asset_bidx=asset_bidx,
            asset_as_band=asset_as_band,
            nodata=nodata,
            unscale=unscale,
            algorithm=algorithm,
            algorithm_params=algorithm_params,
            color_formula=color_formula,
            coord_crs=coord_crs,
            resampling=resampling,
            max_size=max_size,
            rescale=rescale,
            colormap_name=colormap_name,
            colormap=colormap,
            return_mask=return_mask,
            content_type=content_type,
            api_version=self._config.api_version,
            content=_content,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = kwargs.pop("stream", True)
        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                try:
                    response.read()  # Load the body in memory and close the socket
                except (StreamConsumedError, StreamClosedError):
                    pass
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        response_headers = {}
        response_headers["content-type"] = self._deserialize("str", response.headers.get("content-type"))
        response_headers["content-type"] = self._deserialize("str", response.headers.get("content-type"))
        response_headers["content-type"] = self._deserialize("str", response.headers.get("content-type"))
        response_headers["content-type"] = self._deserialize("str", response.headers.get("content-type"))
        response_headers["content-type"] = self._deserialize("str", response.headers.get("content-type"))
        response_headers["content-type"] = self._deserialize("str", response.headers.get("content-type"))
        response_headers["content-type"] = self._deserialize("str", response.headers.get("content-type"))

        deserialized = response.iter_bytes()

        if cls:
            return cls(pipeline_response, deserialized, response_headers)  # type: ignore

        return deserialized  # type: ignore

    @overload
    def crop_format(
        self,
        collection_id: str,
        item_id: str,
        format: str,
        body: _models.Geometry,
        *,
        assets: Optional[List[str]] = None,
        expression: Optional[str] = None,
        asset_bidx: Optional[List[str]] = None,
        asset_as_band: Optional[bool] = None,
        nodata: Optional[float] = None,
        unscale: Optional[bool] = None,
        algorithm: Optional[Union[str, _models.Algorithm]] = None,
        algorithm_params: Optional[str] = None,
        color_formula: Optional[str] = None,
        coord_crs: Optional[str] = None,
        resampling: Optional[Union[str, _models.Resampling]] = None,
        max_size: Optional[int] = None,
        height: Optional[int] = None,
        width: Optional[int] = None,
        rescale: Optional[List[str]] = None,
        colormap_name: Optional[Union[str, _models.ColorMapNames]] = None,
        colormap: Optional[str] = None,
        return_mask: Optional[bool] = None,
        content_type: str = "application/json",
        **kwargs: Any,
    ) -> Iterator[bytes]:
        """Geojson Crop.

        Create image from a geojson feature.

        :param collection_id: STAC Collection Identifier. Required.
        :type collection_id: str
        :param item_id: STAC Item Identifier. Required.
        :type item_id: str
        :param format: Output format for the tile or image (e.g., png, jpeg, webp) (default: "png").
         Required.
        :type format: str
        :param body: Request GeoJson body. Required.
        :type body: ~azure.planetarycomputer.models.Geometry
        :keyword assets: Asset's names. Default value is None.
        :paramtype assets: list[str]
        :keyword expression: Band math expression between assets. Default value is None.
        :paramtype expression: str
        :keyword asset_bidx: Per asset band indexes (coma separated indexes). Default value is None.
        :paramtype asset_bidx: list[str]
        :keyword asset_as_band: Asset as Band. Default value is None.
        :paramtype asset_as_band: bool
        :keyword nodata: Overwrite internal Nodata value. Default value is None.
        :paramtype nodata: float
        :keyword unscale: Apply internal Scale or Offset. Default value is None.
        :paramtype unscale: bool
        :keyword algorithm: Algorithm name. Known values are: "hillshade", "contours",
         "normalizedIndex", "terrarium", and "terrainrgb". Default value is None.
        :paramtype algorithm: str or ~azure.planetarycomputer.models.Algorithm
        :keyword algorithm_params: Algorithm parameter. Default value is None.
        :paramtype algorithm_params: str
        :keyword color_formula: rio-color formula (info: `https://github.com/mapbox/rio-color
         <https://github.com/mapbox/rio-color>`_). Default value is None.
        :paramtype color_formula: str
        :keyword coord_crs: Coordinate Reference System of the input coords. Default to ``epsg:4326``.
         Default value is None.
        :paramtype coord_crs: str
        :keyword resampling: Resampling method. Known values are: "nearest", "bilinear", "cubic",
         "cubic_spline", "lanczos", "average", "mode", "gauss", and "rms". Default value is None.
        :paramtype resampling: str or ~azure.planetarycomputer.models.Resampling
        :keyword max_size: Image output size limit if width and height limits are not set. Default
         value is None.
        :paramtype max_size: int
        :keyword height: Height in pixels for the output image. Default value is None.
        :paramtype height: int
        :keyword width: Width in pixels for the output image. Default value is None.
        :paramtype width: int
        :keyword rescale: comma (',') delimited Min,Max range. Can set multiple time for multiple
         bands. Default value is None.
        :paramtype rescale: list[str]
        :keyword colormap_name: Colormap name. Known values are: "accent", "accent_r", "afmhot",
         "afmhot_r", "ai4g-lulc", "alos-fnf", "alos-palsar-mask", "autumn", "autumn_r", "binary",
         "binary_r", "blues", "blues_r", "bone", "bone_r", "brbg", "brbg_r", "brg", "brg_r", "bugn",
         "bugn_r", "bupu", "bupu_r", "bwr", "bwr_r", "c-cap", "cfastie", "chesapeake-lc-13",
         "chesapeake-lc-7", "chesapeake-lu", "chloris-biomass", "cividis", "cividis_r", "cmrmap",
         "cmrmap_r", "cool", "cool_r", "coolwarm", "coolwarm_r", "copper", "copper_r", "cubehelix",
         "cubehelix_r", "dark2", "dark2_r", "drcog-lulc", "esa-cci-lc", "esa-worldcover", "flag",
         "flag_r", "gap-lulc", "gist_earth", "gist_earth_r", "gist_gray", "gist_gray_r", "gist_heat",
         "gist_heat_r", "gist_ncar", "gist_ncar_r", "gist_rainbow", "gist_rainbow_r", "gist_stern",
         "gist_stern_r", "gist_yarg", "gist_yarg_r", "gnbu", "gnbu_r", "gnuplot", "gnuplot2",
         "gnuplot2_r", "gnuplot_r", "gray", "gray_r", "greens", "greens_r", "greys", "greys_r", "hot",
         "hot_r", "hsv", "hsv_r", "inferno", "inferno_r", "io-bii", "io-lulc", "io-lulc-9-class", "jet",
         "jet_r", "jrc-change", "jrc-extent", "jrc-occurrence", "jrc-recurrence", "jrc-seasonality",
         "jrc-transitions", "lidar-classification", "lidar-hag", "lidar-hag-alternative",
         "lidar-intensity", "lidar-returns", "magma", "magma_r", "modis-10A1", "modis-10A2",
         "modis-13A1|Q1", "modis-14A1|A2", "modis-15A2H|A3H", "modis-16A3GF-ET", "modis-16A3GF-PET",
         "modis-17A2H|A2HGF", "modis-17A3HGF", "modis-64A1", "mtbs-severity", "nipy_spectral",
         "nipy_spectral_r", "nrcan-lulc", "ocean", "ocean_r", "oranges", "oranges_r", "orrd", "orrd_r",
         "paired", "paired_r", "pastel1", "pastel1_r", "pastel2", "pastel2_r", "pink", "pink_r", "piyg",
         "piyg_r", "plasma", "plasma_r", "prgn", "prgn_r", "prism", "prism_r", "pubu", "pubu_r",
         "pubugn", "pubugn_r", "puor", "puor_r", "purd", "purd_r", "purples", "purples_r", "qpe",
         "rainbow", "rainbow_r", "rdbu", "rdbu_r", "rdgy", "rdgy_r", "rdpu", "rdpu_r", "rdylbu",
         "rdylbu_r", "rdylgn", "rdylgn_r", "reds", "reds_r", "rplumbo", "schwarzwald", "seismic",
         "seismic_r", "set1", "set1_r", "set2", "set2_r", "set3", "set3_r", "spectral", "spectral_r",
         "spring", "spring_r", "summer", "summer_r", "tab10", "tab10_r", "tab20", "tab20_r", "tab20b",
         "tab20b_r", "tab20c", "tab20c_r", "terrain", "terrain_r", "twilight", "twilight_r",
         "twilight_shifted", "twilight_shifted_r", "usda-cdl", "usda-cdl-corn", "usda-cdl-cotton",
         "usda-cdl-soybeans", "usda-cdl-wheat", "usgs-lcmap", "viirs-10a1", "viirs-13a1", "viirs-14a1",
         "viirs-15a2H", "viridis", "viridis_r", "winter", "winter_r", "wistia", "wistia_r", "ylgn",
         "ylgn_r", "ylgnbu", "ylgnbu_r", "ylorbr", "ylorbr_r", "ylorrd", and "ylorrd_r". Default value
         is None.
        :paramtype colormap_name: str or ~azure.planetarycomputer.models.ColorMapNames
        :keyword colormap: JSON encoded custom Colormap. Default value is None.
        :paramtype colormap: str
        :keyword return_mask: Add mask to the output data. Default value is None.
        :paramtype return_mask: bool
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: Iterator[bytes]
        :rtype: Iterator[bytes]
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @overload
    def crop_format(
        self,
        collection_id: str,
        item_id: str,
        format: str,
        body: JSON,
        *,
        assets: Optional[List[str]] = None,
        expression: Optional[str] = None,
        asset_bidx: Optional[List[str]] = None,
        asset_as_band: Optional[bool] = None,
        nodata: Optional[float] = None,
        unscale: Optional[bool] = None,
        algorithm: Optional[Union[str, _models.Algorithm]] = None,
        algorithm_params: Optional[str] = None,
        color_formula: Optional[str] = None,
        coord_crs: Optional[str] = None,
        resampling: Optional[Union[str, _models.Resampling]] = None,
        max_size: Optional[int] = None,
        height: Optional[int] = None,
        width: Optional[int] = None,
        rescale: Optional[List[str]] = None,
        colormap_name: Optional[Union[str, _models.ColorMapNames]] = None,
        colormap: Optional[str] = None,
        return_mask: Optional[bool] = None,
        content_type: str = "application/json",
        **kwargs: Any,
    ) -> Iterator[bytes]:
        """Geojson Crop.

        Create image from a geojson feature.

        :param collection_id: STAC Collection Identifier. Required.
        :type collection_id: str
        :param item_id: STAC Item Identifier. Required.
        :type item_id: str
        :param format: Output format for the tile or image (e.g., png, jpeg, webp) (default: "png").
         Required.
        :type format: str
        :param body: Request GeoJson body. Required.
        :type body: JSON
        :keyword assets: Asset's names. Default value is None.
        :paramtype assets: list[str]
        :keyword expression: Band math expression between assets. Default value is None.
        :paramtype expression: str
        :keyword asset_bidx: Per asset band indexes (coma separated indexes). Default value is None.
        :paramtype asset_bidx: list[str]
        :keyword asset_as_band: Asset as Band. Default value is None.
        :paramtype asset_as_band: bool
        :keyword nodata: Overwrite internal Nodata value. Default value is None.
        :paramtype nodata: float
        :keyword unscale: Apply internal Scale or Offset. Default value is None.
        :paramtype unscale: bool
        :keyword algorithm: Algorithm name. Known values are: "hillshade", "contours",
         "normalizedIndex", "terrarium", and "terrainrgb". Default value is None.
        :paramtype algorithm: str or ~azure.planetarycomputer.models.Algorithm
        :keyword algorithm_params: Algorithm parameter. Default value is None.
        :paramtype algorithm_params: str
        :keyword color_formula: rio-color formula (info: `https://github.com/mapbox/rio-color
         <https://github.com/mapbox/rio-color>`_). Default value is None.
        :paramtype color_formula: str
        :keyword coord_crs: Coordinate Reference System of the input coords. Default to ``epsg:4326``.
         Default value is None.
        :paramtype coord_crs: str
        :keyword resampling: Resampling method. Known values are: "nearest", "bilinear", "cubic",
         "cubic_spline", "lanczos", "average", "mode", "gauss", and "rms". Default value is None.
        :paramtype resampling: str or ~azure.planetarycomputer.models.Resampling
        :keyword max_size: Image output size limit if width and height limits are not set. Default
         value is None.
        :paramtype max_size: int
        :keyword height: Height in pixels for the output image. Default value is None.
        :paramtype height: int
        :keyword width: Width in pixels for the output image. Default value is None.
        :paramtype width: int
        :keyword rescale: comma (',') delimited Min,Max range. Can set multiple time for multiple
         bands. Default value is None.
        :paramtype rescale: list[str]
        :keyword colormap_name: Colormap name. Known values are: "accent", "accent_r", "afmhot",
         "afmhot_r", "ai4g-lulc", "alos-fnf", "alos-palsar-mask", "autumn", "autumn_r", "binary",
         "binary_r", "blues", "blues_r", "bone", "bone_r", "brbg", "brbg_r", "brg", "brg_r", "bugn",
         "bugn_r", "bupu", "bupu_r", "bwr", "bwr_r", "c-cap", "cfastie", "chesapeake-lc-13",
         "chesapeake-lc-7", "chesapeake-lu", "chloris-biomass", "cividis", "cividis_r", "cmrmap",
         "cmrmap_r", "cool", "cool_r", "coolwarm", "coolwarm_r", "copper", "copper_r", "cubehelix",
         "cubehelix_r", "dark2", "dark2_r", "drcog-lulc", "esa-cci-lc", "esa-worldcover", "flag",
         "flag_r", "gap-lulc", "gist_earth", "gist_earth_r", "gist_gray", "gist_gray_r", "gist_heat",
         "gist_heat_r", "gist_ncar", "gist_ncar_r", "gist_rainbow", "gist_rainbow_r", "gist_stern",
         "gist_stern_r", "gist_yarg", "gist_yarg_r", "gnbu", "gnbu_r", "gnuplot", "gnuplot2",
         "gnuplot2_r", "gnuplot_r", "gray", "gray_r", "greens", "greens_r", "greys", "greys_r", "hot",
         "hot_r", "hsv", "hsv_r", "inferno", "inferno_r", "io-bii", "io-lulc", "io-lulc-9-class", "jet",
         "jet_r", "jrc-change", "jrc-extent", "jrc-occurrence", "jrc-recurrence", "jrc-seasonality",
         "jrc-transitions", "lidar-classification", "lidar-hag", "lidar-hag-alternative",
         "lidar-intensity", "lidar-returns", "magma", "magma_r", "modis-10A1", "modis-10A2",
         "modis-13A1|Q1", "modis-14A1|A2", "modis-15A2H|A3H", "modis-16A3GF-ET", "modis-16A3GF-PET",
         "modis-17A2H|A2HGF", "modis-17A3HGF", "modis-64A1", "mtbs-severity", "nipy_spectral",
         "nipy_spectral_r", "nrcan-lulc", "ocean", "ocean_r", "oranges", "oranges_r", "orrd", "orrd_r",
         "paired", "paired_r", "pastel1", "pastel1_r", "pastel2", "pastel2_r", "pink", "pink_r", "piyg",
         "piyg_r", "plasma", "plasma_r", "prgn", "prgn_r", "prism", "prism_r", "pubu", "pubu_r",
         "pubugn", "pubugn_r", "puor", "puor_r", "purd", "purd_r", "purples", "purples_r", "qpe",
         "rainbow", "rainbow_r", "rdbu", "rdbu_r", "rdgy", "rdgy_r", "rdpu", "rdpu_r", "rdylbu",
         "rdylbu_r", "rdylgn", "rdylgn_r", "reds", "reds_r", "rplumbo", "schwarzwald", "seismic",
         "seismic_r", "set1", "set1_r", "set2", "set2_r", "set3", "set3_r", "spectral", "spectral_r",
         "spring", "spring_r", "summer", "summer_r", "tab10", "tab10_r", "tab20", "tab20_r", "tab20b",
         "tab20b_r", "tab20c", "tab20c_r", "terrain", "terrain_r", "twilight", "twilight_r",
         "twilight_shifted", "twilight_shifted_r", "usda-cdl", "usda-cdl-corn", "usda-cdl-cotton",
         "usda-cdl-soybeans", "usda-cdl-wheat", "usgs-lcmap", "viirs-10a1", "viirs-13a1", "viirs-14a1",
         "viirs-15a2H", "viridis", "viridis_r", "winter", "winter_r", "wistia", "wistia_r", "ylgn",
         "ylgn_r", "ylgnbu", "ylgnbu_r", "ylorbr", "ylorbr_r", "ylorrd", and "ylorrd_r". Default value
         is None.
        :paramtype colormap_name: str or ~azure.planetarycomputer.models.ColorMapNames
        :keyword colormap: JSON encoded custom Colormap. Default value is None.
        :paramtype colormap: str
        :keyword return_mask: Add mask to the output data. Default value is None.
        :paramtype return_mask: bool
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: Iterator[bytes]
        :rtype: Iterator[bytes]
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @overload
    def crop_format(
        self,
        collection_id: str,
        item_id: str,
        format: str,
        body: IO[bytes],
        *,
        assets: Optional[List[str]] = None,
        expression: Optional[str] = None,
        asset_bidx: Optional[List[str]] = None,
        asset_as_band: Optional[bool] = None,
        nodata: Optional[float] = None,
        unscale: Optional[bool] = None,
        algorithm: Optional[Union[str, _models.Algorithm]] = None,
        algorithm_params: Optional[str] = None,
        color_formula: Optional[str] = None,
        coord_crs: Optional[str] = None,
        resampling: Optional[Union[str, _models.Resampling]] = None,
        max_size: Optional[int] = None,
        height: Optional[int] = None,
        width: Optional[int] = None,
        rescale: Optional[List[str]] = None,
        colormap_name: Optional[Union[str, _models.ColorMapNames]] = None,
        colormap: Optional[str] = None,
        return_mask: Optional[bool] = None,
        content_type: str = "application/json",
        **kwargs: Any,
    ) -> Iterator[bytes]:
        """Geojson Crop.

        Create image from a geojson feature.

        :param collection_id: STAC Collection Identifier. Required.
        :type collection_id: str
        :param item_id: STAC Item Identifier. Required.
        :type item_id: str
        :param format: Output format for the tile or image (e.g., png, jpeg, webp) (default: "png").
         Required.
        :type format: str
        :param body: Request GeoJson body. Required.
        :type body: IO[bytes]
        :keyword assets: Asset's names. Default value is None.
        :paramtype assets: list[str]
        :keyword expression: Band math expression between assets. Default value is None.
        :paramtype expression: str
        :keyword asset_bidx: Per asset band indexes (coma separated indexes). Default value is None.
        :paramtype asset_bidx: list[str]
        :keyword asset_as_band: Asset as Band. Default value is None.
        :paramtype asset_as_band: bool
        :keyword nodata: Overwrite internal Nodata value. Default value is None.
        :paramtype nodata: float
        :keyword unscale: Apply internal Scale or Offset. Default value is None.
        :paramtype unscale: bool
        :keyword algorithm: Algorithm name. Known values are: "hillshade", "contours",
         "normalizedIndex", "terrarium", and "terrainrgb". Default value is None.
        :paramtype algorithm: str or ~azure.planetarycomputer.models.Algorithm
        :keyword algorithm_params: Algorithm parameter. Default value is None.
        :paramtype algorithm_params: str
        :keyword color_formula: rio-color formula (info: `https://github.com/mapbox/rio-color
         <https://github.com/mapbox/rio-color>`_). Default value is None.
        :paramtype color_formula: str
        :keyword coord_crs: Coordinate Reference System of the input coords. Default to ``epsg:4326``.
         Default value is None.
        :paramtype coord_crs: str
        :keyword resampling: Resampling method. Known values are: "nearest", "bilinear", "cubic",
         "cubic_spline", "lanczos", "average", "mode", "gauss", and "rms". Default value is None.
        :paramtype resampling: str or ~azure.planetarycomputer.models.Resampling
        :keyword max_size: Image output size limit if width and height limits are not set. Default
         value is None.
        :paramtype max_size: int
        :keyword height: Height in pixels for the output image. Default value is None.
        :paramtype height: int
        :keyword width: Width in pixels for the output image. Default value is None.
        :paramtype width: int
        :keyword rescale: comma (',') delimited Min,Max range. Can set multiple time for multiple
         bands. Default value is None.
        :paramtype rescale: list[str]
        :keyword colormap_name: Colormap name. Known values are: "accent", "accent_r", "afmhot",
         "afmhot_r", "ai4g-lulc", "alos-fnf", "alos-palsar-mask", "autumn", "autumn_r", "binary",
         "binary_r", "blues", "blues_r", "bone", "bone_r", "brbg", "brbg_r", "brg", "brg_r", "bugn",
         "bugn_r", "bupu", "bupu_r", "bwr", "bwr_r", "c-cap", "cfastie", "chesapeake-lc-13",
         "chesapeake-lc-7", "chesapeake-lu", "chloris-biomass", "cividis", "cividis_r", "cmrmap",
         "cmrmap_r", "cool", "cool_r", "coolwarm", "coolwarm_r", "copper", "copper_r", "cubehelix",
         "cubehelix_r", "dark2", "dark2_r", "drcog-lulc", "esa-cci-lc", "esa-worldcover", "flag",
         "flag_r", "gap-lulc", "gist_earth", "gist_earth_r", "gist_gray", "gist_gray_r", "gist_heat",
         "gist_heat_r", "gist_ncar", "gist_ncar_r", "gist_rainbow", "gist_rainbow_r", "gist_stern",
         "gist_stern_r", "gist_yarg", "gist_yarg_r", "gnbu", "gnbu_r", "gnuplot", "gnuplot2",
         "gnuplot2_r", "gnuplot_r", "gray", "gray_r", "greens", "greens_r", "greys", "greys_r", "hot",
         "hot_r", "hsv", "hsv_r", "inferno", "inferno_r", "io-bii", "io-lulc", "io-lulc-9-class", "jet",
         "jet_r", "jrc-change", "jrc-extent", "jrc-occurrence", "jrc-recurrence", "jrc-seasonality",
         "jrc-transitions", "lidar-classification", "lidar-hag", "lidar-hag-alternative",
         "lidar-intensity", "lidar-returns", "magma", "magma_r", "modis-10A1", "modis-10A2",
         "modis-13A1|Q1", "modis-14A1|A2", "modis-15A2H|A3H", "modis-16A3GF-ET", "modis-16A3GF-PET",
         "modis-17A2H|A2HGF", "modis-17A3HGF", "modis-64A1", "mtbs-severity", "nipy_spectral",
         "nipy_spectral_r", "nrcan-lulc", "ocean", "ocean_r", "oranges", "oranges_r", "orrd", "orrd_r",
         "paired", "paired_r", "pastel1", "pastel1_r", "pastel2", "pastel2_r", "pink", "pink_r", "piyg",
         "piyg_r", "plasma", "plasma_r", "prgn", "prgn_r", "prism", "prism_r", "pubu", "pubu_r",
         "pubugn", "pubugn_r", "puor", "puor_r", "purd", "purd_r", "purples", "purples_r", "qpe",
         "rainbow", "rainbow_r", "rdbu", "rdbu_r", "rdgy", "rdgy_r", "rdpu", "rdpu_r", "rdylbu",
         "rdylbu_r", "rdylgn", "rdylgn_r", "reds", "reds_r", "rplumbo", "schwarzwald", "seismic",
         "seismic_r", "set1", "set1_r", "set2", "set2_r", "set3", "set3_r", "spectral", "spectral_r",
         "spring", "spring_r", "summer", "summer_r", "tab10", "tab10_r", "tab20", "tab20_r", "tab20b",
         "tab20b_r", "tab20c", "tab20c_r", "terrain", "terrain_r", "twilight", "twilight_r",
         "twilight_shifted", "twilight_shifted_r", "usda-cdl", "usda-cdl-corn", "usda-cdl-cotton",
         "usda-cdl-soybeans", "usda-cdl-wheat", "usgs-lcmap", "viirs-10a1", "viirs-13a1", "viirs-14a1",
         "viirs-15a2H", "viridis", "viridis_r", "winter", "winter_r", "wistia", "wistia_r", "ylgn",
         "ylgn_r", "ylgnbu", "ylgnbu_r", "ylorbr", "ylorbr_r", "ylorrd", and "ylorrd_r". Default value
         is None.
        :paramtype colormap_name: str or ~azure.planetarycomputer.models.ColorMapNames
        :keyword colormap: JSON encoded custom Colormap. Default value is None.
        :paramtype colormap: str
        :keyword return_mask: Add mask to the output data. Default value is None.
        :paramtype return_mask: bool
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: Iterator[bytes]
        :rtype: Iterator[bytes]
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @distributed_trace
    def crop_format(
        self,
        collection_id: str,
        item_id: str,
        format: str,
        body: Union[_models.Geometry, JSON, IO[bytes]],
        *,
        assets: Optional[List[str]] = None,
        expression: Optional[str] = None,
        asset_bidx: Optional[List[str]] = None,
        asset_as_band: Optional[bool] = None,
        nodata: Optional[float] = None,
        unscale: Optional[bool] = None,
        algorithm: Optional[Union[str, _models.Algorithm]] = None,
        algorithm_params: Optional[str] = None,
        color_formula: Optional[str] = None,
        coord_crs: Optional[str] = None,
        resampling: Optional[Union[str, _models.Resampling]] = None,
        max_size: Optional[int] = None,
        height: Optional[int] = None,
        width: Optional[int] = None,
        rescale: Optional[List[str]] = None,
        colormap_name: Optional[Union[str, _models.ColorMapNames]] = None,
        colormap: Optional[str] = None,
        return_mask: Optional[bool] = None,
        **kwargs: Any,
    ) -> Iterator[bytes]:
        """Geojson Crop.

        Create image from a geojson feature.

        :param collection_id: STAC Collection Identifier. Required.
        :type collection_id: str
        :param item_id: STAC Item Identifier. Required.
        :type item_id: str
        :param format: Output format for the tile or image (e.g., png, jpeg, webp) (default: "png").
         Required.
        :type format: str
        :param body: Request GeoJson body. Is one of the following types: Geometry, JSON, IO[bytes]
         Required.
        :type body: ~azure.planetarycomputer.models.Geometry or JSON or IO[bytes]
        :keyword assets: Asset's names. Default value is None.
        :paramtype assets: list[str]
        :keyword expression: Band math expression between assets. Default value is None.
        :paramtype expression: str
        :keyword asset_bidx: Per asset band indexes (coma separated indexes). Default value is None.
        :paramtype asset_bidx: list[str]
        :keyword asset_as_band: Asset as Band. Default value is None.
        :paramtype asset_as_band: bool
        :keyword nodata: Overwrite internal Nodata value. Default value is None.
        :paramtype nodata: float
        :keyword unscale: Apply internal Scale or Offset. Default value is None.
        :paramtype unscale: bool
        :keyword algorithm: Algorithm name. Known values are: "hillshade", "contours",
         "normalizedIndex", "terrarium", and "terrainrgb". Default value is None.
        :paramtype algorithm: str or ~azure.planetarycomputer.models.Algorithm
        :keyword algorithm_params: Algorithm parameter. Default value is None.
        :paramtype algorithm_params: str
        :keyword color_formula: rio-color formula (info: `https://github.com/mapbox/rio-color
         <https://github.com/mapbox/rio-color>`_). Default value is None.
        :paramtype color_formula: str
        :keyword coord_crs: Coordinate Reference System of the input coords. Default to ``epsg:4326``.
         Default value is None.
        :paramtype coord_crs: str
        :keyword resampling: Resampling method. Known values are: "nearest", "bilinear", "cubic",
         "cubic_spline", "lanczos", "average", "mode", "gauss", and "rms". Default value is None.
        :paramtype resampling: str or ~azure.planetarycomputer.models.Resampling
        :keyword max_size: Image output size limit if width and height limits are not set. Default
         value is None.
        :paramtype max_size: int
        :keyword height: Height in pixels for the output image. Default value is None.
        :paramtype height: int
        :keyword width: Width in pixels for the output image. Default value is None.
        :paramtype width: int
        :keyword rescale: comma (',') delimited Min,Max range. Can set multiple time for multiple
         bands. Default value is None.
        :paramtype rescale: list[str]
        :keyword colormap_name: Colormap name. Known values are: "accent", "accent_r", "afmhot",
         "afmhot_r", "ai4g-lulc", "alos-fnf", "alos-palsar-mask", "autumn", "autumn_r", "binary",
         "binary_r", "blues", "blues_r", "bone", "bone_r", "brbg", "brbg_r", "brg", "brg_r", "bugn",
         "bugn_r", "bupu", "bupu_r", "bwr", "bwr_r", "c-cap", "cfastie", "chesapeake-lc-13",
         "chesapeake-lc-7", "chesapeake-lu", "chloris-biomass", "cividis", "cividis_r", "cmrmap",
         "cmrmap_r", "cool", "cool_r", "coolwarm", "coolwarm_r", "copper", "copper_r", "cubehelix",
         "cubehelix_r", "dark2", "dark2_r", "drcog-lulc", "esa-cci-lc", "esa-worldcover", "flag",
         "flag_r", "gap-lulc", "gist_earth", "gist_earth_r", "gist_gray", "gist_gray_r", "gist_heat",
         "gist_heat_r", "gist_ncar", "gist_ncar_r", "gist_rainbow", "gist_rainbow_r", "gist_stern",
         "gist_stern_r", "gist_yarg", "gist_yarg_r", "gnbu", "gnbu_r", "gnuplot", "gnuplot2",
         "gnuplot2_r", "gnuplot_r", "gray", "gray_r", "greens", "greens_r", "greys", "greys_r", "hot",
         "hot_r", "hsv", "hsv_r", "inferno", "inferno_r", "io-bii", "io-lulc", "io-lulc-9-class", "jet",
         "jet_r", "jrc-change", "jrc-extent", "jrc-occurrence", "jrc-recurrence", "jrc-seasonality",
         "jrc-transitions", "lidar-classification", "lidar-hag", "lidar-hag-alternative",
         "lidar-intensity", "lidar-returns", "magma", "magma_r", "modis-10A1", "modis-10A2",
         "modis-13A1|Q1", "modis-14A1|A2", "modis-15A2H|A3H", "modis-16A3GF-ET", "modis-16A3GF-PET",
         "modis-17A2H|A2HGF", "modis-17A3HGF", "modis-64A1", "mtbs-severity", "nipy_spectral",
         "nipy_spectral_r", "nrcan-lulc", "ocean", "ocean_r", "oranges", "oranges_r", "orrd", "orrd_r",
         "paired", "paired_r", "pastel1", "pastel1_r", "pastel2", "pastel2_r", "pink", "pink_r", "piyg",
         "piyg_r", "plasma", "plasma_r", "prgn", "prgn_r", "prism", "prism_r", "pubu", "pubu_r",
         "pubugn", "pubugn_r", "puor", "puor_r", "purd", "purd_r", "purples", "purples_r", "qpe",
         "rainbow", "rainbow_r", "rdbu", "rdbu_r", "rdgy", "rdgy_r", "rdpu", "rdpu_r", "rdylbu",
         "rdylbu_r", "rdylgn", "rdylgn_r", "reds", "reds_r", "rplumbo", "schwarzwald", "seismic",
         "seismic_r", "set1", "set1_r", "set2", "set2_r", "set3", "set3_r", "spectral", "spectral_r",
         "spring", "spring_r", "summer", "summer_r", "tab10", "tab10_r", "tab20", "tab20_r", "tab20b",
         "tab20b_r", "tab20c", "tab20c_r", "terrain", "terrain_r", "twilight", "twilight_r",
         "twilight_shifted", "twilight_shifted_r", "usda-cdl", "usda-cdl-corn", "usda-cdl-cotton",
         "usda-cdl-soybeans", "usda-cdl-wheat", "usgs-lcmap", "viirs-10a1", "viirs-13a1", "viirs-14a1",
         "viirs-15a2H", "viridis", "viridis_r", "winter", "winter_r", "wistia", "wistia_r", "ylgn",
         "ylgn_r", "ylgnbu", "ylgnbu_r", "ylorbr", "ylorbr_r", "ylorrd", and "ylorrd_r". Default value
         is None.
        :paramtype colormap_name: str or ~azure.planetarycomputer.models.ColorMapNames
        :keyword colormap: JSON encoded custom Colormap. Default value is None.
        :paramtype colormap: str
        :keyword return_mask: Add mask to the output data. Default value is None.
        :paramtype return_mask: bool
        :return: Iterator[bytes]
        :rtype: Iterator[bytes]
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[Iterator[bytes]] = kwargs.pop("cls", None)

        content_type = content_type or "application/json"
        _content = None
        if isinstance(body, (IOBase, bytes)):
            _content = body
        else:
            _content = json.dumps(body, cls=SdkJSONEncoder, exclude_readonly=True)  # type: ignore

        _request = build_tiler_geo_jsons_crop_format_request(
            collection_id=collection_id,
            item_id=item_id,
            format=format,
            assets=assets,
            expression=expression,
            asset_bidx=asset_bidx,
            asset_as_band=asset_as_band,
            nodata=nodata,
            unscale=unscale,
            algorithm=algorithm,
            algorithm_params=algorithm_params,
            color_formula=color_formula,
            coord_crs=coord_crs,
            resampling=resampling,
            max_size=max_size,
            height=height,
            width=width,
            rescale=rescale,
            colormap_name=colormap_name,
            colormap=colormap,
            return_mask=return_mask,
            content_type=content_type,
            api_version=self._config.api_version,
            content=_content,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = kwargs.pop("stream", True)
        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                try:
                    response.read()  # Load the body in memory and close the socket
                except (StreamConsumedError, StreamClosedError):
                    pass
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        response_headers = {}
        response_headers["content-type"] = self._deserialize("str", response.headers.get("content-type"))
        response_headers["content-type"] = self._deserialize("str", response.headers.get("content-type"))
        response_headers["content-type"] = self._deserialize("str", response.headers.get("content-type"))
        response_headers["content-type"] = self._deserialize("str", response.headers.get("content-type"))
        response_headers["content-type"] = self._deserialize("str", response.headers.get("content-type"))
        response_headers["content-type"] = self._deserialize("str", response.headers.get("content-type"))
        response_headers["content-type"] = self._deserialize("str", response.headers.get("content-type"))

        deserialized = response.iter_bytes()

        if cls:
            return cls(pipeline_response, deserialized, response_headers)  # type: ignore

        return deserialized  # type: ignore


class MapsClassmapLegendsOperations:
    """
    .. warning::
        **DO NOT** instantiate this class directly.

        Instead, you should access the following operations through
        :class:`~azure.planetarycomputer.PlanetaryComputerClient`'s
        :attr:`maps_classmap_legends` attribute.
    """

    def __init__(self, *args, **kwargs) -> None:
        input_args = list(args)
        self._client: PipelineClient = input_args.pop(0) if input_args else kwargs.pop("client")
        self._config: PlanetaryComputerClientConfiguration = input_args.pop(0) if input_args else kwargs.pop("config")
        self._serialize: Serializer = input_args.pop(0) if input_args else kwargs.pop("serializer")
        self._deserialize: Deserializer = input_args.pop(0) if input_args else kwargs.pop("deserializer")

    @distributed_trace
    def get(
        self, classmap_name: str, *, trim_start: Optional[int] = None, trim_end: Optional[int] = None, **kwargs: Any
    ) -> Optional[_models.ClassmapLegendResponse]:
        """Get Classmap Legend.

        Generate values and color swatches mapping for a given classmap.

        Args:
        trim_start (int, optional): Number of items to trim
        from the start of the cmap
        trim_end (int, optional): Number of items to trim from the end of the cmap.

        :param classmap_name: classmap name. Required.
        :type classmap_name: str
        :keyword trim_start: Number of items to trim from the start of the cmap. Default value is None.
        :paramtype trim_start: int
        :keyword trim_end: Number of items to trim from the end of the cmap. Default value is None.
        :paramtype trim_end: int
        :return: ClassmapLegendResponse or None. The ClassmapLegendResponse is compatible with
         MutableMapping
        :rtype: ~azure.planetarycomputer.models.ClassmapLegendResponse or None
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[Optional[_models.ClassmapLegendResponse]] = kwargs.pop("cls", None)

        _request = build_maps_classmap_legends_get_request(
            classmap_name=classmap_name,
            trim_start=trim_start,
            trim_end=trim_end,
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = kwargs.pop("stream", False)
        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200, 204]:
            if _stream:
                try:
                    response.read()  # Load the body in memory and close the socket
                except (StreamConsumedError, StreamClosedError):
                    pass
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        deserialized = None
        if response.status_code == 200:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(_models.ClassmapLegendResponse, response.json())

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore


class MapsLegendsOperations:
    """
    .. warning::
        **DO NOT** instantiate this class directly.

        Instead, you should access the following operations through
        :class:`~azure.planetarycomputer.PlanetaryComputerClient`'s
        :attr:`maps_legends` attribute.
    """

    def __init__(self, *args, **kwargs) -> None:
        input_args = list(args)
        self._client: PipelineClient = input_args.pop(0) if input_args else kwargs.pop("client")
        self._config: PlanetaryComputerClientConfiguration = input_args.pop(0) if input_args else kwargs.pop("config")
        self._serialize: Serializer = input_args.pop(0) if input_args else kwargs.pop("serializer")
        self._deserialize: Deserializer = input_args.pop(0) if input_args else kwargs.pop("deserializer")

    @distributed_trace
    def get(
        self,
        cmap_name: str,
        *,
        height: Optional[float] = None,
        width: Optional[float] = None,
        trim_start: Optional[int] = None,
        trim_end: Optional[int] = None,
        **kwargs: Any,
    ) -> Optional[Iterator[bytes]]:
        """Get Legend.

        Generate a legend image for a given colormap.

        If the colormap has non-contiguous values at the beginning or end,
        which aren't desired in the output image, they can be trimmed by specifying
        the number of values to trim.

        Args:
        cmap_name (string): The name of the registered colormap to generate
        a legend for
        height (float, optional): The output height of the legend image
        width (float, optional): The output width of the legend image
        trim_start (int, optional): Number of items to trim from
        the start of the cmap
        trim_end (int, optional): Number of items to trim from the end of the cmap

        Returns:
        HTTP response with jpeg encoded image data.

        :param cmap_name: The name of the registered colormap to generate a legend for. Required.
        :type cmap_name: str
        :keyword height: The output height of the legend image. Default value is None.
        :paramtype height: float
        :keyword width: The output width of the legend image. Default value is None.
        :paramtype width: float
        :keyword trim_start: Number of items to trim from the start of the cmap. Default value is None.
        :paramtype trim_start: int
        :keyword trim_end: Number of items to trim from the end of the cmap. Default value is None.
        :paramtype trim_end: int
        :return: Iterator[bytes] or None
        :rtype: Iterator[bytes] or None
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[Optional[Iterator[bytes]]] = kwargs.pop("cls", None)

        _request = build_maps_legends_get_request(
            cmap_name=cmap_name,
            height=height,
            width=width,
            trim_start=trim_start,
            trim_end=trim_end,
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = kwargs.pop("stream", True)
        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200, 204]:
            if _stream:
                try:
                    response.read()  # Load the body in memory and close the socket
                except (StreamConsumedError, StreamClosedError):
                    pass
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        deserialized = None
        response_headers = {}
        if response.status_code == 200:
            response_headers["content-type"] = self._deserialize("str", response.headers.get("content-type"))

            deserialized = response.iter_bytes()

        if cls:
            return cls(pipeline_response, deserialized, response_headers)  # type: ignore

        return deserialized  # type: ignore


class MapsIntervalLegendsOperations:
    """
    .. warning::
        **DO NOT** instantiate this class directly.

        Instead, you should access the following operations through
        :class:`~azure.planetarycomputer.PlanetaryComputerClient`'s
        :attr:`maps_interval_legends` attribute.
    """

    def __init__(self, *args, **kwargs) -> None:
        input_args = list(args)
        self._client: PipelineClient = input_args.pop(0) if input_args else kwargs.pop("client")
        self._config: PlanetaryComputerClientConfiguration = input_args.pop(0) if input_args else kwargs.pop("config")
        self._serialize: Serializer = input_args.pop(0) if input_args else kwargs.pop("serializer")
        self._deserialize: Deserializer = input_args.pop(0) if input_args else kwargs.pop("deserializer")

    @distributed_trace
    def get_by_classmap_name(
        self, classmap_name: str, *, trim_start: Optional[int] = None, trim_end: Optional[int] = None, **kwargs: Any
    ) -> Optional[List[List["_types.IntervalLegendsElement"]]]:
        """Get Interval Legend.

        Generate values and color swatches mapping for a given interval classmap.

        Args:
        trim_start (int, optional): Number of items to trim from
        the start of the cmap
        trim_end (int, optional): Number of items to trim from the end of the cmap.

        :param classmap_name: classmap name. Required.
        :type classmap_name: str
        :keyword trim_start: Number of items to trim from the start of the cmap. Default value is None.
        :paramtype trim_start: int
        :keyword trim_end: Number of items to trim from the end of the cmap. Default value is None.
        :paramtype trim_end: int
        :return: list of list of list of int or dict mapping str to str or None
        :rtype: list[list[list[int] or dict[str, str]]] or None
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[Optional[List[List["_types.IntervalLegendsElement"]]]] = kwargs.pop("cls", None)

        _request = build_maps_interval_legends_get_by_classmap_name_request(
            classmap_name=classmap_name,
            trim_start=trim_start,
            trim_end=trim_end,
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = kwargs.pop("stream", False)
        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200, 204]:
            if _stream:
                try:
                    response.read()  # Load the body in memory and close the socket
                except (StreamConsumedError, StreamClosedError):
                    pass
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        deserialized = None
        response_headers = {}
        if response.status_code == 200:
            response_headers["content-type"] = self._deserialize("str", response.headers.get("content-type"))

            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(List[List["_types.IntervalLegendsElement"]], response.json())

        if cls:
            return cls(pipeline_response, deserialized, response_headers)  # type: ignore

        return deserialized  # type: ignore


class MosaicsTilesOperations:
    """
    .. warning::
        **DO NOT** instantiate this class directly.

        Instead, you should access the following operations through
        :class:`~azure.planetarycomputer.PlanetaryComputerClient`'s
        :attr:`mosaics_tiles` attribute.
    """

    def __init__(self, *args, **kwargs) -> None:
        input_args = list(args)
        self._client: PipelineClient = input_args.pop(0) if input_args else kwargs.pop("client")
        self._config: PlanetaryComputerClientConfiguration = input_args.pop(0) if input_args else kwargs.pop("config")
        self._serialize: Serializer = input_args.pop(0) if input_args else kwargs.pop("serializer")
        self._deserialize: Deserializer = input_args.pop(0) if input_args else kwargs.pop("deserializer")

    @distributed_trace
    def get_zxy_scalex_format(
        self,
        search_id: str,
        z: float,
        x: float,
        y: float,
        scale: float,
        format: str,
        *,
        assets: Optional[List[str]] = None,
        expression: Optional[str] = None,
        asset_bidx: Optional[List[str]] = None,
        asset_as_band: Optional[bool] = None,
        nodata: Optional[float] = None,
        unscale: Optional[bool] = None,
        scan_limit: Optional[int] = None,
        items_limit: Optional[int] = None,
        time_limit: Optional[int] = None,
        exitwhenfull: Optional[bool] = None,
        skipcovered: Optional[bool] = None,
        algorithm: Optional[Union[str, _models.Algorithm]] = None,
        algorithm_params: Optional[str] = None,
        tile_matrix_set_id: Optional[Union[str, _models.Tilematrixsetid]] = None,
        buffer: Optional[str] = None,
        color_formula: Optional[str] = None,
        collection: Optional[str] = None,
        resampling: Optional[Union[str, _models.Resampling]] = None,
        pixel_selection: Optional[Union[str, _models.PixelSelection]] = None,
        rescale: Optional[List[str]] = None,
        colormap_name: Optional[Union[str, _models.ColorMapNames]] = None,
        colormap: Optional[str] = None,
        return_mask: Optional[bool] = None,
        **kwargs: Any,
    ) -> Optional[Iterator[bytes]]:
        """Tile.

        Create map tile.

        :param search_id: Search Id (pgSTAC Search Hash). Required.
        :type search_id: str
        :param z: Identifier (Z) selecting one of the scales defined in the TileMatrixSet and
         representing the scaleDenominator the tile. Required.
        :type z: float
        :param x: Column (X) index of the tile on the selected TileMatrix. It cannot exceed the
         MatrixHeight-1 for the selected TileMatrix. Required.
        :type x: float
        :param y: Row (Y) index of the tile on the selected TileMatrix. It cannot exceed the
         MatrixWidth-1 for the selected TileMatrix. Required.
        :type y: float
        :param scale: Numeric scale factor for the tile. Higher values produce larger tiles (default:
         "1"). Required.
        :type scale: float
        :param format: Output format for the tile or image (e.g., png, jpeg, webp) (default: "png").
         Required.
        :type format: str
        :keyword assets: Asset's names. Default value is None.
        :paramtype assets: list[str]
        :keyword expression: Band math expression between assets. Default value is None.
        :paramtype expression: str
        :keyword asset_bidx: Per asset band indexes (coma separated indexes). Default value is None.
        :paramtype asset_bidx: list[str]
        :keyword asset_as_band: Asset as Band. Default value is None.
        :paramtype asset_as_band: bool
        :keyword nodata: Overwrite internal Nodata value. Default value is None.
        :paramtype nodata: float
        :keyword unscale: Apply internal Scale or Offset. Default value is None.
        :paramtype unscale: bool
        :keyword scan_limit: Return as soon as we scan N items (defaults to 10000 in PgSTAC). Default
         value is None.
        :paramtype scan_limit: int
        :keyword items_limit: Return as soon as we have N items per geometry (defaults to 100 in
         PgSTAC). Default value is None.
        :paramtype items_limit: int
        :keyword time_limit: Return after N seconds to avoid long requests (defaults to 5 in PgSTAC).
         Default value is None.
        :paramtype time_limit: int
        :keyword exitwhenfull: Return as soon as the geometry is fully covered (defaults to True in
         PgSTAC). Default value is None.
        :paramtype exitwhenfull: bool
        :keyword skipcovered: Skip any items that would show up completely under the previous items
         (defaults
         to True in PgSTAC). Default value is None.
        :paramtype skipcovered: bool
        :keyword algorithm: Algorithm name. Known values are: "hillshade", "contours",
         "normalizedIndex", "terrarium", and "terrainrgb". Default value is None.
        :paramtype algorithm: str or ~azure.planetarycomputer.models.Algorithm
        :keyword algorithm_params: Algorithm parameter. Default value is None.
        :paramtype algorithm_params: str
        :keyword tile_matrix_set_id: Identifier selecting one of the TileMatrixSetId supported
         (default:
         'WebMercatorQuad'). Known values are: "CanadianNAD83_LCC", "EuropeanETRS89_LAEAQuad",
         "LINZAntarticaMapTilegrid", "NZTM2000Quad", "UPSAntarcticWGS84Quad", "UPSArcticWGS84Quad",
         "UTM31WGS84Quad", "WGS1984Quad", "WebMercatorQuad", "WorldCRS84Quad", and
         "WorldMercatorWGS84Quad". Default value is None.
        :paramtype tile_matrix_set_id: str or ~azure.planetarycomputer.models.Tilematrixsetid
        :keyword buffer: Buffer on each side of the given tile. It must be a multiple of ``0.5``.
         Output
         **tilesize** will be expanded to ``tilesize + 2 * buffer`` (e.g 0.5 = 257x257,
         1.0 = 258x258). Default value is None.
        :paramtype buffer: str
        :keyword color_formula: rio-color formula (info: `https://github.com/mapbox/rio-color
         <https://github.com/mapbox/rio-color>`_). Default value is None.
        :paramtype color_formula: str
        :keyword collection: STAC Collection ID. Default value is None.
        :paramtype collection: str
        :keyword resampling: Resampling method. Known values are: "nearest", "bilinear", "cubic",
         "cubic_spline", "lanczos", "average", "mode", "gauss", and "rms". Default value is None.
        :paramtype resampling: str or ~azure.planetarycomputer.models.Resampling
        :keyword pixel_selection: Pixel selection method. Known values are: "first", "highest",
         "lowest", "mean", "median", "stdev", "lastbandlow", and "lastbandhight". Default value is None.
        :paramtype pixel_selection: str or ~azure.planetarycomputer.models.PixelSelection
        :keyword rescale: comma (',') delimited Min,Max range. Can set multiple time for multiple
         bands. Default value is None.
        :paramtype rescale: list[str]
        :keyword colormap_name: Colormap name. Known values are: "accent", "accent_r", "afmhot",
         "afmhot_r", "ai4g-lulc", "alos-fnf", "alos-palsar-mask", "autumn", "autumn_r", "binary",
         "binary_r", "blues", "blues_r", "bone", "bone_r", "brbg", "brbg_r", "brg", "brg_r", "bugn",
         "bugn_r", "bupu", "bupu_r", "bwr", "bwr_r", "c-cap", "cfastie", "chesapeake-lc-13",
         "chesapeake-lc-7", "chesapeake-lu", "chloris-biomass", "cividis", "cividis_r", "cmrmap",
         "cmrmap_r", "cool", "cool_r", "coolwarm", "coolwarm_r", "copper", "copper_r", "cubehelix",
         "cubehelix_r", "dark2", "dark2_r", "drcog-lulc", "esa-cci-lc", "esa-worldcover", "flag",
         "flag_r", "gap-lulc", "gist_earth", "gist_earth_r", "gist_gray", "gist_gray_r", "gist_heat",
         "gist_heat_r", "gist_ncar", "gist_ncar_r", "gist_rainbow", "gist_rainbow_r", "gist_stern",
         "gist_stern_r", "gist_yarg", "gist_yarg_r", "gnbu", "gnbu_r", "gnuplot", "gnuplot2",
         "gnuplot2_r", "gnuplot_r", "gray", "gray_r", "greens", "greens_r", "greys", "greys_r", "hot",
         "hot_r", "hsv", "hsv_r", "inferno", "inferno_r", "io-bii", "io-lulc", "io-lulc-9-class", "jet",
         "jet_r", "jrc-change", "jrc-extent", "jrc-occurrence", "jrc-recurrence", "jrc-seasonality",
         "jrc-transitions", "lidar-classification", "lidar-hag", "lidar-hag-alternative",
         "lidar-intensity", "lidar-returns", "magma", "magma_r", "modis-10A1", "modis-10A2",
         "modis-13A1|Q1", "modis-14A1|A2", "modis-15A2H|A3H", "modis-16A3GF-ET", "modis-16A3GF-PET",
         "modis-17A2H|A2HGF", "modis-17A3HGF", "modis-64A1", "mtbs-severity", "nipy_spectral",
         "nipy_spectral_r", "nrcan-lulc", "ocean", "ocean_r", "oranges", "oranges_r", "orrd", "orrd_r",
         "paired", "paired_r", "pastel1", "pastel1_r", "pastel2", "pastel2_r", "pink", "pink_r", "piyg",
         "piyg_r", "plasma", "plasma_r", "prgn", "prgn_r", "prism", "prism_r", "pubu", "pubu_r",
         "pubugn", "pubugn_r", "puor", "puor_r", "purd", "purd_r", "purples", "purples_r", "qpe",
         "rainbow", "rainbow_r", "rdbu", "rdbu_r", "rdgy", "rdgy_r", "rdpu", "rdpu_r", "rdylbu",
         "rdylbu_r", "rdylgn", "rdylgn_r", "reds", "reds_r", "rplumbo", "schwarzwald", "seismic",
         "seismic_r", "set1", "set1_r", "set2", "set2_r", "set3", "set3_r", "spectral", "spectral_r",
         "spring", "spring_r", "summer", "summer_r", "tab10", "tab10_r", "tab20", "tab20_r", "tab20b",
         "tab20b_r", "tab20c", "tab20c_r", "terrain", "terrain_r", "twilight", "twilight_r",
         "twilight_shifted", "twilight_shifted_r", "usda-cdl", "usda-cdl-corn", "usda-cdl-cotton",
         "usda-cdl-soybeans", "usda-cdl-wheat", "usgs-lcmap", "viirs-10a1", "viirs-13a1", "viirs-14a1",
         "viirs-15a2H", "viridis", "viridis_r", "winter", "winter_r", "wistia", "wistia_r", "ylgn",
         "ylgn_r", "ylgnbu", "ylgnbu_r", "ylorbr", "ylorbr_r", "ylorrd", and "ylorrd_r". Default value
         is None.
        :paramtype colormap_name: str or ~azure.planetarycomputer.models.ColorMapNames
        :keyword colormap: JSON encoded custom Colormap. Default value is None.
        :paramtype colormap: str
        :keyword return_mask: Add mask to the output data. Default value is None.
        :paramtype return_mask: bool
        :return: Iterator[bytes] or None
        :rtype: Iterator[bytes] or None
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[Optional[Iterator[bytes]]] = kwargs.pop("cls", None)

        _request = build_mosaics_tiles_get_zxy_scalex_format_request(
            search_id=search_id,
            z=z,
            x=x,
            y=y,
            scale=scale,
            format=format,
            assets=assets,
            expression=expression,
            asset_bidx=asset_bidx,
            asset_as_band=asset_as_band,
            nodata=nodata,
            unscale=unscale,
            scan_limit=scan_limit,
            items_limit=items_limit,
            time_limit=time_limit,
            exitwhenfull=exitwhenfull,
            skipcovered=skipcovered,
            algorithm=algorithm,
            algorithm_params=algorithm_params,
            tile_matrix_set_id=tile_matrix_set_id,
            buffer=buffer,
            color_formula=color_formula,
            collection=collection,
            resampling=resampling,
            pixel_selection=pixel_selection,
            rescale=rescale,
            colormap_name=colormap_name,
            colormap=colormap,
            return_mask=return_mask,
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = kwargs.pop("stream", True)
        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200, 204]:
            if _stream:
                try:
                    response.read()  # Load the body in memory and close the socket
                except (StreamConsumedError, StreamClosedError):
                    pass
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        deserialized = None
        response_headers = {}
        if response.status_code == 200:
            response_headers["content-type"] = self._deserialize("str", response.headers.get("content-type"))
            response_headers["content-type"] = self._deserialize("str", response.headers.get("content-type"))
            response_headers["content-type"] = self._deserialize("str", response.headers.get("content-type"))
            response_headers["content-type"] = self._deserialize("str", response.headers.get("content-type"))
            response_headers["content-type"] = self._deserialize("str", response.headers.get("content-type"))
            response_headers["content-type"] = self._deserialize("str", response.headers.get("content-type"))
            response_headers["content-type"] = self._deserialize("str", response.headers.get("content-type"))

            deserialized = response.iter_bytes()

        if cls:
            return cls(pipeline_response, deserialized, response_headers)  # type: ignore

        return deserialized  # type: ignore


class MosaicsTileMatrixSetsOperations:
    """
    .. warning::
        **DO NOT** instantiate this class directly.

        Instead, you should access the following operations through
        :class:`~azure.planetarycomputer.PlanetaryComputerClient`'s
        :attr:`mosaics_tile_matrix_sets` attribute.
    """

    def __init__(self, *args, **kwargs) -> None:
        input_args = list(args)
        self._client: PipelineClient = input_args.pop(0) if input_args else kwargs.pop("client")
        self._config: PlanetaryComputerClientConfiguration = input_args.pop(0) if input_args else kwargs.pop("config")
        self._serialize: Serializer = input_args.pop(0) if input_args else kwargs.pop("serializer")
        self._deserialize: Deserializer = input_args.pop(0) if input_args else kwargs.pop("deserializer")

    @distributed_trace
    def get_zxy_scalex_format(
        self,
        search_id: str,
        tile_matrix_set_id: str,
        z: float,
        x: float,
        y: float,
        scale: float,
        format: str,
        *,
        assets: Optional[List[str]] = None,
        expression: Optional[str] = None,
        asset_bidx: Optional[List[str]] = None,
        asset_as_band: Optional[bool] = None,
        nodata: Optional[float] = None,
        unscale: Optional[bool] = None,
        scan_limit: Optional[int] = None,
        items_limit: Optional[int] = None,
        time_limit: Optional[int] = None,
        exitwhenfull: Optional[bool] = None,
        skipcovered: Optional[bool] = None,
        algorithm: Optional[Union[str, _models.Algorithm]] = None,
        algorithm_params: Optional[str] = None,
        buffer: Optional[str] = None,
        color_formula: Optional[str] = None,
        collection: Optional[str] = None,
        resampling: Optional[Union[str, _models.Resampling]] = None,
        pixel_selection: Optional[Union[str, _models.PixelSelection]] = None,
        rescale: Optional[List[str]] = None,
        colormap_name: Optional[Union[str, _models.ColorMapNames]] = None,
        colormap: Optional[str] = None,
        return_mask: Optional[bool] = None,
        **kwargs: Any,
    ) -> Optional[Iterator[bytes]]:
        """Tile Tilematrixsetid As Path.

        Create map tile.

        :param search_id: Search Id (pgSTAC Search Hash). Required.
        :type search_id: str
        :param tile_matrix_set_id: Identifier selecting one of the TileMatrixSetId supported. Required.
        :type tile_matrix_set_id: str
        :param z: Identifier (Z) selecting one of the scales defined in the TileMatrixSet and
         representing the scaleDenominator the tile. Required.
        :type z: float
        :param x: Column (X) index of the tile on the selected TileMatrix. It cannot exceed the
         MatrixHeight-1 for the selected TileMatrix. Required.
        :type x: float
        :param y: Row (Y) index of the tile on the selected TileMatrix. It cannot exceed the
         MatrixWidth-1 for the selected TileMatrix. Required.
        :type y: float
        :param scale: Numeric scale factor for the tile. Higher values produce larger tiles (default:
         "1"). Required.
        :type scale: float
        :param format: Output format for the tile or image (e.g., png, jpeg, webp) (default: "png").
         Required.
        :type format: str
        :keyword assets: Asset's names. Default value is None.
        :paramtype assets: list[str]
        :keyword expression: Band math expression between assets. Default value is None.
        :paramtype expression: str
        :keyword asset_bidx: Per asset band indexes (coma separated indexes). Default value is None.
        :paramtype asset_bidx: list[str]
        :keyword asset_as_band: Asset as Band. Default value is None.
        :paramtype asset_as_band: bool
        :keyword nodata: Overwrite internal Nodata value. Default value is None.
        :paramtype nodata: float
        :keyword unscale: Apply internal Scale or Offset. Default value is None.
        :paramtype unscale: bool
        :keyword scan_limit: Return as soon as we scan N items (defaults to 10000 in PgSTAC). Default
         value is None.
        :paramtype scan_limit: int
        :keyword items_limit: Return as soon as we have N items per geometry (defaults to 100 in
         PgSTAC). Default value is None.
        :paramtype items_limit: int
        :keyword time_limit: Return after N seconds to avoid long requests (defaults to 5 in PgSTAC).
         Default value is None.
        :paramtype time_limit: int
        :keyword exitwhenfull: Return as soon as the geometry is fully covered (defaults to True in
         PgSTAC). Default value is None.
        :paramtype exitwhenfull: bool
        :keyword skipcovered: Skip any items that would show up completely under the previous items
         (defaults
         to True in PgSTAC). Default value is None.
        :paramtype skipcovered: bool
        :keyword algorithm: Algorithm name. Known values are: "hillshade", "contours",
         "normalizedIndex", "terrarium", and "terrainrgb". Default value is None.
        :paramtype algorithm: str or ~azure.planetarycomputer.models.Algorithm
        :keyword algorithm_params: Algorithm parameter. Default value is None.
        :paramtype algorithm_params: str
        :keyword buffer: Buffer on each side of the given tile. It must be a multiple of ``0.5``.
         Output
         **tilesize** will be expanded to ``tilesize + 2 * buffer`` (e.g 0.5 = 257x257,
         1.0 = 258x258). Default value is None.
        :paramtype buffer: str
        :keyword color_formula: rio-color formula (info: `https://github.com/mapbox/rio-color
         <https://github.com/mapbox/rio-color>`_). Default value is None.
        :paramtype color_formula: str
        :keyword collection: STAC Collection ID. Default value is None.
        :paramtype collection: str
        :keyword resampling: Resampling method. Known values are: "nearest", "bilinear", "cubic",
         "cubic_spline", "lanczos", "average", "mode", "gauss", and "rms". Default value is None.
        :paramtype resampling: str or ~azure.planetarycomputer.models.Resampling
        :keyword pixel_selection: Pixel selection method. Known values are: "first", "highest",
         "lowest", "mean", "median", "stdev", "lastbandlow", and "lastbandhight". Default value is None.
        :paramtype pixel_selection: str or ~azure.planetarycomputer.models.PixelSelection
        :keyword rescale: comma (',') delimited Min,Max range. Can set multiple time for multiple
         bands. Default value is None.
        :paramtype rescale: list[str]
        :keyword colormap_name: Colormap name. Known values are: "accent", "accent_r", "afmhot",
         "afmhot_r", "ai4g-lulc", "alos-fnf", "alos-palsar-mask", "autumn", "autumn_r", "binary",
         "binary_r", "blues", "blues_r", "bone", "bone_r", "brbg", "brbg_r", "brg", "brg_r", "bugn",
         "bugn_r", "bupu", "bupu_r", "bwr", "bwr_r", "c-cap", "cfastie", "chesapeake-lc-13",
         "chesapeake-lc-7", "chesapeake-lu", "chloris-biomass", "cividis", "cividis_r", "cmrmap",
         "cmrmap_r", "cool", "cool_r", "coolwarm", "coolwarm_r", "copper", "copper_r", "cubehelix",
         "cubehelix_r", "dark2", "dark2_r", "drcog-lulc", "esa-cci-lc", "esa-worldcover", "flag",
         "flag_r", "gap-lulc", "gist_earth", "gist_earth_r", "gist_gray", "gist_gray_r", "gist_heat",
         "gist_heat_r", "gist_ncar", "gist_ncar_r", "gist_rainbow", "gist_rainbow_r", "gist_stern",
         "gist_stern_r", "gist_yarg", "gist_yarg_r", "gnbu", "gnbu_r", "gnuplot", "gnuplot2",
         "gnuplot2_r", "gnuplot_r", "gray", "gray_r", "greens", "greens_r", "greys", "greys_r", "hot",
         "hot_r", "hsv", "hsv_r", "inferno", "inferno_r", "io-bii", "io-lulc", "io-lulc-9-class", "jet",
         "jet_r", "jrc-change", "jrc-extent", "jrc-occurrence", "jrc-recurrence", "jrc-seasonality",
         "jrc-transitions", "lidar-classification", "lidar-hag", "lidar-hag-alternative",
         "lidar-intensity", "lidar-returns", "magma", "magma_r", "modis-10A1", "modis-10A2",
         "modis-13A1|Q1", "modis-14A1|A2", "modis-15A2H|A3H", "modis-16A3GF-ET", "modis-16A3GF-PET",
         "modis-17A2H|A2HGF", "modis-17A3HGF", "modis-64A1", "mtbs-severity", "nipy_spectral",
         "nipy_spectral_r", "nrcan-lulc", "ocean", "ocean_r", "oranges", "oranges_r", "orrd", "orrd_r",
         "paired", "paired_r", "pastel1", "pastel1_r", "pastel2", "pastel2_r", "pink", "pink_r", "piyg",
         "piyg_r", "plasma", "plasma_r", "prgn", "prgn_r", "prism", "prism_r", "pubu", "pubu_r",
         "pubugn", "pubugn_r", "puor", "puor_r", "purd", "purd_r", "purples", "purples_r", "qpe",
         "rainbow", "rainbow_r", "rdbu", "rdbu_r", "rdgy", "rdgy_r", "rdpu", "rdpu_r", "rdylbu",
         "rdylbu_r", "rdylgn", "rdylgn_r", "reds", "reds_r", "rplumbo", "schwarzwald", "seismic",
         "seismic_r", "set1", "set1_r", "set2", "set2_r", "set3", "set3_r", "spectral", "spectral_r",
         "spring", "spring_r", "summer", "summer_r", "tab10", "tab10_r", "tab20", "tab20_r", "tab20b",
         "tab20b_r", "tab20c", "tab20c_r", "terrain", "terrain_r", "twilight", "twilight_r",
         "twilight_shifted", "twilight_shifted_r", "usda-cdl", "usda-cdl-corn", "usda-cdl-cotton",
         "usda-cdl-soybeans", "usda-cdl-wheat", "usgs-lcmap", "viirs-10a1", "viirs-13a1", "viirs-14a1",
         "viirs-15a2H", "viridis", "viridis_r", "winter", "winter_r", "wistia", "wistia_r", "ylgn",
         "ylgn_r", "ylgnbu", "ylgnbu_r", "ylorbr", "ylorbr_r", "ylorrd", and "ylorrd_r". Default value
         is None.
        :paramtype colormap_name: str or ~azure.planetarycomputer.models.ColorMapNames
        :keyword colormap: JSON encoded custom Colormap. Default value is None.
        :paramtype colormap: str
        :keyword return_mask: Add mask to the output data. Default value is None.
        :paramtype return_mask: bool
        :return: Iterator[bytes] or None
        :rtype: Iterator[bytes] or None
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[Optional[Iterator[bytes]]] = kwargs.pop("cls", None)

        _request = build_mosaics_tile_matrix_sets_get_zxy_scalex_format_request(
            search_id=search_id,
            tile_matrix_set_id=tile_matrix_set_id,
            z=z,
            x=x,
            y=y,
            scale=scale,
            format=format,
            assets=assets,
            expression=expression,
            asset_bidx=asset_bidx,
            asset_as_band=asset_as_band,
            nodata=nodata,
            unscale=unscale,
            scan_limit=scan_limit,
            items_limit=items_limit,
            time_limit=time_limit,
            exitwhenfull=exitwhenfull,
            skipcovered=skipcovered,
            algorithm=algorithm,
            algorithm_params=algorithm_params,
            buffer=buffer,
            color_formula=color_formula,
            collection=collection,
            resampling=resampling,
            pixel_selection=pixel_selection,
            rescale=rescale,
            colormap_name=colormap_name,
            colormap=colormap,
            return_mask=return_mask,
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = kwargs.pop("stream", True)
        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200, 204]:
            if _stream:
                try:
                    response.read()  # Load the body in memory and close the socket
                except (StreamConsumedError, StreamClosedError):
                    pass
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        deserialized = None
        response_headers = {}
        if response.status_code == 200:
            response_headers["content-type"] = self._deserialize("str", response.headers.get("content-type"))
            response_headers["content-type"] = self._deserialize("str", response.headers.get("content-type"))
            response_headers["content-type"] = self._deserialize("str", response.headers.get("content-type"))
            response_headers["content-type"] = self._deserialize("str", response.headers.get("content-type"))
            response_headers["content-type"] = self._deserialize("str", response.headers.get("content-type"))
            response_headers["content-type"] = self._deserialize("str", response.headers.get("content-type"))
            response_headers["content-type"] = self._deserialize("str", response.headers.get("content-type"))

            deserialized = response.iter_bytes()

        if cls:
            return cls(pipeline_response, deserialized, response_headers)  # type: ignore

        return deserialized  # type: ignore


class MosaicsTileJsonOperationsOperations:
    """
    .. warning::
        **DO NOT** instantiate this class directly.

        Instead, you should access the following operations through
        :class:`~azure.planetarycomputer.PlanetaryComputerClient`'s
        :attr:`mosaics_tile_json_operations` attribute.
    """

    def __init__(self, *args, **kwargs) -> None:
        input_args = list(args)
        self._client: PipelineClient = input_args.pop(0) if input_args else kwargs.pop("client")
        self._config: PlanetaryComputerClientConfiguration = input_args.pop(0) if input_args else kwargs.pop("config")
        self._serialize: Serializer = input_args.pop(0) if input_args else kwargs.pop("serializer")
        self._deserialize: Deserializer = input_args.pop(0) if input_args else kwargs.pop("deserializer")

    @distributed_trace
    def get(
        self,
        search_id: str,
        *,
        assets: Optional[List[str]] = None,
        expression: Optional[str] = None,
        asset_bidx: Optional[List[str]] = None,
        asset_as_band: Optional[bool] = None,
        nodata: Optional[float] = None,
        unscale: Optional[bool] = None,
        scan_limit: Optional[int] = None,
        items_limit: Optional[int] = None,
        time_limit: Optional[int] = None,
        exitwhenfull: Optional[bool] = None,
        skipcovered: Optional[bool] = None,
        tile_matrix_set_id: Optional[Union[str, _models.Tilematrixsetid]] = None,
        tile_format: Optional[Union[str, _models.ImageType]] = None,
        tile_scale: Optional[int] = None,
        minzoom: Optional[int] = None,
        maxzoom: Optional[int] = None,
        buffer: Optional[float] = None,
        color_formula: Optional[str] = None,
        collection: Optional[str] = None,
        resampling: Optional[Union[str, _models.Resampling]] = None,
        pixel_selection: Optional[Union[str, _models.PixelSelection]] = None,
        algorithm: Optional[Union[str, _models.Algorithm]] = None,
        algorithm_params: Optional[str] = None,
        rescale: Optional[List[str]] = None,
        colormap_name: Optional[Union[str, _models.ColorMapNames]] = None,
        colormap: Optional[str] = None,
        return_mask: Optional[bool] = None,
        **kwargs: Any,
    ) -> _models.TileJsonResponse:
        """Tilejson.

        Return TileJSON document for a searchId.

        :param search_id: Search Id (pgSTAC Search Hash). Required.
        :type search_id: str
        :keyword assets: Asset's names. Default value is None.
        :paramtype assets: list[str]
        :keyword expression: Band math expression between assets. Default value is None.
        :paramtype expression: str
        :keyword asset_bidx: Per asset band indexes (coma separated indexes). Default value is None.
        :paramtype asset_bidx: list[str]
        :keyword asset_as_band: Asset as Band. Default value is None.
        :paramtype asset_as_band: bool
        :keyword nodata: Overwrite internal Nodata value. Default value is None.
        :paramtype nodata: float
        :keyword unscale: Apply internal Scale or Offset. Default value is None.
        :paramtype unscale: bool
        :keyword scan_limit: Return as soon as we scan N items (defaults to 10000 in PgSTAC). Default
         value is None.
        :paramtype scan_limit: int
        :keyword items_limit: Return as soon as we have N items per geometry (defaults to 100 in
         PgSTAC). Default value is None.
        :paramtype items_limit: int
        :keyword time_limit: Return after N seconds to avoid long requests (defaults to 5 in PgSTAC).
         Default value is None.
        :paramtype time_limit: int
        :keyword exitwhenfull: Return as soon as the geometry is fully covered (defaults to True in
         PgSTAC). Default value is None.
        :paramtype exitwhenfull: bool
        :keyword skipcovered: Skip any items that would show up completely under the previous items
         (defaults
         to True in PgSTAC). Default value is None.
        :paramtype skipcovered: bool
        :keyword tile_matrix_set_id: Identifier selecting one of the TileMatrixSetId supported
         (default: 'WebMercatorQuad'). Known values are: "CanadianNAD83_LCC", "EuropeanETRS89_LAEAQuad",
         "LINZAntarticaMapTilegrid", "NZTM2000Quad", "UPSAntarcticWGS84Quad", "UPSArcticWGS84Quad",
         "UTM31WGS84Quad", "WGS1984Quad", "WebMercatorQuad", "WorldCRS84Quad", and
         "WorldMercatorWGS84Quad". Default value is None.
        :paramtype tile_matrix_set_id: str or ~azure.planetarycomputer.models.Tilematrixsetid
        :keyword tile_format: Default will be automatically defined if the output image needs a mask
         (png) or
         not (jpeg). Known values are: "png", "npy", "tif", "jpeg", "jpg", "jp2", "webp", and "pngraw".
         Default value is None.
        :paramtype tile_format: str or ~azure.planetarycomputer.models.ImageType
        :keyword tile_scale: Tile scale factor affecting output size. Values > 1 produce larger tiles
         (e.g., 1=256x256, 2=512x512). Default value is None.
        :paramtype tile_scale: int
        :keyword minzoom: Overwrite default minzoom. Default value is None.
        :paramtype minzoom: int
        :keyword maxzoom: Overwrite default maxzoom. Default value is None.
        :paramtype maxzoom: int
        :keyword buffer: Buffer on each side of the given tile. It must be a multiple of ``0.5``.
         Output
         **tilesize** will be expanded to ``tilesize + 2 * buffer`` (e.g 0.5 = 257x257,
         1.0 = 258x258). Default value is None.
        :paramtype buffer: float
        :keyword color_formula: rio-color formula (info: `https://github.com/mapbox/rio-color
         <https://github.com/mapbox/rio-color>`_). Default value is None.
        :paramtype color_formula: str
        :keyword collection: STAC Collection ID. Default value is None.
        :paramtype collection: str
        :keyword resampling: Resampling method. Known values are: "nearest", "bilinear", "cubic",
         "cubic_spline", "lanczos", "average", "mode", "gauss", and "rms". Default value is None.
        :paramtype resampling: str or ~azure.planetarycomputer.models.Resampling
        :keyword pixel_selection: Pixel selection method. Known values are: "first", "highest",
         "lowest", "mean", "median", "stdev", "lastbandlow", and "lastbandhight". Default value is None.
        :paramtype pixel_selection: str or ~azure.planetarycomputer.models.PixelSelection
        :keyword algorithm: Algorithm name. Known values are: "hillshade", "contours",
         "normalizedIndex", "terrarium", and "terrainrgb". Default value is None.
        :paramtype algorithm: str or ~azure.planetarycomputer.models.Algorithm
        :keyword algorithm_params: Algorithm parameter. Default value is None.
        :paramtype algorithm_params: str
        :keyword rescale: comma (',') delimited Min,Max range. Can set multiple time for multiple
         bands. Default value is None.
        :paramtype rescale: list[str]
        :keyword colormap_name: Colormap name. Known values are: "accent", "accent_r", "afmhot",
         "afmhot_r", "ai4g-lulc", "alos-fnf", "alos-palsar-mask", "autumn", "autumn_r", "binary",
         "binary_r", "blues", "blues_r", "bone", "bone_r", "brbg", "brbg_r", "brg", "brg_r", "bugn",
         "bugn_r", "bupu", "bupu_r", "bwr", "bwr_r", "c-cap", "cfastie", "chesapeake-lc-13",
         "chesapeake-lc-7", "chesapeake-lu", "chloris-biomass", "cividis", "cividis_r", "cmrmap",
         "cmrmap_r", "cool", "cool_r", "coolwarm", "coolwarm_r", "copper", "copper_r", "cubehelix",
         "cubehelix_r", "dark2", "dark2_r", "drcog-lulc", "esa-cci-lc", "esa-worldcover", "flag",
         "flag_r", "gap-lulc", "gist_earth", "gist_earth_r", "gist_gray", "gist_gray_r", "gist_heat",
         "gist_heat_r", "gist_ncar", "gist_ncar_r", "gist_rainbow", "gist_rainbow_r", "gist_stern",
         "gist_stern_r", "gist_yarg", "gist_yarg_r", "gnbu", "gnbu_r", "gnuplot", "gnuplot2",
         "gnuplot2_r", "gnuplot_r", "gray", "gray_r", "greens", "greens_r", "greys", "greys_r", "hot",
         "hot_r", "hsv", "hsv_r", "inferno", "inferno_r", "io-bii", "io-lulc", "io-lulc-9-class", "jet",
         "jet_r", "jrc-change", "jrc-extent", "jrc-occurrence", "jrc-recurrence", "jrc-seasonality",
         "jrc-transitions", "lidar-classification", "lidar-hag", "lidar-hag-alternative",
         "lidar-intensity", "lidar-returns", "magma", "magma_r", "modis-10A1", "modis-10A2",
         "modis-13A1|Q1", "modis-14A1|A2", "modis-15A2H|A3H", "modis-16A3GF-ET", "modis-16A3GF-PET",
         "modis-17A2H|A2HGF", "modis-17A3HGF", "modis-64A1", "mtbs-severity", "nipy_spectral",
         "nipy_spectral_r", "nrcan-lulc", "ocean", "ocean_r", "oranges", "oranges_r", "orrd", "orrd_r",
         "paired", "paired_r", "pastel1", "pastel1_r", "pastel2", "pastel2_r", "pink", "pink_r", "piyg",
         "piyg_r", "plasma", "plasma_r", "prgn", "prgn_r", "prism", "prism_r", "pubu", "pubu_r",
         "pubugn", "pubugn_r", "puor", "puor_r", "purd", "purd_r", "purples", "purples_r", "qpe",
         "rainbow", "rainbow_r", "rdbu", "rdbu_r", "rdgy", "rdgy_r", "rdpu", "rdpu_r", "rdylbu",
         "rdylbu_r", "rdylgn", "rdylgn_r", "reds", "reds_r", "rplumbo", "schwarzwald", "seismic",
         "seismic_r", "set1", "set1_r", "set2", "set2_r", "set3", "set3_r", "spectral", "spectral_r",
         "spring", "spring_r", "summer", "summer_r", "tab10", "tab10_r", "tab20", "tab20_r", "tab20b",
         "tab20b_r", "tab20c", "tab20c_r", "terrain", "terrain_r", "twilight", "twilight_r",
         "twilight_shifted", "twilight_shifted_r", "usda-cdl", "usda-cdl-corn", "usda-cdl-cotton",
         "usda-cdl-soybeans", "usda-cdl-wheat", "usgs-lcmap", "viirs-10a1", "viirs-13a1", "viirs-14a1",
         "viirs-15a2H", "viridis", "viridis_r", "winter", "winter_r", "wistia", "wistia_r", "ylgn",
         "ylgn_r", "ylgnbu", "ylgnbu_r", "ylorbr", "ylorbr_r", "ylorrd", and "ylorrd_r". Default value
         is None.
        :paramtype colormap_name: str or ~azure.planetarycomputer.models.ColorMapNames
        :keyword colormap: JSON encoded custom Colormap. Default value is None.
        :paramtype colormap: str
        :keyword return_mask: Add mask to the output data. Default value is None.
        :paramtype return_mask: bool
        :return: TileJsonResponse. The TileJsonResponse is compatible with MutableMapping
        :rtype: ~azure.planetarycomputer.models.TileJsonResponse
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[_models.TileJsonResponse] = kwargs.pop("cls", None)

        _request = build_mosaics_tile_json_operations_get_request(
            search_id=search_id,
            assets=assets,
            expression=expression,
            asset_bidx=asset_bidx,
            asset_as_band=asset_as_band,
            nodata=nodata,
            unscale=unscale,
            scan_limit=scan_limit,
            items_limit=items_limit,
            time_limit=time_limit,
            exitwhenfull=exitwhenfull,
            skipcovered=skipcovered,
            tile_matrix_set_id=tile_matrix_set_id,
            tile_format=tile_format,
            tile_scale=tile_scale,
            minzoom=minzoom,
            maxzoom=maxzoom,
            buffer=buffer,
            color_formula=color_formula,
            collection=collection,
            resampling=resampling,
            pixel_selection=pixel_selection,
            algorithm=algorithm,
            algorithm_params=algorithm_params,
            rescale=rescale,
            colormap_name=colormap_name,
            colormap=colormap,
            return_mask=return_mask,
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = kwargs.pop("stream", False)
        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                try:
                    response.read()  # Load the body in memory and close the socket
                except (StreamConsumedError, StreamClosedError):
                    pass
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if _stream:
            deserialized = response.iter_bytes()
        else:
            deserialized = _deserialize(_models.TileJsonResponse, response.json())

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore


class MosaicsTileMatrixSetsTileJsonOperations:
    """
    .. warning::
        **DO NOT** instantiate this class directly.

        Instead, you should access the following operations through
        :class:`~azure.planetarycomputer.PlanetaryComputerClient`'s
        :attr:`mosaics_tile_matrix_sets_tile_json` attribute.
    """

    def __init__(self, *args, **kwargs) -> None:
        input_args = list(args)
        self._client: PipelineClient = input_args.pop(0) if input_args else kwargs.pop("client")
        self._config: PlanetaryComputerClientConfiguration = input_args.pop(0) if input_args else kwargs.pop("config")
        self._serialize: Serializer = input_args.pop(0) if input_args else kwargs.pop("serializer")
        self._deserialize: Deserializer = input_args.pop(0) if input_args else kwargs.pop("deserializer")

    @distributed_trace
    def get(
        self,
        search_id: str,
        tile_matrix_set_id: str,
        *,
        assets: Optional[List[str]] = None,
        expression: Optional[str] = None,
        asset_bidx: Optional[List[str]] = None,
        asset_as_band: Optional[bool] = None,
        nodata: Optional[float] = None,
        unscale: Optional[bool] = None,
        scan_limit: Optional[int] = None,
        items_limit: Optional[int] = None,
        time_limit: Optional[int] = None,
        exitwhenfull: Optional[bool] = None,
        skipcovered: Optional[bool] = None,
        algorithm: Optional[Union[str, _models.Algorithm]] = None,
        algorithm_params: Optional[str] = None,
        minzoom: Optional[int] = None,
        maxzoom: Optional[int] = None,
        tile_format: Optional[Union[str, _models.ImageType]] = None,
        tile_scale: Optional[int] = None,
        buffer: Optional[str] = None,
        color_formula: Optional[str] = None,
        collection: Optional[str] = None,
        resampling: Optional[Union[str, _models.Resampling]] = None,
        pixel_selection: Optional[Union[str, _models.PixelSelection]] = None,
        rescale: Optional[List[str]] = None,
        colormap_name: Optional[Union[str, _models.ColorMapNames]] = None,
        colormap: Optional[str] = None,
        return_mask: Optional[bool] = None,
        **kwargs: Any,
    ) -> _models.TileJsonResponse:
        """Tilejson Tilematrixsetid As Path.

        Return TileJSON document for a searchId.

        :param search_id: Search Id (pgSTAC Search Hash). Required.
        :type search_id: str
        :param tile_matrix_set_id: Identifier selecting one of the TileMatrixSetId supported. Required.
        :type tile_matrix_set_id: str
        :keyword assets: Asset's names. Default value is None.
        :paramtype assets: list[str]
        :keyword expression: Band math expression between assets. Default value is None.
        :paramtype expression: str
        :keyword asset_bidx: Per asset band indexes (coma separated indexes). Default value is None.
        :paramtype asset_bidx: list[str]
        :keyword asset_as_band: Asset as Band. Default value is None.
        :paramtype asset_as_band: bool
        :keyword nodata: Overwrite internal Nodata value. Default value is None.
        :paramtype nodata: float
        :keyword unscale: Apply internal Scale or Offset. Default value is None.
        :paramtype unscale: bool
        :keyword scan_limit: Return as soon as we scan N items (defaults to 10000 in PgSTAC). Default
         value is None.
        :paramtype scan_limit: int
        :keyword items_limit: Return as soon as we have N items per geometry (defaults to 100 in
         PgSTAC). Default value is None.
        :paramtype items_limit: int
        :keyword time_limit: Return after N seconds to avoid long requests (defaults to 5 in PgSTAC).
         Default value is None.
        :paramtype time_limit: int
        :keyword exitwhenfull: Return as soon as the geometry is fully covered (defaults to True in
         PgSTAC). Default value is None.
        :paramtype exitwhenfull: bool
        :keyword skipcovered: Skip any items that would show up completely under the previous items
         (defaults
         to True in PgSTAC). Default value is None.
        :paramtype skipcovered: bool
        :keyword algorithm: Algorithm name. Known values are: "hillshade", "contours",
         "normalizedIndex", "terrarium", and "terrainrgb". Default value is None.
        :paramtype algorithm: str or ~azure.planetarycomputer.models.Algorithm
        :keyword algorithm_params: Algorithm parameter. Default value is None.
        :paramtype algorithm_params: str
        :keyword minzoom: Overwrite default minzoom. Default value is None.
        :paramtype minzoom: int
        :keyword maxzoom: Overwrite default maxzoom. Default value is None.
        :paramtype maxzoom: int
        :keyword tile_format: Default will be automatically defined if the output image needs a mask
         (png) or
         not (jpeg). Known values are: "png", "npy", "tif", "jpeg", "jpg", "jp2", "webp", and "pngraw".
         Default value is None.
        :paramtype tile_format: str or ~azure.planetarycomputer.models.ImageType
        :keyword tile_scale: Tile scale factor affecting output size. Values > 1 produce larger tiles
         (e.g., 1=256x256, 2=512x512). Default value is None.
        :paramtype tile_scale: int
        :keyword buffer: Buffer on each side of the given tile. It must be a multiple of ``0.5``.
         Output
         **tilesize** will be expanded to ``tilesize + 2 * buffer`` (e.g 0.5 = 257x257,
         1.0 = 258x258). Default value is None.
        :paramtype buffer: str
        :keyword color_formula: rio-color formula (info: `https://github.com/mapbox/rio-color
         <https://github.com/mapbox/rio-color>`_). Default value is None.
        :paramtype color_formula: str
        :keyword collection: STAC Collection ID. Default value is None.
        :paramtype collection: str
        :keyword resampling: Resampling method. Known values are: "nearest", "bilinear", "cubic",
         "cubic_spline", "lanczos", "average", "mode", "gauss", and "rms". Default value is None.
        :paramtype resampling: str or ~azure.planetarycomputer.models.Resampling
        :keyword pixel_selection: Pixel selection method. Known values are: "first", "highest",
         "lowest", "mean", "median", "stdev", "lastbandlow", and "lastbandhight". Default value is None.
        :paramtype pixel_selection: str or ~azure.planetarycomputer.models.PixelSelection
        :keyword rescale: comma (',') delimited Min,Max range. Can set multiple time for multiple
         bands. Default value is None.
        :paramtype rescale: list[str]
        :keyword colormap_name: Colormap name. Known values are: "accent", "accent_r", "afmhot",
         "afmhot_r", "ai4g-lulc", "alos-fnf", "alos-palsar-mask", "autumn", "autumn_r", "binary",
         "binary_r", "blues", "blues_r", "bone", "bone_r", "brbg", "brbg_r", "brg", "brg_r", "bugn",
         "bugn_r", "bupu", "bupu_r", "bwr", "bwr_r", "c-cap", "cfastie", "chesapeake-lc-13",
         "chesapeake-lc-7", "chesapeake-lu", "chloris-biomass", "cividis", "cividis_r", "cmrmap",
         "cmrmap_r", "cool", "cool_r", "coolwarm", "coolwarm_r", "copper", "copper_r", "cubehelix",
         "cubehelix_r", "dark2", "dark2_r", "drcog-lulc", "esa-cci-lc", "esa-worldcover", "flag",
         "flag_r", "gap-lulc", "gist_earth", "gist_earth_r", "gist_gray", "gist_gray_r", "gist_heat",
         "gist_heat_r", "gist_ncar", "gist_ncar_r", "gist_rainbow", "gist_rainbow_r", "gist_stern",
         "gist_stern_r", "gist_yarg", "gist_yarg_r", "gnbu", "gnbu_r", "gnuplot", "gnuplot2",
         "gnuplot2_r", "gnuplot_r", "gray", "gray_r", "greens", "greens_r", "greys", "greys_r", "hot",
         "hot_r", "hsv", "hsv_r", "inferno", "inferno_r", "io-bii", "io-lulc", "io-lulc-9-class", "jet",
         "jet_r", "jrc-change", "jrc-extent", "jrc-occurrence", "jrc-recurrence", "jrc-seasonality",
         "jrc-transitions", "lidar-classification", "lidar-hag", "lidar-hag-alternative",
         "lidar-intensity", "lidar-returns", "magma", "magma_r", "modis-10A1", "modis-10A2",
         "modis-13A1|Q1", "modis-14A1|A2", "modis-15A2H|A3H", "modis-16A3GF-ET", "modis-16A3GF-PET",
         "modis-17A2H|A2HGF", "modis-17A3HGF", "modis-64A1", "mtbs-severity", "nipy_spectral",
         "nipy_spectral_r", "nrcan-lulc", "ocean", "ocean_r", "oranges", "oranges_r", "orrd", "orrd_r",
         "paired", "paired_r", "pastel1", "pastel1_r", "pastel2", "pastel2_r", "pink", "pink_r", "piyg",
         "piyg_r", "plasma", "plasma_r", "prgn", "prgn_r", "prism", "prism_r", "pubu", "pubu_r",
         "pubugn", "pubugn_r", "puor", "puor_r", "purd", "purd_r", "purples", "purples_r", "qpe",
         "rainbow", "rainbow_r", "rdbu", "rdbu_r", "rdgy", "rdgy_r", "rdpu", "rdpu_r", "rdylbu",
         "rdylbu_r", "rdylgn", "rdylgn_r", "reds", "reds_r", "rplumbo", "schwarzwald", "seismic",
         "seismic_r", "set1", "set1_r", "set2", "set2_r", "set3", "set3_r", "spectral", "spectral_r",
         "spring", "spring_r", "summer", "summer_r", "tab10", "tab10_r", "tab20", "tab20_r", "tab20b",
         "tab20b_r", "tab20c", "tab20c_r", "terrain", "terrain_r", "twilight", "twilight_r",
         "twilight_shifted", "twilight_shifted_r", "usda-cdl", "usda-cdl-corn", "usda-cdl-cotton",
         "usda-cdl-soybeans", "usda-cdl-wheat", "usgs-lcmap", "viirs-10a1", "viirs-13a1", "viirs-14a1",
         "viirs-15a2H", "viridis", "viridis_r", "winter", "winter_r", "wistia", "wistia_r", "ylgn",
         "ylgn_r", "ylgnbu", "ylgnbu_r", "ylorbr", "ylorbr_r", "ylorrd", and "ylorrd_r". Default value
         is None.
        :paramtype colormap_name: str or ~azure.planetarycomputer.models.ColorMapNames
        :keyword colormap: JSON encoded custom Colormap. Default value is None.
        :paramtype colormap: str
        :keyword return_mask: Add mask to the output data. Default value is None.
        :paramtype return_mask: bool
        :return: TileJsonResponse. The TileJsonResponse is compatible with MutableMapping
        :rtype: ~azure.planetarycomputer.models.TileJsonResponse
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[_models.TileJsonResponse] = kwargs.pop("cls", None)

        _request = build_mosaics_tile_matrix_sets_tile_json_get_request(
            search_id=search_id,
            tile_matrix_set_id=tile_matrix_set_id,
            assets=assets,
            expression=expression,
            asset_bidx=asset_bidx,
            asset_as_band=asset_as_band,
            nodata=nodata,
            unscale=unscale,
            scan_limit=scan_limit,
            items_limit=items_limit,
            time_limit=time_limit,
            exitwhenfull=exitwhenfull,
            skipcovered=skipcovered,
            algorithm=algorithm,
            algorithm_params=algorithm_params,
            minzoom=minzoom,
            maxzoom=maxzoom,
            tile_format=tile_format,
            tile_scale=tile_scale,
            buffer=buffer,
            color_formula=color_formula,
            collection=collection,
            resampling=resampling,
            pixel_selection=pixel_selection,
            rescale=rescale,
            colormap_name=colormap_name,
            colormap=colormap,
            return_mask=return_mask,
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = kwargs.pop("stream", False)
        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                try:
                    response.read()  # Load the body in memory and close the socket
                except (StreamConsumedError, StreamClosedError):
                    pass
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if _stream:
            deserialized = response.iter_bytes()
        else:
            deserialized = _deserialize(_models.TileJsonResponse, response.json())

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore


class MosaicsWmtsMosaicsOperations:
    """
    .. warning::
        **DO NOT** instantiate this class directly.

        Instead, you should access the following operations through
        :class:`~azure.planetarycomputer.PlanetaryComputerClient`'s
        :attr:`mosaics_wmts_mosaics` attribute.
    """

    def __init__(self, *args, **kwargs) -> None:
        input_args = list(args)
        self._client: PipelineClient = input_args.pop(0) if input_args else kwargs.pop("client")
        self._config: PlanetaryComputerClientConfiguration = input_args.pop(0) if input_args else kwargs.pop("config")
        self._serialize: Serializer = input_args.pop(0) if input_args else kwargs.pop("serializer")
        self._deserialize: Deserializer = input_args.pop(0) if input_args else kwargs.pop("deserializer")

    @distributed_trace
    def get_capabilities_xml(
        self,
        search_id: str,
        *,
        assets: Optional[List[str]] = None,
        expression: Optional[str] = None,
        asset_bidx: Optional[List[str]] = None,
        asset_as_band: Optional[bool] = None,
        nodata: Optional[float] = None,
        unscale: Optional[bool] = None,
        algorithm: Optional[Union[str, _models.Algorithm]] = None,
        algorithm_params: Optional[str] = None,
        tile_matrix_set_id: Optional[Union[str, _models.Tilematrixsetid]] = None,
        tile_format: Optional[Union[str, _models.ImageType]] = None,
        tile_scale: Optional[int] = None,
        minzoom: Optional[int] = None,
        maxzoom: Optional[int] = None,
        buffer: Optional[str] = None,
        color_formula: Optional[str] = None,
        resampling: Optional[Union[str, _models.Resampling]] = None,
        rescale: Optional[List[str]] = None,
        colormap_name: Optional[Union[str, _models.ColorMapNames]] = None,
        colormap: Optional[str] = None,
        return_mask: Optional[bool] = None,
        **kwargs: Any,
    ) -> Optional[str]:
        """Wmts.

        OGC WMTS endpoint.

        :param search_id: Search Id (pgSTAC Search Hash). Required.
        :type search_id: str
        :keyword assets: Asset's names. Default value is None.
        :paramtype assets: list[str]
        :keyword expression: Band math expression between assets. Default value is None.
        :paramtype expression: str
        :keyword asset_bidx: Per asset band indexes (coma separated indexes). Default value is None.
        :paramtype asset_bidx: list[str]
        :keyword asset_as_band: Asset as Band. Default value is None.
        :paramtype asset_as_band: bool
        :keyword nodata: Overwrite internal Nodata value. Default value is None.
        :paramtype nodata: float
        :keyword unscale: Apply internal Scale or Offset. Default value is None.
        :paramtype unscale: bool
        :keyword algorithm: Algorithm name. Known values are: "hillshade", "contours",
         "normalizedIndex", "terrarium", and "terrainrgb". Default value is None.
        :paramtype algorithm: str or ~azure.planetarycomputer.models.Algorithm
        :keyword algorithm_params: Algorithm parameter. Default value is None.
        :paramtype algorithm_params: str
        :keyword tile_matrix_set_id: Identifier selecting one of the TileMatrixSetId supported
         (default:
         'WebMercatorQuad'). Known values are: "CanadianNAD83_LCC", "EuropeanETRS89_LAEAQuad",
         "LINZAntarticaMapTilegrid", "NZTM2000Quad", "UPSAntarcticWGS84Quad", "UPSArcticWGS84Quad",
         "UTM31WGS84Quad", "WGS1984Quad", "WebMercatorQuad", "WorldCRS84Quad", and
         "WorldMercatorWGS84Quad". Default value is None.
        :paramtype tile_matrix_set_id: str or ~azure.planetarycomputer.models.Tilematrixsetid
        :keyword tile_format: Output image type. Default is png. Known values are: "png", "npy", "tif",
         "jpeg", "jpg", "jp2", "webp", and "pngraw". Default value is None.
        :paramtype tile_format: str or ~azure.planetarycomputer.models.ImageType
        :keyword tile_scale: Tile scale factor affecting output size. Values > 1 produce larger tiles
         (e.g., 1=256x256, 2=512x512). Default value is None.
        :paramtype tile_scale: int
        :keyword minzoom: Overwrite default minzoom. Default value is None.
        :paramtype minzoom: int
        :keyword maxzoom: Overwrite default maxzoom. Default value is None.
        :paramtype maxzoom: int
        :keyword buffer: Buffer on each side of the given tile. It must be a multiple of ``0.5``.
         Output
         **tilesize** will be expanded to ``tilesize + 2 * buffer`` (e.g 0.5 = 257x257,
         1.0 = 258x258). Default value is None.
        :paramtype buffer: str
        :keyword color_formula: rio-color formula (info: `https://github.com/mapbox/rio-color
         <https://github.com/mapbox/rio-color>`_). Default value is None.
        :paramtype color_formula: str
        :keyword resampling: Resampling method. Known values are: "nearest", "bilinear", "cubic",
         "cubic_spline", "lanczos", "average", "mode", "gauss", and "rms". Default value is None.
        :paramtype resampling: str or ~azure.planetarycomputer.models.Resampling
        :keyword rescale: comma (',') delimited Min,Max range. Can set multiple time for multiple
         bands. Default value is None.
        :paramtype rescale: list[str]
        :keyword colormap_name: Colormap name. Known values are: "accent", "accent_r", "afmhot",
         "afmhot_r", "ai4g-lulc", "alos-fnf", "alos-palsar-mask", "autumn", "autumn_r", "binary",
         "binary_r", "blues", "blues_r", "bone", "bone_r", "brbg", "brbg_r", "brg", "brg_r", "bugn",
         "bugn_r", "bupu", "bupu_r", "bwr", "bwr_r", "c-cap", "cfastie", "chesapeake-lc-13",
         "chesapeake-lc-7", "chesapeake-lu", "chloris-biomass", "cividis", "cividis_r", "cmrmap",
         "cmrmap_r", "cool", "cool_r", "coolwarm", "coolwarm_r", "copper", "copper_r", "cubehelix",
         "cubehelix_r", "dark2", "dark2_r", "drcog-lulc", "esa-cci-lc", "esa-worldcover", "flag",
         "flag_r", "gap-lulc", "gist_earth", "gist_earth_r", "gist_gray", "gist_gray_r", "gist_heat",
         "gist_heat_r", "gist_ncar", "gist_ncar_r", "gist_rainbow", "gist_rainbow_r", "gist_stern",
         "gist_stern_r", "gist_yarg", "gist_yarg_r", "gnbu", "gnbu_r", "gnuplot", "gnuplot2",
         "gnuplot2_r", "gnuplot_r", "gray", "gray_r", "greens", "greens_r", "greys", "greys_r", "hot",
         "hot_r", "hsv", "hsv_r", "inferno", "inferno_r", "io-bii", "io-lulc", "io-lulc-9-class", "jet",
         "jet_r", "jrc-change", "jrc-extent", "jrc-occurrence", "jrc-recurrence", "jrc-seasonality",
         "jrc-transitions", "lidar-classification", "lidar-hag", "lidar-hag-alternative",
         "lidar-intensity", "lidar-returns", "magma", "magma_r", "modis-10A1", "modis-10A2",
         "modis-13A1|Q1", "modis-14A1|A2", "modis-15A2H|A3H", "modis-16A3GF-ET", "modis-16A3GF-PET",
         "modis-17A2H|A2HGF", "modis-17A3HGF", "modis-64A1", "mtbs-severity", "nipy_spectral",
         "nipy_spectral_r", "nrcan-lulc", "ocean", "ocean_r", "oranges", "oranges_r", "orrd", "orrd_r",
         "paired", "paired_r", "pastel1", "pastel1_r", "pastel2", "pastel2_r", "pink", "pink_r", "piyg",
         "piyg_r", "plasma", "plasma_r", "prgn", "prgn_r", "prism", "prism_r", "pubu", "pubu_r",
         "pubugn", "pubugn_r", "puor", "puor_r", "purd", "purd_r", "purples", "purples_r", "qpe",
         "rainbow", "rainbow_r", "rdbu", "rdbu_r", "rdgy", "rdgy_r", "rdpu", "rdpu_r", "rdylbu",
         "rdylbu_r", "rdylgn", "rdylgn_r", "reds", "reds_r", "rplumbo", "schwarzwald", "seismic",
         "seismic_r", "set1", "set1_r", "set2", "set2_r", "set3", "set3_r", "spectral", "spectral_r",
         "spring", "spring_r", "summer", "summer_r", "tab10", "tab10_r", "tab20", "tab20_r", "tab20b",
         "tab20b_r", "tab20c", "tab20c_r", "terrain", "terrain_r", "twilight", "twilight_r",
         "twilight_shifted", "twilight_shifted_r", "usda-cdl", "usda-cdl-corn", "usda-cdl-cotton",
         "usda-cdl-soybeans", "usda-cdl-wheat", "usgs-lcmap", "viirs-10a1", "viirs-13a1", "viirs-14a1",
         "viirs-15a2H", "viridis", "viridis_r", "winter", "winter_r", "wistia", "wistia_r", "ylgn",
         "ylgn_r", "ylgnbu", "ylgnbu_r", "ylorbr", "ylorbr_r", "ylorrd", and "ylorrd_r". Default value
         is None.
        :paramtype colormap_name: str or ~azure.planetarycomputer.models.ColorMapNames
        :keyword colormap: JSON encoded custom Colormap. Default value is None.
        :paramtype colormap: str
        :keyword return_mask: Add mask to the output data. Default value is None.
        :paramtype return_mask: bool
        :return: str or None
        :rtype: str or None
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[Optional[str]] = kwargs.pop("cls", None)

        _request = build_mosaics_wmts_mosaics_get_capabilities_xml_request(
            search_id=search_id,
            assets=assets,
            expression=expression,
            asset_bidx=asset_bidx,
            asset_as_band=asset_as_band,
            nodata=nodata,
            unscale=unscale,
            algorithm=algorithm,
            algorithm_params=algorithm_params,
            tile_matrix_set_id=tile_matrix_set_id,
            tile_format=tile_format,
            tile_scale=tile_scale,
            minzoom=minzoom,
            maxzoom=maxzoom,
            buffer=buffer,
            color_formula=color_formula,
            resampling=resampling,
            rescale=rescale,
            colormap_name=colormap_name,
            colormap=colormap,
            return_mask=return_mask,
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = kwargs.pop("stream", False)
        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200, 204]:
            if _stream:
                try:
                    response.read()  # Load the body in memory and close the socket
                except (StreamConsumedError, StreamClosedError):
                    pass
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        deserialized = None
        response_headers = {}
        if response.status_code == 200:
            response_headers["content-type"] = self._deserialize("str", response.headers.get("content-type"))

            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize_xml(str, response.text())

        if cls:
            return cls(pipeline_response, deserialized, response_headers)  # type: ignore

        return deserialized  # type: ignore


class MosaicsWmtsMosaicsTileMatrixSetsOperations:  # pylint: disable=name-too-long
    """
    .. warning::
        **DO NOT** instantiate this class directly.

        Instead, you should access the following operations through
        :class:`~azure.planetarycomputer.PlanetaryComputerClient`'s
        :attr:`mosaics_wmts_mosaics_tile_matrix_sets` attribute.
    """

    def __init__(self, *args, **kwargs) -> None:
        input_args = list(args)
        self._client: PipelineClient = input_args.pop(0) if input_args else kwargs.pop("client")
        self._config: PlanetaryComputerClientConfiguration = input_args.pop(0) if input_args else kwargs.pop("config")
        self._serialize: Serializer = input_args.pop(0) if input_args else kwargs.pop("serializer")
        self._deserialize: Deserializer = input_args.pop(0) if input_args else kwargs.pop("deserializer")

    @distributed_trace
    def get_capabilities_xml(
        self,
        search_id: str,
        tile_matrix_set_id: str,
        *,
        assets: Optional[List[str]] = None,
        expression: Optional[str] = None,
        asset_bidx: Optional[List[str]] = None,
        asset_as_band: Optional[bool] = None,
        nodata: Optional[float] = None,
        unscale: Optional[bool] = None,
        algorithm: Optional[Union[str, _models.Algorithm]] = None,
        algorithm_params: Optional[str] = None,
        tile_format: Optional[Union[str, _models.ImageType]] = None,
        tile_scale: Optional[int] = None,
        minzoom: Optional[int] = None,
        maxzoom: Optional[int] = None,
        buffer: Optional[str] = None,
        color_formula: Optional[str] = None,
        resampling: Optional[Union[str, _models.Resampling]] = None,
        rescale: Optional[List[str]] = None,
        colormap_name: Optional[Union[str, _models.ColorMapNames]] = None,
        colormap: Optional[str] = None,
        return_mask: Optional[bool] = None,
        **kwargs: Any,
    ) -> Optional[str]:
        """Wmts Tilematrixsetid As Path.

        OGC WMTS endpoint.

        :param search_id: Search Id (pgSTAC Search Hash). Required.
        :type search_id: str
        :param tile_matrix_set_id: Identifier selecting one of the TileMatrixSetId supported. Required.
        :type tile_matrix_set_id: str
        :keyword assets: Asset's names. Default value is None.
        :paramtype assets: list[str]
        :keyword expression: Band math expression between assets. Default value is None.
        :paramtype expression: str
        :keyword asset_bidx: Per asset band indexes (coma separated indexes). Default value is None.
        :paramtype asset_bidx: list[str]
        :keyword asset_as_band: Asset as Band. Default value is None.
        :paramtype asset_as_band: bool
        :keyword nodata: Overwrite internal Nodata value. Default value is None.
        :paramtype nodata: float
        :keyword unscale: Apply internal Scale or Offset. Default value is None.
        :paramtype unscale: bool
        :keyword algorithm: Algorithm name. Known values are: "hillshade", "contours",
         "normalizedIndex", "terrarium", and "terrainrgb". Default value is None.
        :paramtype algorithm: str or ~azure.planetarycomputer.models.Algorithm
        :keyword algorithm_params: Algorithm parameter. Default value is None.
        :paramtype algorithm_params: str
        :keyword tile_format: Output image type. Default is png. Known values are: "png", "npy", "tif",
         "jpeg", "jpg", "jp2", "webp", and "pngraw". Default value is None.
        :paramtype tile_format: str or ~azure.planetarycomputer.models.ImageType
        :keyword tile_scale: Tile scale factor affecting output size. Values > 1 produce larger tiles
         (e.g., 1=256x256, 2=512x512). Default value is None.
        :paramtype tile_scale: int
        :keyword minzoom: Overwrite default minzoom. Default value is None.
        :paramtype minzoom: int
        :keyword maxzoom: Overwrite default maxzoom. Default value is None.
        :paramtype maxzoom: int
        :keyword buffer: Buffer on each side of the given tile. It must be a multiple of ``0.5``.
         Output
         **tilesize** will be expanded to ``tilesize + 2 * buffer`` (e.g 0.5 = 257x257,
         1.0 = 258x258). Default value is None.
        :paramtype buffer: str
        :keyword color_formula: rio-color formula (info: `https://github.com/mapbox/rio-color
         <https://github.com/mapbox/rio-color>`_). Default value is None.
        :paramtype color_formula: str
        :keyword resampling: Resampling method. Known values are: "nearest", "bilinear", "cubic",
         "cubic_spline", "lanczos", "average", "mode", "gauss", and "rms". Default value is None.
        :paramtype resampling: str or ~azure.planetarycomputer.models.Resampling
        :keyword rescale: comma (',') delimited Min,Max range. Can set multiple time for multiple
         bands. Default value is None.
        :paramtype rescale: list[str]
        :keyword colormap_name: Colormap name. Known values are: "accent", "accent_r", "afmhot",
         "afmhot_r", "ai4g-lulc", "alos-fnf", "alos-palsar-mask", "autumn", "autumn_r", "binary",
         "binary_r", "blues", "blues_r", "bone", "bone_r", "brbg", "brbg_r", "brg", "brg_r", "bugn",
         "bugn_r", "bupu", "bupu_r", "bwr", "bwr_r", "c-cap", "cfastie", "chesapeake-lc-13",
         "chesapeake-lc-7", "chesapeake-lu", "chloris-biomass", "cividis", "cividis_r", "cmrmap",
         "cmrmap_r", "cool", "cool_r", "coolwarm", "coolwarm_r", "copper", "copper_r", "cubehelix",
         "cubehelix_r", "dark2", "dark2_r", "drcog-lulc", "esa-cci-lc", "esa-worldcover", "flag",
         "flag_r", "gap-lulc", "gist_earth", "gist_earth_r", "gist_gray", "gist_gray_r", "gist_heat",
         "gist_heat_r", "gist_ncar", "gist_ncar_r", "gist_rainbow", "gist_rainbow_r", "gist_stern",
         "gist_stern_r", "gist_yarg", "gist_yarg_r", "gnbu", "gnbu_r", "gnuplot", "gnuplot2",
         "gnuplot2_r", "gnuplot_r", "gray", "gray_r", "greens", "greens_r", "greys", "greys_r", "hot",
         "hot_r", "hsv", "hsv_r", "inferno", "inferno_r", "io-bii", "io-lulc", "io-lulc-9-class", "jet",
         "jet_r", "jrc-change", "jrc-extent", "jrc-occurrence", "jrc-recurrence", "jrc-seasonality",
         "jrc-transitions", "lidar-classification", "lidar-hag", "lidar-hag-alternative",
         "lidar-intensity", "lidar-returns", "magma", "magma_r", "modis-10A1", "modis-10A2",
         "modis-13A1|Q1", "modis-14A1|A2", "modis-15A2H|A3H", "modis-16A3GF-ET", "modis-16A3GF-PET",
         "modis-17A2H|A2HGF", "modis-17A3HGF", "modis-64A1", "mtbs-severity", "nipy_spectral",
         "nipy_spectral_r", "nrcan-lulc", "ocean", "ocean_r", "oranges", "oranges_r", "orrd", "orrd_r",
         "paired", "paired_r", "pastel1", "pastel1_r", "pastel2", "pastel2_r", "pink", "pink_r", "piyg",
         "piyg_r", "plasma", "plasma_r", "prgn", "prgn_r", "prism", "prism_r", "pubu", "pubu_r",
         "pubugn", "pubugn_r", "puor", "puor_r", "purd", "purd_r", "purples", "purples_r", "qpe",
         "rainbow", "rainbow_r", "rdbu", "rdbu_r", "rdgy", "rdgy_r", "rdpu", "rdpu_r", "rdylbu",
         "rdylbu_r", "rdylgn", "rdylgn_r", "reds", "reds_r", "rplumbo", "schwarzwald", "seismic",
         "seismic_r", "set1", "set1_r", "set2", "set2_r", "set3", "set3_r", "spectral", "spectral_r",
         "spring", "spring_r", "summer", "summer_r", "tab10", "tab10_r", "tab20", "tab20_r", "tab20b",
         "tab20b_r", "tab20c", "tab20c_r", "terrain", "terrain_r", "twilight", "twilight_r",
         "twilight_shifted", "twilight_shifted_r", "usda-cdl", "usda-cdl-corn", "usda-cdl-cotton",
         "usda-cdl-soybeans", "usda-cdl-wheat", "usgs-lcmap", "viirs-10a1", "viirs-13a1", "viirs-14a1",
         "viirs-15a2H", "viridis", "viridis_r", "winter", "winter_r", "wistia", "wistia_r", "ylgn",
         "ylgn_r", "ylgnbu", "ylgnbu_r", "ylorbr", "ylorbr_r", "ylorrd", and "ylorrd_r". Default value
         is None.
        :paramtype colormap_name: str or ~azure.planetarycomputer.models.ColorMapNames
        :keyword colormap: JSON encoded custom Colormap. Default value is None.
        :paramtype colormap: str
        :keyword return_mask: Add mask to the output data. Default value is None.
        :paramtype return_mask: bool
        :return: str or None
        :rtype: str or None
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[Optional[str]] = kwargs.pop("cls", None)

        _request = build_mosaics_wmts_mosaics_tile_matrix_sets_get_capabilities_xml_request(
            search_id=search_id,
            tile_matrix_set_id=tile_matrix_set_id,
            assets=assets,
            expression=expression,
            asset_bidx=asset_bidx,
            asset_as_band=asset_as_band,
            nodata=nodata,
            unscale=unscale,
            algorithm=algorithm,
            algorithm_params=algorithm_params,
            tile_format=tile_format,
            tile_scale=tile_scale,
            minzoom=minzoom,
            maxzoom=maxzoom,
            buffer=buffer,
            color_formula=color_formula,
            resampling=resampling,
            rescale=rescale,
            colormap_name=colormap_name,
            colormap=colormap,
            return_mask=return_mask,
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = kwargs.pop("stream", False)
        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200, 204]:
            if _stream:
                try:
                    response.read()  # Load the body in memory and close the socket
                except (StreamConsumedError, StreamClosedError):
                    pass
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        deserialized = None
        response_headers = {}
        if response.status_code == 200:
            response_headers["content-type"] = self._deserialize("str", response.headers.get("content-type"))

            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize_xml(str, response.text())

        if cls:
            return cls(pipeline_response, deserialized, response_headers)  # type: ignore

        return deserialized  # type: ignore


class MosaicsRegisterSearchOperations:
    """
    .. warning::
        **DO NOT** instantiate this class directly.

        Instead, you should access the following operations through
        :class:`~azure.planetarycomputer.PlanetaryComputerClient`'s
        :attr:`mosaics_register_search` attribute.
    """

    def __init__(self, *args, **kwargs) -> None:
        input_args = list(args)
        self._client: PipelineClient = input_args.pop(0) if input_args else kwargs.pop("client")
        self._config: PlanetaryComputerClientConfiguration = input_args.pop(0) if input_args else kwargs.pop("config")
        self._serialize: Serializer = input_args.pop(0) if input_args else kwargs.pop("serializer")
        self._deserialize: Deserializer = input_args.pop(0) if input_args else kwargs.pop("deserializer")

    @overload
    def register(
        self,
        *,
        content_type: str = "application/json",
        collections: Optional[List[str]] = None,
        ids: Optional[List[str]] = None,
        bbox: Optional[float] = None,
        intersects: Optional[_models.Geometry] = None,
        query: Optional[_models.StacQuery] = None,
        filter: Optional[_models.CqlFilter] = None,
        datetime: Optional[str] = None,
        sort_by: Optional[List[_models.SortExtension]] = None,
        filter_lang: Optional[Union[str, _models.FilterLang]] = None,
        metadata: Optional[_models.Metadata] = None,
        **kwargs: Any,
    ) -> _models.RegisterResponse:
        """Register Search.

        Register a Search query.

        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :keyword collections: List of STAC collection IDs to include in the mosaic. Default value is
         None.
        :paramtype collections: list[str]
        :keyword ids: List of specific STAC item IDs to include in the mosaic. Default value is None.
        :paramtype ids: list[str]
        :keyword bbox: Geographic bounding box to filter items [west, south, east, north]. Default
         value is None.
        :paramtype bbox: float
        :keyword intersects: GeoJSON geometry to spatially filter items by intersection. Default value
         is None.
        :paramtype intersects: ~azure.planetarycomputer.models.Geometry
        :keyword query: Query. Default value is None.
        :paramtype query: ~azure.planetarycomputer.models.StacQuery
        :keyword filter: Filter. Default value is None.
        :paramtype filter: ~azure.planetarycomputer.models.CqlFilter
        :keyword datetime: Temporal filter in RFC 3339 format or interval. Default value is None.
        :paramtype datetime: str
        :keyword sort_by: Criteria for ordering items in the mosaic. Default value is None.
        :paramtype sort_by: list[~azure.planetarycomputer.models.SortExtension]
        :keyword filter_lang: Query language format used in the filter parameter. Known values are:
         "cql-json", "cql2-json", and "cql2-text". Default value is None.
        :paramtype filter_lang: str or ~azure.planetarycomputer.models.FilterLang
        :keyword metadata: Additional metadata to associate with the mosaic. Default value is None.
        :paramtype metadata: ~azure.planetarycomputer.models.Metadata
        :return: RegisterResponse. The RegisterResponse is compatible with MutableMapping
        :rtype: ~azure.planetarycomputer.models.RegisterResponse
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @overload
    def register(
        self, body: JSON, *, content_type: str = "application/json", **kwargs: Any
    ) -> _models.RegisterResponse:
        """Register Search.

        Register a Search query.

        :param body: Required.
        :type body: JSON
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: RegisterResponse. The RegisterResponse is compatible with MutableMapping
        :rtype: ~azure.planetarycomputer.models.RegisterResponse
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @overload
    def register(
        self, body: IO[bytes], *, content_type: str = "application/json", **kwargs: Any
    ) -> _models.RegisterResponse:
        """Register Search.

        Register a Search query.

        :param body: Required.
        :type body: IO[bytes]
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: RegisterResponse. The RegisterResponse is compatible with MutableMapping
        :rtype: ~azure.planetarycomputer.models.RegisterResponse
        :raises ~azure.core.exceptions.HttpResponseError:
        """

    @distributed_trace
    def register(
        self,
        body: Union[JSON, IO[bytes]] = _Unset,
        *,
        collections: Optional[List[str]] = None,
        ids: Optional[List[str]] = None,
        bbox: Optional[float] = None,
        intersects: Optional[_models.Geometry] = None,
        query: Optional[_models.StacQuery] = None,
        filter: Optional[_models.CqlFilter] = None,
        datetime: Optional[str] = None,
        sort_by: Optional[List[_models.SortExtension]] = None,
        filter_lang: Optional[Union[str, _models.FilterLang]] = None,
        metadata: Optional[_models.Metadata] = None,
        **kwargs: Any,
    ) -> _models.RegisterResponse:
        """Register Search.

        Register a Search query.

        :param body: Is either a JSON type or a IO[bytes] type. Required.
        :type body: JSON or IO[bytes]
        :keyword collections: List of STAC collection IDs to include in the mosaic. Default value is
         None.
        :paramtype collections: list[str]
        :keyword ids: List of specific STAC item IDs to include in the mosaic. Default value is None.
        :paramtype ids: list[str]
        :keyword bbox: Geographic bounding box to filter items [west, south, east, north]. Default
         value is None.
        :paramtype bbox: float
        :keyword intersects: GeoJSON geometry to spatially filter items by intersection. Default value
         is None.
        :paramtype intersects: ~azure.planetarycomputer.models.Geometry
        :keyword query: Query. Default value is None.
        :paramtype query: ~azure.planetarycomputer.models.StacQuery
        :keyword filter: Filter. Default value is None.
        :paramtype filter: ~azure.planetarycomputer.models.CqlFilter
        :keyword datetime: Temporal filter in RFC 3339 format or interval. Default value is None.
        :paramtype datetime: str
        :keyword sort_by: Criteria for ordering items in the mosaic. Default value is None.
        :paramtype sort_by: list[~azure.planetarycomputer.models.SortExtension]
        :keyword filter_lang: Query language format used in the filter parameter. Known values are:
         "cql-json", "cql2-json", and "cql2-text". Default value is None.
        :paramtype filter_lang: str or ~azure.planetarycomputer.models.FilterLang
        :keyword metadata: Additional metadata to associate with the mosaic. Default value is None.
        :paramtype metadata: ~azure.planetarycomputer.models.Metadata
        :return: RegisterResponse. The RegisterResponse is compatible with MutableMapping
        :rtype: ~azure.planetarycomputer.models.RegisterResponse
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
        cls: ClsType[_models.RegisterResponse] = kwargs.pop("cls", None)

        if body is _Unset:
            body = {
                "bbox": bbox,
                "collections": collections,
                "datetime": datetime,
                "filter": filter,
                "filter_lang": filter_lang,
                "ids": ids,
                "intersects": intersects,
                "metadata": metadata,
                "query": query,
                "sortby": sort_by,
            }
            body = {k: v for k, v in body.items() if v is not None}
        content_type = content_type or "application/json"
        _content = None
        if isinstance(body, (IOBase, bytes)):
            _content = body
        else:
            _content = json.dumps(body, cls=SdkJSONEncoder, exclude_readonly=True)  # type: ignore

        _request = build_mosaics_register_search_register_request(
            content_type=content_type,
            api_version=self._config.api_version,
            content=_content,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = kwargs.pop("stream", False)
        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                try:
                    response.read()  # Load the body in memory and close the socket
                except (StreamConsumedError, StreamClosedError):
                    pass
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if _stream:
            deserialized = response.iter_bytes()
        else:
            deserialized = _deserialize(_models.RegisterResponse, response.json())

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore


class MosaicsInfoSearchOperations:
    """
    .. warning::
        **DO NOT** instantiate this class directly.

        Instead, you should access the following operations through
        :class:`~azure.planetarycomputer.PlanetaryComputerClient`'s
        :attr:`mosaics_info_search` attribute.
    """

    def __init__(self, *args, **kwargs) -> None:
        input_args = list(args)
        self._client: PipelineClient = input_args.pop(0) if input_args else kwargs.pop("client")
        self._config: PlanetaryComputerClientConfiguration = input_args.pop(0) if input_args else kwargs.pop("config")
        self._serialize: Serializer = input_args.pop(0) if input_args else kwargs.pop("serializer")
        self._deserialize: Deserializer = input_args.pop(0) if input_args else kwargs.pop("deserializer")

    @distributed_trace
    def get(self, search_id: str, **kwargs: Any) -> _models.TitilerPgstacModelInfo:
        """Info Search.

        Get Search query metadata.

        :param search_id: Search Id (pgSTAC Search Hash). Required.
        :type search_id: str
        :return: TitilerPgstacModelInfo. The TitilerPgstacModelInfo is compatible with MutableMapping
        :rtype: ~azure.planetarycomputer.models.TitilerPgstacModelInfo
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[_models.TitilerPgstacModelInfo] = kwargs.pop("cls", None)

        _request = build_mosaics_info_search_get_request(
            search_id=search_id,
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = kwargs.pop("stream", False)
        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                try:
                    response.read()  # Load the body in memory and close the socket
                except (StreamConsumedError, StreamClosedError):
                    pass
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if _stream:
            deserialized = response.iter_bytes()
        else:
            deserialized = _deserialize(_models.TitilerPgstacModelInfo, response.json())

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore


class MosaicsAssetsForTilesOperations:
    """
    .. warning::
        **DO NOT** instantiate this class directly.

        Instead, you should access the following operations through
        :class:`~azure.planetarycomputer.PlanetaryComputerClient`'s
        :attr:`mosaics_assets_for_tiles` attribute.
    """

    def __init__(self, *args, **kwargs) -> None:
        input_args = list(args)
        self._client: PipelineClient = input_args.pop(0) if input_args else kwargs.pop("client")
        self._config: PlanetaryComputerClientConfiguration = input_args.pop(0) if input_args else kwargs.pop("config")
        self._serialize: Serializer = input_args.pop(0) if input_args else kwargs.pop("serializer")
        self._deserialize: Deserializer = input_args.pop(0) if input_args else kwargs.pop("deserializer")

    @distributed_trace
    def get_zxy_assets(
        self,
        search_id: str,
        z: float,
        x: float,
        y: float,
        *,
        scan_limit: Optional[int] = None,
        items_limit: Optional[int] = None,
        time_limit: Optional[int] = None,
        exitwhenfull: Optional[bool] = None,
        skipcovered: Optional[bool] = None,
        tile_matrix_set_id: Optional[Union[str, _models.Tilematrixsetid]] = None,
        **kwargs: Any,
    ) -> Optional[List[Any]]:
        """Assets For Tile.

        Return a list of assets which overlap a given tile.

        :param search_id: Search Id (pgSTAC Search Hash). Required.
        :type search_id: str
        :param z: Identifier (Z) selecting one of the scales defined in the TileMatrixSet and
         representing the scaleDenominator the tile. Required.
        :type z: float
        :param x: Column (X) index of the tile on the selected TileMatrix. It cannot exceed the
         MatrixHeight-1 for the selected TileMatrix. Required.
        :type x: float
        :param y: Row (Y) index of the tile on the selected TileMatrix. It cannot exceed the
         MatrixWidth-1 for the selected TileMatrix. Required.
        :type y: float
        :keyword scan_limit: Return as soon as we scan N items (defaults to 10000 in PgSTAC). Default
         value is None.
        :paramtype scan_limit: int
        :keyword items_limit: Return as soon as we have N items per geometry (defaults to 100 in
         PgSTAC). Default value is None.
        :paramtype items_limit: int
        :keyword time_limit: Return after N seconds to avoid long requests (defaults to 5 in PgSTAC).
         Default value is None.
        :paramtype time_limit: int
        :keyword exitwhenfull: Return as soon as the geometry is fully covered (defaults to True in
         PgSTAC). Default value is None.
        :paramtype exitwhenfull: bool
        :keyword skipcovered: Skip any items that would show up completely under the previous items
         (defaults
         to True in PgSTAC). Default value is None.
        :paramtype skipcovered: bool
        :keyword tile_matrix_set_id: Identifier selecting one of the TileMatrixSetId supported
         (default:
         'WebMercatorQuad'). Known values are: "CanadianNAD83_LCC", "EuropeanETRS89_LAEAQuad",
         "LINZAntarticaMapTilegrid", "NZTM2000Quad", "UPSAntarcticWGS84Quad", "UPSArcticWGS84Quad",
         "UTM31WGS84Quad", "WGS1984Quad", "WebMercatorQuad", "WorldCRS84Quad", and
         "WorldMercatorWGS84Quad". Default value is None.
        :paramtype tile_matrix_set_id: str or ~azure.planetarycomputer.models.Tilematrixsetid
        :return: list of any or None
        :rtype: list[any] or None
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[Optional[List[Any]]] = kwargs.pop("cls", None)

        _request = build_mosaics_assets_for_tiles_get_zxy_assets_request(
            search_id=search_id,
            z=z,
            x=x,
            y=y,
            scan_limit=scan_limit,
            items_limit=items_limit,
            time_limit=time_limit,
            exitwhenfull=exitwhenfull,
            skipcovered=skipcovered,
            tile_matrix_set_id=tile_matrix_set_id,
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = kwargs.pop("stream", False)
        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200, 204]:
            if _stream:
                try:
                    response.read()  # Load the body in memory and close the socket
                except (StreamConsumedError, StreamClosedError):
                    pass
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        deserialized = None
        if response.status_code == 200:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(List[Any], response.json())

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore


class MosaicsAssetsForTileMatrixSetsOperations:
    """
    .. warning::
        **DO NOT** instantiate this class directly.

        Instead, you should access the following operations through
        :class:`~azure.planetarycomputer.PlanetaryComputerClient`'s
        :attr:`mosaics_assets_for_tile_matrix_sets` attribute.
    """

    def __init__(self, *args, **kwargs) -> None:
        input_args = list(args)
        self._client: PipelineClient = input_args.pop(0) if input_args else kwargs.pop("client")
        self._config: PlanetaryComputerClientConfiguration = input_args.pop(0) if input_args else kwargs.pop("config")
        self._serialize: Serializer = input_args.pop(0) if input_args else kwargs.pop("serializer")
        self._deserialize: Deserializer = input_args.pop(0) if input_args else kwargs.pop("deserializer")

    @distributed_trace
    def get_zxy_assets(
        self,
        search_id: str,
        tile_matrix_set_id: str,
        z: float,
        x: float,
        y: float,
        *,
        scan_limit: Optional[int] = None,
        items_limit: Optional[int] = None,
        time_limit: Optional[int] = None,
        exitwhenfull: Optional[bool] = None,
        skipcovered: Optional[bool] = None,
        **kwargs: Any,
    ) -> Optional[List[Any]]:
        """Assets For Tile Tilematrixsetid As Path.

        Return a list of assets which overlap a given tile.

        :param search_id: Search Id (pgSTAC Search Hash). Required.
        :type search_id: str
        :param tile_matrix_set_id: Identifier selecting one of the TileMatrixSetId supported. Required.
        :type tile_matrix_set_id: str
        :param z: Identifier (Z) selecting one of the scales defined in the TileMatrixSet and
         representing the scaleDenominator the tile. Required.
        :type z: float
        :param x: Column (X) index of the tile on the selected TileMatrix. It cannot exceed the
         MatrixHeight-1 for the selected TileMatrix. Required.
        :type x: float
        :param y: Row (Y) index of the tile on the selected TileMatrix. It cannot exceed the
         MatrixWidth-1 for the selected TileMatrix. Required.
        :type y: float
        :keyword scan_limit: Return as soon as we scan N items (defaults to 10000 in PgSTAC). Default
         value is None.
        :paramtype scan_limit: int
        :keyword items_limit: Return as soon as we have N items per geometry (defaults to 100 in
         PgSTAC). Default value is None.
        :paramtype items_limit: int
        :keyword time_limit: Return after N seconds to avoid long requests (defaults to 5 in PgSTAC).
         Default value is None.
        :paramtype time_limit: int
        :keyword exitwhenfull: Return as soon as the geometry is fully covered (defaults to True in
         PgSTAC). Default value is None.
        :paramtype exitwhenfull: bool
        :keyword skipcovered: Skip any items that would show up completely under the previous items
         (defaults
         to True in PgSTAC). Default value is None.
        :paramtype skipcovered: bool
        :return: list of any or None
        :rtype: list[any] or None
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[Optional[List[Any]]] = kwargs.pop("cls", None)

        _request = build_mosaics_assets_for_tile_matrix_sets_get_zxy_assets_request(
            search_id=search_id,
            tile_matrix_set_id=tile_matrix_set_id,
            z=z,
            x=x,
            y=y,
            scan_limit=scan_limit,
            items_limit=items_limit,
            time_limit=time_limit,
            exitwhenfull=exitwhenfull,
            skipcovered=skipcovered,
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = kwargs.pop("stream", False)
        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200, 204]:
            if _stream:
                try:
                    response.read()  # Load the body in memory and close the socket
                except (StreamConsumedError, StreamClosedError):
                    pass
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        deserialized = None
        if response.status_code == 200:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(List[Any], response.json())

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore


class MosaicsAssetsForPointsOperations:
    """
    .. warning::
        **DO NOT** instantiate this class directly.

        Instead, you should access the following operations through
        :class:`~azure.planetarycomputer.PlanetaryComputerClient`'s
        :attr:`mosaics_assets_for_points` attribute.
    """

    def __init__(self, *args, **kwargs) -> None:
        input_args = list(args)
        self._client: PipelineClient = input_args.pop(0) if input_args else kwargs.pop("client")
        self._config: PlanetaryComputerClientConfiguration = input_args.pop(0) if input_args else kwargs.pop("config")
        self._serialize: Serializer = input_args.pop(0) if input_args else kwargs.pop("serializer")
        self._deserialize: Deserializer = input_args.pop(0) if input_args else kwargs.pop("deserializer")

    @distributed_trace
    def get_lon_lat_assets(
        self,
        search_id: str,
        lon: float,
        lat: float,
        *,
        scan_limit: Optional[int] = None,
        items_limit: Optional[int] = None,
        time_limit: Optional[int] = None,
        exitwhenfull: Optional[bool] = None,
        skipcovered: Optional[bool] = None,
        coord_crs: Optional[str] = None,
        **kwargs: Any,
    ) -> Optional[List[Any]]:
        """Assets For Point.

        Return a list of assets for a given point.

        :param search_id: Search Id (pgSTAC Search Hash). Required.
        :type search_id: str
        :param lon: Longitude. Required.
        :type lon: float
        :param lat: Latitude. Required.
        :type lat: float
        :keyword scan_limit: Return as soon as we scan N items (defaults to 10000 in PgSTAC). Default
         value is None.
        :paramtype scan_limit: int
        :keyword items_limit: Return as soon as we have N items per geometry (defaults to 100 in
         PgSTAC). Default value is None.
        :paramtype items_limit: int
        :keyword time_limit: Return after N seconds to avoid long requests (defaults to 5 in PgSTAC).
         Default value is None.
        :paramtype time_limit: int
        :keyword exitwhenfull: Return as soon as the geometry is fully covered (defaults to True in
         PgSTAC). Default value is None.
        :paramtype exitwhenfull: bool
        :keyword skipcovered: Skip any items that would show up completely under the previous items
         (defaults
         to True in PgSTAC). Default value is None.
        :paramtype skipcovered: bool
        :keyword coord_crs: Coordinate Reference System of the input coords. Default to ``epsg:4326``.
         Default value is None.
        :paramtype coord_crs: str
        :return: list of any or None
        :rtype: list[any] or None
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[Optional[List[Any]]] = kwargs.pop("cls", None)

        _request = build_mosaics_assets_for_points_get_lon_lat_assets_request(
            search_id=search_id,
            lon=lon,
            lat=lat,
            scan_limit=scan_limit,
            items_limit=items_limit,
            time_limit=time_limit,
            exitwhenfull=exitwhenfull,
            skipcovered=skipcovered,
            coord_crs=coord_crs,
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = kwargs.pop("stream", False)
        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200, 204]:
            if _stream:
                try:
                    response.read()  # Load the body in memory and close the socket
                except (StreamConsumedError, StreamClosedError):
                    pass
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        deserialized = None
        if response.status_code == 200:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(List[Any], response.json())

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore


class TileMatrixListOperations:
    """
    .. warning::
        **DO NOT** instantiate this class directly.

        Instead, you should access the following operations through
        :class:`~azure.planetarycomputer.PlanetaryComputerClient`'s
        :attr:`tile_matrix_list` attribute.
    """

    def __init__(self, *args, **kwargs) -> None:
        input_args = list(args)
        self._client: PipelineClient = input_args.pop(0) if input_args else kwargs.pop("client")
        self._config: PlanetaryComputerClientConfiguration = input_args.pop(0) if input_args else kwargs.pop("config")
        self._serialize: Serializer = input_args.pop(0) if input_args else kwargs.pop("serializer")
        self._deserialize: Deserializer = input_args.pop(0) if input_args else kwargs.pop("deserializer")

    @distributed_trace
    def get(self, **kwargs: Any) -> Optional[List[str]]:
        """Matrix List.

        Return Matrix List.

        :return: list of str or None
        :rtype: list[str] or None
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[Optional[List[str]]] = kwargs.pop("cls", None)

        _request = build_tile_matrix_list_get_request(
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = kwargs.pop("stream", False)
        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200, 204]:
            if _stream:
                try:
                    response.read()  # Load the body in memory and close the socket
                except (StreamConsumedError, StreamClosedError):
                    pass
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        deserialized = None
        if response.status_code == 200:
            if _stream:
                deserialized = response.iter_bytes()
            else:
                deserialized = _deserialize(List[str], response.json())

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore


class TileMatrixDefinitionsOperations:
    """
    .. warning::
        **DO NOT** instantiate this class directly.

        Instead, you should access the following operations through
        :class:`~azure.planetarycomputer.PlanetaryComputerClient`'s
        :attr:`tile_matrix_definitions` attribute.
    """

    def __init__(self, *args, **kwargs) -> None:
        input_args = list(args)
        self._client: PipelineClient = input_args.pop(0) if input_args else kwargs.pop("client")
        self._config: PlanetaryComputerClientConfiguration = input_args.pop(0) if input_args else kwargs.pop("config")
        self._serialize: Serializer = input_args.pop(0) if input_args else kwargs.pop("serializer")
        self._deserialize: Deserializer = input_args.pop(0) if input_args else kwargs.pop("deserializer")

    @distributed_trace
    def get(self, tile_matrix_set_id: str, **kwargs: Any) -> _models.TileMatrixSet:
        """Matrix Definition.

        Return Matrix Definition.

        :param tile_matrix_set_id: Identifier selecting one of the TileMatrixSetId supported. Required.
        :type tile_matrix_set_id: str
        :return: TileMatrixSet. The TileMatrixSet is compatible with MutableMapping
        :rtype: ~azure.planetarycomputer.models.TileMatrixSet
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[_models.TileMatrixSet] = kwargs.pop("cls", None)

        _request = build_tile_matrix_definitions_get_request(
            tile_matrix_set_id=tile_matrix_set_id,
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = kwargs.pop("stream", False)
        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                try:
                    response.read()  # Load the body in memory and close the socket
                except (StreamConsumedError, StreamClosedError):
                    pass
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if _stream:
            deserialized = response.iter_bytes()
        else:
            deserialized = _deserialize(_models.TileMatrixSet, response.json())

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore


class SasOperations:
    """
    .. warning::
        **DO NOT** instantiate this class directly.

        Instead, you should access the following operations through
        :class:`~azure.planetarycomputer.PlanetaryComputerClient`'s
        :attr:`sas` attribute.
    """

    def __init__(self, *args, **kwargs) -> None:
        input_args = list(args)
        self._client: PipelineClient = input_args.pop(0) if input_args else kwargs.pop("client")
        self._config: PlanetaryComputerClientConfiguration = input_args.pop(0) if input_args else kwargs.pop("config")
        self._serialize: Serializer = input_args.pop(0) if input_args else kwargs.pop("serializer")
        self._deserialize: Deserializer = input_args.pop(0) if input_args else kwargs.pop("deserializer")

    @distributed_trace
    def get_token(self, collection_id: str, *, duration: Optional[int] = None, **kwargs: Any) -> _models.SasToken:
        """generate a SAS Token for the given Azure Blob storage account and container.

        Generate a `SAS Token
        <https://docs.microsoft.com/en-us/azure/storage/common/storage-sas-overview#how-a-shared-access-signature-works>`_
        for the given storage account and container. The storage account and container
        must be associated with a Planetary Computer dataset indexed by the STAC API.

        :param collection_id: Collection Id. Required.
        :type collection_id: str
        :keyword duration: Duration. Default value is None.
        :paramtype duration: int
        :return: SasToken. The SasToken is compatible with MutableMapping
        :rtype: ~azure.planetarycomputer.models.SasToken
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[_models.SasToken] = kwargs.pop("cls", None)

        _request = build_sas_get_token_request(
            collection_id=collection_id,
            duration=duration,
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = kwargs.pop("stream", False)
        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                try:
                    response.read()  # Load the body in memory and close the socket
                except (StreamConsumedError, StreamClosedError):
                    pass
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if _stream:
            deserialized = response.iter_bytes()
        else:
            deserialized = _deserialize(_models.SasToken, response.json())

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore

    @distributed_trace
    def revoke_token(  # pylint: disable=inconsistent-return-statements
        self, *, duration: Optional[int] = None, **kwargs: Any
    ) -> None:
        """revoke a SAS Token for the given Azure Blob storage account.

        Revoke a `SAS Token
        <https://docs.microsoft.com/en-us/azure/storage/common/storage-sas-overview#how-a-shared-access-signature-works>`_
        for managed storage account of this GeoCatalog.

        :keyword duration: Duration. Default value is None.
        :paramtype duration: int
        :return: None
        :rtype: None
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[None] = kwargs.pop("cls", None)

        _request = build_sas_revoke_token_request(
            duration=duration,
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = False
        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if cls:
            return cls(pipeline_response, None, {})  # type: ignore

    @distributed_trace
    def get_sign(self, *, href: str, duration: Optional[int] = None, **kwargs: Any) -> _models.UnsignedLink:
        """sign an HREF in the format of a URL and returns a SingedLink.

        Signs a HREF (a link URL) by appending a `SAS Token
        <https://docs.microsoft.com/en-us/azure/storage/common/storage-sas-overview#how-a-shared-access-signature-works>`_.
        If the HREF is not a Azure Blob Storage HREF, then pass back the HREF unsigned.

        :keyword href: Href. Required.
        :paramtype href: str
        :keyword duration: Duration. Default value is None.
        :paramtype duration: int
        :return: UnsignedLink. The UnsignedLink is compatible with MutableMapping
        :rtype: ~azure.planetarycomputer.models.UnsignedLink
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[_models.UnsignedLink] = kwargs.pop("cls", None)

        _request = build_sas_get_sign_request(
            href=href,
            duration=duration,
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = kwargs.pop("stream", False)
        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                try:
                    response.read()  # Load the body in memory and close the socket
                except (StreamConsumedError, StreamClosedError):
                    pass
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if _stream:
            deserialized = response.iter_bytes()
        else:
            deserialized = _deserialize(_models.UnsignedLink, response.json())

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore


class IngestionsIngestionRunsOperations:
    """
    .. warning::
        **DO NOT** instantiate this class directly.

        Instead, you should access the following operations through
        :class:`~azure.planetarycomputer.PlanetaryComputerClient`'s
        :attr:`ingestion_runs` attribute.
    """

    def __init__(self, *args, **kwargs) -> None:
        input_args = list(args)
        self._client: PipelineClient = input_args.pop(0) if input_args else kwargs.pop("client")
        self._config: PlanetaryComputerClientConfiguration = input_args.pop(0) if input_args else kwargs.pop("config")
        self._serialize: Serializer = input_args.pop(0) if input_args else kwargs.pop("serializer")
        self._deserialize: Deserializer = input_args.pop(0) if input_args else kwargs.pop("deserializer")

    @distributed_trace
    def list_all(
        self,
        collection_id: str,
        ingestion_id: str,
        *,
        top: Optional[int] = None,
        skip: Optional[int] = None,
        **kwargs: Any,
    ) -> _models.IngestionRunsPagedResponse:
        """Get the runs of an ingestion.

        :param collection_id: Catalog collection id. Required.
        :type collection_id: str
        :param ingestion_id: Ingestion id. Required.
        :type ingestion_id: str
        :keyword top: The number of items to return. Default value is None.
        :paramtype top: int
        :keyword skip: The number of items to skip. Default value is None.
        :paramtype skip: int
        :return: IngestionRunsPagedResponse. The IngestionRunsPagedResponse is compatible with
         MutableMapping
        :rtype: ~azure.planetarycomputer.models.IngestionRunsPagedResponse
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[_models.IngestionRunsPagedResponse] = kwargs.pop("cls", None)

        _request = build_ingestions_ingestion_runs_list_all_request(
            collection_id=collection_id,
            ingestion_id=ingestion_id,
            top=top,
            skip=skip,
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = kwargs.pop("stream", False)
        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                try:
                    response.read()  # Load the body in memory and close the socket
                except (StreamConsumedError, StreamClosedError):
                    pass
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if _stream:
            deserialized = response.iter_bytes()
        else:
            deserialized = _deserialize(_models.IngestionRunsPagedResponse, response.json())

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore

    @distributed_trace
    def create(self, collection_id: str, ingestion_id: str, **kwargs: Any) -> _models.IngestionRun:
        """Create a new run of an ingestion.

        :param collection_id: Catalog collection id. Required.
        :type collection_id: str
        :param ingestion_id: Ingestion id. Required.
        :type ingestion_id: str
        :return: IngestionRun. The IngestionRun is compatible with MutableMapping
        :rtype: ~azure.planetarycomputer.models.IngestionRun
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[_models.IngestionRun] = kwargs.pop("cls", None)

        _request = build_ingestions_ingestion_runs_create_request(
            collection_id=collection_id,
            ingestion_id=ingestion_id,
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = kwargs.pop("stream", False)
        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [201]:
            if _stream:
                try:
                    response.read()  # Load the body in memory and close the socket
                except (StreamConsumedError, StreamClosedError):
                    pass
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        response_headers = {}
        response_headers["location"] = self._deserialize("str", response.headers.get("location"))

        if _stream:
            deserialized = response.iter_bytes()
        else:
            deserialized = _deserialize(_models.IngestionRun, response.json())

        if cls:
            return cls(pipeline_response, deserialized, response_headers)  # type: ignore

        return deserialized  # type: ignore

    @distributed_trace
    def get(self, collection_id: str, ingestion_id: str, run_id: str, **kwargs: Any) -> _models.IngestionRun:
        """Get a run of an ingestion.

        :param collection_id: Catalog collection id. Required.
        :type collection_id: str
        :param ingestion_id: Ingestion id. Required.
        :type ingestion_id: str
        :param run_id: Run id. Required.
        :type run_id: str
        :return: IngestionRun. The IngestionRun is compatible with MutableMapping
        :rtype: ~azure.planetarycomputer.models.IngestionRun
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[_models.IngestionRun] = kwargs.pop("cls", None)

        _request = build_ingestions_ingestion_runs_get_request(
            collection_id=collection_id,
            ingestion_id=ingestion_id,
            run_id=run_id,
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, "str", skip_quote=True),
        }
        _request.url = self._client.format_url(_request.url, **path_format_arguments)

        _stream = kwargs.pop("stream", False)
        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
            _request, stream=_stream, **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            if _stream:
                try:
                    response.read()  # Load the body in memory and close the socket
                except (StreamConsumedError, StreamClosedError):
                    pass
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if _stream:
            deserialized = response.iter_bytes()
        else:
            deserialized = _deserialize(_models.IngestionRun, response.json())

        if cls:
            return cls(pipeline_response, deserialized, {})  # type: ignore

        return deserialized  # type: ignore
