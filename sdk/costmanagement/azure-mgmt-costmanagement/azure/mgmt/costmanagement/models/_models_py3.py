# coding=utf-8
# --------------------------------------------------------------------------
# Copyright (c) Microsoft Corporation. All rights reserved.
# Licensed under the MIT License. See License.txt in the project root for
# license information.
#
# Code generated by Microsoft (R) AutoRest Code Generator.
# Changes may cause incorrect behavior and will be lost if the code is
# regenerated.
# --------------------------------------------------------------------------

from msrest.serialization import Model
from msrest.exceptions import HttpOperationError


class Resource(Model):
    """The Resource model definition.

    Variables are only populated by the server, and will be ignored when
    sending a request.

    :ivar id: Resource Id.
    :vartype id: str
    :ivar name: Resource name.
    :vartype name: str
    :ivar type: Resource type.
    :vartype type: str
    :ivar tags: Resource tags.
    :vartype tags: dict[str, str]
    """

    _validation = {
        'id': {'readonly': True},
        'name': {'readonly': True},
        'type': {'readonly': True},
        'tags': {'readonly': True},
    }

    _attribute_map = {
        'id': {'key': 'id', 'type': 'str'},
        'name': {'key': 'name', 'type': 'str'},
        'type': {'key': 'type', 'type': 'str'},
        'tags': {'key': 'tags', 'type': '{str}'},
    }

    def __init__(self, **kwargs) -> None:
        super(Resource, self).__init__(**kwargs)
        self.id = None
        self.name = None
        self.type = None
        self.tags = None


class Alert(Resource):
    """An individual alert.

    Variables are only populated by the server, and will be ignored when
    sending a request.

    :ivar id: Resource Id.
    :vartype id: str
    :ivar name: Resource name.
    :vartype name: str
    :ivar type: Resource type.
    :vartype type: str
    :ivar tags: Resource tags.
    :vartype tags: dict[str, str]
    :param definition: defines the type of alert
    :type definition:
     ~azure.mgmt.costmanagement.models.AlertPropertiesDefinition
    :param description: Alert description
    :type description: str
    :param source: Source of alert. Possible values include: 'Preset', 'User'
    :type source: str or ~azure.mgmt.costmanagement.models.AlertSource
    :param details: Alert details
    :type details: ~azure.mgmt.costmanagement.models.AlertPropertiesDetails
    :param cost_entity_id: related budget
    :type cost_entity_id: str
    :param status: alert status. Possible values include: 'None', 'Active',
     'Overridden', 'Resolved', 'Dismissed'
    :type status: str or ~azure.mgmt.costmanagement.models.AlertStatus
    :param creation_time: dateTime in which alert was created
    :type creation_time: str
    :param close_time: dateTime in which alert was closed
    :type close_time: str
    :param modification_time: dateTime in which alert was last modified
    :type modification_time: str
    :param status_modification_user_name:
    :type status_modification_user_name: str
    :param status_modification_time: dateTime in which the alert status was
     last modified
    :type status_modification_time: str
    """

    _validation = {
        'id': {'readonly': True},
        'name': {'readonly': True},
        'type': {'readonly': True},
        'tags': {'readonly': True},
    }

    _attribute_map = {
        'id': {'key': 'id', 'type': 'str'},
        'name': {'key': 'name', 'type': 'str'},
        'type': {'key': 'type', 'type': 'str'},
        'tags': {'key': 'tags', 'type': '{str}'},
        'definition': {'key': 'properties.definition', 'type': 'AlertPropertiesDefinition'},
        'description': {'key': 'properties.description', 'type': 'str'},
        'source': {'key': 'properties.source', 'type': 'str'},
        'details': {'key': 'properties.details', 'type': 'AlertPropertiesDetails'},
        'cost_entity_id': {'key': 'properties.costEntityId', 'type': 'str'},
        'status': {'key': 'properties.status', 'type': 'str'},
        'creation_time': {'key': 'properties.creationTime', 'type': 'str'},
        'close_time': {'key': 'properties.closeTime', 'type': 'str'},
        'modification_time': {'key': 'properties.modificationTime', 'type': 'str'},
        'status_modification_user_name': {'key': 'properties.statusModificationUserName', 'type': 'str'},
        'status_modification_time': {'key': 'properties.statusModificationTime', 'type': 'str'},
    }

    def __init__(self, *, definition=None, description: str=None, source=None, details=None, cost_entity_id: str=None, status=None, creation_time: str=None, close_time: str=None, modification_time: str=None, status_modification_user_name: str=None, status_modification_time: str=None, **kwargs) -> None:
        super(Alert, self).__init__(**kwargs)
        self.definition = definition
        self.description = description
        self.source = source
        self.details = details
        self.cost_entity_id = cost_entity_id
        self.status = status
        self.creation_time = creation_time
        self.close_time = close_time
        self.modification_time = modification_time
        self.status_modification_user_name = status_modification_user_name
        self.status_modification_time = status_modification_time


class AlertPropertiesDefinition(Model):
    """defines the type of alert.

    :param type: type of alert. Possible values include: 'Budget', 'Invoice',
     'Credit', 'Quota', 'General', 'xCloud', 'BudgetForecast'
    :type type: str or ~azure.mgmt.costmanagement.models.AlertType
    :param category: Alert category. Possible values include: 'Cost', 'Usage',
     'Billing', 'System'
    :type category: str or ~azure.mgmt.costmanagement.models.AlertCategory
    :param criteria: Criteria that triggered alert. Possible values include:
     'CostThresholdExceeded', 'UsageThresholdExceeded',
     'CreditThresholdApproaching', 'CreditThresholdReached',
     'QuotaThresholdApproaching', 'QuotaThresholdReached', 'MultiCurrency',
     'ForecastCostThresholdExceeded', 'ForecastUsageThresholdExceeded',
     'InvoiceDueDateApproaching', 'InvoiceDueDateReached',
     'CrossCloudNewDataAvailable', 'CrossCloudCollectionError',
     'GeneralThresholdError'
    :type criteria: str or ~azure.mgmt.costmanagement.models.AlertCriteria
    """

    _attribute_map = {
        'type': {'key': 'type', 'type': 'str'},
        'category': {'key': 'category', 'type': 'str'},
        'criteria': {'key': 'criteria', 'type': 'str'},
    }

    def __init__(self, *, type=None, category=None, criteria=None, **kwargs) -> None:
        super(AlertPropertiesDefinition, self).__init__(**kwargs)
        self.type = type
        self.category = category
        self.criteria = criteria


class AlertPropertiesDetails(Model):
    """Alert details.

    :param time_grain_type: Type of timegrain cadence. Possible values
     include: 'None', 'Monthly', 'Quarterly', 'Annually', 'BillingMonth',
     'BillingQuarter', 'BillingAnnual'
    :type time_grain_type: str or
     ~azure.mgmt.costmanagement.models.AlertTimeGrainType
    :param period_start_date: datetime of periodStartDate
    :type period_start_date: str
    :param triggered_by: notificationId that triggered this alert
    :type triggered_by: str
    :param resource_group_filter: array of resourceGroups to filter by
    :type resource_group_filter: list[object]
    :param resource_filter: array of resources to filter by
    :type resource_filter: list[object]
    :param meter_filter: array of meters to filter by
    :type meter_filter: list[object]
    :param tag_filter: tags to filter by
    :type tag_filter: object
    :param threshold: notification threshold percentage as a decimal which
     activated this alert
    :type threshold: decimal.Decimal
    :param operator: operator used to compare currentSpend with amount.
     Possible values include: 'None', 'EqualTo', 'GreaterThan',
     'GreaterThanOrEqualTo', 'LessThan', 'LessThanOrEqualTo'
    :type operator: str or ~azure.mgmt.costmanagement.models.AlertOperator
    :param amount: budget threshold amount
    :type amount: decimal.Decimal
    :param unit: unit of currency being used
    :type unit: str
    :param current_spend: current spend
    :type current_spend: decimal.Decimal
    :param contact_emails: list of emails to contact
    :type contact_emails: list[str]
    :param contact_groups: list of action groups to broadcast to
    :type contact_groups: list[str]
    :param contact_roles: list of contact roles
    :type contact_roles: list[str]
    :param overriding_alert: overriding alert
    :type overriding_alert: str
    """

    _attribute_map = {
        'time_grain_type': {'key': 'timeGrainType', 'type': 'str'},
        'period_start_date': {'key': 'periodStartDate', 'type': 'str'},
        'triggered_by': {'key': 'triggeredBy', 'type': 'str'},
        'resource_group_filter': {'key': 'resourceGroupFilter', 'type': '[object]'},
        'resource_filter': {'key': 'resourceFilter', 'type': '[object]'},
        'meter_filter': {'key': 'meterFilter', 'type': '[object]'},
        'tag_filter': {'key': 'tagFilter', 'type': 'object'},
        'threshold': {'key': 'threshold', 'type': 'decimal'},
        'operator': {'key': 'operator', 'type': 'str'},
        'amount': {'key': 'amount', 'type': 'decimal'},
        'unit': {'key': 'unit', 'type': 'str'},
        'current_spend': {'key': 'currentSpend', 'type': 'decimal'},
        'contact_emails': {'key': 'contactEmails', 'type': '[str]'},
        'contact_groups': {'key': 'contactGroups', 'type': '[str]'},
        'contact_roles': {'key': 'contactRoles', 'type': '[str]'},
        'overriding_alert': {'key': 'overridingAlert', 'type': 'str'},
    }

    def __init__(self, *, time_grain_type=None, period_start_date: str=None, triggered_by: str=None, resource_group_filter=None, resource_filter=None, meter_filter=None, tag_filter=None, threshold=None, operator=None, amount=None, unit: str=None, current_spend=None, contact_emails=None, contact_groups=None, contact_roles=None, overriding_alert: str=None, **kwargs) -> None:
        super(AlertPropertiesDetails, self).__init__(**kwargs)
        self.time_grain_type = time_grain_type
        self.period_start_date = period_start_date
        self.triggered_by = triggered_by
        self.resource_group_filter = resource_group_filter
        self.resource_filter = resource_filter
        self.meter_filter = meter_filter
        self.tag_filter = tag_filter
        self.threshold = threshold
        self.operator = operator
        self.amount = amount
        self.unit = unit
        self.current_spend = current_spend
        self.contact_emails = contact_emails
        self.contact_groups = contact_groups
        self.contact_roles = contact_roles
        self.overriding_alert = overriding_alert


class AlertsResult(Model):
    """Result of alerts.

    Variables are only populated by the server, and will be ignored when
    sending a request.

    :ivar value: List of alerts.
    :vartype value: list[~azure.mgmt.costmanagement.models.Alert]
    :ivar next_link: URL to get the next set of alerts results if there are
     any.
    :vartype next_link: str
    """

    _validation = {
        'value': {'readonly': True},
        'next_link': {'readonly': True},
    }

    _attribute_map = {
        'value': {'key': 'value', 'type': '[Alert]'},
        'next_link': {'key': 'nextLink', 'type': 'str'},
    }

    def __init__(self, **kwargs) -> None:
        super(AlertsResult, self).__init__(**kwargs)
        self.value = None
        self.next_link = None


class CloudError(Model):
    """CloudError.
    """

    _attribute_map = {
    }


class CommonExportProperties(Model):
    """The common properties of the export.

    Variables are only populated by the server, and will be ignored when
    sending a request.

    All required parameters must be populated in order to send to Azure.

    :param format: The format of the export being delivered. Currently only
     'Csv' is supported. Possible values include: 'Csv'
    :type format: str or ~azure.mgmt.costmanagement.models.FormatType
    :param delivery_info: Required. Has delivery information for the export.
    :type delivery_info: ~azure.mgmt.costmanagement.models.ExportDeliveryInfo
    :param definition: Required. Has the definition for the export.
    :type definition: ~azure.mgmt.costmanagement.models.ExportDefinition
    :param run_history: If requested, has the most recent execution history
     for the export.
    :type run_history:
     ~azure.mgmt.costmanagement.models.ExportExecutionListResult
    :ivar next_run_time_estimate: If the export has an active schedule,
     provides an estimate of the next execution time.
    :vartype next_run_time_estimate: datetime
    """

    _validation = {
        'delivery_info': {'required': True},
        'definition': {'required': True},
        'next_run_time_estimate': {'readonly': True},
    }

    _attribute_map = {
        'format': {'key': 'format', 'type': 'str'},
        'delivery_info': {'key': 'deliveryInfo', 'type': 'ExportDeliveryInfo'},
        'definition': {'key': 'definition', 'type': 'ExportDefinition'},
        'run_history': {'key': 'runHistory', 'type': 'ExportExecutionListResult'},
        'next_run_time_estimate': {'key': 'nextRunTimeEstimate', 'type': 'iso-8601'},
    }

    def __init__(self, *, delivery_info, definition, format=None, run_history=None, **kwargs) -> None:
        super(CommonExportProperties, self).__init__(**kwargs)
        self.format = format
        self.delivery_info = delivery_info
        self.definition = definition
        self.run_history = run_history
        self.next_run_time_estimate = None


class Dimension(Resource):
    """Dimension.

    Variables are only populated by the server, and will be ignored when
    sending a request.

    :ivar id: Resource Id.
    :vartype id: str
    :ivar name: Resource name.
    :vartype name: str
    :ivar type: Resource type.
    :vartype type: str
    :ivar tags: Resource tags.
    :vartype tags: dict[str, str]
    :ivar description: Dimension description.
    :vartype description: str
    :ivar filter_enabled: Filter enabled.
    :vartype filter_enabled: bool
    :ivar grouping_enabled: Grouping enabled.
    :vartype grouping_enabled: bool
    :param data:
    :type data: list[str]
    :ivar total: Total number of data for the dimension.
    :vartype total: int
    :ivar category: Dimension category.
    :vartype category: str
    :ivar usage_start: Usage start.
    :vartype usage_start: datetime
    :ivar usage_end: Usage end.
    :vartype usage_end: datetime
    :ivar next_link: The link (url) to the next page of results.
    :vartype next_link: str
    """

    _validation = {
        'id': {'readonly': True},
        'name': {'readonly': True},
        'type': {'readonly': True},
        'tags': {'readonly': True},
        'description': {'readonly': True},
        'filter_enabled': {'readonly': True},
        'grouping_enabled': {'readonly': True},
        'total': {'readonly': True},
        'category': {'readonly': True},
        'usage_start': {'readonly': True},
        'usage_end': {'readonly': True},
        'next_link': {'readonly': True},
    }

    _attribute_map = {
        'id': {'key': 'id', 'type': 'str'},
        'name': {'key': 'name', 'type': 'str'},
        'type': {'key': 'type', 'type': 'str'},
        'tags': {'key': 'tags', 'type': '{str}'},
        'description': {'key': 'properties.description', 'type': 'str'},
        'filter_enabled': {'key': 'properties.filterEnabled', 'type': 'bool'},
        'grouping_enabled': {'key': 'properties.groupingEnabled', 'type': 'bool'},
        'data': {'key': 'properties.data', 'type': '[str]'},
        'total': {'key': 'properties.total', 'type': 'int'},
        'category': {'key': 'properties.category', 'type': 'str'},
        'usage_start': {'key': 'properties.usageStart', 'type': 'iso-8601'},
        'usage_end': {'key': 'properties.usageEnd', 'type': 'iso-8601'},
        'next_link': {'key': 'properties.nextLink', 'type': 'str'},
    }

    def __init__(self, *, data=None, **kwargs) -> None:
        super(Dimension, self).__init__(**kwargs)
        self.description = None
        self.filter_enabled = None
        self.grouping_enabled = None
        self.data = data
        self.total = None
        self.category = None
        self.usage_start = None
        self.usage_end = None
        self.next_link = None


class DismissAlertPayload(Model):
    """The request payload to update an alert.

    :param definition: defines the type of alert
    :type definition:
     ~azure.mgmt.costmanagement.models.AlertPropertiesDefinition
    :param description: Alert description
    :type description: str
    :param source: Source of alert. Possible values include: 'Preset', 'User'
    :type source: str or ~azure.mgmt.costmanagement.models.AlertSource
    :param details: Alert details
    :type details: ~azure.mgmt.costmanagement.models.AlertPropertiesDetails
    :param cost_entity_id: related budget
    :type cost_entity_id: str
    :param status: alert status. Possible values include: 'None', 'Active',
     'Overridden', 'Resolved', 'Dismissed'
    :type status: str or ~azure.mgmt.costmanagement.models.AlertStatus
    :param creation_time: dateTime in which alert was created
    :type creation_time: str
    :param close_time: dateTime in which alert was closed
    :type close_time: str
    :param modification_time: dateTime in which alert was last modified
    :type modification_time: str
    :param status_modification_user_name:
    :type status_modification_user_name: str
    :param status_modification_time: dateTime in which the alert status was
     last modified
    :type status_modification_time: str
    """

    _attribute_map = {
        'definition': {'key': 'properties.definition', 'type': 'AlertPropertiesDefinition'},
        'description': {'key': 'properties.description', 'type': 'str'},
        'source': {'key': 'properties.source', 'type': 'str'},
        'details': {'key': 'properties.details', 'type': 'AlertPropertiesDetails'},
        'cost_entity_id': {'key': 'properties.costEntityId', 'type': 'str'},
        'status': {'key': 'properties.status', 'type': 'str'},
        'creation_time': {'key': 'properties.creationTime', 'type': 'str'},
        'close_time': {'key': 'properties.closeTime', 'type': 'str'},
        'modification_time': {'key': 'properties.modificationTime', 'type': 'str'},
        'status_modification_user_name': {'key': 'properties.statusModificationUserName', 'type': 'str'},
        'status_modification_time': {'key': 'properties.statusModificationTime', 'type': 'str'},
    }

    def __init__(self, *, definition=None, description: str=None, source=None, details=None, cost_entity_id: str=None, status=None, creation_time: str=None, close_time: str=None, modification_time: str=None, status_modification_user_name: str=None, status_modification_time: str=None, **kwargs) -> None:
        super(DismissAlertPayload, self).__init__(**kwargs)
        self.definition = definition
        self.description = description
        self.source = source
        self.details = details
        self.cost_entity_id = cost_entity_id
        self.status = status
        self.creation_time = creation_time
        self.close_time = close_time
        self.modification_time = modification_time
        self.status_modification_user_name = status_modification_user_name
        self.status_modification_time = status_modification_time


class ErrorDetails(Model):
    """The details of the error.

    Variables are only populated by the server, and will be ignored when
    sending a request.

    :ivar code: Error code.
    :vartype code: str
    :ivar message: Error message indicating why the operation failed.
    :vartype message: str
    """

    _validation = {
        'code': {'readonly': True},
        'message': {'readonly': True},
    }

    _attribute_map = {
        'code': {'key': 'code', 'type': 'str'},
        'message': {'key': 'message', 'type': 'str'},
    }

    def __init__(self, **kwargs) -> None:
        super(ErrorDetails, self).__init__(**kwargs)
        self.code = None
        self.message = None


class ErrorResponse(Model):
    """Error response indicates that the service is not able to process the
    incoming request. The reason is provided in the error message.
    Some Error responses:
    * 429 TooManyRequests - Request is throttled. Retry after waiting for the
    time specified in the "x-ms-ratelimit-microsoft.consumption-retry-after"
    header.
    * 503 ServiceUnavailable - Service is temporarily unavailable. Retry after
    waiting for the time specified in the "Retry-After" header.

    :param error: The details of the error.
    :type error: ~azure.mgmt.costmanagement.models.ErrorDetails
    """

    _attribute_map = {
        'error': {'key': 'error', 'type': 'ErrorDetails'},
    }

    def __init__(self, *, error=None, **kwargs) -> None:
        super(ErrorResponse, self).__init__(**kwargs)
        self.error = error


class ErrorResponseException(HttpOperationError):
    """Server responsed with exception of type: 'ErrorResponse'.

    :param deserialize: A deserializer
    :param response: Server response to be deserialized.
    """

    def __init__(self, deserialize, response, *args):

        super(ErrorResponseException, self).__init__(deserialize, response, 'ErrorResponse', *args)


class ProxyResource(Model):
    """The Resource model definition.

    Variables are only populated by the server, and will be ignored when
    sending a request.

    :ivar id: Resource Id.
    :vartype id: str
    :ivar name: Resource name.
    :vartype name: str
    :ivar type: Resource type.
    :vartype type: str
    :param e_tag: eTag of the resource. To handle concurrent update scenario,
     this field will be used to determine whether the user is updating the
     latest version or not.
    :type e_tag: str
    """

    _validation = {
        'id': {'readonly': True},
        'name': {'readonly': True},
        'type': {'readonly': True},
    }

    _attribute_map = {
        'id': {'key': 'id', 'type': 'str'},
        'name': {'key': 'name', 'type': 'str'},
        'type': {'key': 'type', 'type': 'str'},
        'e_tag': {'key': 'eTag', 'type': 'str'},
    }

    def __init__(self, *, e_tag: str=None, **kwargs) -> None:
        super(ProxyResource, self).__init__(**kwargs)
        self.id = None
        self.name = None
        self.type = None
        self.e_tag = e_tag


class Export(ProxyResource):
    """An export resource.

    Variables are only populated by the server, and will be ignored when
    sending a request.

    All required parameters must be populated in order to send to Azure.

    :ivar id: Resource Id.
    :vartype id: str
    :ivar name: Resource name.
    :vartype name: str
    :ivar type: Resource type.
    :vartype type: str
    :param e_tag: eTag of the resource. To handle concurrent update scenario,
     this field will be used to determine whether the user is updating the
     latest version or not.
    :type e_tag: str
    :param format: The format of the export being delivered. Currently only
     'Csv' is supported. Possible values include: 'Csv'
    :type format: str or ~azure.mgmt.costmanagement.models.FormatType
    :param delivery_info: Required. Has delivery information for the export.
    :type delivery_info: ~azure.mgmt.costmanagement.models.ExportDeliveryInfo
    :param definition: Required. Has the definition for the export.
    :type definition: ~azure.mgmt.costmanagement.models.ExportDefinition
    :param run_history: If requested, has the most recent execution history
     for the export.
    :type run_history:
     ~azure.mgmt.costmanagement.models.ExportExecutionListResult
    :ivar next_run_time_estimate: If the export has an active schedule,
     provides an estimate of the next execution time.
    :vartype next_run_time_estimate: datetime
    :param schedule: Has schedule information for the export.
    :type schedule: ~azure.mgmt.costmanagement.models.ExportSchedule
    """

    _validation = {
        'id': {'readonly': True},
        'name': {'readonly': True},
        'type': {'readonly': True},
        'delivery_info': {'required': True},
        'definition': {'required': True},
        'next_run_time_estimate': {'readonly': True},
    }

    _attribute_map = {
        'id': {'key': 'id', 'type': 'str'},
        'name': {'key': 'name', 'type': 'str'},
        'type': {'key': 'type', 'type': 'str'},
        'e_tag': {'key': 'eTag', 'type': 'str'},
        'format': {'key': 'properties.format', 'type': 'str'},
        'delivery_info': {'key': 'properties.deliveryInfo', 'type': 'ExportDeliveryInfo'},
        'definition': {'key': 'properties.definition', 'type': 'ExportDefinition'},
        'run_history': {'key': 'properties.runHistory', 'type': 'ExportExecutionListResult'},
        'next_run_time_estimate': {'key': 'properties.nextRunTimeEstimate', 'type': 'iso-8601'},
        'schedule': {'key': 'properties.schedule', 'type': 'ExportSchedule'},
    }

    def __init__(self, *, delivery_info, definition, e_tag: str=None, format=None, run_history=None, schedule=None, **kwargs) -> None:
        super(Export, self).__init__(e_tag=e_tag, **kwargs)
        self.format = format
        self.delivery_info = delivery_info
        self.definition = definition
        self.run_history = run_history
        self.next_run_time_estimate = None
        self.schedule = schedule


class ExportDataset(Model):
    """The definition for data in the export.

    :param granularity: The granularity of rows in the export. Currently only
     'Daily' is supported. Possible values include: 'Daily'
    :type granularity: str or
     ~azure.mgmt.costmanagement.models.GranularityType
    :param configuration: The export dataset configuration.
    :type configuration:
     ~azure.mgmt.costmanagement.models.ExportDatasetConfiguration
    """

    _attribute_map = {
        'granularity': {'key': 'granularity', 'type': 'str'},
        'configuration': {'key': 'configuration', 'type': 'ExportDatasetConfiguration'},
    }

    def __init__(self, *, granularity=None, configuration=None, **kwargs) -> None:
        super(ExportDataset, self).__init__(**kwargs)
        self.granularity = granularity
        self.configuration = configuration


class ExportDatasetConfiguration(Model):
    """The export dataset configuration. Allows columns to be selected for the
    export. If not provided then the export will include all available columns.

    :param columns: Array of column names to be included in the export. If not
     provided then the export will include all available columns. The available
     columns can vary by customer channel (see examples).
    :type columns: list[str]
    """

    _attribute_map = {
        'columns': {'key': 'columns', 'type': '[str]'},
    }

    def __init__(self, *, columns=None, **kwargs) -> None:
        super(ExportDatasetConfiguration, self).__init__(**kwargs)
        self.columns = columns


class ExportDefinition(Model):
    """The definition of an export.

    All required parameters must be populated in order to send to Azure.

    :param type: Required. The type of the export. Note that 'Usage' is
     equivalent to 'ActualCost' and is applicable to exports that do not yet
     provide data for charges or amortization for service reservations.
     Possible values include: 'Usage', 'ActualCost', 'AmortizedCost'
    :type type: str or ~azure.mgmt.costmanagement.models.ExportType
    :param timeframe: Required. The time frame for pulling data for the
     export. If custom, then a specific time period must be provided. Possible
     values include: 'MonthToDate', 'BillingMonthToDate', 'TheLastMonth',
     'TheLastBillingMonth', 'WeekToDate', 'Custom'
    :type timeframe: str or ~azure.mgmt.costmanagement.models.TimeframeType
    :param time_period: Has time period for pulling data for the export.
    :type time_period: ~azure.mgmt.costmanagement.models.ExportTimePeriod
    :param data_set: The definition for data in the export.
    :type data_set: ~azure.mgmt.costmanagement.models.ExportDataset
    """

    _validation = {
        'type': {'required': True},
        'timeframe': {'required': True},
    }

    _attribute_map = {
        'type': {'key': 'type', 'type': 'str'},
        'timeframe': {'key': 'timeframe', 'type': 'str'},
        'time_period': {'key': 'timePeriod', 'type': 'ExportTimePeriod'},
        'data_set': {'key': 'dataSet', 'type': 'ExportDataset'},
    }

    def __init__(self, *, type, timeframe, time_period=None, data_set=None, **kwargs) -> None:
        super(ExportDefinition, self).__init__(**kwargs)
        self.type = type
        self.timeframe = timeframe
        self.time_period = time_period
        self.data_set = data_set


class ExportDeliveryDestination(Model):
    """The destination information for the delivery of the export. To allow access
    to a storage account, you must register the account's subscription with the
    Microsoft.CostManagementExports resource provider. This is required once
    per subscription. When creating an export in the Azure portal, it is done
    automatically, however API users need to register the subscription. For
    more information see
    https://docs.microsoft.com/en-us/azure/azure-resource-manager/resource-manager-supported-services
    .

    All required parameters must be populated in order to send to Azure.

    :param resource_id: Required. The resource id of the storage account where
     exports will be delivered.
    :type resource_id: str
    :param container: Required. The name of the container where exports will
     be uploaded.
    :type container: str
    :param root_folder_path: The name of the directory where exports will be
     uploaded.
    :type root_folder_path: str
    """

    _validation = {
        'resource_id': {'required': True},
        'container': {'required': True},
    }

    _attribute_map = {
        'resource_id': {'key': 'resourceId', 'type': 'str'},
        'container': {'key': 'container', 'type': 'str'},
        'root_folder_path': {'key': 'rootFolderPath', 'type': 'str'},
    }

    def __init__(self, *, resource_id: str, container: str, root_folder_path: str=None, **kwargs) -> None:
        super(ExportDeliveryDestination, self).__init__(**kwargs)
        self.resource_id = resource_id
        self.container = container
        self.root_folder_path = root_folder_path


class ExportDeliveryInfo(Model):
    """The delivery information associated with a export.

    All required parameters must be populated in order to send to Azure.

    :param destination: Required. Has destination for the export being
     delivered.
    :type destination:
     ~azure.mgmt.costmanagement.models.ExportDeliveryDestination
    """

    _validation = {
        'destination': {'required': True},
    }

    _attribute_map = {
        'destination': {'key': 'destination', 'type': 'ExportDeliveryDestination'},
    }

    def __init__(self, *, destination, **kwargs) -> None:
        super(ExportDeliveryInfo, self).__init__(**kwargs)
        self.destination = destination


class ExportExecution(Resource):
    """An export execution.

    Variables are only populated by the server, and will be ignored when
    sending a request.

    :ivar id: Resource Id.
    :vartype id: str
    :ivar name: Resource name.
    :vartype name: str
    :ivar type: Resource type.
    :vartype type: str
    :ivar tags: Resource tags.
    :vartype tags: dict[str, str]
    :param execution_type: The type of the export execution. Possible values
     include: 'OnDemand', 'Scheduled'
    :type execution_type: str or
     ~azure.mgmt.costmanagement.models.ExecutionType
    :param status: The last known status of the export execution. Possible
     values include: 'Queued', 'InProgress', 'Completed', 'Failed', 'Timeout',
     'NewDataNotAvailable', 'DataNotAvailable'
    :type status: str or ~azure.mgmt.costmanagement.models.ExecutionStatus
    :param submitted_by: The identifier for the entity that executed the
     export. For OnDemand executions it is the user email. For scheduled
     executions it is 'System'.
    :type submitted_by: str
    :param submitted_time: The time when export was queued to be executed.
    :type submitted_time: datetime
    :param processing_start_time: The time when export was picked up to be
     executed.
    :type processing_start_time: datetime
    :param processing_end_time: The time when the export execution finished.
    :type processing_end_time: datetime
    :param file_name: The name of the exported file.
    :type file_name: str
    :param run_settings: The export settings that were in effect for this
     execution.
    :type run_settings:
     ~azure.mgmt.costmanagement.models.CommonExportProperties
    :param error: The details of any error.
    :type error: ~azure.mgmt.costmanagement.models.ErrorDetails
    """

    _validation = {
        'id': {'readonly': True},
        'name': {'readonly': True},
        'type': {'readonly': True},
        'tags': {'readonly': True},
    }

    _attribute_map = {
        'id': {'key': 'id', 'type': 'str'},
        'name': {'key': 'name', 'type': 'str'},
        'type': {'key': 'type', 'type': 'str'},
        'tags': {'key': 'tags', 'type': '{str}'},
        'execution_type': {'key': 'properties.executionType', 'type': 'str'},
        'status': {'key': 'properties.status', 'type': 'str'},
        'submitted_by': {'key': 'properties.submittedBy', 'type': 'str'},
        'submitted_time': {'key': 'properties.submittedTime', 'type': 'iso-8601'},
        'processing_start_time': {'key': 'properties.processingStartTime', 'type': 'iso-8601'},
        'processing_end_time': {'key': 'properties.processingEndTime', 'type': 'iso-8601'},
        'file_name': {'key': 'properties.fileName', 'type': 'str'},
        'run_settings': {'key': 'properties.runSettings', 'type': 'CommonExportProperties'},
        'error': {'key': 'properties.error', 'type': 'ErrorDetails'},
    }

    def __init__(self, *, execution_type=None, status=None, submitted_by: str=None, submitted_time=None, processing_start_time=None, processing_end_time=None, file_name: str=None, run_settings=None, error=None, **kwargs) -> None:
        super(ExportExecution, self).__init__(**kwargs)
        self.execution_type = execution_type
        self.status = status
        self.submitted_by = submitted_by
        self.submitted_time = submitted_time
        self.processing_start_time = processing_start_time
        self.processing_end_time = processing_end_time
        self.file_name = file_name
        self.run_settings = run_settings
        self.error = error


class ExportExecutionListResult(Model):
    """Result of listing the execution history of an export.

    Variables are only populated by the server, and will be ignored when
    sending a request.

    :ivar value: A list of export executions.
    :vartype value: list[~azure.mgmt.costmanagement.models.ExportExecution]
    """

    _validation = {
        'value': {'readonly': True},
    }

    _attribute_map = {
        'value': {'key': 'value', 'type': '[ExportExecution]'},
    }

    def __init__(self, **kwargs) -> None:
        super(ExportExecutionListResult, self).__init__(**kwargs)
        self.value = None


class ExportListResult(Model):
    """Result of listing exports. It contains a list of available exports in the
    scope provided.

    Variables are only populated by the server, and will be ignored when
    sending a request.

    :ivar value: The list of exports.
    :vartype value: list[~azure.mgmt.costmanagement.models.Export]
    """

    _validation = {
        'value': {'readonly': True},
    }

    _attribute_map = {
        'value': {'key': 'value', 'type': '[Export]'},
    }

    def __init__(self, **kwargs) -> None:
        super(ExportListResult, self).__init__(**kwargs)
        self.value = None


class ExportRecurrencePeriod(Model):
    """The start and end date for recurrence schedule.

    All required parameters must be populated in order to send to Azure.

    :param from_property: Required. The start date of recurrence.
    :type from_property: datetime
    :param to: The end date of recurrence.
    :type to: datetime
    """

    _validation = {
        'from_property': {'required': True},
    }

    _attribute_map = {
        'from_property': {'key': 'from', 'type': 'iso-8601'},
        'to': {'key': 'to', 'type': 'iso-8601'},
    }

    def __init__(self, *, from_property, to=None, **kwargs) -> None:
        super(ExportRecurrencePeriod, self).__init__(**kwargs)
        self.from_property = from_property
        self.to = to


class ExportSchedule(Model):
    """The schedule associated with the export.

    All required parameters must be populated in order to send to Azure.

    :param status: The status of the export's schedule. If 'Inactive', the
     export's schedule is paused. Possible values include: 'Active', 'Inactive'
    :type status: str or ~azure.mgmt.costmanagement.models.StatusType
    :param recurrence: Required. The schedule recurrence. Possible values
     include: 'Daily', 'Weekly', 'Monthly', 'Annually'
    :type recurrence: str or ~azure.mgmt.costmanagement.models.RecurrenceType
    :param recurrence_period: Has start and end date of the recurrence. The
     start date must be in future. If present, the end date must be greater
     than start date.
    :type recurrence_period:
     ~azure.mgmt.costmanagement.models.ExportRecurrencePeriod
    """

    _validation = {
        'recurrence': {'required': True},
    }

    _attribute_map = {
        'status': {'key': 'status', 'type': 'str'},
        'recurrence': {'key': 'recurrence', 'type': 'str'},
        'recurrence_period': {'key': 'recurrencePeriod', 'type': 'ExportRecurrencePeriod'},
    }

    def __init__(self, *, recurrence, status=None, recurrence_period=None, **kwargs) -> None:
        super(ExportSchedule, self).__init__(**kwargs)
        self.status = status
        self.recurrence = recurrence
        self.recurrence_period = recurrence_period


class ExportTimePeriod(Model):
    """The date range for data in the export. This should only be specified with
    timeFrame set to 'Custom'. The maximum date range is 3 months.

    All required parameters must be populated in order to send to Azure.

    :param from_property: Required. The start date for export data.
    :type from_property: datetime
    :param to: Required. The end date for export data.
    :type to: datetime
    """

    _validation = {
        'from_property': {'required': True},
        'to': {'required': True},
    }

    _attribute_map = {
        'from_property': {'key': 'from', 'type': 'iso-8601'},
        'to': {'key': 'to', 'type': 'iso-8601'},
    }

    def __init__(self, *, from_property, to, **kwargs) -> None:
        super(ExportTimePeriod, self).__init__(**kwargs)
        self.from_property = from_property
        self.to = to


class ForecastDataset(Model):
    """The definition of data present in the forecast.

    :param granularity: The granularity of rows in the forecast. Possible
     values include: 'Daily'
    :type granularity: str or
     ~azure.mgmt.costmanagement.models.GranularityType
    :param configuration: Has configuration information for the data in the
     export. The configuration will be ignored if aggregation and grouping are
     provided.
    :type configuration:
     ~azure.mgmt.costmanagement.models.QueryDatasetConfiguration
    :param aggregation: Dictionary of aggregation expression to use in the
     forecast. The key of each item in the dictionary is the alias for the
     aggregated column. forecast can have up to 2 aggregation clauses.
    :type aggregation: dict[str,
     ~azure.mgmt.costmanagement.models.QueryAggregation]
    :param filter: Has filter expression to use in the forecast.
    :type filter: ~azure.mgmt.costmanagement.models.QueryFilter
    """

    _attribute_map = {
        'granularity': {'key': 'granularity', 'type': 'str'},
        'configuration': {'key': 'configuration', 'type': 'QueryDatasetConfiguration'},
        'aggregation': {'key': 'aggregation', 'type': '{QueryAggregation}'},
        'filter': {'key': 'filter', 'type': 'QueryFilter'},
    }

    def __init__(self, *, granularity=None, configuration=None, aggregation=None, filter=None, **kwargs) -> None:
        super(ForecastDataset, self).__init__(**kwargs)
        self.granularity = granularity
        self.configuration = configuration
        self.aggregation = aggregation
        self.filter = filter


class ForecastDefinition(Model):
    """The definition of a forecast.

    All required parameters must be populated in order to send to Azure.

    :param type: Required. The type of the forecast. Possible values include:
     'Usage', 'ActualCost', 'AmortizedCost'
    :type type: str or ~azure.mgmt.costmanagement.models.ForecastType
    :param timeframe: Required. The time frame for pulling data for the
     forecast. If custom, then a specific time period must be provided.
     Possible values include: 'MonthToDate', 'BillingMonthToDate',
     'TheLastMonth', 'TheLastBillingMonth', 'WeekToDate', 'Custom'
    :type timeframe: str or
     ~azure.mgmt.costmanagement.models.ForecastTimeframeType
    :param time_period: Has time period for pulling data for the forecast.
    :type time_period: ~azure.mgmt.costmanagement.models.QueryTimePeriod
    :param dataset: Has definition for data in this forecast.
    :type dataset: ~azure.mgmt.costmanagement.models.ForecastDataset
    :param include_actual_cost: a boolean determining if actualCost will be
     included
    :type include_actual_cost: bool
    :param include_fresh_partial_cost: a boolean determining if
     FreshPartialCost will be included
    :type include_fresh_partial_cost: bool
    """

    _validation = {
        'type': {'required': True},
        'timeframe': {'required': True},
    }

    _attribute_map = {
        'type': {'key': 'type', 'type': 'str'},
        'timeframe': {'key': 'timeframe', 'type': 'str'},
        'time_period': {'key': 'timePeriod', 'type': 'QueryTimePeriod'},
        'dataset': {'key': 'dataset', 'type': 'ForecastDataset'},
        'include_actual_cost': {'key': 'includeActualCost', 'type': 'bool'},
        'include_fresh_partial_cost': {'key': 'includeFreshPartialCost', 'type': 'bool'},
    }

    def __init__(self, *, type, timeframe, time_period=None, dataset=None, include_actual_cost: bool=None, include_fresh_partial_cost: bool=None, **kwargs) -> None:
        super(ForecastDefinition, self).__init__(**kwargs)
        self.type = type
        self.timeframe = timeframe
        self.time_period = time_period
        self.dataset = dataset
        self.include_actual_cost = include_actual_cost
        self.include_fresh_partial_cost = include_fresh_partial_cost


class KpiProperties(Model):
    """Each KPI must contain a 'type' and 'enabled' key.

    :param type: KPI type (Forecast, Budget). Possible values include:
     'Forecast', 'Budget'
    :type type: str or ~azure.mgmt.costmanagement.models.KpiTypeType
    :param id: ID of resource related to metric (budget).
    :type id: str
    :param enabled: show the KPI in the UI?
    :type enabled: bool
    """

    _attribute_map = {
        'type': {'key': 'type', 'type': 'str'},
        'id': {'key': 'id', 'type': 'str'},
        'enabled': {'key': 'enabled', 'type': 'bool'},
    }

    def __init__(self, *, type=None, id: str=None, enabled: bool=None, **kwargs) -> None:
        super(KpiProperties, self).__init__(**kwargs)
        self.type = type
        self.id = id
        self.enabled = enabled


class Operation(Model):
    """A Cost management REST API operation.

    Variables are only populated by the server, and will be ignored when
    sending a request.

    :ivar name: Operation name: {provider}/{resource}/{operation}.
    :vartype name: str
    :param display: The object that represents the operation.
    :type display: ~azure.mgmt.costmanagement.models.OperationDisplay
    """

    _validation = {
        'name': {'readonly': True},
    }

    _attribute_map = {
        'name': {'key': 'name', 'type': 'str'},
        'display': {'key': 'display', 'type': 'OperationDisplay'},
    }

    def __init__(self, *, display=None, **kwargs) -> None:
        super(Operation, self).__init__(**kwargs)
        self.name = None
        self.display = display


class OperationDisplay(Model):
    """The object that represents the operation.

    Variables are only populated by the server, and will be ignored when
    sending a request.

    :ivar provider: Service provider: Microsoft.CostManagement.
    :vartype provider: str
    :ivar resource: Resource on which the operation is performed: Dimensions,
     Query.
    :vartype resource: str
    :ivar operation: Operation type: Read, write, delete, etc.
    :vartype operation: str
    """

    _validation = {
        'provider': {'readonly': True},
        'resource': {'readonly': True},
        'operation': {'readonly': True},
    }

    _attribute_map = {
        'provider': {'key': 'provider', 'type': 'str'},
        'resource': {'key': 'resource', 'type': 'str'},
        'operation': {'key': 'operation', 'type': 'str'},
    }

    def __init__(self, **kwargs) -> None:
        super(OperationDisplay, self).__init__(**kwargs)
        self.provider = None
        self.resource = None
        self.operation = None


class PivotProperties(Model):
    """Each pivot must contain a 'type' and 'name'.

    :param type: Data type to show in view. Possible values include:
     'Dimension', 'TagKey'
    :type type: str or ~azure.mgmt.costmanagement.models.PivotTypeType
    :param name: Data field to show in view.
    :type name: str
    """

    _attribute_map = {
        'type': {'key': 'type', 'type': 'str'},
        'name': {'key': 'name', 'type': 'str'},
    }

    def __init__(self, *, type=None, name: str=None, **kwargs) -> None:
        super(PivotProperties, self).__init__(**kwargs)
        self.type = type
        self.name = name


class QueryAggregation(Model):
    """The aggregation expression to be used in the query.

    Variables are only populated by the server, and will be ignored when
    sending a request.

    All required parameters must be populated in order to send to Azure.

    :param name: Required. The name of the column to aggregate.
    :type name: str
    :ivar function: Required. The name of the aggregation function to use.
     Default value: "Sum" .
    :vartype function: str
    """

    _validation = {
        'name': {'required': True},
        'function': {'required': True, 'constant': True},
    }

    _attribute_map = {
        'name': {'key': 'name', 'type': 'str'},
        'function': {'key': 'function', 'type': 'str'},
    }

    function = "Sum"

    def __init__(self, *, name: str, **kwargs) -> None:
        super(QueryAggregation, self).__init__(**kwargs)
        self.name = name


class QueryColumn(Model):
    """QueryColumn.

    :param name: The name of column.
    :type name: str
    :param type: The type of column.
    :type type: str
    """

    _attribute_map = {
        'name': {'key': 'name', 'type': 'str'},
        'type': {'key': 'type', 'type': 'str'},
    }

    def __init__(self, *, name: str=None, type: str=None, **kwargs) -> None:
        super(QueryColumn, self).__init__(**kwargs)
        self.name = name
        self.type = type


class QueryComparisonExpression(Model):
    """The comparison expression to be used in the query.

    Variables are only populated by the server, and will be ignored when
    sending a request.

    All required parameters must be populated in order to send to Azure.

    :param name: Required. The name of the column to use in comparison.
    :type name: str
    :ivar operator: Required. The operator to use for comparison. Default
     value: "In" .
    :vartype operator: str
    :param values: Required. Array of values to use for comparison
    :type values: list[str]
    """

    _validation = {
        'name': {'required': True},
        'operator': {'required': True, 'constant': True},
        'values': {'required': True, 'min_items': 1},
    }

    _attribute_map = {
        'name': {'key': 'name', 'type': 'str'},
        'operator': {'key': 'operator', 'type': 'str'},
        'values': {'key': 'values', 'type': '[str]'},
    }

    operator = "In"

    def __init__(self, *, name: str, values, **kwargs) -> None:
        super(QueryComparisonExpression, self).__init__(**kwargs)
        self.name = name
        self.values = values


class QueryDataset(Model):
    """The definition of data present in the query.

    :param granularity: The granularity of rows in the query. Possible values
     include: 'Daily'
    :type granularity: str or
     ~azure.mgmt.costmanagement.models.GranularityType
    :param configuration: Has configuration information for the data in the
     export. The configuration will be ignored if aggregation and grouping are
     provided.
    :type configuration:
     ~azure.mgmt.costmanagement.models.QueryDatasetConfiguration
    :param aggregation: Dictionary of aggregation expression to use in the
     query. The key of each item in the dictionary is the alias for the
     aggregated column. Query can have up to 2 aggregation clauses.
    :type aggregation: dict[str,
     ~azure.mgmt.costmanagement.models.QueryAggregation]
    :param grouping: Array of group by expression to use in the query. Query
     can have up to 2 group by clauses.
    :type grouping: list[~azure.mgmt.costmanagement.models.QueryGrouping]
    :param filter: Has filter expression to use in the query.
    :type filter: ~azure.mgmt.costmanagement.models.QueryFilter
    """

    _validation = {
        'grouping': {'max_items': 2},
    }

    _attribute_map = {
        'granularity': {'key': 'granularity', 'type': 'str'},
        'configuration': {'key': 'configuration', 'type': 'QueryDatasetConfiguration'},
        'aggregation': {'key': 'aggregation', 'type': '{QueryAggregation}'},
        'grouping': {'key': 'grouping', 'type': '[QueryGrouping]'},
        'filter': {'key': 'filter', 'type': 'QueryFilter'},
    }

    def __init__(self, *, granularity=None, configuration=None, aggregation=None, grouping=None, filter=None, **kwargs) -> None:
        super(QueryDataset, self).__init__(**kwargs)
        self.granularity = granularity
        self.configuration = configuration
        self.aggregation = aggregation
        self.grouping = grouping
        self.filter = filter


class QueryDatasetConfiguration(Model):
    """The configuration of dataset in the query.

    :param columns: Array of column names to be included in the query. Any
     valid query column name is allowed. If not provided, then query includes
     all columns.
    :type columns: list[str]
    """

    _attribute_map = {
        'columns': {'key': 'columns', 'type': '[str]'},
    }

    def __init__(self, *, columns=None, **kwargs) -> None:
        super(QueryDatasetConfiguration, self).__init__(**kwargs)
        self.columns = columns


class QueryDefinition(Model):
    """The definition of a query.

    All required parameters must be populated in order to send to Azure.

    :param type: Required. The type of the query. Possible values include:
     'Usage', 'ActualCost', 'AmortizedCost'
    :type type: str or ~azure.mgmt.costmanagement.models.ExportType
    :param timeframe: Required. The time frame for pulling data for the query.
     If custom, then a specific time period must be provided. Possible values
     include: 'MonthToDate', 'BillingMonthToDate', 'TheLastMonth',
     'TheLastBillingMonth', 'WeekToDate', 'Custom'
    :type timeframe: str or ~azure.mgmt.costmanagement.models.TimeframeType
    :param time_period: Has time period for pulling data for the query.
    :type time_period: ~azure.mgmt.costmanagement.models.QueryTimePeriod
    :param dataset: Has definition for data in this query.
    :type dataset: ~azure.mgmt.costmanagement.models.QueryDataset
    """

    _validation = {
        'type': {'required': True},
        'timeframe': {'required': True},
    }

    _attribute_map = {
        'type': {'key': 'type', 'type': 'str'},
        'timeframe': {'key': 'timeframe', 'type': 'str'},
        'time_period': {'key': 'timePeriod', 'type': 'QueryTimePeriod'},
        'dataset': {'key': 'dataset', 'type': 'QueryDataset'},
    }

    def __init__(self, *, type, timeframe, time_period=None, dataset=None, **kwargs) -> None:
        super(QueryDefinition, self).__init__(**kwargs)
        self.type = type
        self.timeframe = timeframe
        self.time_period = time_period
        self.dataset = dataset


class QueryFilter(Model):
    """The filter expression to be used in the export.

    :param and_property: The logical "AND" expression. Must have at least 2
     items.
    :type and_property: list[~azure.mgmt.costmanagement.models.QueryFilter]
    :param or_property: The logical "OR" expression. Must have at least 2
     items.
    :type or_property: list[~azure.mgmt.costmanagement.models.QueryFilter]
    :param not_property: The logical "NOT" expression.
    :type not_property: ~azure.mgmt.costmanagement.models.QueryFilter
    :param dimension: Has comparison expression for a dimension
    :type dimension:
     ~azure.mgmt.costmanagement.models.QueryComparisonExpression
    :param tag: Has comparison expression for a tag
    :type tag: ~azure.mgmt.costmanagement.models.QueryComparisonExpression
    """

    _validation = {
        'and_property': {'min_items': 2},
        'or_property': {'min_items': 2},
    }

    _attribute_map = {
        'and_property': {'key': 'and', 'type': '[QueryFilter]'},
        'or_property': {'key': 'or', 'type': '[QueryFilter]'},
        'not_property': {'key': 'not', 'type': 'QueryFilter'},
        'dimension': {'key': 'dimension', 'type': 'QueryComparisonExpression'},
        'tag': {'key': 'tag', 'type': 'QueryComparisonExpression'},
    }

    def __init__(self, *, and_property=None, or_property=None, not_property=None, dimension=None, tag=None, **kwargs) -> None:
        super(QueryFilter, self).__init__(**kwargs)
        self.and_property = and_property
        self.or_property = or_property
        self.not_property = not_property
        self.dimension = dimension
        self.tag = tag


class QueryGrouping(Model):
    """The group by expression to be used in the query.

    All required parameters must be populated in order to send to Azure.

    :param type: Required. Has type of the column to group. Possible values
     include: 'Tag', 'Dimension'
    :type type: str or ~azure.mgmt.costmanagement.models.QueryColumnType
    :param name: Required. The name of the column to group.
    :type name: str
    """

    _validation = {
        'type': {'required': True},
        'name': {'required': True},
    }

    _attribute_map = {
        'type': {'key': 'type', 'type': 'str'},
        'name': {'key': 'name', 'type': 'str'},
    }

    def __init__(self, *, type, name: str, **kwargs) -> None:
        super(QueryGrouping, self).__init__(**kwargs)
        self.type = type
        self.name = name


class QueryResult(Resource):
    """Result of query. It contains all columns listed under groupings and
    aggregation.

    Variables are only populated by the server, and will be ignored when
    sending a request.

    :ivar id: Resource Id.
    :vartype id: str
    :ivar name: Resource name.
    :vartype name: str
    :ivar type: Resource type.
    :vartype type: str
    :ivar tags: Resource tags.
    :vartype tags: dict[str, str]
    :param next_link: The link (url) to the next page of results.
    :type next_link: str
    :param columns: Array of columns
    :type columns: list[~azure.mgmt.costmanagement.models.QueryColumn]
    :param rows: Array of rows
    :type rows: list[list[object]]
    """

    _validation = {
        'id': {'readonly': True},
        'name': {'readonly': True},
        'type': {'readonly': True},
        'tags': {'readonly': True},
    }

    _attribute_map = {
        'id': {'key': 'id', 'type': 'str'},
        'name': {'key': 'name', 'type': 'str'},
        'type': {'key': 'type', 'type': 'str'},
        'tags': {'key': 'tags', 'type': '{str}'},
        'next_link': {'key': 'properties.nextLink', 'type': 'str'},
        'columns': {'key': 'properties.columns', 'type': '[QueryColumn]'},
        'rows': {'key': 'properties.rows', 'type': '[[object]]'},
    }

    def __init__(self, *, next_link: str=None, columns=None, rows=None, **kwargs) -> None:
        super(QueryResult, self).__init__(**kwargs)
        self.next_link = next_link
        self.columns = columns
        self.rows = rows


class QueryTimePeriod(Model):
    """The start and end date for pulling data for the query.

    All required parameters must be populated in order to send to Azure.

    :param from_property: Required. The start date to pull data from.
    :type from_property: datetime
    :param to: Required. The end date to pull data to.
    :type to: datetime
    """

    _validation = {
        'from_property': {'required': True},
        'to': {'required': True},
    }

    _attribute_map = {
        'from_property': {'key': 'from', 'type': 'iso-8601'},
        'to': {'key': 'to', 'type': 'iso-8601'},
    }

    def __init__(self, *, from_property, to, **kwargs) -> None:
        super(QueryTimePeriod, self).__init__(**kwargs)
        self.from_property = from_property
        self.to = to


class ReportConfigAggregation(Model):
    """The aggregation expression to be used in the report.

    Variables are only populated by the server, and will be ignored when
    sending a request.

    All required parameters must be populated in order to send to Azure.

    :param name: Required. The name of the column to aggregate.
    :type name: str
    :ivar function: Required. The name of the aggregation function to use.
     Default value: "Sum" .
    :vartype function: str
    """

    _validation = {
        'name': {'required': True},
        'function': {'required': True, 'constant': True},
    }

    _attribute_map = {
        'name': {'key': 'name', 'type': 'str'},
        'function': {'key': 'function', 'type': 'str'},
    }

    function = "Sum"

    def __init__(self, *, name: str, **kwargs) -> None:
        super(ReportConfigAggregation, self).__init__(**kwargs)
        self.name = name


class ReportConfigComparisonExpression(Model):
    """The comparison expression to be used in the report.

    All required parameters must be populated in order to send to Azure.

    :param name: Required. The name of the column to use in comparison.
    :type name: str
    :param operator: Required. The operator to use for comparison. Possible
     values include: 'In', 'Contains'
    :type operator: str or ~azure.mgmt.costmanagement.models.OperatorType
    :param values: Required. Array of values to use for comparison
    :type values: list[str]
    """

    _validation = {
        'name': {'required': True},
        'operator': {'required': True},
        'values': {'required': True, 'min_items': 1},
    }

    _attribute_map = {
        'name': {'key': 'name', 'type': 'str'},
        'operator': {'key': 'operator', 'type': 'str'},
        'values': {'key': 'values', 'type': '[str]'},
    }

    def __init__(self, *, name: str, operator, values, **kwargs) -> None:
        super(ReportConfigComparisonExpression, self).__init__(**kwargs)
        self.name = name
        self.operator = operator
        self.values = values


class ReportConfigDataset(Model):
    """The definition of data present in the report.

    :param granularity: The granularity of rows in the report. Possible values
     include: 'Daily', 'Monthly'
    :type granularity: str or
     ~azure.mgmt.costmanagement.models.ReportGranularityType
    :param configuration: Has configuration information for the data in the
     report. The configuration will be ignored if aggregation and grouping are
     provided.
    :type configuration:
     ~azure.mgmt.costmanagement.models.ReportConfigDatasetConfiguration
    :param aggregation: Dictionary of aggregation expression to use in the
     report. The key of each item in the dictionary is the alias for the
     aggregated column. Report can have up to 2 aggregation clauses.
    :type aggregation: dict[str,
     ~azure.mgmt.costmanagement.models.ReportConfigAggregation]
    :param grouping: Array of group by expression to use in the report. Report
     can have up to 2 group by clauses.
    :type grouping:
     list[~azure.mgmt.costmanagement.models.ReportConfigGrouping]
    :param sorting: Array of order by expression to use in the report.
    :type sorting: list[~azure.mgmt.costmanagement.models.ReportConfigSorting]
    :param filter: Has filter expression to use in the report.
    :type filter: ~azure.mgmt.costmanagement.models.ReportConfigFilter
    """

    _validation = {
        'grouping': {'max_items': 2},
    }

    _attribute_map = {
        'granularity': {'key': 'granularity', 'type': 'str'},
        'configuration': {'key': 'configuration', 'type': 'ReportConfigDatasetConfiguration'},
        'aggregation': {'key': 'aggregation', 'type': '{ReportConfigAggregation}'},
        'grouping': {'key': 'grouping', 'type': '[ReportConfigGrouping]'},
        'sorting': {'key': 'sorting', 'type': '[ReportConfigSorting]'},
        'filter': {'key': 'filter', 'type': 'ReportConfigFilter'},
    }

    def __init__(self, *, granularity=None, configuration=None, aggregation=None, grouping=None, sorting=None, filter=None, **kwargs) -> None:
        super(ReportConfigDataset, self).__init__(**kwargs)
        self.granularity = granularity
        self.configuration = configuration
        self.aggregation = aggregation
        self.grouping = grouping
        self.sorting = sorting
        self.filter = filter


class ReportConfigDatasetConfiguration(Model):
    """The configuration of dataset in the report.

    :param columns: Array of column names to be included in the report. Any
     valid report column name is allowed. If not provided, then report includes
     all columns.
    :type columns: list[str]
    """

    _attribute_map = {
        'columns': {'key': 'columns', 'type': '[str]'},
    }

    def __init__(self, *, columns=None, **kwargs) -> None:
        super(ReportConfigDatasetConfiguration, self).__init__(**kwargs)
        self.columns = columns


class ReportConfigFilter(Model):
    """The filter expression to be used in the report.

    :param and_property: The logical "AND" expression. Must have at least 2
     items.
    :type and_property:
     list[~azure.mgmt.costmanagement.models.ReportConfigFilter]
    :param or_property: The logical "OR" expression. Must have at least 2
     items.
    :type or_property:
     list[~azure.mgmt.costmanagement.models.ReportConfigFilter]
    :param not_property: The logical "NOT" expression.
    :type not_property: ~azure.mgmt.costmanagement.models.ReportConfigFilter
    :param dimension: Has comparison expression for a dimension
    :type dimension:
     ~azure.mgmt.costmanagement.models.ReportConfigComparisonExpression
    :param tag: Has comparison expression for a tag
    :type tag:
     ~azure.mgmt.costmanagement.models.ReportConfigComparisonExpression
    """

    _validation = {
        'and_property': {'min_items': 2},
        'or_property': {'min_items': 2},
    }

    _attribute_map = {
        'and_property': {'key': 'and', 'type': '[ReportConfigFilter]'},
        'or_property': {'key': 'or', 'type': '[ReportConfigFilter]'},
        'not_property': {'key': 'not', 'type': 'ReportConfigFilter'},
        'dimension': {'key': 'dimension', 'type': 'ReportConfigComparisonExpression'},
        'tag': {'key': 'tag', 'type': 'ReportConfigComparisonExpression'},
    }

    def __init__(self, *, and_property=None, or_property=None, not_property=None, dimension=None, tag=None, **kwargs) -> None:
        super(ReportConfigFilter, self).__init__(**kwargs)
        self.and_property = and_property
        self.or_property = or_property
        self.not_property = not_property
        self.dimension = dimension
        self.tag = tag


class ReportConfigGrouping(Model):
    """The group by expression to be used in the report.

    All required parameters must be populated in order to send to Azure.

    :param type: Required. Has type of the column to group. Possible values
     include: 'Tag', 'Dimension'
    :type type: str or
     ~azure.mgmt.costmanagement.models.ReportConfigColumnType
    :param name: Required. The name of the column to group. This version
     supports subscription lowest possible grain.
    :type name: str
    """

    _validation = {
        'type': {'required': True},
        'name': {'required': True},
    }

    _attribute_map = {
        'type': {'key': 'type', 'type': 'str'},
        'name': {'key': 'name', 'type': 'str'},
    }

    def __init__(self, *, type, name: str, **kwargs) -> None:
        super(ReportConfigGrouping, self).__init__(**kwargs)
        self.type = type
        self.name = name


class ReportConfigSorting(Model):
    """The order by expression to be used in the report.

    All required parameters must be populated in order to send to Azure.

    :param direction: Direction of sort. Possible values include: 'Ascending',
     'Descending'
    :type direction: str or ~azure.mgmt.costmanagement.models.enum
    :param name: Required. The name of the column to sort.
    :type name: str
    """

    _validation = {
        'name': {'required': True},
    }

    _attribute_map = {
        'direction': {'key': 'direction', 'type': 'str'},
        'name': {'key': 'name', 'type': 'str'},
    }

    def __init__(self, *, name: str, direction=None, **kwargs) -> None:
        super(ReportConfigSorting, self).__init__(**kwargs)
        self.direction = direction
        self.name = name


class ReportConfigTimePeriod(Model):
    """The start and end date for pulling data for the report.

    All required parameters must be populated in order to send to Azure.

    :param from_property: Required. The start date to pull data from.
    :type from_property: datetime
    :param to: Required. The end date to pull data to.
    :type to: datetime
    """

    _validation = {
        'from_property': {'required': True},
        'to': {'required': True},
    }

    _attribute_map = {
        'from_property': {'key': 'from', 'type': 'iso-8601'},
        'to': {'key': 'to', 'type': 'iso-8601'},
    }

    def __init__(self, *, from_property, to, **kwargs) -> None:
        super(ReportConfigTimePeriod, self).__init__(**kwargs)
        self.from_property = from_property
        self.to = to


class View(ProxyResource):
    """States and configurations of Cost Analysis.

    Variables are only populated by the server, and will be ignored when
    sending a request.

    All required parameters must be populated in order to send to Azure.

    :ivar id: Resource Id.
    :vartype id: str
    :ivar name: Resource name.
    :vartype name: str
    :ivar type: Resource type.
    :vartype type: str
    :param e_tag: eTag of the resource. To handle concurrent update scenario,
     this field will be used to determine whether the user is updating the
     latest version or not.
    :type e_tag: str
    :param display_name: User input name of the view. Required.
    :type display_name: str
    :param scope: Cost Management scope to save the view on. This includes
     'subscriptions/{subscriptionId}' for subscription scope,
     'subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}' for
     resourceGroup scope,
     'providers/Microsoft.Billing/billingAccounts/{billingAccountId}' for
     Billing Account scope,
     'providers/Microsoft.Billing/billingAccounts/{billingAccountId}/departments/{departmentId}'
     for Department scope,
     'providers/Microsoft.Billing/billingAccounts/{billingAccountId}/enrollmentAccounts/{enrollmentAccountId}'
     for EnrollmentAccount scope,
     'providers/Microsoft.Billing/billingAccounts/{billingAccountId}/billingProfiles/{billingProfileId}'
     for BillingProfile scope,
     'providers/Microsoft.Billing/billingAccounts/{billingAccountId}/invoiceSections/{invoiceSectionId}'
     for InvoiceSection scope,
     'providers/Microsoft.Management/managementGroups/{managementGroupId}' for
     Management Group scope,
     '/providers/Microsoft.CostManagement/externalBillingAccounts/{externalBillingAccountName}'
     for ExternalBillingAccount scope, and
     '/providers/Microsoft.CostManagement/externalSubscriptions/{externalSubscriptionName}'
     for ExternalSubscription scope.
    :type scope: str
    :ivar created_on: Date the user created this view.
    :vartype created_on: datetime
    :ivar modified_on: Date when the user last modified this view.
    :vartype modified_on: datetime
    :ivar view_type: Required. The type of the report. Usage represents actual
     usage, forecast represents forecasted data and UsageAndForecast represents
     both usage and forecasted data. Actual usage and forecasted data can be
     differentiated based on dates. Default value: "Usage" .
    :vartype view_type: str
    :param timeframe: Required. The time frame for pulling data for the
     report. If custom, then a specific time period must be provided. Possible
     values include: 'WeekToDate', 'MonthToDate', 'YearToDate', 'Custom'
    :type timeframe: str or
     ~azure.mgmt.costmanagement.models.ReportTimeframeType
    :param time_period: Has time period for pulling data for the report.
    :type time_period:
     ~azure.mgmt.costmanagement.models.ReportConfigTimePeriod
    :param dataset: Has definition for data in this report config.
    :type dataset: ~azure.mgmt.costmanagement.models.ReportConfigDataset
    :param chart: Chart type of the main view in Cost Analysis. Required.
     Possible values include: 'Area', 'Line', 'StackedColumn', 'GroupedColumn',
     'Table'
    :type chart: str or ~azure.mgmt.costmanagement.models.ChartType
    :param accumulated: Show costs accumulated over time. Possible values
     include: 'true', 'false'
    :type accumulated: str or
     ~azure.mgmt.costmanagement.models.AccumulatedType
    :param metric: Metric to use when displaying costs. Possible values
     include: 'ActualCost', 'AmortizedCost', 'AHUB'
    :type metric: str or ~azure.mgmt.costmanagement.models.MetricType
    :param kpis: List of KPIs to show in Cost Analysis UI.
    :type kpis: list[~azure.mgmt.costmanagement.models.KpiProperties]
    :param pivots: Configuration of 3 sub-views in the Cost Analysis UI.
    :type pivots: list[~azure.mgmt.costmanagement.models.PivotProperties]
    """

    _validation = {
        'id': {'readonly': True},
        'name': {'readonly': True},
        'type': {'readonly': True},
        'created_on': {'readonly': True},
        'modified_on': {'readonly': True},
        'view_type': {'required': True, 'constant': True},
        'timeframe': {'required': True},
    }

    _attribute_map = {
        'id': {'key': 'id', 'type': 'str'},
        'name': {'key': 'name', 'type': 'str'},
        'type': {'key': 'type', 'type': 'str'},
        'e_tag': {'key': 'eTag', 'type': 'str'},
        'display_name': {'key': 'properties.displayName', 'type': 'str'},
        'scope': {'key': 'properties.scope', 'type': 'str'},
        'created_on': {'key': 'properties.createdOn', 'type': 'iso-8601'},
        'modified_on': {'key': 'properties.modifiedOn', 'type': 'iso-8601'},
        'view_type': {'key': 'properties.query.type', 'type': 'str'},
        'timeframe': {'key': 'properties.query.timeframe', 'type': 'str'},
        'time_period': {'key': 'properties.query.timePeriod', 'type': 'ReportConfigTimePeriod'},
        'dataset': {'key': 'properties.query.dataset', 'type': 'ReportConfigDataset'},
        'chart': {'key': 'properties.chart', 'type': 'str'},
        'accumulated': {'key': 'properties.accumulated', 'type': 'str'},
        'metric': {'key': 'properties.metric', 'type': 'str'},
        'kpis': {'key': 'properties.kpis', 'type': '[KpiProperties]'},
        'pivots': {'key': 'properties.pivots', 'type': '[PivotProperties]'},
    }

    view_type = "Usage"

    def __init__(self, *, timeframe, e_tag: str=None, display_name: str=None, scope: str=None, time_period=None, dataset=None, chart=None, accumulated=None, metric=None, kpis=None, pivots=None, **kwargs) -> None:
        super(View, self).__init__(e_tag=e_tag, **kwargs)
        self.display_name = display_name
        self.scope = scope
        self.created_on = None
        self.modified_on = None
        self.timeframe = timeframe
        self.time_period = time_period
        self.dataset = dataset
        self.chart = chart
        self.accumulated = accumulated
        self.metric = metric
        self.kpis = kpis
        self.pivots = pivots
