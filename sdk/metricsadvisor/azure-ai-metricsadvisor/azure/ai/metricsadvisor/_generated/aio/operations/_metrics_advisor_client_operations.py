# coding=utf-8
# --------------------------------------------------------------------------
# Copyright (c) Microsoft Corporation. All rights reserved.
# Licensed under the MIT License. See License.txt in the project root for license information.
# Code generated by Microsoft (R) AutoRest Code Generator.
# Changes may cause incorrect behavior and will be lost if the code is regenerated.
# --------------------------------------------------------------------------
import functools
from typing import Any, AsyncIterable, Callable, Dict, Generic, Optional, TYPE_CHECKING, TypeVar, Union
import warnings

from azure.core.async_paging import AsyncItemPaged, AsyncList
from azure.core.exceptions import ClientAuthenticationError, HttpResponseError, ResourceExistsError, ResourceNotFoundError, map_error
from azure.core.pipeline import PipelineResponse
from azure.core.pipeline.transport import AsyncHttpResponse
from azure.core.rest import HttpRequest
from azure.core.tracing.decorator import distributed_trace
from azure.core.tracing.decorator_async import distributed_trace_async

from ... import models as _models
from ..._vendor import _convert_request
from ...operations._metrics_advisor_client_operations import build_add_feedback_request, build_create_alerting_configuration_request, build_create_data_feed_request, build_create_datasource_credential_request, build_create_detection_configuration_request, build_create_hook_request, build_delete_alert_configuration_request, build_delete_data_feed_request, build_delete_datasource_credential_request, build_delete_detection_configuration_request, build_delete_hook_request, build_get_active_series_count_request, build_get_alert_configuration_request, build_get_anomalies_by_anomaly_detection_configuration_request, build_get_anomalies_from_alert_by_anomaly_alerting_configuration_request, build_get_anomaly_detection_configuration_request, build_get_data_feed_ingestion_progress_request, build_get_data_feed_request, build_get_datasource_credential_request, build_get_feedback_request, build_get_hook_request, build_get_incidents_by_anomaly_detection_configuration_next_pages_request, build_get_incidents_by_anomaly_detection_configuration_request, build_get_incidents_from_alert_by_anomaly_alerting_configuration_request, build_list_alert_configurations_request, build_list_alerts_request, build_list_anomaly_dimension_values_request, build_list_data_feed_ingestion_status_request, build_list_data_feeds_request, build_list_datasource_credentials_request, build_list_detection_configurations_request, build_list_feedback_request, build_list_hooks_request, build_list_incident_root_causes_request, build_list_metric_dimension_values_request, build_list_metric_enriched_series_data_request, build_list_metric_enrichment_status_request, build_list_metric_series_data_request, build_list_metric_series_definitions_request, build_refresh_data_feed_ingestion_request, build_update_alert_configuration_request, build_update_data_feed_request, build_update_datasource_credential_request, build_update_detection_configuration_request, build_update_hook_request

if TYPE_CHECKING:
    # pylint: disable=unused-import,ungrouped-imports
    from ..._patch import AlertResultListCustomization, AlertingResultQueryCustomization, AnomalyAlertingConfigurationCustomization, AnomalyAlertingConfigurationListCustomization, AnomalyAlertingConfigurationPatchCustomization, AnomalyDetectionConfigurationCustomization, AnomalyDetectionConfigurationListCustomization, AnomalyDetectionConfigurationPatchCustomization, AnomalyDimensionListCustomization, AnomalyDimensionQueryCustomization, AnomalyResultListCustomization, DataFeedDetailCustomization, DataFeedDetailPatchCustomization, DataFeedIngestionProgressCustomization, DataFeedListCustomization, DataSourceCredentialCustomization, DataSourceCredentialListCustomization, DataSourceCredentialPatchCustomization, DetectionAnomalyResultQueryCustomization, DetectionIncidentResultQueryCustomization, DetectionSeriesQueryCustomization, EnrichmentStatusListCustomization, EnrichmentStatusQueryOptionCustomization, HookInfoCustomization, HookInfoPatchCustomization, HookListCustomization, IncidentResultListCustomization, IngestionProgressResetOptionsCustomization, IngestionStatusListCustomization, IngestionStatusQueryOptionsCustomization, MetricDataListCustomization, MetricDataQueryOptionsCustomization, MetricDimensionListCustomization, MetricDimensionQueryOptionsCustomization, MetricFeedbackCustomization, MetricFeedbackFilterCustomization, MetricFeedbackListCustomization, MetricSeriesListCustomization, MetricSeriesQueryOptionsCustomization, RootCauseListCustomization, SeriesResultListCustomization, UsageStatsCustomization
    from .._patch import MetricsAdvisorClientOperationsMixinCustomization
else:
    try:
        from .._patch import MetricsAdvisorClientOperationsMixinCustomization
    except ImportError:
        class MetricsAdvisorClientOperationsMixinCustomization:
            pass
    try:
        from .._patch import UsageStatsCustomization
    except ImportError:
        class UsageStatsCustomization(object):
            pass
    try:
        from .._patch import AnomalyAlertingConfigurationCustomization
    except ImportError:
        class AnomalyAlertingConfigurationCustomization(object):
            pass
    try:
        from .._patch import AnomalyAlertingConfigurationPatchCustomization
    except ImportError:
        class AnomalyAlertingConfigurationPatchCustomization(object):
            pass
    try:
        from .._patch import AlertingResultQueryCustomization
    except ImportError:
        class AlertingResultQueryCustomization(object):
            pass
    try:
        from .._patch import AlertResultListCustomization
    except ImportError:
        class AlertResultListCustomization(object):
            pass
    try:
        from .._patch import AnomalyResultListCustomization
    except ImportError:
        class AnomalyResultListCustomization(object):
            pass
    try:
        from .._patch import IncidentResultListCustomization
    except ImportError:
        class IncidentResultListCustomization(object):
            pass
    try:
        from .._patch import AnomalyDetectionConfigurationCustomization
    except ImportError:
        class AnomalyDetectionConfigurationCustomization(object):
            pass
    try:
        from .._patch import AnomalyDetectionConfigurationPatchCustomization
    except ImportError:
        class AnomalyDetectionConfigurationPatchCustomization(object):
            pass
    try:
        from .._patch import AnomalyAlertingConfigurationListCustomization
    except ImportError:
        class AnomalyAlertingConfigurationListCustomization(object):
            pass
    try:
        from .._patch import DetectionSeriesQueryCustomization
    except ImportError:
        class DetectionSeriesQueryCustomization(object):
            pass
    try:
        from .._patch import SeriesResultListCustomization
    except ImportError:
        class SeriesResultListCustomization(object):
            pass
    try:
        from .._patch import DetectionAnomalyResultQueryCustomization
    except ImportError:
        class DetectionAnomalyResultQueryCustomization(object):
            pass
    try:
        from .._patch import AnomalyDimensionQueryCustomization
    except ImportError:
        class AnomalyDimensionQueryCustomization(object):
            pass
    try:
        from .._patch import AnomalyDimensionListCustomization
    except ImportError:
        class AnomalyDimensionListCustomization(object):
            pass
    try:
        from .._patch import DetectionIncidentResultQueryCustomization
    except ImportError:
        class DetectionIncidentResultQueryCustomization(object):
            pass
    try:
        from .._patch import RootCauseListCustomization
    except ImportError:
        class RootCauseListCustomization(object):
            pass
    try:
        from .._patch import DataSourceCredentialCustomization
    except ImportError:
        class DataSourceCredentialCustomization(object):
            pass
    try:
        from .._patch import DataSourceCredentialListCustomization
    except ImportError:
        class DataSourceCredentialListCustomization(object):
            pass
    try:
        from .._patch import DataSourceCredentialPatchCustomization
    except ImportError:
        class DataSourceCredentialPatchCustomization(object):
            pass
    try:
        from .._patch import DataFeedListCustomization
    except ImportError:
        class DataFeedListCustomization(object):
            pass
    try:
        from .._patch import DataFeedDetailCustomization
    except ImportError:
        class DataFeedDetailCustomization(object):
            pass
    try:
        from .._patch import DataFeedDetailPatchCustomization
    except ImportError:
        class DataFeedDetailPatchCustomization(object):
            pass
    try:
        from .._patch import MetricFeedbackCustomization
    except ImportError:
        class MetricFeedbackCustomization(object):
            pass
    try:
        from .._patch import MetricFeedbackFilterCustomization
    except ImportError:
        class MetricFeedbackFilterCustomization(object):
            pass
    try:
        from .._patch import MetricFeedbackListCustomization
    except ImportError:
        class MetricFeedbackListCustomization(object):
            pass
    try:
        from .._patch import HookListCustomization
    except ImportError:
        class HookListCustomization(object):
            pass
    try:
        from .._patch import HookInfoCustomization
    except ImportError:
        class HookInfoCustomization(object):
            pass
    try:
        from .._patch import HookInfoPatchCustomization
    except ImportError:
        class HookInfoPatchCustomization(object):
            pass
    try:
        from .._patch import IngestionStatusQueryOptionsCustomization
    except ImportError:
        class IngestionStatusQueryOptionsCustomization(object):
            pass
    try:
        from .._patch import IngestionStatusListCustomization
    except ImportError:
        class IngestionStatusListCustomization(object):
            pass
    try:
        from .._patch import IngestionProgressResetOptionsCustomization
    except ImportError:
        class IngestionProgressResetOptionsCustomization(object):
            pass
    try:
        from .._patch import DataFeedIngestionProgressCustomization
    except ImportError:
        class DataFeedIngestionProgressCustomization(object):
            pass
    try:
        from .._patch import MetricDataQueryOptionsCustomization
    except ImportError:
        class MetricDataQueryOptionsCustomization(object):
            pass
    try:
        from .._patch import MetricDataListCustomization
    except ImportError:
        class MetricDataListCustomization(object):
            pass
    try:
        from .._patch import MetricSeriesQueryOptionsCustomization
    except ImportError:
        class MetricSeriesQueryOptionsCustomization(object):
            pass
    try:
        from .._patch import MetricSeriesListCustomization
    except ImportError:
        class MetricSeriesListCustomization(object):
            pass
    try:
        from .._patch import MetricDimensionQueryOptionsCustomization
    except ImportError:
        class MetricDimensionQueryOptionsCustomization(object):
            pass
    try:
        from .._patch import MetricDimensionListCustomization
    except ImportError:
        class MetricDimensionListCustomization(object):
            pass
    try:
        from .._patch import AnomalyDetectionConfigurationListCustomization
    except ImportError:
        class AnomalyDetectionConfigurationListCustomization(object):
            pass
    try:
        from .._patch import EnrichmentStatusQueryOptionCustomization
    except ImportError:
        class EnrichmentStatusQueryOptionCustomization(object):
            pass
    try:
        from .._patch import EnrichmentStatusListCustomization
    except ImportError:
        class EnrichmentStatusListCustomization(object):
            pass
T = TypeVar('T')
ClsType = Optional[Callable[[PipelineResponse[HttpRequest, AsyncHttpResponse], T, Dict[str, Any]], Any]]

class _MetricsAdvisorClientOperationsMixinGenerated:

    @distributed_trace_async
    async def get_active_series_count(
        self,
        **kwargs: Any
    ) -> "_models.UsageStats":
        """Get latest usage stats.

        Get latest usage stats.

        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: UsageStats, or the result of cls(response)
        :rtype: ~azure.ai.metricsadvisor.models.UsageStats
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType["_models.UsageStats"]
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}))

        
        request = build_get_active_series_count_request(
            template_url=self.get_active_series_count.metadata['url'],
        )
        request = _convert_request(request)
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, 'str', skip_quote=True),
        }
        request.url = self._client.format_url(request.url, **path_format_arguments)

        pipeline_response = await self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize.failsafe_deserialize(_models.ErrorCode, pipeline_response)
            raise HttpResponseError(response=response, model=error)

        deserialized = self._deserialize('UsageStats', pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized

    get_active_series_count.metadata = {'url': '/stats/latest'}  # type: ignore


    @distributed_trace_async
    async def get_alert_configuration(
        self,
        configuration_id: str,
        **kwargs: Any
    ) -> "_models.AnomalyAlertingConfiguration":
        """Query a single anomaly alerting configuration.

        Query a single anomaly alerting configuration.

        :param configuration_id: anomaly alerting configuration unique id.
        :type configuration_id: str
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: AnomalyAlertingConfiguration, or the result of cls(response)
        :rtype: ~azure.ai.metricsadvisor.models.AnomalyAlertingConfiguration
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType["_models.AnomalyAlertingConfiguration"]
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}))

        
        request = build_get_alert_configuration_request(
            configuration_id=configuration_id,
            template_url=self.get_alert_configuration.metadata['url'],
        )
        request = _convert_request(request)
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, 'str', skip_quote=True),
        }
        request.url = self._client.format_url(request.url, **path_format_arguments)

        pipeline_response = await self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize.failsafe_deserialize(_models.ErrorCode, pipeline_response)
            raise HttpResponseError(response=response, model=error)

        deserialized = self._deserialize('AnomalyAlertingConfiguration', pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized

    get_alert_configuration.metadata = {'url': '/alert/anomaly/configurations/{configurationId}'}  # type: ignore


    @distributed_trace_async
    async def update_alert_configuration(
        self,
        configuration_id: str,
        body: "_models.AnomalyAlertingConfigurationPatch",
        **kwargs: Any
    ) -> "_models.AnomalyAlertingConfiguration":
        """Update anomaly alerting configuration.

        Update anomaly alerting configuration.

        :param configuration_id: anomaly alerting configuration unique id.
        :type configuration_id: str
        :param body: anomaly alerting configuration.
        :type body: ~azure.ai.metricsadvisor.models.AnomalyAlertingConfigurationPatch
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: AnomalyAlertingConfiguration, or the result of cls(response)
        :rtype: ~azure.ai.metricsadvisor.models.AnomalyAlertingConfiguration
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType["_models.AnomalyAlertingConfiguration"]
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}))

        content_type = kwargs.pop('content_type', "application/merge-patch+json")  # type: Optional[str]

        _content = self._serialize.body(body, 'AnomalyAlertingConfigurationPatch')

        request = build_update_alert_configuration_request(
            configuration_id=configuration_id,
            content_type=content_type,
            content=_content,
            template_url=self.update_alert_configuration.metadata['url'],
        )
        request = _convert_request(request)
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, 'str', skip_quote=True),
        }
        request.url = self._client.format_url(request.url, **path_format_arguments)

        pipeline_response = await self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize.failsafe_deserialize(_models.ErrorCode, pipeline_response)
            raise HttpResponseError(response=response, model=error)

        deserialized = self._deserialize('AnomalyAlertingConfiguration', pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized

    update_alert_configuration.metadata = {'url': '/alert/anomaly/configurations/{configurationId}'}  # type: ignore


    @distributed_trace_async
    async def delete_alert_configuration(
        self,
        configuration_id: str,
        **kwargs: Any
    ) -> None:
        """Delete anomaly alerting configuration.

        Delete anomaly alerting configuration.

        :param configuration_id: anomaly alerting configuration unique id.
        :type configuration_id: str
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: None, or the result of cls(response)
        :rtype: None
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType[None]
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}))

        
        request = build_delete_alert_configuration_request(
            configuration_id=configuration_id,
            template_url=self.delete_alert_configuration.metadata['url'],
        )
        request = _convert_request(request)
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, 'str', skip_quote=True),
        }
        request.url = self._client.format_url(request.url, **path_format_arguments)

        pipeline_response = await self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [204]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize.failsafe_deserialize(_models.ErrorCode, pipeline_response)
            raise HttpResponseError(response=response, model=error)

        if cls:
            return cls(pipeline_response, None, {})

    delete_alert_configuration.metadata = {'url': '/alert/anomaly/configurations/{configurationId}'}  # type: ignore


    @distributed_trace_async
    async def create_alerting_configuration(
        self,
        body: "_models.AnomalyAlertingConfiguration",
        **kwargs: Any
    ) -> None:
        """Create anomaly alerting configuration.

        Create anomaly alerting configuration.

        :param body: anomaly alerting configuration.
        :type body: ~azure.ai.metricsadvisor.models.AnomalyAlertingConfiguration
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: None, or the result of cls(response)
        :rtype: None
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType[None]
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}))

        content_type = kwargs.pop('content_type', "application/json")  # type: Optional[str]

        _json = self._serialize.body(body, 'AnomalyAlertingConfiguration')

        request = build_create_alerting_configuration_request(
            content_type=content_type,
            json=_json,
            template_url=self.create_alerting_configuration.metadata['url'],
        )
        request = _convert_request(request)
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, 'str', skip_quote=True),
        }
        request.url = self._client.format_url(request.url, **path_format_arguments)

        pipeline_response = await self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [201]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize.failsafe_deserialize(_models.ErrorCode, pipeline_response)
            raise HttpResponseError(response=response, model=error)

        response_headers = {}
        response_headers['Location']=self._deserialize('str', response.headers.get('Location'))


        if cls:
            return cls(pipeline_response, None, response_headers)

    create_alerting_configuration.metadata = {'url': '/alert/anomaly/configurations'}  # type: ignore


    @distributed_trace
    def list_alerts(
        self,
        configuration_id: str,
        body: "_models.AlertingResultQuery",
        skip: Optional[int] = None,
        maxpagesize: Optional[int] = None,
        **kwargs: Any
    ) -> AsyncIterable["_models.AlertResultList"]:
        """Query alerts under anomaly alerting configuration.

        Query alerts under anomaly alerting configuration.

        :param configuration_id: anomaly alerting configuration unique id.
        :type configuration_id: str
        :param body: query alerting result request.
        :type body: ~azure.ai.metricsadvisor.models.AlertingResultQuery
        :param skip: for paging, skipped number.
        :type skip: int
        :param maxpagesize: the maximum number of items in one page.
        :type maxpagesize: int
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: An iterator like instance of either AlertResultList or the result of cls(response)
        :rtype:
         ~azure.core.async_paging.AsyncItemPaged[~azure.ai.metricsadvisor.models.AlertResultList]
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        content_type = kwargs.pop('content_type', "application/json")  # type: Optional[str]

        cls = kwargs.pop('cls', None)  # type: ClsType["_models.AlertResultList"]
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}))
        def prepare_request(next_link=None):
            if not next_link:
                _json = self._serialize.body(body, 'AlertingResultQuery')
                
                request = build_list_alerts_request(
                    configuration_id=configuration_id,
                    content_type=content_type,
                    json=_json,
                    skip=skip,
                    maxpagesize=maxpagesize,
                    template_url=self.list_alerts.metadata['url'],
                )
                request = _convert_request(request)
                path_format_arguments = {
                    "endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, 'str', skip_quote=True),
                }
                request.url = self._client.format_url(request.url, **path_format_arguments)

            else:
                _json = self._serialize.body(body, 'AlertingResultQuery')
                
                request = build_list_alerts_request(
                    configuration_id=configuration_id,
                    content_type=content_type,
                    json=_json,
                    skip=skip,
                    maxpagesize=maxpagesize,
                    template_url=next_link,
                )
                request = _convert_request(request)
                path_format_arguments = {
                    "endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, 'str', skip_quote=True),
                }
                request.url = self._client.format_url(request.url, **path_format_arguments)

                path_format_arguments = {
                    "endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, 'str', skip_quote=True),
                }
                request.method = "GET"
            return request

        async def extract_data(pipeline_response):
            deserialized = self._deserialize("AlertResultList", pipeline_response)
            list_of_elem = deserialized.value
            if cls:
                list_of_elem = cls(list_of_elem)
            return deserialized.next_link or None, AsyncList(list_of_elem)

        async def get_next(next_link=None):
            request = prepare_request(next_link)

            pipeline_response = await self._client._pipeline.run(request, stream=False, **kwargs)
            response = pipeline_response.http_response

            if response.status_code not in [200]:
                map_error(status_code=response.status_code, response=response, error_map=error_map)
                error = self._deserialize.failsafe_deserialize(_models.ErrorCode, pipeline_response)
                raise HttpResponseError(response=response, model=error)

            return pipeline_response


        return AsyncItemPaged(
            get_next, extract_data
        )
    list_alerts.metadata = {'url': '/alert/anomaly/configurations/{configurationId}/alerts/query'}  # type: ignore

    @distributed_trace
    def get_anomalies_from_alert_by_anomaly_alerting_configuration(
        self,
        configuration_id: str,
        alert_id: str,
        skip: Optional[int] = None,
        maxpagesize: Optional[int] = None,
        **kwargs: Any
    ) -> AsyncIterable["_models.AnomalyResultList"]:
        """Query anomalies under a specific alert.

        Query anomalies under a specific alert.

        :param configuration_id: anomaly alerting configuration unique id.
        :type configuration_id: str
        :param alert_id: alert id.
        :type alert_id: str
        :param skip: for paging, skipped number.
        :type skip: int
        :param maxpagesize: the maximum number of items in one page.
        :type maxpagesize: int
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: An iterator like instance of either AnomalyResultList or the result of cls(response)
        :rtype:
         ~azure.core.async_paging.AsyncItemPaged[~azure.ai.metricsadvisor.models.AnomalyResultList]
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType["_models.AnomalyResultList"]
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}))
        def prepare_request(next_link=None):
            if not next_link:
                
                request = build_get_anomalies_from_alert_by_anomaly_alerting_configuration_request(
                    configuration_id=configuration_id,
                    alert_id=alert_id,
                    skip=skip,
                    maxpagesize=maxpagesize,
                    template_url=self.get_anomalies_from_alert_by_anomaly_alerting_configuration.metadata['url'],
                )
                request = _convert_request(request)
                path_format_arguments = {
                    "endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, 'str', skip_quote=True),
                }
                request.url = self._client.format_url(request.url, **path_format_arguments)

            else:
                
                request = build_get_anomalies_from_alert_by_anomaly_alerting_configuration_request(
                    configuration_id=configuration_id,
                    alert_id=alert_id,
                    skip=skip,
                    maxpagesize=maxpagesize,
                    template_url=next_link,
                )
                request = _convert_request(request)
                path_format_arguments = {
                    "endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, 'str', skip_quote=True),
                }
                request.url = self._client.format_url(request.url, **path_format_arguments)

                path_format_arguments = {
                    "endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, 'str', skip_quote=True),
                }
                request.method = "GET"
            return request

        async def extract_data(pipeline_response):
            deserialized = self._deserialize("AnomalyResultList", pipeline_response)
            list_of_elem = deserialized.value
            if cls:
                list_of_elem = cls(list_of_elem)
            return deserialized.next_link or None, AsyncList(list_of_elem)

        async def get_next(next_link=None):
            request = prepare_request(next_link)

            pipeline_response = await self._client._pipeline.run(request, stream=False, **kwargs)
            response = pipeline_response.http_response

            if response.status_code not in [200]:
                map_error(status_code=response.status_code, response=response, error_map=error_map)
                error = self._deserialize.failsafe_deserialize(_models.ErrorCode, pipeline_response)
                raise HttpResponseError(response=response, model=error)

            return pipeline_response


        return AsyncItemPaged(
            get_next, extract_data
        )
    get_anomalies_from_alert_by_anomaly_alerting_configuration.metadata = {'url': '/alert/anomaly/configurations/{configurationId}/alerts/{alertId}/anomalies'}  # type: ignore

    @distributed_trace
    def get_incidents_from_alert_by_anomaly_alerting_configuration(
        self,
        configuration_id: str,
        alert_id: str,
        skip: Optional[int] = None,
        maxpagesize: Optional[int] = None,
        **kwargs: Any
    ) -> AsyncIterable["_models.IncidentResultList"]:
        """Query incidents under a specific alert.

        Query incidents under a specific alert.

        :param configuration_id: anomaly alerting configuration unique id.
        :type configuration_id: str
        :param alert_id: alert id.
        :type alert_id: str
        :param skip: for paging, skipped number.
        :type skip: int
        :param maxpagesize: the maximum number of items in one page.
        :type maxpagesize: int
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: An iterator like instance of either IncidentResultList or the result of cls(response)
        :rtype:
         ~azure.core.async_paging.AsyncItemPaged[~azure.ai.metricsadvisor.models.IncidentResultList]
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType["_models.IncidentResultList"]
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}))
        def prepare_request(next_link=None):
            if not next_link:
                
                request = build_get_incidents_from_alert_by_anomaly_alerting_configuration_request(
                    configuration_id=configuration_id,
                    alert_id=alert_id,
                    skip=skip,
                    maxpagesize=maxpagesize,
                    template_url=self.get_incidents_from_alert_by_anomaly_alerting_configuration.metadata['url'],
                )
                request = _convert_request(request)
                path_format_arguments = {
                    "endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, 'str', skip_quote=True),
                }
                request.url = self._client.format_url(request.url, **path_format_arguments)

            else:
                
                request = build_get_incidents_from_alert_by_anomaly_alerting_configuration_request(
                    configuration_id=configuration_id,
                    alert_id=alert_id,
                    skip=skip,
                    maxpagesize=maxpagesize,
                    template_url=next_link,
                )
                request = _convert_request(request)
                path_format_arguments = {
                    "endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, 'str', skip_quote=True),
                }
                request.url = self._client.format_url(request.url, **path_format_arguments)

                path_format_arguments = {
                    "endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, 'str', skip_quote=True),
                }
                request.method = "GET"
            return request

        async def extract_data(pipeline_response):
            deserialized = self._deserialize("IncidentResultList", pipeline_response)
            list_of_elem = deserialized.value
            if cls:
                list_of_elem = cls(list_of_elem)
            return deserialized.next_link or None, AsyncList(list_of_elem)

        async def get_next(next_link=None):
            request = prepare_request(next_link)

            pipeline_response = await self._client._pipeline.run(request, stream=False, **kwargs)
            response = pipeline_response.http_response

            if response.status_code not in [200]:
                map_error(status_code=response.status_code, response=response, error_map=error_map)
                error = self._deserialize.failsafe_deserialize(_models.ErrorCode, pipeline_response)
                raise HttpResponseError(response=response, model=error)

            return pipeline_response


        return AsyncItemPaged(
            get_next, extract_data
        )
    get_incidents_from_alert_by_anomaly_alerting_configuration.metadata = {'url': '/alert/anomaly/configurations/{configurationId}/alerts/{alertId}/incidents'}  # type: ignore

    @distributed_trace_async
    async def get_anomaly_detection_configuration(
        self,
        configuration_id: str,
        **kwargs: Any
    ) -> "_models.AnomalyDetectionConfiguration":
        """Query a single anomaly detection configuration.

        Query a single anomaly detection configuration.

        :param configuration_id: anomaly detection configuration unique id.
        :type configuration_id: str
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: AnomalyDetectionConfiguration, or the result of cls(response)
        :rtype: ~azure.ai.metricsadvisor.models.AnomalyDetectionConfiguration
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType["_models.AnomalyDetectionConfiguration"]
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}))

        
        request = build_get_anomaly_detection_configuration_request(
            configuration_id=configuration_id,
            template_url=self.get_anomaly_detection_configuration.metadata['url'],
        )
        request = _convert_request(request)
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, 'str', skip_quote=True),
        }
        request.url = self._client.format_url(request.url, **path_format_arguments)

        pipeline_response = await self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize.failsafe_deserialize(_models.ErrorCode, pipeline_response)
            raise HttpResponseError(response=response, model=error)

        deserialized = self._deserialize('AnomalyDetectionConfiguration', pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized

    get_anomaly_detection_configuration.metadata = {'url': '/enrichment/anomalyDetection/configurations/{configurationId}'}  # type: ignore


    @distributed_trace_async
    async def update_detection_configuration(
        self,
        configuration_id: str,
        body: "_models.AnomalyDetectionConfigurationPatch",
        **kwargs: Any
    ) -> "_models.AnomalyDetectionConfiguration":
        """Update anomaly detection configuration.

        Update anomaly detection configuration.

        :param configuration_id: anomaly detection configuration unique id.
        :type configuration_id: str
        :param body: anomaly detection configuration.
        :type body: ~azure.ai.metricsadvisor.models.AnomalyDetectionConfigurationPatch
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: AnomalyDetectionConfiguration, or the result of cls(response)
        :rtype: ~azure.ai.metricsadvisor.models.AnomalyDetectionConfiguration
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType["_models.AnomalyDetectionConfiguration"]
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}))

        content_type = kwargs.pop('content_type', "application/merge-patch+json")  # type: Optional[str]

        _content = self._serialize.body(body, 'AnomalyDetectionConfigurationPatch')

        request = build_update_detection_configuration_request(
            configuration_id=configuration_id,
            content_type=content_type,
            content=_content,
            template_url=self.update_detection_configuration.metadata['url'],
        )
        request = _convert_request(request)
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, 'str', skip_quote=True),
        }
        request.url = self._client.format_url(request.url, **path_format_arguments)

        pipeline_response = await self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize.failsafe_deserialize(_models.ErrorCode, pipeline_response)
            raise HttpResponseError(response=response, model=error)

        deserialized = self._deserialize('AnomalyDetectionConfiguration', pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized

    update_detection_configuration.metadata = {'url': '/enrichment/anomalyDetection/configurations/{configurationId}'}  # type: ignore


    @distributed_trace_async
    async def delete_detection_configuration(
        self,
        configuration_id: str,
        **kwargs: Any
    ) -> None:
        """Delete anomaly detection configuration.

        Delete anomaly detection configuration.

        :param configuration_id: anomaly detection configuration unique id.
        :type configuration_id: str
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: None, or the result of cls(response)
        :rtype: None
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType[None]
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}))

        
        request = build_delete_detection_configuration_request(
            configuration_id=configuration_id,
            template_url=self.delete_detection_configuration.metadata['url'],
        )
        request = _convert_request(request)
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, 'str', skip_quote=True),
        }
        request.url = self._client.format_url(request.url, **path_format_arguments)

        pipeline_response = await self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [204]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize.failsafe_deserialize(_models.ErrorCode, pipeline_response)
            raise HttpResponseError(response=response, model=error)

        if cls:
            return cls(pipeline_response, None, {})

    delete_detection_configuration.metadata = {'url': '/enrichment/anomalyDetection/configurations/{configurationId}'}  # type: ignore


    @distributed_trace_async
    async def create_detection_configuration(
        self,
        body: "_models.AnomalyDetectionConfiguration",
        **kwargs: Any
    ) -> None:
        """Create anomaly detection configuration.

        Create anomaly detection configuration.

        :param body: anomaly detection configuration.
        :type body: ~azure.ai.metricsadvisor.models.AnomalyDetectionConfiguration
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: None, or the result of cls(response)
        :rtype: None
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType[None]
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}))

        content_type = kwargs.pop('content_type', "application/json")  # type: Optional[str]

        _json = self._serialize.body(body, 'AnomalyDetectionConfiguration')

        request = build_create_detection_configuration_request(
            content_type=content_type,
            json=_json,
            template_url=self.create_detection_configuration.metadata['url'],
        )
        request = _convert_request(request)
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, 'str', skip_quote=True),
        }
        request.url = self._client.format_url(request.url, **path_format_arguments)

        pipeline_response = await self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [201]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize.failsafe_deserialize(_models.ErrorCode, pipeline_response)
            raise HttpResponseError(response=response, model=error)

        response_headers = {}
        response_headers['Location']=self._deserialize('str', response.headers.get('Location'))


        if cls:
            return cls(pipeline_response, None, response_headers)

    create_detection_configuration.metadata = {'url': '/enrichment/anomalyDetection/configurations'}  # type: ignore


    @distributed_trace
    def list_alert_configurations(
        self,
        configuration_id: str,
        skip: Optional[int] = None,
        maxpagesize: Optional[int] = None,
        **kwargs: Any
    ) -> AsyncIterable["_models.AnomalyAlertingConfigurationList"]:
        """List all anomaly alerting configurations for specific anomaly detection configuration.

        List all anomaly alerting configurations for specific anomaly detection configuration.

        :param configuration_id: anomaly detection configuration unique id.
        :type configuration_id: str
        :param skip: for paging, skipped number.
        :type skip: int
        :param maxpagesize: the maximum number of items in one page.
        :type maxpagesize: int
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: An iterator like instance of either AnomalyAlertingConfigurationList or the result of
         cls(response)
        :rtype:
         ~azure.core.async_paging.AsyncItemPaged[~azure.ai.metricsadvisor.models.AnomalyAlertingConfigurationList]
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType["_models.AnomalyAlertingConfigurationList"]
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}))
        def prepare_request(next_link=None):
            if not next_link:
                
                request = build_list_alert_configurations_request(
                    configuration_id=configuration_id,
                    skip=skip,
                    maxpagesize=maxpagesize,
                    template_url=self.list_alert_configurations.metadata['url'],
                )
                request = _convert_request(request)
                path_format_arguments = {
                    "endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, 'str', skip_quote=True),
                }
                request.url = self._client.format_url(request.url, **path_format_arguments)

            else:
                
                request = build_list_alert_configurations_request(
                    configuration_id=configuration_id,
                    skip=skip,
                    maxpagesize=maxpagesize,
                    template_url=next_link,
                )
                request = _convert_request(request)
                path_format_arguments = {
                    "endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, 'str', skip_quote=True),
                }
                request.url = self._client.format_url(request.url, **path_format_arguments)

                path_format_arguments = {
                    "endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, 'str', skip_quote=True),
                }
                request.method = "GET"
            return request

        async def extract_data(pipeline_response):
            deserialized = self._deserialize("AnomalyAlertingConfigurationList", pipeline_response)
            list_of_elem = deserialized.value
            if cls:
                list_of_elem = cls(list_of_elem)
            return deserialized.next_link or None, AsyncList(list_of_elem)

        async def get_next(next_link=None):
            request = prepare_request(next_link)

            pipeline_response = await self._client._pipeline.run(request, stream=False, **kwargs)
            response = pipeline_response.http_response

            if response.status_code not in [200]:
                map_error(status_code=response.status_code, response=response, error_map=error_map)
                error = self._deserialize.failsafe_deserialize(_models.ErrorCode, pipeline_response)
                raise HttpResponseError(response=response, model=error)

            return pipeline_response


        return AsyncItemPaged(
            get_next, extract_data
        )
    list_alert_configurations.metadata = {'url': '/enrichment/anomalyDetection/configurations/{configurationId}/alert/anomaly/configurations'}  # type: ignore

    @distributed_trace
    def list_metric_enriched_series_data(
        self,
        configuration_id: str,
        body: "_models.DetectionSeriesQuery",
        **kwargs: Any
    ) -> AsyncIterable["_models.SeriesResultList"]:
        """Query series enriched by anomaly detection.

        Query series enriched by anomaly detection.

        :param configuration_id: anomaly detection configuration unique id.
        :type configuration_id: str
        :param body: query series detection result request.
        :type body: ~azure.ai.metricsadvisor.models.DetectionSeriesQuery
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: An iterator like instance of either SeriesResultList or the result of cls(response)
        :rtype:
         ~azure.core.async_paging.AsyncItemPaged[~azure.ai.metricsadvisor.models.SeriesResultList]
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        content_type = kwargs.pop('content_type', "application/json")  # type: Optional[str]

        cls = kwargs.pop('cls', None)  # type: ClsType["_models.SeriesResultList"]
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}))
        def prepare_request(next_link=None):
            if not next_link:
                _json = self._serialize.body(body, 'DetectionSeriesQuery')
                
                request = build_list_metric_enriched_series_data_request(
                    configuration_id=configuration_id,
                    content_type=content_type,
                    json=_json,
                    template_url=self.list_metric_enriched_series_data.metadata['url'],
                )
                request = _convert_request(request)
                path_format_arguments = {
                    "endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, 'str', skip_quote=True),
                }
                request.url = self._client.format_url(request.url, **path_format_arguments)

            else:
                _json = self._serialize.body(body, 'DetectionSeriesQuery')
                
                request = build_list_metric_enriched_series_data_request(
                    configuration_id=configuration_id,
                    content_type=content_type,
                    json=_json,
                    template_url=next_link,
                )
                request = _convert_request(request)
                path_format_arguments = {
                    "endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, 'str', skip_quote=True),
                }
                request.url = self._client.format_url(request.url, **path_format_arguments)

                path_format_arguments = {
                    "endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, 'str', skip_quote=True),
                }
                request.method = "GET"
            return request

        async def extract_data(pipeline_response):
            deserialized = self._deserialize("SeriesResultList", pipeline_response)
            list_of_elem = deserialized.value
            if cls:
                list_of_elem = cls(list_of_elem)
            return None, AsyncList(list_of_elem)

        async def get_next(next_link=None):
            request = prepare_request(next_link)

            pipeline_response = await self._client._pipeline.run(request, stream=False, **kwargs)
            response = pipeline_response.http_response

            if response.status_code not in [200]:
                map_error(status_code=response.status_code, response=response, error_map=error_map)
                error = self._deserialize.failsafe_deserialize(_models.ErrorCode, pipeline_response)
                raise HttpResponseError(response=response, model=error)

            return pipeline_response


        return AsyncItemPaged(
            get_next, extract_data
        )
    list_metric_enriched_series_data.metadata = {'url': '/enrichment/anomalyDetection/configurations/{configurationId}/series/query'}  # type: ignore

    @distributed_trace
    def get_anomalies_by_anomaly_detection_configuration(
        self,
        configuration_id: str,
        body: "_models.DetectionAnomalyResultQuery",
        skip: Optional[int] = None,
        maxpagesize: Optional[int] = None,
        **kwargs: Any
    ) -> AsyncIterable["_models.AnomalyResultList"]:
        """Query anomalies under anomaly detection configuration.

        Query anomalies under anomaly detection configuration.

        :param configuration_id: anomaly detection configuration unique id.
        :type configuration_id: str
        :param body: query detection anomaly result request.
        :type body: ~azure.ai.metricsadvisor.models.DetectionAnomalyResultQuery
        :param skip: for paging, skipped number.
        :type skip: int
        :param maxpagesize: the maximum number of items in one page.
        :type maxpagesize: int
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: An iterator like instance of either AnomalyResultList or the result of cls(response)
        :rtype:
         ~azure.core.async_paging.AsyncItemPaged[~azure.ai.metricsadvisor.models.AnomalyResultList]
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        content_type = kwargs.pop('content_type', "application/json")  # type: Optional[str]

        cls = kwargs.pop('cls', None)  # type: ClsType["_models.AnomalyResultList"]
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}))
        def prepare_request(next_link=None):
            if not next_link:
                _json = self._serialize.body(body, 'DetectionAnomalyResultQuery')
                
                request = build_get_anomalies_by_anomaly_detection_configuration_request(
                    configuration_id=configuration_id,
                    content_type=content_type,
                    json=_json,
                    skip=skip,
                    maxpagesize=maxpagesize,
                    template_url=self.get_anomalies_by_anomaly_detection_configuration.metadata['url'],
                )
                request = _convert_request(request)
                path_format_arguments = {
                    "endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, 'str', skip_quote=True),
                }
                request.url = self._client.format_url(request.url, **path_format_arguments)

            else:
                _json = self._serialize.body(body, 'DetectionAnomalyResultQuery')
                
                request = build_get_anomalies_by_anomaly_detection_configuration_request(
                    configuration_id=configuration_id,
                    content_type=content_type,
                    json=_json,
                    skip=skip,
                    maxpagesize=maxpagesize,
                    template_url=next_link,
                )
                request = _convert_request(request)
                path_format_arguments = {
                    "endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, 'str', skip_quote=True),
                }
                request.url = self._client.format_url(request.url, **path_format_arguments)

                path_format_arguments = {
                    "endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, 'str', skip_quote=True),
                }
                request.method = "GET"
            return request

        async def extract_data(pipeline_response):
            deserialized = self._deserialize("AnomalyResultList", pipeline_response)
            list_of_elem = deserialized.value
            if cls:
                list_of_elem = cls(list_of_elem)
            return deserialized.next_link or None, AsyncList(list_of_elem)

        async def get_next(next_link=None):
            request = prepare_request(next_link)

            pipeline_response = await self._client._pipeline.run(request, stream=False, **kwargs)
            response = pipeline_response.http_response

            if response.status_code not in [200]:
                map_error(status_code=response.status_code, response=response, error_map=error_map)
                error = self._deserialize.failsafe_deserialize(_models.ErrorCode, pipeline_response)
                raise HttpResponseError(response=response, model=error)

            return pipeline_response


        return AsyncItemPaged(
            get_next, extract_data
        )
    get_anomalies_by_anomaly_detection_configuration.metadata = {'url': '/enrichment/anomalyDetection/configurations/{configurationId}/anomalies/query'}  # type: ignore

    @distributed_trace
    def list_anomaly_dimension_values(
        self,
        configuration_id: str,
        body: "_models.AnomalyDimensionQuery",
        skip: Optional[int] = None,
        maxpagesize: Optional[int] = None,
        **kwargs: Any
    ) -> AsyncIterable["_models.AnomalyDimensionList"]:
        """Query dimension values of anomalies.

        Query dimension values of anomalies.

        :param configuration_id: anomaly detection configuration unique id.
        :type configuration_id: str
        :param body: query dimension values request.
        :type body: ~azure.ai.metricsadvisor.models.AnomalyDimensionQuery
        :param skip: for paging, skipped number.
        :type skip: int
        :param maxpagesize: the maximum number of items in one page.
        :type maxpagesize: int
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: An iterator like instance of either AnomalyDimensionList or the result of
         cls(response)
        :rtype:
         ~azure.core.async_paging.AsyncItemPaged[~azure.ai.metricsadvisor.models.AnomalyDimensionList]
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        content_type = kwargs.pop('content_type', "application/json")  # type: Optional[str]

        cls = kwargs.pop('cls', None)  # type: ClsType["_models.AnomalyDimensionList"]
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}))
        def prepare_request(next_link=None):
            if not next_link:
                _json = self._serialize.body(body, 'AnomalyDimensionQuery')
                
                request = build_list_anomaly_dimension_values_request(
                    configuration_id=configuration_id,
                    content_type=content_type,
                    json=_json,
                    skip=skip,
                    maxpagesize=maxpagesize,
                    template_url=self.list_anomaly_dimension_values.metadata['url'],
                )
                request = _convert_request(request)
                path_format_arguments = {
                    "endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, 'str', skip_quote=True),
                }
                request.url = self._client.format_url(request.url, **path_format_arguments)

            else:
                _json = self._serialize.body(body, 'AnomalyDimensionQuery')
                
                request = build_list_anomaly_dimension_values_request(
                    configuration_id=configuration_id,
                    content_type=content_type,
                    json=_json,
                    skip=skip,
                    maxpagesize=maxpagesize,
                    template_url=next_link,
                )
                request = _convert_request(request)
                path_format_arguments = {
                    "endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, 'str', skip_quote=True),
                }
                request.url = self._client.format_url(request.url, **path_format_arguments)

                path_format_arguments = {
                    "endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, 'str', skip_quote=True),
                }
                request.method = "GET"
            return request

        async def extract_data(pipeline_response):
            deserialized = self._deserialize("AnomalyDimensionList", pipeline_response)
            list_of_elem = deserialized.value
            if cls:
                list_of_elem = cls(list_of_elem)
            return deserialized.next_link or None, AsyncList(list_of_elem)

        async def get_next(next_link=None):
            request = prepare_request(next_link)

            pipeline_response = await self._client._pipeline.run(request, stream=False, **kwargs)
            response = pipeline_response.http_response

            if response.status_code not in [200]:
                map_error(status_code=response.status_code, response=response, error_map=error_map)
                error = self._deserialize.failsafe_deserialize(_models.ErrorCode, pipeline_response)
                raise HttpResponseError(response=response, model=error)

            return pipeline_response


        return AsyncItemPaged(
            get_next, extract_data
        )
    list_anomaly_dimension_values.metadata = {'url': '/enrichment/anomalyDetection/configurations/{configurationId}/anomalies/dimension/query'}  # type: ignore

    @distributed_trace
    def get_incidents_by_anomaly_detection_configuration(
        self,
        configuration_id: str,
        body: "_models.DetectionIncidentResultQuery",
        maxpagesize: Optional[int] = None,
        **kwargs: Any
    ) -> AsyncIterable["_models.IncidentResultList"]:
        """Query incidents under anomaly detection configuration.

        Query incidents under anomaly detection configuration.

        :param configuration_id: anomaly detection configuration unique id.
        :type configuration_id: str
        :param body: query detection incident result request.
        :type body: ~azure.ai.metricsadvisor.models.DetectionIncidentResultQuery
        :param maxpagesize: the maximum number of items in one page.
        :type maxpagesize: int
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: An iterator like instance of either IncidentResultList or the result of cls(response)
        :rtype:
         ~azure.core.async_paging.AsyncItemPaged[~azure.ai.metricsadvisor.models.IncidentResultList]
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        content_type = kwargs.pop('content_type', "application/json")  # type: Optional[str]

        cls = kwargs.pop('cls', None)  # type: ClsType["_models.IncidentResultList"]
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}))
        def prepare_request(next_link=None):
            if not next_link:
                _json = self._serialize.body(body, 'DetectionIncidentResultQuery')
                
                request = build_get_incidents_by_anomaly_detection_configuration_request(
                    configuration_id=configuration_id,
                    content_type=content_type,
                    json=_json,
                    maxpagesize=maxpagesize,
                    template_url=self.get_incidents_by_anomaly_detection_configuration.metadata['url'],
                )
                request = _convert_request(request)
                path_format_arguments = {
                    "endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, 'str', skip_quote=True),
                }
                request.url = self._client.format_url(request.url, **path_format_arguments)

            else:
                _json = self._serialize.body(body, 'DetectionIncidentResultQuery')
                
                request = build_get_incidents_by_anomaly_detection_configuration_request(
                    configuration_id=configuration_id,
                    content_type=content_type,
                    json=_json,
                    maxpagesize=maxpagesize,
                    template_url=next_link,
                )
                request = _convert_request(request)
                path_format_arguments = {
                    "endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, 'str', skip_quote=True),
                }
                request.url = self._client.format_url(request.url, **path_format_arguments)

                path_format_arguments = {
                    "endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, 'str', skip_quote=True),
                }
                request.method = "GET"
            return request

        async def extract_data(pipeline_response):
            deserialized = self._deserialize("IncidentResultList", pipeline_response)
            list_of_elem = deserialized.value
            if cls:
                list_of_elem = cls(list_of_elem)
            return deserialized.next_link or None, AsyncList(list_of_elem)

        async def get_next(next_link=None):
            request = prepare_request(next_link)

            pipeline_response = await self._client._pipeline.run(request, stream=False, **kwargs)
            response = pipeline_response.http_response

            if response.status_code not in [200]:
                map_error(status_code=response.status_code, response=response, error_map=error_map)
                error = self._deserialize.failsafe_deserialize(_models.ErrorCode, pipeline_response)
                raise HttpResponseError(response=response, model=error)

            return pipeline_response


        return AsyncItemPaged(
            get_next, extract_data
        )
    get_incidents_by_anomaly_detection_configuration.metadata = {'url': '/enrichment/anomalyDetection/configurations/{configurationId}/incidents/query'}  # type: ignore

    @distributed_trace
    def get_incidents_by_anomaly_detection_configuration_next_pages(
        self,
        configuration_id: str,
        maxpagesize: Optional[int] = None,
        token: Optional[str] = None,
        **kwargs: Any
    ) -> AsyncIterable["_models.IncidentResultList"]:
        """Query incidents under anomaly detection configuration.

        Query incidents under anomaly detection configuration.

        :param configuration_id: anomaly detection configuration unique id.
        :type configuration_id: str
        :param maxpagesize: the maximum number of items in one page.
        :type maxpagesize: int
        :param token: the token for getting the next page.
        :type token: str
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: An iterator like instance of either IncidentResultList or the result of cls(response)
        :rtype:
         ~azure.core.async_paging.AsyncItemPaged[~azure.ai.metricsadvisor.models.IncidentResultList]
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType["_models.IncidentResultList"]
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}))
        def prepare_request(next_link=None):
            if not next_link:
                
                request = build_get_incidents_by_anomaly_detection_configuration_next_pages_request(
                    configuration_id=configuration_id,
                    maxpagesize=maxpagesize,
                    token=token,
                    template_url=self.get_incidents_by_anomaly_detection_configuration_next_pages.metadata['url'],
                )
                request = _convert_request(request)
                path_format_arguments = {
                    "endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, 'str', skip_quote=True),
                }
                request.url = self._client.format_url(request.url, **path_format_arguments)

            else:
                
                request = build_get_incidents_by_anomaly_detection_configuration_next_pages_request(
                    configuration_id=configuration_id,
                    maxpagesize=maxpagesize,
                    token=token,
                    template_url=next_link,
                )
                request = _convert_request(request)
                path_format_arguments = {
                    "endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, 'str', skip_quote=True),
                }
                request.url = self._client.format_url(request.url, **path_format_arguments)

                path_format_arguments = {
                    "endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, 'str', skip_quote=True),
                }
                request.method = "GET"
            return request

        async def extract_data(pipeline_response):
            deserialized = self._deserialize("IncidentResultList", pipeline_response)
            list_of_elem = deserialized.value
            if cls:
                list_of_elem = cls(list_of_elem)
            return deserialized.next_link or None, AsyncList(list_of_elem)

        async def get_next(next_link=None):
            request = prepare_request(next_link)

            pipeline_response = await self._client._pipeline.run(request, stream=False, **kwargs)
            response = pipeline_response.http_response

            if response.status_code not in [200]:
                map_error(status_code=response.status_code, response=response, error_map=error_map)
                error = self._deserialize.failsafe_deserialize(_models.ErrorCode, pipeline_response)
                raise HttpResponseError(response=response, model=error)

            return pipeline_response


        return AsyncItemPaged(
            get_next, extract_data
        )
    get_incidents_by_anomaly_detection_configuration_next_pages.metadata = {'url': '/enrichment/anomalyDetection/configurations/{configurationId}/incidents/query'}  # type: ignore

    @distributed_trace
    def list_incident_root_causes(
        self,
        configuration_id: str,
        incident_id: str,
        **kwargs: Any
    ) -> AsyncIterable["_models.RootCauseList"]:
        """Query root cause for incident.

        Query root cause for incident.

        :param configuration_id: anomaly detection configuration unique id.
        :type configuration_id: str
        :param incident_id: incident id.
        :type incident_id: str
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: An iterator like instance of either RootCauseList or the result of cls(response)
        :rtype: ~azure.core.async_paging.AsyncItemPaged[~azure.ai.metricsadvisor.models.RootCauseList]
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType["_models.RootCauseList"]
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}))
        def prepare_request(next_link=None):
            if not next_link:
                
                request = build_list_incident_root_causes_request(
                    configuration_id=configuration_id,
                    incident_id=incident_id,
                    template_url=self.list_incident_root_causes.metadata['url'],
                )
                request = _convert_request(request)
                path_format_arguments = {
                    "endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, 'str', skip_quote=True),
                }
                request.url = self._client.format_url(request.url, **path_format_arguments)

            else:
                
                request = build_list_incident_root_causes_request(
                    configuration_id=configuration_id,
                    incident_id=incident_id,
                    template_url=next_link,
                )
                request = _convert_request(request)
                path_format_arguments = {
                    "endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, 'str', skip_quote=True),
                }
                request.url = self._client.format_url(request.url, **path_format_arguments)

                path_format_arguments = {
                    "endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, 'str', skip_quote=True),
                }
                request.method = "GET"
            return request

        async def extract_data(pipeline_response):
            deserialized = self._deserialize("RootCauseList", pipeline_response)
            list_of_elem = deserialized.value
            if cls:
                list_of_elem = cls(list_of_elem)
            return None, AsyncList(list_of_elem)

        async def get_next(next_link=None):
            request = prepare_request(next_link)

            pipeline_response = await self._client._pipeline.run(request, stream=False, **kwargs)
            response = pipeline_response.http_response

            if response.status_code not in [200]:
                map_error(status_code=response.status_code, response=response, error_map=error_map)
                error = self._deserialize.failsafe_deserialize(_models.ErrorCode, pipeline_response)
                raise HttpResponseError(response=response, model=error)

            return pipeline_response


        return AsyncItemPaged(
            get_next, extract_data
        )
    list_incident_root_causes.metadata = {'url': '/enrichment/anomalyDetection/configurations/{configurationId}/incidents/{incidentId}/rootCause'}  # type: ignore

    @distributed_trace_async
    async def create_datasource_credential(
        self,
        body: "_models.DataSourceCredential",
        **kwargs: Any
    ) -> None:
        """Create a new data source credential.

        Create a new data source credential.

        :param body: Create data source credential request.
        :type body: ~azure.ai.metricsadvisor.models.DataSourceCredential
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: None, or the result of cls(response)
        :rtype: None
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType[None]
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}))

        content_type = kwargs.pop('content_type', "application/json")  # type: Optional[str]

        _json = self._serialize.body(body, 'DataSourceCredential')

        request = build_create_datasource_credential_request(
            content_type=content_type,
            json=_json,
            template_url=self.create_datasource_credential.metadata['url'],
        )
        request = _convert_request(request)
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, 'str', skip_quote=True),
        }
        request.url = self._client.format_url(request.url, **path_format_arguments)

        pipeline_response = await self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [201]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize.failsafe_deserialize(_models.ErrorCode, pipeline_response)
            raise HttpResponseError(response=response, model=error)

        response_headers = {}
        response_headers['Location']=self._deserialize('str', response.headers.get('Location'))


        if cls:
            return cls(pipeline_response, None, response_headers)

    create_datasource_credential.metadata = {'url': '/credentials'}  # type: ignore


    @distributed_trace
    def list_datasource_credentials(
        self,
        skip: Optional[int] = None,
        maxpagesize: Optional[int] = None,
        **kwargs: Any
    ) -> AsyncIterable["_models.DataSourceCredentialList"]:
        """List all credentials.

        List all credentials.

        :param skip: for paging, skipped number.
        :type skip: int
        :param maxpagesize: the maximum number of items in one page.
        :type maxpagesize: int
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: An iterator like instance of either DataSourceCredentialList or the result of
         cls(response)
        :rtype:
         ~azure.core.async_paging.AsyncItemPaged[~azure.ai.metricsadvisor.models.DataSourceCredentialList]
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType["_models.DataSourceCredentialList"]
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}))
        def prepare_request(next_link=None):
            if not next_link:
                
                request = build_list_datasource_credentials_request(
                    skip=skip,
                    maxpagesize=maxpagesize,
                    template_url=self.list_datasource_credentials.metadata['url'],
                )
                request = _convert_request(request)
                path_format_arguments = {
                    "endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, 'str', skip_quote=True),
                }
                request.url = self._client.format_url(request.url, **path_format_arguments)

            else:
                
                request = build_list_datasource_credentials_request(
                    skip=skip,
                    maxpagesize=maxpagesize,
                    template_url=next_link,
                )
                request = _convert_request(request)
                path_format_arguments = {
                    "endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, 'str', skip_quote=True),
                }
                request.url = self._client.format_url(request.url, **path_format_arguments)

                path_format_arguments = {
                    "endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, 'str', skip_quote=True),
                }
                request.method = "GET"
            return request

        async def extract_data(pipeline_response):
            deserialized = self._deserialize("DataSourceCredentialList", pipeline_response)
            list_of_elem = deserialized.value
            if cls:
                list_of_elem = cls(list_of_elem)
            return deserialized.next_link or None, AsyncList(list_of_elem)

        async def get_next(next_link=None):
            request = prepare_request(next_link)

            pipeline_response = await self._client._pipeline.run(request, stream=False, **kwargs)
            response = pipeline_response.http_response

            if response.status_code not in [200]:
                map_error(status_code=response.status_code, response=response, error_map=error_map)
                error = self._deserialize.failsafe_deserialize(_models.ErrorCode, pipeline_response)
                raise HttpResponseError(response=response, model=error)

            return pipeline_response


        return AsyncItemPaged(
            get_next, extract_data
        )
    list_datasource_credentials.metadata = {'url': '/credentials'}  # type: ignore

    @distributed_trace_async
    async def update_datasource_credential(
        self,
        credential_id: str,
        body: "_models.DataSourceCredentialPatch",
        **kwargs: Any
    ) -> "_models.DataSourceCredential":
        """Update a data source credential.

        Update a data source credential.

        :param credential_id: Data source credential unique ID.
        :type credential_id: str
        :param body: Update data source credential request.
        :type body: ~azure.ai.metricsadvisor.models.DataSourceCredentialPatch
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: DataSourceCredential, or the result of cls(response)
        :rtype: ~azure.ai.metricsadvisor.models.DataSourceCredential
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType["_models.DataSourceCredential"]
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}))

        content_type = kwargs.pop('content_type', "application/merge-patch+json")  # type: Optional[str]

        _content = self._serialize.body(body, 'DataSourceCredentialPatch')

        request = build_update_datasource_credential_request(
            credential_id=credential_id,
            content_type=content_type,
            content=_content,
            template_url=self.update_datasource_credential.metadata['url'],
        )
        request = _convert_request(request)
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, 'str', skip_quote=True),
        }
        request.url = self._client.format_url(request.url, **path_format_arguments)

        pipeline_response = await self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize.failsafe_deserialize(_models.ErrorCode, pipeline_response)
            raise HttpResponseError(response=response, model=error)

        deserialized = self._deserialize('DataSourceCredential', pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized

    update_datasource_credential.metadata = {'url': '/credentials/{credentialId}'}  # type: ignore


    @distributed_trace_async
    async def delete_datasource_credential(
        self,
        credential_id: str,
        **kwargs: Any
    ) -> None:
        """Delete a data source credential.

        Delete a data source credential.

        :param credential_id: Data source credential unique ID.
        :type credential_id: str
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: None, or the result of cls(response)
        :rtype: None
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType[None]
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}))

        
        request = build_delete_datasource_credential_request(
            credential_id=credential_id,
            template_url=self.delete_datasource_credential.metadata['url'],
        )
        request = _convert_request(request)
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, 'str', skip_quote=True),
        }
        request.url = self._client.format_url(request.url, **path_format_arguments)

        pipeline_response = await self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [204]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize.failsafe_deserialize(_models.ErrorCode, pipeline_response)
            raise HttpResponseError(response=response, model=error)

        if cls:
            return cls(pipeline_response, None, {})

    delete_datasource_credential.metadata = {'url': '/credentials/{credentialId}'}  # type: ignore


    @distributed_trace_async
    async def get_datasource_credential(
        self,
        credential_id: str,
        **kwargs: Any
    ) -> "_models.DataSourceCredential":
        """Get a data source credential.

        Get a data source credential.

        :param credential_id: Data source credential unique ID.
        :type credential_id: str
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: DataSourceCredential, or the result of cls(response)
        :rtype: ~azure.ai.metricsadvisor.models.DataSourceCredential
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType["_models.DataSourceCredential"]
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}))

        
        request = build_get_datasource_credential_request(
            credential_id=credential_id,
            template_url=self.get_datasource_credential.metadata['url'],
        )
        request = _convert_request(request)
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, 'str', skip_quote=True),
        }
        request.url = self._client.format_url(request.url, **path_format_arguments)

        pipeline_response = await self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize.failsafe_deserialize(_models.ErrorCode, pipeline_response)
            raise HttpResponseError(response=response, model=error)

        deserialized = self._deserialize('DataSourceCredential', pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized

    get_datasource_credential.metadata = {'url': '/credentials/{credentialId}'}  # type: ignore


    @distributed_trace
    def list_data_feeds(
        self,
        data_feed_name: Optional[str] = None,
        data_source_type: Optional[Union[str, "_models.DataSourceType"]] = None,
        granularity_name: Optional[Union[str, "_models.Granularity"]] = None,
        status: Optional[Union[str, "_models.EntityStatus"]] = None,
        creator: Optional[str] = None,
        skip: Optional[int] = None,
        maxpagesize: Optional[int] = None,
        **kwargs: Any
    ) -> AsyncIterable["_models.DataFeedList"]:
        """List all data feeds.

        List all data feeds.

        :param data_feed_name: filter data feed by its name.
        :type data_feed_name: str
        :param data_source_type: filter data feed by its source type.
        :type data_source_type: str or ~azure.ai.metricsadvisor.models.DataSourceType
        :param granularity_name: filter data feed by its granularity.
        :type granularity_name: str or ~azure.ai.metricsadvisor.models.Granularity
        :param status: filter data feed by its status.
        :type status: str or ~azure.ai.metricsadvisor.models.EntityStatus
        :param creator: filter data feed by its creator.
        :type creator: str
        :param skip: for paging, skipped number.
        :type skip: int
        :param maxpagesize: the maximum number of items in one page.
        :type maxpagesize: int
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: An iterator like instance of either DataFeedList or the result of cls(response)
        :rtype: ~azure.core.async_paging.AsyncItemPaged[~azure.ai.metricsadvisor.models.DataFeedList]
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType["_models.DataFeedList"]
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}))
        def prepare_request(next_link=None):
            if not next_link:
                
                request = build_list_data_feeds_request(
                    data_feed_name=data_feed_name,
                    data_source_type=data_source_type,
                    granularity_name=granularity_name,
                    status=status,
                    creator=creator,
                    skip=skip,
                    maxpagesize=maxpagesize,
                    template_url=self.list_data_feeds.metadata['url'],
                )
                request = _convert_request(request)
                path_format_arguments = {
                    "endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, 'str', skip_quote=True),
                }
                request.url = self._client.format_url(request.url, **path_format_arguments)

            else:
                
                request = build_list_data_feeds_request(
                    data_feed_name=data_feed_name,
                    data_source_type=data_source_type,
                    granularity_name=granularity_name,
                    status=status,
                    creator=creator,
                    skip=skip,
                    maxpagesize=maxpagesize,
                    template_url=next_link,
                )
                request = _convert_request(request)
                path_format_arguments = {
                    "endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, 'str', skip_quote=True),
                }
                request.url = self._client.format_url(request.url, **path_format_arguments)

                path_format_arguments = {
                    "endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, 'str', skip_quote=True),
                }
                request.method = "GET"
            return request

        async def extract_data(pipeline_response):
            deserialized = self._deserialize("DataFeedList", pipeline_response)
            list_of_elem = deserialized.value
            if cls:
                list_of_elem = cls(list_of_elem)
            return deserialized.next_link or None, AsyncList(list_of_elem)

        async def get_next(next_link=None):
            request = prepare_request(next_link)

            pipeline_response = await self._client._pipeline.run(request, stream=False, **kwargs)
            response = pipeline_response.http_response

            if response.status_code not in [200]:
                map_error(status_code=response.status_code, response=response, error_map=error_map)
                error = self._deserialize.failsafe_deserialize(_models.ErrorCode, pipeline_response)
                raise HttpResponseError(response=response, model=error)

            return pipeline_response


        return AsyncItemPaged(
            get_next, extract_data
        )
    list_data_feeds.metadata = {'url': '/dataFeeds'}  # type: ignore

    @distributed_trace_async
    async def create_data_feed(
        self,
        body: "_models.DataFeedDetail",
        **kwargs: Any
    ) -> None:
        """Create a new data feed.

        Create a new data feed.

        :param body: parameters to create a data feed.
        :type body: ~azure.ai.metricsadvisor.models.DataFeedDetail
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: None, or the result of cls(response)
        :rtype: None
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType[None]
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}))

        content_type = kwargs.pop('content_type', "application/json")  # type: Optional[str]

        _json = self._serialize.body(body, 'DataFeedDetail')

        request = build_create_data_feed_request(
            content_type=content_type,
            json=_json,
            template_url=self.create_data_feed.metadata['url'],
        )
        request = _convert_request(request)
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, 'str', skip_quote=True),
        }
        request.url = self._client.format_url(request.url, **path_format_arguments)

        pipeline_response = await self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [201]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize.failsafe_deserialize(_models.ErrorCode, pipeline_response)
            raise HttpResponseError(response=response, model=error)

        response_headers = {}
        response_headers['Location']=self._deserialize('str', response.headers.get('Location'))


        if cls:
            return cls(pipeline_response, None, response_headers)

    create_data_feed.metadata = {'url': '/dataFeeds'}  # type: ignore


    @distributed_trace_async
    async def get_data_feed(
        self,
        data_feed_id: str,
        **kwargs: Any
    ) -> "_models.DataFeedDetail":
        """Get a data feed by its id.

        Get a data feed by its id.

        :param data_feed_id: The data feed unique id.
        :type data_feed_id: str
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: DataFeedDetail, or the result of cls(response)
        :rtype: ~azure.ai.metricsadvisor.models.DataFeedDetail
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType["_models.DataFeedDetail"]
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}))

        
        request = build_get_data_feed_request(
            data_feed_id=data_feed_id,
            template_url=self.get_data_feed.metadata['url'],
        )
        request = _convert_request(request)
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, 'str', skip_quote=True),
        }
        request.url = self._client.format_url(request.url, **path_format_arguments)

        pipeline_response = await self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize.failsafe_deserialize(_models.ErrorCode, pipeline_response)
            raise HttpResponseError(response=response, model=error)

        deserialized = self._deserialize('DataFeedDetail', pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized

    get_data_feed.metadata = {'url': '/dataFeeds/{dataFeedId}'}  # type: ignore


    @distributed_trace_async
    async def update_data_feed(
        self,
        data_feed_id: str,
        body: "_models.DataFeedDetailPatch",
        **kwargs: Any
    ) -> "_models.DataFeedDetail":
        """Update a data feed.

        Update a data feed.

        :param data_feed_id: The data feed unique id.
        :type data_feed_id: str
        :param body: parameters to update a data feed.
        :type body: ~azure.ai.metricsadvisor.models.DataFeedDetailPatch
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: DataFeedDetail, or the result of cls(response)
        :rtype: ~azure.ai.metricsadvisor.models.DataFeedDetail
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType["_models.DataFeedDetail"]
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}))

        content_type = kwargs.pop('content_type', "application/merge-patch+json")  # type: Optional[str]

        _content = self._serialize.body(body, 'DataFeedDetailPatch')

        request = build_update_data_feed_request(
            data_feed_id=data_feed_id,
            content_type=content_type,
            content=_content,
            template_url=self.update_data_feed.metadata['url'],
        )
        request = _convert_request(request)
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, 'str', skip_quote=True),
        }
        request.url = self._client.format_url(request.url, **path_format_arguments)

        pipeline_response = await self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize.failsafe_deserialize(_models.ErrorCode, pipeline_response)
            raise HttpResponseError(response=response, model=error)

        deserialized = self._deserialize('DataFeedDetail', pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized

    update_data_feed.metadata = {'url': '/dataFeeds/{dataFeedId}'}  # type: ignore


    @distributed_trace_async
    async def delete_data_feed(
        self,
        data_feed_id: str,
        **kwargs: Any
    ) -> None:
        """Delete a data feed.

        Delete a data feed.

        :param data_feed_id: The data feed unique id.
        :type data_feed_id: str
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: None, or the result of cls(response)
        :rtype: None
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType[None]
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}))

        
        request = build_delete_data_feed_request(
            data_feed_id=data_feed_id,
            template_url=self.delete_data_feed.metadata['url'],
        )
        request = _convert_request(request)
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, 'str', skip_quote=True),
        }
        request.url = self._client.format_url(request.url, **path_format_arguments)

        pipeline_response = await self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [204]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize.failsafe_deserialize(_models.ErrorCode, pipeline_response)
            raise HttpResponseError(response=response, model=error)

        if cls:
            return cls(pipeline_response, None, {})

    delete_data_feed.metadata = {'url': '/dataFeeds/{dataFeedId}'}  # type: ignore


    @distributed_trace_async
    async def get_feedback(
        self,
        feedback_id: str,
        **kwargs: Any
    ) -> "_models.MetricFeedback":
        """Get a metric feedback by its id.

        Get a metric feedback by its id.

        :param feedback_id: the unique feedback ID.
        :type feedback_id: str
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: MetricFeedback, or the result of cls(response)
        :rtype: ~azure.ai.metricsadvisor.models.MetricFeedback
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType["_models.MetricFeedback"]
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}))

        
        request = build_get_feedback_request(
            feedback_id=feedback_id,
            template_url=self.get_feedback.metadata['url'],
        )
        request = _convert_request(request)
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, 'str', skip_quote=True),
        }
        request.url = self._client.format_url(request.url, **path_format_arguments)

        pipeline_response = await self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize.failsafe_deserialize(_models.ErrorCode, pipeline_response)
            raise HttpResponseError(response=response, model=error)

        deserialized = self._deserialize('MetricFeedback', pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized

    get_feedback.metadata = {'url': '/feedback/metric/{feedbackId}'}  # type: ignore


    @distributed_trace
    def list_feedback(
        self,
        body: "_models.MetricFeedbackFilter",
        skip: Optional[int] = None,
        maxpagesize: Optional[int] = None,
        **kwargs: Any
    ) -> AsyncIterable["_models.MetricFeedbackList"]:
        """List feedback on the given metric.

        List feedback on the given metric.

        :param body: metric feedback filter.
        :type body: ~azure.ai.metricsadvisor.models.MetricFeedbackFilter
        :param skip: for paging, skipped number.
        :type skip: int
        :param maxpagesize: the maximum number of items in one page.
        :type maxpagesize: int
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: An iterator like instance of either MetricFeedbackList or the result of cls(response)
        :rtype:
         ~azure.core.async_paging.AsyncItemPaged[~azure.ai.metricsadvisor.models.MetricFeedbackList]
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        content_type = kwargs.pop('content_type', "application/json")  # type: Optional[str]

        cls = kwargs.pop('cls', None)  # type: ClsType["_models.MetricFeedbackList"]
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}))
        def prepare_request(next_link=None):
            if not next_link:
                _json = self._serialize.body(body, 'MetricFeedbackFilter')
                
                request = build_list_feedback_request(
                    content_type=content_type,
                    json=_json,
                    skip=skip,
                    maxpagesize=maxpagesize,
                    template_url=self.list_feedback.metadata['url'],
                )
                request = _convert_request(request)
                path_format_arguments = {
                    "endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, 'str', skip_quote=True),
                }
                request.url = self._client.format_url(request.url, **path_format_arguments)

            else:
                _json = self._serialize.body(body, 'MetricFeedbackFilter')
                
                request = build_list_feedback_request(
                    content_type=content_type,
                    json=_json,
                    skip=skip,
                    maxpagesize=maxpagesize,
                    template_url=next_link,
                )
                request = _convert_request(request)
                path_format_arguments = {
                    "endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, 'str', skip_quote=True),
                }
                request.url = self._client.format_url(request.url, **path_format_arguments)

                path_format_arguments = {
                    "endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, 'str', skip_quote=True),
                }
                request.method = "GET"
            return request

        async def extract_data(pipeline_response):
            deserialized = self._deserialize("MetricFeedbackList", pipeline_response)
            list_of_elem = deserialized.value
            if cls:
                list_of_elem = cls(list_of_elem)
            return deserialized.next_link or None, AsyncList(list_of_elem)

        async def get_next(next_link=None):
            request = prepare_request(next_link)

            pipeline_response = await self._client._pipeline.run(request, stream=False, **kwargs)
            response = pipeline_response.http_response

            if response.status_code not in [200]:
                map_error(status_code=response.status_code, response=response, error_map=error_map)
                error = self._deserialize.failsafe_deserialize(_models.ErrorCode, pipeline_response)
                raise HttpResponseError(response=response, model=error)

            return pipeline_response


        return AsyncItemPaged(
            get_next, extract_data
        )
    list_feedback.metadata = {'url': '/feedback/metric/query'}  # type: ignore

    @distributed_trace_async
    async def add_feedback(
        self,
        body: "_models.MetricFeedback",
        **kwargs: Any
    ) -> None:
        """Create a new metric feedback.

        Create a new metric feedback.

        :param body: metric feedback.
        :type body: ~azure.ai.metricsadvisor.models.MetricFeedback
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: None, or the result of cls(response)
        :rtype: None
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType[None]
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}))

        content_type = kwargs.pop('content_type', "application/json")  # type: Optional[str]

        _json = self._serialize.body(body, 'MetricFeedback')

        request = build_add_feedback_request(
            content_type=content_type,
            json=_json,
            template_url=self.add_feedback.metadata['url'],
        )
        request = _convert_request(request)
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, 'str', skip_quote=True),
        }
        request.url = self._client.format_url(request.url, **path_format_arguments)

        pipeline_response = await self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [201]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize.failsafe_deserialize(_models.ErrorCode, pipeline_response)
            raise HttpResponseError(response=response, model=error)

        response_headers = {}
        response_headers['Location']=self._deserialize('str', response.headers.get('Location'))


        if cls:
            return cls(pipeline_response, None, response_headers)

    add_feedback.metadata = {'url': '/feedback/metric'}  # type: ignore


    @distributed_trace
    def list_hooks(
        self,
        hook_name: Optional[str] = None,
        skip: Optional[int] = None,
        maxpagesize: Optional[int] = None,
        **kwargs: Any
    ) -> AsyncIterable["_models.HookList"]:
        """List all hooks.

        List all hooks.

        :param hook_name: filter hook by its name.
        :type hook_name: str
        :param skip: for paging, skipped number.
        :type skip: int
        :param maxpagesize: the maximum number of items in one page.
        :type maxpagesize: int
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: An iterator like instance of either HookList or the result of cls(response)
        :rtype: ~azure.core.async_paging.AsyncItemPaged[~azure.ai.metricsadvisor.models.HookList]
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType["_models.HookList"]
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}))
        def prepare_request(next_link=None):
            if not next_link:
                
                request = build_list_hooks_request(
                    hook_name=hook_name,
                    skip=skip,
                    maxpagesize=maxpagesize,
                    template_url=self.list_hooks.metadata['url'],
                )
                request = _convert_request(request)
                path_format_arguments = {
                    "endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, 'str', skip_quote=True),
                }
                request.url = self._client.format_url(request.url, **path_format_arguments)

            else:
                
                request = build_list_hooks_request(
                    hook_name=hook_name,
                    skip=skip,
                    maxpagesize=maxpagesize,
                    template_url=next_link,
                )
                request = _convert_request(request)
                path_format_arguments = {
                    "endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, 'str', skip_quote=True),
                }
                request.url = self._client.format_url(request.url, **path_format_arguments)

                path_format_arguments = {
                    "endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, 'str', skip_quote=True),
                }
                request.method = "GET"
            return request

        async def extract_data(pipeline_response):
            deserialized = self._deserialize("HookList", pipeline_response)
            list_of_elem = deserialized.value
            if cls:
                list_of_elem = cls(list_of_elem)
            return deserialized.next_link or None, AsyncList(list_of_elem)

        async def get_next(next_link=None):
            request = prepare_request(next_link)

            pipeline_response = await self._client._pipeline.run(request, stream=False, **kwargs)
            response = pipeline_response.http_response

            if response.status_code not in [200]:
                map_error(status_code=response.status_code, response=response, error_map=error_map)
                error = self._deserialize.failsafe_deserialize(_models.ErrorCode, pipeline_response)
                raise HttpResponseError(response=response, model=error)

            return pipeline_response


        return AsyncItemPaged(
            get_next, extract_data
        )
    list_hooks.metadata = {'url': '/hooks'}  # type: ignore

    @distributed_trace_async
    async def create_hook(
        self,
        body: "_models.HookInfo",
        **kwargs: Any
    ) -> None:
        """Create a new hook.

        Create a new hook.

        :param body: Create hook request.
        :type body: ~azure.ai.metricsadvisor.models.HookInfo
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: None, or the result of cls(response)
        :rtype: None
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType[None]
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}))

        content_type = kwargs.pop('content_type', "application/json")  # type: Optional[str]

        _json = self._serialize.body(body, 'HookInfo')

        request = build_create_hook_request(
            content_type=content_type,
            json=_json,
            template_url=self.create_hook.metadata['url'],
        )
        request = _convert_request(request)
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, 'str', skip_quote=True),
        }
        request.url = self._client.format_url(request.url, **path_format_arguments)

        pipeline_response = await self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [201]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize.failsafe_deserialize(_models.ErrorCode, pipeline_response)
            raise HttpResponseError(response=response, model=error)

        response_headers = {}
        response_headers['Location']=self._deserialize('str', response.headers.get('Location'))


        if cls:
            return cls(pipeline_response, None, response_headers)

    create_hook.metadata = {'url': '/hooks'}  # type: ignore


    @distributed_trace_async
    async def get_hook(
        self,
        hook_id: str,
        **kwargs: Any
    ) -> "_models.HookInfo":
        """Get a hook by its id.

        Get a hook by its id.

        :param hook_id: Hook unique ID.
        :type hook_id: str
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: HookInfo, or the result of cls(response)
        :rtype: ~azure.ai.metricsadvisor.models.HookInfo
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType["_models.HookInfo"]
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}))

        
        request = build_get_hook_request(
            hook_id=hook_id,
            template_url=self.get_hook.metadata['url'],
        )
        request = _convert_request(request)
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, 'str', skip_quote=True),
        }
        request.url = self._client.format_url(request.url, **path_format_arguments)

        pipeline_response = await self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize.failsafe_deserialize(_models.ErrorCode, pipeline_response)
            raise HttpResponseError(response=response, model=error)

        deserialized = self._deserialize('HookInfo', pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized

    get_hook.metadata = {'url': '/hooks/{hookId}'}  # type: ignore


    @distributed_trace_async
    async def update_hook(
        self,
        hook_id: str,
        body: "_models.HookInfoPatch",
        **kwargs: Any
    ) -> "_models.HookInfo":
        """Update a hook.

        Update a hook.

        :param hook_id: Hook unique ID.
        :type hook_id: str
        :param body: Update hook request.
        :type body: ~azure.ai.metricsadvisor.models.HookInfoPatch
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: HookInfo, or the result of cls(response)
        :rtype: ~azure.ai.metricsadvisor.models.HookInfo
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType["_models.HookInfo"]
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}))

        content_type = kwargs.pop('content_type', "application/merge-patch+json")  # type: Optional[str]

        _content = self._serialize.body(body, 'HookInfoPatch')

        request = build_update_hook_request(
            hook_id=hook_id,
            content_type=content_type,
            content=_content,
            template_url=self.update_hook.metadata['url'],
        )
        request = _convert_request(request)
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, 'str', skip_quote=True),
        }
        request.url = self._client.format_url(request.url, **path_format_arguments)

        pipeline_response = await self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize.failsafe_deserialize(_models.ErrorCode, pipeline_response)
            raise HttpResponseError(response=response, model=error)

        deserialized = self._deserialize('HookInfo', pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized

    update_hook.metadata = {'url': '/hooks/{hookId}'}  # type: ignore


    @distributed_trace_async
    async def delete_hook(
        self,
        hook_id: str,
        **kwargs: Any
    ) -> None:
        """Delete a hook.

        Delete a hook.

        :param hook_id: Hook unique ID.
        :type hook_id: str
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: None, or the result of cls(response)
        :rtype: None
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType[None]
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}))

        
        request = build_delete_hook_request(
            hook_id=hook_id,
            template_url=self.delete_hook.metadata['url'],
        )
        request = _convert_request(request)
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, 'str', skip_quote=True),
        }
        request.url = self._client.format_url(request.url, **path_format_arguments)

        pipeline_response = await self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [204]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize.failsafe_deserialize(_models.ErrorCode, pipeline_response)
            raise HttpResponseError(response=response, model=error)

        if cls:
            return cls(pipeline_response, None, {})

    delete_hook.metadata = {'url': '/hooks/{hookId}'}  # type: ignore


    @distributed_trace
    def list_data_feed_ingestion_status(
        self,
        data_feed_id: str,
        body: "_models.IngestionStatusQueryOptions",
        skip: Optional[int] = None,
        maxpagesize: Optional[int] = None,
        **kwargs: Any
    ) -> AsyncIterable["_models.IngestionStatusList"]:
        """Get data ingestion status by data feed.

        Get data ingestion status by data feed.

        :param data_feed_id: The data feed unique id.
        :type data_feed_id: str
        :param body: The query time range.
        :type body: ~azure.ai.metricsadvisor.models.IngestionStatusQueryOptions
        :param skip: for paging, skipped number.
        :type skip: int
        :param maxpagesize: the maximum number of items in one page.
        :type maxpagesize: int
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: An iterator like instance of either IngestionStatusList or the result of cls(response)
        :rtype:
         ~azure.core.async_paging.AsyncItemPaged[~azure.ai.metricsadvisor.models.IngestionStatusList]
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        content_type = kwargs.pop('content_type', "application/json")  # type: Optional[str]

        cls = kwargs.pop('cls', None)  # type: ClsType["_models.IngestionStatusList"]
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}))
        def prepare_request(next_link=None):
            if not next_link:
                _json = self._serialize.body(body, 'IngestionStatusQueryOptions')
                
                request = build_list_data_feed_ingestion_status_request(
                    data_feed_id=data_feed_id,
                    content_type=content_type,
                    json=_json,
                    skip=skip,
                    maxpagesize=maxpagesize,
                    template_url=self.list_data_feed_ingestion_status.metadata['url'],
                )
                request = _convert_request(request)
                path_format_arguments = {
                    "endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, 'str', skip_quote=True),
                }
                request.url = self._client.format_url(request.url, **path_format_arguments)

            else:
                _json = self._serialize.body(body, 'IngestionStatusQueryOptions')
                
                request = build_list_data_feed_ingestion_status_request(
                    data_feed_id=data_feed_id,
                    content_type=content_type,
                    json=_json,
                    skip=skip,
                    maxpagesize=maxpagesize,
                    template_url=next_link,
                )
                request = _convert_request(request)
                path_format_arguments = {
                    "endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, 'str', skip_quote=True),
                }
                request.url = self._client.format_url(request.url, **path_format_arguments)

                path_format_arguments = {
                    "endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, 'str', skip_quote=True),
                }
                request.method = "GET"
            return request

        async def extract_data(pipeline_response):
            deserialized = self._deserialize("IngestionStatusList", pipeline_response)
            list_of_elem = deserialized.value
            if cls:
                list_of_elem = cls(list_of_elem)
            return deserialized.next_link or None, AsyncList(list_of_elem)

        async def get_next(next_link=None):
            request = prepare_request(next_link)

            pipeline_response = await self._client._pipeline.run(request, stream=False, **kwargs)
            response = pipeline_response.http_response

            if response.status_code not in [200]:
                map_error(status_code=response.status_code, response=response, error_map=error_map)
                error = self._deserialize.failsafe_deserialize(_models.ErrorCode, pipeline_response)
                raise HttpResponseError(response=response, model=error)

            return pipeline_response


        return AsyncItemPaged(
            get_next, extract_data
        )
    list_data_feed_ingestion_status.metadata = {'url': '/dataFeeds/{dataFeedId}/ingestionStatus/query'}  # type: ignore

    @distributed_trace_async
    async def refresh_data_feed_ingestion(
        self,
        data_feed_id: str,
        body: "_models.IngestionProgressResetOptions",
        **kwargs: Any
    ) -> None:
        """Reset data ingestion status by data feed to backfill data.

        Reset data ingestion status by data feed to backfill data.

        :param data_feed_id: The data feed unique id.
        :type data_feed_id: str
        :param body: The backfill time range.
        :type body: ~azure.ai.metricsadvisor.models.IngestionProgressResetOptions
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: None, or the result of cls(response)
        :rtype: None
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType[None]
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}))

        content_type = kwargs.pop('content_type', "application/json")  # type: Optional[str]

        _json = self._serialize.body(body, 'IngestionProgressResetOptions')

        request = build_refresh_data_feed_ingestion_request(
            data_feed_id=data_feed_id,
            content_type=content_type,
            json=_json,
            template_url=self.refresh_data_feed_ingestion.metadata['url'],
        )
        request = _convert_request(request)
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, 'str', skip_quote=True),
        }
        request.url = self._client.format_url(request.url, **path_format_arguments)

        pipeline_response = await self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [204]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize.failsafe_deserialize(_models.ErrorCode, pipeline_response)
            raise HttpResponseError(response=response, model=error)

        if cls:
            return cls(pipeline_response, None, {})

    refresh_data_feed_ingestion.metadata = {'url': '/dataFeeds/{dataFeedId}/ingestionProgress/reset'}  # type: ignore


    @distributed_trace_async
    async def get_data_feed_ingestion_progress(
        self,
        data_feed_id: str,
        **kwargs: Any
    ) -> "_models.DataFeedIngestionProgress":
        """Get data last success ingestion job timestamp by data feed.

        Get data last success ingestion job timestamp by data feed.

        :param data_feed_id: The data feed unique id.
        :type data_feed_id: str
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: DataFeedIngestionProgress, or the result of cls(response)
        :rtype: ~azure.ai.metricsadvisor.models.DataFeedIngestionProgress
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType["_models.DataFeedIngestionProgress"]
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}))

        
        request = build_get_data_feed_ingestion_progress_request(
            data_feed_id=data_feed_id,
            template_url=self.get_data_feed_ingestion_progress.metadata['url'],
        )
        request = _convert_request(request)
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, 'str', skip_quote=True),
        }
        request.url = self._client.format_url(request.url, **path_format_arguments)

        pipeline_response = await self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize.failsafe_deserialize(_models.ErrorCode, pipeline_response)
            raise HttpResponseError(response=response, model=error)

        deserialized = self._deserialize('DataFeedIngestionProgress', pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized

    get_data_feed_ingestion_progress.metadata = {'url': '/dataFeeds/{dataFeedId}/ingestionProgress'}  # type: ignore


    @distributed_trace
    def list_metric_series_data(
        self,
        metric_id: str,
        body: "_models.MetricDataQueryOptions",
        **kwargs: Any
    ) -> AsyncIterable["_models.MetricDataList"]:
        """Get time series data from metric.

        Get time series data from metric.

        :param metric_id: metric unique id.
        :type metric_id: str
        :param body: query time series data condition.
        :type body: ~azure.ai.metricsadvisor.models.MetricDataQueryOptions
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: An iterator like instance of either MetricDataList or the result of cls(response)
        :rtype: ~azure.core.async_paging.AsyncItemPaged[~azure.ai.metricsadvisor.models.MetricDataList]
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        content_type = kwargs.pop('content_type', "application/json")  # type: Optional[str]

        cls = kwargs.pop('cls', None)  # type: ClsType["_models.MetricDataList"]
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}))
        def prepare_request(next_link=None):
            if not next_link:
                _json = self._serialize.body(body, 'MetricDataQueryOptions')
                
                request = build_list_metric_series_data_request(
                    metric_id=metric_id,
                    content_type=content_type,
                    json=_json,
                    template_url=self.list_metric_series_data.metadata['url'],
                )
                request = _convert_request(request)
                path_format_arguments = {
                    "endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, 'str', skip_quote=True),
                }
                request.url = self._client.format_url(request.url, **path_format_arguments)

            else:
                _json = self._serialize.body(body, 'MetricDataQueryOptions')
                
                request = build_list_metric_series_data_request(
                    metric_id=metric_id,
                    content_type=content_type,
                    json=_json,
                    template_url=next_link,
                )
                request = _convert_request(request)
                path_format_arguments = {
                    "endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, 'str', skip_quote=True),
                }
                request.url = self._client.format_url(request.url, **path_format_arguments)

                path_format_arguments = {
                    "endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, 'str', skip_quote=True),
                }
                request.method = "GET"
            return request

        async def extract_data(pipeline_response):
            deserialized = self._deserialize("MetricDataList", pipeline_response)
            list_of_elem = deserialized.value
            if cls:
                list_of_elem = cls(list_of_elem)
            return None, AsyncList(list_of_elem)

        async def get_next(next_link=None):
            request = prepare_request(next_link)

            pipeline_response = await self._client._pipeline.run(request, stream=False, **kwargs)
            response = pipeline_response.http_response

            if response.status_code not in [200]:
                map_error(status_code=response.status_code, response=response, error_map=error_map)
                error = self._deserialize.failsafe_deserialize(_models.ErrorCode, pipeline_response)
                raise HttpResponseError(response=response, model=error)

            return pipeline_response


        return AsyncItemPaged(
            get_next, extract_data
        )
    list_metric_series_data.metadata = {'url': '/metrics/{metricId}/data/query'}  # type: ignore

    @distributed_trace
    def list_metric_series_definitions(
        self,
        metric_id: str,
        body: "_models.MetricSeriesQueryOptions",
        skip: Optional[int] = None,
        maxpagesize: Optional[int] = None,
        **kwargs: Any
    ) -> AsyncIterable["_models.MetricSeriesList"]:
        """List series (dimension combinations) from metric.

        List series (dimension combinations) from metric.

        :param metric_id: metric unique id.
        :type metric_id: str
        :param body: filter to query series.
        :type body: ~azure.ai.metricsadvisor.models.MetricSeriesQueryOptions
        :param skip: for paging, skipped number.
        :type skip: int
        :param maxpagesize: the maximum number of items in one page.
        :type maxpagesize: int
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: An iterator like instance of either MetricSeriesList or the result of cls(response)
        :rtype:
         ~azure.core.async_paging.AsyncItemPaged[~azure.ai.metricsadvisor.models.MetricSeriesList]
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        content_type = kwargs.pop('content_type', "application/json")  # type: Optional[str]

        cls = kwargs.pop('cls', None)  # type: ClsType["_models.MetricSeriesList"]
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}))
        def prepare_request(next_link=None):
            if not next_link:
                _json = self._serialize.body(body, 'MetricSeriesQueryOptions')
                
                request = build_list_metric_series_definitions_request(
                    metric_id=metric_id,
                    content_type=content_type,
                    json=_json,
                    skip=skip,
                    maxpagesize=maxpagesize,
                    template_url=self.list_metric_series_definitions.metadata['url'],
                )
                request = _convert_request(request)
                path_format_arguments = {
                    "endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, 'str', skip_quote=True),
                }
                request.url = self._client.format_url(request.url, **path_format_arguments)

            else:
                _json = self._serialize.body(body, 'MetricSeriesQueryOptions')
                
                request = build_list_metric_series_definitions_request(
                    metric_id=metric_id,
                    content_type=content_type,
                    json=_json,
                    skip=skip,
                    maxpagesize=maxpagesize,
                    template_url=next_link,
                )
                request = _convert_request(request)
                path_format_arguments = {
                    "endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, 'str', skip_quote=True),
                }
                request.url = self._client.format_url(request.url, **path_format_arguments)

                path_format_arguments = {
                    "endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, 'str', skip_quote=True),
                }
                request.method = "GET"
            return request

        async def extract_data(pipeline_response):
            deserialized = self._deserialize("MetricSeriesList", pipeline_response)
            list_of_elem = deserialized.value
            if cls:
                list_of_elem = cls(list_of_elem)
            return deserialized.next_link or None, AsyncList(list_of_elem)

        async def get_next(next_link=None):
            request = prepare_request(next_link)

            pipeline_response = await self._client._pipeline.run(request, stream=False, **kwargs)
            response = pipeline_response.http_response

            if response.status_code not in [200]:
                map_error(status_code=response.status_code, response=response, error_map=error_map)
                error = self._deserialize.failsafe_deserialize(_models.ErrorCode, pipeline_response)
                raise HttpResponseError(response=response, model=error)

            return pipeline_response


        return AsyncItemPaged(
            get_next, extract_data
        )
    list_metric_series_definitions.metadata = {'url': '/metrics/{metricId}/series/query'}  # type: ignore

    @distributed_trace
    def list_metric_dimension_values(
        self,
        metric_id: str,
        body: "_models.MetricDimensionQueryOptions",
        skip: Optional[int] = None,
        maxpagesize: Optional[int] = None,
        **kwargs: Any
    ) -> AsyncIterable["_models.MetricDimensionList"]:
        """List dimension from certain metric.

        List dimension from certain metric.

        :param metric_id: metric unique id.
        :type metric_id: str
        :param body: query dimension option.
        :type body: ~azure.ai.metricsadvisor.models.MetricDimensionQueryOptions
        :param skip: for paging, skipped number.
        :type skip: int
        :param maxpagesize: the maximum number of items in one page.
        :type maxpagesize: int
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: An iterator like instance of either MetricDimensionList or the result of cls(response)
        :rtype:
         ~azure.core.async_paging.AsyncItemPaged[~azure.ai.metricsadvisor.models.MetricDimensionList]
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        content_type = kwargs.pop('content_type', "application/json")  # type: Optional[str]

        cls = kwargs.pop('cls', None)  # type: ClsType["_models.MetricDimensionList"]
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}))
        def prepare_request(next_link=None):
            if not next_link:
                _json = self._serialize.body(body, 'MetricDimensionQueryOptions')
                
                request = build_list_metric_dimension_values_request(
                    metric_id=metric_id,
                    content_type=content_type,
                    json=_json,
                    skip=skip,
                    maxpagesize=maxpagesize,
                    template_url=self.list_metric_dimension_values.metadata['url'],
                )
                request = _convert_request(request)
                path_format_arguments = {
                    "endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, 'str', skip_quote=True),
                }
                request.url = self._client.format_url(request.url, **path_format_arguments)

            else:
                _json = self._serialize.body(body, 'MetricDimensionQueryOptions')
                
                request = build_list_metric_dimension_values_request(
                    metric_id=metric_id,
                    content_type=content_type,
                    json=_json,
                    skip=skip,
                    maxpagesize=maxpagesize,
                    template_url=next_link,
                )
                request = _convert_request(request)
                path_format_arguments = {
                    "endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, 'str', skip_quote=True),
                }
                request.url = self._client.format_url(request.url, **path_format_arguments)

                path_format_arguments = {
                    "endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, 'str', skip_quote=True),
                }
                request.method = "GET"
            return request

        async def extract_data(pipeline_response):
            deserialized = self._deserialize("MetricDimensionList", pipeline_response)
            list_of_elem = deserialized.value
            if cls:
                list_of_elem = cls(list_of_elem)
            return deserialized.next_link or None, AsyncList(list_of_elem)

        async def get_next(next_link=None):
            request = prepare_request(next_link)

            pipeline_response = await self._client._pipeline.run(request, stream=False, **kwargs)
            response = pipeline_response.http_response

            if response.status_code not in [200]:
                map_error(status_code=response.status_code, response=response, error_map=error_map)
                error = self._deserialize.failsafe_deserialize(_models.ErrorCode, pipeline_response)
                raise HttpResponseError(response=response, model=error)

            return pipeline_response


        return AsyncItemPaged(
            get_next, extract_data
        )
    list_metric_dimension_values.metadata = {'url': '/metrics/{metricId}/dimension/query'}  # type: ignore

    @distributed_trace
    def list_detection_configurations(
        self,
        metric_id: str,
        skip: Optional[int] = None,
        maxpagesize: Optional[int] = None,
        **kwargs: Any
    ) -> AsyncIterable["_models.AnomalyDetectionConfigurationList"]:
        """List all anomaly detection configurations for specific metric.

        List all anomaly detection configurations for specific metric.

        :param metric_id: metric unique id.
        :type metric_id: str
        :param skip: for paging, skipped number.
        :type skip: int
        :param maxpagesize: the maximum number of items in one page.
        :type maxpagesize: int
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: An iterator like instance of either AnomalyDetectionConfigurationList or the result of
         cls(response)
        :rtype:
         ~azure.core.async_paging.AsyncItemPaged[~azure.ai.metricsadvisor.models.AnomalyDetectionConfigurationList]
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType["_models.AnomalyDetectionConfigurationList"]
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}))
        def prepare_request(next_link=None):
            if not next_link:
                
                request = build_list_detection_configurations_request(
                    metric_id=metric_id,
                    skip=skip,
                    maxpagesize=maxpagesize,
                    template_url=self.list_detection_configurations.metadata['url'],
                )
                request = _convert_request(request)
                path_format_arguments = {
                    "endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, 'str', skip_quote=True),
                }
                request.url = self._client.format_url(request.url, **path_format_arguments)

            else:
                
                request = build_list_detection_configurations_request(
                    metric_id=metric_id,
                    skip=skip,
                    maxpagesize=maxpagesize,
                    template_url=next_link,
                )
                request = _convert_request(request)
                path_format_arguments = {
                    "endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, 'str', skip_quote=True),
                }
                request.url = self._client.format_url(request.url, **path_format_arguments)

                path_format_arguments = {
                    "endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, 'str', skip_quote=True),
                }
                request.method = "GET"
            return request

        async def extract_data(pipeline_response):
            deserialized = self._deserialize("AnomalyDetectionConfigurationList", pipeline_response)
            list_of_elem = deserialized.value
            if cls:
                list_of_elem = cls(list_of_elem)
            return deserialized.next_link or None, AsyncList(list_of_elem)

        async def get_next(next_link=None):
            request = prepare_request(next_link)

            pipeline_response = await self._client._pipeline.run(request, stream=False, **kwargs)
            response = pipeline_response.http_response

            if response.status_code not in [200]:
                map_error(status_code=response.status_code, response=response, error_map=error_map)
                error = self._deserialize.failsafe_deserialize(_models.ErrorCode, pipeline_response)
                raise HttpResponseError(response=response, model=error)

            return pipeline_response


        return AsyncItemPaged(
            get_next, extract_data
        )
    list_detection_configurations.metadata = {'url': '/metrics/{metricId}/enrichment/anomalyDetection/configurations'}  # type: ignore

    @distributed_trace
    def list_metric_enrichment_status(
        self,
        metric_id: str,
        body: "_models.EnrichmentStatusQueryOption",
        skip: Optional[int] = None,
        maxpagesize: Optional[int] = None,
        **kwargs: Any
    ) -> AsyncIterable["_models.EnrichmentStatusList"]:
        """Query anomaly detection status.

        Query anomaly detection status.

        :param metric_id: metric unique id.
        :type metric_id: str
        :param body: query options.
        :type body: ~azure.ai.metricsadvisor.models.EnrichmentStatusQueryOption
        :param skip: for paging, skipped number.
        :type skip: int
        :param maxpagesize: the maximum number of items in one page.
        :type maxpagesize: int
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: An iterator like instance of either EnrichmentStatusList or the result of
         cls(response)
        :rtype:
         ~azure.core.async_paging.AsyncItemPaged[~azure.ai.metricsadvisor.models.EnrichmentStatusList]
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        content_type = kwargs.pop('content_type', "application/json")  # type: Optional[str]

        cls = kwargs.pop('cls', None)  # type: ClsType["_models.EnrichmentStatusList"]
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}))
        def prepare_request(next_link=None):
            if not next_link:
                _json = self._serialize.body(body, 'EnrichmentStatusQueryOption')
                
                request = build_list_metric_enrichment_status_request(
                    metric_id=metric_id,
                    content_type=content_type,
                    json=_json,
                    skip=skip,
                    maxpagesize=maxpagesize,
                    template_url=self.list_metric_enrichment_status.metadata['url'],
                )
                request = _convert_request(request)
                path_format_arguments = {
                    "endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, 'str', skip_quote=True),
                }
                request.url = self._client.format_url(request.url, **path_format_arguments)

            else:
                _json = self._serialize.body(body, 'EnrichmentStatusQueryOption')
                
                request = build_list_metric_enrichment_status_request(
                    metric_id=metric_id,
                    content_type=content_type,
                    json=_json,
                    skip=skip,
                    maxpagesize=maxpagesize,
                    template_url=next_link,
                )
                request = _convert_request(request)
                path_format_arguments = {
                    "endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, 'str', skip_quote=True),
                }
                request.url = self._client.format_url(request.url, **path_format_arguments)

                path_format_arguments = {
                    "endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, 'str', skip_quote=True),
                }
                request.method = "GET"
            return request

        async def extract_data(pipeline_response):
            deserialized = self._deserialize("EnrichmentStatusList", pipeline_response)
            list_of_elem = deserialized.value
            if cls:
                list_of_elem = cls(list_of_elem)
            return deserialized.next_link or None, AsyncList(list_of_elem)

        async def get_next(next_link=None):
            request = prepare_request(next_link)

            pipeline_response = await self._client._pipeline.run(request, stream=False, **kwargs)
            response = pipeline_response.http_response

            if response.status_code not in [200]:
                map_error(status_code=response.status_code, response=response, error_map=error_map)
                error = self._deserialize.failsafe_deserialize(_models.ErrorCode, pipeline_response)
                raise HttpResponseError(response=response, model=error)

            return pipeline_response


        return AsyncItemPaged(
            get_next, extract_data
        )
    list_metric_enrichment_status.metadata = {'url': '/metrics/{metricId}/status/enrichment/anomalyDetection/query'}  # type: ignore

class MetricsAdvisorClientOperationsMixin(MetricsAdvisorClientOperationsMixinCustomization, _MetricsAdvisorClientOperationsMixinGenerated):
    pass
