# coding=utf-8
# --------------------------------------------------------------------------
# Copyright (c) Microsoft Corporation. All rights reserved.
# Licensed under the MIT License. See License.txt in the project root for license information.
# Code generated by Microsoft (R) AutoRest Code Generator.
# Changes may cause incorrect behavior and will be lost if the code is regenerated.
# --------------------------------------------------------------------------
import functools
from typing import TYPE_CHECKING
import warnings

from azure.core.exceptions import ClientAuthenticationError, HttpResponseError, ResourceExistsError, ResourceNotFoundError, map_error
from azure.core.paging import ItemPaged
from azure.core.pipeline import PipelineResponse
from azure.core.pipeline.transport import HttpResponse
from azure.core.rest import HttpRequest
from azure.core.tracing.decorator import distributed_trace
from msrest import Serializer

from .. import models as _models
from .._vendor import _convert_request, _format_url_section

if TYPE_CHECKING:
    # pylint: disable=unused-import,ungrouped-imports
    from typing import Any, Callable, Dict, Generic, Iterable, Optional, TypeVar, Union
    T = TypeVar('T')
    ClsType = Optional[Callable[[PipelineResponse[HttpRequest, HttpResponse], T, Dict[str, Any]], Any]]

_SERIALIZER = Serializer()
_SERIALIZER.client_side_validation = False
# fmt: off

def build_get_active_series_count_request(
    **kwargs  # type: Any
):
    # type: (...) -> HttpRequest
    accept = "application/json"
    # Construct URL
    url = kwargs.pop("template_url", '/stats/latest')

    # Construct headers
    header_parameters = kwargs.pop("headers", {})  # type: Dict[str, Any]
    header_parameters['Accept'] = _SERIALIZER.header("accept", accept, 'str')

    return HttpRequest(
        method="GET",
        url=url,
        headers=header_parameters,
        **kwargs
    )


def build_get_anomaly_alerting_configuration_request(
    configuration_id,  # type: str
    **kwargs  # type: Any
):
    # type: (...) -> HttpRequest
    accept = "application/json"
    # Construct URL
    url = kwargs.pop("template_url", '/alert/anomaly/configurations/{configurationId}')
    path_format_arguments = {
        "configurationId": _SERIALIZER.url("configuration_id", configuration_id, 'str'),
    }

    url = _format_url_section(url, **path_format_arguments)

    # Construct headers
    header_parameters = kwargs.pop("headers", {})  # type: Dict[str, Any]
    header_parameters['Accept'] = _SERIALIZER.header("accept", accept, 'str')

    return HttpRequest(
        method="GET",
        url=url,
        headers=header_parameters,
        **kwargs
    )


def build_update_anomaly_alerting_configuration_request(
    configuration_id,  # type: str
    **kwargs  # type: Any
):
    # type: (...) -> HttpRequest
    content_type = kwargs.pop('content_type', None)  # type: Optional[str]

    accept = "application/json"
    # Construct URL
    url = kwargs.pop("template_url", '/alert/anomaly/configurations/{configurationId}')
    path_format_arguments = {
        "configurationId": _SERIALIZER.url("configuration_id", configuration_id, 'str'),
    }

    url = _format_url_section(url, **path_format_arguments)

    # Construct headers
    header_parameters = kwargs.pop("headers", {})  # type: Dict[str, Any]
    if content_type is not None:
        header_parameters['Content-Type'] = _SERIALIZER.header("content_type", content_type, 'str')
    header_parameters['Accept'] = _SERIALIZER.header("accept", accept, 'str')

    return HttpRequest(
        method="PATCH",
        url=url,
        headers=header_parameters,
        **kwargs
    )


def build_delete_anomaly_alerting_configuration_request(
    configuration_id,  # type: str
    **kwargs  # type: Any
):
    # type: (...) -> HttpRequest
    accept = "application/json"
    # Construct URL
    url = kwargs.pop("template_url", '/alert/anomaly/configurations/{configurationId}')
    path_format_arguments = {
        "configurationId": _SERIALIZER.url("configuration_id", configuration_id, 'str'),
    }

    url = _format_url_section(url, **path_format_arguments)

    # Construct headers
    header_parameters = kwargs.pop("headers", {})  # type: Dict[str, Any]
    header_parameters['Accept'] = _SERIALIZER.header("accept", accept, 'str')

    return HttpRequest(
        method="DELETE",
        url=url,
        headers=header_parameters,
        **kwargs
    )


def build_create_anomaly_alerting_configuration_request(
    **kwargs  # type: Any
):
    # type: (...) -> HttpRequest
    content_type = kwargs.pop('content_type', None)  # type: Optional[str]

    accept = "application/json"
    # Construct URL
    url = kwargs.pop("template_url", '/alert/anomaly/configurations')

    # Construct headers
    header_parameters = kwargs.pop("headers", {})  # type: Dict[str, Any]
    if content_type is not None:
        header_parameters['Content-Type'] = _SERIALIZER.header("content_type", content_type, 'str')
    header_parameters['Accept'] = _SERIALIZER.header("accept", accept, 'str')

    return HttpRequest(
        method="POST",
        url=url,
        headers=header_parameters,
        **kwargs
    )


def build_get_alerts_by_anomaly_alerting_configuration_request(
    configuration_id,  # type: str
    **kwargs  # type: Any
):
    # type: (...) -> HttpRequest
    content_type = kwargs.pop('content_type', None)  # type: Optional[str]
    skip = kwargs.pop('skip', None)  # type: Optional[int]
    maxpagesize = kwargs.pop('maxpagesize', None)  # type: Optional[int]

    accept = "application/json"
    # Construct URL
    url = kwargs.pop("template_url", '/alert/anomaly/configurations/{configurationId}/alerts/query')
    path_format_arguments = {
        "configurationId": _SERIALIZER.url("configuration_id", configuration_id, 'str'),
    }

    url = _format_url_section(url, **path_format_arguments)

    # Construct parameters
    query_parameters = kwargs.pop("params", {})  # type: Dict[str, Any]
    if skip is not None:
        query_parameters['$skip'] = _SERIALIZER.query("skip", skip, 'int')
    if maxpagesize is not None:
        query_parameters['$maxpagesize'] = _SERIALIZER.query("maxpagesize", maxpagesize, 'int')

    # Construct headers
    header_parameters = kwargs.pop("headers", {})  # type: Dict[str, Any]
    if content_type is not None:
        header_parameters['Content-Type'] = _SERIALIZER.header("content_type", content_type, 'str')
    header_parameters['Accept'] = _SERIALIZER.header("accept", accept, 'str')

    return HttpRequest(
        method="POST",
        url=url,
        params=query_parameters,
        headers=header_parameters,
        **kwargs
    )


def build_get_anomalies_from_alert_by_anomaly_alerting_configuration_request(
    configuration_id,  # type: str
    alert_id,  # type: str
    **kwargs  # type: Any
):
    # type: (...) -> HttpRequest
    skip = kwargs.pop('skip', None)  # type: Optional[int]
    maxpagesize = kwargs.pop('maxpagesize', None)  # type: Optional[int]

    accept = "application/json"
    # Construct URL
    url = kwargs.pop("template_url", '/alert/anomaly/configurations/{configurationId}/alerts/{alertId}/anomalies')
    path_format_arguments = {
        "configurationId": _SERIALIZER.url("configuration_id", configuration_id, 'str'),
        "alertId": _SERIALIZER.url("alert_id", alert_id, 'str'),
    }

    url = _format_url_section(url, **path_format_arguments)

    # Construct parameters
    query_parameters = kwargs.pop("params", {})  # type: Dict[str, Any]
    if skip is not None:
        query_parameters['$skip'] = _SERIALIZER.query("skip", skip, 'int')
    if maxpagesize is not None:
        query_parameters['$maxpagesize'] = _SERIALIZER.query("maxpagesize", maxpagesize, 'int')

    # Construct headers
    header_parameters = kwargs.pop("headers", {})  # type: Dict[str, Any]
    header_parameters['Accept'] = _SERIALIZER.header("accept", accept, 'str')

    return HttpRequest(
        method="GET",
        url=url,
        params=query_parameters,
        headers=header_parameters,
        **kwargs
    )


def build_get_incidents_from_alert_by_anomaly_alerting_configuration_request(
    configuration_id,  # type: str
    alert_id,  # type: str
    **kwargs  # type: Any
):
    # type: (...) -> HttpRequest
    skip = kwargs.pop('skip', None)  # type: Optional[int]
    maxpagesize = kwargs.pop('maxpagesize', None)  # type: Optional[int]

    accept = "application/json"
    # Construct URL
    url = kwargs.pop("template_url", '/alert/anomaly/configurations/{configurationId}/alerts/{alertId}/incidents')
    path_format_arguments = {
        "configurationId": _SERIALIZER.url("configuration_id", configuration_id, 'str'),
        "alertId": _SERIALIZER.url("alert_id", alert_id, 'str'),
    }

    url = _format_url_section(url, **path_format_arguments)

    # Construct parameters
    query_parameters = kwargs.pop("params", {})  # type: Dict[str, Any]
    if skip is not None:
        query_parameters['$skip'] = _SERIALIZER.query("skip", skip, 'int')
    if maxpagesize is not None:
        query_parameters['$maxpagesize'] = _SERIALIZER.query("maxpagesize", maxpagesize, 'int')

    # Construct headers
    header_parameters = kwargs.pop("headers", {})  # type: Dict[str, Any]
    header_parameters['Accept'] = _SERIALIZER.header("accept", accept, 'str')

    return HttpRequest(
        method="GET",
        url=url,
        params=query_parameters,
        headers=header_parameters,
        **kwargs
    )


def build_get_anomaly_detection_configuration_request(
    configuration_id,  # type: str
    **kwargs  # type: Any
):
    # type: (...) -> HttpRequest
    accept = "application/json"
    # Construct URL
    url = kwargs.pop("template_url", '/enrichment/anomalyDetection/configurations/{configurationId}')
    path_format_arguments = {
        "configurationId": _SERIALIZER.url("configuration_id", configuration_id, 'str'),
    }

    url = _format_url_section(url, **path_format_arguments)

    # Construct headers
    header_parameters = kwargs.pop("headers", {})  # type: Dict[str, Any]
    header_parameters['Accept'] = _SERIALIZER.header("accept", accept, 'str')

    return HttpRequest(
        method="GET",
        url=url,
        headers=header_parameters,
        **kwargs
    )


def build_update_anomaly_detection_configuration_request(
    configuration_id,  # type: str
    **kwargs  # type: Any
):
    # type: (...) -> HttpRequest
    content_type = kwargs.pop('content_type', None)  # type: Optional[str]

    accept = "application/json"
    # Construct URL
    url = kwargs.pop("template_url", '/enrichment/anomalyDetection/configurations/{configurationId}')
    path_format_arguments = {
        "configurationId": _SERIALIZER.url("configuration_id", configuration_id, 'str'),
    }

    url = _format_url_section(url, **path_format_arguments)

    # Construct headers
    header_parameters = kwargs.pop("headers", {})  # type: Dict[str, Any]
    if content_type is not None:
        header_parameters['Content-Type'] = _SERIALIZER.header("content_type", content_type, 'str')
    header_parameters['Accept'] = _SERIALIZER.header("accept", accept, 'str')

    return HttpRequest(
        method="PATCH",
        url=url,
        headers=header_parameters,
        **kwargs
    )


def build_delete_anomaly_detection_configuration_request(
    configuration_id,  # type: str
    **kwargs  # type: Any
):
    # type: (...) -> HttpRequest
    accept = "application/json"
    # Construct URL
    url = kwargs.pop("template_url", '/enrichment/anomalyDetection/configurations/{configurationId}')
    path_format_arguments = {
        "configurationId": _SERIALIZER.url("configuration_id", configuration_id, 'str'),
    }

    url = _format_url_section(url, **path_format_arguments)

    # Construct headers
    header_parameters = kwargs.pop("headers", {})  # type: Dict[str, Any]
    header_parameters['Accept'] = _SERIALIZER.header("accept", accept, 'str')

    return HttpRequest(
        method="DELETE",
        url=url,
        headers=header_parameters,
        **kwargs
    )


def build_create_anomaly_detection_configuration_request(
    **kwargs  # type: Any
):
    # type: (...) -> HttpRequest
    content_type = kwargs.pop('content_type', None)  # type: Optional[str]

    accept = "application/json"
    # Construct URL
    url = kwargs.pop("template_url", '/enrichment/anomalyDetection/configurations')

    # Construct headers
    header_parameters = kwargs.pop("headers", {})  # type: Dict[str, Any]
    if content_type is not None:
        header_parameters['Content-Type'] = _SERIALIZER.header("content_type", content_type, 'str')
    header_parameters['Accept'] = _SERIALIZER.header("accept", accept, 'str')

    return HttpRequest(
        method="POST",
        url=url,
        headers=header_parameters,
        **kwargs
    )


def build_get_anomaly_alerting_configurations_by_anomaly_detection_configuration_request(
    configuration_id,  # type: str
    **kwargs  # type: Any
):
    # type: (...) -> HttpRequest
    skip = kwargs.pop('skip', None)  # type: Optional[int]
    maxpagesize = kwargs.pop('maxpagesize', None)  # type: Optional[int]

    accept = "application/json"
    # Construct URL
    url = kwargs.pop("template_url", '/enrichment/anomalyDetection/configurations/{configurationId}/alert/anomaly/configurations')
    path_format_arguments = {
        "configurationId": _SERIALIZER.url("configuration_id", configuration_id, 'str'),
    }

    url = _format_url_section(url, **path_format_arguments)

    # Construct parameters
    query_parameters = kwargs.pop("params", {})  # type: Dict[str, Any]
    if skip is not None:
        query_parameters['$skip'] = _SERIALIZER.query("skip", skip, 'int')
    if maxpagesize is not None:
        query_parameters['$maxpagesize'] = _SERIALIZER.query("maxpagesize", maxpagesize, 'int')

    # Construct headers
    header_parameters = kwargs.pop("headers", {})  # type: Dict[str, Any]
    header_parameters['Accept'] = _SERIALIZER.header("accept", accept, 'str')

    return HttpRequest(
        method="GET",
        url=url,
        params=query_parameters,
        headers=header_parameters,
        **kwargs
    )


def build_get_series_by_anomaly_detection_configuration_request(
    configuration_id,  # type: str
    **kwargs  # type: Any
):
    # type: (...) -> HttpRequest
    content_type = kwargs.pop('content_type', None)  # type: Optional[str]

    accept = "application/json"
    # Construct URL
    url = kwargs.pop("template_url", '/enrichment/anomalyDetection/configurations/{configurationId}/series/query')
    path_format_arguments = {
        "configurationId": _SERIALIZER.url("configuration_id", configuration_id, 'str'),
    }

    url = _format_url_section(url, **path_format_arguments)

    # Construct headers
    header_parameters = kwargs.pop("headers", {})  # type: Dict[str, Any]
    if content_type is not None:
        header_parameters['Content-Type'] = _SERIALIZER.header("content_type", content_type, 'str')
    header_parameters['Accept'] = _SERIALIZER.header("accept", accept, 'str')

    return HttpRequest(
        method="POST",
        url=url,
        headers=header_parameters,
        **kwargs
    )


def build_get_anomalies_by_anomaly_detection_configuration_request(
    configuration_id,  # type: str
    **kwargs  # type: Any
):
    # type: (...) -> HttpRequest
    content_type = kwargs.pop('content_type', None)  # type: Optional[str]
    skip = kwargs.pop('skip', None)  # type: Optional[int]
    maxpagesize = kwargs.pop('maxpagesize', None)  # type: Optional[int]

    accept = "application/json"
    # Construct URL
    url = kwargs.pop("template_url", '/enrichment/anomalyDetection/configurations/{configurationId}/anomalies/query')
    path_format_arguments = {
        "configurationId": _SERIALIZER.url("configuration_id", configuration_id, 'str'),
    }

    url = _format_url_section(url, **path_format_arguments)

    # Construct parameters
    query_parameters = kwargs.pop("params", {})  # type: Dict[str, Any]
    if skip is not None:
        query_parameters['$skip'] = _SERIALIZER.query("skip", skip, 'int')
    if maxpagesize is not None:
        query_parameters['$maxpagesize'] = _SERIALIZER.query("maxpagesize", maxpagesize, 'int')

    # Construct headers
    header_parameters = kwargs.pop("headers", {})  # type: Dict[str, Any]
    if content_type is not None:
        header_parameters['Content-Type'] = _SERIALIZER.header("content_type", content_type, 'str')
    header_parameters['Accept'] = _SERIALIZER.header("accept", accept, 'str')

    return HttpRequest(
        method="POST",
        url=url,
        params=query_parameters,
        headers=header_parameters,
        **kwargs
    )


def build_get_dimension_of_anomalies_by_anomaly_detection_configuration_request(
    configuration_id,  # type: str
    **kwargs  # type: Any
):
    # type: (...) -> HttpRequest
    content_type = kwargs.pop('content_type', None)  # type: Optional[str]
    skip = kwargs.pop('skip', None)  # type: Optional[int]
    maxpagesize = kwargs.pop('maxpagesize', None)  # type: Optional[int]

    accept = "application/json"
    # Construct URL
    url = kwargs.pop("template_url", '/enrichment/anomalyDetection/configurations/{configurationId}/anomalies/dimension/query')
    path_format_arguments = {
        "configurationId": _SERIALIZER.url("configuration_id", configuration_id, 'str'),
    }

    url = _format_url_section(url, **path_format_arguments)

    # Construct parameters
    query_parameters = kwargs.pop("params", {})  # type: Dict[str, Any]
    if skip is not None:
        query_parameters['$skip'] = _SERIALIZER.query("skip", skip, 'int')
    if maxpagesize is not None:
        query_parameters['$maxpagesize'] = _SERIALIZER.query("maxpagesize", maxpagesize, 'int')

    # Construct headers
    header_parameters = kwargs.pop("headers", {})  # type: Dict[str, Any]
    if content_type is not None:
        header_parameters['Content-Type'] = _SERIALIZER.header("content_type", content_type, 'str')
    header_parameters['Accept'] = _SERIALIZER.header("accept", accept, 'str')

    return HttpRequest(
        method="POST",
        url=url,
        params=query_parameters,
        headers=header_parameters,
        **kwargs
    )


def build_get_incidents_by_anomaly_detection_configuration_request(
    configuration_id,  # type: str
    **kwargs  # type: Any
):
    # type: (...) -> HttpRequest
    content_type = kwargs.pop('content_type', None)  # type: Optional[str]
    maxpagesize = kwargs.pop('maxpagesize', None)  # type: Optional[int]

    accept = "application/json"
    # Construct URL
    url = kwargs.pop("template_url", '/enrichment/anomalyDetection/configurations/{configurationId}/incidents/query')
    path_format_arguments = {
        "configurationId": _SERIALIZER.url("configuration_id", configuration_id, 'str'),
    }

    url = _format_url_section(url, **path_format_arguments)

    # Construct parameters
    query_parameters = kwargs.pop("params", {})  # type: Dict[str, Any]
    if maxpagesize is not None:
        query_parameters['$maxpagesize'] = _SERIALIZER.query("maxpagesize", maxpagesize, 'int')

    # Construct headers
    header_parameters = kwargs.pop("headers", {})  # type: Dict[str, Any]
    if content_type is not None:
        header_parameters['Content-Type'] = _SERIALIZER.header("content_type", content_type, 'str')
    header_parameters['Accept'] = _SERIALIZER.header("accept", accept, 'str')

    return HttpRequest(
        method="POST",
        url=url,
        params=query_parameters,
        headers=header_parameters,
        **kwargs
    )


def build_get_incidents_by_anomaly_detection_configuration_next_pages_request(
    configuration_id,  # type: str
    **kwargs  # type: Any
):
    # type: (...) -> HttpRequest
    maxpagesize = kwargs.pop('maxpagesize', None)  # type: Optional[int]
    token = kwargs.pop('token', None)  # type: Optional[str]

    accept = "application/json"
    # Construct URL
    url = kwargs.pop("template_url", '/enrichment/anomalyDetection/configurations/{configurationId}/incidents/query')
    path_format_arguments = {
        "configurationId": _SERIALIZER.url("configuration_id", configuration_id, 'str'),
    }

    url = _format_url_section(url, **path_format_arguments)

    # Construct parameters
    query_parameters = kwargs.pop("params", {})  # type: Dict[str, Any]
    if maxpagesize is not None:
        query_parameters['$maxpagesize'] = _SERIALIZER.query("maxpagesize", maxpagesize, 'int')
    if token is not None:
        query_parameters['$token'] = _SERIALIZER.query("token", token, 'str')

    # Construct headers
    header_parameters = kwargs.pop("headers", {})  # type: Dict[str, Any]
    header_parameters['Accept'] = _SERIALIZER.header("accept", accept, 'str')

    return HttpRequest(
        method="GET",
        url=url,
        params=query_parameters,
        headers=header_parameters,
        **kwargs
    )


def build_get_root_cause_of_incident_by_anomaly_detection_configuration_request(
    configuration_id,  # type: str
    incident_id,  # type: str
    **kwargs  # type: Any
):
    # type: (...) -> HttpRequest
    accept = "application/json"
    # Construct URL
    url = kwargs.pop("template_url", '/enrichment/anomalyDetection/configurations/{configurationId}/incidents/{incidentId}/rootCause')
    path_format_arguments = {
        "configurationId": _SERIALIZER.url("configuration_id", configuration_id, 'str'),
        "incidentId": _SERIALIZER.url("incident_id", incident_id, 'str'),
    }

    url = _format_url_section(url, **path_format_arguments)

    # Construct headers
    header_parameters = kwargs.pop("headers", {})  # type: Dict[str, Any]
    header_parameters['Accept'] = _SERIALIZER.header("accept", accept, 'str')

    return HttpRequest(
        method="GET",
        url=url,
        headers=header_parameters,
        **kwargs
    )


def build_create_credential_request(
    **kwargs  # type: Any
):
    # type: (...) -> HttpRequest
    content_type = kwargs.pop('content_type', None)  # type: Optional[str]

    accept = "application/json"
    # Construct URL
    url = kwargs.pop("template_url", '/credentials')

    # Construct headers
    header_parameters = kwargs.pop("headers", {})  # type: Dict[str, Any]
    if content_type is not None:
        header_parameters['Content-Type'] = _SERIALIZER.header("content_type", content_type, 'str')
    header_parameters['Accept'] = _SERIALIZER.header("accept", accept, 'str')

    return HttpRequest(
        method="POST",
        url=url,
        headers=header_parameters,
        **kwargs
    )


def build_list_credentials_request(
    **kwargs  # type: Any
):
    # type: (...) -> HttpRequest
    skip = kwargs.pop('skip', None)  # type: Optional[int]
    maxpagesize = kwargs.pop('maxpagesize', None)  # type: Optional[int]

    accept = "application/json"
    # Construct URL
    url = kwargs.pop("template_url", '/credentials')

    # Construct parameters
    query_parameters = kwargs.pop("params", {})  # type: Dict[str, Any]
    if skip is not None:
        query_parameters['$skip'] = _SERIALIZER.query("skip", skip, 'int')
    if maxpagesize is not None:
        query_parameters['$maxpagesize'] = _SERIALIZER.query("maxpagesize", maxpagesize, 'int')

    # Construct headers
    header_parameters = kwargs.pop("headers", {})  # type: Dict[str, Any]
    header_parameters['Accept'] = _SERIALIZER.header("accept", accept, 'str')

    return HttpRequest(
        method="GET",
        url=url,
        params=query_parameters,
        headers=header_parameters,
        **kwargs
    )


def build_update_credential_request(
    credential_id,  # type: str
    **kwargs  # type: Any
):
    # type: (...) -> HttpRequest
    content_type = kwargs.pop('content_type', None)  # type: Optional[str]

    accept = "application/json"
    # Construct URL
    url = kwargs.pop("template_url", '/credentials/{credentialId}')
    path_format_arguments = {
        "credentialId": _SERIALIZER.url("credential_id", credential_id, 'str'),
    }

    url = _format_url_section(url, **path_format_arguments)

    # Construct headers
    header_parameters = kwargs.pop("headers", {})  # type: Dict[str, Any]
    if content_type is not None:
        header_parameters['Content-Type'] = _SERIALIZER.header("content_type", content_type, 'str')
    header_parameters['Accept'] = _SERIALIZER.header("accept", accept, 'str')

    return HttpRequest(
        method="PATCH",
        url=url,
        headers=header_parameters,
        **kwargs
    )


def build_delete_credential_request(
    credential_id,  # type: str
    **kwargs  # type: Any
):
    # type: (...) -> HttpRequest
    accept = "application/json"
    # Construct URL
    url = kwargs.pop("template_url", '/credentials/{credentialId}')
    path_format_arguments = {
        "credentialId": _SERIALIZER.url("credential_id", credential_id, 'str'),
    }

    url = _format_url_section(url, **path_format_arguments)

    # Construct headers
    header_parameters = kwargs.pop("headers", {})  # type: Dict[str, Any]
    header_parameters['Accept'] = _SERIALIZER.header("accept", accept, 'str')

    return HttpRequest(
        method="DELETE",
        url=url,
        headers=header_parameters,
        **kwargs
    )


def build_get_credential_request(
    credential_id,  # type: str
    **kwargs  # type: Any
):
    # type: (...) -> HttpRequest
    accept = "application/json"
    # Construct URL
    url = kwargs.pop("template_url", '/credentials/{credentialId}')
    path_format_arguments = {
        "credentialId": _SERIALIZER.url("credential_id", credential_id, 'str'),
    }

    url = _format_url_section(url, **path_format_arguments)

    # Construct headers
    header_parameters = kwargs.pop("headers", {})  # type: Dict[str, Any]
    header_parameters['Accept'] = _SERIALIZER.header("accept", accept, 'str')

    return HttpRequest(
        method="GET",
        url=url,
        headers=header_parameters,
        **kwargs
    )


def build_list_data_feeds_request(
    **kwargs  # type: Any
):
    # type: (...) -> HttpRequest
    data_feed_name = kwargs.pop('data_feed_name', None)  # type: Optional[str]
    data_source_type = kwargs.pop('data_source_type', None)  # type: Optional[Union[str, "_models.DataSourceType"]]
    granularity_name = kwargs.pop('granularity_name', None)  # type: Optional[Union[str, "_models.Granularity"]]
    status = kwargs.pop('status', None)  # type: Optional[Union[str, "_models.EntityStatus"]]
    creator = kwargs.pop('creator', None)  # type: Optional[str]
    skip = kwargs.pop('skip', None)  # type: Optional[int]
    maxpagesize = kwargs.pop('maxpagesize', None)  # type: Optional[int]

    accept = "application/json"
    # Construct URL
    url = kwargs.pop("template_url", '/dataFeeds')

    # Construct parameters
    query_parameters = kwargs.pop("params", {})  # type: Dict[str, Any]
    if data_feed_name is not None:
        query_parameters['dataFeedName'] = _SERIALIZER.query("data_feed_name", data_feed_name, 'str')
    if data_source_type is not None:
        query_parameters['dataSourceType'] = _SERIALIZER.query("data_source_type", data_source_type, 'str')
    if granularity_name is not None:
        query_parameters['granularityName'] = _SERIALIZER.query("granularity_name", granularity_name, 'str')
    if status is not None:
        query_parameters['status'] = _SERIALIZER.query("status", status, 'str')
    if creator is not None:
        query_parameters['creator'] = _SERIALIZER.query("creator", creator, 'str')
    if skip is not None:
        query_parameters['$skip'] = _SERIALIZER.query("skip", skip, 'int')
    if maxpagesize is not None:
        query_parameters['$maxpagesize'] = _SERIALIZER.query("maxpagesize", maxpagesize, 'int')

    # Construct headers
    header_parameters = kwargs.pop("headers", {})  # type: Dict[str, Any]
    header_parameters['Accept'] = _SERIALIZER.header("accept", accept, 'str')

    return HttpRequest(
        method="GET",
        url=url,
        params=query_parameters,
        headers=header_parameters,
        **kwargs
    )


def build_create_data_feed_request(
    **kwargs  # type: Any
):
    # type: (...) -> HttpRequest
    content_type = kwargs.pop('content_type', None)  # type: Optional[str]

    accept = "application/json"
    # Construct URL
    url = kwargs.pop("template_url", '/dataFeeds')

    # Construct headers
    header_parameters = kwargs.pop("headers", {})  # type: Dict[str, Any]
    if content_type is not None:
        header_parameters['Content-Type'] = _SERIALIZER.header("content_type", content_type, 'str')
    header_parameters['Accept'] = _SERIALIZER.header("accept", accept, 'str')

    return HttpRequest(
        method="POST",
        url=url,
        headers=header_parameters,
        **kwargs
    )


def build_get_data_feed_by_id_request(
    data_feed_id,  # type: str
    **kwargs  # type: Any
):
    # type: (...) -> HttpRequest
    accept = "application/json"
    # Construct URL
    url = kwargs.pop("template_url", '/dataFeeds/{dataFeedId}')
    path_format_arguments = {
        "dataFeedId": _SERIALIZER.url("data_feed_id", data_feed_id, 'str'),
    }

    url = _format_url_section(url, **path_format_arguments)

    # Construct headers
    header_parameters = kwargs.pop("headers", {})  # type: Dict[str, Any]
    header_parameters['Accept'] = _SERIALIZER.header("accept", accept, 'str')

    return HttpRequest(
        method="GET",
        url=url,
        headers=header_parameters,
        **kwargs
    )


def build_update_data_feed_request(
    data_feed_id,  # type: str
    **kwargs  # type: Any
):
    # type: (...) -> HttpRequest
    content_type = kwargs.pop('content_type', None)  # type: Optional[str]

    accept = "application/json"
    # Construct URL
    url = kwargs.pop("template_url", '/dataFeeds/{dataFeedId}')
    path_format_arguments = {
        "dataFeedId": _SERIALIZER.url("data_feed_id", data_feed_id, 'str'),
    }

    url = _format_url_section(url, **path_format_arguments)

    # Construct headers
    header_parameters = kwargs.pop("headers", {})  # type: Dict[str, Any]
    if content_type is not None:
        header_parameters['Content-Type'] = _SERIALIZER.header("content_type", content_type, 'str')
    header_parameters['Accept'] = _SERIALIZER.header("accept", accept, 'str')

    return HttpRequest(
        method="PATCH",
        url=url,
        headers=header_parameters,
        **kwargs
    )


def build_delete_data_feed_request(
    data_feed_id,  # type: str
    **kwargs  # type: Any
):
    # type: (...) -> HttpRequest
    accept = "application/json"
    # Construct URL
    url = kwargs.pop("template_url", '/dataFeeds/{dataFeedId}')
    path_format_arguments = {
        "dataFeedId": _SERIALIZER.url("data_feed_id", data_feed_id, 'str'),
    }

    url = _format_url_section(url, **path_format_arguments)

    # Construct headers
    header_parameters = kwargs.pop("headers", {})  # type: Dict[str, Any]
    header_parameters['Accept'] = _SERIALIZER.header("accept", accept, 'str')

    return HttpRequest(
        method="DELETE",
        url=url,
        headers=header_parameters,
        **kwargs
    )


def build_get_metric_feedback_request(
    feedback_id,  # type: str
    **kwargs  # type: Any
):
    # type: (...) -> HttpRequest
    accept = "application/json"
    # Construct URL
    url = kwargs.pop("template_url", '/feedback/metric/{feedbackId}')
    path_format_arguments = {
        "feedbackId": _SERIALIZER.url("feedback_id", feedback_id, 'str'),
    }

    url = _format_url_section(url, **path_format_arguments)

    # Construct headers
    header_parameters = kwargs.pop("headers", {})  # type: Dict[str, Any]
    header_parameters['Accept'] = _SERIALIZER.header("accept", accept, 'str')

    return HttpRequest(
        method="GET",
        url=url,
        headers=header_parameters,
        **kwargs
    )


def build_list_metric_feedbacks_request(
    **kwargs  # type: Any
):
    # type: (...) -> HttpRequest
    content_type = kwargs.pop('content_type', None)  # type: Optional[str]
    skip = kwargs.pop('skip', None)  # type: Optional[int]
    maxpagesize = kwargs.pop('maxpagesize', None)  # type: Optional[int]

    accept = "application/json"
    # Construct URL
    url = kwargs.pop("template_url", '/feedback/metric/query')

    # Construct parameters
    query_parameters = kwargs.pop("params", {})  # type: Dict[str, Any]
    if skip is not None:
        query_parameters['$skip'] = _SERIALIZER.query("skip", skip, 'int')
    if maxpagesize is not None:
        query_parameters['$maxpagesize'] = _SERIALIZER.query("maxpagesize", maxpagesize, 'int')

    # Construct headers
    header_parameters = kwargs.pop("headers", {})  # type: Dict[str, Any]
    if content_type is not None:
        header_parameters['Content-Type'] = _SERIALIZER.header("content_type", content_type, 'str')
    header_parameters['Accept'] = _SERIALIZER.header("accept", accept, 'str')

    return HttpRequest(
        method="POST",
        url=url,
        params=query_parameters,
        headers=header_parameters,
        **kwargs
    )


def build_create_metric_feedback_request(
    **kwargs  # type: Any
):
    # type: (...) -> HttpRequest
    content_type = kwargs.pop('content_type', None)  # type: Optional[str]

    accept = "application/json"
    # Construct URL
    url = kwargs.pop("template_url", '/feedback/metric')

    # Construct headers
    header_parameters = kwargs.pop("headers", {})  # type: Dict[str, Any]
    if content_type is not None:
        header_parameters['Content-Type'] = _SERIALIZER.header("content_type", content_type, 'str')
    header_parameters['Accept'] = _SERIALIZER.header("accept", accept, 'str')

    return HttpRequest(
        method="POST",
        url=url,
        headers=header_parameters,
        **kwargs
    )


def build_list_hooks_request(
    **kwargs  # type: Any
):
    # type: (...) -> HttpRequest
    hook_name = kwargs.pop('hook_name', None)  # type: Optional[str]
    skip = kwargs.pop('skip', None)  # type: Optional[int]
    maxpagesize = kwargs.pop('maxpagesize', None)  # type: Optional[int]

    accept = "application/json"
    # Construct URL
    url = kwargs.pop("template_url", '/hooks')

    # Construct parameters
    query_parameters = kwargs.pop("params", {})  # type: Dict[str, Any]
    if hook_name is not None:
        query_parameters['hookName'] = _SERIALIZER.query("hook_name", hook_name, 'str')
    if skip is not None:
        query_parameters['$skip'] = _SERIALIZER.query("skip", skip, 'int')
    if maxpagesize is not None:
        query_parameters['$maxpagesize'] = _SERIALIZER.query("maxpagesize", maxpagesize, 'int')

    # Construct headers
    header_parameters = kwargs.pop("headers", {})  # type: Dict[str, Any]
    header_parameters['Accept'] = _SERIALIZER.header("accept", accept, 'str')

    return HttpRequest(
        method="GET",
        url=url,
        params=query_parameters,
        headers=header_parameters,
        **kwargs
    )


def build_create_hook_request(
    **kwargs  # type: Any
):
    # type: (...) -> HttpRequest
    content_type = kwargs.pop('content_type', None)  # type: Optional[str]

    accept = "application/json"
    # Construct URL
    url = kwargs.pop("template_url", '/hooks')

    # Construct headers
    header_parameters = kwargs.pop("headers", {})  # type: Dict[str, Any]
    if content_type is not None:
        header_parameters['Content-Type'] = _SERIALIZER.header("content_type", content_type, 'str')
    header_parameters['Accept'] = _SERIALIZER.header("accept", accept, 'str')

    return HttpRequest(
        method="POST",
        url=url,
        headers=header_parameters,
        **kwargs
    )


def build_get_hook_request(
    hook_id,  # type: str
    **kwargs  # type: Any
):
    # type: (...) -> HttpRequest
    accept = "application/json"
    # Construct URL
    url = kwargs.pop("template_url", '/hooks/{hookId}')
    path_format_arguments = {
        "hookId": _SERIALIZER.url("hook_id", hook_id, 'str'),
    }

    url = _format_url_section(url, **path_format_arguments)

    # Construct headers
    header_parameters = kwargs.pop("headers", {})  # type: Dict[str, Any]
    header_parameters['Accept'] = _SERIALIZER.header("accept", accept, 'str')

    return HttpRequest(
        method="GET",
        url=url,
        headers=header_parameters,
        **kwargs
    )


def build_update_hook_request(
    hook_id,  # type: str
    **kwargs  # type: Any
):
    # type: (...) -> HttpRequest
    content_type = kwargs.pop('content_type', None)  # type: Optional[str]

    accept = "application/json"
    # Construct URL
    url = kwargs.pop("template_url", '/hooks/{hookId}')
    path_format_arguments = {
        "hookId": _SERIALIZER.url("hook_id", hook_id, 'str'),
    }

    url = _format_url_section(url, **path_format_arguments)

    # Construct headers
    header_parameters = kwargs.pop("headers", {})  # type: Dict[str, Any]
    if content_type is not None:
        header_parameters['Content-Type'] = _SERIALIZER.header("content_type", content_type, 'str')
    header_parameters['Accept'] = _SERIALIZER.header("accept", accept, 'str')

    return HttpRequest(
        method="PATCH",
        url=url,
        headers=header_parameters,
        **kwargs
    )


def build_delete_hook_request(
    hook_id,  # type: str
    **kwargs  # type: Any
):
    # type: (...) -> HttpRequest
    accept = "application/json"
    # Construct URL
    url = kwargs.pop("template_url", '/hooks/{hookId}')
    path_format_arguments = {
        "hookId": _SERIALIZER.url("hook_id", hook_id, 'str'),
    }

    url = _format_url_section(url, **path_format_arguments)

    # Construct headers
    header_parameters = kwargs.pop("headers", {})  # type: Dict[str, Any]
    header_parameters['Accept'] = _SERIALIZER.header("accept", accept, 'str')

    return HttpRequest(
        method="DELETE",
        url=url,
        headers=header_parameters,
        **kwargs
    )


def build_get_data_feed_ingestion_status_request(
    data_feed_id,  # type: str
    **kwargs  # type: Any
):
    # type: (...) -> HttpRequest
    content_type = kwargs.pop('content_type', None)  # type: Optional[str]
    skip = kwargs.pop('skip', None)  # type: Optional[int]
    maxpagesize = kwargs.pop('maxpagesize', None)  # type: Optional[int]

    accept = "application/json"
    # Construct URL
    url = kwargs.pop("template_url", '/dataFeeds/{dataFeedId}/ingestionStatus/query')
    path_format_arguments = {
        "dataFeedId": _SERIALIZER.url("data_feed_id", data_feed_id, 'str'),
    }

    url = _format_url_section(url, **path_format_arguments)

    # Construct parameters
    query_parameters = kwargs.pop("params", {})  # type: Dict[str, Any]
    if skip is not None:
        query_parameters['$skip'] = _SERIALIZER.query("skip", skip, 'int')
    if maxpagesize is not None:
        query_parameters['$maxpagesize'] = _SERIALIZER.query("maxpagesize", maxpagesize, 'int')

    # Construct headers
    header_parameters = kwargs.pop("headers", {})  # type: Dict[str, Any]
    if content_type is not None:
        header_parameters['Content-Type'] = _SERIALIZER.header("content_type", content_type, 'str')
    header_parameters['Accept'] = _SERIALIZER.header("accept", accept, 'str')

    return HttpRequest(
        method="POST",
        url=url,
        params=query_parameters,
        headers=header_parameters,
        **kwargs
    )


def build_reset_data_feed_ingestion_status_request(
    data_feed_id,  # type: str
    **kwargs  # type: Any
):
    # type: (...) -> HttpRequest
    content_type = kwargs.pop('content_type', None)  # type: Optional[str]

    accept = "application/json"
    # Construct URL
    url = kwargs.pop("template_url", '/dataFeeds/{dataFeedId}/ingestionProgress/reset')
    path_format_arguments = {
        "dataFeedId": _SERIALIZER.url("data_feed_id", data_feed_id, 'str'),
    }

    url = _format_url_section(url, **path_format_arguments)

    # Construct headers
    header_parameters = kwargs.pop("headers", {})  # type: Dict[str, Any]
    if content_type is not None:
        header_parameters['Content-Type'] = _SERIALIZER.header("content_type", content_type, 'str')
    header_parameters['Accept'] = _SERIALIZER.header("accept", accept, 'str')

    return HttpRequest(
        method="POST",
        url=url,
        headers=header_parameters,
        **kwargs
    )


def build_get_ingestion_progress_request(
    data_feed_id,  # type: str
    **kwargs  # type: Any
):
    # type: (...) -> HttpRequest
    accept = "application/json"
    # Construct URL
    url = kwargs.pop("template_url", '/dataFeeds/{dataFeedId}/ingestionProgress')
    path_format_arguments = {
        "dataFeedId": _SERIALIZER.url("data_feed_id", data_feed_id, 'str'),
    }

    url = _format_url_section(url, **path_format_arguments)

    # Construct headers
    header_parameters = kwargs.pop("headers", {})  # type: Dict[str, Any]
    header_parameters['Accept'] = _SERIALIZER.header("accept", accept, 'str')

    return HttpRequest(
        method="GET",
        url=url,
        headers=header_parameters,
        **kwargs
    )


def build_get_metric_data_request(
    metric_id,  # type: str
    **kwargs  # type: Any
):
    # type: (...) -> HttpRequest
    content_type = kwargs.pop('content_type', None)  # type: Optional[str]

    accept = "application/json"
    # Construct URL
    url = kwargs.pop("template_url", '/metrics/{metricId}/data/query')
    path_format_arguments = {
        "metricId": _SERIALIZER.url("metric_id", metric_id, 'str'),
    }

    url = _format_url_section(url, **path_format_arguments)

    # Construct headers
    header_parameters = kwargs.pop("headers", {})  # type: Dict[str, Any]
    if content_type is not None:
        header_parameters['Content-Type'] = _SERIALIZER.header("content_type", content_type, 'str')
    header_parameters['Accept'] = _SERIALIZER.header("accept", accept, 'str')

    return HttpRequest(
        method="POST",
        url=url,
        headers=header_parameters,
        **kwargs
    )


def build_get_metric_series_request(
    metric_id,  # type: str
    **kwargs  # type: Any
):
    # type: (...) -> HttpRequest
    content_type = kwargs.pop('content_type', None)  # type: Optional[str]
    skip = kwargs.pop('skip', None)  # type: Optional[int]
    maxpagesize = kwargs.pop('maxpagesize', None)  # type: Optional[int]

    accept = "application/json"
    # Construct URL
    url = kwargs.pop("template_url", '/metrics/{metricId}/series/query')
    path_format_arguments = {
        "metricId": _SERIALIZER.url("metric_id", metric_id, 'str'),
    }

    url = _format_url_section(url, **path_format_arguments)

    # Construct parameters
    query_parameters = kwargs.pop("params", {})  # type: Dict[str, Any]
    if skip is not None:
        query_parameters['$skip'] = _SERIALIZER.query("skip", skip, 'int')
    if maxpagesize is not None:
        query_parameters['$maxpagesize'] = _SERIALIZER.query("maxpagesize", maxpagesize, 'int')

    # Construct headers
    header_parameters = kwargs.pop("headers", {})  # type: Dict[str, Any]
    if content_type is not None:
        header_parameters['Content-Type'] = _SERIALIZER.header("content_type", content_type, 'str')
    header_parameters['Accept'] = _SERIALIZER.header("accept", accept, 'str')

    return HttpRequest(
        method="POST",
        url=url,
        params=query_parameters,
        headers=header_parameters,
        **kwargs
    )


def build_get_metric_dimension_request(
    metric_id,  # type: str
    **kwargs  # type: Any
):
    # type: (...) -> HttpRequest
    content_type = kwargs.pop('content_type', None)  # type: Optional[str]
    skip = kwargs.pop('skip', None)  # type: Optional[int]
    maxpagesize = kwargs.pop('maxpagesize', None)  # type: Optional[int]

    accept = "application/json"
    # Construct URL
    url = kwargs.pop("template_url", '/metrics/{metricId}/dimension/query')
    path_format_arguments = {
        "metricId": _SERIALIZER.url("metric_id", metric_id, 'str'),
    }

    url = _format_url_section(url, **path_format_arguments)

    # Construct parameters
    query_parameters = kwargs.pop("params", {})  # type: Dict[str, Any]
    if skip is not None:
        query_parameters['$skip'] = _SERIALIZER.query("skip", skip, 'int')
    if maxpagesize is not None:
        query_parameters['$maxpagesize'] = _SERIALIZER.query("maxpagesize", maxpagesize, 'int')

    # Construct headers
    header_parameters = kwargs.pop("headers", {})  # type: Dict[str, Any]
    if content_type is not None:
        header_parameters['Content-Type'] = _SERIALIZER.header("content_type", content_type, 'str')
    header_parameters['Accept'] = _SERIALIZER.header("accept", accept, 'str')

    return HttpRequest(
        method="POST",
        url=url,
        params=query_parameters,
        headers=header_parameters,
        **kwargs
    )


def build_get_anomaly_detection_configurations_by_metric_request(
    metric_id,  # type: str
    **kwargs  # type: Any
):
    # type: (...) -> HttpRequest
    skip = kwargs.pop('skip', None)  # type: Optional[int]
    maxpagesize = kwargs.pop('maxpagesize', None)  # type: Optional[int]

    accept = "application/json"
    # Construct URL
    url = kwargs.pop("template_url", '/metrics/{metricId}/enrichment/anomalyDetection/configurations')
    path_format_arguments = {
        "metricId": _SERIALIZER.url("metric_id", metric_id, 'str'),
    }

    url = _format_url_section(url, **path_format_arguments)

    # Construct parameters
    query_parameters = kwargs.pop("params", {})  # type: Dict[str, Any]
    if skip is not None:
        query_parameters['$skip'] = _SERIALIZER.query("skip", skip, 'int')
    if maxpagesize is not None:
        query_parameters['$maxpagesize'] = _SERIALIZER.query("maxpagesize", maxpagesize, 'int')

    # Construct headers
    header_parameters = kwargs.pop("headers", {})  # type: Dict[str, Any]
    header_parameters['Accept'] = _SERIALIZER.header("accept", accept, 'str')

    return HttpRequest(
        method="GET",
        url=url,
        params=query_parameters,
        headers=header_parameters,
        **kwargs
    )


def build_get_enrichment_status_by_metric_request(
    metric_id,  # type: str
    **kwargs  # type: Any
):
    # type: (...) -> HttpRequest
    content_type = kwargs.pop('content_type', None)  # type: Optional[str]
    skip = kwargs.pop('skip', None)  # type: Optional[int]
    maxpagesize = kwargs.pop('maxpagesize', None)  # type: Optional[int]

    accept = "application/json"
    # Construct URL
    url = kwargs.pop("template_url", '/metrics/{metricId}/status/enrichment/anomalyDetection/query')
    path_format_arguments = {
        "metricId": _SERIALIZER.url("metric_id", metric_id, 'str'),
    }

    url = _format_url_section(url, **path_format_arguments)

    # Construct parameters
    query_parameters = kwargs.pop("params", {})  # type: Dict[str, Any]
    if skip is not None:
        query_parameters['$skip'] = _SERIALIZER.query("skip", skip, 'int')
    if maxpagesize is not None:
        query_parameters['$maxpagesize'] = _SERIALIZER.query("maxpagesize", maxpagesize, 'int')

    # Construct headers
    header_parameters = kwargs.pop("headers", {})  # type: Dict[str, Any]
    if content_type is not None:
        header_parameters['Content-Type'] = _SERIALIZER.header("content_type", content_type, 'str')
    header_parameters['Accept'] = _SERIALIZER.header("accept", accept, 'str')

    return HttpRequest(
        method="POST",
        url=url,
        params=query_parameters,
        headers=header_parameters,
        **kwargs
    )

# fmt: on
class MetricsAdvisorOperationsMixin(object):

    @distributed_trace
    def get_active_series_count(
        self,
        **kwargs  # type: Any
    ):
        # type: (...) -> "_models.UsageStats"
        """Get latest usage stats.

        Get latest usage stats.

        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: UsageStats, or the result of cls(response)
        :rtype: ~azure.ai.metricsadvisor.models.UsageStats
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType["_models.UsageStats"]
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}))

        
        request = build_get_active_series_count_request(
            template_url=self.get_active_series_count.metadata['url'],
        )
        request = _convert_request(request)
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, 'str', skip_quote=True),
        }
        request.url = self._client.format_url(request.url, **path_format_arguments)

        pipeline_response = self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize.failsafe_deserialize(_models.ErrorCode, pipeline_response)
            raise HttpResponseError(response=response, model=error)

        deserialized = self._deserialize('UsageStats', pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized

    get_active_series_count.metadata = {'url': '/stats/latest'}  # type: ignore


    @distributed_trace
    def get_anomaly_alerting_configuration(
        self,
        configuration_id,  # type: str
        **kwargs  # type: Any
    ):
        # type: (...) -> "_models.AnomalyAlertingConfiguration"
        """Query a single anomaly alerting configuration.

        Query a single anomaly alerting configuration.

        :param configuration_id: anomaly alerting configuration unique id.
        :type configuration_id: str
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: AnomalyAlertingConfiguration, or the result of cls(response)
        :rtype: ~azure.ai.metricsadvisor.models.AnomalyAlertingConfiguration
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType["_models.AnomalyAlertingConfiguration"]
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}))

        
        request = build_get_anomaly_alerting_configuration_request(
            configuration_id=configuration_id,
            template_url=self.get_anomaly_alerting_configuration.metadata['url'],
        )
        request = _convert_request(request)
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, 'str', skip_quote=True),
        }
        request.url = self._client.format_url(request.url, **path_format_arguments)

        pipeline_response = self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize.failsafe_deserialize(_models.ErrorCode, pipeline_response)
            raise HttpResponseError(response=response, model=error)

        deserialized = self._deserialize('AnomalyAlertingConfiguration', pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized

    get_anomaly_alerting_configuration.metadata = {'url': '/alert/anomaly/configurations/{configurationId}'}  # type: ignore


    @distributed_trace
    def update_anomaly_alerting_configuration(
        self,
        configuration_id,  # type: str
        body,  # type: "_models.AnomalyAlertingConfigurationPatch"
        **kwargs  # type: Any
    ):
        # type: (...) -> "_models.AnomalyAlertingConfiguration"
        """Update anomaly alerting configuration.

        Update anomaly alerting configuration.

        :param configuration_id: anomaly alerting configuration unique id.
        :type configuration_id: str
        :param body: anomaly alerting configuration.
        :type body: ~azure.ai.metricsadvisor.models.AnomalyAlertingConfigurationPatch
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: AnomalyAlertingConfiguration, or the result of cls(response)
        :rtype: ~azure.ai.metricsadvisor.models.AnomalyAlertingConfiguration
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType["_models.AnomalyAlertingConfiguration"]
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}))

        content_type = kwargs.pop('content_type', "application/merge-patch+json")  # type: Optional[str]

        content = self._serialize.body(body, 'AnomalyAlertingConfigurationPatch')

        request = build_update_anomaly_alerting_configuration_request(
            configuration_id=configuration_id,
            content_type=content_type,
            content=content,
            template_url=self.update_anomaly_alerting_configuration.metadata['url'],
        )
        request = _convert_request(request)
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, 'str', skip_quote=True),
        }
        request.url = self._client.format_url(request.url, **path_format_arguments)

        pipeline_response = self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize.failsafe_deserialize(_models.ErrorCode, pipeline_response)
            raise HttpResponseError(response=response, model=error)

        deserialized = self._deserialize('AnomalyAlertingConfiguration', pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized

    update_anomaly_alerting_configuration.metadata = {'url': '/alert/anomaly/configurations/{configurationId}'}  # type: ignore


    @distributed_trace
    def delete_anomaly_alerting_configuration(
        self,
        configuration_id,  # type: str
        **kwargs  # type: Any
    ):
        # type: (...) -> None
        """Delete anomaly alerting configuration.

        Delete anomaly alerting configuration.

        :param configuration_id: anomaly alerting configuration unique id.
        :type configuration_id: str
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: None, or the result of cls(response)
        :rtype: None
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType[None]
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}))

        
        request = build_delete_anomaly_alerting_configuration_request(
            configuration_id=configuration_id,
            template_url=self.delete_anomaly_alerting_configuration.metadata['url'],
        )
        request = _convert_request(request)
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, 'str', skip_quote=True),
        }
        request.url = self._client.format_url(request.url, **path_format_arguments)

        pipeline_response = self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [204]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize.failsafe_deserialize(_models.ErrorCode, pipeline_response)
            raise HttpResponseError(response=response, model=error)

        if cls:
            return cls(pipeline_response, None, {})

    delete_anomaly_alerting_configuration.metadata = {'url': '/alert/anomaly/configurations/{configurationId}'}  # type: ignore


    @distributed_trace
    def create_anomaly_alerting_configuration(
        self,
        body,  # type: "_models.AnomalyAlertingConfiguration"
        **kwargs  # type: Any
    ):
        # type: (...) -> None
        """Create anomaly alerting configuration.

        Create anomaly alerting configuration.

        :param body: anomaly alerting configuration.
        :type body: ~azure.ai.metricsadvisor.models.AnomalyAlertingConfiguration
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: None, or the result of cls(response)
        :rtype: None
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType[None]
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}))

        content_type = kwargs.pop('content_type', "application/json")  # type: Optional[str]

        json = self._serialize.body(body, 'AnomalyAlertingConfiguration')

        request = build_create_anomaly_alerting_configuration_request(
            content_type=content_type,
            json=json,
            template_url=self.create_anomaly_alerting_configuration.metadata['url'],
        )
        request = _convert_request(request)
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, 'str', skip_quote=True),
        }
        request.url = self._client.format_url(request.url, **path_format_arguments)

        pipeline_response = self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [201]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize.failsafe_deserialize(_models.ErrorCode, pipeline_response)
            raise HttpResponseError(response=response, model=error)

        response_headers = {}
        response_headers['Location']=self._deserialize('str', response.headers.get('Location'))


        if cls:
            return cls(pipeline_response, None, response_headers)

    create_anomaly_alerting_configuration.metadata = {'url': '/alert/anomaly/configurations'}  # type: ignore


    @distributed_trace
    def get_alerts_by_anomaly_alerting_configuration(
        self,
        configuration_id,  # type: str
        body,  # type: "_models.AlertingResultQuery"
        skip=None,  # type: Optional[int]
        maxpagesize=None,  # type: Optional[int]
        **kwargs  # type: Any
    ):
        # type: (...) -> Iterable["_models.AlertResultList"]
        """Query alerts under anomaly alerting configuration.

        Query alerts under anomaly alerting configuration.

        :param configuration_id: anomaly alerting configuration unique id.
        :type configuration_id: str
        :param body: query alerting result request.
        :type body: ~azure.ai.metricsadvisor.models.AlertingResultQuery
        :param skip: for paging, skipped number.
        :type skip: int
        :param maxpagesize: the maximum number of items in one page.
        :type maxpagesize: int
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: An iterator like instance of either AlertResultList or the result of cls(response)
        :rtype: ~azure.core.paging.ItemPaged[~azure.ai.metricsadvisor.models.AlertResultList]
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        content_type = kwargs.pop('content_type', "application/json")  # type: Optional[str]

        cls = kwargs.pop('cls', None)  # type: ClsType["_models.AlertResultList"]
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}))
        def prepare_request(next_link=None):
            if not next_link:
                json = self._serialize.body(body, 'AlertingResultQuery')
                
                request = build_get_alerts_by_anomaly_alerting_configuration_request(
                    configuration_id=configuration_id,
                    content_type=content_type,
                    json=json,
                    skip=skip,
                    maxpagesize=maxpagesize,
                    template_url=self.get_alerts_by_anomaly_alerting_configuration.metadata['url'],
                )
                request = _convert_request(request)
                path_format_arguments = {
                    "endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, 'str', skip_quote=True),
                }
                request.url = self._client.format_url(request.url, **path_format_arguments)

            else:
                json = self._serialize.body(body, 'AlertingResultQuery')
                
                request = build_get_alerts_by_anomaly_alerting_configuration_request(
                    configuration_id=configuration_id,
                    content_type=content_type,
                    json=json,
                    skip=skip,
                    maxpagesize=maxpagesize,
                    template_url=next_link,
                )
                request = _convert_request(request)
                path_format_arguments = {
                    "endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, 'str', skip_quote=True),
                }
                request.url = self._client.format_url(request.url, **path_format_arguments)

                path_format_arguments = {
                    "endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, 'str', skip_quote=True),
                }
                request.method = "GET"
            return request

        def extract_data(pipeline_response):
            deserialized = self._deserialize("AlertResultList", pipeline_response)
            list_of_elem = deserialized.value
            if cls:
                list_of_elem = cls(list_of_elem)
            return deserialized.next_link or None, iter(list_of_elem)

        def get_next(next_link=None):
            request = prepare_request(next_link)

            pipeline_response = self._client._pipeline.run(request, stream=False, **kwargs)
            response = pipeline_response.http_response

            if response.status_code not in [200]:
                map_error(status_code=response.status_code, response=response, error_map=error_map)
                error = self._deserialize.failsafe_deserialize(_models.ErrorCode, pipeline_response)
                raise HttpResponseError(response=response, model=error)

            return pipeline_response


        return ItemPaged(
            get_next, extract_data
        )
    get_alerts_by_anomaly_alerting_configuration.metadata = {'url': '/alert/anomaly/configurations/{configurationId}/alerts/query'}  # type: ignore

    @distributed_trace
    def get_anomalies_from_alert_by_anomaly_alerting_configuration(
        self,
        configuration_id,  # type: str
        alert_id,  # type: str
        skip=None,  # type: Optional[int]
        maxpagesize=None,  # type: Optional[int]
        **kwargs  # type: Any
    ):
        # type: (...) -> Iterable["_models.AnomalyResultList"]
        """Query anomalies under a specific alert.

        Query anomalies under a specific alert.

        :param configuration_id: anomaly alerting configuration unique id.
        :type configuration_id: str
        :param alert_id: alert id.
        :type alert_id: str
        :param skip: for paging, skipped number.
        :type skip: int
        :param maxpagesize: the maximum number of items in one page.
        :type maxpagesize: int
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: An iterator like instance of either AnomalyResultList or the result of cls(response)
        :rtype: ~azure.core.paging.ItemPaged[~azure.ai.metricsadvisor.models.AnomalyResultList]
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType["_models.AnomalyResultList"]
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}))
        def prepare_request(next_link=None):
            if not next_link:
                
                request = build_get_anomalies_from_alert_by_anomaly_alerting_configuration_request(
                    configuration_id=configuration_id,
                    alert_id=alert_id,
                    skip=skip,
                    maxpagesize=maxpagesize,
                    template_url=self.get_anomalies_from_alert_by_anomaly_alerting_configuration.metadata['url'],
                )
                request = _convert_request(request)
                path_format_arguments = {
                    "endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, 'str', skip_quote=True),
                }
                request.url = self._client.format_url(request.url, **path_format_arguments)

            else:
                
                request = build_get_anomalies_from_alert_by_anomaly_alerting_configuration_request(
                    configuration_id=configuration_id,
                    alert_id=alert_id,
                    skip=skip,
                    maxpagesize=maxpagesize,
                    template_url=next_link,
                )
                request = _convert_request(request)
                path_format_arguments = {
                    "endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, 'str', skip_quote=True),
                }
                request.url = self._client.format_url(request.url, **path_format_arguments)

                path_format_arguments = {
                    "endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, 'str', skip_quote=True),
                }
                request.method = "GET"
            return request

        def extract_data(pipeline_response):
            deserialized = self._deserialize("AnomalyResultList", pipeline_response)
            list_of_elem = deserialized.value
            if cls:
                list_of_elem = cls(list_of_elem)
            return deserialized.next_link or None, iter(list_of_elem)

        def get_next(next_link=None):
            request = prepare_request(next_link)

            pipeline_response = self._client._pipeline.run(request, stream=False, **kwargs)
            response = pipeline_response.http_response

            if response.status_code not in [200]:
                map_error(status_code=response.status_code, response=response, error_map=error_map)
                error = self._deserialize.failsafe_deserialize(_models.ErrorCode, pipeline_response)
                raise HttpResponseError(response=response, model=error)

            return pipeline_response


        return ItemPaged(
            get_next, extract_data
        )
    get_anomalies_from_alert_by_anomaly_alerting_configuration.metadata = {'url': '/alert/anomaly/configurations/{configurationId}/alerts/{alertId}/anomalies'}  # type: ignore

    @distributed_trace
    def get_incidents_from_alert_by_anomaly_alerting_configuration(
        self,
        configuration_id,  # type: str
        alert_id,  # type: str
        skip=None,  # type: Optional[int]
        maxpagesize=None,  # type: Optional[int]
        **kwargs  # type: Any
    ):
        # type: (...) -> Iterable["_models.IncidentResultList"]
        """Query incidents under a specific alert.

        Query incidents under a specific alert.

        :param configuration_id: anomaly alerting configuration unique id.
        :type configuration_id: str
        :param alert_id: alert id.
        :type alert_id: str
        :param skip: for paging, skipped number.
        :type skip: int
        :param maxpagesize: the maximum number of items in one page.
        :type maxpagesize: int
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: An iterator like instance of either IncidentResultList or the result of cls(response)
        :rtype: ~azure.core.paging.ItemPaged[~azure.ai.metricsadvisor.models.IncidentResultList]
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType["_models.IncidentResultList"]
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}))
        def prepare_request(next_link=None):
            if not next_link:
                
                request = build_get_incidents_from_alert_by_anomaly_alerting_configuration_request(
                    configuration_id=configuration_id,
                    alert_id=alert_id,
                    skip=skip,
                    maxpagesize=maxpagesize,
                    template_url=self.get_incidents_from_alert_by_anomaly_alerting_configuration.metadata['url'],
                )
                request = _convert_request(request)
                path_format_arguments = {
                    "endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, 'str', skip_quote=True),
                }
                request.url = self._client.format_url(request.url, **path_format_arguments)

            else:
                
                request = build_get_incidents_from_alert_by_anomaly_alerting_configuration_request(
                    configuration_id=configuration_id,
                    alert_id=alert_id,
                    skip=skip,
                    maxpagesize=maxpagesize,
                    template_url=next_link,
                )
                request = _convert_request(request)
                path_format_arguments = {
                    "endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, 'str', skip_quote=True),
                }
                request.url = self._client.format_url(request.url, **path_format_arguments)

                path_format_arguments = {
                    "endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, 'str', skip_quote=True),
                }
                request.method = "GET"
            return request

        def extract_data(pipeline_response):
            deserialized = self._deserialize("IncidentResultList", pipeline_response)
            list_of_elem = deserialized.value
            if cls:
                list_of_elem = cls(list_of_elem)
            return deserialized.next_link or None, iter(list_of_elem)

        def get_next(next_link=None):
            request = prepare_request(next_link)

            pipeline_response = self._client._pipeline.run(request, stream=False, **kwargs)
            response = pipeline_response.http_response

            if response.status_code not in [200]:
                map_error(status_code=response.status_code, response=response, error_map=error_map)
                error = self._deserialize.failsafe_deserialize(_models.ErrorCode, pipeline_response)
                raise HttpResponseError(response=response, model=error)

            return pipeline_response


        return ItemPaged(
            get_next, extract_data
        )
    get_incidents_from_alert_by_anomaly_alerting_configuration.metadata = {'url': '/alert/anomaly/configurations/{configurationId}/alerts/{alertId}/incidents'}  # type: ignore

    @distributed_trace
    def get_anomaly_detection_configuration(
        self,
        configuration_id,  # type: str
        **kwargs  # type: Any
    ):
        # type: (...) -> "_models.AnomalyDetectionConfiguration"
        """Query a single anomaly detection configuration.

        Query a single anomaly detection configuration.

        :param configuration_id: anomaly detection configuration unique id.
        :type configuration_id: str
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: AnomalyDetectionConfiguration, or the result of cls(response)
        :rtype: ~azure.ai.metricsadvisor.models.AnomalyDetectionConfiguration
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType["_models.AnomalyDetectionConfiguration"]
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}))

        
        request = build_get_anomaly_detection_configuration_request(
            configuration_id=configuration_id,
            template_url=self.get_anomaly_detection_configuration.metadata['url'],
        )
        request = _convert_request(request)
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, 'str', skip_quote=True),
        }
        request.url = self._client.format_url(request.url, **path_format_arguments)

        pipeline_response = self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize.failsafe_deserialize(_models.ErrorCode, pipeline_response)
            raise HttpResponseError(response=response, model=error)

        deserialized = self._deserialize('AnomalyDetectionConfiguration', pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized

    get_anomaly_detection_configuration.metadata = {'url': '/enrichment/anomalyDetection/configurations/{configurationId}'}  # type: ignore


    @distributed_trace
    def update_anomaly_detection_configuration(
        self,
        configuration_id,  # type: str
        body,  # type: "_models.AnomalyDetectionConfigurationPatch"
        **kwargs  # type: Any
    ):
        # type: (...) -> "_models.AnomalyDetectionConfiguration"
        """Update anomaly detection configuration.

        Update anomaly detection configuration.

        :param configuration_id: anomaly detection configuration unique id.
        :type configuration_id: str
        :param body: anomaly detection configuration.
        :type body: ~azure.ai.metricsadvisor.models.AnomalyDetectionConfigurationPatch
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: AnomalyDetectionConfiguration, or the result of cls(response)
        :rtype: ~azure.ai.metricsadvisor.models.AnomalyDetectionConfiguration
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType["_models.AnomalyDetectionConfiguration"]
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}))

        content_type = kwargs.pop('content_type', "application/merge-patch+json")  # type: Optional[str]

        content = self._serialize.body(body, 'AnomalyDetectionConfigurationPatch')

        request = build_update_anomaly_detection_configuration_request(
            configuration_id=configuration_id,
            content_type=content_type,
            content=content,
            template_url=self.update_anomaly_detection_configuration.metadata['url'],
        )
        request = _convert_request(request)
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, 'str', skip_quote=True),
        }
        request.url = self._client.format_url(request.url, **path_format_arguments)

        pipeline_response = self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize.failsafe_deserialize(_models.ErrorCode, pipeline_response)
            raise HttpResponseError(response=response, model=error)

        deserialized = self._deserialize('AnomalyDetectionConfiguration', pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized

    update_anomaly_detection_configuration.metadata = {'url': '/enrichment/anomalyDetection/configurations/{configurationId}'}  # type: ignore


    @distributed_trace
    def delete_anomaly_detection_configuration(
        self,
        configuration_id,  # type: str
        **kwargs  # type: Any
    ):
        # type: (...) -> None
        """Delete anomaly detection configuration.

        Delete anomaly detection configuration.

        :param configuration_id: anomaly detection configuration unique id.
        :type configuration_id: str
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: None, or the result of cls(response)
        :rtype: None
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType[None]
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}))

        
        request = build_delete_anomaly_detection_configuration_request(
            configuration_id=configuration_id,
            template_url=self.delete_anomaly_detection_configuration.metadata['url'],
        )
        request = _convert_request(request)
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, 'str', skip_quote=True),
        }
        request.url = self._client.format_url(request.url, **path_format_arguments)

        pipeline_response = self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [204]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize.failsafe_deserialize(_models.ErrorCode, pipeline_response)
            raise HttpResponseError(response=response, model=error)

        if cls:
            return cls(pipeline_response, None, {})

    delete_anomaly_detection_configuration.metadata = {'url': '/enrichment/anomalyDetection/configurations/{configurationId}'}  # type: ignore


    @distributed_trace
    def create_anomaly_detection_configuration(
        self,
        body,  # type: "_models.AnomalyDetectionConfiguration"
        **kwargs  # type: Any
    ):
        # type: (...) -> None
        """Create anomaly detection configuration.

        Create anomaly detection configuration.

        :param body: anomaly detection configuration.
        :type body: ~azure.ai.metricsadvisor.models.AnomalyDetectionConfiguration
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: None, or the result of cls(response)
        :rtype: None
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType[None]
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}))

        content_type = kwargs.pop('content_type', "application/json")  # type: Optional[str]

        json = self._serialize.body(body, 'AnomalyDetectionConfiguration')

        request = build_create_anomaly_detection_configuration_request(
            content_type=content_type,
            json=json,
            template_url=self.create_anomaly_detection_configuration.metadata['url'],
        )
        request = _convert_request(request)
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, 'str', skip_quote=True),
        }
        request.url = self._client.format_url(request.url, **path_format_arguments)

        pipeline_response = self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [201]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize.failsafe_deserialize(_models.ErrorCode, pipeline_response)
            raise HttpResponseError(response=response, model=error)

        response_headers = {}
        response_headers['Location']=self._deserialize('str', response.headers.get('Location'))


        if cls:
            return cls(pipeline_response, None, response_headers)

    create_anomaly_detection_configuration.metadata = {'url': '/enrichment/anomalyDetection/configurations'}  # type: ignore


    @distributed_trace
    def get_anomaly_alerting_configurations_by_anomaly_detection_configuration(
        self,
        configuration_id,  # type: str
        skip=None,  # type: Optional[int]
        maxpagesize=None,  # type: Optional[int]
        **kwargs  # type: Any
    ):
        # type: (...) -> Iterable["_models.AnomalyAlertingConfigurationList"]
        """List all anomaly alerting configurations for specific anomaly detection configuration.

        List all anomaly alerting configurations for specific anomaly detection configuration.

        :param configuration_id: anomaly detection configuration unique id.
        :type configuration_id: str
        :param skip: for paging, skipped number.
        :type skip: int
        :param maxpagesize: the maximum number of items in one page.
        :type maxpagesize: int
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: An iterator like instance of either AnomalyAlertingConfigurationList or the result of
         cls(response)
        :rtype:
         ~azure.core.paging.ItemPaged[~azure.ai.metricsadvisor.models.AnomalyAlertingConfigurationList]
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType["_models.AnomalyAlertingConfigurationList"]
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}))
        def prepare_request(next_link=None):
            if not next_link:
                
                request = build_get_anomaly_alerting_configurations_by_anomaly_detection_configuration_request(
                    configuration_id=configuration_id,
                    skip=skip,
                    maxpagesize=maxpagesize,
                    template_url=self.get_anomaly_alerting_configurations_by_anomaly_detection_configuration.metadata['url'],
                )
                request = _convert_request(request)
                path_format_arguments = {
                    "endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, 'str', skip_quote=True),
                }
                request.url = self._client.format_url(request.url, **path_format_arguments)

            else:
                
                request = build_get_anomaly_alerting_configurations_by_anomaly_detection_configuration_request(
                    configuration_id=configuration_id,
                    skip=skip,
                    maxpagesize=maxpagesize,
                    template_url=next_link,
                )
                request = _convert_request(request)
                path_format_arguments = {
                    "endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, 'str', skip_quote=True),
                }
                request.url = self._client.format_url(request.url, **path_format_arguments)

                path_format_arguments = {
                    "endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, 'str', skip_quote=True),
                }
                request.method = "GET"
            return request

        def extract_data(pipeline_response):
            deserialized = self._deserialize("AnomalyAlertingConfigurationList", pipeline_response)
            list_of_elem = deserialized.value
            if cls:
                list_of_elem = cls(list_of_elem)
            return deserialized.next_link or None, iter(list_of_elem)

        def get_next(next_link=None):
            request = prepare_request(next_link)

            pipeline_response = self._client._pipeline.run(request, stream=False, **kwargs)
            response = pipeline_response.http_response

            if response.status_code not in [200]:
                map_error(status_code=response.status_code, response=response, error_map=error_map)
                error = self._deserialize.failsafe_deserialize(_models.ErrorCode, pipeline_response)
                raise HttpResponseError(response=response, model=error)

            return pipeline_response


        return ItemPaged(
            get_next, extract_data
        )
    get_anomaly_alerting_configurations_by_anomaly_detection_configuration.metadata = {'url': '/enrichment/anomalyDetection/configurations/{configurationId}/alert/anomaly/configurations'}  # type: ignore

    @distributed_trace
    def get_series_by_anomaly_detection_configuration(
        self,
        configuration_id,  # type: str
        body,  # type: "_models.DetectionSeriesQuery"
        **kwargs  # type: Any
    ):
        # type: (...) -> "_models.SeriesResultList"
        """Query series enriched by anomaly detection.

        Query series enriched by anomaly detection.

        :param configuration_id: anomaly detection configuration unique id.
        :type configuration_id: str
        :param body: query series detection result request.
        :type body: ~azure.ai.metricsadvisor.models.DetectionSeriesQuery
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: SeriesResultList, or the result of cls(response)
        :rtype: ~azure.ai.metricsadvisor.models.SeriesResultList
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType["_models.SeriesResultList"]
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}))

        content_type = kwargs.pop('content_type', "application/json")  # type: Optional[str]

        json = self._serialize.body(body, 'DetectionSeriesQuery')

        request = build_get_series_by_anomaly_detection_configuration_request(
            configuration_id=configuration_id,
            content_type=content_type,
            json=json,
            template_url=self.get_series_by_anomaly_detection_configuration.metadata['url'],
        )
        request = _convert_request(request)
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, 'str', skip_quote=True),
        }
        request.url = self._client.format_url(request.url, **path_format_arguments)

        pipeline_response = self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize.failsafe_deserialize(_models.ErrorCode, pipeline_response)
            raise HttpResponseError(response=response, model=error)

        deserialized = self._deserialize('SeriesResultList', pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized

    get_series_by_anomaly_detection_configuration.metadata = {'url': '/enrichment/anomalyDetection/configurations/{configurationId}/series/query'}  # type: ignore


    @distributed_trace
    def get_anomalies_by_anomaly_detection_configuration(
        self,
        configuration_id,  # type: str
        body,  # type: "_models.DetectionAnomalyResultQuery"
        skip=None,  # type: Optional[int]
        maxpagesize=None,  # type: Optional[int]
        **kwargs  # type: Any
    ):
        # type: (...) -> Iterable["_models.AnomalyResultList"]
        """Query anomalies under anomaly detection configuration.

        Query anomalies under anomaly detection configuration.

        :param configuration_id: anomaly detection configuration unique id.
        :type configuration_id: str
        :param body: query detection anomaly result request.
        :type body: ~azure.ai.metricsadvisor.models.DetectionAnomalyResultQuery
        :param skip: for paging, skipped number.
        :type skip: int
        :param maxpagesize: the maximum number of items in one page.
        :type maxpagesize: int
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: An iterator like instance of either AnomalyResultList or the result of cls(response)
        :rtype: ~azure.core.paging.ItemPaged[~azure.ai.metricsadvisor.models.AnomalyResultList]
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        content_type = kwargs.pop('content_type', "application/json")  # type: Optional[str]

        cls = kwargs.pop('cls', None)  # type: ClsType["_models.AnomalyResultList"]
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}))
        def prepare_request(next_link=None):
            if not next_link:
                json = self._serialize.body(body, 'DetectionAnomalyResultQuery')
                
                request = build_get_anomalies_by_anomaly_detection_configuration_request(
                    configuration_id=configuration_id,
                    content_type=content_type,
                    json=json,
                    skip=skip,
                    maxpagesize=maxpagesize,
                    template_url=self.get_anomalies_by_anomaly_detection_configuration.metadata['url'],
                )
                request = _convert_request(request)
                path_format_arguments = {
                    "endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, 'str', skip_quote=True),
                }
                request.url = self._client.format_url(request.url, **path_format_arguments)

            else:
                json = self._serialize.body(body, 'DetectionAnomalyResultQuery')
                
                request = build_get_anomalies_by_anomaly_detection_configuration_request(
                    configuration_id=configuration_id,
                    content_type=content_type,
                    json=json,
                    skip=skip,
                    maxpagesize=maxpagesize,
                    template_url=next_link,
                )
                request = _convert_request(request)
                path_format_arguments = {
                    "endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, 'str', skip_quote=True),
                }
                request.url = self._client.format_url(request.url, **path_format_arguments)

                path_format_arguments = {
                    "endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, 'str', skip_quote=True),
                }
                request.method = "GET"
            return request

        def extract_data(pipeline_response):
            deserialized = self._deserialize("AnomalyResultList", pipeline_response)
            list_of_elem = deserialized.value
            if cls:
                list_of_elem = cls(list_of_elem)
            return deserialized.next_link or None, iter(list_of_elem)

        def get_next(next_link=None):
            request = prepare_request(next_link)

            pipeline_response = self._client._pipeline.run(request, stream=False, **kwargs)
            response = pipeline_response.http_response

            if response.status_code not in [200]:
                map_error(status_code=response.status_code, response=response, error_map=error_map)
                error = self._deserialize.failsafe_deserialize(_models.ErrorCode, pipeline_response)
                raise HttpResponseError(response=response, model=error)

            return pipeline_response


        return ItemPaged(
            get_next, extract_data
        )
    get_anomalies_by_anomaly_detection_configuration.metadata = {'url': '/enrichment/anomalyDetection/configurations/{configurationId}/anomalies/query'}  # type: ignore

    @distributed_trace
    def get_dimension_of_anomalies_by_anomaly_detection_configuration(
        self,
        configuration_id,  # type: str
        body,  # type: "_models.AnomalyDimensionQuery"
        skip=None,  # type: Optional[int]
        maxpagesize=None,  # type: Optional[int]
        **kwargs  # type: Any
    ):
        # type: (...) -> Iterable["_models.AnomalyDimensionList"]
        """Query dimension values of anomalies.

        Query dimension values of anomalies.

        :param configuration_id: anomaly detection configuration unique id.
        :type configuration_id: str
        :param body: query dimension values request.
        :type body: ~azure.ai.metricsadvisor.models.AnomalyDimensionQuery
        :param skip: for paging, skipped number.
        :type skip: int
        :param maxpagesize: the maximum number of items in one page.
        :type maxpagesize: int
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: An iterator like instance of either AnomalyDimensionList or the result of
         cls(response)
        :rtype: ~azure.core.paging.ItemPaged[~azure.ai.metricsadvisor.models.AnomalyDimensionList]
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        content_type = kwargs.pop('content_type', "application/json")  # type: Optional[str]

        cls = kwargs.pop('cls', None)  # type: ClsType["_models.AnomalyDimensionList"]
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}))
        def prepare_request(next_link=None):
            if not next_link:
                json = self._serialize.body(body, 'AnomalyDimensionQuery')
                
                request = build_get_dimension_of_anomalies_by_anomaly_detection_configuration_request(
                    configuration_id=configuration_id,
                    content_type=content_type,
                    json=json,
                    skip=skip,
                    maxpagesize=maxpagesize,
                    template_url=self.get_dimension_of_anomalies_by_anomaly_detection_configuration.metadata['url'],
                )
                request = _convert_request(request)
                path_format_arguments = {
                    "endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, 'str', skip_quote=True),
                }
                request.url = self._client.format_url(request.url, **path_format_arguments)

            else:
                json = self._serialize.body(body, 'AnomalyDimensionQuery')
                
                request = build_get_dimension_of_anomalies_by_anomaly_detection_configuration_request(
                    configuration_id=configuration_id,
                    content_type=content_type,
                    json=json,
                    skip=skip,
                    maxpagesize=maxpagesize,
                    template_url=next_link,
                )
                request = _convert_request(request)
                path_format_arguments = {
                    "endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, 'str', skip_quote=True),
                }
                request.url = self._client.format_url(request.url, **path_format_arguments)

                path_format_arguments = {
                    "endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, 'str', skip_quote=True),
                }
                request.method = "GET"
            return request

        def extract_data(pipeline_response):
            deserialized = self._deserialize("AnomalyDimensionList", pipeline_response)
            list_of_elem = deserialized.value
            if cls:
                list_of_elem = cls(list_of_elem)
            return deserialized.next_link or None, iter(list_of_elem)

        def get_next(next_link=None):
            request = prepare_request(next_link)

            pipeline_response = self._client._pipeline.run(request, stream=False, **kwargs)
            response = pipeline_response.http_response

            if response.status_code not in [200]:
                map_error(status_code=response.status_code, response=response, error_map=error_map)
                error = self._deserialize.failsafe_deserialize(_models.ErrorCode, pipeline_response)
                raise HttpResponseError(response=response, model=error)

            return pipeline_response


        return ItemPaged(
            get_next, extract_data
        )
    get_dimension_of_anomalies_by_anomaly_detection_configuration.metadata = {'url': '/enrichment/anomalyDetection/configurations/{configurationId}/anomalies/dimension/query'}  # type: ignore

    @distributed_trace
    def get_incidents_by_anomaly_detection_configuration(
        self,
        configuration_id,  # type: str
        body,  # type: "_models.DetectionIncidentResultQuery"
        maxpagesize=None,  # type: Optional[int]
        **kwargs  # type: Any
    ):
        # type: (...) -> Iterable["_models.IncidentResultList"]
        """Query incidents under anomaly detection configuration.

        Query incidents under anomaly detection configuration.

        :param configuration_id: anomaly detection configuration unique id.
        :type configuration_id: str
        :param body: query detection incident result request.
        :type body: ~azure.ai.metricsadvisor.models.DetectionIncidentResultQuery
        :param maxpagesize: the maximum number of items in one page.
        :type maxpagesize: int
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: An iterator like instance of either IncidentResultList or the result of cls(response)
        :rtype: ~azure.core.paging.ItemPaged[~azure.ai.metricsadvisor.models.IncidentResultList]
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        content_type = kwargs.pop('content_type', "application/json")  # type: Optional[str]

        cls = kwargs.pop('cls', None)  # type: ClsType["_models.IncidentResultList"]
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}))
        def prepare_request(next_link=None):
            if not next_link:
                json = self._serialize.body(body, 'DetectionIncidentResultQuery')
                
                request = build_get_incidents_by_anomaly_detection_configuration_request(
                    configuration_id=configuration_id,
                    content_type=content_type,
                    json=json,
                    maxpagesize=maxpagesize,
                    template_url=self.get_incidents_by_anomaly_detection_configuration.metadata['url'],
                )
                request = _convert_request(request)
                path_format_arguments = {
                    "endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, 'str', skip_quote=True),
                }
                request.url = self._client.format_url(request.url, **path_format_arguments)

            else:
                json = self._serialize.body(body, 'DetectionIncidentResultQuery')
                
                request = build_get_incidents_by_anomaly_detection_configuration_request(
                    configuration_id=configuration_id,
                    content_type=content_type,
                    json=json,
                    maxpagesize=maxpagesize,
                    template_url=next_link,
                )
                request = _convert_request(request)
                path_format_arguments = {
                    "endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, 'str', skip_quote=True),
                }
                request.url = self._client.format_url(request.url, **path_format_arguments)

                path_format_arguments = {
                    "endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, 'str', skip_quote=True),
                }
                request.method = "GET"
            return request

        def extract_data(pipeline_response):
            deserialized = self._deserialize("IncidentResultList", pipeline_response)
            list_of_elem = deserialized.value
            if cls:
                list_of_elem = cls(list_of_elem)
            return deserialized.next_link or None, iter(list_of_elem)

        def get_next(next_link=None):
            request = prepare_request(next_link)

            pipeline_response = self._client._pipeline.run(request, stream=False, **kwargs)
            response = pipeline_response.http_response

            if response.status_code not in [200]:
                map_error(status_code=response.status_code, response=response, error_map=error_map)
                error = self._deserialize.failsafe_deserialize(_models.ErrorCode, pipeline_response)
                raise HttpResponseError(response=response, model=error)

            return pipeline_response


        return ItemPaged(
            get_next, extract_data
        )
    get_incidents_by_anomaly_detection_configuration.metadata = {'url': '/enrichment/anomalyDetection/configurations/{configurationId}/incidents/query'}  # type: ignore

    @distributed_trace
    def get_incidents_by_anomaly_detection_configuration_next_pages(
        self,
        configuration_id,  # type: str
        maxpagesize=None,  # type: Optional[int]
        token=None,  # type: Optional[str]
        **kwargs  # type: Any
    ):
        # type: (...) -> Iterable["_models.IncidentResultList"]
        """Query incidents under anomaly detection configuration.

        Query incidents under anomaly detection configuration.

        :param configuration_id: anomaly detection configuration unique id.
        :type configuration_id: str
        :param maxpagesize: the maximum number of items in one page.
        :type maxpagesize: int
        :param token: the token for getting the next page.
        :type token: str
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: An iterator like instance of either IncidentResultList or the result of cls(response)
        :rtype: ~azure.core.paging.ItemPaged[~azure.ai.metricsadvisor.models.IncidentResultList]
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType["_models.IncidentResultList"]
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}))
        def prepare_request(next_link=None):
            if not next_link:
                
                request = build_get_incidents_by_anomaly_detection_configuration_next_pages_request(
                    configuration_id=configuration_id,
                    maxpagesize=maxpagesize,
                    token=token,
                    template_url=self.get_incidents_by_anomaly_detection_configuration_next_pages.metadata['url'],
                )
                request = _convert_request(request)
                path_format_arguments = {
                    "endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, 'str', skip_quote=True),
                }
                request.url = self._client.format_url(request.url, **path_format_arguments)

            else:
                
                request = build_get_incidents_by_anomaly_detection_configuration_next_pages_request(
                    configuration_id=configuration_id,
                    maxpagesize=maxpagesize,
                    token=token,
                    template_url=next_link,
                )
                request = _convert_request(request)
                path_format_arguments = {
                    "endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, 'str', skip_quote=True),
                }
                request.url = self._client.format_url(request.url, **path_format_arguments)

                path_format_arguments = {
                    "endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, 'str', skip_quote=True),
                }
                request.method = "GET"
            return request

        def extract_data(pipeline_response):
            deserialized = self._deserialize("IncidentResultList", pipeline_response)
            list_of_elem = deserialized.value
            if cls:
                list_of_elem = cls(list_of_elem)
            return deserialized.next_link or None, iter(list_of_elem)

        def get_next(next_link=None):
            request = prepare_request(next_link)

            pipeline_response = self._client._pipeline.run(request, stream=False, **kwargs)
            response = pipeline_response.http_response

            if response.status_code not in [200]:
                map_error(status_code=response.status_code, response=response, error_map=error_map)
                error = self._deserialize.failsafe_deserialize(_models.ErrorCode, pipeline_response)
                raise HttpResponseError(response=response, model=error)

            return pipeline_response


        return ItemPaged(
            get_next, extract_data
        )
    get_incidents_by_anomaly_detection_configuration_next_pages.metadata = {'url': '/enrichment/anomalyDetection/configurations/{configurationId}/incidents/query'}  # type: ignore

    @distributed_trace
    def get_root_cause_of_incident_by_anomaly_detection_configuration(
        self,
        configuration_id,  # type: str
        incident_id,  # type: str
        **kwargs  # type: Any
    ):
        # type: (...) -> "_models.RootCauseList"
        """Query root cause for incident.

        Query root cause for incident.

        :param configuration_id: anomaly detection configuration unique id.
        :type configuration_id: str
        :param incident_id: incident id.
        :type incident_id: str
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: RootCauseList, or the result of cls(response)
        :rtype: ~azure.ai.metricsadvisor.models.RootCauseList
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType["_models.RootCauseList"]
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}))

        
        request = build_get_root_cause_of_incident_by_anomaly_detection_configuration_request(
            configuration_id=configuration_id,
            incident_id=incident_id,
            template_url=self.get_root_cause_of_incident_by_anomaly_detection_configuration.metadata['url'],
        )
        request = _convert_request(request)
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, 'str', skip_quote=True),
        }
        request.url = self._client.format_url(request.url, **path_format_arguments)

        pipeline_response = self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize.failsafe_deserialize(_models.ErrorCode, pipeline_response)
            raise HttpResponseError(response=response, model=error)

        deserialized = self._deserialize('RootCauseList', pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized

    get_root_cause_of_incident_by_anomaly_detection_configuration.metadata = {'url': '/enrichment/anomalyDetection/configurations/{configurationId}/incidents/{incidentId}/rootCause'}  # type: ignore


    @distributed_trace
    def create_credential(
        self,
        body,  # type: "_models.DataSourceCredential"
        **kwargs  # type: Any
    ):
        # type: (...) -> None
        """Create a new data source credential.

        Create a new data source credential.

        :param body: Create data source credential request.
        :type body: ~azure.ai.metricsadvisor.models.DataSourceCredential
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: None, or the result of cls(response)
        :rtype: None
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType[None]
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}))

        content_type = kwargs.pop('content_type', "application/json")  # type: Optional[str]

        json = self._serialize.body(body, 'DataSourceCredential')

        request = build_create_credential_request(
            content_type=content_type,
            json=json,
            template_url=self.create_credential.metadata['url'],
        )
        request = _convert_request(request)
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, 'str', skip_quote=True),
        }
        request.url = self._client.format_url(request.url, **path_format_arguments)

        pipeline_response = self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [201]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize.failsafe_deserialize(_models.ErrorCode, pipeline_response)
            raise HttpResponseError(response=response, model=error)

        response_headers = {}
        response_headers['Location']=self._deserialize('str', response.headers.get('Location'))


        if cls:
            return cls(pipeline_response, None, response_headers)

    create_credential.metadata = {'url': '/credentials'}  # type: ignore


    @distributed_trace
    def list_credentials(
        self,
        skip=None,  # type: Optional[int]
        maxpagesize=None,  # type: Optional[int]
        **kwargs  # type: Any
    ):
        # type: (...) -> Iterable["_models.DataSourceCredentialList"]
        """List all credentials.

        List all credentials.

        :param skip: for paging, skipped number.
        :type skip: int
        :param maxpagesize: the maximum number of items in one page.
        :type maxpagesize: int
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: An iterator like instance of either DataSourceCredentialList or the result of
         cls(response)
        :rtype: ~azure.core.paging.ItemPaged[~azure.ai.metricsadvisor.models.DataSourceCredentialList]
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType["_models.DataSourceCredentialList"]
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}))
        def prepare_request(next_link=None):
            if not next_link:
                
                request = build_list_credentials_request(
                    skip=skip,
                    maxpagesize=maxpagesize,
                    template_url=self.list_credentials.metadata['url'],
                )
                request = _convert_request(request)
                path_format_arguments = {
                    "endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, 'str', skip_quote=True),
                }
                request.url = self._client.format_url(request.url, **path_format_arguments)

            else:
                
                request = build_list_credentials_request(
                    skip=skip,
                    maxpagesize=maxpagesize,
                    template_url=next_link,
                )
                request = _convert_request(request)
                path_format_arguments = {
                    "endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, 'str', skip_quote=True),
                }
                request.url = self._client.format_url(request.url, **path_format_arguments)

                path_format_arguments = {
                    "endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, 'str', skip_quote=True),
                }
                request.method = "GET"
            return request

        def extract_data(pipeline_response):
            deserialized = self._deserialize("DataSourceCredentialList", pipeline_response)
            list_of_elem = deserialized.value
            if cls:
                list_of_elem = cls(list_of_elem)
            return deserialized.next_link or None, iter(list_of_elem)

        def get_next(next_link=None):
            request = prepare_request(next_link)

            pipeline_response = self._client._pipeline.run(request, stream=False, **kwargs)
            response = pipeline_response.http_response

            if response.status_code not in [200]:
                map_error(status_code=response.status_code, response=response, error_map=error_map)
                error = self._deserialize.failsafe_deserialize(_models.ErrorCode, pipeline_response)
                raise HttpResponseError(response=response, model=error)

            return pipeline_response


        return ItemPaged(
            get_next, extract_data
        )
    list_credentials.metadata = {'url': '/credentials'}  # type: ignore

    @distributed_trace
    def update_credential(
        self,
        credential_id,  # type: str
        body,  # type: "_models.DataSourceCredentialPatch"
        **kwargs  # type: Any
    ):
        # type: (...) -> "_models.DataSourceCredential"
        """Update a data source credential.

        Update a data source credential.

        :param credential_id: Data source credential unique ID.
        :type credential_id: str
        :param body: Update data source credential request.
        :type body: ~azure.ai.metricsadvisor.models.DataSourceCredentialPatch
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: DataSourceCredential, or the result of cls(response)
        :rtype: ~azure.ai.metricsadvisor.models.DataSourceCredential
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType["_models.DataSourceCredential"]
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}))

        content_type = kwargs.pop('content_type', "application/merge-patch+json")  # type: Optional[str]

        content = self._serialize.body(body, 'DataSourceCredentialPatch')

        request = build_update_credential_request(
            credential_id=credential_id,
            content_type=content_type,
            content=content,
            template_url=self.update_credential.metadata['url'],
        )
        request = _convert_request(request)
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, 'str', skip_quote=True),
        }
        request.url = self._client.format_url(request.url, **path_format_arguments)

        pipeline_response = self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize.failsafe_deserialize(_models.ErrorCode, pipeline_response)
            raise HttpResponseError(response=response, model=error)

        deserialized = self._deserialize('DataSourceCredential', pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized

    update_credential.metadata = {'url': '/credentials/{credentialId}'}  # type: ignore


    @distributed_trace
    def delete_credential(
        self,
        credential_id,  # type: str
        **kwargs  # type: Any
    ):
        # type: (...) -> None
        """Delete a data source credential.

        Delete a data source credential.

        :param credential_id: Data source credential unique ID.
        :type credential_id: str
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: None, or the result of cls(response)
        :rtype: None
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType[None]
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}))

        
        request = build_delete_credential_request(
            credential_id=credential_id,
            template_url=self.delete_credential.metadata['url'],
        )
        request = _convert_request(request)
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, 'str', skip_quote=True),
        }
        request.url = self._client.format_url(request.url, **path_format_arguments)

        pipeline_response = self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [204]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize.failsafe_deserialize(_models.ErrorCode, pipeline_response)
            raise HttpResponseError(response=response, model=error)

        if cls:
            return cls(pipeline_response, None, {})

    delete_credential.metadata = {'url': '/credentials/{credentialId}'}  # type: ignore


    @distributed_trace
    def get_credential(
        self,
        credential_id,  # type: str
        **kwargs  # type: Any
    ):
        # type: (...) -> "_models.DataSourceCredential"
        """Get a data source credential.

        Get a data source credential.

        :param credential_id: Data source credential unique ID.
        :type credential_id: str
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: DataSourceCredential, or the result of cls(response)
        :rtype: ~azure.ai.metricsadvisor.models.DataSourceCredential
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType["_models.DataSourceCredential"]
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}))

        
        request = build_get_credential_request(
            credential_id=credential_id,
            template_url=self.get_credential.metadata['url'],
        )
        request = _convert_request(request)
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, 'str', skip_quote=True),
        }
        request.url = self._client.format_url(request.url, **path_format_arguments)

        pipeline_response = self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize.failsafe_deserialize(_models.ErrorCode, pipeline_response)
            raise HttpResponseError(response=response, model=error)

        deserialized = self._deserialize('DataSourceCredential', pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized

    get_credential.metadata = {'url': '/credentials/{credentialId}'}  # type: ignore


    @distributed_trace
    def list_data_feeds(
        self,
        data_feed_name=None,  # type: Optional[str]
        data_source_type=None,  # type: Optional[Union[str, "_models.DataSourceType"]]
        granularity_name=None,  # type: Optional[Union[str, "_models.Granularity"]]
        status=None,  # type: Optional[Union[str, "_models.EntityStatus"]]
        creator=None,  # type: Optional[str]
        skip=None,  # type: Optional[int]
        maxpagesize=None,  # type: Optional[int]
        **kwargs  # type: Any
    ):
        # type: (...) -> Iterable["_models.DataFeedList"]
        """List all data feeds.

        List all data feeds.

        :param data_feed_name: filter data feed by its name.
        :type data_feed_name: str
        :param data_source_type: filter data feed by its source type.
        :type data_source_type: str or ~azure.ai.metricsadvisor.models.DataSourceType
        :param granularity_name: filter data feed by its granularity.
        :type granularity_name: str or ~azure.ai.metricsadvisor.models.Granularity
        :param status: filter data feed by its status.
        :type status: str or ~azure.ai.metricsadvisor.models.EntityStatus
        :param creator: filter data feed by its creator.
        :type creator: str
        :param skip: for paging, skipped number.
        :type skip: int
        :param maxpagesize: the maximum number of items in one page.
        :type maxpagesize: int
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: An iterator like instance of either DataFeedList or the result of cls(response)
        :rtype: ~azure.core.paging.ItemPaged[~azure.ai.metricsadvisor.models.DataFeedList]
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType["_models.DataFeedList"]
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}))
        def prepare_request(next_link=None):
            if not next_link:
                
                request = build_list_data_feeds_request(
                    data_feed_name=data_feed_name,
                    data_source_type=data_source_type,
                    granularity_name=granularity_name,
                    status=status,
                    creator=creator,
                    skip=skip,
                    maxpagesize=maxpagesize,
                    template_url=self.list_data_feeds.metadata['url'],
                )
                request = _convert_request(request)
                path_format_arguments = {
                    "endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, 'str', skip_quote=True),
                }
                request.url = self._client.format_url(request.url, **path_format_arguments)

            else:
                
                request = build_list_data_feeds_request(
                    data_feed_name=data_feed_name,
                    data_source_type=data_source_type,
                    granularity_name=granularity_name,
                    status=status,
                    creator=creator,
                    skip=skip,
                    maxpagesize=maxpagesize,
                    template_url=next_link,
                )
                request = _convert_request(request)
                path_format_arguments = {
                    "endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, 'str', skip_quote=True),
                }
                request.url = self._client.format_url(request.url, **path_format_arguments)

                path_format_arguments = {
                    "endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, 'str', skip_quote=True),
                }
                request.method = "GET"
            return request

        def extract_data(pipeline_response):
            deserialized = self._deserialize("DataFeedList", pipeline_response)
            list_of_elem = deserialized.value
            if cls:
                list_of_elem = cls(list_of_elem)
            return deserialized.next_link or None, iter(list_of_elem)

        def get_next(next_link=None):
            request = prepare_request(next_link)

            pipeline_response = self._client._pipeline.run(request, stream=False, **kwargs)
            response = pipeline_response.http_response

            if response.status_code not in [200]:
                map_error(status_code=response.status_code, response=response, error_map=error_map)
                error = self._deserialize.failsafe_deserialize(_models.ErrorCode, pipeline_response)
                raise HttpResponseError(response=response, model=error)

            return pipeline_response


        return ItemPaged(
            get_next, extract_data
        )
    list_data_feeds.metadata = {'url': '/dataFeeds'}  # type: ignore

    @distributed_trace
    def create_data_feed(
        self,
        body,  # type: "_models.DataFeedDetail"
        **kwargs  # type: Any
    ):
        # type: (...) -> None
        """Create a new data feed.

        Create a new data feed.

        :param body: parameters to create a data feed.
        :type body: ~azure.ai.metricsadvisor.models.DataFeedDetail
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: None, or the result of cls(response)
        :rtype: None
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType[None]
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}))

        content_type = kwargs.pop('content_type', "application/json")  # type: Optional[str]

        json = self._serialize.body(body, 'DataFeedDetail')

        request = build_create_data_feed_request(
            content_type=content_type,
            json=json,
            template_url=self.create_data_feed.metadata['url'],
        )
        request = _convert_request(request)
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, 'str', skip_quote=True),
        }
        request.url = self._client.format_url(request.url, **path_format_arguments)

        pipeline_response = self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [201]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize.failsafe_deserialize(_models.ErrorCode, pipeline_response)
            raise HttpResponseError(response=response, model=error)

        response_headers = {}
        response_headers['Location']=self._deserialize('str', response.headers.get('Location'))


        if cls:
            return cls(pipeline_response, None, response_headers)

    create_data_feed.metadata = {'url': '/dataFeeds'}  # type: ignore


    @distributed_trace
    def get_data_feed_by_id(
        self,
        data_feed_id,  # type: str
        **kwargs  # type: Any
    ):
        # type: (...) -> "_models.DataFeedDetail"
        """Get a data feed by its id.

        Get a data feed by its id.

        :param data_feed_id: The data feed unique id.
        :type data_feed_id: str
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: DataFeedDetail, or the result of cls(response)
        :rtype: ~azure.ai.metricsadvisor.models.DataFeedDetail
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType["_models.DataFeedDetail"]
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}))

        
        request = build_get_data_feed_by_id_request(
            data_feed_id=data_feed_id,
            template_url=self.get_data_feed_by_id.metadata['url'],
        )
        request = _convert_request(request)
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, 'str', skip_quote=True),
        }
        request.url = self._client.format_url(request.url, **path_format_arguments)

        pipeline_response = self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize.failsafe_deserialize(_models.ErrorCode, pipeline_response)
            raise HttpResponseError(response=response, model=error)

        deserialized = self._deserialize('DataFeedDetail', pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized

    get_data_feed_by_id.metadata = {'url': '/dataFeeds/{dataFeedId}'}  # type: ignore


    @distributed_trace
    def update_data_feed(
        self,
        data_feed_id,  # type: str
        body,  # type: "_models.DataFeedDetailPatch"
        **kwargs  # type: Any
    ):
        # type: (...) -> "_models.DataFeedDetail"
        """Update a data feed.

        Update a data feed.

        :param data_feed_id: The data feed unique id.
        :type data_feed_id: str
        :param body: parameters to update a data feed.
        :type body: ~azure.ai.metricsadvisor.models.DataFeedDetailPatch
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: DataFeedDetail, or the result of cls(response)
        :rtype: ~azure.ai.metricsadvisor.models.DataFeedDetail
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType["_models.DataFeedDetail"]
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}))

        content_type = kwargs.pop('content_type', "application/merge-patch+json")  # type: Optional[str]

        content = self._serialize.body(body, 'DataFeedDetailPatch')

        request = build_update_data_feed_request(
            data_feed_id=data_feed_id,
            content_type=content_type,
            content=content,
            template_url=self.update_data_feed.metadata['url'],
        )
        request = _convert_request(request)
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, 'str', skip_quote=True),
        }
        request.url = self._client.format_url(request.url, **path_format_arguments)

        pipeline_response = self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize.failsafe_deserialize(_models.ErrorCode, pipeline_response)
            raise HttpResponseError(response=response, model=error)

        deserialized = self._deserialize('DataFeedDetail', pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized

    update_data_feed.metadata = {'url': '/dataFeeds/{dataFeedId}'}  # type: ignore


    @distributed_trace
    def delete_data_feed(
        self,
        data_feed_id,  # type: str
        **kwargs  # type: Any
    ):
        # type: (...) -> None
        """Delete a data feed.

        Delete a data feed.

        :param data_feed_id: The data feed unique id.
        :type data_feed_id: str
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: None, or the result of cls(response)
        :rtype: None
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType[None]
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}))

        
        request = build_delete_data_feed_request(
            data_feed_id=data_feed_id,
            template_url=self.delete_data_feed.metadata['url'],
        )
        request = _convert_request(request)
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, 'str', skip_quote=True),
        }
        request.url = self._client.format_url(request.url, **path_format_arguments)

        pipeline_response = self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [204]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize.failsafe_deserialize(_models.ErrorCode, pipeline_response)
            raise HttpResponseError(response=response, model=error)

        if cls:
            return cls(pipeline_response, None, {})

    delete_data_feed.metadata = {'url': '/dataFeeds/{dataFeedId}'}  # type: ignore


    @distributed_trace
    def get_metric_feedback(
        self,
        feedback_id,  # type: str
        **kwargs  # type: Any
    ):
        # type: (...) -> "_models.MetricFeedback"
        """Get a metric feedback by its id.

        Get a metric feedback by its id.

        :param feedback_id: the unique feedback ID.
        :type feedback_id: str
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: MetricFeedback, or the result of cls(response)
        :rtype: ~azure.ai.metricsadvisor.models.MetricFeedback
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType["_models.MetricFeedback"]
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}))

        
        request = build_get_metric_feedback_request(
            feedback_id=feedback_id,
            template_url=self.get_metric_feedback.metadata['url'],
        )
        request = _convert_request(request)
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, 'str', skip_quote=True),
        }
        request.url = self._client.format_url(request.url, **path_format_arguments)

        pipeline_response = self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize.failsafe_deserialize(_models.ErrorCode, pipeline_response)
            raise HttpResponseError(response=response, model=error)

        deserialized = self._deserialize('MetricFeedback', pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized

    get_metric_feedback.metadata = {'url': '/feedback/metric/{feedbackId}'}  # type: ignore


    @distributed_trace
    def list_metric_feedbacks(
        self,
        body,  # type: "_models.MetricFeedbackFilter"
        skip=None,  # type: Optional[int]
        maxpagesize=None,  # type: Optional[int]
        **kwargs  # type: Any
    ):
        # type: (...) -> Iterable["_models.MetricFeedbackList"]
        """List feedback on the given metric.

        List feedback on the given metric.

        :param body: metric feedback filter.
        :type body: ~azure.ai.metricsadvisor.models.MetricFeedbackFilter
        :param skip: for paging, skipped number.
        :type skip: int
        :param maxpagesize: the maximum number of items in one page.
        :type maxpagesize: int
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: An iterator like instance of either MetricFeedbackList or the result of cls(response)
        :rtype: ~azure.core.paging.ItemPaged[~azure.ai.metricsadvisor.models.MetricFeedbackList]
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        content_type = kwargs.pop('content_type', "application/json")  # type: Optional[str]

        cls = kwargs.pop('cls', None)  # type: ClsType["_models.MetricFeedbackList"]
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}))
        def prepare_request(next_link=None):
            if not next_link:
                json = self._serialize.body(body, 'MetricFeedbackFilter')
                
                request = build_list_metric_feedbacks_request(
                    content_type=content_type,
                    json=json,
                    skip=skip,
                    maxpagesize=maxpagesize,
                    template_url=self.list_metric_feedbacks.metadata['url'],
                )
                request = _convert_request(request)
                path_format_arguments = {
                    "endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, 'str', skip_quote=True),
                }
                request.url = self._client.format_url(request.url, **path_format_arguments)

            else:
                json = self._serialize.body(body, 'MetricFeedbackFilter')
                
                request = build_list_metric_feedbacks_request(
                    content_type=content_type,
                    json=json,
                    skip=skip,
                    maxpagesize=maxpagesize,
                    template_url=next_link,
                )
                request = _convert_request(request)
                path_format_arguments = {
                    "endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, 'str', skip_quote=True),
                }
                request.url = self._client.format_url(request.url, **path_format_arguments)

                path_format_arguments = {
                    "endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, 'str', skip_quote=True),
                }
                request.method = "GET"
            return request

        def extract_data(pipeline_response):
            deserialized = self._deserialize("MetricFeedbackList", pipeline_response)
            list_of_elem = deserialized.value
            if cls:
                list_of_elem = cls(list_of_elem)
            return deserialized.next_link or None, iter(list_of_elem)

        def get_next(next_link=None):
            request = prepare_request(next_link)

            pipeline_response = self._client._pipeline.run(request, stream=False, **kwargs)
            response = pipeline_response.http_response

            if response.status_code not in [200]:
                map_error(status_code=response.status_code, response=response, error_map=error_map)
                error = self._deserialize.failsafe_deserialize(_models.ErrorCode, pipeline_response)
                raise HttpResponseError(response=response, model=error)

            return pipeline_response


        return ItemPaged(
            get_next, extract_data
        )
    list_metric_feedbacks.metadata = {'url': '/feedback/metric/query'}  # type: ignore

    @distributed_trace
    def create_metric_feedback(
        self,
        body,  # type: "_models.MetricFeedback"
        **kwargs  # type: Any
    ):
        # type: (...) -> None
        """Create a new metric feedback.

        Create a new metric feedback.

        :param body: metric feedback.
        :type body: ~azure.ai.metricsadvisor.models.MetricFeedback
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: None, or the result of cls(response)
        :rtype: None
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType[None]
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}))

        content_type = kwargs.pop('content_type', "application/json")  # type: Optional[str]

        json = self._serialize.body(body, 'MetricFeedback')

        request = build_create_metric_feedback_request(
            content_type=content_type,
            json=json,
            template_url=self.create_metric_feedback.metadata['url'],
        )
        request = _convert_request(request)
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, 'str', skip_quote=True),
        }
        request.url = self._client.format_url(request.url, **path_format_arguments)

        pipeline_response = self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [201]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize.failsafe_deserialize(_models.ErrorCode, pipeline_response)
            raise HttpResponseError(response=response, model=error)

        response_headers = {}
        response_headers['Location']=self._deserialize('str', response.headers.get('Location'))


        if cls:
            return cls(pipeline_response, None, response_headers)

    create_metric_feedback.metadata = {'url': '/feedback/metric'}  # type: ignore


    @distributed_trace
    def list_hooks(
        self,
        hook_name=None,  # type: Optional[str]
        skip=None,  # type: Optional[int]
        maxpagesize=None,  # type: Optional[int]
        **kwargs  # type: Any
    ):
        # type: (...) -> Iterable["_models.HookList"]
        """List all hooks.

        List all hooks.

        :param hook_name: filter hook by its name.
        :type hook_name: str
        :param skip: for paging, skipped number.
        :type skip: int
        :param maxpagesize: the maximum number of items in one page.
        :type maxpagesize: int
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: An iterator like instance of either HookList or the result of cls(response)
        :rtype: ~azure.core.paging.ItemPaged[~azure.ai.metricsadvisor.models.HookList]
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType["_models.HookList"]
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}))
        def prepare_request(next_link=None):
            if not next_link:
                
                request = build_list_hooks_request(
                    hook_name=hook_name,
                    skip=skip,
                    maxpagesize=maxpagesize,
                    template_url=self.list_hooks.metadata['url'],
                )
                request = _convert_request(request)
                path_format_arguments = {
                    "endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, 'str', skip_quote=True),
                }
                request.url = self._client.format_url(request.url, **path_format_arguments)

            else:
                
                request = build_list_hooks_request(
                    hook_name=hook_name,
                    skip=skip,
                    maxpagesize=maxpagesize,
                    template_url=next_link,
                )
                request = _convert_request(request)
                path_format_arguments = {
                    "endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, 'str', skip_quote=True),
                }
                request.url = self._client.format_url(request.url, **path_format_arguments)

                path_format_arguments = {
                    "endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, 'str', skip_quote=True),
                }
                request.method = "GET"
            return request

        def extract_data(pipeline_response):
            deserialized = self._deserialize("HookList", pipeline_response)
            list_of_elem = deserialized.value
            if cls:
                list_of_elem = cls(list_of_elem)
            return deserialized.next_link or None, iter(list_of_elem)

        def get_next(next_link=None):
            request = prepare_request(next_link)

            pipeline_response = self._client._pipeline.run(request, stream=False, **kwargs)
            response = pipeline_response.http_response

            if response.status_code not in [200]:
                map_error(status_code=response.status_code, response=response, error_map=error_map)
                error = self._deserialize.failsafe_deserialize(_models.ErrorCode, pipeline_response)
                raise HttpResponseError(response=response, model=error)

            return pipeline_response


        return ItemPaged(
            get_next, extract_data
        )
    list_hooks.metadata = {'url': '/hooks'}  # type: ignore

    @distributed_trace
    def create_hook(
        self,
        body,  # type: "_models.HookInfo"
        **kwargs  # type: Any
    ):
        # type: (...) -> None
        """Create a new hook.

        Create a new hook.

        :param body: Create hook request.
        :type body: ~azure.ai.metricsadvisor.models.HookInfo
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: None, or the result of cls(response)
        :rtype: None
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType[None]
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}))

        content_type = kwargs.pop('content_type', "application/json")  # type: Optional[str]

        json = self._serialize.body(body, 'HookInfo')

        request = build_create_hook_request(
            content_type=content_type,
            json=json,
            template_url=self.create_hook.metadata['url'],
        )
        request = _convert_request(request)
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, 'str', skip_quote=True),
        }
        request.url = self._client.format_url(request.url, **path_format_arguments)

        pipeline_response = self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [201]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize.failsafe_deserialize(_models.ErrorCode, pipeline_response)
            raise HttpResponseError(response=response, model=error)

        response_headers = {}
        response_headers['Location']=self._deserialize('str', response.headers.get('Location'))


        if cls:
            return cls(pipeline_response, None, response_headers)

    create_hook.metadata = {'url': '/hooks'}  # type: ignore


    @distributed_trace
    def get_hook(
        self,
        hook_id,  # type: str
        **kwargs  # type: Any
    ):
        # type: (...) -> "_models.HookInfo"
        """Get a hook by its id.

        Get a hook by its id.

        :param hook_id: Hook unique ID.
        :type hook_id: str
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: HookInfo, or the result of cls(response)
        :rtype: ~azure.ai.metricsadvisor.models.HookInfo
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType["_models.HookInfo"]
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}))

        
        request = build_get_hook_request(
            hook_id=hook_id,
            template_url=self.get_hook.metadata['url'],
        )
        request = _convert_request(request)
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, 'str', skip_quote=True),
        }
        request.url = self._client.format_url(request.url, **path_format_arguments)

        pipeline_response = self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize.failsafe_deserialize(_models.ErrorCode, pipeline_response)
            raise HttpResponseError(response=response, model=error)

        deserialized = self._deserialize('HookInfo', pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized

    get_hook.metadata = {'url': '/hooks/{hookId}'}  # type: ignore


    @distributed_trace
    def update_hook(
        self,
        hook_id,  # type: str
        body,  # type: "_models.HookInfoPatch"
        **kwargs  # type: Any
    ):
        # type: (...) -> "_models.HookInfo"
        """Update a hook.

        Update a hook.

        :param hook_id: Hook unique ID.
        :type hook_id: str
        :param body: Update hook request.
        :type body: ~azure.ai.metricsadvisor.models.HookInfoPatch
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: HookInfo, or the result of cls(response)
        :rtype: ~azure.ai.metricsadvisor.models.HookInfo
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType["_models.HookInfo"]
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}))

        content_type = kwargs.pop('content_type', "application/merge-patch+json")  # type: Optional[str]

        content = self._serialize.body(body, 'HookInfoPatch')

        request = build_update_hook_request(
            hook_id=hook_id,
            content_type=content_type,
            content=content,
            template_url=self.update_hook.metadata['url'],
        )
        request = _convert_request(request)
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, 'str', skip_quote=True),
        }
        request.url = self._client.format_url(request.url, **path_format_arguments)

        pipeline_response = self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize.failsafe_deserialize(_models.ErrorCode, pipeline_response)
            raise HttpResponseError(response=response, model=error)

        deserialized = self._deserialize('HookInfo', pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized

    update_hook.metadata = {'url': '/hooks/{hookId}'}  # type: ignore


    @distributed_trace
    def delete_hook(
        self,
        hook_id,  # type: str
        **kwargs  # type: Any
    ):
        # type: (...) -> None
        """Delete a hook.

        Delete a hook.

        :param hook_id: Hook unique ID.
        :type hook_id: str
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: None, or the result of cls(response)
        :rtype: None
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType[None]
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}))

        
        request = build_delete_hook_request(
            hook_id=hook_id,
            template_url=self.delete_hook.metadata['url'],
        )
        request = _convert_request(request)
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, 'str', skip_quote=True),
        }
        request.url = self._client.format_url(request.url, **path_format_arguments)

        pipeline_response = self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [204]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize.failsafe_deserialize(_models.ErrorCode, pipeline_response)
            raise HttpResponseError(response=response, model=error)

        if cls:
            return cls(pipeline_response, None, {})

    delete_hook.metadata = {'url': '/hooks/{hookId}'}  # type: ignore


    @distributed_trace
    def get_data_feed_ingestion_status(
        self,
        data_feed_id,  # type: str
        body,  # type: "_models.IngestionStatusQueryOptions"
        skip=None,  # type: Optional[int]
        maxpagesize=None,  # type: Optional[int]
        **kwargs  # type: Any
    ):
        # type: (...) -> Iterable["_models.IngestionStatusList"]
        """Get data ingestion status by data feed.

        Get data ingestion status by data feed.

        :param data_feed_id: The data feed unique id.
        :type data_feed_id: str
        :param body: The query time range.
        :type body: ~azure.ai.metricsadvisor.models.IngestionStatusQueryOptions
        :param skip: for paging, skipped number.
        :type skip: int
        :param maxpagesize: the maximum number of items in one page.
        :type maxpagesize: int
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: An iterator like instance of either IngestionStatusList or the result of cls(response)
        :rtype: ~azure.core.paging.ItemPaged[~azure.ai.metricsadvisor.models.IngestionStatusList]
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        content_type = kwargs.pop('content_type', "application/json")  # type: Optional[str]

        cls = kwargs.pop('cls', None)  # type: ClsType["_models.IngestionStatusList"]
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}))
        def prepare_request(next_link=None):
            if not next_link:
                json = self._serialize.body(body, 'IngestionStatusQueryOptions')
                
                request = build_get_data_feed_ingestion_status_request(
                    data_feed_id=data_feed_id,
                    content_type=content_type,
                    json=json,
                    skip=skip,
                    maxpagesize=maxpagesize,
                    template_url=self.get_data_feed_ingestion_status.metadata['url'],
                )
                request = _convert_request(request)
                path_format_arguments = {
                    "endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, 'str', skip_quote=True),
                }
                request.url = self._client.format_url(request.url, **path_format_arguments)

            else:
                json = self._serialize.body(body, 'IngestionStatusQueryOptions')
                
                request = build_get_data_feed_ingestion_status_request(
                    data_feed_id=data_feed_id,
                    content_type=content_type,
                    json=json,
                    skip=skip,
                    maxpagesize=maxpagesize,
                    template_url=next_link,
                )
                request = _convert_request(request)
                path_format_arguments = {
                    "endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, 'str', skip_quote=True),
                }
                request.url = self._client.format_url(request.url, **path_format_arguments)

                path_format_arguments = {
                    "endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, 'str', skip_quote=True),
                }
                request.method = "GET"
            return request

        def extract_data(pipeline_response):
            deserialized = self._deserialize("IngestionStatusList", pipeline_response)
            list_of_elem = deserialized.value
            if cls:
                list_of_elem = cls(list_of_elem)
            return deserialized.next_link or None, iter(list_of_elem)

        def get_next(next_link=None):
            request = prepare_request(next_link)

            pipeline_response = self._client._pipeline.run(request, stream=False, **kwargs)
            response = pipeline_response.http_response

            if response.status_code not in [200]:
                map_error(status_code=response.status_code, response=response, error_map=error_map)
                error = self._deserialize.failsafe_deserialize(_models.ErrorCode, pipeline_response)
                raise HttpResponseError(response=response, model=error)

            return pipeline_response


        return ItemPaged(
            get_next, extract_data
        )
    get_data_feed_ingestion_status.metadata = {'url': '/dataFeeds/{dataFeedId}/ingestionStatus/query'}  # type: ignore

    @distributed_trace
    def reset_data_feed_ingestion_status(
        self,
        data_feed_id,  # type: str
        body,  # type: "_models.IngestionProgressResetOptions"
        **kwargs  # type: Any
    ):
        # type: (...) -> None
        """Reset data ingestion status by data feed to backfill data.

        Reset data ingestion status by data feed to backfill data.

        :param data_feed_id: The data feed unique id.
        :type data_feed_id: str
        :param body: The backfill time range.
        :type body: ~azure.ai.metricsadvisor.models.IngestionProgressResetOptions
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: None, or the result of cls(response)
        :rtype: None
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType[None]
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}))

        content_type = kwargs.pop('content_type', "application/json")  # type: Optional[str]

        json = self._serialize.body(body, 'IngestionProgressResetOptions')

        request = build_reset_data_feed_ingestion_status_request(
            data_feed_id=data_feed_id,
            content_type=content_type,
            json=json,
            template_url=self.reset_data_feed_ingestion_status.metadata['url'],
        )
        request = _convert_request(request)
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, 'str', skip_quote=True),
        }
        request.url = self._client.format_url(request.url, **path_format_arguments)

        pipeline_response = self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [204]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize.failsafe_deserialize(_models.ErrorCode, pipeline_response)
            raise HttpResponseError(response=response, model=error)

        if cls:
            return cls(pipeline_response, None, {})

    reset_data_feed_ingestion_status.metadata = {'url': '/dataFeeds/{dataFeedId}/ingestionProgress/reset'}  # type: ignore


    @distributed_trace
    def get_ingestion_progress(
        self,
        data_feed_id,  # type: str
        **kwargs  # type: Any
    ):
        # type: (...) -> "_models.DataFeedIngestionProgress"
        """Get data last success ingestion job timestamp by data feed.

        Get data last success ingestion job timestamp by data feed.

        :param data_feed_id: The data feed unique id.
        :type data_feed_id: str
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: DataFeedIngestionProgress, or the result of cls(response)
        :rtype: ~azure.ai.metricsadvisor.models.DataFeedIngestionProgress
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType["_models.DataFeedIngestionProgress"]
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}))

        
        request = build_get_ingestion_progress_request(
            data_feed_id=data_feed_id,
            template_url=self.get_ingestion_progress.metadata['url'],
        )
        request = _convert_request(request)
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, 'str', skip_quote=True),
        }
        request.url = self._client.format_url(request.url, **path_format_arguments)

        pipeline_response = self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize.failsafe_deserialize(_models.ErrorCode, pipeline_response)
            raise HttpResponseError(response=response, model=error)

        deserialized = self._deserialize('DataFeedIngestionProgress', pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized

    get_ingestion_progress.metadata = {'url': '/dataFeeds/{dataFeedId}/ingestionProgress'}  # type: ignore


    @distributed_trace
    def get_metric_data(
        self,
        metric_id,  # type: str
        body,  # type: "_models.MetricDataQueryOptions"
        **kwargs  # type: Any
    ):
        # type: (...) -> "_models.MetricDataList"
        """Get time series data from metric.

        Get time series data from metric.

        :param metric_id: metric unique id.
        :type metric_id: str
        :param body: query time series data condition.
        :type body: ~azure.ai.metricsadvisor.models.MetricDataQueryOptions
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: MetricDataList, or the result of cls(response)
        :rtype: ~azure.ai.metricsadvisor.models.MetricDataList
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType["_models.MetricDataList"]
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}))

        content_type = kwargs.pop('content_type', "application/json")  # type: Optional[str]

        json = self._serialize.body(body, 'MetricDataQueryOptions')

        request = build_get_metric_data_request(
            metric_id=metric_id,
            content_type=content_type,
            json=json,
            template_url=self.get_metric_data.metadata['url'],
        )
        request = _convert_request(request)
        path_format_arguments = {
            "endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, 'str', skip_quote=True),
        }
        request.url = self._client.format_url(request.url, **path_format_arguments)

        pipeline_response = self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            error = self._deserialize.failsafe_deserialize(_models.ErrorCode, pipeline_response)
            raise HttpResponseError(response=response, model=error)

        deserialized = self._deserialize('MetricDataList', pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized

    get_metric_data.metadata = {'url': '/metrics/{metricId}/data/query'}  # type: ignore


    @distributed_trace
    def get_metric_series(
        self,
        metric_id,  # type: str
        body,  # type: "_models.MetricSeriesQueryOptions"
        skip=None,  # type: Optional[int]
        maxpagesize=None,  # type: Optional[int]
        **kwargs  # type: Any
    ):
        # type: (...) -> Iterable["_models.MetricSeriesList"]
        """List series (dimension combinations) from metric.

        List series (dimension combinations) from metric.

        :param metric_id: metric unique id.
        :type metric_id: str
        :param body: filter to query series.
        :type body: ~azure.ai.metricsadvisor.models.MetricSeriesQueryOptions
        :param skip: for paging, skipped number.
        :type skip: int
        :param maxpagesize: the maximum number of items in one page.
        :type maxpagesize: int
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: An iterator like instance of either MetricSeriesList or the result of cls(response)
        :rtype: ~azure.core.paging.ItemPaged[~azure.ai.metricsadvisor.models.MetricSeriesList]
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        content_type = kwargs.pop('content_type', "application/json")  # type: Optional[str]

        cls = kwargs.pop('cls', None)  # type: ClsType["_models.MetricSeriesList"]
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}))
        def prepare_request(next_link=None):
            if not next_link:
                json = self._serialize.body(body, 'MetricSeriesQueryOptions')
                
                request = build_get_metric_series_request(
                    metric_id=metric_id,
                    content_type=content_type,
                    json=json,
                    skip=skip,
                    maxpagesize=maxpagesize,
                    template_url=self.get_metric_series.metadata['url'],
                )
                request = _convert_request(request)
                path_format_arguments = {
                    "endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, 'str', skip_quote=True),
                }
                request.url = self._client.format_url(request.url, **path_format_arguments)

            else:
                json = self._serialize.body(body, 'MetricSeriesQueryOptions')
                
                request = build_get_metric_series_request(
                    metric_id=metric_id,
                    content_type=content_type,
                    json=json,
                    skip=skip,
                    maxpagesize=maxpagesize,
                    template_url=next_link,
                )
                request = _convert_request(request)
                path_format_arguments = {
                    "endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, 'str', skip_quote=True),
                }
                request.url = self._client.format_url(request.url, **path_format_arguments)

                path_format_arguments = {
                    "endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, 'str', skip_quote=True),
                }
                request.method = "GET"
            return request

        def extract_data(pipeline_response):
            deserialized = self._deserialize("MetricSeriesList", pipeline_response)
            list_of_elem = deserialized.value
            if cls:
                list_of_elem = cls(list_of_elem)
            return deserialized.next_link or None, iter(list_of_elem)

        def get_next(next_link=None):
            request = prepare_request(next_link)

            pipeline_response = self._client._pipeline.run(request, stream=False, **kwargs)
            response = pipeline_response.http_response

            if response.status_code not in [200]:
                map_error(status_code=response.status_code, response=response, error_map=error_map)
                error = self._deserialize.failsafe_deserialize(_models.ErrorCode, pipeline_response)
                raise HttpResponseError(response=response, model=error)

            return pipeline_response


        return ItemPaged(
            get_next, extract_data
        )
    get_metric_series.metadata = {'url': '/metrics/{metricId}/series/query'}  # type: ignore

    @distributed_trace
    def get_metric_dimension(
        self,
        metric_id,  # type: str
        body,  # type: "_models.MetricDimensionQueryOptions"
        skip=None,  # type: Optional[int]
        maxpagesize=None,  # type: Optional[int]
        **kwargs  # type: Any
    ):
        # type: (...) -> Iterable["_models.MetricDimensionList"]
        """List dimension from certain metric.

        List dimension from certain metric.

        :param metric_id: metric unique id.
        :type metric_id: str
        :param body: query dimension option.
        :type body: ~azure.ai.metricsadvisor.models.MetricDimensionQueryOptions
        :param skip: for paging, skipped number.
        :type skip: int
        :param maxpagesize: the maximum number of items in one page.
        :type maxpagesize: int
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: An iterator like instance of either MetricDimensionList or the result of cls(response)
        :rtype: ~azure.core.paging.ItemPaged[~azure.ai.metricsadvisor.models.MetricDimensionList]
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        content_type = kwargs.pop('content_type', "application/json")  # type: Optional[str]

        cls = kwargs.pop('cls', None)  # type: ClsType["_models.MetricDimensionList"]
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}))
        def prepare_request(next_link=None):
            if not next_link:
                json = self._serialize.body(body, 'MetricDimensionQueryOptions')
                
                request = build_get_metric_dimension_request(
                    metric_id=metric_id,
                    content_type=content_type,
                    json=json,
                    skip=skip,
                    maxpagesize=maxpagesize,
                    template_url=self.get_metric_dimension.metadata['url'],
                )
                request = _convert_request(request)
                path_format_arguments = {
                    "endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, 'str', skip_quote=True),
                }
                request.url = self._client.format_url(request.url, **path_format_arguments)

            else:
                json = self._serialize.body(body, 'MetricDimensionQueryOptions')
                
                request = build_get_metric_dimension_request(
                    metric_id=metric_id,
                    content_type=content_type,
                    json=json,
                    skip=skip,
                    maxpagesize=maxpagesize,
                    template_url=next_link,
                )
                request = _convert_request(request)
                path_format_arguments = {
                    "endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, 'str', skip_quote=True),
                }
                request.url = self._client.format_url(request.url, **path_format_arguments)

                path_format_arguments = {
                    "endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, 'str', skip_quote=True),
                }
                request.method = "GET"
            return request

        def extract_data(pipeline_response):
            deserialized = self._deserialize("MetricDimensionList", pipeline_response)
            list_of_elem = deserialized.value
            if cls:
                list_of_elem = cls(list_of_elem)
            return deserialized.next_link or None, iter(list_of_elem)

        def get_next(next_link=None):
            request = prepare_request(next_link)

            pipeline_response = self._client._pipeline.run(request, stream=False, **kwargs)
            response = pipeline_response.http_response

            if response.status_code not in [200]:
                map_error(status_code=response.status_code, response=response, error_map=error_map)
                error = self._deserialize.failsafe_deserialize(_models.ErrorCode, pipeline_response)
                raise HttpResponseError(response=response, model=error)

            return pipeline_response


        return ItemPaged(
            get_next, extract_data
        )
    get_metric_dimension.metadata = {'url': '/metrics/{metricId}/dimension/query'}  # type: ignore

    @distributed_trace
    def get_anomaly_detection_configurations_by_metric(
        self,
        metric_id,  # type: str
        skip=None,  # type: Optional[int]
        maxpagesize=None,  # type: Optional[int]
        **kwargs  # type: Any
    ):
        # type: (...) -> Iterable["_models.AnomalyDetectionConfigurationList"]
        """List all anomaly detection configurations for specific metric.

        List all anomaly detection configurations for specific metric.

        :param metric_id: metric unique id.
        :type metric_id: str
        :param skip: for paging, skipped number.
        :type skip: int
        :param maxpagesize: the maximum number of items in one page.
        :type maxpagesize: int
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: An iterator like instance of either AnomalyDetectionConfigurationList or the result of
         cls(response)
        :rtype:
         ~azure.core.paging.ItemPaged[~azure.ai.metricsadvisor.models.AnomalyDetectionConfigurationList]
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType["_models.AnomalyDetectionConfigurationList"]
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}))
        def prepare_request(next_link=None):
            if not next_link:
                
                request = build_get_anomaly_detection_configurations_by_metric_request(
                    metric_id=metric_id,
                    skip=skip,
                    maxpagesize=maxpagesize,
                    template_url=self.get_anomaly_detection_configurations_by_metric.metadata['url'],
                )
                request = _convert_request(request)
                path_format_arguments = {
                    "endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, 'str', skip_quote=True),
                }
                request.url = self._client.format_url(request.url, **path_format_arguments)

            else:
                
                request = build_get_anomaly_detection_configurations_by_metric_request(
                    metric_id=metric_id,
                    skip=skip,
                    maxpagesize=maxpagesize,
                    template_url=next_link,
                )
                request = _convert_request(request)
                path_format_arguments = {
                    "endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, 'str', skip_quote=True),
                }
                request.url = self._client.format_url(request.url, **path_format_arguments)

                path_format_arguments = {
                    "endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, 'str', skip_quote=True),
                }
                request.method = "GET"
            return request

        def extract_data(pipeline_response):
            deserialized = self._deserialize("AnomalyDetectionConfigurationList", pipeline_response)
            list_of_elem = deserialized.value
            if cls:
                list_of_elem = cls(list_of_elem)
            return deserialized.next_link or None, iter(list_of_elem)

        def get_next(next_link=None):
            request = prepare_request(next_link)

            pipeline_response = self._client._pipeline.run(request, stream=False, **kwargs)
            response = pipeline_response.http_response

            if response.status_code not in [200]:
                map_error(status_code=response.status_code, response=response, error_map=error_map)
                error = self._deserialize.failsafe_deserialize(_models.ErrorCode, pipeline_response)
                raise HttpResponseError(response=response, model=error)

            return pipeline_response


        return ItemPaged(
            get_next, extract_data
        )
    get_anomaly_detection_configurations_by_metric.metadata = {'url': '/metrics/{metricId}/enrichment/anomalyDetection/configurations'}  # type: ignore

    @distributed_trace
    def get_enrichment_status_by_metric(
        self,
        metric_id,  # type: str
        body,  # type: "_models.EnrichmentStatusQueryOption"
        skip=None,  # type: Optional[int]
        maxpagesize=None,  # type: Optional[int]
        **kwargs  # type: Any
    ):
        # type: (...) -> Iterable["_models.EnrichmentStatusList"]
        """Query anomaly detection status.

        Query anomaly detection status.

        :param metric_id: metric unique id.
        :type metric_id: str
        :param body: query options.
        :type body: ~azure.ai.metricsadvisor.models.EnrichmentStatusQueryOption
        :param skip: for paging, skipped number.
        :type skip: int
        :param maxpagesize: the maximum number of items in one page.
        :type maxpagesize: int
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: An iterator like instance of either EnrichmentStatusList or the result of
         cls(response)
        :rtype: ~azure.core.paging.ItemPaged[~azure.ai.metricsadvisor.models.EnrichmentStatusList]
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        content_type = kwargs.pop('content_type', "application/json")  # type: Optional[str]

        cls = kwargs.pop('cls', None)  # type: ClsType["_models.EnrichmentStatusList"]
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}))
        def prepare_request(next_link=None):
            if not next_link:
                json = self._serialize.body(body, 'EnrichmentStatusQueryOption')
                
                request = build_get_enrichment_status_by_metric_request(
                    metric_id=metric_id,
                    content_type=content_type,
                    json=json,
                    skip=skip,
                    maxpagesize=maxpagesize,
                    template_url=self.get_enrichment_status_by_metric.metadata['url'],
                )
                request = _convert_request(request)
                path_format_arguments = {
                    "endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, 'str', skip_quote=True),
                }
                request.url = self._client.format_url(request.url, **path_format_arguments)

            else:
                json = self._serialize.body(body, 'EnrichmentStatusQueryOption')
                
                request = build_get_enrichment_status_by_metric_request(
                    metric_id=metric_id,
                    content_type=content_type,
                    json=json,
                    skip=skip,
                    maxpagesize=maxpagesize,
                    template_url=next_link,
                )
                request = _convert_request(request)
                path_format_arguments = {
                    "endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, 'str', skip_quote=True),
                }
                request.url = self._client.format_url(request.url, **path_format_arguments)

                path_format_arguments = {
                    "endpoint": self._serialize.url("self._config.endpoint", self._config.endpoint, 'str', skip_quote=True),
                }
                request.method = "GET"
            return request

        def extract_data(pipeline_response):
            deserialized = self._deserialize("EnrichmentStatusList", pipeline_response)
            list_of_elem = deserialized.value
            if cls:
                list_of_elem = cls(list_of_elem)
            return deserialized.next_link or None, iter(list_of_elem)

        def get_next(next_link=None):
            request = prepare_request(next_link)

            pipeline_response = self._client._pipeline.run(request, stream=False, **kwargs)
            response = pipeline_response.http_response

            if response.status_code not in [200]:
                map_error(status_code=response.status_code, response=response, error_map=error_map)
                error = self._deserialize.failsafe_deserialize(_models.ErrorCode, pipeline_response)
                raise HttpResponseError(response=response, model=error)

            return pipeline_response


        return ItemPaged(
            get_next, extract_data
        )
    get_enrichment_status_by_metric.metadata = {'url': '/metrics/{metricId}/status/enrichment/anomalyDetection/query'}  # type: ignore
